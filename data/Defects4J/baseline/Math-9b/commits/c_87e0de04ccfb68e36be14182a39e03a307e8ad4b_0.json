{"sha": "87e0de04ccfb68e36be14182a39e03a307e8ad4b", "log": "", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtils.java\n import java.util.Map;\n \n import org.apache.commons.math.fraction.BigFraction;\n-import org.apache.commons.math.util.ArithmeticsUtils;\n+import org.apache.commons.math.util.ArithmeticUtils;\n import org.apache.commons.math.util.FastMath;\n \n /**\n         final int[][] coeff = new int[dp1][dp1];\n         for (int i = 0; i < dp1; i++){\n             for(int j = 0; j <= i; j++){\n-                coeff[i][j] = (int) ArithmeticsUtils.binomialCoefficient(i, j);\n+                coeff[i][j] = (int) ArithmeticUtils.binomialCoefficient(i, j);\n             }\n         }\n \n--- a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.util.ArithmeticsUtils;\n+import org.apache.commons.math.util.ArithmeticUtils;\n import org.apache.commons.math.util.FastMath;\n \n /**\n      * @return PMF for the distribution.\n      */\n     private double probability(int n, int m, int k, int x) {\n-        return FastMath.exp(ArithmeticsUtils.binomialCoefficientLog(m, x) +\n-               ArithmeticsUtils.binomialCoefficientLog(n - m, k - x) -\n-               ArithmeticsUtils.binomialCoefficientLog(n, k));\n+        return FastMath.exp(ArithmeticUtils.binomialCoefficientLog(m, x) +\n+               ArithmeticUtils.binomialCoefficientLog(n - m, k - x) -\n+               ArithmeticUtils.binomialCoefficientLog(n, k));\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n import org.apache.commons.math.exception.NotPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Beta;\n-import org.apache.commons.math.util.ArithmeticsUtils;\n+import org.apache.commons.math.util.ArithmeticUtils;\n import org.apache.commons.math.util.FastMath;\n \n /**\n         if (x < 0) {\n             ret = 0.0;\n         } else {\n-            ret = ArithmeticsUtils.binomialCoefficientDouble(x +\n+            ret = ArithmeticUtils.binomialCoefficientDouble(x +\n                   numberOfSuccesses - 1, numberOfSuccesses - 1) *\n                   FastMath.pow(probabilityOfSuccess, numberOfSuccesses) *\n                   FastMath.pow(1.0 - probabilityOfSuccess, x);\n--- a/src/main/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/Fraction.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.exception.NullArgumentException;\n-import org.apache.commons.math.util.ArithmeticsUtils;\n+import org.apache.commons.math.util.ArithmeticUtils;\n import org.apache.commons.math.util.FastMath;\n \n /**\n             den = -den;\n         }\n         // reduce numerator and denominator by greatest common denominator.\n-        final int d = ArithmeticsUtils.gcd(num, den);\n+        final int d = ArithmeticUtils.gcd(num, den);\n         if (d > 1) {\n             num /= d;\n             den /= d;\n         }\n         // if denominators are randomly distributed, d1 will be 1 about 61%\n         // of the time.\n-        int d1 = ArithmeticsUtils.gcd(denominator, fraction.denominator);\n+        int d1 = ArithmeticUtils.gcd(denominator, fraction.denominator);\n         if (d1==1) {\n             // result is ( (u*v' +/- u'v) / u'v')\n-            int uvp = ArithmeticsUtils.mulAndCheck(numerator, fraction.denominator);\n-            int upv = ArithmeticsUtils.mulAndCheck(fraction.numerator, denominator);\n+            int uvp = ArithmeticUtils.mulAndCheck(numerator, fraction.denominator);\n+            int upv = ArithmeticUtils.mulAndCheck(fraction.numerator, denominator);\n             return new Fraction\n-                (isAdd ? ArithmeticsUtils.addAndCheck(uvp, upv) :\n-                 ArithmeticsUtils.subAndCheck(uvp, upv),\n-                 ArithmeticsUtils.mulAndCheck(denominator, fraction.denominator));\n+                (isAdd ? ArithmeticUtils.addAndCheck(uvp, upv) :\n+                 ArithmeticUtils.subAndCheck(uvp, upv),\n+                 ArithmeticUtils.mulAndCheck(denominator, fraction.denominator));\n         }\n         // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n         // exercise 7.  we're going to use a BigInteger.\n         // but d2 doesn't need extra precision because\n         // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n         int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n-        int d2 = (tmodd1==0)?d1:ArithmeticsUtils.gcd(tmodd1, d1);\n+        int d2 = (tmodd1==0)?d1:ArithmeticUtils.gcd(tmodd1, d1);\n \n         // result is (t/d2) / (u'/d1)(v'/d2)\n         BigInteger w = t.divide(BigInteger.valueOf(d2));\n                                               w);\n         }\n         return new Fraction (w.intValue(),\n-                ArithmeticsUtils.mulAndCheck(denominator/d1,\n+                ArithmeticUtils.mulAndCheck(denominator/d1,\n                         fraction.denominator/d2));\n     }\n \n         }\n         // knuth 4.5.1\n         // make sure we don't overflow unless the result *must* overflow.\n-        int d1 = ArithmeticsUtils.gcd(numerator, fraction.denominator);\n-        int d2 = ArithmeticsUtils.gcd(fraction.numerator, denominator);\n+        int d1 = ArithmeticUtils.gcd(numerator, fraction.denominator);\n+        int d2 = ArithmeticUtils.gcd(fraction.numerator, denominator);\n         return getReducedFraction\n-        (ArithmeticsUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n-                ArithmeticsUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n+        (ArithmeticUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n+                ArithmeticUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n     }\n \n     /**\n             denominator = -denominator;\n         }\n         // simplify fraction.\n-        int gcd = ArithmeticsUtils.gcd(numerator, denominator);\n+        int gcd = ArithmeticUtils.gcd(numerator, denominator);\n         numerator /= gcd;\n         denominator /= gcd;\n         return new Fraction(numerator, denominator);\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n-import org.apache.commons.math.util.ArithmeticsUtils;\n+import org.apache.commons.math.util.ArithmeticUtils;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.ResizableDoubleArray;\n \n         final ResizableDoubleArray ra = new ResizableDoubleArray(20);\n \n         while (qi < 1) {\n-            qi += FastMath.pow(LN2, i) / ArithmeticsUtils.factorial(i);\n+            qi += FastMath.pow(LN2, i) / ArithmeticUtils.factorial(i);\n             ra.addElement(qi);\n             ++i;\n         }\n             final double lambda = FastMath.floor(mean);\n             final double lambdaFractional = mean - lambda;\n             final double logLambda = FastMath.log(lambda);\n-            final double logLambdaFactorial = ArithmeticsUtils.factorialLog((int) lambda);\n+            final double logLambdaFactorial = ArithmeticUtils.factorialLog((int) lambda);\n             final long y2 = lambdaFractional < Double.MIN_VALUE ? 0 : nextPoisson(lambdaFractional);\n             final double delta = FastMath.sqrt(lambda * FastMath.log(32 * lambda / FastMath.PI + 1));\n             final double halfDelta = delta / 2;\n                 if (v > qr) {\n                     continue;\n                 }\n-                if (v < y * logLambda - ArithmeticsUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) {\n+                if (v < y * logLambda - ArithmeticUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) {\n                     y = lambda + y;\n                     break;\n                 }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/ArithmeticUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.exception.NotPositiveException;\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.util.Localizable;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+/**\n+ * Some useful, arithmetics related, additions to the built-in functions in\n+ * {@link Math}.\n+ *\n+ * @version $Id$\n+ */\n+public final class ArithmeticUtils {\n+\n+    /** All long-representable factorials */\n+    static final long[] FACTORIALS = new long[] {\n+                       1l,                  1l,                   2l,\n+                       6l,                 24l,                 120l,\n+                     720l,               5040l,               40320l,\n+                  362880l,            3628800l,            39916800l,\n+               479001600l,         6227020800l,         87178291200l,\n+           1307674368000l,     20922789888000l,     355687428096000l,\n+        6402373705728000l, 121645100408832000l, 2432902008176640000l };\n+\n+    /** Private constructor. */\n+    private ArithmeticUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Add two integers, checking for overflow.\n+     *\n+     * @param x an addend\n+     * @param y an addend\n+     * @return the sum {@code x+y}\n+     * @throws MathArithmeticException if the result can not be represented\n+     * as an {@code int}.\n+     * @since 1.1\n+     */\n+    public static int addAndCheck(int x, int y) {\n+        long s = (long)x + (long)y;\n+        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n+            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, x, y);\n+        }\n+        return (int)s;\n+    }\n+\n+    /**\n+     * Add two long integers, checking for overflow.\n+     *\n+     * @param a an addend\n+     * @param b an addend\n+     * @return the sum {@code a+b}\n+     * @throws MathArithmeticException if the result can not be represented as an\n+     *         long\n+     * @since 1.2\n+     */\n+    public static long addAndCheck(long a, long b) {\n+        return ArithmeticUtils.addAndCheck(a, b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n+    }\n+\n+    /**\n+     * Returns an exact representation of the <a\n+     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n+     * Coefficient</a>, \"{@code n choose k}\", the number of\n+     * {@code k}-element subsets that can be selected from an\n+     * {@code n}-element set.\n+     * <p>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n+     * <li> {@code 0 <= k <= n } (otherwise\n+     * {@code IllegalArgumentException} is thrown)</li>\n+     * <li> The result is small enough to fit into a {@code long}. The\n+     * largest value of {@code n} for which all coefficients are\n+     * {@code  < Long.MAX_VALUE} is 66. If the computed value exceeds\n+     * {@code Long.MAX_VALUE} an {@code ArithMeticException} is\n+     * thrown.</li>\n+     * </ul></p>\n+     *\n+     * @param n the size of the set\n+     * @param k the size of the subsets to be counted\n+     * @return {@code n choose k}\n+     * @throws MathIllegalArgumentException if preconditions are not met.\n+     * @throws MathArithmeticException if the result is too large to be\n+     * represented by a long integer.\n+     */\n+    public static long binomialCoefficient(final int n, final int k) {\n+        ArithmeticUtils.checkBinomial(n, k);\n+        if ((n == k) || (k == 0)) {\n+            return 1;\n+        }\n+        if ((k == 1) || (k == n - 1)) {\n+            return n;\n+        }\n+        // Use symmetry for large k\n+        if (k > n / 2) {\n+            return binomialCoefficient(n, n - k);\n+        }\n+\n+        // We use the formula\n+        // (n choose k) = n! / (n-k)! / k!\n+        // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n+        // which could be written\n+        // (n choose k) == (n-1 choose k-1) * n / k\n+        long result = 1;\n+        if (n <= 61) {\n+            // For n <= 61, the naive implementation cannot overflow.\n+            int i = n - k + 1;\n+            for (int j = 1; j <= k; j++) {\n+                result = result * i / j;\n+                i++;\n+            }\n+        } else if (n <= 66) {\n+            // For n > 61 but n <= 66, the result cannot overflow,\n+            // but we must take care not to overflow intermediate values.\n+            int i = n - k + 1;\n+            for (int j = 1; j <= k; j++) {\n+                // We know that (result * i) is divisible by j,\n+                // but (result * i) may overflow, so we split j:\n+                // Filter out the gcd, d, so j/d and i/d are integer.\n+                // result is divisible by (j/d) because (j/d)\n+                // is relative prime to (i/d) and is a divisor of\n+                // result * (i/d).\n+                final long d = gcd(i, j);\n+                result = (result / (j / d)) * (i / d);\n+                i++;\n+            }\n+        } else {\n+            // For n > 66, a result overflow might occur, so we check\n+            // the multiplication, taking care to not overflow\n+            // unnecessary.\n+            int i = n - k + 1;\n+            for (int j = 1; j <= k; j++) {\n+                final long d = gcd(i, j);\n+                result = mulAndCheck(result / (j / d), i / d);\n+                i++;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a {@code double} representation of the <a\n+     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n+     * Coefficient</a>, \"{@code n choose k}\", the number of\n+     * {@code k}-element subsets that can be selected from an\n+     * {@code n}-element set.\n+     * <p>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n+     * <li> {@code 0 <= k <= n } (otherwise\n+     * {@code IllegalArgumentException} is thrown)</li>\n+     * <li> The result is small enough to fit into a {@code double}. The\n+     * largest value of {@code n} for which all coefficients are <\n+     * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,\n+     * Double.POSITIVE_INFINITY is returned</li>\n+     * </ul></p>\n+     *\n+     * @param n the size of the set\n+     * @param k the size of the subsets to be counted\n+     * @return {@code n choose k}\n+     * @throws IllegalArgumentException if preconditions are not met.\n+     */\n+    public static double binomialCoefficientDouble(final int n, final int k) {\n+        ArithmeticUtils.checkBinomial(n, k);\n+        if ((n == k) || (k == 0)) {\n+            return 1d;\n+        }\n+        if ((k == 1) || (k == n - 1)) {\n+            return n;\n+        }\n+        if (k > n/2) {\n+            return binomialCoefficientDouble(n, n - k);\n+        }\n+        if (n < 67) {\n+            return binomialCoefficient(n,k);\n+        }\n+\n+        double result = 1d;\n+        for (int i = 1; i <= k; i++) {\n+             result *= (double)(n - k + i) / (double)i;\n+        }\n+\n+        return FastMath.floor(result + 0.5);\n+    }\n+\n+    /**\n+     * Returns the natural {@code log} of the <a\n+     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n+     * Coefficient</a>, \"{@code n choose k}\", the number of\n+     * {@code k}-element subsets that can be selected from an\n+     * {@code n}-element set.\n+     * <p>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n+     * <li> {@code 0 <= k <= n } (otherwise\n+     * {@code IllegalArgumentException} is thrown)</li>\n+     * </ul></p>\n+     *\n+     * @param n the size of the set\n+     * @param k the size of the subsets to be counted\n+     * @return {@code n choose k}\n+     * @throws IllegalArgumentException if preconditions are not met.\n+     */\n+    public static double binomialCoefficientLog(final int n, final int k) {\n+        ArithmeticUtils.checkBinomial(n, k);\n+        if ((n == k) || (k == 0)) {\n+            return 0;\n+        }\n+        if ((k == 1) || (k == n - 1)) {\n+            return FastMath.log(n);\n+        }\n+\n+        /*\n+         * For values small enough to do exact integer computation,\n+         * return the log of the exact value\n+         */\n+        if (n < 67) {\n+            return FastMath.log(binomialCoefficient(n,k));\n+        }\n+\n+        /*\n+         * Return the log of binomialCoefficientDouble for values that will not\n+         * overflow binomialCoefficientDouble\n+         */\n+        if (n < 1030) {\n+            return FastMath.log(binomialCoefficientDouble(n, k));\n+        }\n+\n+        if (k > n / 2) {\n+            return binomialCoefficientLog(n, n - k);\n+        }\n+\n+        /*\n+         * Sum logs for values that could overflow\n+         */\n+        double logSum = 0;\n+\n+        // n!/(n-k)!\n+        for (int i = n - k + 1; i <= n; i++) {\n+            logSum += FastMath.log(i);\n+        }\n+\n+        // divide by k!\n+        for (int i = 2; i <= k; i++) {\n+            logSum -= FastMath.log(i);\n+        }\n+\n+        return logSum;\n+    }\n+\n+    /**\n+     * Returns n!. Shorthand for {@code n} <a\n+     * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n+     * product of the numbers {@code 1,...,n}.\n+     * <p>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n+     * <li> {@code n >= 0} (otherwise\n+     * {@code IllegalArgumentException} is thrown)</li>\n+     * <li> The result is small enough to fit into a {@code long}. The\n+     * largest value of {@code n} for which {@code n!} <\n+     * Long.MAX_VALUE} is 20. If the computed value exceeds {@code Long.MAX_VALUE}\n+     * an {@code ArithMeticException } is thrown.</li>\n+     * </ul>\n+     * </p>\n+     *\n+     * @param n argument\n+     * @return {@code n!}\n+     * @throws MathArithmeticException if the result is too large to be represented\n+     * by a {@code long}.\n+     * @throws NotPositiveException if {@code n < 0}.\n+     * @throws MathArithmeticException if {@code n > 20}: The factorial value is too\n+     * large to fit in a {@code long}.\n+     */\n+    public static long factorial(final int n) {\n+        if (n < 0) {\n+            throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n+                                           n);\n+        }\n+        if (n > 20) {\n+            throw new MathArithmeticException();\n+        }\n+        return FACTORIALS[n];\n+    }\n+\n+    /**\n+     * Compute n!, the<a href=\"http://mathworld.wolfram.com/Factorial.html\">\n+     * factorial</a> of {@code n} (the product of the numbers 1 to n), as a\n+     * {@code double}.\n+     * The result should be small enough to fit into a {@code double}: The\n+     * largest {@code n} for which {@code n! < Double.MAX_VALUE} is 170.\n+     * If the computed value exceeds {@code Double.MAX_VALUE},\n+     * {@code Double.POSITIVE_INFINITY} is returned.\n+     *\n+     * @param n Argument.\n+     * @return {@code n!}\n+     * @throws NotPositiveException if {@code n < 0}.\n+     */\n+    public static double factorialDouble(final int n) {\n+        if (n < 0) {\n+            throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n+                                           n);\n+        }\n+        if (n < 21) {\n+            return factorial(n);\n+        }\n+        return FastMath.floor(FastMath.exp(ArithmeticUtils.factorialLog(n)) + 0.5);\n+    }\n+\n+    /**\n+     * Compute the natural logarithm of the factorial of {@code n}.\n+     *\n+     * @param n Argument.\n+     * @return {@code n!}\n+     * @throws NotPositiveException if {@code n < 0}.\n+     */\n+    public static double factorialLog(final int n) {\n+        if (n < 0) {\n+            throw new NotPositiveException(LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER,\n+                                           n);\n+        }\n+        if (n < 21) {\n+            return FastMath.log(factorial(n));\n+        }\n+        double logSum = 0;\n+        for (int i = 2; i <= n; i++) {\n+            logSum += FastMath.log(i);\n+        }\n+        return logSum;\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the greatest common divisor of the absolute value of two numbers,\n+     * using the \"binary gcd\" method which avoids division and modulo\n+     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n+     * Stein (1961).\n+     * </p>\n+     * Special cases:\n+     * <ul>\n+     * <li>The invocations\n+     * {@code gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)},\n+     * {@code gcd(Integer.MIN_VALUE, 0)} and\n+     * {@code gcd(0, Integer.MIN_VALUE)} throw an\n+     * {@code ArithmeticException}, because the result would be 2^31, which\n+     * is too large for an int value.</li>\n+     * <li>The result of {@code gcd(x, x)}, {@code gcd(0, x)} and\n+     * {@code gcd(x, 0)} is the absolute value of {@code x}, except\n+     * for the special cases above.\n+     * <li>The invocation {@code gcd(0, 0)} is the only one which returns\n+     * {@code 0}.</li>\n+     * </ul>\n+     *\n+     * @param p Number.\n+     * @param q Number.\n+     * @return the greatest common divisor, never negative.\n+     * @throws MathArithmeticException if the result cannot be represented as\n+     * a non-negative {@code int} value.\n+     * @since 1.1\n+     */\n+    public static int gcd(final int p, final int q) {\n+        int u = p;\n+        int v = q;\n+        if ((u == 0) || (v == 0)) {\n+            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n+                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n+                                                  p, q);\n+            }\n+            return FastMath.abs(u) + FastMath.abs(v);\n+        }\n+        // keep u and v negative, as negative integers range down to\n+        // -2^31, while positive numbers can only be as large as 2^31-1\n+        // (i.e. we can't necessarily negate a negative number without\n+        // overflow)\n+        /* assert u!=0 && v!=0; */\n+        if (u > 0) {\n+            u = -u;\n+        } // make u negative\n+        if (v > 0) {\n+            v = -v;\n+        } // make v negative\n+        // B1. [Find power of 2]\n+        int k = 0;\n+        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n+                                                            // both even...\n+            u /= 2;\n+            v /= 2;\n+            k++; // cast out twos.\n+        }\n+        if (k == 31) {\n+            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_32_BITS,\n+                                              p, q);\n+        }\n+        // B2. Initialize: u and v have been divided by 2^k and at least\n+        // one is odd.\n+        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n+        // t negative: u was odd, v may be even (t replaces v)\n+        // t positive: u was even, v is odd (t replaces u)\n+        do {\n+            /* assert u<0 && v<0; */\n+            // B4/B3: cast out twos from t.\n+            while ((t & 1) == 0) { // while t is even..\n+                t /= 2; // cast out twos\n+            }\n+            // B5 [reset max(u,v)]\n+            if (t > 0) {\n+                u = -t;\n+            } else {\n+                v = t;\n+            }\n+            // B6/B3. at this point both u and v should be odd.\n+            t = (v - u) / 2;\n+            // |u| larger: t positive (replace u)\n+            // |v| larger: t negative (replace v)\n+        } while (t != 0);\n+        return -u * (1 << k); // gcd is u*2^k\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the greatest common divisor of the absolute value of two numbers,\n+     * using the \"binary gcd\" method which avoids division and modulo\n+     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n+     * Stein (1961).\n+     * </p>\n+     * Special cases:\n+     * <ul>\n+     * <li>The invocations\n+     * {@code gcd(Long.MIN_VALUE, Long.MIN_VALUE)},\n+     * {@code gcd(Long.MIN_VALUE, 0L)} and\n+     * {@code gcd(0L, Long.MIN_VALUE)} throw an\n+     * {@code ArithmeticException}, because the result would be 2^63, which\n+     * is too large for a long value.</li>\n+     * <li>The result of {@code gcd(x, x)}, {@code gcd(0L, x)} and\n+     * {@code gcd(x, 0L)} is the absolute value of {@code x}, except\n+     * for the special cases above.\n+     * <li>The invocation {@code gcd(0L, 0L)} is the only one which returns\n+     * {@code 0L}.</li>\n+     * </ul>\n+     *\n+     * @param p Number.\n+     * @param q Number.\n+     * @return the greatest common divisor, never negative.\n+     * @throws MathArithmeticException if the result cannot be represented as\n+     * a non-negative {@code long} value.\n+     * @since 2.1\n+     */\n+    public static long gcd(final long p, final long q) {\n+        long u = p;\n+        long v = q;\n+        if ((u == 0) || (v == 0)) {\n+            if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)){\n+                throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS,\n+                                                  p, q);\n+            }\n+            return FastMath.abs(u) + FastMath.abs(v);\n+        }\n+        // keep u and v negative, as negative integers range down to\n+        // -2^63, while positive numbers can only be as large as 2^63-1\n+        // (i.e. we can't necessarily negate a negative number without\n+        // overflow)\n+        /* assert u!=0 && v!=0; */\n+        if (u > 0) {\n+            u = -u;\n+        } // make u negative\n+        if (v > 0) {\n+            v = -v;\n+        } // make v negative\n+        // B1. [Find power of 2]\n+        int k = 0;\n+        while ((u & 1) == 0 && (v & 1) == 0 && k < 63) { // while u and v are\n+                                                            // both even...\n+            u /= 2;\n+            v /= 2;\n+            k++; // cast out twos.\n+        }\n+        if (k == 63) {\n+            throw new MathArithmeticException(LocalizedFormats.GCD_OVERFLOW_64_BITS,\n+                                              p, q);\n+        }\n+        // B2. Initialize: u and v have been divided by 2^k and at least\n+        // one is odd.\n+        long t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n+        // t negative: u was odd, v may be even (t replaces v)\n+        // t positive: u was even, v is odd (t replaces u)\n+        do {\n+            /* assert u<0 && v<0; */\n+            // B4/B3: cast out twos from t.\n+            while ((t & 1) == 0) { // while t is even..\n+                t /= 2; // cast out twos\n+            }\n+            // B5 [reset max(u,v)]\n+            if (t > 0) {\n+                u = -t;\n+            } else {\n+                v = t;\n+            }\n+            // B6/B3. at this point both u and v should be odd.\n+            t = (v - u) / 2;\n+            // |u| larger: t positive (replace u)\n+            // |v| larger: t negative (replace v)\n+        } while (t != 0);\n+        return -u * (1L << k); // gcd is u*2^k\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns the least common multiple of the absolute value of two numbers,\n+     * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.\n+     * </p>\n+     * Special cases:\n+     * <ul>\n+     * <li>The invocations {@code lcm(Integer.MIN_VALUE, n)} and\n+     * {@code lcm(n, Integer.MIN_VALUE)}, where {@code abs(n)} is a\n+     * power of 2, throw an {@code ArithmeticException}, because the result\n+     * would be 2^31, which is too large for an int value.</li>\n+     * <li>The result of {@code lcm(0, x)} and {@code lcm(x, 0)} is\n+     * {@code 0} for any {@code x}.\n+     * </ul>\n+     *\n+     * @param a Number.\n+     * @param b Number.\n+     * @return the least common multiple, never negative.\n+     * @throws MathArithmeticException if the result cannot be represented as\n+     * a non-negative {@code int} value.\n+     * @since 1.1\n+     */\n+    public static int lcm(int a, int b) {\n+        if (a == 0 || b == 0){\n+            return 0;\n+        }\n+        int lcm = FastMath.abs(ArithmeticUtils.mulAndCheck(a / gcd(a, b), b));\n+        if (lcm == Integer.MIN_VALUE) {\n+            throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_32_BITS,\n+                                              a, b);\n+        }\n+        return lcm;\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns the least common multiple of the absolute value of two numbers,\n+     * using the formula {@code lcm(a,b) = (a / gcd(a,b)) * b}.\n+     * </p>\n+     * Special cases:\n+     * <ul>\n+     * <li>The invocations {@code lcm(Long.MIN_VALUE, n)} and\n+     * {@code lcm(n, Long.MIN_VALUE)}, where {@code abs(n)} is a\n+     * power of 2, throw an {@code ArithmeticException}, because the result\n+     * would be 2^63, which is too large for an int value.</li>\n+     * <li>The result of {@code lcm(0L, x)} and {@code lcm(x, 0L)} is\n+     * {@code 0L} for any {@code x}.\n+     * </ul>\n+     *\n+     * @param a Number.\n+     * @param b Number.\n+     * @return the least common multiple, never negative.\n+     * @throws MathArithmeticException if the result cannot be represented\n+     * as a non-negative {@code long} value.\n+     * @since 2.1\n+     */\n+    public static long lcm(long a, long b) {\n+        if (a == 0 || b == 0){\n+            return 0;\n+        }\n+        long lcm = FastMath.abs(ArithmeticUtils.mulAndCheck(a / gcd(a, b), b));\n+        if (lcm == Long.MIN_VALUE){\n+            throw new MathArithmeticException(LocalizedFormats.LCM_OVERFLOW_64_BITS,\n+                                              a, b);\n+        }\n+        return lcm;\n+    }\n+\n+    /**\n+     * Multiply two integers, checking for overflow.\n+     *\n+     * @param x Factor.\n+     * @param y Factor.\n+     * @return the product {@code x * y}.\n+     * @throws MathArithmeticException if the result can not be\n+     * represented as an {@code int}.\n+     * @since 1.1\n+     */\n+    public static int mulAndCheck(int x, int y) {\n+        long m = ((long)x) * ((long)y);\n+        if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n+            throw new MathArithmeticException();\n+        }\n+        return (int)m;\n+    }\n+\n+    /**\n+     * Multiply two long integers, checking for overflow.\n+     *\n+     * @param a Factor.\n+     * @param b Factor.\n+     * @return the product {@code a * b}.\n+     * @throws MathArithmeticException if the result can not be represented\n+     * as a {@code long}.\n+     * @since 1.2\n+     */\n+    public static long mulAndCheck(long a, long b) {\n+        long ret;\n+        if (a > b) {\n+            // use symmetry to reduce boundary cases\n+            ret = mulAndCheck(b, a);\n+        } else {\n+            if (a < 0) {\n+                if (b < 0) {\n+                    // check for positive overflow with negative a, negative b\n+                    if (a >= Long.MAX_VALUE / b) {\n+                        ret = a * b;\n+                    } else {\n+                        throw new MathArithmeticException();\n+                    }\n+                } else if (b > 0) {\n+                    // check for negative overflow with negative a, positive b\n+                    if (Long.MIN_VALUE / b <= a) {\n+                        ret = a * b;\n+                    } else {\n+                        throw new MathArithmeticException();\n+\n+                    }\n+                } else {\n+                    // assert b == 0\n+                    ret = 0;\n+                }\n+            } else if (a > 0) {\n+                // assert a > 0\n+                // assert b > 0\n+\n+                // check for positive overflow with positive a, positive b\n+                if (a <= Long.MAX_VALUE / b) {\n+                    ret = a * b;\n+                } else {\n+                    throw new MathArithmeticException();\n+                }\n+            } else {\n+                // assert a == 0\n+                ret = 0;\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Subtract two integers, checking for overflow.\n+     *\n+     * @param x Minuend.\n+     * @param y Subtrahend.\n+     * @return the difference {@code x - y}.\n+     * @throws MathArithmeticException if the result can not be represented\n+     * as an {@code int}.\n+     * @since 1.1\n+     */\n+    public static int subAndCheck(int x, int y) {\n+        long s = (long)x - (long)y;\n+        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n+            throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_SUBTRACTION, x, y);\n+        }\n+        return (int)s;\n+    }\n+\n+    /**\n+     * Subtract two long integers, checking for overflow.\n+     *\n+     * @param a Value.\n+     * @param b Value.\n+     * @return the difference {@code a - b}.\n+     * @throws MathArithmeticException if the result can not be represented as a\n+     * {@code long}.\n+     * @since 1.2\n+     */\n+    public static long subAndCheck(long a, long b) {\n+        long ret;\n+        if (b == Long.MIN_VALUE) {\n+            if (a < 0) {\n+                ret = a - b;\n+            } else {\n+                throw new MathArithmeticException(LocalizedFormats.OVERFLOW_IN_ADDITION, a, -b);\n+            }\n+        } else {\n+            // use additive inverse\n+            ret = addAndCheck(a, -b, LocalizedFormats.OVERFLOW_IN_ADDITION);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Add two long integers, checking for overflow.\n+     *\n+     * @param a Addend.\n+     * @param b Addend.\n+     * @param pattern Pattern to use for any thrown exception.\n+     * @return the sum {@code a + b}.\n+     * @throws MathArithmeticException if the result cannot be represented\n+     * as a {@code long}.\n+     * @since 1.2\n+     */\n+     private static long addAndCheck(long a, long b, Localizable pattern) {\n+        long ret;\n+        if (a > b) {\n+            // use symmetry to reduce boundary cases\n+            ret = addAndCheck(b, a, pattern);\n+        } else {\n+            // assert a <= b\n+\n+            if (a < 0) {\n+                if (b < 0) {\n+                    // check for negative overflow\n+                    if (Long.MIN_VALUE - b <= a) {\n+                        ret = a + b;\n+                    } else {\n+                        throw new MathArithmeticException(pattern, a, b);\n+                    }\n+                } else {\n+                    // opposite sign addition is always safe\n+                    ret = a + b;\n+                }\n+            } else {\n+                // assert a >= 0\n+                // assert b >= 0\n+\n+                // check for positive overflow\n+                if (a <= Long.MAX_VALUE - b) {\n+                    ret = a + b;\n+                } else {\n+                    throw new MathArithmeticException(pattern, a, b);\n+                }\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Check binomial preconditions.\n+     *\n+     * @param n Size of the set.\n+     * @param k Size of the subsets to be counted.\n+     * @throws NotPositiveException if {@code n < 0}.\n+     * @throws NumberIsTooLargeException if {@code k > n}.\n+     */\n+    private static void checkBinomial(final int n, final int k) {\n+        if (n < k) {\n+            throw new NumberIsTooLargeException(LocalizedFormats.BINOMIAL_INVALID_PARAMETERS_ORDER,\n+                                                k, n, true);\n+        }\n+        if (n < 0) {\n+            throw new NotPositiveException(LocalizedFormats.BINOMIAL_NEGATIVE_PARAMETER, n);\n+        }\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtilsTest.java\n \n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.integration.LegendreGaussIntegrator;\n-import org.apache.commons.math.util.ArithmeticsUtils;\n+import org.apache.commons.math.util.ArithmeticUtils;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.Precision;\n import org.junit.Assert;\n             for (int w = 0; w < 10; ++w) {\n                 for (int i = 0; i < 10; ++i) {\n                     PolynomialFunction jacobi = PolynomialsUtils.createJacobiPolynomial(i, v, w);\n-                    double binomial = ArithmeticsUtils.binomialCoefficient(v + i, i);\n+                    double binomial = ArithmeticUtils.binomialCoefficient(v + i, i);\n                     Assert.assertTrue(Precision.equals(binomial, jacobi.value(1.0), 1));\n                 }\n             }\n--- a/src/test/java/org/apache/commons/math/linear/InverseHilbertMatrix.java\n+++ b/src/test/java/org/apache/commons/math/linear/InverseHilbertMatrix.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.exception.DimensionMismatchException;\n-import org.apache.commons.math.util.ArithmeticsUtils;\n+import org.apache.commons.math.util.ArithmeticUtils;\n \n /**\n  * This class implements inverses of Hilbert Matrices as\n      */\n     public long getEntry(final int i, final int j) {\n         long val = i + j + 1;\n-        long aux = ArithmeticsUtils.binomialCoefficient(n + i, n - j - 1);\n-        val = ArithmeticsUtils.mulAndCheck(val, aux);\n-        aux = ArithmeticsUtils.binomialCoefficient(n + j, n - i - 1);\n-        val = ArithmeticsUtils.mulAndCheck(val, aux);\n-        aux = ArithmeticsUtils.binomialCoefficient(i + j, i);\n-        val = ArithmeticsUtils.mulAndCheck(val, aux);\n-        val = ArithmeticsUtils.mulAndCheck(val, aux);\n+        long aux = ArithmeticUtils.binomialCoefficient(n + i, n - j - 1);\n+        val = ArithmeticUtils.mulAndCheck(val, aux);\n+        aux = ArithmeticUtils.binomialCoefficient(n + j, n - i - 1);\n+        val = ArithmeticUtils.mulAndCheck(val, aux);\n+        aux = ArithmeticUtils.binomialCoefficient(i + j, i);\n+        val = ArithmeticUtils.mulAndCheck(val, aux);\n+        val = ArithmeticUtils.mulAndCheck(val, aux);\n         return ((i + j) & 1) == 0 ? val : -val;\n     }\n \n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/util/ArithmeticUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.random.RandomDataImpl;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test cases for the {@link ArithmeticUtils} class.\n+ *\n+ * @version $Id$\n+ */\n+public class ArithmeticUtilsTest {\n+\n+    /** cached binomial coefficients */\n+    private static final List<Map<Integer, Long>> binomialCache = new ArrayList<Map<Integer, Long>>();\n+\n+    /** Verify that b(0,0) = 1 */\n+    @Test\n+    public void test0Choose0() {\n+        Assert.assertEquals(ArithmeticUtils.binomialCoefficientDouble(0, 0), 1d, 0);\n+        Assert.assertEquals(ArithmeticUtils.binomialCoefficientLog(0, 0), 0d, 0);\n+        Assert.assertEquals(ArithmeticUtils.binomialCoefficient(0, 0), 1);\n+    }\n+\n+    @Test\n+    public void testAddAndCheck() {\n+        int big = Integer.MAX_VALUE;\n+        int bigNeg = Integer.MIN_VALUE;\n+        Assert.assertEquals(big, ArithmeticUtils.addAndCheck(big, 0));\n+        try {\n+            ArithmeticUtils.addAndCheck(big, 1);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+        }\n+        try {\n+            ArithmeticUtils.addAndCheck(bigNeg, -1);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+        }\n+    }\n+\n+    @Test\n+    public void testAddAndCheckLong() {\n+        long max = Long.MAX_VALUE;\n+        long min = Long.MIN_VALUE;\n+        Assert.assertEquals(max, ArithmeticUtils.addAndCheck(max, 0L));\n+        Assert.assertEquals(min, ArithmeticUtils.addAndCheck(min, 0L));\n+        Assert.assertEquals(max, ArithmeticUtils.addAndCheck(0L, max));\n+        Assert.assertEquals(min, ArithmeticUtils.addAndCheck(0L, min));\n+        Assert.assertEquals(1, ArithmeticUtils.addAndCheck(-1L, 2L));\n+        Assert.assertEquals(1, ArithmeticUtils.addAndCheck(2L, -1L));\n+        Assert.assertEquals(-3, ArithmeticUtils.addAndCheck(-2L, -1L));\n+        Assert.assertEquals(min, ArithmeticUtils.addAndCheck(min + 1, -1L));\n+        testAddAndCheckLongFailure(max, 1L);\n+        testAddAndCheckLongFailure(min, -1L);\n+        testAddAndCheckLongFailure(1L, max);\n+        testAddAndCheckLongFailure(-1L, min);\n+    }\n+\n+\n+    @Test\n+    public void testBinomialCoefficient() {\n+        long[] bcoef5 = {\n+            1,\n+            5,\n+            10,\n+            10,\n+            5,\n+            1 };\n+        long[] bcoef6 = {\n+            1,\n+            6,\n+            15,\n+            20,\n+            15,\n+            6,\n+            1 };\n+        for (int i = 0; i < 6; i++) {\n+            Assert.assertEquals(\"5 choose \" + i, bcoef5[i], ArithmeticUtils.binomialCoefficient(5, i));\n+        }\n+        for (int i = 0; i < 7; i++) {\n+            Assert.assertEquals(\"6 choose \" + i, bcoef6[i], ArithmeticUtils.binomialCoefficient(6, i));\n+        }\n+\n+        for (int n = 1; n < 10; n++) {\n+            for (int k = 0; k <= n; k++) {\n+                Assert.assertEquals(n + \" choose \" + k, binomialCoefficient(n, k), ArithmeticUtils.binomialCoefficient(n, k));\n+                Assert.assertEquals(n + \" choose \" + k, binomialCoefficient(n, k), ArithmeticUtils.binomialCoefficientDouble(n, k), Double.MIN_VALUE);\n+                Assert.assertEquals(n + \" choose \" + k, FastMath.log(binomialCoefficient(n, k)), ArithmeticUtils.binomialCoefficientLog(n, k), 10E-12);\n+            }\n+        }\n+\n+        int[] n = { 34, 66, 100, 1500, 1500 };\n+        int[] k = { 17, 33, 10, 1500 - 4, 4 };\n+        for (int i = 0; i < n.length; i++) {\n+            long expected = binomialCoefficient(n[i], k[i]);\n+            Assert.assertEquals(n[i] + \" choose \" + k[i], expected,\n+                ArithmeticUtils.binomialCoefficient(n[i], k[i]));\n+            Assert.assertEquals(n[i] + \" choose \" + k[i], expected,\n+                ArithmeticUtils.binomialCoefficientDouble(n[i], k[i]), 0.0);\n+            Assert.assertEquals(\"log(\" + n[i] + \" choose \" + k[i] + \")\", FastMath.log(expected),\n+                ArithmeticUtils.binomialCoefficientLog(n[i], k[i]), 0.0);\n+        }\n+    }\n+\n+    @Test\n+    public void testBinomialCoefficientFail() {\n+        try {\n+            ArithmeticUtils.binomialCoefficient(4, 5);\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+\n+        try {\n+            ArithmeticUtils.binomialCoefficientDouble(4, 5);\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+\n+        try {\n+            ArithmeticUtils.binomialCoefficientLog(4, 5);\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+\n+        try {\n+            ArithmeticUtils.binomialCoefficient(-1, -2);\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            ArithmeticUtils.binomialCoefficientDouble(-1, -2);\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            ArithmeticUtils.binomialCoefficientLog(-1, -2);\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+\n+        try {\n+            ArithmeticUtils.binomialCoefficient(67, 30);\n+            Assert.fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+            // ignored\n+        }\n+        try {\n+            ArithmeticUtils.binomialCoefficient(67, 34);\n+            Assert.fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+            // ignored\n+        }\n+        double x = ArithmeticUtils.binomialCoefficientDouble(1030, 515);\n+        Assert.assertTrue(\"expecting infinite binomial coefficient\", Double\n+            .isInfinite(x));\n+    }\n+\n+    /**\n+     * Tests correctness for large n and sharpness of upper bound in API doc\n+     * JIRA: MATH-241\n+     */\n+    @Test\n+    public void testBinomialCoefficientLarge() throws Exception {\n+        // This tests all legal and illegal values for n <= 200.\n+        for (int n = 0; n <= 200; n++) {\n+            for (int k = 0; k <= n; k++) {\n+                long ourResult = -1;\n+                long exactResult = -1;\n+                boolean shouldThrow = false;\n+                boolean didThrow = false;\n+                try {\n+                    ourResult = ArithmeticUtils.binomialCoefficient(n, k);\n+                } catch (MathArithmeticException ex) {\n+                    didThrow = true;\n+                }\n+                try {\n+                    exactResult = binomialCoefficient(n, k);\n+                } catch (MathArithmeticException ex) {\n+                    shouldThrow = true;\n+                }\n+                Assert.assertEquals(n + \" choose \" + k, exactResult, ourResult);\n+                Assert.assertEquals(n + \" choose \" + k, shouldThrow, didThrow);\n+                Assert.assertTrue(n + \" choose \" + k, (n > 66 || !didThrow));\n+\n+                if (!shouldThrow && exactResult > 1) {\n+                    Assert.assertEquals(n + \" choose \" + k, 1.,\n+                        ArithmeticUtils.binomialCoefficientDouble(n, k) / exactResult, 1e-10);\n+                    Assert.assertEquals(n + \" choose \" + k, 1,\n+                        ArithmeticUtils.binomialCoefficientLog(n, k) / FastMath.log(exactResult), 1e-10);\n+                }\n+            }\n+        }\n+\n+        long ourResult = ArithmeticUtils.binomialCoefficient(300, 3);\n+        long exactResult = binomialCoefficient(300, 3);\n+        Assert.assertEquals(exactResult, ourResult);\n+\n+        ourResult = ArithmeticUtils.binomialCoefficient(700, 697);\n+        exactResult = binomialCoefficient(700, 697);\n+        Assert.assertEquals(exactResult, ourResult);\n+\n+        // This one should throw\n+        try {\n+            ArithmeticUtils.binomialCoefficient(700, 300);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+            // Expected\n+        }\n+\n+        int n = 10000;\n+        ourResult = ArithmeticUtils.binomialCoefficient(n, 3);\n+        exactResult = binomialCoefficient(n, 3);\n+        Assert.assertEquals(exactResult, ourResult);\n+        Assert.assertEquals(1, ArithmeticUtils.binomialCoefficientDouble(n, 3) / exactResult, 1e-10);\n+        Assert.assertEquals(1, ArithmeticUtils.binomialCoefficientLog(n, 3) / FastMath.log(exactResult), 1e-10);\n+\n+    }\n+\n+    @Test\n+    public void testFactorial() {\n+        for (int i = 1; i < 21; i++) {\n+            Assert.assertEquals(i + \"! \", factorial(i), ArithmeticUtils.factorial(i));\n+            Assert.assertEquals(i + \"! \", factorial(i), ArithmeticUtils.factorialDouble(i), Double.MIN_VALUE);\n+            Assert.assertEquals(i + \"! \", FastMath.log(factorial(i)), ArithmeticUtils.factorialLog(i), 10E-12);\n+        }\n+\n+        Assert.assertEquals(\"0\", 1, ArithmeticUtils.factorial(0));\n+        Assert.assertEquals(\"0\", 1.0d, ArithmeticUtils.factorialDouble(0), 1E-14);\n+        Assert.assertEquals(\"0\", 0.0d, ArithmeticUtils.factorialLog(0), 1E-14);\n+    }\n+\n+    @Test\n+    public void testFactorialFail() {\n+        try {\n+            ArithmeticUtils.factorial(-1);\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            ArithmeticUtils.factorialDouble(-1);\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            ArithmeticUtils.factorialLog(-1);\n+            Assert.fail(\"expecting MathIllegalArgumentException\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            ArithmeticUtils.factorial(21);\n+            Assert.fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+            // ignored\n+        }\n+        Assert.assertTrue(\"expecting infinite factorial value\", Double.isInfinite(ArithmeticUtils.factorialDouble(171)));\n+    }\n+\n+    @Test\n+    public void testGcd() {\n+        int a = 30;\n+        int b = 50;\n+        int c = 77;\n+\n+        Assert.assertEquals(0, ArithmeticUtils.gcd(0, 0));\n+\n+        Assert.assertEquals(b, ArithmeticUtils.gcd(0, b));\n+        Assert.assertEquals(a, ArithmeticUtils.gcd(a, 0));\n+        Assert.assertEquals(b, ArithmeticUtils.gcd(0, -b));\n+        Assert.assertEquals(a, ArithmeticUtils.gcd(-a, 0));\n+\n+        Assert.assertEquals(10, ArithmeticUtils.gcd(a, b));\n+        Assert.assertEquals(10, ArithmeticUtils.gcd(-a, b));\n+        Assert.assertEquals(10, ArithmeticUtils.gcd(a, -b));\n+        Assert.assertEquals(10, ArithmeticUtils.gcd(-a, -b));\n+\n+        Assert.assertEquals(1, ArithmeticUtils.gcd(a, c));\n+        Assert.assertEquals(1, ArithmeticUtils.gcd(-a, c));\n+        Assert.assertEquals(1, ArithmeticUtils.gcd(a, -c));\n+        Assert.assertEquals(1, ArithmeticUtils.gcd(-a, -c));\n+\n+        Assert.assertEquals(3 * (1<<15), ArithmeticUtils.gcd(3 * (1<<20), 9 * (1<<15)));\n+\n+        Assert.assertEquals(Integer.MAX_VALUE, ArithmeticUtils.gcd(Integer.MAX_VALUE, 0));\n+        Assert.assertEquals(Integer.MAX_VALUE, ArithmeticUtils.gcd(-Integer.MAX_VALUE, 0));\n+        Assert.assertEquals(1<<30, ArithmeticUtils.gcd(1<<30, -Integer.MIN_VALUE));\n+        try {\n+            // gcd(Integer.MIN_VALUE, 0) > Integer.MAX_VALUE\n+            ArithmeticUtils.gcd(Integer.MIN_VALUE, 0);\n+            Assert.fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+        try {\n+            // gcd(0, Integer.MIN_VALUE) > Integer.MAX_VALUE\n+            ArithmeticUtils.gcd(0, Integer.MIN_VALUE);\n+            Assert.fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+        try {\n+            // gcd(Integer.MIN_VALUE, Integer.MIN_VALUE) > Integer.MAX_VALUE\n+            ArithmeticUtils.gcd(Integer.MIN_VALUE, Integer.MIN_VALUE);\n+            Assert.fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testGcdConsistency() {\n+        int[] primeList = {19, 23, 53, 67, 73, 79, 101, 103, 111, 131};\n+        ArrayList<Integer> primes = new ArrayList<Integer>();\n+        for (int i = 0; i < primeList.length; i++) {\n+            primes.add(Integer.valueOf(primeList[i]));\n+        }\n+        RandomDataImpl randomData = new RandomDataImpl();\n+        for (int i = 0; i < 20; i++) {\n+            Object[] sample = randomData.nextSample(primes, 4);\n+            int p1 = ((Integer) sample[0]).intValue();\n+            int p2 = ((Integer) sample[1]).intValue();\n+            int p3 = ((Integer) sample[2]).intValue();\n+            int p4 = ((Integer) sample[3]).intValue();\n+            int i1 = p1 * p2 * p3;\n+            int i2 = p1 * p2 * p4;\n+            int gcd = p1 * p2;\n+            Assert.assertEquals(gcd, ArithmeticUtils.gcd(i1, i2));\n+            long l1 = i1;\n+            long l2 = i2;\n+            Assert.assertEquals(gcd, ArithmeticUtils.gcd(l1, l2));\n+        }\n+    }\n+\n+    @Test\n+    public void  testGcdLong(){\n+        long a = 30;\n+        long b = 50;\n+        long c = 77;\n+\n+        Assert.assertEquals(0, ArithmeticUtils.gcd(0L, 0));\n+\n+        Assert.assertEquals(b, ArithmeticUtils.gcd(0, b));\n+        Assert.assertEquals(a, ArithmeticUtils.gcd(a, 0));\n+        Assert.assertEquals(b, ArithmeticUtils.gcd(0, -b));\n+        Assert.assertEquals(a, ArithmeticUtils.gcd(-a, 0));\n+\n+        Assert.assertEquals(10, ArithmeticUtils.gcd(a, b));\n+        Assert.assertEquals(10, ArithmeticUtils.gcd(-a, b));\n+        Assert.assertEquals(10, ArithmeticUtils.gcd(a, -b));\n+        Assert.assertEquals(10, ArithmeticUtils.gcd(-a, -b));\n+\n+        Assert.assertEquals(1, ArithmeticUtils.gcd(a, c));\n+        Assert.assertEquals(1, ArithmeticUtils.gcd(-a, c));\n+        Assert.assertEquals(1, ArithmeticUtils.gcd(a, -c));\n+        Assert.assertEquals(1, ArithmeticUtils.gcd(-a, -c));\n+\n+        Assert.assertEquals(3L * (1L<<45), ArithmeticUtils.gcd(3L * (1L<<50), 9L * (1L<<45)));\n+\n+        Assert.assertEquals(1L<<45, ArithmeticUtils.gcd(1L<<45, Long.MIN_VALUE));\n+\n+        Assert.assertEquals(Long.MAX_VALUE, ArithmeticUtils.gcd(Long.MAX_VALUE, 0L));\n+        Assert.assertEquals(Long.MAX_VALUE, ArithmeticUtils.gcd(-Long.MAX_VALUE, 0L));\n+        Assert.assertEquals(1, ArithmeticUtils.gcd(60247241209L, 153092023L));\n+        try {\n+            // gcd(Long.MIN_VALUE, 0) > Long.MAX_VALUE\n+            ArithmeticUtils.gcd(Long.MIN_VALUE, 0);\n+            Assert.fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+        try {\n+            // gcd(0, Long.MIN_VALUE) > Long.MAX_VALUE\n+            ArithmeticUtils.gcd(0, Long.MIN_VALUE);\n+            Assert.fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+        try {\n+            // gcd(Long.MIN_VALUE, Long.MIN_VALUE) > Long.MAX_VALUE\n+            ArithmeticUtils.gcd(Long.MIN_VALUE, Long.MIN_VALUE);\n+            Assert.fail(\"expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testLcm() {\n+        int a = 30;\n+        int b = 50;\n+        int c = 77;\n+\n+        Assert.assertEquals(0, ArithmeticUtils.lcm(0, b));\n+        Assert.assertEquals(0, ArithmeticUtils.lcm(a, 0));\n+        Assert.assertEquals(b, ArithmeticUtils.lcm(1, b));\n+        Assert.assertEquals(a, ArithmeticUtils.lcm(a, 1));\n+        Assert.assertEquals(150, ArithmeticUtils.lcm(a, b));\n+        Assert.assertEquals(150, ArithmeticUtils.lcm(-a, b));\n+        Assert.assertEquals(150, ArithmeticUtils.lcm(a, -b));\n+        Assert.assertEquals(150, ArithmeticUtils.lcm(-a, -b));\n+        Assert.assertEquals(2310, ArithmeticUtils.lcm(a, c));\n+\n+        // Assert that no intermediate value overflows:\n+        // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)\n+        Assert.assertEquals((1<<20)*15, ArithmeticUtils.lcm((1<<20)*3, (1<<20)*5));\n+\n+        // Special case\n+        Assert.assertEquals(0, ArithmeticUtils.lcm(0, 0));\n+\n+        try {\n+            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n+            ArithmeticUtils.lcm(Integer.MIN_VALUE, 1);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+\n+        try {\n+            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n+            ArithmeticUtils.lcm(Integer.MIN_VALUE, 1<<20);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+\n+        try {\n+            ArithmeticUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testLcmLong() {\n+        long a = 30;\n+        long b = 50;\n+        long c = 77;\n+\n+        Assert.assertEquals(0, ArithmeticUtils.lcm(0, b));\n+        Assert.assertEquals(0, ArithmeticUtils.lcm(a, 0));\n+        Assert.assertEquals(b, ArithmeticUtils.lcm(1, b));\n+        Assert.assertEquals(a, ArithmeticUtils.lcm(a, 1));\n+        Assert.assertEquals(150, ArithmeticUtils.lcm(a, b));\n+        Assert.assertEquals(150, ArithmeticUtils.lcm(-a, b));\n+        Assert.assertEquals(150, ArithmeticUtils.lcm(a, -b));\n+        Assert.assertEquals(150, ArithmeticUtils.lcm(-a, -b));\n+        Assert.assertEquals(2310, ArithmeticUtils.lcm(a, c));\n+\n+        Assert.assertEquals(Long.MAX_VALUE, ArithmeticUtils.lcm(60247241209L, 153092023L));\n+\n+        // Assert that no intermediate value overflows:\n+        // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)\n+        Assert.assertEquals((1L<<50)*15, ArithmeticUtils.lcm((1L<<45)*3, (1L<<50)*5));\n+\n+        // Special case\n+        Assert.assertEquals(0L, ArithmeticUtils.lcm(0L, 0L));\n+\n+        try {\n+            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n+            ArithmeticUtils.lcm(Long.MIN_VALUE, 1);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+\n+        try {\n+            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n+            ArithmeticUtils.lcm(Long.MIN_VALUE, 1<<20);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+\n+        Assert.assertEquals((long) Integer.MAX_VALUE * (Integer.MAX_VALUE - 1),\n+            ArithmeticUtils.lcm((long)Integer.MAX_VALUE, Integer.MAX_VALUE - 1));\n+        try {\n+            ArithmeticUtils.lcm(Long.MAX_VALUE, Long.MAX_VALUE - 1);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException expected) {\n+            // expected\n+        }\n+    }\n+\n+    @Test\n+    public void testMulAndCheck() {\n+        int big = Integer.MAX_VALUE;\n+        int bigNeg = Integer.MIN_VALUE;\n+        Assert.assertEquals(big, ArithmeticUtils.mulAndCheck(big, 1));\n+        try {\n+            ArithmeticUtils.mulAndCheck(big, 2);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+        }\n+        try {\n+            ArithmeticUtils.mulAndCheck(bigNeg, 2);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+        }\n+    }\n+\n+    @Test\n+    public void testMulAndCheckLong() {\n+        long max = Long.MAX_VALUE;\n+        long min = Long.MIN_VALUE;\n+        Assert.assertEquals(max, ArithmeticUtils.mulAndCheck(max, 1L));\n+        Assert.assertEquals(min, ArithmeticUtils.mulAndCheck(min, 1L));\n+        Assert.assertEquals(0L, ArithmeticUtils.mulAndCheck(max, 0L));\n+        Assert.assertEquals(0L, ArithmeticUtils.mulAndCheck(min, 0L));\n+        Assert.assertEquals(max, ArithmeticUtils.mulAndCheck(1L, max));\n+        Assert.assertEquals(min, ArithmeticUtils.mulAndCheck(1L, min));\n+        Assert.assertEquals(0L, ArithmeticUtils.mulAndCheck(0L, max));\n+        Assert.assertEquals(0L, ArithmeticUtils.mulAndCheck(0L, min));\n+        Assert.assertEquals(1L, ArithmeticUtils.mulAndCheck(-1L, -1L));\n+        Assert.assertEquals(min, ArithmeticUtils.mulAndCheck(min / 2, 2));\n+        testMulAndCheckLongFailure(max, 2L);\n+        testMulAndCheckLongFailure(2L, max);\n+        testMulAndCheckLongFailure(min, 2L);\n+        testMulAndCheckLongFailure(2L, min);\n+        testMulAndCheckLongFailure(min, -1L);\n+        testMulAndCheckLongFailure(-1L, min);\n+    }\n+\n+    @Test\n+    public void testSubAndCheck() {\n+        int big = Integer.MAX_VALUE;\n+        int bigNeg = Integer.MIN_VALUE;\n+        Assert.assertEquals(big, ArithmeticUtils.subAndCheck(big, 0));\n+        Assert.assertEquals(bigNeg + 1, ArithmeticUtils.subAndCheck(bigNeg, -1));\n+        Assert.assertEquals(-1, ArithmeticUtils.subAndCheck(bigNeg, -big));\n+        try {\n+            ArithmeticUtils.subAndCheck(big, -1);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+        }\n+        try {\n+            ArithmeticUtils.subAndCheck(bigNeg, 1);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+        }\n+    }\n+\n+    @Test\n+    public void testSubAndCheckErrorMessage() {\n+        int big = Integer.MAX_VALUE;\n+        try {\n+            ArithmeticUtils.subAndCheck(big, -1);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+            Assert.assertTrue(ex.getMessage().length() > 1);\n+        }\n+    }\n+\n+    @Test\n+    public void testSubAndCheckLong() {\n+        long max = Long.MAX_VALUE;\n+        long min = Long.MIN_VALUE;\n+        Assert.assertEquals(max, ArithmeticUtils.subAndCheck(max, 0));\n+        Assert.assertEquals(min, ArithmeticUtils.subAndCheck(min, 0));\n+        Assert.assertEquals(-max, ArithmeticUtils.subAndCheck(0, max));\n+        Assert.assertEquals(min + 1, ArithmeticUtils.subAndCheck(min, -1));\n+        // min == -1-max\n+        Assert.assertEquals(-1, ArithmeticUtils.subAndCheck(-max - 1, -max));\n+        Assert.assertEquals(max, ArithmeticUtils.subAndCheck(-1, -1 - max));\n+        testSubAndCheckLongFailure(0L, min);\n+        testSubAndCheckLongFailure(max, -1L);\n+        testSubAndCheckLongFailure(min, 1L);\n+    }\n+\n+    /**\n+     * Exact (caching) recursive implementation to test against\n+     */\n+    private long binomialCoefficient(int n, int k) throws MathArithmeticException {\n+        if (binomialCache.size() > n) {\n+            Long cachedResult = binomialCache.get(n).get(Integer.valueOf(k));\n+            if (cachedResult != null) {\n+                return cachedResult.longValue();\n+            }\n+        }\n+        long result = -1;\n+        if ((n == k) || (k == 0)) {\n+            result = 1;\n+        } else if ((k == 1) || (k == n - 1)) {\n+            result = n;\n+        } else {\n+            // Reduce stack depth for larger values of n\n+            if (k < n - 100) {\n+                binomialCoefficient(n - 100, k);\n+            }\n+            if (k > 100) {\n+                binomialCoefficient(n - 100, k - 100);\n+            }\n+            result = ArithmeticUtils.addAndCheck(binomialCoefficient(n - 1, k - 1),\n+                binomialCoefficient(n - 1, k));\n+        }\n+        if (result == -1) {\n+            throw new MathArithmeticException();\n+        }\n+        for (int i = binomialCache.size(); i < n + 1; i++) {\n+            binomialCache.add(new HashMap<Integer, Long>());\n+        }\n+        binomialCache.get(n).put(Integer.valueOf(k), Long.valueOf(result));\n+        return result;\n+    }\n+\n+    /**\n+     * Exact direct multiplication implementation to test against\n+     */\n+    private long factorial(int n) {\n+        long result = 1;\n+        for (int i = 2; i <= n; i++) {\n+            result *= i;\n+        }\n+        return result;\n+    }\n+\n+    private void testAddAndCheckLongFailure(long a, long b) {\n+        try {\n+            ArithmeticUtils.addAndCheck(a, b);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+            // success\n+        }\n+    }\n+\n+    private void testMulAndCheckLongFailure(long a, long b) {\n+        try {\n+            ArithmeticUtils.mulAndCheck(a, b);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+            // success\n+        }\n+    }\n+\n+    private void testSubAndCheckLongFailure(long a, long b) {\n+        try {\n+            ArithmeticUtils.subAndCheck(a, b);\n+            Assert.fail(\"Expecting MathArithmeticException\");\n+        } catch (MathArithmeticException ex) {\n+            // success\n+        }\n+\n+    }\n+}", "timestamp": 1318504848, "metainfo": ""}