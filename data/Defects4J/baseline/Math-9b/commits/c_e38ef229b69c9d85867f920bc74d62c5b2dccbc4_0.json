{"sha": "e38ef229b69c9d85867f920bc74d62c5b2dccbc4", "log": "Added support for Gaussian curve fitting JIRA: MATH-400  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/exception/ZeroNotAllowedException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception;\n+\n+import org.apache.commons.math.util.Localizable;\n+import org.apache.commons.math.util.LocalizedFormats;\n+\n+/**\n+ * Exception to be thrown when zero is provided where it is not allowed.\n+ *\n+ * @since 2.2\n+ * @version $Revision$ $Date$\n+ */\n+public class ZeroNotAllowedException extends MathIllegalNumberException {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -1960874856936000015L;\n+\n+    /**\n+     * Construct the exception.\n+     */\n+    public ZeroNotAllowedException() {\n+        this(null);\n+    }\n+\n+    /**\n+     * Construct the exception with a specific context.\n+     *\n+     * @param specific Specific contexte pattern .\n+     */\n+    public ZeroNotAllowedException(Localizable specific) {\n+        super(specific, LocalizedFormats.ZERO_NOT_ALLOWED, 0);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianDerivativeFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.ZeroNotAllowedException;\n+import org.apache.commons.math.util.LocalizedFormats;\n+\n+/**\n+ * The derivative of {@link GaussianFunction}.  Specifically:\n+ * <p>\n+ * <tt>f'(x) = (-b / (d^2)) * (x - c) * exp(-((x - c)^2) / (2*(d^2)))</tt>\n+ * <p>\n+ * Notation key:\n+ * <ul>\n+ * <li><tt>x^n</tt>: <tt>x</tt> raised to the power of <tt>n</tt>\n+ * <li><tt>exp(x)</tt>: <i>e</i><tt>^x</tt>\n+ * </ul>\n+ *\n+ * @since 2.2\n+ * @version $Revision$ $Date$\n+ */\n+public class GaussianDerivativeFunction implements UnivariateRealFunction, Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -6500229089670174766L;\n+\n+    /** Parameter b of this function. */\n+    private final double b;\n+\n+    /** Parameter c of this function. */\n+    private final double c;\n+\n+    /** Square of the parameter d of this function. */\n+    private final double d2;\n+\n+    /**\n+     * Constructs an instance with the specified parameters.\n+     *\n+     * @param b <tt>b</tt> parameter value\n+     * @param c <tt>c</tt> parameter value\n+     * @param d <tt>d</tt> parameter value\n+     *\n+     * @throws IllegalArgumentException if <code>d</code> is 0\n+     */\n+    public GaussianDerivativeFunction(double b, double c, double d) {\n+        if (d == 0.0) {\n+            throw new ZeroNotAllowedException();\n+        }\n+        this.b = b;\n+        this.c = c;\n+        this.d2 = d * d;\n+    }\n+\n+    /**\n+     * Constructs an instance with the specified parameters.\n+     *\n+     * @param parameters <tt>b</tt>, <tt>c</tt>, and <tt>d</tt> parameter values\n+     *\n+     * @throws IllegalArgumentException if <code>parameters</code> is null,\n+     *         <code>parameters</code> length is not 3, or if\n+     *         <code>parameters[2]</code> is 0\n+     */\n+    public GaussianDerivativeFunction(double[] parameters) {\n+        if (parameters == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NULL_INPUT_ARRAY);\n+        }\n+        if (parameters.length != 3) {\n+            throw new DimensionMismatchException(3, parameters.length);\n+        }\n+        if (parameters[2] == 0.0) {\n+            throw new ZeroNotAllowedException();\n+        }\n+        this.b = parameters[0];\n+        this.c = parameters[1];\n+        this.d2 = parameters[2] * parameters[2];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double value(double x) throws FunctionEvaluationException {\n+        final double xMc = x - c;\n+        return (-b / d2) * xMc * Math.exp(-(xMc * xMc) / (2.0 * d2));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.optimization.\n+       DifferentiableMultivariateVectorialOptimizer;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.fitting.CurveFitter;\n+import org.apache.commons.math.optimization.fitting.WeightedObservedPoint;\n+\n+/**\n+ * Fits points to a Gaussian function (that is, a {@link GaussianFunction}).\n+ * <p>\n+ * Usage example:\n+ * <pre>\n+ *   GaussianFitter fitter = new GaussianFitter(\n+ *     new LevenbergMarquardtOptimizer());\n+ *   fitter.addObservedPoint(4.0254623,  531026.0);\n+ *   fitter.addObservedPoint(4.03128248, 984167.0);\n+ *   fitter.addObservedPoint(4.03839603, 1887233.0);\n+ *   fitter.addObservedPoint(4.04421621, 2687152.0);\n+ *   fitter.addObservedPoint(4.05132976, 3461228.0);\n+ *   fitter.addObservedPoint(4.05326982, 3580526.0);\n+ *   fitter.addObservedPoint(4.05779662, 3439750.0);\n+ *   fitter.addObservedPoint(4.0636168,  2877648.0);\n+ *   fitter.addObservedPoint(4.06943698, 2175960.0);\n+ *   fitter.addObservedPoint(4.07525716, 1447024.0);\n+ *   fitter.addObservedPoint(4.08237071, 717104.0);\n+ *   fitter.addObservedPoint(4.08366408, 620014.0);\n+ *  GaussianFunction fitFunction = fitter.fit();\n+ * </pre>\n+ *\n+ * @see ParametricGaussianFunction\n+ * @since 2.2\n+ * @version $Revision$ $Date$\n+ */\n+public class GaussianFitter {\n+\n+    /** Fitter used for fitting. */\n+    private final CurveFitter fitter;\n+\n+    /**\n+     * Constructs an instance using the specified optimizer.\n+     *\n+     * @param optimizer optimizer to use for the fitting\n+     */\n+    public GaussianFitter(DifferentiableMultivariateVectorialOptimizer optimizer) {\n+        fitter = new CurveFitter(optimizer);\n+    }\n+\n+    /**\n+     * Adds point (<code>x</code>, <code>y</code>) to list of observed points\n+     * with a weight of 1.0.\n+     *\n+     * @param x <tt>x</tt> point value\n+     * @param y <tt>y</tt> point value\n+     */\n+    public void addObservedPoint(double x, double y) {\n+        addObservedPoint(1.0, x, y);\n+    }\n+\n+    /**\n+     * Adds point (<code>x</code>, <code>y</code>) to list of observed points\n+     * with a weight of <code>weight</code>.\n+     *\n+     * @param weight weight assigned to point\n+     * @param x <tt>x</tt> point value\n+     * @param y <tt>y</tt> point value\n+     */\n+    public void addObservedPoint(double weight, double x, double y) {\n+        fitter.addObservedPoint(weight, x, y);\n+    }\n+\n+    /**\n+     * Fits Gaussian function to the observed points.\n+     *\n+     * @return Gaussian function best fitting the observed points\n+     *\n+     * @throws FunctionEvaluationException if <code>CurveFitter.fit</code>\n+     *         throws it\n+     * @throws OptimizationException if <code>CurveFitter.fit</code> throws it\n+     * @throws IllegalArgumentException if <code>CurveFitter.fit</code> throws\n+     *         it\n+     *\n+     * @see CurveFitter\n+     */\n+    public GaussianFunction fit()\n+        throws FunctionEvaluationException, OptimizationException {\n+        return new GaussianFunction(fitter.fit(new ParametricGaussianFunction(),\n+                                               createParametersGuesser(fitter.getObservations()).guess()));\n+    }\n+\n+    /**\n+     * Factory method to create a <code>GaussianParametersGuesser</code>\n+     * instance initialized with the specified observations.\n+     *\n+     * @param observations points used to initialize the created\n+     *        <code>GaussianParametersGuesser</code> instance\n+     *\n+     * @return new <code>GaussianParametersGuesser</code> instance\n+     */\n+    protected GaussianParametersGuesser createParametersGuesser(WeightedObservedPoint[] observations) {\n+        return new GaussianParametersGuesser(observations);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.ZeroNotAllowedException;\n+import org.apache.commons.math.util.LocalizedFormats;\n+\n+/**\n+ * A Gaussian function.  Specifically:\n+ * <p>\n+ * <tt>f(x) = a + b*exp(-((x - c)^2 / (2*d^2)))</tt>\n+ * <p>\n+ * Notation key:\n+ * <ul>\n+ * <li><tt>x^n</tt>: <tt>x</tt> raised to the power of <tt>n</tt>\n+ * <li><tt>exp(x)</tt>: <i>e</i><tt>^x</tt>\n+ * </ul>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://en.wikipedia.org/wiki/Gaussian_function\">Wikipedia:\n+ *   Gaussian function</a>\n+ * </ul>\n+ *\n+ * @see GaussianDerivativeFunction\n+ * @see ParametricGaussianFunction\n+ * @since 2.2\n+ * @version $Revision$ $Date$\n+ */\n+public class GaussianFunction implements DifferentiableUnivariateRealFunction, Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -3195385616125629512L;\n+\n+    /** Parameter a of this function. */\n+    private final double a;\n+\n+    /** Parameter b of this function. */\n+    private final double b;\n+\n+    /** Parameter c of this function. */\n+    private final double c;\n+\n+    /** Parameter d of this function. */\n+    private final double d;\n+\n+    /**\n+     * Constructs an instance with the specified parameters.\n+     *\n+     * @param a <tt>a</tt> parameter value\n+     * @param b <tt>b</tt> parameter value\n+     * @param c <tt>c</tt> parameter value\n+     * @param d <tt>d</tt> parameter value\n+     *\n+     * @throws IllegalArgumentException if <code>d</code> is 0\n+     */\n+    public GaussianFunction(double a, double b, double c, double d) {\n+        if (d == 0.0) {\n+            throw new ZeroNotAllowedException();\n+        }\n+        this.a = a;\n+        this.b = b;\n+        this.c = c;\n+        this.d = d;\n+    }\n+\n+    /**\n+     * Constructs an instance with the specified parameters.\n+     *\n+     * @param parameters <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, and <tt>d</tt>\n+     *        parameter values\n+     *\n+     * @throws IllegalArgumentException if <code>parameters</code> is null,\n+     *         <code>parameters</code> length is not 4, or if\n+     *         <code>parameters[3]</code> is 0\n+     */\n+    public GaussianFunction(double[] parameters) {\n+        if (parameters == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NULL_INPUT_ARRAY);\n+        }\n+        if (parameters.length != 4) {\n+            throw new DimensionMismatchException(4, parameters.length);\n+        }\n+        if (parameters[3] == 0.0) {\n+            throw new ZeroNotAllowedException();\n+        }\n+        this.a = parameters[0];\n+        this.b = parameters[1];\n+        this.c = parameters[2];\n+        this.d = parameters[3];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public UnivariateRealFunction derivative() {\n+        return new GaussianDerivativeFunction(b, c, d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double value(double x) throws FunctionEvaluationException {\n+        final double xMc = x - c;\n+        return a + b * Math.exp(-xMc * xMc / (2.0 * (d * d)));\n+    }\n+\n+    /**\n+     * Gets <tt>a</tt> parameter value.\n+     *\n+     * @return <tt>a</tt> parameter value\n+     */\n+    public double getA() {\n+        return a;\n+    }\n+\n+    /**\n+     * Gets <tt>b</tt> parameter value.\n+     *\n+     * @return <tt>b</tt> parameter value\n+     */\n+    public double getB() {\n+        return b;\n+    }\n+\n+    /**\n+     * Gets <tt>c</tt> parameter value.\n+     *\n+     * @return <tt>c</tt> parameter value\n+     */\n+    public double getC() {\n+        return c;\n+    }\n+\n+    /**\n+     * Gets <tt>d</tt> parameter value.\n+     *\n+     * @return <tt>d</tt> parameter value\n+     */\n+    public double getD() {\n+        return d;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianParametersGuesser.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.ZeroNotAllowedException;\n+import org.apache.commons.math.util.LocalizedFormats;\n+\n+/**\n+ * Guesses the parameters (<tt>a</tt>, <tt>b</tt>, <tt>c</tt>, and <tt>d</tt>)\n+ * of a {@link ParametricGaussianFunction} based on the specified observed\n+ * points.\n+ *\n+ * @since 2.2\n+ * @version $Revision$ $Date$\n+ */\n+public class GaussianParametersGuesser {\n+\n+    /** Observed points. */\n+    private final WeightedObservedPoint[] observations;\n+\n+    /** Resulting guessed parameters. */\n+    private double[] parameters;\n+\n+    /**\n+     * Constructs instance with the specified observed points.\n+     *\n+     * @param observations observed points upon which should base guess\n+     */\n+    public GaussianParametersGuesser(WeightedObservedPoint[] observations) {\n+        if (observations == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NULL_INPUT_ARRAY);\n+        }\n+        if (observations.length < 3) {\n+            throw new NumberIsTooSmallException(observations.length, 3, true);\n+        }\n+        this.observations = observations.clone();\n+    }\n+\n+    /**\n+     * Guesses the parameters based on the observed points.\n+     *\n+     * @return guessed parameters array <code>{a, b, c, d}</code>\n+     */\n+    public double[] guess() {\n+        if (parameters == null) {\n+            parameters = basicGuess(observations);\n+        }\n+        return parameters.clone();\n+    }\n+\n+    /**\n+     * Guesses the parameters based on the specified observed points.\n+     *\n+     * @param points observed points upon which should base guess\n+     *\n+     * @return guessed parameters array <code>{a, b, c, d}</code>\n+     */\n+    private double[] basicGuess(WeightedObservedPoint[] points) {\n+        Arrays.sort(points, createWeightedObservedPointComparator());\n+        double[] params = new double[4];\n+\n+        int minYIdx = findMinY(points);\n+        params[0] = points[minYIdx].getY();\n+\n+        int maxYIdx = findMaxY(points);\n+        params[1] = points[maxYIdx].getY();\n+        params[2] = points[maxYIdx].getX();\n+\n+        double fwhmApprox;\n+        try {\n+            double halfY = params[0] + ((params[1] - params[0]) / 2.0);\n+            double fwhmX1 = interpolateXAtY(points, maxYIdx, -1, halfY);\n+            double fwhmX2 = interpolateXAtY(points, maxYIdx, +1, halfY);\n+            fwhmApprox = fwhmX2 - fwhmX1;\n+        } catch (OutOfRangeException e) {\n+            fwhmApprox = points[points.length - 1].getX() - points[0].getX();\n+        }\n+        params[3] = fwhmApprox / (2.0 * Math.sqrt(2.0 * Math.log(2.0)));\n+\n+        return params;\n+    }\n+\n+    /**\n+     * Finds index of point in specified points with the smallest Y.\n+     *\n+     * @param points points to search\n+     *\n+     * @return index in specified points array\n+     */\n+    private int findMinY(WeightedObservedPoint[] points) {\n+        int minYIdx = 0;\n+        for (int i = 1; i < points.length; i++) {\n+            if (points[i].getY() < points[minYIdx].getY()) {\n+                minYIdx = i;\n+            }\n+        }\n+        return minYIdx;\n+    }\n+\n+    /**\n+     * Finds index of point in specified points with the largest Y.\n+     *\n+     * @param points points to search\n+     *\n+     * @return index in specified points array\n+     */\n+    private int findMaxY(WeightedObservedPoint[] points) {\n+        int maxYIdx = 0;\n+        for (int i = 1; i < points.length; i++) {\n+            if (points[i].getY() > points[maxYIdx].getY()) {\n+                maxYIdx = i;\n+            }\n+        }\n+        return maxYIdx;\n+    }\n+\n+    /**\n+     * Interpolates using the specified points to determine X at the specified\n+     * Y.\n+     *\n+     * @param points points to use for interpolation\n+     * @param startIdx index within points from which to start search for\n+     *        interpolation bounds points\n+     * @param idxStep index step for search for interpolation bounds points\n+     * @param y Y value for which X should be determined\n+     *\n+     * @return value of X at the specified Y\n+     *\n+     * @throws IllegalArgumentException if idxStep is 0\n+     * @throws OutOfRangeException if specified <code>y</code> is not within the\n+     *         range of the specified <code>points</code>\n+     */\n+    private double interpolateXAtY(WeightedObservedPoint[] points,\n+                                   int startIdx, int idxStep, double y) throws OutOfRangeException {\n+        if (idxStep == 0) {\n+            throw new ZeroNotAllowedException();\n+        }\n+        WeightedObservedPoint[] twoPoints = getInterpolationPointsForY(points, startIdx, idxStep, y);\n+        WeightedObservedPoint pointA = twoPoints[0];\n+        WeightedObservedPoint pointB = twoPoints[1];\n+        if (pointA.getY() == y) {\n+            return pointA.getX();\n+        }\n+        if (pointB.getY() == y) {\n+            return pointB.getX();\n+        }\n+        return pointA.getX() +\n+               (((y - pointA.getY()) * (pointB.getX() - pointA.getX())) / (pointB.getY() - pointA.getY()));\n+    }\n+\n+    /**\n+     * Gets the two bounding interpolation points from the specified points\n+     * suitable for determining X at the specified Y.\n+     *\n+     * @param points points to use for interpolation\n+     * @param startIdx index within points from which to start search for\n+     *        interpolation bounds points\n+     * @param idxStep index step for search for interpolation bounds points\n+     * @param y Y value for which X should be determined\n+     *\n+     * @return array containing two points suitable for determining X at the\n+     *         specified Y\n+     *\n+     * @throws IllegalArgumentException if idxStep is 0\n+     * @throws OutOfRangeException if specified <code>y</code> is not within the\n+     *         range of the specified <code>points</code>\n+     */\n+    private WeightedObservedPoint[] getInterpolationPointsForY(WeightedObservedPoint[] points,\n+                                                               int startIdx, int idxStep, double y)\n+        throws OutOfRangeException {\n+        if (idxStep == 0) {\n+            throw new ZeroNotAllowedException();\n+        }\n+        for (int i = startIdx;\n+             (idxStep < 0) ? (i + idxStep >= 0) : (i + idxStep < points.length);\n+             i += idxStep) {\n+            if (isBetween(y, points[i].getY(), points[i + idxStep].getY())) {\n+                return (idxStep < 0) ?\n+                       new WeightedObservedPoint[] { points[i + idxStep], points[i] } :\n+                       new WeightedObservedPoint[] { points[i], points[i + idxStep] };\n+            }\n+        }\n+\n+        double minY = Double.POSITIVE_INFINITY;\n+        double maxY = Double.NEGATIVE_INFINITY;\n+        for (final WeightedObservedPoint point : points) {\n+            minY = Math.min(minY, point.getY());\n+            maxY = Math.max(maxY, point.getY());\n+        }\n+        throw new OutOfRangeException(y, minY, maxY);\n+\n+    }\n+\n+    /**\n+     * Determines whether a value is between two other values.\n+     *\n+     * @param value value to determine whether is between <code>boundary1</code>\n+     *        and <code>boundary2</code>\n+     * @param boundary1 one end of the range\n+     * @param boundary2 other end of the range\n+     *\n+     * @return true if <code>value</code> is between <code>boundary1</code> and\n+     *         <code>boundary2</code> (inclusive); false otherwise\n+     */\n+    private boolean isBetween(double value, double boundary1, double boundary2) {\n+        return (value >= boundary1 && value <= boundary2) ||\n+               (value >= boundary2 && value <= boundary1);\n+    }\n+\n+    /**\n+     * Factory method creating <code>Comparator</code> for comparing\n+     * <code>WeightedObservedPoint</code> instances.\n+     *\n+     * @return new <code>Comparator</code> instance\n+     */\n+    private Comparator<WeightedObservedPoint> createWeightedObservedPointComparator() {\n+        return new Comparator<WeightedObservedPoint>() {\n+            public int compare(WeightedObservedPoint p1, WeightedObservedPoint p2) {\n+                if (p1 == null && p2 == null) {\n+                    return 0;\n+                }\n+                if (p1 == null) {\n+                    return -1;\n+                }\n+                if (p2 == null) {\n+                    return 1;\n+                }\n+                if (p1.getX() < p2.getX()) {\n+                    return -1;\n+                }\n+                if (p1.getX() > p2.getX()) {\n+                    return 1;\n+                }\n+                if (p1.getY() < p2.getY()) {\n+                    return -1;\n+                }\n+                if (p1.getY() > p2.getY()) {\n+                    return 1;\n+                }\n+                if (p1.getWeight() < p2.getWeight()) {\n+                    return -1;\n+                }\n+                if (p1.getWeight() > p2.getWeight()) {\n+                    return 1;\n+                }\n+                return 0;\n+            }\n+        };\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/ParametricGaussianFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.ZeroNotAllowedException;\n+import org.apache.commons.math.optimization.fitting.ParametricRealFunction;\n+import org.apache.commons.math.util.LocalizedFormats;\n+\n+/**\n+ * A Gaussian function.  Specifically:\n+ * <p>\n+ * <tt>f(x) = a + b*exp(-((x - c)^2 / (2*d^2)))</tt>\n+ * <p>\n+ * The parameters have the following meaning:\n+ * <ul>\n+ * <li><tt>a</tt> is a constant offset that shifts <tt>f(x)</tt> up or down\n+ * <li><tt>b</tt> is the height of the peak\n+ * <li><tt>c</tt> is the position of the center of the peak\n+ * <li><tt>d</tt> is related to the FWHM by <tt>FWHM = 2*sqrt(2*ln(2))*d</tt>\n+ * </ul>\n+ * Notation key:\n+ * <ul>\n+ * <li><tt>x^n</tt>: <tt>x</tt> raised to the power of <tt>n</tt>\n+ * <li><tt>exp(x)</tt>: <i>e</i><tt>^x</tt>\n+ * <li><tt>sqrt(x)</tt>: the square root of <tt>x</tt>\n+ * <li><tt>ln(x)</tt>: the natural logarithm of <tt>x</tt>\n+ * </ul>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://en.wikipedia.org/wiki/Gaussian_function\">Wikipedia:\n+ *   Gaussian function</a>\n+ * </ul>\n+ *\n+ * @since 2.2\n+ * @version $Revision$ $Date$\n+ */\n+public class ParametricGaussianFunction implements ParametricRealFunction, Serializable {\n+\n+    /** Serializable version Id. */\n+    private static final long serialVersionUID = -3875578602503903233L;\n+\n+    /**\n+     * Constructs an instance.\n+     */\n+    public ParametricGaussianFunction() {\n+    }\n+\n+    /**\n+     * Computes value of function <tt>f(x)</tt> for the specified <tt>x</tt> and\n+     * parameters <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, and <tt>d</tt>.\n+     *\n+     * @param x <tt>x</tt> value\n+     * @param parameters values of <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, and\n+     *        <tt>d</tt>\n+     *\n+     * @return value of <tt>f(x)</tt> evaluated at <tt>x</tt> with the specified\n+     *         parameters\n+     *\n+     * @throws IllegalArgumentException if <code>parameters</code> is invalid as\n+     *         determined by {@link #validateParameters(double[])}\n+     * @throws FunctionEvaluationException if <code>parameters</code> values are\n+     *         invalid as determined by {@link #validateParameters(double[])}\n+     */\n+    public double value(double x, double[] parameters) throws FunctionEvaluationException {\n+        validateParameters(parameters);\n+        final double a = parameters[0];\n+        final double b = parameters[1];\n+        final double c = parameters[2];\n+        final double d = parameters[3];\n+        final double xMc = x - c;\n+        return a + b * Math.exp(-xMc * xMc / (2.0 * (d * d)));\n+    }\n+\n+    /**\n+     * Computes the gradient vector for a four variable version of the function\n+     * where the parameters, <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, and <tt>d</tt>,\n+     * are considered the variables, not <tt>x</tt>.  That is, instead of\n+     * computing the gradient vector for the function <tt>f(x)</tt> (which would\n+     * just be the derivative of <tt>f(x)</tt> with respect to <tt>x</tt> since\n+     * it's a one-dimensional function), computes the gradient vector for the\n+     * function <tt>f(a, b, c, d) = a + b*exp(-((x - c)^2 / (2*d^2)))</tt>\n+     * treating the specified <tt>x</tt> as a constant.\n+     * <p>\n+     * The components of the computed gradient vector are the partial\n+     * derivatives of <tt>f(a, b, c, d)</tt> with respect to each variable.\n+     * That is, the partial derivative of <tt>f(a, b, c, d)</tt> with respect to\n+     * <tt>a</tt>, the partial derivative of <tt>f(a, b, c, d)</tt> with respect\n+     * to <tt>b</tt>, the partial derivative of <tt>f(a, b, c, d)</tt> with\n+     * respect to <tt>c</tt>, and the partial derivative of <tt>f(a, b, c,\n+     * d)</tt> with respect to <tt>d</tt>.\n+     *\n+     * @param x <tt>x</tt> value to be used as constant in <tt>f(a, b, c,\n+     *        d)</tt>\n+     * @param parameters values of <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, and\n+     *        <tt>d</tt> for computation of gradient vector of <tt>f(a, b, c,\n+     *        d)</tt>\n+     *\n+     * @return gradient vector of <tt>f(a, b, c, d)</tt>\n+     *\n+     * @throws IllegalArgumentException if <code>parameters</code> is invalid as\n+     *         determined by {@link #validateParameters(double[])}\n+     * @throws FunctionEvaluationException if <code>parameters</code> values are\n+     *         invalid as determined by {@link #validateParameters(double[])}\n+     */\n+    public double[] gradient(double x, double[] parameters) throws FunctionEvaluationException {\n+\n+        validateParameters(parameters);\n+        final double b = parameters[1];\n+        final double c = parameters[2];\n+        final double d = parameters[3];\n+\n+        final double xMc  = x - c;\n+        final double d2   = d * d;\n+        final double exp  = Math.exp(-xMc * xMc / (2 * d2));\n+        final double f    = b * exp * xMc / d2;\n+\n+        return new double[] { 1.0, exp, f, f * xMc / d };\n+\n+    }\n+\n+    /**\n+     * Validates parameters to ensure they are appropriate for the evaluation of\n+     * the <code>value</code> and <code>gradient</code> methods.\n+     *\n+     * @param parameters values of <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, and\n+     *        <tt>d</tt>\n+     *\n+     * @throws IllegalArgumentException if <code>parameters</code> is\n+     *         <code>null</code> or if <code>parameters</code> does not have\n+     *         length == 4\n+     * @throws FunctionEvaluationException if <code>parameters[3]</code>\n+     *         (<tt>d</tt>) is 0\n+     */\n+    private void validateParameters(double[] parameters) throws FunctionEvaluationException {\n+        if (parameters == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.NULL_INPUT_ARRAY);\n+        }\n+        if (parameters.length != 4) {\n+            throw new DimensionMismatchException(4, parameters.length);\n+        }\n+        if (parameters[3] == 0.0) {\n+            throw new ZeroNotAllowedException();\n+        }\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/util/LocalizedFormats.java\n public enum LocalizedFormats implements Localizable {\n \n     // CHECKSTYLE: stop MultipleVariableDeclarations\n+    // CHECKSTYLE: stop JavadocVariable\n \n     ARGUMENT_OUTSIDE_DOMAIN(\"Argument {0} outside domain [{1} ; {2}]\"),\n     ARRAY_SIZES_SHOULD_HAVE_DIFFERENCE_1(\"array sizes should have difference 1 ({0} != {1} + 1)\"),\n     ZERO_FRACTION_TO_DIVIDE_BY(\"the fraction to divide by must not be zero: {0}/{1}\"),\n     ZERO_NORM(\"zero norm\"),\n     ZERO_NORM_FOR_ROTATION_AXIS(\"zero norm for rotation axis\"),\n-    ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR(\"zero norm for rotation defining vector\");\n-\n+    ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR(\"zero norm for rotation defining vector\"),\n+    ZERO_NOT_ALLOWED(\"zero not allowed here\");\n+\n+    // CHECKSTYLE: resume JavadocVariable\n     // CHECKSTYLE: resume MultipleVariableDeclarations\n \n \n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/GaussianFitterTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.general.\n+       LevenbergMarquardtOptimizer;\n+import org.junit.Test;\n+\n+/**\n+ * Tests {@link GaussianFitter}.\n+ *\n+ * @since 2.2\n+ * @version $Revision$ $Date$\n+ */\n+public class GaussianFitterTest {\n+    /** Good data. */\n+    protected static final double[][] DATASET1 = new double[][] {\n+        {4.0254623,  531026.0},\n+        {4.02804905, 664002.0},\n+        {4.02934242, 787079.0},\n+        {4.03128248, 984167.0},\n+        {4.03386923, 1294546.0},\n+        {4.03580929, 1560230.0},\n+        {4.03839603, 1887233.0},\n+        {4.0396894,  2113240.0},\n+        {4.04162946, 2375211.0},\n+        {4.04421621, 2687152.0},\n+        {4.04550958, 2862644.0},\n+        {4.04744964, 3078898.0},\n+        {4.05003639, 3327238.0},\n+        {4.05132976, 3461228.0},\n+        {4.05326982, 3580526.0},\n+        {4.05585657, 3576946.0},\n+        {4.05779662, 3439750.0},\n+        {4.06038337, 3220296.0},\n+        {4.06167674, 3070073.0},\n+        {4.0636168,  2877648.0},\n+        {4.06620355, 2595848.0},\n+        {4.06749692, 2390157.0},\n+        {4.06943698, 2175960.0},\n+        {4.07202373, 1895104.0},\n+        {4.0733171,  1687576.0},\n+        {4.07525716, 1447024.0},\n+        {4.0778439,  1130879.0},\n+        {4.07978396, 904900.0},\n+        {4.08237071, 717104.0},\n+        {4.08366408, 620014.0}\n+    };\n+    /** Poor data: right of peak not symmetric with left of peak. */\n+    protected static final double[][] DATASET2 = new double[][] {\n+        {-20.15,   1523.0},\n+        {-19.65,   1566.0},\n+        {-19.15,   1592.0},\n+        {-18.65,   1927.0},\n+        {-18.15,   3089.0},\n+        {-17.65,   6068.0},\n+        {-17.15,  14239.0},\n+        {-16.65,  34124.0},\n+        {-16.15,  64097.0},\n+        {-15.65, 110352.0},\n+        {-15.15, 164742.0},\n+        {-14.65, 209499.0},\n+        {-14.15, 267274.0},\n+        {-13.65, 283290.0},\n+        {-13.15, 275363.0},\n+        {-12.65, 258014.0},\n+        {-12.15, 225000.0},\n+        {-11.65, 200000.0},\n+        {-11.15, 190000.0},\n+        {-10.65, 185000.0},\n+        {-10.15, 180000.0},\n+        { -9.65, 179000.0},\n+        { -9.15, 178000.0},\n+        { -8.65, 177000.0},\n+        { -8.15, 176000.0},\n+        { -7.65, 175000.0},\n+        { -7.15, 174000.0},\n+        { -6.65, 173000.0},\n+        { -6.15, 172000.0},\n+        { -5.65, 171000.0},\n+        { -5.15, 170000.0}\n+    };\n+    /** Poor data: long tails. */\n+    protected static final double[][] DATASET3 = new double[][] {\n+        {-90.15,   1513.0},\n+        {-80.15,   1514.0},\n+        {-70.15,   1513.0},\n+        {-60.15,   1514.0},\n+        {-50.15,   1513.0},\n+        {-40.15,   1514.0},\n+        {-30.15,   1513.0},\n+        {-20.15,   1523.0},\n+        {-19.65,   1566.0},\n+        {-19.15,   1592.0},\n+        {-18.65,   1927.0},\n+        {-18.15,   3089.0},\n+        {-17.65,   6068.0},\n+        {-17.15,  14239.0},\n+        {-16.65,  34124.0},\n+        {-16.15,  64097.0},\n+        {-15.65, 110352.0},\n+        {-15.15, 164742.0},\n+        {-14.65, 209499.0},\n+        {-14.15, 267274.0},\n+        {-13.65, 283290.0},\n+        {-13.15, 275363.0},\n+        {-12.65, 258014.0},\n+        {-12.15, 214073.0},\n+        {-11.65, 182244.0},\n+        {-11.15, 136419.0},\n+        {-10.65,  97823.0},\n+        {-10.15,  58930.0},\n+        { -9.65,  35404.0},\n+        { -9.15,  16120.0},\n+        { -8.65,   9823.0},\n+        { -8.15,   5064.0},\n+        { -7.65,   2575.0},\n+        { -7.15,   1642.0},\n+        { -6.65,   1101.0},\n+        { -6.15,    812.0},\n+        { -5.65,    690.0},\n+        { -5.15,    565.0},\n+        {  5.15,    564.0},\n+        { 15.15,    565.0},\n+        { 25.15,    564.0},\n+        { 35.15,    565.0},\n+        { 45.15,    564.0},\n+        { 55.15,    565.0},\n+        { 65.15,    564.0},\n+        { 75.15,    565.0}\n+    };\n+    /** Poor data: right of peak is missing. */\n+    protected static final double[][] DATASET4 = new double[][] {\n+        {-20.15,   1523.0},\n+        {-19.65,   1566.0},\n+        {-19.15,   1592.0},\n+        {-18.65,   1927.0},\n+        {-18.15,   3089.0},\n+        {-17.65,   6068.0},\n+        {-17.15,  14239.0},\n+        {-16.65,  34124.0},\n+        {-16.15,  64097.0},\n+        {-15.65, 110352.0},\n+        {-15.15, 164742.0},\n+        {-14.65, 209499.0},\n+        {-14.15, 267274.0},\n+        {-13.65, 283290.0}\n+    };\n+    /** Good data, but few points. */\n+    protected static final double[][] DATASET5 = new double[][] {\n+        {4.0254623,  531026.0},\n+        {4.03128248, 984167.0},\n+        {4.03839603, 1887233.0},\n+        {4.04421621, 2687152.0},\n+        {4.05132976, 3461228.0},\n+        {4.05326982, 3580526.0},\n+        {4.05779662, 3439750.0},\n+        {4.0636168,  2877648.0},\n+        {4.06943698, 2175960.0},\n+        {4.07525716, 1447024.0},\n+        {4.08237071, 717104.0},\n+        {4.08366408, 620014.0}\n+    };\n+\n+    /**\n+     * Basic.\n+     *\n+     * @throws OptimizationException in the event of a test case error\n+     * @throws FunctionEvaluationException in the event of a test case error\n+     */\n+    @Test\n+    public void testFit01()\n+    throws OptimizationException, FunctionEvaluationException {\n+        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n+        addDatasetToGaussianFitter(DATASET1, fitter);\n+        GaussianFunction fitFunction = fitter.fit();\n+        assertEquals(99200.86969833552, fitFunction.getA(), 1e-4);\n+        assertEquals(3410515.285208688, fitFunction.getB(), 1e-4);\n+        assertEquals(4.054928275302832, fitFunction.getC(), 1e-4);\n+        assertEquals(0.014609868872574, fitFunction.getD(), 1e-4);\n+    }\n+\n+    /**\n+     * Zero points is not enough observed points.\n+     *\n+     * @throws OptimizationException in the event of a test case error\n+     * @throws FunctionEvaluationException in the event of a test case error\n+     */\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testFit02()\n+    throws OptimizationException, FunctionEvaluationException {\n+        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n+        fitter.fit();\n+    }\n+\n+    /**\n+     * Two points is not enough observed points.\n+     *\n+     * @throws OptimizationException in the event of a test case error\n+     * @throws FunctionEvaluationException in the event of a test case error\n+     */\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testFit03()\n+    throws OptimizationException, FunctionEvaluationException {\n+        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n+        addDatasetToGaussianFitter(new double[][] {\n+            {4.0254623,  531026.0},\n+            {4.02804905, 664002.0}},\n+            fitter);\n+        fitter.fit();\n+    }\n+\n+    /**\n+     * Poor data: right of peak not symmetric with left of peak.\n+     *\n+     * @throws OptimizationException in the event of a test case error\n+     * @throws FunctionEvaluationException in the event of a test case error\n+     */\n+    @Test\n+    public void testFit04()\n+    throws OptimizationException, FunctionEvaluationException {\n+        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n+        addDatasetToGaussianFitter(DATASET2, fitter);\n+        GaussianFunction fitFunction = fitter.fit();\n+        assertEquals(-256534.689445631, fitFunction.getA(), 1e-4);\n+        assertEquals(481328.2181530679, fitFunction.getB(), 1e-4);\n+        assertEquals(-10.5217226891099, fitFunction.getC(), 1e-4);\n+        assertEquals(-7.64248239366800, fitFunction.getD(), 1e-4);\n+    }\n+\n+    /**\n+     * Poor data: long tails.\n+     *\n+     * @throws OptimizationException in the event of a test case error\n+     * @throws FunctionEvaluationException in the event of a test case error\n+     */\n+    @Test\n+    public void testFit05()\n+    throws OptimizationException, FunctionEvaluationException {\n+        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n+        addDatasetToGaussianFitter(DATASET3, fitter);\n+        GaussianFunction fitFunction = fitter.fit();\n+        assertEquals(491.6310079258938, fitFunction.getA(), 1e-4);\n+        assertEquals(283508.6800413632, fitFunction.getB(), 1e-4);\n+        assertEquals(-13.2966857238057, fitFunction.getC(), 1e-4);\n+        assertEquals(1.725590356962981, fitFunction.getD(), 1e-4);\n+    }\n+\n+    /**\n+     * Poor data: right of peak is missing.\n+     *\n+     * @throws OptimizationException in the event of a test case error\n+     * @throws FunctionEvaluationException in the event of a test case error\n+     */\n+    @Test\n+    public void testFit06()\n+    throws OptimizationException, FunctionEvaluationException {\n+        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n+        addDatasetToGaussianFitter(DATASET4, fitter);\n+        GaussianFunction fitFunction = fitter.fit();\n+        assertEquals(530.3649792355617, fitFunction.getA(), 1e-4);\n+        assertEquals(284517.0835567514, fitFunction.getB(), 1e-4);\n+        assertEquals(-13.5355534565105, fitFunction.getC(), 1e-4);\n+        assertEquals(1.512353018625465, fitFunction.getD(), 1e-4);\n+    }\n+\n+    /**\n+     * Basic with smaller dataset.\n+     *\n+     * @throws OptimizationException in the event of a test case error\n+     * @throws FunctionEvaluationException in the event of a test case error\n+     */\n+    @Test\n+    public void testFit07()\n+    throws OptimizationException, FunctionEvaluationException {\n+        GaussianFitter fitter = new GaussianFitter(new LevenbergMarquardtOptimizer());\n+        addDatasetToGaussianFitter(DATASET5, fitter);\n+        GaussianFunction fitFunction = fitter.fit();\n+        assertEquals(176748.1400947575, fitFunction.getA(), 1e-4);\n+        assertEquals(3361537.018813906, fitFunction.getB(), 1e-4);\n+        assertEquals(4.054949992747176, fitFunction.getC(), 1e-4);\n+        assertEquals(0.014192380137002, fitFunction.getD(), 1e-4);\n+    }\n+\n+    /**\n+     * Adds the specified points to specified <code>GaussianFitter</code>\n+     * instance.\n+     *\n+     * @param points data points where first dimension is a point index and\n+     *        second dimension is an array of length two representing the point\n+     *        with the first value corresponding to X and the second value\n+     *        corresponding to Y\n+     * @param fitter fitter to which the points in <code>points</code> should be\n+     *        added as observed points\n+     */\n+    protected static void addDatasetToGaussianFitter(double[][] points,\n+                                                     GaussianFitter fitter) {\n+        for (int i = 0; i < points.length; i++) {\n+            fitter.addObservedPoint(points[i][0], points[i][1]);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/ParametricGaussianFunctionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.exception.ZeroNotAllowedException;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.fitting.CurveFitter;\n+import org.apache.commons.math.optimization.general.\n+       LevenbergMarquardtOptimizer;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+/**\n+ * Tests {@link ParametricGaussianFunction}.\n+ *\n+ * @since 2.2\n+ * @version $Revision$ $Date$\n+ */\n+public class ParametricGaussianFunctionTest {\n+    /** Dataset 1 used by some test cases. */\n+    protected static final double[][] DATASET1 = new double[][] {\n+        {4.0254623,  531026.0},\n+        {4.02804905, 664002.0},\n+        {4.02934242, 787079.0},\n+        {4.03128248, 984167.0},\n+        {4.03386923, 1294546.0},\n+        {4.03580929, 1560230.0},\n+        {4.03839603, 1887233.0},\n+        {4.0396894,  2113240.0},\n+        {4.04162946, 2375211.0},\n+        {4.04421621, 2687152.0},\n+        {4.04550958, 2862644.0},\n+        {4.04744964, 3078898.0},\n+        {4.05003639, 3327238.0},\n+        {4.05132976, 3461228.0},\n+        {4.05326982, 3580526.0},\n+        {4.05585657, 3576946.0},\n+        {4.05779662, 3439750.0},\n+        {4.06038337, 3220296.0},\n+        {4.06167674, 3070073.0},\n+        {4.0636168,  2877648.0},\n+        {4.06620355, 2595848.0},\n+        {4.06749692, 2390157.0},\n+        {4.06943698, 2175960.0},\n+        {4.07202373, 1895104.0},\n+        {4.0733171,  1687576.0},\n+        {4.07525716, 1447024.0},\n+        {4.0778439,  1130879.0},\n+        {4.07978396, 904900.0},\n+        {4.08237071, 717104.0},\n+        {4.08366408, 620014.0}\n+    };\n+\n+    /**\n+     * Using not-so-good initial parameters.\n+     *\n+     * @throws OptimizationException in the event of a test case error\n+     * @throws FunctionEvaluationException in the event of a test case error\n+     */\n+    @Test\n+    public void testFit01()\n+    throws OptimizationException, FunctionEvaluationException {\n+        CurveFitter fitter = new CurveFitter(new LevenbergMarquardtOptimizer());\n+        addDatasetToCurveFitter(DATASET1, fitter);\n+        double[] parameters = fitter.fit(new ParametricGaussianFunction(),\n+                                         new double[] {8.64753e3, 3.483323e6, 4.06322, 1.946857e-2});\n+        assertEquals(99200.94715858076, parameters[0], 1e-4);\n+        assertEquals(3410515.221897707, parameters[1], 1e-4);\n+        assertEquals(4.054928275257894, parameters[2], 1e-4);\n+        assertEquals(0.014609868499860, parameters[3], 1e-4);\n+    }\n+\n+    /**\n+     * Using eye-balled guesses for initial parameters.\n+     *\n+     * @throws OptimizationException in the event of a test case error\n+     * @throws FunctionEvaluationException in the event of a test case error\n+     */\n+    @Test\n+    public void testFit02()\n+    throws OptimizationException, FunctionEvaluationException {\n+        CurveFitter fitter = new CurveFitter(new LevenbergMarquardtOptimizer());\n+        addDatasetToCurveFitter(DATASET1, fitter);\n+        double[] parameters = fitter.fit(new ParametricGaussianFunction(),\n+                                         new double[] {500000.0, 3500000.0, 4.055, 0.025479654});\n+        assertEquals(99200.81836264656, parameters[0], 1e-4);\n+        assertEquals(3410515.327151986, parameters[1], 1e-4);\n+        assertEquals(4.054928275377392, parameters[2], 1e-4);\n+        assertEquals(0.014609869119806, parameters[3], 1e-4);\n+    }\n+\n+    /**\n+     * The parameters array is null.\n+     *\n+     * @throws FunctionEvaluationException in the event of a test case error\n+     */\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testValue01() throws FunctionEvaluationException {\n+        ParametricGaussianFunction f = new ParametricGaussianFunction();\n+        f.value(0.0, null);\n+    }\n+\n+    /**\n+     * The parameters array length is not 4.\n+     *\n+     * @throws FunctionEvaluationException in the event of a test case error\n+     */\n+    @Test(expected=IllegalArgumentException.class)\n+    public void testValue02() throws FunctionEvaluationException {\n+        ParametricGaussianFunction f = new ParametricGaussianFunction();\n+        f.value(0.0, new double[] {0.0, 1.0});\n+    }\n+\n+    /**\n+     * The parameters d is 0.\n+     *\n+     * @throws FunctionEvaluationException in the event of a test case error\n+     */\n+    @Test(expected=ZeroNotAllowedException.class)\n+    public void testValue03() throws FunctionEvaluationException {\n+        ParametricGaussianFunction f = new ParametricGaussianFunction();\n+        f.value(0.0, new double[] {0.0, 1.0, 1.0, 0.0});\n+    }\n+\n+    /**\n+     * Adds the specified points to specified <code>CurveFitter</code> instance.\n+     *\n+     * @param points data points where first dimension is a point index and\n+     *        second dimension is an array of length two representing the point\n+     *        with the first value corresponding to X and the second value\n+     *        corresponding to Y\n+     * @param fitter fitter to which the points in <code>points</code> should be\n+     *        added as observed points\n+     */\n+    protected static void addDatasetToCurveFitter(double[][] points,\n+                                                  CurveFitter fitter) {\n+        for (int i = 0; i < points.length; i++) {\n+            fitter.addObservedPoint(points[i][0], points[i][1]);\n+        }\n+    }\n+}", "timestamp": 1280520978, "metainfo": ""}