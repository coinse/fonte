{"sha": "26dac5a0e7fc9c6be9571b3e71a15d8502480d96", "log": "Removed trailing spaces.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ArgumentOutsideDomainException.java\n+++ b/src/main/java/org/apache/commons/math/ArgumentOutsideDomainException.java\n     /**\n      * Constructs an exception with specified formatted detail message.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n-     * @param argument  the failing function argument \n+     * @param argument  the failing function argument\n      * @param lower lower bound of the domain\n      * @param upper upper bound of the domain\n      */\n--- a/src/main/java/org/apache/commons/math/ConvergenceException.java\n+++ b/src/main/java/org/apache/commons/math/ConvergenceException.java\n  * @version $Revision$ $Date$\n  */\n public class ConvergenceException extends MathException {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 4883703247677159141L;\n \n     public ConvergenceException() {\n         super(\"Convergence failed\");\n     }\n-    \n+\n     /**\n      * Constructs an exception with specified formatted detail message.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n--- a/src/main/java/org/apache/commons/math/ConvergingAlgorithm.java\n+++ b/src/main/java/org/apache/commons/math/ConvergingAlgorithm.java\n      * <p>\n      * A {@link ConvergenceException} will be thrown if this number\n      * is exceeded.</p>\n-     *  \n+     *\n      * @param count maximum number of iterations\n      */\n     public abstract void setMaximalIterationCount(int count);\n \n     /**\n      * Get the upper limit for the number of iterations.\n-     * \n+     *\n      * @return the actual upper limit\n      */\n     public abstract int getMaximalIterationCount();\n      * Reset the upper limit for the number of iterations to the default.\n      * <p>\n      * The default value is supplied by the algorithm implementation.</p>\n-     * \n+     *\n      * @see #setMaximalIterationCount(int)\n      */\n     public abstract void resetMaximalIterationCount();\n      * <p>\n      * Algorithms are advised to do a plausibility check with the relative\n      * accuracy, but clients should not rely on this.</p>\n-     *  \n+     *\n      * @param accuracy the accuracy.\n      * @throws IllegalArgumentException if the accuracy can't be achieved by\n-     * the solver or is otherwise deemed unreasonable. \n+     * the solver or is otherwise deemed unreasonable.\n      */\n     public abstract void setAbsoluteAccuracy(double accuracy);\n \n     /**\n      * Get the actual absolute accuracy.\n-     * \n+     *\n      * @return the accuracy\n      */\n     public abstract double getAbsoluteAccuracy();\n      * If this should be the primary criterion for convergence rather then a\n      * safety measure, set the absolute accuracy to a ridiculously small value,\n      * like {@link org.apache.commons.math.util.MathUtils#SAFE_MIN MathUtils.SAFE_MIN}.</p>\n-     * \n+     *\n      * @param accuracy the relative accuracy.\n      * @throws IllegalArgumentException if the accuracy can't be achieved by\n-     *  the algorithm or is otherwise deemed unreasonable. \n+     *  the algorithm or is otherwise deemed unreasonable.\n      */\n     public abstract void setRelativeAccuracy(double accuracy);\n \n      * is notoriously high, check whether the problem is evaluated\n      * properly, and whether another algorithm is more amenable to the\n      * problem.</p>\n-     * \n+     *\n      * @return the last iteration count.\n      * @throws IllegalStateException if there is no result available, either\n      * because no result was yet computed or the last attempt failed.\n      */\n     public abstract int getIterationCount();\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java\n+++ b/src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java\n /**\n  * Provide a default implementation for several functions useful to generic\n  * converging algorithms.\n- *  \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n \n     /**\n      * Construct an algorithm with given iteration count and accuracy.\n-     * \n+     *\n      * @param defaultAbsoluteAccuracy maximum absolute error\n      * @param defaultMaximalIterationCount maximum number of iterations\n-     * @throws IllegalArgumentException if f is null or the \n+     * @throws IllegalArgumentException if f is null or the\n      * defaultAbsoluteAccuracy is not valid\n      */\n     protected ConvergingAlgorithmImpl(final int defaultMaximalIterationCount,\n--- a/src/main/java/org/apache/commons/math/DimensionMismatchException.java\n+++ b/src/main/java/org/apache/commons/math/DimensionMismatchException.java\n \n /**\n  * Error thrown when two dimensions differ.\n- * \n+ *\n  * @since 1.2\n  * @version $Revision$ $Date$\n  */\n public class DimensionMismatchException extends MathException {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -1316089546353786411L;\n \n     public int getDimension1() {\n         return dimension1;\n     }\n-    \n+\n     /**\n      * Get the second dimension\n      * @return second dimension\n \n     /** First dimension. */\n     private int dimension1;\n-    \n+\n     /** Second dimension. */\n     private int dimension2;\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/math/DuplicateSampleAbscissaException.java\n+++ b/src/main/java/org/apache/commons/math/DuplicateSampleAbscissaException.java\n \n /**\n  * Exeption thrown when a sample contains several entries at the same abscissa.\n- * \n+ *\n  * @since 1.2\n  * @version $Revision$ $Date$\n  */\n public class DuplicateSampleAbscissaException extends MathException  {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -2271007547170169872L;\n \n     public double getDuplicateAbscissa() {\n         return ((Double) getArguments()[0]).doubleValue();\n     }\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/math/Field.java\n+++ b/src/main/java/org/apache/commons/math/Field.java\n      */\n     T getOne();\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/FieldElement.java\n+++ b/src/main/java/org/apache/commons/math/FieldElement.java\n      */\n     Field<T> getField();\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/FunctionEvaluationException.java\n+++ b/src/main/java/org/apache/commons/math/FunctionEvaluationException.java\n  * <p>\n  * Maintains an <code>argument</code> property holding the input value that\n  * caused the function evaluation to fail.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class FunctionEvaluationException extends MathException  {\n-    \n+\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -4305020489115478365L;\n \n     /** Argument causing function evaluation failure */\n     private double[] argument;\n-    \n+\n     /**\n      * Construct an exception indicating the argument value\n      * that caused the function evaluation to fail.\n-     * \n-     * @param argument  the failing function argument \n+     *\n+     * @param argument  the failing function argument\n      */\n     public FunctionEvaluationException(double argument) {\n         super(\"evaluation failed for argument = {0}\", argument);\n         this.argument = new double[] { argument };\n     }\n-    \n+\n     /**\n      * Construct an exception indicating the argument value\n      * that caused the function evaluation to fail.\n-     * \n-     * @param argument  the failing function argument \n+     *\n+     * @param argument  the failing function argument\n      * @since 2.0\n      */\n     public FunctionEvaluationException(double[] argument) {\n         super(\"evaluation failed for argument = {0}\", new ArrayRealVector(argument));\n         this.argument = argument.clone();\n     }\n-    \n+\n     /**\n      * Constructs an exception with specified formatted detail message.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n-     * @param argument  the failing function argument \n+     * @param argument  the failing function argument\n      * @param pattern format specifier\n      * @param arguments format arguments\n      * @since 1.2\n     /**\n      * Constructs an exception with specified formatted detail message.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n-     * @param argument  the failing function argument \n+     * @param argument  the failing function argument\n      * @param pattern format specifier\n      * @param arguments format arguments\n      * @since 2.0\n      * Constructs an exception with specified root cause.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param cause  the exception or error that caused this exception to be thrown\n-     * @param argument  the failing function argument \n+     * @param argument  the failing function argument\n      * @since 1.2\n      */\n     public FunctionEvaluationException(Throwable cause, double argument) {\n      * Constructs an exception with specified root cause.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param cause  the exception or error that caused this exception to be thrown\n-     * @param argument  the failing function argument \n+     * @param argument  the failing function argument\n      * @since 2.0\n      */\n     public FunctionEvaluationException(Throwable cause, double[] argument) {\n      * Constructs an exception with specified formatted detail message and root cause.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param cause  the exception or error that caused this exception to be thrown\n-     * @param argument  the failing function argument \n+     * @param argument  the failing function argument\n      * @param pattern format specifier\n      * @param arguments format arguments\n      * @since 1.2\n      * Constructs an exception with specified formatted detail message and root cause.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param cause  the exception or error that caused this exception to be thrown\n-     * @param argument  the failing function argument \n+     * @param argument  the failing function argument\n      * @param pattern format specifier\n      * @param arguments format arguments\n      * @since 2.0\n \n     /**\n      * Returns the function argument that caused this exception.\n-     * \n+     *\n      * @return  argument that caused function evaluation to fail\n      */\n     public double[] getArgument() {\n--- a/src/main/java/org/apache/commons/math/MathConfigurationException.java\n+++ b/src/main/java/org/apache/commons/math/MathConfigurationException.java\n     public MathConfigurationException() {\n         super();\n     }\n-    \n+\n     /**\n      * Constructs an exception with specified formatted detail message.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n--- a/src/main/java/org/apache/commons/math/MathException.java\n+++ b/src/main/java/org/apache/commons/math/MathException.java\n * Supports nesting, emulating JDK 1.4 behavior if necessary.</p>\n * <p>\n * Adapted from <a href=\"http://commons.apache.org/collections/api-release/org/apache/commons/collections/FunctorException.html\"/>.</p>\n-* \n+*\n * @version $Revision$ $Date$\n */\n public class MathException extends Exception {\n-    \n+\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -9004610152740737812L;\n \n                 // the value of the resource is the translated string\n                 return bundle.getString(s);\n             }\n-            \n+\n         } catch (MissingResourceException mre) {\n             // do nothing here\n         }\n      * @return a message string\n      */\n     private static String buildMessage(Locale locale, String pattern, Object ... arguments) {\n-        return (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);        \n+        return (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);\n     }\n \n     /**\n         this.pattern   = null;\n         this.arguments = new Object[0];\n     }\n-    \n+\n     /**\n      * Constructs a new <code>MathException</code> with specified\n      * formatted detail message.\n         this.pattern   = getMessage();\n         this.arguments = new Object[0];\n     }\n-    \n+\n     /**\n      * Constructs a new <code>MathException</code> with specified\n      * formatted detail message and nested <code>Throwable</code> root cause.\n     /** Gets the message in a specified locale.\n      *\n      * @param locale Locale in which the message should be translated\n-     * \n+     *\n      * @return localized message\n      * @since 1.2\n      */\n     public void printStackTrace() {\n         printStackTrace(System.err);\n     }\n-    \n+\n     /**\n      * Prints the stack trace of this exception to the specified stream.\n      *\n--- a/src/main/java/org/apache/commons/math/MathRuntimeException.java\n+++ b/src/main/java/org/apache/commons/math/MathRuntimeException.java\n \n /**\n * Base class for commons-math unchecked exceptions.\n-* \n+*\n * @version $Revision$ $Date$\n * @since 2.0\n */\n public class MathRuntimeException extends RuntimeException {\n-    \n+\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -5128983364075381060L;\n \n                 // the value of the resource is the translated string\n                 return bundle.getString(s);\n             }\n-            \n+\n         } catch (MissingResourceException mre) {\n             // do nothing here\n         }\n      */\n     private static String buildMessage(final Locale locale, final String pattern,\n                                        final Object ... arguments) {\n-        return (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);        \n+        return (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);\n     }\n \n     /**\n         this.pattern   = getMessage();\n         this.arguments = new Object[0];\n     }\n-    \n+\n     /**\n      * Constructs a new <code>MathRuntimeException</code> with specified\n      * formatted detail message and nested <code>Throwable</code> root cause.\n     /** Gets the message in a specified locale.\n      *\n      * @param locale Locale in which the message should be translated\n-     * \n+     *\n      * @return localized message\n      */\n     public String getMessage(final Locale locale) {\n     public void printStackTrace() {\n         printStackTrace(System.err);\n     }\n-    \n+\n     /**\n      * Prints the stack trace of this exception to the specified stream.\n      *\n--- a/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n \n import java.util.ListResourceBundle;\n \n-/** \n+/**\n  * French localization message resources for the commons-math library.\n  * @version $Revision$ $Date$\n  * @since 1.2\n public class MessagesResources_fr\n   extends ListResourceBundle {\n \n-  /** \n+  /**\n    * Simple constructor.\n    */\n   public MessagesResources_fr() {\n   }\n \n-  /** \n+  /**\n    * Get the non-translated/translated messages arrays from this resource bundle.\n    * @return non-translated/translated messages arrays\n    */\n     // org.apache.commons.math.linear.SparseRealVector\n     { \"vector length mismatch: got {0} but expected {1}\",\n       \"dimension de vecteur erronn\\u00e9e : {0} \\u00e0 la place de {1}\" },\n-      \n+\n     // org.apache.commons.math.linear.ArrayRealVector\n     // org.apache.commons.math.linear.ArrayFieldVector\n     // org.apache.commons.math.linear.SparseRealVector\n \n     // org.apache.commons.math.linear.AbstractRealMatrix\n     // org.apache.commons.math.linear.AbstractFieldMatrix\n-    // org.apache.commons.math.stat.inference.ChiSquareTestImpl      \n+    // org.apache.commons.math.stat.inference.ChiSquareTestImpl\n     { \"some rows have length {0} while others have length {1}\",\n       \"certaines lignes ont une longueur de {0} alors que d''autres ont une longueur de {1}\" },\n \n--- a/src/main/java/org/apache/commons/math/analysis/DifferentiableMultivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/DifferentiableMultivariateRealFunction.java\n \n package org.apache.commons.math.analysis;\n \n-/** \n+/**\n  * Extension of {@link MultivariateRealFunction} representing a differentiable\n  * multivariate real function.\n  * @version $Revision$ $Date$\n--- a/src/main/java/org/apache/commons/math/analysis/DifferentiableMultivariateVectorialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/DifferentiableMultivariateVectorialFunction.java\n package org.apache.commons.math.analysis;\n \n \n-/** \n+/**\n  * Extension of {@link MultivariateVectorialFunction} representing a differentiable\n  * multivariate vectorial function.\n  * @version $Revision$ $Date$\n--- a/src/main/java/org/apache/commons/math/analysis/DifferentiableUnivariateMatrixFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/DifferentiableUnivariateMatrixFunction.java\n  */\n public interface DifferentiableUnivariateMatrixFunction\n     extends UnivariateMatrixFunction {\n- \n+\n     /**\n      * Returns the derivative of the function\n-     * \n+     *\n      * @return  the derivative function\n      */\n     public UnivariateMatrixFunction derivative();\n--- a/src/main/java/org/apache/commons/math/analysis/DifferentiableUnivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/DifferentiableUnivariateRealFunction.java\n  */\n public interface DifferentiableUnivariateRealFunction\n     extends UnivariateRealFunction {\n- \n+\n     /**\n      * Returns the derivative of the function\n-     * \n+     *\n      * @return  the derivative function\n      */\n     public UnivariateRealFunction derivative();\n--- a/src/main/java/org/apache/commons/math/analysis/DifferentiableUnivariateVectorialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/DifferentiableUnivariateVectorialFunction.java\n  */\n public interface DifferentiableUnivariateVectorialFunction\n     extends UnivariateVectorialFunction {\n- \n+\n     /**\n      * Returns the derivative of the function\n-     * \n+     *\n      * @return  the derivative function\n      */\n     public UnivariateVectorialFunction derivative();\n--- a/src/main/java/org/apache/commons/math/analysis/MultivariateMatrixFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/MultivariateMatrixFunction.java\n \n import org.apache.commons.math.FunctionEvaluationException;\n \n-/** \n+/**\n  * An interface representing a multivariate matrix function.\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public interface MultivariateMatrixFunction {\n \n-    /** \n+    /**\n      * Compute the value for the function at the given point.\n      * @param point point at which the function must be evaluated\n      * @return function value for the given point\n--- a/src/main/java/org/apache/commons/math/analysis/MultivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/MultivariateRealFunction.java\n \n import org.apache.commons.math.FunctionEvaluationException;\n \n-/** \n+/**\n  * An interface representing a multivariate real function.\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public interface MultivariateRealFunction {\n \n-    /** \n+    /**\n      * Compute the value for the function at the given point.\n      * @param point point at which the function must be evaluated\n      * @return function value for the given point\n--- a/src/main/java/org/apache/commons/math/analysis/MultivariateVectorialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/MultivariateVectorialFunction.java\n \n import org.apache.commons.math.FunctionEvaluationException;\n \n-/** \n+/**\n  * An interface representing a multivariate vectorial function.\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public interface MultivariateVectorialFunction {\n \n-    /** \n+    /**\n      * Compute the value for the function at the given point.\n      * @param point point at which the function must be evaluated\n      * @return function value for the given point\n--- a/src/main/java/org/apache/commons/math/analysis/UnivariateMatrixFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/UnivariateMatrixFunction.java\n \n /**\n  * An interface representing a univariate matrix function.\n- *  \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n--- a/src/main/java/org/apache/commons/math/analysis/UnivariateRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/UnivariateRealFunction.java\n \n /**\n  * An interface representing a univariate real function.\n- *  \n+ *\n  * @version $Revision$ $Date$\n  */\n public interface UnivariateRealFunction {\n--- a/src/main/java/org/apache/commons/math/analysis/UnivariateVectorialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/UnivariateVectorialFunction.java\n \n /**\n  * An interface representing a univariate vectorial function.\n- *  \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n--- a/src/main/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n     public double integrate(final UnivariateRealFunction f,\n             final double min, final double max)\n         throws ConvergenceException,  FunctionEvaluationException, IllegalArgumentException {\n-        \n+\n         clearResult();\n         verifyInterval(min, max);\n         verifyIterationCount();\n--- a/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n  * Romberg integration employs k successive refinements of the trapezoid\n  * rule to remove error terms less than order O(N^(-2k)). Simpson's rule\n  * is a special case of k = 2.</p>\n- *  \n+ *\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n \n     /**\n      * Construct an integrator for the given function.\n-     * \n+     *\n      * @param f function to integrate\n      * @deprecated as of 2.0 the integrand function is passed as an argument\n      * to the {@link #integrate(UnivariateRealFunction, double, double)}method.\n     public double integrate(final UnivariateRealFunction f,\n                             final double min, final double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException, IllegalArgumentException {\n-        \n+\n         int i = 1, j, m = maximalIterationCount + 1;\n         // Array structure here can be improved for better space\n         // efficiency because only the lower triangle is used.\n             if (i >= minimalIterationCount) {\n                 final double delta = Math.abs(s - olds);\n                 final double rLimit =\n-                    relativeAccuracy * (Math.abs(olds) + Math.abs(s)) * 0.5; \n+                    relativeAccuracy * (Math.abs(olds) + Math.abs(s)) * 0.5;\n                 if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n                     setResult(s, i);\n                     return result;\n--- a/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n  * <p>\n  * This implementation employs basic trapezoid rule as building blocks to\n  * calculate the Simpson's rule of alternating 2/3 and 4/3.</p>\n- *  \n+ *\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n \n     /**\n      * Construct an integrator for the given function.\n-     * \n+     *\n      * @param f function to integrate\n      * @deprecated as of 2.0 the integrand function is passed as an argument\n      * to the {@link #integrate(UnivariateRealFunction, double, double)}method.\n     public double integrate(final UnivariateRealFunction f,\n                             final double min, final double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException, IllegalArgumentException {\n-        \n+\n         int i = 1;\n         double s, olds, t, oldt;\n-        \n+\n         clearResult();\n         verifyInterval(min, max);\n         verifyIterationCount();\n             if (i >= minimalIterationCount) {\n                 final double delta = Math.abs(s - olds);\n                 final double rLimit =\n-                    relativeAccuracy * (Math.abs(olds) + Math.abs(s)) * 0.5; \n+                    relativeAccuracy * (Math.abs(olds) + Math.abs(s)) * 0.5;\n                 if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n                     setResult(s, i);\n                     return result;\n--- a/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n  * chapter 3.\n  * <p>\n  * The function should be integrable.</p>\n- *  \n+ *\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n \n     /**\n      * Construct an integrator for the given function.\n-     * \n+     *\n      * @param f function to integrate\n      * @deprecated as of 2.0 the integrand function is passed as an argument\n      * to the {@link #integrate(UnivariateRealFunction, double, double)}method.\n     double stage(final UnivariateRealFunction f,\n                  final double min, final double max, final int n)\n         throws FunctionEvaluationException {\n-        \n+\n         long i, np;\n         double x, spacing, sum = 0;\n-        \n+\n         if (n == 0) {\n             s = 0.5 * (max - min) * (f.value(min) + f.value(max));\n             return s;\n     public double integrate(final UnivariateRealFunction f,\n                             final double min, final double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException, IllegalArgumentException {\n-        \n+\n         int i = 1;\n         double t, oldt;\n-        \n+\n         clearResult();\n         verifyInterval(min, max);\n         verifyIterationCount();\n             if (i >= minimalIterationCount) {\n                 final double delta = Math.abs(t - oldt);\n                 final double rLimit =\n-                    relativeAccuracy * (Math.abs(oldt) + Math.abs(t)) * 0.5; \n+                    relativeAccuracy * (Math.abs(oldt) + Math.abs(t)) * 0.5;\n                 if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n                     setResult(t, i);\n                     return result;\n--- a/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegrator.java\n \n /**\n  * Interface for univariate real integration algorithms.\n- *  \n+ *\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n \n     /**\n      * Get the lower limit for the number of iterations.\n-     * \n+     *\n      * @return the actual lower limit\n      */\n     int getMinimalIterationCount();\n      * Reset the lower limit for the number of iterations to the default.\n      * <p>\n      * The default value is supplied by the implementation.</p>\n-     * \n+     *\n      * @see #setMinimalIterationCount(int)\n      */\n     void resetMinimalIterationCount();\n \n     /**\n      * Integrate the function in the given interval.\n-     * \n+     *\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @return the value of integral\n      * since 2.0\n      */\n     @Deprecated\n-    double integrate(double min, double max) throws ConvergenceException, \n+    double integrate(double min, double max) throws ConvergenceException,\n         FunctionEvaluationException, IllegalArgumentException;\n \n     /**\n      * Integrate the function in the given interval.\n-     * \n+     *\n      * @param f the integrand function\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @throws IllegalArgumentException if min > max or the endpoints do not\n      * satisfy the requirements specified by the integrator\n      */\n-    double integrate(UnivariateRealFunction f, double min, double max) throws ConvergenceException, \n+    double integrate(UnivariateRealFunction f, double min, double max) throws ConvergenceException,\n         FunctionEvaluationException, IllegalArgumentException;\n \n     /**\n      * Get the result of the last run of the integrator.\n-     * \n+     *\n      * @return the last result\n      * @throws IllegalStateException if there is no result available, either\n      * because no result was yet computed or the last attempt failed\n--- a/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n \n /**\n  * Provide a default implementation for several generic functions.\n- *  \n+ *\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n \n     /**\n      * Construct an integrator with given iteration count and accuracy.\n-     * \n+     *\n      * @param f the integrand function\n      * @param defaultMaximalIterationCount maximum number of iterations\n      * @throws IllegalArgumentException if f is null or the iteration\n         setRelativeAccuracy(1.0e-6);\n         this.defaultMinimalIterationCount = 3;\n         this.minimalIterationCount = defaultMinimalIterationCount;\n-        \n+\n         verifyIterationCount();\n     }\n \n     /**\n      * Construct an integrator with given iteration count and accuracy.\n-     * \n+     *\n      * @param defaultMaximalIterationCount maximum number of iterations\n      * @throws IllegalArgumentException if f is null or the iteration\n      * limits are not valid\n         setRelativeAccuracy(1.0e-6);\n         this.defaultMinimalIterationCount = 3;\n         this.minimalIterationCount = defaultMinimalIterationCount;\n-        \n+\n         verifyIterationCount();\n     }\n \n     /**\n      * Access the last computed integral.\n-     * \n+     *\n      * @return the last computed integral\n      * @throws IllegalStateException if no integral has been computed\n      */\n \n     /**\n      * Convenience function for implementations.\n-     * \n+     *\n      * @param newResult the result to set\n      * @param iterationCount the iteration count to set\n      */\n \n     /**\n      * Verifies that the endpoints specify an interval.\n-     * \n+     *\n      * @param lower lower endpoint\n      * @param upper upper endpoint\n      * @throws IllegalArgumentException if not interval\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"endpoints do not specify an interval: [{0}, {1}]\",\n                     lower, upper);\n-        }       \n+        }\n     }\n \n     /**\n      * Verifies that the upper and lower limits of iterations are valid.\n-     * \n+     *\n      * @throws IllegalArgumentException if not valid\n      */\n     protected void verifyIterationCount() throws IllegalArgumentException {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"invalid iteration limits: min={0}, max={1}\",\n                     minimalIterationCount, maximalIterationCount);\n-        }       \n+        }\n     }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolator.java\n \n     /**\n      * Returns a copy of the divided difference array.\n-     * <p> \n+     * <p>\n      * The divided difference array is defined recursively by <pre>\n      * f[x0] = f(x0)\n      * f[x0,x1,...,xk] = (f(x1,...,xk) - f(x0,...,x[k-1])) / (xk - x0)\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n             // Recompute the robustness weights.\n \n             // Find the median residual.\n-            // An arraycopy and a sort are completely tractable here, \n+            // An arraycopy and a sort are completely tractable here,\n             // because the preceding loop is a lot more expensive\n             System.arraycopy(residuals, 0, sortedResiduals, 0, n);\n             Arrays.sort(sortedResiduals);\n     }\n \n     /**\n-     * Compute the \n+     * Compute the\n      * <a href=\"http://en.wikipedia.org/wiki/Local_regression#Weight_function\">tricube</a>\n      * weight function\n      *\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/SplineInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SplineInterpolator.java\n  * Computes a natural (also known as \"free\", \"unclamped\") cubic spline interpolation for the data set.\n  * <p>\n  * The {@link #interpolate(double[], double[])} method returns a {@link PolynomialSplineFunction}\n- * consisting of n cubic polynomials, defined over the subintervals determined by the x values,  \n+ * consisting of n cubic polynomials, defined over the subintervals determined by the x values,\n  * x[0] < x[i] ... < x[n].  The x values are referred to as \"knot points.\"</p>\n  * <p>\n  * The value of the PolynomialSplineFunction at a point x that is greater than or equal to the smallest\n  * </p>\n  * <p>\n  * The interpolating polynomials satisfy: <ol>\n- * <li>The value of the PolynomialSplineFunction at each of the input x values equals the \n+ * <li>The value of the PolynomialSplineFunction at each of the input x values equals the\n  *  corresponding y value.</li>\n- * <li>Adjacent polynomials are equal through two derivatives at the knot points (i.e., adjacent polynomials \n+ * <li>Adjacent polynomials are equal through two derivatives at the knot points (i.e., adjacent polynomials\n  *  \"match up\" at the knot points, as do their first and second derivatives).</li>\n  * </ol></p>\n  * <p>\n- * The cubic spline interpolation algorithm implemented is as described in R.L. Burden, J.D. Faires, \n+ * The cubic spline interpolation algorithm implemented is as described in R.L. Burden, J.D. Faires,\n  * <u>Numerical Analysis</u>, 4th Ed., 1989, PWS-Kent, ISBN 0-53491-585-X, pp 126-131.\n  * </p>\n  *\n  *\n  */\n public class SplineInterpolator implements UnivariateRealInterpolator {\n-    \n+\n     /**\n      * Computes an interpolating function for the data set.\n      * @param x the arguments for the interpolation points\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"dimension mismatch {0} != {1}\", x.length, y.length);\n         }\n-        \n+\n         if (x.length < 3) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"{0} points are required, got only {1}\", 3, x.length);\n         }\n-        \n+\n         // Number of intervals.  The number of data points is n + 1.\n-        int n = x.length - 1;   \n-        \n+        int n = x.length - 1;\n+\n         for (int i = 0; i < n; i++) {\n             if (x[i]  >= x[i + 1]) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                       i, i+1, x[i], x[i+1]);\n             }\n         }\n-        \n+\n         // Differences between knot points\n         double h[] = new double[n];\n         for (int i = 0; i < n; i++) {\n             h[i] = x[i + 1] - x[i];\n         }\n-        \n+\n         double mu[] = new double[n];\n         double z[] = new double[n + 1];\n         mu[0] = 0d;\n             z[i] = (3d * (y[i + 1] * h[i - 1] - y[i] * (x[i + 1] - x[i - 1])+ y[i - 1] * h[i]) /\n                     (h[i - 1] * h[i]) - h[i - 1] * z[i - 1]) / g;\n         }\n-       \n+\n         // cubic spline coefficients --  b is linear, c quadratic, d is cubic (original y's are constants)\n         double b[] = new double[n];\n         double c[] = new double[n + 1];\n         double d[] = new double[n];\n-        \n+\n         z[n] = 0d;\n         c[n] = 0d;\n-        \n+\n         for (int j = n -1; j >=0; j--) {\n             c[j] = z[j] - mu[j] * c[j + 1];\n             b[j] = (y[j + 1] - y[j]) / h[j] - h[j] * (c[j + 1] + 2d * c[j]) / 3d;\n             d[j] = (c[j + 1] - c[j]) / (3d * h[j]);\n         }\n-        \n+\n         PolynomialFunction polynomials[] = new PolynomialFunction[n];\n         double coefficients[] = new double[4];\n         for (int i = 0; i < n; i++) {\n             coefficients[3] = d[i];\n             polynomials[i] = new PolynomialFunction(coefficients);\n         }\n-        \n+\n         return new PolynomialSplineFunction(x, polynomials);\n     }\n \n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/UnivariateRealInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/UnivariateRealInterpolator.java\n \n /**\n  * Interface representing a univariate real interpolating function.\n- *  \n+ *\n  * @version $Revision$ $Date$\n  */\n public interface UnivariateRealInterpolator {\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n      * Serializtion identifier\n      */\n     private static final long serialVersionUID = -7726511984200295583L;\n-    \n-    /**\n-     * The coefficients of the polynomial, ordered by degree -- i.e.,  \n-     * coefficients[0] is the constant term and coefficients[n] is the \n+\n+    /**\n+     * The coefficients of the polynomial, ordered by degree -- i.e.,\n+     * coefficients[0] is the constant term and coefficients[n] is the\n      * coefficient of x^n where n is the degree of the polynomial.\n      */\n     private final double coefficients[];\n      * of the coefficients array is the constant term.  Higher degree\n      * coefficients follow in sequence.  The degree of the resulting polynomial\n      * is the index of the last non-null element of the array, or 0 if all elements\n-     * are null. \n+     * are null.\n      * <p>\n      * The constructor makes a copy of the input array and assigns the copy to\n      * the coefficients property.</p>\n-     * \n+     *\n      * @param c polynomial coefficients\n      * @throws NullPointerException if c is null\n      * @throws IllegalArgumentException if c is empty\n      *  The value returned is <br>\n      *   <code>coefficients[n] * x^n + ... + coefficients[1] * x  + coefficients[0]</code>\n      * </p>\n-     * \n+     *\n      * @param x the argument for which the function value should be computed\n      * @return the value of the polynomial at the given point\n      * @see UnivariateRealFunction#value(double)\n \n     /**\n      *  Returns the degree of the polynomial\n-     * \n+     *\n      * @return the degree of the polynomial\n      */\n     public int degree() {\n         return coefficients.length - 1;\n     }\n-    \n+\n     /**\n      * Returns a copy of the coefficients array.\n      * <p>\n      * Changes made to the returned copy will not affect the coefficients of\n      * the polynomial.</p>\n-     * \n+     *\n      * @return  a fresh copy of the coefficients array\n      */\n     public double[] getCoefficients() {\n         return coefficients.clone();\n     }\n-    \n+\n     /**\n      * Uses Horner's Method to evaluate the polynomial with the given coefficients at\n      * the argument.\n-     * \n+     *\n      * @param coefficients  the coefficients of the polynomial to evaluate\n      * @param argument  the input value\n-     * @return  the value of the polynomial \n+     * @return  the value of the polynomial\n      * @throws IllegalArgumentException if coefficients is empty\n      * @throws NullPointerException if coefficients is null\n      */\n \n     /**\n      * Returns the coefficients of the derivative of the polynomial with the given coefficients.\n-     * \n+     *\n      * @param coefficients  the coefficients of the polynomial to differentiate\n      * @return the coefficients of the derivative or null if coefficients has length 1.\n      * @throws IllegalArgumentException if coefficients is empty\n         }\n         return result;\n     }\n-    \n+\n     /**\n      * Returns the derivative as a PolynomialRealFunction\n-     * \n+     *\n      * @return  the derivative polynomial\n      */\n     public PolynomialFunction polynomialDerivative() {\n         return new PolynomialFunction(differentiate(coefficients));\n     }\n-    \n+\n     /**\n      * Returns the derivative as a UnivariateRealFunction\n-     * \n+     *\n      * @return  the derivative function\n      */\n     public UnivariateRealFunction derivative() {\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n \n     /**\n      * The coefficients of the polynomial, ordered by degree -- i.e.\n-     * coefficients[0] is the constant term and coefficients[n] is the \n+     * coefficients[0] is the constant term and coefficients[n] is the\n      * coefficient of x^n where n is the degree of the polynomial.\n      */\n     private double coefficients[];\n      * values. The order of interpolating points are not important.\n      * <p>\n      * The constructor makes copy of the input arrays and assigns them.</p>\n-     * \n+     *\n      * @param x interpolating points\n      * @param y function values at interpolating points\n      * @throws IllegalArgumentException if input arrays are not valid\n \n     /**\n      * Returns the degree of the polynomial.\n-     * \n+     *\n      * @return the degree of the polynomial\n      */\n     public int degree() {\n      * Returns a copy of the interpolating points array.\n      * <p>\n      * Changes made to the returned copy will not affect the polynomial.</p>\n-     * \n+     *\n      * @return a fresh copy of the interpolating points array\n      */\n     public double[] getInterpolatingPoints() {\n      * Returns a copy of the interpolating values array.\n      * <p>\n      * Changes made to the returned copy will not affect the polynomial.</p>\n-     * \n+     *\n      * @return a fresh copy of the interpolating values array\n      */\n     public double[] getInterpolatingValues() {\n      * Returns a copy of the coefficients array.\n      * <p>\n      * Changes made to the returned copy will not affect the polynomial.</p>\n-     * \n+     *\n      * @return a fresh copy of the coefficients array\n      */\n     public double[] getCoefficients() {\n     }\n \n     /**\n-     * Evaluate the Lagrange polynomial using \n+     * Evaluate the Lagrange polynomial using\n      * <a href=\"http://mathworld.wolfram.com/NevillesAlgorithm.html\">\n      * Neville's Algorithm</a>. It takes O(N^2) time.\n      * <p>\n      * <p>\n      * The interpolating points must be distinct. However it is not\n      * verified here, it is checked in evaluate() and computeCoefficients().</p>\n-     * \n+     *\n      * @param x the interpolating points array\n      * @param y the interpolating values array\n      * @throws IllegalArgumentException if not valid\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonForm.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonForm.java\n \n     /**\n      * The coefficients of the polynomial, ordered by degree -- i.e.\n-     * coefficients[0] is the constant term and coefficients[n] is the \n+     * coefficients[0] is the constant term and coefficients[n] is the\n      * coefficient of x^n where n is the degree of the polynomial.\n      */\n     private double coefficients[];\n      * completely change, not just a permutation of old a[].\n      * <p>\n      * The constructor makes copy of the input arrays and assigns them.</p>\n-     * \n+     *\n      * @param a the coefficients in Newton form formula\n      * @param c the centers\n      * @throws IllegalArgumentException if input arrays are not valid\n \n     /**\n      * Returns the degree of the polynomial.\n-     * \n+     *\n      * @return the degree of the polynomial\n      */\n     public int degree() {\n      * Returns a copy of coefficients in Newton form formula.\n      * <p>\n      * Changes made to the returned copy will not affect the polynomial.</p>\n-     * \n+     *\n      * @return a fresh copy of coefficients in Newton form formula\n      */\n     public double[] getNewtonCoefficients() {\n      * Returns a copy of the centers array.\n      * <p>\n      * Changes made to the returned copy will not affect the polynomial.</p>\n-     * \n+     *\n      * @return a fresh copy of the centers array\n      */\n     public double[] getCenters() {\n      * Returns a copy of the coefficients array.\n      * <p>\n      * Changes made to the returned copy will not affect the polynomial.</p>\n-     * \n+     *\n      * @return a fresh copy of the coefficients array\n      */\n     public double[] getCoefficients() {\n      * <p>\n      * The centers must be distinct for interpolation purposes, but not\n      * for general use. Thus it is not verified here.</p>\n-     * \n+     *\n      * @param a the coefficients in Newton form formula\n      * @param c the centers\n      * @throws IllegalArgumentException if not valid\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunction.java\n /**\n  * Represents a polynomial spline function.\n  * <p>\n- * A <strong>polynomial spline function</strong> consists of a set of \n- * <i>interpolating polynomials</i> and an ascending array of domain \n+ * A <strong>polynomial spline function</strong> consists of a set of\n+ * <i>interpolating polynomials</i> and an ascending array of domain\n  * <i>knot points</i>, determining the intervals over which the spline function\n  * is defined by the constituent polynomials.  The polynomials are assumed to\n  * have been computed to match the values of another function at the knot\n- * points.  The value consistency constraints are not currently enforced by \n+ * points.  The value consistency constraints are not currently enforced by\n  * <code>PolynomialSplineFunction</code> itself, but are assumed to hold among\n  * the polynomials and knot points passed to the constructor.</p>\n  * <p>\n  * N.B.:  The polynomials in the <code>polynomials</code> property must be\n- * centered on the knot points to compute the spline function values.  \n+ * centered on the knot points to compute the spline function values.\n  * See below.</p>\n  * <p>\n- * The domain of the polynomial spline function is \n+ * The domain of the polynomial spline function is\n  * <code>[smallest knot, largest knot]</code>.  Attempts to evaluate the\n  * function at values outside of this range generate IllegalArgumentExceptions.\n  * </p>\n  *\n  * @version $Revision$ $Date$\n  */\n-public class PolynomialSplineFunction \n+public class PolynomialSplineFunction\n     implements DifferentiableUnivariateRealFunction {\n \n     /** Spline segment interval delimiters (knots).   Size is n+1 for n segments. */\n      * knot segment to which x belongs.\n      */\n     private PolynomialFunction polynomials[] = null;\n-    \n-    /** \n+\n+    /**\n      * Number of spline segments = number of polynomials\n-     *  = number of partition points - 1 \n+     *  = number of partition points - 1\n      */\n     private int n = 0;\n-    \n+\n \n     /**\n      * Construct a polynomial spline function with the given segment delimiters\n      * <p>\n      * The constructor copies both arrays and assigns the copies to the knots\n      * and polynomials properties, respectively.</p>\n-     * \n+     *\n      * @param knots spline segment interval delimiters\n      * @param polynomials polynomial functions that make up the spline\n      * @throws NullPointerException if either of the input arrays is null\n-     * @throws IllegalArgumentException if knots has length less than 2,  \n+     * @throws IllegalArgumentException if knots has length less than 2,\n      * <code>polynomials.length != knots.length - 1 </code>, or the knots array\n      * is not strictly increasing.\n-     * \n+     *\n      */\n     public PolynomialSplineFunction(double knots[], PolynomialFunction polynomials[]) {\n         if (knots.length < 2) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"knot values must be strictly increasing\");\n         }\n-        \n+\n         this.n = knots.length -1;\n         this.knots = new double[n + 1];\n         System.arraycopy(knots, 0, this.knots, 0, n + 1);\n      * <p>\n      * See {@link PolynomialSplineFunction} for details on the algorithm for\n      * computing the value of the function.</p>\n-     * \n+     *\n      * @param v the point for which the function value should be computed\n      * @return the value\n      * @throws ArgumentOutsideDomainException if v is outside of the domain of\n         }\n         return polynomials[i].value(v - knots[i]);\n     }\n-    \n+\n     /**\n      * Returns the derivative of the polynomial spline function as a UnivariateRealFunction\n      * @return  the derivative function\n     public UnivariateRealFunction derivative() {\n         return polynomialSplineDerivative();\n     }\n-    \n+\n     /**\n      * Returns the derivative of the polynomial spline function as a PolynomialSplineFunction\n-     * \n+     *\n      * @return  the derivative function\n      */\n     public PolynomialSplineFunction polynomialSplineDerivative() {\n     }\n \n     /**\n-     * Returns the number of spline segments = the number of polynomials \n+     * Returns the number of spline segments = the number of polynomials\n      * = the number of knot points - 1.\n-     * \n+     *\n      * @return the number of spline segments\n      */\n     public int getN() {\n      * <p>\n      * Returns a fresh copy of the array. Changes made to the copy will\n      * not affect the polynomials property.</p>\n-     * \n+     *\n      * @return the interpolating polynomials\n      */\n     public PolynomialFunction[] getPolynomials() {\n      * <p>\n      * Returns a fresh copy of the array. Changes made to the copy\n      * will not affect the knots property.</p>\n-     * \n+     *\n      * @return the knot points\n      */\n     public double[] getKnots() {\n         double out[] = new double[n + 1];\n         System.arraycopy(knots, 0, out, 0, n + 1);\n-        return out;  \n+        return out;\n     }\n \n     /**\n      * Determines if the given array is ordered in a strictly increasing\n      * fashion.\n-     * \n+     *\n      * @param x the array to examine.\n      * @return <code>true</code> if the elements in <code>x</code> are ordered\n      * in a stricly increasing manner.  <code>false</code>, otherwise.\n--- a/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtils.java\n \n /**\n  * A collection of static methods that operate on or return polynomials.\n- * \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n         return new PolynomialFunction(a);\n \n     }\n-    \n+\n     /** Compute polynomial coefficients up to a given degree.\n      * @param degree maximal degree\n      * @param maxDegree current maximal degree\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n \n /**\n  * Implements the <a href=\"http://mathworld.wolfram.com/Bisection.html\">\n- * bisection algorithm</a> for finding zeros of univariate real functions. \n+ * bisection algorithm</a> for finding zeros of univariate real functions.\n  * <p>\n  * The function should be continuous but not necessarily smooth.</p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class BisectionSolver extends UnivariateRealSolverImpl {\n-    \n+\n     /**\n      * Construct a solver for the given function.\n-     * \n+     *\n      * @param f function to solve.\n      * @deprecated as of 2.0 the function to solve is passed as an argument\n      * to the {@link #solve(UnivariateRealFunction, double, double)} or\n \n     /**\n      * Construct a solver.\n-     * \n+     *\n      */\n     public BisectionSolver() {\n         super(100, 1E-6);\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n         return solve(f, min, max);\n     }\n-    \n+\n     /** {@inheritDoc} */\n     @Deprecated\n     public double solve(double min, double max)\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-            \n+\n         clearResult();\n         verifyInterval(min,max);\n         double m;\n         double fm;\n         double fmin;\n-        \n+\n         int i = 0;\n         while (i < maximalIterationCount) {\n             m = UnivariateRealSolverUtils.midpoint(min, max);\n             }\n             ++i;\n         }\n-        \n+\n         throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n  * Brent algorithm</a> for  finding zeros of real univariate functions.\n  * <p>\n  * The function should be continuous but not necessarily smooth.</p>\n- *  \n+ *\n  * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $\n  */\n public class BrentSolver extends UnivariateRealSolverImpl {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 7694577816772532779L;\n \n     /**\n      * Construct a solver for the given function.\n-     * \n+     *\n      * @param f function to solve.\n      * @deprecated as of 2.0 the function to solve is passed as an argument\n      * to the {@link #solve(UnivariateRealFunction, double, double)} or\n      * function at the three points have the same sign (note that it is\n      * allowed to have endpoints with the same sign if the initial point has\n      * opposite sign function-wise).</p>\n-     * \n+     *\n      * @param f function to solve.\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n      * initial point is known).\n      * @return the value where the function is zero\n      * @throws MaxIterationsExceededException the maximum iteration count\n-     * is exceeded \n+     * is exceeded\n      * @throws FunctionEvaluationException if an error occurs evaluating\n      *  the function\n      * @throws IllegalArgumentException if initial is not between min and max\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n \n     }\n-    \n+\n     /**\n      * Find a zero in the given interval.\n      * <p>\n      * Requires that the values of the function at the endpoints have opposite\n      * signs. An <code>IllegalArgumentException</code> is thrown if this is not\n      * the case.</p>\n-     * \n+     *\n      * @param f the function to solve\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n      * @return the value where the function is zero\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function \n+     * function\n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n     public double solve(final UnivariateRealFunction f,\n                         final double min, final double max)\n-        throws MaxIterationsExceededException, \n+        throws MaxIterationsExceededException,\n         FunctionEvaluationException {\n-        \n+\n         clearResult();\n         verifyInterval(min, max);\n-        \n+\n         double ret = Double.NaN;\n-        \n+\n         double yMin = f.value(min);\n         double yMax = f.value(max);\n-        \n+\n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign > 0) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"function values at endpoints do not have different signs.  \" +\n                         \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\",\n-                        min, max, yMin, yMax);       \n+                        min, max, yMin, yMax);\n             }\n         } else if (sign < 0){\n             // solve using only the first endpoint as initial guess\n \n         return ret;\n     }\n-        \n+\n     /**\n      * Find a zero starting search according to the three provided points.\n      * @param f the function to solve\n      * @throws MaxIterationsExceededException if the maximum iteration count\n      * is exceeded\n      * @throws FunctionEvaluationException if an error occurs evaluating\n-     * the function \n+     * the function\n      */\n     private double solve(final UnivariateRealFunction f,\n                          double x0, double y0,\n                     delta = p / p1;\n                 }\n             }\n-            // Save old X1, Y1 \n+            // Save old X1, Y1\n             x0 = x1;\n             y0 = y1;\n             // Compute new X1, Y1\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n \n     /**\n      * Returns a copy of the polynomial function.\n-     * \n+     *\n      * @return a fresh copy of the polynomial function\n      * @deprecated as of 2.0 the function is not stored anymore within the instance.\n      */\n      * Find a real root in the given interval with initial value.\n      * <p>\n      * Requires bracketing condition.</p>\n-     * \n+     *\n      * @param f function to solve (must be polynomial)\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @throws ConvergenceException if the maximum iteration count is exceeded\n      * or the solver detects convergence problems otherwise\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function \n+     * function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double solve(final UnivariateRealFunction f,\n     /**\n      * Returns true iff the given complex root is actually a real zero\n      * in the given interval, within the solver tolerance level.\n-     * \n+     *\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @param z the complex root\n     /**\n      * Find all complex roots for the polynomial with the given coefficients,\n      * starting from the given initial value.\n-     * \n+     *\n      * @param coefficients the polynomial coefficients array\n      * @param initial the start value to use\n      * @return the point at which the function value is zero\n      * @throws ConvergenceException if the maximum iteration count is exceeded\n      * or the solver detects convergence problems otherwise\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function \n+     * function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public Complex[] solveAll(double coefficients[], double initial) throws\n     /**\n      * Find all complex roots for the polynomial with the given coefficients,\n      * starting from the given initial value.\n-     * \n+     *\n      * @param coefficients the polynomial coefficients array\n      * @param initial the start value to use\n      * @return the point at which the function value is zero\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * or the solver detects convergence problems otherwise\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function \n+     * function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public Complex[] solveAll(Complex coefficients[], Complex initial) throws\n     /**\n      * Find a complex root for the polynomial with the given coefficients,\n      * starting from the given initial value.\n-     * \n+     *\n      * @param coefficients the polynomial coefficients array\n      * @param initial the start value to use\n      * @return the point at which the function value is zero\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * or the solver detects convergence problems otherwise\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function \n+     * function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public Complex solve(Complex coefficients[], Complex initial) throws\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver.java\n \n     /**\n      * Construct a solver for the given function.\n-     * \n+     *\n      * @param f function to solve\n      * @deprecated as of 2.0 the function to solve is passed as an argument\n      * to the {@link #solve(UnivariateRealFunction, double, double)} or\n      * Find a real root in the given interval with initial value.\n      * <p>\n      * Requires bracketing condition.</p>\n-     * \n+     *\n      * @param f the function to solve\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * bisection as a safety backup if it performs very poorly.</p>\n      * <p>\n      * The formulas here use divided differences directly.</p>\n-     * \n+     *\n      * @param f the function to solve\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * or the solver detects convergence problems otherwise\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function \n+     * function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double solve(final UnivariateRealFunction f,\n      * approximation is often negligible.</p>\n      * <p>\n      * The formulas here do not use divided differences directly.</p>\n-     * \n+     *\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @return the point at which the function value is zero\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * or the solver detects convergence problems otherwise\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function \n+     * function\n      * @throws IllegalArgumentException if any parameters are invalid\n      * @deprecated replaced by {@link #solve2(UnivariateRealFunction, double, double)}\n      * since 2.0\n      * approximation is often negligible.</p>\n      * <p>\n      * The formulas here do not use divided differences directly.</p>\n-     * \n+     *\n      * @param f the function to solve\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * or the solver detects convergence problems otherwise\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function \n+     * function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double solve2(final UnivariateRealFunction f,\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n \n /**\n  * Implements <a href=\"http://mathworld.wolfram.com/NewtonsMethod.html\">\n- * Newton's Method</a> for finding zeros of real univariate functions. \n- * <p> \n+ * Newton's Method</a> for finding zeros of real univariate functions.\n+ * <p>\n  * The function should be continuous but not necessarily smooth.</p>\n  *\n  * @version $Revision$ $Date$\n  */\n public class NewtonSolver extends UnivariateRealSolverImpl {\n-    \n+\n     /**\n      * Construct a solver for the given function.\n      * @param f function to solve.\n     /** {@inheritDoc} */\n     @Deprecated\n     public double solve(final double min, final double max)\n-        throws MaxIterationsExceededException, \n+        throws MaxIterationsExceededException,\n         FunctionEvaluationException  {\n         return solve(f, min, max);\n     }\n \n     /**\n      * Find a zero near the midpoint of <code>min</code> and <code>max</code>.\n-     * \n+     *\n      * @param f the function to solve\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @return the value where the function is zero\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded \n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function or derivative\n      * @throws IllegalArgumentException if min is not less than max\n \n     /**\n      * Find a zero near the value <code>startValue</code>.\n-     * \n+     *\n      * @param f the function to solve\n      * @param min the lower bound for the interval (ignored).\n      * @param max the upper bound for the interval (ignored).\n      * @param startValue the start value to use.\n      * @return the value where the function is zero\n-     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded \n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function or derivative\n      * @throws IllegalArgumentException if startValue is not between min and max or\n             throw MathRuntimeException.createIllegalArgumentException(\"function is not differentiable\");\n         }\n     }\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/RiddersSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/RiddersSolver.java\n  * Systems, 26 (1979), 979 - 980.\n  * <p>\n  * The function should be continuous but not necessarily smooth.</p>\n- *  \n+ *\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n \n     /**\n      * Construct a solver for the given function.\n-     * \n+     *\n      * @param f function to solve\n      * @deprecated as of 2.0 the function to solve is passed as an argument\n      * to the {@link #solve(UnivariateRealFunction, double, double)} or\n      * Find a root in the given interval with initial value.\n      * <p>\n      * Requires bracketing condition.</p>\n-     * \n+     *\n      * @param f the function to solve\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * Find a root in the given interval.\n      * <p>\n      * Requires bracketing condition.</p>\n-     * \n+     *\n      * @param f the function to solve\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @return the point at which the function value is zero\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function \n+     * function\n      * @throws IllegalArgumentException if any parameters are invalid\n      */\n     public double solve(final UnivariateRealFunction f,\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n \n \n /**\n- * Implements a modified version of the \n+ * Implements a modified version of the\n  * <a href=\"http://mathworld.wolfram.com/SecantMethod.html\">secant method</a>\n- * for approximating a zero of a real univariate function.  \n+ * for approximating a zero of a real univariate function.\n  * <p>\n  * The algorithm is modified to maintain bracketing of a root by successive\n  * approximations. Because of forced bracketing, convergence may be slower than\n  * the unrestricted secant algorithm. However, this implementation should in\n- * general outperform the \n+ * general outperform the\n  * <a href=\"http://mathworld.wolfram.com/MethodofFalsePosition.html\">\n  * regula falsi method.</a></p>\n  * <p>\n  * The function is assumed to be continuous but not necessarily smooth.</p>\n- *  \n+ *\n  * @version $Revision$ $Date$\n  */\n public class SecantSolver extends UnivariateRealSolverImpl {\n-    \n+\n     /**\n      * Construct a solver for the given function.\n      * @param f function to solve.\n \n     /**\n      * Find a zero in the given interval.\n-     * \n+     *\n      * @param f the function to solve\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * @return the value where the function is zero\n      * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function \n+     * function\n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n         return solve(f, min, max);\n     }\n-    \n+\n     /**\n      * Find a zero in the given interval.\n      * @param f the function to solve\n      * @return the value where the function is zero\n      * @throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function \n+     * function\n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n     public double solve(final UnivariateRealFunction f,\n                         final double min, final double max)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        \n+\n         clearResult();\n         verifyInterval(min, max);\n-        \n+\n         // Index 0 is the old approximation for the root.\n         // Index 1 is the last calculated approximation  for the root.\n         // Index 2 is a bracket for the root with respect to x0.\n         double x1 = max;\n         double y0 = f.value(x0);\n         double y1 = f.value(x1);\n-        \n+\n         // Verify bracketing\n         if (y0 * y1 >= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"function values at endpoints do not have different signs, \" +\n                   \"endpoints: [{0}, {1}], values: [{2}, {3}]\",\n-                  min, max, y0, y1);       \n+                  min, max, y0, y1);\n         }\n-        \n+\n         double x2 = x0;\n         double y2 = y0;\n         double oldDelta = x2 - x1;\n             x1 = x1 + delta;\n             y1 = f.value(x1);\n             if ((y1 > 0) == (y2 > 0)) {\n-                // New bracket is (x0,x1).                    \n+                // New bracket is (x0,x1).\n                 x2 = x0;\n                 y2 = y0;\n             }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolver.java\n  * Interface for (univariate real) rootfinding algorithms.\n  * <p>\n  * Implementations will search for only one zero in the given interval.</p>\n- *  \n+ *\n  * @version $Revision$ $Date$\n  */\n public interface UnivariateRealSolver extends ConvergingAlgorithm {\n      * <p>\n      * This is a safety guard and it shouldn't be necessary to change this in\n      * general.</p>\n-     * \n+     *\n      * @param accuracy the accuracy.\n      * @throws IllegalArgumentException if the accuracy can't be achieved by\n-     * the solver or is otherwise deemed unreasonable. \n+     * the solver or is otherwise deemed unreasonable.\n      */\n     void setFunctionValueAccuracy(double accuracy);\n \n      * <p>A solver may require that the interval brackets a single zero root.\n      * Solvers that do require bracketing should be able to handle the case\n      * where one of the endpoints is itself a root.</p>\n-     * \n+     *\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n      * @return a value where the function is zero\n      * since 2.0\n      */\n     @Deprecated\n-    double solve(double min, double max) throws ConvergenceException, \n+    double solve(double min, double max) throws ConvergenceException,\n         FunctionEvaluationException;\n \n     /**\n      * <p>A solver may require that the interval brackets a single zero root.\n      * Solvers that do require bracketing should be able to handle the case\n      * where one of the endpoints is itself a root.</p>\n-     * \n+     *\n      * @param f the function to solve.\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n      * @since 2.0\n      */\n     double solve(UnivariateRealFunction f, double min, double max)\n-        throws ConvergenceException, \n+        throws ConvergenceException,\n         FunctionEvaluationException;\n \n     /**\n      * <p>A solver may require that the interval brackets a single zero root.\n      * Solvers that do require bracketing should be able to handle the case\n      * where one of the endpoints is itself a root.</p>\n-     * \n+     *\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n      * @param startValue the start value to use\n      * <p>A solver may require that the interval brackets a single zero root.\n      * Solvers that do require bracketing should be able to handle the case\n      * where one of the endpoints is itself a root.</p>\n-     * \n+     *\n      * @param f the function to solve.\n      * @param min the lower bound for the interval.\n      * @param max the upper bound for the interval.\n \n     /**\n      * Get the result of the last run of the solver.\n-     * \n+     *\n      * @return the last result.\n      * @throws IllegalStateException if there is no result available, either\n      * because no result was yet computed or the last attempt failed.\n \n     /**\n      * Get the result of the last run of the solver.\n-     * \n+     *\n      * @return the value of the function at the last result.\n      * @throws IllegalStateException if there is no result available, either\n      * because no result was yet computed or the last attempt failed.\n      */\n     double getFunctionValue();\n-}\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverFactory.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverFactory.java\n     public static UnivariateRealSolverFactory newInstance() {\n         return new UnivariateRealSolverFactoryImpl();\n     }\n-    \n+\n     /**\n      * Create a new {@link UnivariateRealSolver}.  The\n      * actual solver returned is determined by the underlying factory.\n      * @return the new solver.\n      */\n     public abstract UnivariateRealSolver newDefaultSolver();\n-    \n+\n     /**\n      * Create a new {@link UnivariateRealSolver}.  The\n      * solver is an implementation of the bisection method.\n      * @return the new solver.\n      */\n     public abstract UnivariateRealSolver newBisectionSolver();\n-    \n+\n     /**\n      * Create a new {@link UnivariateRealSolver}.  The\n      * solver is an implementation of the Brent method.\n      * @return the new solver.\n      */\n     public abstract UnivariateRealSolver newBrentSolver();\n-    \n+\n     /**\n      * Create a new {@link UnivariateRealSolver}.  The\n      * solver is an implementation of Newton's Method.\n      * @return the new solver.\n      */\n     public abstract UnivariateRealSolver newNewtonSolver();\n-    \n+\n     /**\n      * Create a new {@link UnivariateRealSolver}.  The\n      * solver is an implementation of the secant method.\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverFactoryImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverFactoryImpl.java\n  * @version $Revision$ $Date$\n  */\n public class UnivariateRealSolverFactoryImpl extends UnivariateRealSolverFactory {\n-        \n+\n     /**\n      * Default constructor.\n      */\n     public UnivariateRealSolver newDefaultSolver() {\n         return newBrentSolver();\n     }\n-    \n+\n     /** {@inheritDoc} */\n     @Override\n     public UnivariateRealSolver newBisectionSolver() {\n     public UnivariateRealSolver newBrentSolver() {\n         return new BrentSolver();\n     }\n-    \n+\n     /** {@inheritDoc} */\n     @Override\n     public UnivariateRealSolver newNewtonSolver() {\n         return new NewtonSolver();\n     }\n-    \n+\n     /** {@inheritDoc} */\n     @Override\n     public UnivariateRealSolver newSecantSolver() {\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n /**\n  * Provide a default implementation for several functions useful to generic\n  * solvers.\n- *  \n+ *\n  * @version $Revision$ $Date$\n  */\n public abstract class UnivariateRealSolverImpl\n \n     /**\n      * Construct a solver with given iteration count and accuracy.\n-     * \n+     *\n      * @param f the function to solve.\n      * @param defaultAbsoluteAccuracy maximum absolute error\n      * @param defaultMaximalIterationCount maximum number of iterations\n-     * @throws IllegalArgumentException if f is null or the \n+     * @throws IllegalArgumentException if f is null or the\n      * defaultAbsoluteAccuracy is not valid\n      * @deprecated as of 2.0 the function to solve is passed as an argument\n      * to the {@link #solve(UnivariateRealFunction, double, double)} or\n \n     /**\n      * Construct a solver with given iteration count and accuracy.\n-     * \n+     *\n      * @param defaultAbsoluteAccuracy maximum absolute error\n      * @param defaultMaximalIterationCount maximum number of iterations\n-     * @throws IllegalArgumentException if f is null or the \n+     * @throws IllegalArgumentException if f is null or the\n      * defaultAbsoluteAccuracy is not valid\n      */\n     protected UnivariateRealSolverImpl(final int defaultMaximalIterationCount,\n \n     /**\n      * Convenience function for implementations.\n-     * \n+     *\n      * @param newResult the result to set\n      * @param iterationCount the iteration count to set\n      */\n \n     /**\n      * Convenience function for implementations.\n-     * \n+     *\n      * @param x the result to set\n      * @param fx the result to set\n      * @param iterationCount the iteration count to set\n \n     /**\n      * Returns true iff the function takes opposite signs at the endpoints.\n-     * \n-     * @param lower  the lower endpoint \n+     *\n+     * @param lower  the lower endpoint\n      * @param upper  the upper endpoint\n      * @param function the function\n      * @return true if f(lower) * f(upper) < 0\n-     * @throws FunctionEvaluationException if an error occurs evaluating the \n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function at the endpoints\n      */\n-    protected boolean isBracketing(final double lower, final double upper, \n+    protected boolean isBracketing(final double lower, final double upper,\n                                    final UnivariateRealFunction function)\n         throws FunctionEvaluationException {\n         final double f1 = function.value(lower);\n         final double f2 = function.value(upper);\n         return ((f1 > 0 && f2 < 0) || (f1 < 0 && f2 > 0));\n     }\n-    \n+\n     /**\n      * Returns true if the arguments form a (strictly) increasing sequence\n-     * \n+     *\n      * @param start  first number\n      * @param mid   second number\n      * @param end  third number\n     protected boolean isSequence(final double start, final double mid, final double end) {\n         return (start < mid) && (mid < end);\n     }\n-    \n-    /**\n-     * Verifies that the endpoints specify an interval, \n+\n+    /**\n+     * Verifies that the endpoints specify an interval,\n      * throws IllegalArgumentException if not\n-     * \n+     *\n      * @param lower  lower endpoint\n      * @param upper upper endpoint\n      * @throws IllegalArgumentException\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"endpoints do not specify an interval: [{0}, {1}]\",\n                     lower, upper);\n-        }       \n-    }\n-    \n+        }\n+    }\n+\n     /**\n      * Verifies that <code>lower < initial < upper</code>\n      * throws IllegalArgumentException if not\n-     * \n+     *\n      * @param lower  lower endpoint\n      * @param initial initial value\n      * @param upper upper endpoint\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",\n                     lower, initial, upper);\n-        }       \n-    }\n-    \n+        }\n+    }\n+\n     /**\n      * Verifies that the endpoints specify an interval and the function takes\n      * opposite signs at the enpoints, throws IllegalArgumentException if not\n-     * \n+     *\n      * @param lower  lower endpoint\n      * @param upper upper endpoint\n      * @param function function\n      * @throws IllegalArgumentException\n-     * @throws FunctionEvaluationException if an error occurs evaluating the \n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function at the endpoints\n      */\n-    protected void verifyBracketing(final double lower, final double upper, \n+    protected void verifyBracketing(final double lower, final double upper,\n                                     final UnivariateRealFunction function)\n         throws FunctionEvaluationException {\n-        \n+\n         verifyInterval(lower, upper);\n         if (!isBracketing(lower, upper, function)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"function values at endpoints do not have different signs.  \" +\n                     \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\",\n-                    lower, upper, function.value(lower), function.value(upper));       \n+                    lower, upper, function.value(lower), function.value(upper));\n         }\n     }\n }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n \n /**\n  * Utility routines for {@link UnivariateRealSolver} objects.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class UnivariateRealSolverUtils {\n     private UnivariateRealSolverUtils() {\n         super();\n     }\n-    \n+\n     /**\n      * Convenience method to find a zero of a univariate real function.  A default\n-     * solver is used. \n-     * \n+     * solver is used.\n+     *\n      * @param f the function.\n      * @param x0 the lower bound for the interval.\n      * @param x1 the upper bound for the interval.\n \n     /**\n      * Convenience method to find a zero of a univariate real function.  A default\n-     * solver is used. \n-     * \n+     * solver is used.\n+     *\n      * @param f the function\n      * @param x0 the lower bound for the interval\n      * @param x1 the upper bound for the interval\n      * @throws ConvergenceException if the iteration count is exceeded\n      * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function\n-     * @throws IllegalArgumentException if f is null, the endpoints do not \n+     * @throws IllegalArgumentException if f is null, the endpoints do not\n      * specify a valid interval, or the absoluteAccuracy is not valid for the\n      * default solver\n      */\n     public static double solve(UnivariateRealFunction f, double x0, double x1,\n-            double absoluteAccuracy) throws ConvergenceException, \n-            FunctionEvaluationException {    \n-       \n+            double absoluteAccuracy) throws ConvergenceException,\n+            FunctionEvaluationException {\n+\n         setup(f);\n         UnivariateRealSolver solver = LazyHolder.FACTORY.newDefaultSolver();\n         solver.setAbsoluteAccuracy(absoluteAccuracy);\n      * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n      * and <code>b</code> bracket a root of f.\n      * <p>\n-     * The algorithm starts by setting \n+     * The algorithm starts by setting\n      * <code>a := initial -1; b := initial +1,</code> examines the value of the\n      * function at <code>a</code> and <code>b</code> and keeps moving\n-     * the endpoints out by one unit each time through a loop that terminates \n+     * the endpoints out by one unit each time through a loop that terminates\n      * when one of the following happens: <ul>\n      * <li> <code> f(a) * f(b) < 0 </code> --  success!</li>\n-     * <li> <code> a = lower </code> and <code> b = upper</code> \n+     * <li> <code> a = lower </code> and <code> b = upper</code>\n      * -- ConvergenceException </li>\n-     * <li> <code> Integer.MAX_VALUE</code> iterations elapse \n+     * <li> <code> Integer.MAX_VALUE</code> iterations elapse\n      * -- ConvergenceException </li>\n      * </ul></p>\n      * <p>\n-     * <strong>Note: </strong> this method can take \n-     * <code>Integer.MAX_VALUE</code> iterations to throw a \n+     * <strong>Note: </strong> this method can take\n+     * <code>Integer.MAX_VALUE</code> iterations to throw a\n      * <code>ConvergenceException.</code>  Unless you are confident that there\n      * is a root between <code>lowerBound</code> and <code>upperBound</code>\n-     * near <code>initial,</code> it is better to use \n-     * {@link #bracket(UnivariateRealFunction, double, double, double, int)}, \n+     * near <code>initial,</code> it is better to use\n+     * {@link #bracket(UnivariateRealFunction, double, double, double, int)},\n      * explicitly specifying the maximum number of iterations.</p>\n      *\n      * @param function the function\n      * @throws IllegalArgumentException if function is null, maximumIterations\n      * is not positive, or initial is not between lowerBound and upperBound\n      */\n-    public static double[] bracket(UnivariateRealFunction function, \n-            double initial, double lowerBound, double upperBound) \n+    public static double[] bracket(UnivariateRealFunction function,\n+            double initial, double lowerBound, double upperBound)\n     throws ConvergenceException, FunctionEvaluationException {\n         return bracket( function, initial, lowerBound, upperBound,\n             Integer.MAX_VALUE ) ;\n      * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n      * and <code>b</code> bracket a root of f.\n      * <p>\n-     * The algorithm starts by setting \n+     * The algorithm starts by setting\n      * <code>a := initial -1; b := initial +1,</code> examines the value of the\n      * function at <code>a</code> and <code>b</code> and keeps moving\n-     * the endpoints out by one unit each time through a loop that terminates \n+     * the endpoints out by one unit each time through a loop that terminates\n      * when one of the following happens: <ul>\n      * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n-     * <li> <code> a = lower </code> and <code> b = upper</code> \n+     * <li> <code> a = lower </code> and <code> b = upper</code>\n      * -- ConvergenceException </li>\n-     * <li> <code> maximumIterations</code> iterations elapse \n+     * <li> <code> maximumIterations</code> iterations elapse\n      * -- ConvergenceException </li></ul></p>\n-     * \n+     *\n      * @param function the function\n      * @param initial initial midpoint of interval being expanded to\n      * bracket a root\n      * @return a two element array holding {a, b}.\n      * @throws ConvergenceException if the algorithm fails to find a and b\n      * satisfying the desired conditions\n-     * @throws FunctionEvaluationException if an error occurs evaluating the \n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n      * function\n      * @throws IllegalArgumentException if function is null, maximumIterations\n      * is not positive, or initial is not between lowerBound and upperBound\n      */\n     public static double[] bracket(UnivariateRealFunction function,\n-            double initial, double lowerBound, double upperBound, \n-            int maximumIterations) throws ConvergenceException, \n+            double initial, double lowerBound, double upperBound,\n+            int maximumIterations) throws ConvergenceException,\n             FunctionEvaluationException {\n-        \n+\n         if (function == null) {\n             throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n         }\n         double fa;\n         double fb;\n         int numIterations = 0 ;\n-    \n+\n         do {\n             a = Math.max(a - 1.0, lowerBound);\n             b = Math.min(b + 1.0, upperBound);\n             fa = function.value(a);\n-            \n+\n             fb = function.value(b);\n             numIterations++ ;\n-        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n+        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&\n                 ((a > lowerBound) || (b < upperBound)));\n-   \n+\n         if (fa * fb > 0.0 ) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       numIterations, maximumIterations, initial,\n                       lowerBound, upperBound, a, b, fa, fb);\n         }\n-        \n+\n         return new double[]{a, b};\n     }\n \n     /**\n      * Compute the midpoint of two values.\n-     * \n+     *\n      * @param a first value.\n      * @param b second value.\n-     * @return the midpoint. \n+     * @return the midpoint.\n      */\n     public static double midpoint(double a, double b) {\n         return (a + b) * .5;\n     }\n-    \n+\n     /**\n      * Checks to see if f is null, throwing IllegalArgumentException if so.\n      * @param f  input function\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n import org.apache.commons.math.util.MathUtils;\n \n /**\n- * Representation of a Complex number - a number which has both a \n+ * Representation of a Complex number - a number which has both a\n  * real and imaginary part.\n  * <p>\n  * Implementations of arithmetic operations handle <code>NaN</code> and\n  * infinite values according to the rules for {@link java.lang.Double}\n  * arithmetic, applying definitional formulas and returning <code>NaN</code> or\n- * infinite values in real or imaginary parts as these arise in computation. \n+ * infinite values in real or imaginary parts as these arise in computation.\n  * See individual method javadocs for details.</p>\n  * <p>\n- * {@link #equals} identifies all values with <code>NaN</code> in either real \n+ * {@link #equals} identifies all values with <code>NaN</code> in either real\n  * or imaginary part - e.g., <pre>\n  * <code>1 + NaNi  == NaN + i == NaN + NaNi.</code></pre></p>\n  *\n  * implements Serializable since 2.0\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class Complex implements FieldElement<Complex>, Serializable  {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6195664516687396620L;\n \n-    /** The square root of -1. A number representing \"0.0 + 1.0i\" */    \n+    /** The square root of -1. A number representing \"0.0 + 1.0i\" */\n     public static final Complex I = new Complex(0.0, 1.0);\n \n     // CHECKSTYLE: stop ConstantName\n     /** A complex number representing \"+INF + INFi\" */\n     public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n \n-    /** A complex number representing \"1.0 + 0.0i\" */    \n+    /** A complex number representing \"1.0 + 0.0i\" */\n     public static final Complex ONE = new Complex(1.0, 0.0);\n-    \n-    /** A complex number representing \"0.0 + 0.0i\" */    \n+\n+    /** A complex number representing \"0.0 + 0.0i\" */\n     public static final Complex ZERO = new Complex(0.0, 0.0);\n-    \n-    /** \n-     * The imaginary part \n+\n+    /**\n+     * The imaginary part\n      */\n     private final double imaginary;\n-    \n-    /** \n-     * The real part \n+\n+    /**\n+     * The real part\n      */\n     private final double real;\n-    \n+\n     /**\n      * Record whether this complex number is equal to NaN\n      */\n     private final transient boolean isNaN;\n-    \n+\n     /**\n      * Record whether this complex number is infinite\n      */\n     private final transient boolean isInfinite;\n-    \n+\n     /**\n      * Create a complex number given the real and imaginary parts.\n      *\n         super();\n         this.real = real;\n         this.imaginary = imaginary;\n-        \n+\n         isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n         isInfinite = !isNaN &&\n         (Double.isInfinite(real) || Double.isInfinite(imaginary));\n         if (isNaN()) {\n             return Double.NaN;\n         }\n-        \n+\n         if (isInfinite()) {\n             return Double.POSITIVE_INFINITY;\n         }\n-        \n+\n         if (Math.abs(real) < Math.abs(imaginary)) {\n             if (imaginary == 0.0) {\n                 return Math.abs(real);\n             return (Math.abs(real) * Math.sqrt(1 + q*q));\n         }\n     }\n-    \n+\n     /**\n      * Return the sum of this complex number and the given complex number.\n      * <p>\n-     * Uses the definitional formula \n+     * Uses the definitional formula\n      * <pre>\n      * (a + bi) + (c + di) = (a+c) + (b+d)i\n      * </pre></p>\n      * If either this or <code>rhs</code> has a NaN value in either part,\n      * {@link #NaN} is returned; otherwise Inifinite and NaN values are\n      * returned in the parts of the result according to the rules for\n-     * {@link java.lang.Double} arithmetic.</p> \n+     * {@link java.lang.Double} arithmetic.</p>\n      *\n      * @param rhs the other complex number\n      * @return the complex number sum\n      * @throws NullPointerException if <code>rhs</code> is null\n      */\n-    public Complex add(Complex rhs) {   \n+    public Complex add(Complex rhs) {\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }\n-    \n+\n     /**\n      * Return the conjugate of this complex number. The conjugate of\n-     * \"A + Bi\" is \"A - Bi\". \n+     * \"A + Bi\" is \"A - Bi\".\n      * <p>\n      * {@link #NaN} is returned if either the real or imaginary\n      * part of this Complex number equals <code>Double.NaN</code>.</p>\n      * <p>\n-     * If the imaginary part is infinite, and the real part is not NaN, \n+     * If the imaginary part is infinite, and the real part is not NaN,\n      * the returned value has infinite imaginary part of the opposite\n      * sign - e.g. the conjugate of <code>1 + POSITIVE_INFINITY i</code>\n      * is <code>1 - NEGATIVE_INFINITY i</code></p>\n     public Complex conjugate() {\n         if (isNaN()) {\n             return NaN;\n-        }   \n+        }\n         return createComplex(real, -imaginary);\n     }\n-    \n+\n     /**\n      * Return the quotient of this complex number and the given complex number.\n      * <p>\n      *    ----------- = -------------------------\n      *    c + di               c<sup>2</sup> + d<sup>2</sup>\n      * </code></pre>\n-     * but uses \n+     * but uses\n      * <a href=\"http://doi.acm.org/10.1145/1039813.1039814\">\n      * prescaling of operands</a> to limit the effects of overflows and\n      * underflows in the computation.</p>\n      * <li>If this and <code>rhs</code> are both infinite,\n      * {@link #NaN} is returned.</li>\n      * <li>If this is finite (i.e., has no infinite or NaN parts) and\n-     *  <code>rhs</code> is infinite (one or both parts infinite), \n+     *  <code>rhs</code> is infinite (one or both parts infinite),\n      * {@link #ZERO} is returned.</li>\n      * <li>If this is infinite and <code>rhs</code> is finite, NaN values are\n      * returned in the parts of the result if the {@link java.lang.Double}\n      * rules applied to the definitional formula force NaN results.</li>\n      * </ul></p>\n-     * \n+     *\n      * @param rhs the other complex number\n      * @return the complex number quotient\n      * @throws NullPointerException if <code>rhs</code> is null\n         if (c == 0.0 && d == 0.0) {\n             return NaN;\n         }\n-        \n+\n         if (rhs.isInfinite() && !isInfinite()) {\n             return ZERO;\n         }\n                 (imaginary - real * q) / denominator);\n         }\n     }\n-    \n+\n     /**\n      * Test for the equality of two Complex objects.\n      * <p>\n      * <p>\n      * All <code>NaN</code> values are considered to be equal - i.e, if either\n      * (or both) real and imaginary parts of the complex number are equal\n-     * to <code>Double.NaN</code>, the complex number is equal to \n+     * to <code>Double.NaN</code>, the complex number is equal to\n      * <code>Complex.NaN</code>.</p>\n      *\n      * @param other Object to test for equality to this\n      * @return true if two Complex objects are equal, false if\n      *         object is null, not an instance of Complex, or\n      *         not equal to this Complex instance\n-     * \n+     *\n      */\n     @Override\n     public boolean equals(Object other) {\n         boolean ret;\n-        \n-        if (this == other) { \n+\n+        if (this == other) {\n             ret = true;\n         } else if (other == null) {\n             ret = false;\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); \n+                    ret = (real == rhs.real) && (imaginary == rhs.imaginary);\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n                 ret = false;\n             }\n         }\n-      \n+\n         return ret;\n     }\n-    \n+\n     /**\n      * Get a hashCode for the complex number.\n      * <p>\n      * All NaN values have the same hash code.</p>\n-     * \n+     *\n      * @return a hash code value for this object\n      */\n     @Override\n         if (isNaN()) {\n             return 7;\n         }\n-        return 37 * (17 * MathUtils.hash(imaginary) + \n+        return 37 * (17 * MathUtils.hash(imaginary) +\n             MathUtils.hash(real));\n     }\n \n     public double getReal() {\n         return real;\n     }\n-    \n+\n     /**\n      * Returns true if either or both parts of this complex number is NaN;\n      * false otherwise\n      * false otherwise\n      */\n     public boolean isNaN() {\n-        return isNaN;        \n-    }\n-    \n+        return isNaN;\n+    }\n+\n     /**\n      * Returns true if either the real or imaginary part of this complex number\n-     * takes an infinite value (either <code>Double.POSITIVE_INFINITY</code> or \n+     * takes an infinite value (either <code>Double.POSITIVE_INFINITY</code> or\n      * <code>Double.NEGATIVE_INFINITY</code>) and neither part\n      * is <code>NaN</code>.\n-     * \n+     *\n      * @return true if one or both parts of this complex number are infinite\n      * and neither part is <code>NaN</code>\n      */\n     public boolean isInfinite() {\n-        return isInfinite;        \n-    }\n-    \n+        return isInfinite;\n+    }\n+\n     /**\n      * Return the product of this complex number and the given complex number.\n      * <p>\n      * Returns finite values in components of the result per the\n      * definitional formula in all remaining cases.\n      *  </p>\n-     * \n+     *\n      * @param rhs the other complex number\n      * @return the complex number product\n      * @throws NullPointerException if <code>rhs</code> is null\n         return createComplex(real * rhs.real - imaginary * rhs.imaginary,\n                 real * rhs.imaginary + imaginary * rhs.real);\n     }\n-    \n+\n     /**\n      * Return the product of this complex number and the given scalar number.\n      * <p>\n      * Returns finite values in components of the result per the\n      * definitional formula in all remaining cases.\n      *  </p>\n-     * \n+     *\n      * @param rhs the scalar number\n      * @return the complex number product\n      */\n         }\n         return createComplex(real * rhs, imaginary * rhs);\n     }\n-    \n+\n     /**\n      * Return the additive inverse of this complex number.\n      * <p>\n         if (isNaN()) {\n             return NaN;\n         }\n-        \n+\n         return createComplex(-real, -imaginary);\n     }\n-    \n+\n     /**\n      * Return the difference between this complex number and the given complex\n      * number.\n       * <p>\n-     * Uses the definitional formula \n+     * Uses the definitional formula\n      * <pre>\n      * (a + bi) - (c + di) = (a-c) + (b-d)i\n      * </pre></p>\n      * {@link #NaN} is returned; otherwise inifinite and NaN values are\n      * returned in the parts of the result according to the rules for\n      * {@link java.lang.Double} arithmetic. </p>\n-     * \n+     *\n      * @param rhs the other complex number\n      * @return the complex number difference\n      * @throws NullPointerException if <code>rhs</code> is null\n         if (isNaN() || rhs.isNaN()) {\n             return NaN;\n         }\n-        \n+\n         return createComplex(real - rhs.getReal(),\n             imaginary - rhs.getImaginary());\n     }\n-    \n-    /**\n-     * Compute the \n+\n+    /**\n+     * Compute the\n      * <a href=\"http://mathworld.wolfram.com/InverseCosine.html\" TARGET=\"_top\">\n      * inverse cosine</a> of this complex number.\n      * <p>\n      * Implements the formula: <pre>\n      * <code> acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))</code></pre></p>\n      * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is <code>NaN</code> or infinite.</p>\n-     * \n+     *\n      * @return the inverse cosine of this complex number\n      * @since 1.2\n      */\n         return this.add(this.sqrt1z().multiply(Complex.I)).log()\n               .multiply(Complex.I.negate());\n     }\n-    \n-    /**\n-     * Compute the \n+\n+    /**\n+     * Compute the\n      * <a href=\"http://mathworld.wolfram.com/InverseSine.html\" TARGET=\"_top\">\n      * inverse sine</a> of this complex number.\n      * <p>\n      * Implements the formula: <pre>\n      * <code> asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz)) </code></pre></p>\n      * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is <code>NaN</code> or infinite.</p>\n-     * \n+     *\n      * @return the inverse sine of this complex number.\n      * @since 1.2\n      */\n         return sqrt1z().add(this.multiply(Complex.I)).log()\n               .multiply(Complex.I.negate());\n     }\n-    \n-    /**\n-     * Compute the \n+\n+    /**\n+     * Compute the\n      * <a href=\"http://mathworld.wolfram.com/InverseTangent.html\" TARGET=\"_top\">\n      * inverse tangent</a> of this complex number.\n      * <p>\n      * Implements the formula: <pre>\n      * <code> atan(z) = (i/2) log((i + z)/(i - z)) </code></pre></p>\n      * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is <code>NaN</code> or infinite.</p>\n-     * \n+     *\n      * @return the inverse tangent of this complex number\n      * @since 1.2\n      */\n         if (isNaN()) {\n             return Complex.NaN;\n         }\n-        \n+\n         return this.add(Complex.I).divide(Complex.I.subtract(this)).log()\n             .multiply(Complex.I.divide(createComplex(2.0, 0.0)));\n     }\n-    \n-    /**\n-     * Compute the \n+\n+    /**\n+     * Compute the\n      * <a href=\"http://mathworld.wolfram.com/Cosine.html\" TARGET=\"_top\">\n      * cosine</a>\n      * of this complex number.\n      * Implements the formula: <pre>\n      * <code> cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i</code></pre>\n      * where the (real) functions on the right-hand side are\n-     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n      * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n      * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite values in real or imaginary parts of the input may result in\n      * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples: \n+     * Examples:\n      * <code>\n      * cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i\n      * cos(&plusmn;INFINITY + i) = NaN + NaN i\n      * cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n-     * \n+     *\n      * @return the cosine of this complex number\n      * @since 1.2\n      */\n         if (isNaN()) {\n             return Complex.NaN;\n         }\n-        \n+\n         return createComplex(Math.cos(real) * MathUtils.cosh(imaginary),\n             -Math.sin(real) * MathUtils.sinh(imaginary));\n     }\n-    \n-    /**\n-     * Compute the \n+\n+    /**\n+     * Compute the\n      * <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\" TARGET=\"_top\">\n      * hyperbolic cosine</a> of this complex number.\n      * <p>\n      * Implements the formula: <pre>\n      * <code> cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i</code></pre>\n      * where the (real) functions on the right-hand side are\n-     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n      * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n      * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite values in real or imaginary parts of the input may result in\n      * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples: \n+     * Examples:\n      * <code>\n      * cosh(1 &plusmn; INFINITY i) = NaN + NaN i\n      * cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i\n      * cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n-     * \n+     *\n      * @return the hyperbolic cosine of this complex number.\n      * @since 1.2\n      */\n         if (isNaN()) {\n             return Complex.NaN;\n         }\n-        \n+\n         return createComplex(MathUtils.cosh(real) * Math.cos(imaginary),\n             MathUtils.sinh(real) * Math.sin(imaginary));\n     }\n-    \n+\n     /**\n      * Compute the\n      * <a href=\"http://mathworld.wolfram.com/ExponentialFunction.html\" TARGET=\"_top\">\n      * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and\n      * {@link java.lang.Math#sin}.</p>\n      * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite values in real or imaginary parts of the input may result in\n      * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples: \n+     * Examples:\n      * <code>\n      * exp(1 &plusmn; INFINITY i) = NaN + NaN i\n      * exp(INFINITY + i) = INFINITY + INFINITY i\n      * exp(-INFINITY + i) = 0 + 0i\n      * exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n-     * \n+     *\n      * @return <i>e</i><sup><code>this</code></sup>\n      * @since 1.2\n      */\n         if (isNaN()) {\n             return Complex.NaN;\n         }\n-        \n+\n         double expReal = Math.exp(real);\n         return createComplex(expReal *  Math.cos(imaginary), expReal * Math.sin(imaginary));\n     }\n-    \n-    /**\n-     * Compute the \n+\n+    /**\n+     * Compute the\n      * <a href=\"http://mathworld.wolfram.com/NaturalLogarithm.html\" TARGET=\"_top\">\n      * natural logarithm</a> of this complex number.\n      * <p>\n      * <code>|a + bi|</code> is the modulus, {@link Complex#abs},  and\n      * <code>arg(a + bi) = {@link java.lang.Math#atan2}(b, a)</code></p>\n      * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite (or critical) values in real or imaginary parts of the input may\n      * result in infinite or NaN values returned in parts of the result.<pre>\n-     * Examples: \n+     * Examples:\n      * <code>\n      * log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i\n      * log(INFINITY + i) = INFINITY + 0i\n      * log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i\n      * log(0 + 0i) = -INFINITY + 0i\n      * </code></pre></p>\n-     * \n+     *\n      * @return ln of this complex number.\n      * @since 1.2\n      */\n         }\n \n         return createComplex(Math.log(abs()),\n-            Math.atan2(imaginary, real));        \n-    }\n-    \n+            Math.atan2(imaginary, real));\n+    }\n+\n     /**\n      * Returns of value of this complex number raised to the power of <code>x</code>.\n      * <p>\n      * Implements the formula: <pre>\n-     * <code> y<sup>x</sup> = exp(x&middot;log(y))</code></pre> \n+     * <code> y<sup>x</sup> = exp(x&middot;log(y))</code></pre>\n      * where <code>exp</code> and <code>log</code> are {@link #exp} and\n      * {@link #log}, respectively.</p>\n      * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is <code>NaN</code> or infinite, or if <code>y</code>\n      * equals {@link Complex#ZERO}.</p>\n-     * \n+     *\n      * @param x the exponent.\n      * @return <code>this</code><sup><code>x</code></sup>\n      * @throws NullPointerException if x is null\n         }\n         return this.log().multiply(x).exp();\n     }\n-    \n-    /**\n-     * Compute the \n+\n+    /**\n+     * Compute the\n      * <a href=\"http://mathworld.wolfram.com/Sine.html\" TARGET=\"_top\">\n      * sine</a>\n      * of this complex number.\n      * Implements the formula: <pre>\n      * <code> sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i</code></pre>\n      * where the (real) functions on the right-hand side are\n-     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n      * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n      * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite values in real or imaginary parts of the input may result in\n      * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples: \n+     * Examples:\n      * <code>\n      * sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i\n      * sin(&plusmn;INFINITY + i) = NaN + NaN i\n      * sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n-     * \n+     *\n      * @return the sine of this complex number.\n      * @since 1.2\n      */\n         if (isNaN()) {\n             return Complex.NaN;\n         }\n-        \n+\n         return createComplex(Math.sin(real) * MathUtils.cosh(imaginary),\n             Math.cos(real) * MathUtils.sinh(imaginary));\n     }\n-    \n-    /**\n-     * Compute the \n+\n+    /**\n+     * Compute the\n      * <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\" TARGET=\"_top\">\n      * hyperbolic sine</a> of this complex number.\n      * <p>\n      * Implements the formula: <pre>\n      * <code> sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i</code></pre>\n      * where the (real) functions on the right-hand side are\n-     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n      * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n      * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite values in real or imaginary parts of the input may result in\n      * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples: \n+     * Examples:\n      * <code>\n      * sinh(1 &plusmn; INFINITY i) = NaN + NaN i\n      * sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i\n      * sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n-     * \n+     *\n      * @return the hyperbolic sine of this complex number\n      * @since 1.2\n      */\n         if (isNaN()) {\n             return Complex.NaN;\n         }\n-        \n+\n         return createComplex(MathUtils.sinh(real) * Math.cos(imaginary),\n             MathUtils.cosh(real) * Math.sin(imaginary));\n     }\n-    \n-    /**\n-     * Compute the \n+\n+    /**\n+     * Compute the\n      * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n      * square root</a> of this complex number.\n      * <p>\n-     * Implements the following algorithm to compute <code>sqrt(a + bi)</code>: \n+     * Implements the following algorithm to compute <code>sqrt(a + bi)</code>:\n      * <ol><li>Let <code>t = sqrt((|a| + |a + bi|) / 2)</code></li>\n      * <li><pre>if <code> a &#8805; 0</code> return <code>t + (b/2t)i</code>\n      *  else return <code>|b|/2t + sign(b)t i </code></pre></li>\n      * <li><code>sign(b) =  {@link MathUtils#indicator}(b) </code>\n      * </ul></p>\n      * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite values in real or imaginary parts of the input may result in\n      * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples: \n+     * Examples:\n      * <code>\n      * sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i\n      * sqrt(INFINITY + i) = INFINITY + 0i\n      * sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i\n      * sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i\n      * </code></pre></p>\n-     * \n+     *\n      * @return the square root of this complex number\n      * @since 1.2\n      */\n         if (isNaN()) {\n             return Complex.NaN;\n         }\n-        \n+\n         if (real == 0.0 && imaginary == 0.0) {\n             return createComplex(0.0, 0.0);\n         }\n-        \n+\n         double t = Math.sqrt((Math.abs(real) + abs()) / 2.0);\n         if (real >= 0.0) {\n             return createComplex(t, imaginary / (2.0 * t));\n                 MathUtils.indicator(imaginary) * t);\n         }\n     }\n-    \n-    /**\n-     * Compute the \n+\n+    /**\n+     * Compute the\n      * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n      * square root</a> of 1 - <code>this</code><sup>2</sup> for this complex\n      * number.\n      * <p>\n-     * Computes the result directly as \n+     * Computes the result directly as\n      * <code>sqrt(Complex.ONE.subtract(z.multiply(z)))</code>.</p>\n      * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite values in real or imaginary parts of the input may result in\n      * infinite or NaN values returned in parts of the result.</p>\n-     * \n+     *\n      * @return the square root of 1 - <code>this</code><sup>2</sup>\n      * @since 1.2\n      */\n     public Complex sqrt1z() {\n         return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n     }\n-    \n-    /**\n-     * Compute the \n+\n+    /**\n+     * Compute the\n      * <a href=\"http://mathworld.wolfram.com/Tangent.html\" TARGET=\"_top\">\n      * tangent</a> of this complex number.\n      * <p>\n      * Implements the formula: <pre>\n      * <code>tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i</code></pre>\n      * where the (real) functions on the right-hand side are\n-     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n      * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n      * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite (or critical) values in real or imaginary parts of the input may\n      * result in infinite or NaN values returned in parts of the result.<pre>\n-     * Examples: \n+     * Examples:\n      * <code>\n      * tan(1 &plusmn; INFINITY i) = 0 + NaN i\n      * tan(&plusmn;INFINITY + i) = NaN + NaN i\n      * tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n      * tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i</code></pre></p>\n-     * \n+     *\n      * @return the tangent of this complex number\n      * @since 1.2\n      */\n         if (isNaN()) {\n             return Complex.NaN;\n         }\n-        \n+\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n         double d = Math.cos(real2) + MathUtils.cosh(imaginary2);\n-        \n+\n         return createComplex(Math.sin(real2) / d, MathUtils.sinh(imaginary2) / d);\n     }\n-    \n+\n     /**\n      * Compute the\n      * <a href=\"http://mathworld.wolfram.com/HyperbolicTangent.html\" TARGET=\"_top\">\n      * Implements the formula: <pre>\n      * <code>tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i</code></pre>\n      * where the (real) functions on the right-hand side are\n-     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos},\n      * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n      * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * Returns {@link Complex#NaN} if either real or imaginary part of the\n      * input argument is <code>NaN</code>.</p>\n      * <p>\n      * Infinite values in real or imaginary parts of the input may result in\n      * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples: \n+     * Examples:\n      * <code>\n      * tanh(1 &plusmn; INFINITY i) = NaN + NaN i\n      * tanh(&plusmn;INFINITY + i) = NaN + 0 i\n         if (isNaN()) {\n             return Complex.NaN;\n         }\n-        \n+\n         double real2 = 2.0 * real;\n         double imaginary2 = 2.0 * imaginary;\n         double d = MathUtils.cosh(real2) + Math.cos(imaginary2);\n-        \n+\n         return createComplex(MathUtils.sinh(real2) / d, Math.sin(imaginary2) / d);\n     }\n-    \n-    \n-    \n+\n+\n+\n     /**\n      * <p>Compute the argument of this complex number.\n      * </p>\n      * <p>The argument is the angle phi between the positive real axis and the point\n-     * representing this number in the complex plane. The value returned is between -PI (not inclusive) \n+     * representing this number in the complex plane. The value returned is between -PI (not inclusive)\n      * and PI (inclusive), with negative values returned for numbers with negative imaginary parts.\n      * </p>\n      * <p>If either real or imaginary part (or both) is NaN, NaN is returned.  Infinite parts are handled\n      * as java.Math.atan2 handles them, essentially treating finite parts as zero in the presence of\n      * an infinite coordinate and returning a multiple of pi/4 depending on the signs of the infinite\n      * parts.  See the javadoc for java.Math.atan2 for full details.</p>\n-     * \n+     *\n      * @return the argument of this complex number\n      */\n     public double getArgument() {\n         return Math.atan2(getImaginary(), getReal());\n     }\n-    \n+\n     /**\n      * <p>Computes the n-th roots of this complex number.\n      * </p>\n      *  {@link #NaN} is returned.</p>\n      * <p>if neither part is NaN, but at least one part is infinite, the result is a one-element\n      * list containing {@link #INF}.</p>\n-     * \n+     *\n      * @param n degree of root\n      * @return List<Complex> all nth roots of this complex number\n      * @throws IllegalArgumentException if parameter n is less than or equal to 0\n                     \"cannot compute nth root for null or negative n: {0}\",\n                     n);\n         }\n-        \n+\n         List<Complex> result = new ArrayList<Complex>();\n-        \n+\n         if (isNaN()) {\n             result.add(Complex.NaN);\n             return result;\n         }\n-        \n+\n         if (isInfinite()) {\n             result.add(Complex.INF);\n             return result;\n \n     /**\n      * <p>Resolve the transient fields in a deserialized Complex Object.</p>\n-     * <p>Subclasses will need to override {@link #createComplex} to deserialize properly</p> \n+     * <p>Subclasses will need to override {@link #createComplex} to deserialize properly</p>\n      * @return A Complex instance with all fields resolved.\n      * @since 2.0\n      */\n     protected final Object readResolve() {\n         return createComplex(real, imaginary);\n     }\n-    \n+\n     /** {@inheritDoc} */\n     public ComplexField getField() {\n         return ComplexField.getInstance();\n--- a/src/main/java/org/apache/commons/math/complex/ComplexField.java\n+++ b/src/main/java/org/apache/commons/math/complex/ComplexField.java\n      */\n     private Object readResolve() {\n         // return the singleton instance\n-        return LazyHolder.INSTANCE; \n+        return LazyHolder.INSTANCE;\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/main/java/org/apache/commons/math/complex/ComplexFormat.java\n  * @version $Revision$ $Date$\n  */\n public class ComplexFormat extends CompositeFormat {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -3343698360149467646L;\n \n      /** The default imaginary character. */\n     private static final String DEFAULT_IMAGINARY_CHARACTER = \"i\";\n-    \n+\n     /** The notation used to signify the imaginary part of the complex number. */\n     private String imaginaryCharacter;\n-    \n+\n     /** The format used for the imaginary part. */\n     private NumberFormat imaginaryFormat;\n \n     /** The format used for the real part. */\n     private NumberFormat realFormat;\n-    \n+\n     /**\n      * Create an instance with the default imaginary character, 'i', and the\n      * default number format for both real and imaginary parts.\n     public ComplexFormat(NumberFormat format) {\n         this(DEFAULT_IMAGINARY_CHARACTER, format);\n     }\n-    \n+\n     /**\n      * Create an instance with a custom number format for the real part and a\n      * custom number format for the imaginary part.\n     public ComplexFormat(NumberFormat realFormat, NumberFormat imaginaryFormat) {\n         this(DEFAULT_IMAGINARY_CHARACTER, realFormat, imaginaryFormat);\n     }\n-    \n+\n     /**\n      * Create an instance with a custom imaginary character, and the default\n      * number format for both real and imaginary parts.\n     public ComplexFormat(String imaginaryCharacter) {\n         this(imaginaryCharacter, getDefaultNumberFormat());\n     }\n-    \n+\n     /**\n      * Create an instance with a custom imaginary character, and a custom number\n      * format for both real and imaginary parts.\n     public ComplexFormat(String imaginaryCharacter, NumberFormat format) {\n         this(imaginaryCharacter, format, (NumberFormat)format.clone());\n     }\n-    \n+\n     /**\n      * Create an instance with a custom imaginary character, a custom number\n      * format for the real part, and a custom number format for the imaginary\n \n     /**\n      * Get the set of locales for which complex formats are available.\n-     * <p>This is the same set as the {@link NumberFormat} set.</p> \n+     * <p>This is the same set as the {@link NumberFormat} set.</p>\n      * @return available complex format locales.\n      */\n     public static Locale[] getAvailableLocales() {\n     public static String formatComplex(Complex c) {\n         return getInstance().format(c);\n     }\n-    \n+\n     /**\n      * Formats a {@link Complex} object to produce a string.\n      *\n      */\n     public StringBuffer format(Complex complex, StringBuffer toAppendTo,\n             FieldPosition pos) {\n-        \n+\n         pos.setBeginIndex(0);\n         pos.setEndIndex(0);\n \n         // format real\n         double re = complex.getReal();\n         formatDouble(re, getRealFormat(), toAppendTo, pos);\n-        \n+\n         // format sign and imaginary\n         double im = complex.getImaginary();\n         if (im < 0.0) {\n             formatDouble(im, getImaginaryFormat(), toAppendTo, pos);\n             toAppendTo.append(getImaginaryCharacter());\n         }\n-        \n+\n         return toAppendTo;\n     }\n-    \n-    /**\n-     * Formats a object to produce a string.  <code>obj</code> must be either a \n+\n+    /**\n+     * Formats a object to produce a string.  <code>obj</code> must be either a\n      * {@link Complex} object or a {@link Number} object.  Any other type of\n      * object will result in an {@link IllegalArgumentException} being thrown.\n      *\n     @Override\n     public StringBuffer format(Object obj, StringBuffer toAppendTo,\n             FieldPosition pos) {\n-        \n+\n         StringBuffer ret = null;\n-        \n+\n         if (obj instanceof Complex) {\n             ret = format( (Complex)obj, toAppendTo, pos);\n         } else if (obj instanceof Number) {\n             ret = format( new Complex(((Number)obj).doubleValue(), 0.0),\n                 toAppendTo, pos);\n-        } else { \n+        } else {\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"cannot format a {0} instance as a complex number\",\n                   obj.getClass().getName());\n         }\n-        \n+\n         return ret;\n     }\n \n     public String getImaginaryCharacter() {\n         return imaginaryCharacter;\n     }\n-    \n+\n     /**\n      * Access the imaginaryFormat.\n      * @return the imaginaryFormat.\n     public NumberFormat getImaginaryFormat() {\n         return imaginaryFormat;\n     }\n-    \n+\n     /**\n      * Returns the default complex format for the current locale.\n      * @return the default complex format.\n     public static ComplexFormat getInstance() {\n         return getInstance(Locale.getDefault());\n     }\n-    \n+\n     /**\n      * Returns the default complex format for the given locale.\n      * @param locale the specific locale used by the format.\n         NumberFormat f = getDefaultNumberFormat(locale);\n         return new ComplexFormat(f);\n     }\n-    \n+\n     /**\n      * Access the realFormat.\n      * @return the realFormat.\n         }\n         return result;\n     }\n-    \n+\n     /**\n      * Parses a string to produce a {@link Complex} object.\n      *\n         return new Complex(re.doubleValue(), im.doubleValue() * sign);\n \n     }\n-     \n+\n     /**\n      * Parses a string to produce a object.\n      *\n         }\n         this.imaginaryCharacter = imaginaryCharacter;\n     }\n-    \n+\n     /**\n      * Modify the imaginaryFormat.\n      * @param imaginaryFormat The new imaginaryFormat value.\n         }\n         this.imaginaryFormat = imaginaryFormat;\n     }\n-    \n+\n     /**\n      * Modify the realFormat.\n      * @param realFormat The new realFormat value.\n--- a/src/main/java/org/apache/commons/math/complex/ComplexUtils.java\n+++ b/src/main/java/org/apache/commons/math/complex/ComplexUtils.java\n import org.apache.commons.math.MathRuntimeException;\n \n /**\n- * Static implementations of common \n+ * Static implementations of common\n  * {@link org.apache.commons.math.complex.Complex} utilities functions.\n  *\n  * @version $Revision$ $Date$\n  */\n public class ComplexUtils {\n-    \n+\n     /**\n      * Default constructor.\n      */\n     private ComplexUtils() {\n         super();\n     }\n-    \n+\n     /**\n      * Creates a complex number from the given polar representation.\n      * <p>\n      * The value returned is <code>r&middot;e<sup>i&middot;theta</sup></code>,\n      * computed as <code>r&middot;cos(theta) + r&middot;sin(theta)i</code></p>\n      * <p>\n-     * If either <code>r</code> or <code>theta</code> is NaN, or \n+     * If either <code>r</code> or <code>theta</code> is NaN, or\n      * <code>theta</code> is infinite, {@link Complex#NaN} is returned.</p>\n      * <p>\n-     * If <code>r</code> is infinite and <code>theta</code> is finite, \n+     * If <code>r</code> is infinite and <code>theta</code> is finite,\n      * infinite or NaN values may be returned in parts of the result, following\n      * the rules for double arithmetic.<pre>\n-     * Examples: \n+     * Examples:\n      * <code>\n      * polar2Complex(INFINITY, &pi;/4) = INFINITY + INFINITY i\n      * polar2Complex(INFINITY, 0) = INFINITY + NaN i\n      * polar2Complex(INFINITY, -&pi;/4) = INFINITY - INFINITY i\n      * polar2Complex(INFINITY, 5&pi;/4) = -INFINITY - INFINITY i </code></pre></p>\n-     * \n+     *\n      * @param r the modulus of the complex number to create\n      * @param theta  the argument of the complex number to create\n      * @return <code>r&middot;e<sup>i&middot;theta</sup></code>\n         }\n         return new Complex(r * Math.cos(theta), r * Math.sin(theta));\n     }\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n  * Base class for continuous distributions.  Default implementations are\n  * provided for some of the methods that do not vary from distribution to\n  * distribution.\n- *  \n+ *\n  * @version $Revision$ $Date$\n  */\n public abstract class AbstractContinuousDistribution\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -38038050983108802L;\n-    \n+\n     /**\n      * Default constructor.\n      */\n                 }\n             }\n         };\n-              \n-        // Try to bracket root, test domain endoints if this fails     \n+\n+        // Try to bracket root, test domain endoints if this fails\n         double lowerBound = getDomainLowerBound(p);\n         double upperBound = getDomainUpperBound(p);\n         double[] bracket = null;\n                     rootFindingFunction, getInitialDomain(p),\n                     lowerBound, upperBound);\n         }  catch (ConvergenceException ex) {\n-            /* \n+            /*\n              * Check domain endpoints to see if one gives value that is within\n              * the default solver's defaultAbsoluteAccuracy of 0 (will be the\n              * case if density has bounded support and p is 0 or 1).\n-             * \n+             *\n              * TODO: expose the default solver, defaultAbsoluteAccuracy as\n              * a constant.\n-             */ \n+             */\n             if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) {\n                 return lowerBound;\n             }\n             if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) {\n                 return upperBound;\n-            }     \n+            }\n             // Failed bracket convergence was not because of corner solution\n             throw new MathException(ex);\n         }\n      * Access the initial domain value, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n      */\n     protected abstract double getDomainLowerBound(double p);\n \n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n      */\n     protected abstract double getDomainUpperBound(double p);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractDistribution.java\n import org.apache.commons.math.MathRuntimeException;\n \n /**\n- * Base class for probability distributions.   \n- *  \n+ * Base class for probability distributions.\n+ *\n  * @version $Revision$ $Date$\n  */\n public abstract class AbstractDistribution\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -38038050983108802L;\n-    \n+\n     /**\n      * Default constructor.\n      */\n      * The default implementation uses the identity</p>\n      * <p>\n      * P(x0 &le; X &le; x1) = P(X &le; x1) - P(X &le; x0) </p>\n-     * \n+     *\n      * @param x0 the (inclusive) lower bound\n      * @param x1 the (inclusive) upper bound\n      * @return the probability that a random variable with this distribution\n--- a/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n  * Base class for integer-valued discrete distributions.  Default\n  * implementations are provided for some of the methods that do not vary\n  * from distribution to distribution.\n- *  \n+ *\n  * @version $Revision$ $Date$\n  */\n public abstract class AbstractIntegerDistribution extends AbstractDistribution\n     implements IntegerDistribution, Serializable {\n-        \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -1146319659338487221L;\n-    \n+\n     /**\n      * Default constructor.\n      */\n     protected AbstractIntegerDistribution() {\n         super();\n     }\n-    \n+\n     /**\n      * For a random variable X whose values are distributed according\n      * to this distribution, this method returns P(X &le; x).  In other words,\n      * this method represents the  (cumulative) distribution function, or\n      * CDF, for this distribution.\n      * <p>\n-     * If <code>x</code> does not represent an integer value, the CDF is \n+     * If <code>x</code> does not represent an integer value, the CDF is\n      * evaluated at the greatest integer less than x.\n-     * \n+     *\n      * @param x the value at which the distribution function is evaluated.\n      * @return cumulative probability that a random variable with this\n      * distribution takes a value less than or equal to <code>x</code>\n      * computed due to convergence or other numerical errors.\n      */\n     public double cumulativeProbability(double x) throws MathException {\n-        return cumulativeProbability((int) Math.floor(x));  \n-    }\n-    \n+        return cumulativeProbability((int) Math.floor(x));\n+    }\n+\n     /**\n      * For a random variable X whose values are distributed according\n      * to this distribution, this method returns P(x0 &le; X &le; x1).\n-     * \n+     *\n      * @param x0 the (inclusive) lower bound\n      * @param x1 the (inclusive) upper bound\n      * @return the probability that a random variable with this distribution\n                (int) Math.floor(x1)); // don't want to count mass below x0\n         } else { // x0 is mathematical integer, so use as is\n             return cumulativeProbability((int) Math.floor(x0),\n-                (int) Math.floor(x1)); \n-        }\n-    }\n-    \n+                (int) Math.floor(x1));\n+        }\n+    }\n+\n     /**\n      * For a random variable X whose values are distributed according\n      * to this distribution, this method returns P(X &le; x).  In other words,\n      * this method represents the probability distribution function, or PDF,\n      * for this distribution.\n-     * \n+     *\n      * @param x the value at which the PDF is evaluated.\n-     * @return PDF for this distribution. \n+     * @return PDF for this distribution.\n      * @throws MathException if the cumulative probability can not be\n      *            computed due to convergence or other numerical errors.\n      */\n     abstract public double cumulativeProbability(int x) throws MathException;\n-    \n+\n     /**\n      * For a random variable X whose values are distributed according\n      * to this distribution, this method returns P(X = x). In other words, this\n      * method represents the probability mass function,  or PMF, for the distribution.\n      * <p>\n      * If <code>x</code> does not represent an integer value, 0 is returned.\n-     * \n+     *\n      * @param x the value at which the probability density function is evaluated\n      * @return the value of the probability density function at x\n      */\n             return 0;\n         }\n     }\n-    \n+\n     /**\n     * For a random variable X whose values are distributed according\n      * to this distribution, this method returns P(x0 &le; X &le; x1).\n-     * \n+     *\n      * @param x0 the inclusive, lower bound\n      * @param x1 the inclusive, upper bound\n-     * @return the cumulative probability. \n+     * @return the cumulative probability.\n      * @throws MathException if the cumulative probability can not be\n      *            computed due to convergence or other numerical errors.\n      * @throws IllegalArgumentException if x0 > x1\n         }\n         return cumulativeProbability(x1) - cumulativeProbability(x0 - 1);\n     }\n-    \n+\n     /**\n      * For a random variable X whose values are distributed according\n      * to this distribution, this method returns the largest x, such\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n         }\n-        \n+\n         // by default, do simple bisection.\n         // subclasses can override if there is a better method.\n         int x0 = getDomainLowerBound(p);\n                 }\n             }\n         }\n-        \n+\n         // insure x0 is the correct critical point\n         pm = cumulativeProbability(x0);\n         while (pm > p) {\n             --x0;\n             pm = cumulativeProbability(x0);\n         }\n-    \n-        return x0;        \n-    }\n-    \n+\n+        return x0;\n+    }\n+\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a PDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n      */\n     protected abstract int getDomainLowerBound(double p);\n-    \n+\n     /**\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a PDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n      */\n     protected abstract int getDomainUpperBound(double p);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java\n      * @return the number of trials.\n      */\n     int getNumberOfTrials();\n-    \n+\n     /**\n      * Access the probability of success for this distribution.\n      * @return the probability of success.\n      */\n     double getProbabilityOfSuccess();\n-    \n+\n     /**\n      * Change the number of trials for this distribution.\n      * @param trials the new number of trials.\n      */\n     void setNumberOfTrials(int trials);\n-    \n+\n     /**\n      * Change the probability of success for this distribution.\n      * @param p the new probability of success.\n      */\n     void setProbabilityOfSuccess(double p);\n-}\n+}\n--- a/src/main/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a PDF root.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n      */\n     @Override\n     protected int getDomainLowerBound(double p) {\n     /**\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a PDF root.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n      */\n     @Override\n     protected int getDomainUpperBound(double p) {\n     /**\n      * For this distribution, X, this method returns P(X &le; x).\n      * @param x the value at which the PDF is evaluated.\n-     * @return PDF for this distribution. \n+     * @return PDF for this distribution.\n      * @throws MathException if the cumulative probability can not be\n      *            computed due to convergence or other numerical errors.\n      */\n \n     /**\n      * For this distribution, X, this method returns P(X = x).\n-     * \n+     *\n      * @param x the value at which the PMF is evaluated.\n-     * @return PMF for this distribution. \n+     * @return PMF for this distribution.\n      */\n     public double probability(int x) {\n         double ret;\n         }\n         return ret;\n     }\n-    \n+\n     /**\n      * For this distribution, X, this method returns the largest x, such\n      * that P(X &le; x) &le; <code>p</code>.\n         // handle extreme values explicitly\n         if (p == 0) {\n             return -1;\n-        } \n+        }\n         if (p == 1) {\n-            return Integer.MAX_VALUE; \n+            return Integer.MAX_VALUE;\n         }\n-        \n+\n         // use default bisection impl\n         return super.inverseCumulativeProbability(p);\n     }\n--- a/src/main/java/org/apache/commons/math/distribution/CauchyDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/CauchyDistribution.java\n  * @version $Revision$ $Date$\n  */\n public interface CauchyDistribution extends ContinuousDistribution {\n-    \n+\n     /**\n      * Access the median.\n      * @return median for this distribution\n      */\n     double getMedian();\n-    \n+\n     /**\n      * Access the scale parameter.\n      * @return scale parameter for this distribution\n      */\n     double getScale();\n-    \n+\n     /**\n      * Modify the median.\n      * @param median for this distribution\n      */\n     void setMedian(double median);\n-    \n+\n     /**\n      * Modify the scale parameter.\n      * @param s scale parameter for this distribution\n--- a/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n  * @since 1.1\n  * @version $Revision$ $Date$\n  */\n-public class CauchyDistributionImpl extends AbstractContinuousDistribution \n+public class CauchyDistributionImpl extends AbstractContinuousDistribution\n         implements CauchyDistribution, Serializable {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 8589540077390120676L;\n \n     /** The median of this distribution. */\n     private double median = 0;\n-    \n+\n     /** The scale of this distribution. */\n     private double scale = 1;\n-    \n+\n     /**\n      * Creates cauchy distribution with the medain equal to zero and scale\n-     * equal to one. \n+     * equal to one.\n      */\n     public CauchyDistributionImpl(){\n         this(0.0, 1.0);\n     }\n-    \n+\n     /**\n      * Create a cauchy distribution using the given median and scale.\n      * @param median median for this distribution\n     /**\n      * For this distribution, X, this method returns P(X &lt; <code>x</code>).\n      * @param x the value at which the CDF is evaluated.\n-     * @return CDF evaluted at <code>x</code>. \n+     * @return CDF evaluted at <code>x</code>.\n      */\n     public double cumulativeProbability(double x) {\n         return 0.5 + (Math.atan((x - median) / scale) / Math.PI);\n     }\n-    \n+\n     /**\n      * Access the median.\n      * @return median for this distribution\n-     */ \n+     */\n     public double getMedian() {\n         return median;\n     }\n     public double getScale() {\n         return scale;\n     }\n-    \n+\n     /**\n      * For this distribution, X, this method returns the critical point x, such\n      * that P(X &lt; x) = <code>p</code>.\n      * <p>\n-     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and \n+     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and\n      * <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n      *\n      * @param p the desired probability\n         }\n         return ret;\n     }\n-    \n+\n     /**\n      * Modify the median.\n      * @param median for this distribution\n         if (s <= 0.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"scale must be positive ({0})\", s);\n-        }       \n+        }\n         scale = s;\n     }\n-    \n+\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n      */\n     @Override\n     protected double getDomainLowerBound(double p) {\n         } else {\n             ret = getMedian();\n         }\n-        \n+\n         return ret;\n     }\n \n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n      */\n     @Override\n     protected double getDomainUpperBound(double p) {\n         } else {\n             ret = Double.MAX_VALUE;\n         }\n-        \n+\n         return ret;\n     }\n \n      * Access the initial domain value, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n         } else {\n             ret = getMedian();\n         }\n-        \n+\n         return ret;\n     }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java\n      * @param degreesOfFreedom the new degrees of freedom.\n      */\n     void setDegreesOfFreedom(double degreesOfFreedom);\n-    \n+\n     /**\n      * Access the degrees of freedom.\n      * @return the degrees of freedom.\n      * @return  The pdf at point x.\n      */\n     double density(Double x);\n-}\n+}\n--- a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n public class ChiSquaredDistributionImpl\n     extends AbstractContinuousDistribution\n     implements ChiSquaredDistribution, Serializable  {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -8352658048349159782L;\n \n-    /** Internal Gamma distribution. */    \n+    /** Internal Gamma distribution. */\n     private GammaDistribution gamma;\n-    \n+\n     /**\n      * Create a Chi-Squared distribution with the given degrees of freedom.\n      * @param df degrees of freedom.\n     public ChiSquaredDistributionImpl(double df) {\n         this(df, new GammaDistributionImpl(df / 2.0, 2.0));\n     }\n-    \n+\n     /**\n      * Create a Chi-Squared distribution with the given degrees of freedom.\n      * @param df degrees of freedom.\n         setGamma(g);\n         setDegreesOfFreedom(df);\n     }\n-    \n+\n     /**\n      * Modify the degrees of freedom.\n      * @param degreesOfFreedom the new degrees of freedom.\n     public void setDegreesOfFreedom(double degreesOfFreedom) {\n         getGamma().setAlpha(degreesOfFreedom / 2.0);\n     }\n-        \n+\n     /**\n      * Access the degrees of freedom.\n      * @return the degrees of freedom.\n     /**\n      * For this distribution, X, this method returns P(X &lt; x).\n      * @param x the value at which the CDF is evaluated.\n-     * @return CDF for this distribution. \n+     * @return CDF for this distribution.\n      * @throws MathException if the cumulative probability can not be\n      *            computed due to convergence or other numerical errors.\n      */\n     public double cumulativeProbability(double x) throws MathException {\n         return getGamma().cumulativeProbability(x);\n     }\n-    \n+\n     /**\n      * For this distribution, X, this method returns the critical point x, such\n      * that P(X &lt; x) = <code>p</code>.\n         }\n         return super.inverseCumulativeProbability(p);\n     }\n-        \n+\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n      */\n     @Override\n     protected double getDomainLowerBound(double p) {\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n      */\n     @Override\n     protected double getDomainUpperBound(double p) {\n             // use max\n             ret = Double.MAX_VALUE;\n         }\n-        \n+\n         return ret;\n     }\n \n      * Access the initial domain value, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n     protected double getInitialDomain(double p) {\n         // NOTE: chi squared is skewed to the left\n         // NOTE: therefore, P(X < &mu;) > .5\n-        \n+\n         double ret;\n \n         if (p < .5) {\n             // use mean\n             ret = getDegreesOfFreedom();\n         }\n-        \n+\n         return ret;\n     }\n-    \n+\n     /**\n      * Modify the underlying gamma distribution.  The caller is responsible for\n      * insuring the gamma distribution has the proper parameter settings.\n      */\n     public void setGamma(GammaDistribution g) {\n         this.gamma = g;\n-        \n+\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/distribution/ContinuousDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ContinuousDistribution.java\n  * @version $Revision$ $Date$\n  */\n public interface ContinuousDistribution extends Distribution {\n-    \n+\n     /**\n      * For this distribution, X, this method returns x such that P(X &lt; x) = p.\n      * @param p the cumulative probability.\n-     * @return x. \n+     * @return x.\n      * @throws MathException if the inverse cumulative probability can not be\n      *            computed due to convergence or other numerical errors.\n      */\n--- a/src/main/java/org/apache/commons/math/distribution/DiscreteDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/DiscreteDistribution.java\n      * For a random variable X whose values are distributed according\n      * to this distribution, this method returns P(X = x). In other words, this\n      * method represents the probability mass function, or PMF for the distribution.\n-     * \n+     *\n      * @param x the value at which the probability mass function is evaluated.\n      * @return the value of the probability mass function at x\n      */\n--- a/src/main/java/org/apache/commons/math/distribution/Distribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/Distribution.java\n      * to this distribution, this method returns P(X &le; x).  In other words,\n      * this method represents the  (cumulative) distribution function, or\n      * CDF, for this distribution.\n-     * \n+     *\n      * @param x the value at which the distribution function is evaluated.\n      * @return the probability that a random variable with this\n      * distribution takes a value less than or equal to <code>x</code>\n      * computed due to convergence or other numerical errors.\n      */\n     double cumulativeProbability(double x) throws MathException;\n-    \n+\n     /**\n      * For a random variable X whose values are distributed according\n      * to this distribution, this method returns P(x0 &le; X &le; x1).\n-     * \n+     *\n      * @param x0 the (inclusive) lower bound\n      * @param x1 the (inclusive) upper bound\n      * @return the probability that a random variable with this distribution\n-     * will take a value between <code>x0</code> and <code>x1</code>, \n+     * will take a value between <code>x0</code> and <code>x1</code>,\n      * including the endpoints\n      * @throws MathException if the cumulative probability can not be\n      * computed due to convergence or other numerical errors.\n--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java\n      * @param mean the new mean.\n      */\n     void setMean(double mean);\n-    \n+\n     /**\n      * Access the mean.\n      * @return the mean.\n      * @return  The pdf at point x.\n      */\n     double density(Double x);\n-}\n+}\n--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = 2401296428283614780L;\n-    \n+\n     /** The mean of this distribution. */\n     private double mean;\n-    \n+\n     /**\n      * Create a exponential distribution with the given mean.\n      * @param mean mean of this distribution.\n \n     /**\n      * For this distribution, X, this method returns P(X &lt; x).\n-     * \n+     *\n      * The implementation of this method is based on:\n      * <ul>\n      * <li>\n      * <a href=\"http://mathworld.wolfram.com/ExponentialDistribution.html\">\n      * Exponential Distribution</a>, equation (1).</li>\n      * </ul>\n-     * \n+     *\n      * @param x the value at which the CDF is evaluated.\n      * @return CDF for this distribution.\n      * @throws MathException if the cumulative probability can not be\n         }\n         return ret;\n     }\n-    \n+\n     /**\n      * For this distribution, X, this method returns the critical point x, such\n      * that P(X &lt; x) = <code>p</code>.\n      * <p>\n      * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n-     * \n+     *\n      * @param p the desired probability\n      * @return x, such that P(X &lt; x) = <code>p</code>\n      * @throws MathException if the inverse cumulative probability can not be\n     @Override\n     public double inverseCumulativeProbability(double p) throws MathException {\n         double ret;\n-        \n+\n         if (p < 0.0 || p > 1.0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n         } else {\n             ret = -getMean() * Math.log(1.0 - p);\n         }\n-        \n+\n         return ret;\n     }\n-    \n+\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n-     * bracket a CDF root.   \n-     * \n+     * bracket a CDF root.\n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n      *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n     protected double getDomainLowerBound(double p) {\n         return 0;\n     }\n-    \n+\n     /**\n      * Access the domain value upper bound, based on <code>p</code>, used to\n-     * bracket a CDF root.   \n-     * \n+     * bracket a CDF root.\n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n      */\n     @Override\n     protected double getDomainUpperBound(double p) {\n             return Double.MAX_VALUE;\n         }\n     }\n-    \n+\n     /**\n      * Access the initial domain value, based on <code>p</code>, used to\n-     * bracket a CDF root.   \n-     * \n+     * bracket a CDF root.\n+     *\n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n--- a/src/main/java/org/apache/commons/math/distribution/FDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/FDistribution.java\n      * @param degreesOfFreedom the new numerator degrees of freedom.\n      */\n     void setNumeratorDegreesOfFreedom(double degreesOfFreedom);\n-    \n+\n     /**\n      * Access the numerator degrees of freedom.\n      * @return the numerator degrees of freedom.\n      */\n     double getNumeratorDegreesOfFreedom();\n-    \n+\n     /**\n      * Modify the denominator degrees of freedom.\n      * @param degreesOfFreedom the new denominator degrees of freedom.\n      */\n     void setDenominatorDegreesOfFreedom(double degreesOfFreedom);\n-    \n+\n     /**\n      * Access the denominator degrees of freedom.\n      * @return the denominator degrees of freedom.\n--- a/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n \n     /** The numerator degrees of freedom*/\n     private double denominatorDegreesOfFreedom;\n-    \n+\n     /**\n      * Create a F distribution using the given degrees of freedom.\n      * @param numeratorDegreesOfFreedom the numerator degrees of freedom.\n         setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);\n         setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n     }\n-    \n+\n     /**\n      * For this distribution, X, this method returns P(X &lt; x).\n-     * \n+     *\n      * The implementation of this method is based on:\n      * <ul>\n      * <li>\n      * <a href=\"http://mathworld.wolfram.com/F-Distribution.html\">\n      * F-Distribution</a>, equation (4).</li>\n      * </ul>\n-     * \n+     *\n      * @param x the value at which the CDF is evaluated.\n-     * @return CDF for this distribution. \n+     * @return CDF for this distribution.\n      * @throws MathException if the cumulative probability can not be\n      *            computed due to convergence or other numerical errors.\n      */\n         } else {\n             double n = getNumeratorDegreesOfFreedom();\n             double m = getDenominatorDegreesOfFreedom();\n-            \n+\n             ret = Beta.regularizedBeta((n * x) / (m + n * x),\n                 0.5 * n,\n                 0.5 * m);\n         }\n         return ret;\n     }\n-    \n+\n     /**\n      * For this distribution, X, this method returns the critical point x, such\n      * that P(X &lt; x) = <code>p</code>.\n      *         probability.\n      */\n     @Override\n-    public double inverseCumulativeProbability(final double p) \n+    public double inverseCumulativeProbability(final double p)\n         throws MathException {\n         if (p == 0) {\n             return 0d;\n         }\n         return super.inverseCumulativeProbability(p);\n     }\n-        \n+\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n      */\n     @Override\n     protected double getDomainLowerBound(double p) {\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n      */\n     @Override\n     protected double getDomainUpperBound(double p) {\n      * Access the initial domain value, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n         }\n         return ret;\n     }\n-    \n+\n     /**\n      * Modify the numerator degrees of freedom.\n      * @param degreesOfFreedom the new numerator degrees of freedom.\n         }\n         this.numeratorDegreesOfFreedom = degreesOfFreedom;\n     }\n-    \n+\n     /**\n      * Access the numerator degrees of freedom.\n      * @return the numerator degrees of freedom.\n     public double getNumeratorDegreesOfFreedom() {\n         return numeratorDegreesOfFreedom;\n     }\n-    \n+\n     /**\n      * Modify the denominator degrees of freedom.\n      * @param degreesOfFreedom the new denominator degrees of freedom.\n         }\n         this.denominatorDegreesOfFreedom = degreesOfFreedom;\n     }\n-    \n+\n     /**\n      * Access the denominator degrees of freedom.\n      * @return the denominator degrees of freedom.\n--- a/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java\n      * @param alpha the new shape parameter.\n      */\n     void setAlpha(double alpha);\n-    \n+\n     /**\n      * Access the shape parameter, alpha\n      * @return alpha.\n      */\n     double getAlpha();\n-    \n+\n     /**\n      * Modify the scale parameter, beta.\n      * @param beta the new scale parameter.\n      */\n     void setBeta(double beta);\n-    \n+\n     /**\n      * Access the scale parameter, beta\n      * @return beta.\n--- a/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n \n     /** The shape parameter. */\n     private double alpha;\n-    \n+\n     /** The scale parameter. */\n     private double beta;\n-    \n+\n     /**\n      * Create a new gamma distribution with the given alpha and beta values.\n      * @param alpha the shape parameter.\n         setAlpha(alpha);\n         setBeta(beta);\n     }\n-    \n+\n     /**\n      * For this distribution, X, this method returns P(X &lt; x).\n-     * \n+     *\n      * The implementation of this method is based on:\n      * <ul>\n      * <li>\n      * <li>Casella, G., & Berger, R. (1990). <i>Statistical Inference</i>.\n      * Belmont, CA: Duxbury Press.</li>\n      * </ul>\n-     * \n+     *\n      * @param x the value at which the CDF is evaluated.\n-     * @return CDF for this distribution. \n+     * @return CDF for this distribution.\n      * @throws MathException if the cumulative probability can not be\n      *            computed due to convergence or other numerical errors.\n      */\n     public double cumulativeProbability(double x) throws MathException{\n         double ret;\n-    \n+\n         if (x <= 0.0) {\n             ret = 0.0;\n         } else {\n             ret = Gamma.regularizedGammaP(getAlpha(), x / getBeta());\n         }\n-    \n+\n         return ret;\n     }\n-    \n+\n     /**\n      * For this distribution, X, this method returns the critical point x, such\n      * that P(X &lt; x) = <code>p</code>.\n      *         probability.\n      */\n     @Override\n-    public double inverseCumulativeProbability(final double p) \n+    public double inverseCumulativeProbability(final double p)\n     throws MathException {\n         if (p == 0) {\n             return 0d;\n         }\n         return super.inverseCumulativeProbability(p);\n     }\n-    \n+\n     /**\n      * Modify the shape parameter, alpha.\n      * @param alpha the new shape parameter.\n         }\n         this.alpha = alpha;\n     }\n-    \n+\n     /**\n      * Access the shape parameter, alpha\n      * @return alpha.\n     public double getAlpha() {\n         return alpha;\n     }\n-    \n+\n     /**\n      * Modify the scale parameter, beta.\n      * @param beta the new scale parameter.\n         }\n         this.beta = beta;\n     }\n-    \n+\n     /**\n      * Access the scale parameter, beta\n      * @return beta.\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n      *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n      */\n     @Override\n     protected double getDomainUpperBound(double p) {\n             // use max value\n             ret = Double.MAX_VALUE;\n         }\n-        \n+\n         return ret;\n     }\n \n      * Access the initial domain value, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n             // use mean\n             ret = getAlpha() * getBeta();\n         }\n-        \n+\n         return ret;\n     }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\n      * @return the number of successes.\n      */\n     public abstract int getNumberOfSuccesses();\n-    \n+\n     /**\n      * Access the population size.\n      * @return the population size.\n      */\n     public abstract int getPopulationSize();\n-    \n+\n     /**\n      * Access the sample size.\n      * @return the sample size.\n      */\n     public abstract int getSampleSize();\n-    \n+\n     /**\n      * Modify the number of successes.\n      * @param num the new number of successes.\n      */\n     public abstract void setNumberOfSuccesses(int num);\n-    \n+\n     /**\n      * Modify the population size.\n      * @param size the new population size.\n      */\n     public abstract void setPopulationSize(int size);\n-    \n+\n     /**\n      * Modify the sample size.\n      * @param size the new sample size.\n--- a/src/main/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n  * @version $Revision$ $Date$\n  */\n public class HypergeometricDistributionImpl extends AbstractIntegerDistribution\n-    implements HypergeometricDistribution, Serializable \n+    implements HypergeometricDistribution, Serializable\n {\n \n     /** Serializable version identifier */\n \n     /** The number of successes in the population. */\n     private int numberOfSuccesses;\n-    \n+\n     /** The population size. */\n     private int populationSize;\n-    \n+\n     /** The sample size. */\n     private int sampleSize;\n-    \n+\n     /**\n      * Construct a new hypergeometric distribution with the given the population\n      * size, the number of successes in the population, and the sample size.\n     /**\n      * For this distribution, X, this method returns P(X &le; x).\n      * @param x the value at which the PDF is evaluated.\n-     * @return PDF for this distribution. \n+     * @return PDF for this distribution.\n      */\n     @Override\n     public double cumulativeProbability(int x) {\n         double ret;\n-        \n+\n         int n = getPopulationSize();\n         int m = getNumberOfSuccesses();\n         int k = getSampleSize();\n         } else {\n             ret = innerCumulativeProbability(domain[0], x, 1, n, m, k);\n         }\n-        \n+\n         return ret;\n     }\n \n      * @param m number of successes in the population.\n      * @param k the sample size.\n      * @return a two element array containing the lower and upper bounds of the\n-     *         hypergeometric distribution.  \n+     *         hypergeometric distribution.\n      */\n     private int[] getDomain(int n, int m, int k){\n         return new int[]{\n             getUpperDomain(m, k)\n         };\n     }\n-    \n+\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a PDF root.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n      */\n     @Override\n     protected int getDomainLowerBound(double p) {\n         return getLowerDomain(getPopulationSize(), getNumberOfSuccesses(),\n             getSampleSize());\n     }\n-    \n+\n     /**\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a PDF root.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n      */\n     @Override\n     protected int getDomainUpperBound(double p) {\n      * @param n the population size.\n      * @param m number of successes in the population.\n      * @param k the sample size.\n-     * @return the lowest domain value of the hypergeometric distribution.  \n+     * @return the lowest domain value of the hypergeometric distribution.\n      */\n     private int getLowerDomain(int n, int m, int k) {\n         return Math.max(0, m - (n - k));\n      * parameters.\n      * @param m number of successes in the population.\n      * @param k the sample size.\n-     * @return the highest domain value of the hypergeometric distribution.  \n+     * @return the highest domain value of the hypergeometric distribution.\n      */\n     private int getUpperDomain(int m, int k){\n         return Math.min(k, m);\n \n     /**\n      * For this distribution, X, this method returns P(X = x).\n-     * \n+     *\n      * @param x the value at which the PMF is evaluated.\n-     * @return PMF for this distribution. \n+     * @return PMF for this distribution.\n      */\n     public double probability(int x) {\n         double ret;\n-        \n+\n         int n = getPopulationSize();\n         int m = getNumberOfSuccesses();\n         int k = getSampleSize();\n         } else {\n             ret = probability(n, m, k, x);\n         }\n-        \n+\n         return ret;\n     }\n-    \n+\n     /**\n      * For the distribution, X, defined by the given hypergeometric distribution\n      * parameters, this method returns P(X = x).\n-     * \n+     *\n      * @param n the population size.\n      * @param m number of successes in the population.\n      * @param k the sample size.\n      * @param x the value at which the PMF is evaluated.\n-     * @return PMF for the distribution. \n+     * @return PMF for the distribution.\n      */\n     private double probability(int n, int m, int k, int x) {\n         return Math.exp(MathUtils.binomialCoefficientLog(m, x) +\n         }\n         populationSize = size;\n     }\n-    \n+\n     /**\n      * Modify the sample size.\n      * @param size the new sample size.\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"sample size must be positive ({0})\",\n                   size);\n-        }    \n+        }\n         sampleSize = size;\n     }\n \n      */\n     public double upperCumulativeProbability(int x) {\n         double ret;\n-        \n+\n         int n = getPopulationSize();\n         int m = getNumberOfSuccesses();\n         int k = getSampleSize();\n         } else {\n             ret = innerCumulativeProbability(domain[1], x, -1, n, m, k);\n         }\n-        \n+\n         return ret;\n     }\n-    \n+\n     /**\n      * For this distribution, X, this method returns P(x0 &le; X &le; x1).  This\n      * probability is computed by summing the point probabilities for the values\n-     * x0, x0 + 1, x0 + 2, ..., x1, in the order directed by dx. \n+     * x0, x0 + 1, x0 + 2, ..., x1, in the order directed by dx.\n      * @param x0 the inclusive, lower bound\n      * @param x1 the inclusive, upper bound\n      * @param dx the direction of summation. 1 indicates summing from x0 to x1.\n      * @param n the population size.\n      * @param m number of successes in the population.\n      * @param k the sample size.\n-     * @return P(x0 &le; X &le; x1). \n+     * @return P(x0 &le; X &le; x1).\n      */\n     private double innerCumulativeProbability(\n         int x0, int x1, int dx, int n, int m, int k)\n--- a/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java\n      * For a random variable X whose values are distributed according\n      * to this distribution, this method returns P(X = x). In other words, this\n      * method represents the probability mass function for the distribution.\n-     * \n+     *\n      * @param x the value at which the probability density function is evaluated.\n      * @return the value of the probability density function at x\n      */\n      * to this distribution, this method returns P(X &le; x).  In other words,\n      * this method represents the probability distribution function, or PDF\n      * for the distribution.\n-     * \n+     *\n      * @param x the value at which the PDF is evaluated.\n-     * @return PDF for this distribution. \n+     * @return PDF for this distribution.\n      * @throws MathException if the cumulative probability can not be\n      *            computed due to convergence or other numerical errors.\n      */\n     double cumulativeProbability(int x) throws MathException;\n-    \n+\n     /**\n      * For this distribution, X, this method returns P(x0 &le; X &le; x1).\n      * @param x0 the inclusive, lower bound\n      * @param x1 the inclusive, upper bound\n-     * @return the cumulative probability. \n+     * @return the cumulative probability.\n      * @throws MathException if the cumulative probability can not be\n      *            computed due to convergence or other numerical errors.\n      * @throws IllegalArgumentException if x0 > x1\n      */\n     double cumulativeProbability(int x0, int x1) throws MathException;\n-    \n+\n     /**\n      * For this distribution, X, this method returns the largest x such that\n      * P(X &le; x) <= p.\n      * <li> If there is a minimum value, <code>m</code>, with postive\n      * probablility under (the density of) X, then <code>m - 1</code> is\n      * returned by <code>inverseCumulativeProbability(0).</code>  If there is\n-     * no such value <code>m,  Integer.MIN_VALUE</code> is \n+     * no such value <code>m,  Integer.MIN_VALUE</code> is\n      * returned.</li>\n      * <li> If there is a maximum value, <code>M</code>, such that\n-     * P(X &le; M) =1, then <code>M</code> is returned by \n+     * P(X &le; M) =1, then <code>M</code> is returned by\n      * <code>inverseCumulativeProbability(1).</code>\n-     * If there is no such value, <code>M, Integer.MAX_VALUE</code> is \n+     * If there is no such value, <code>M, Integer.MAX_VALUE</code> is\n      * returned.</li></ul></p>\n-     * \n+     *\n      * @param p the cumulative probability.\n      * @return the largest x such that P(X &le; x) <= p\n      * @throws MathException if the inverse cumulative probability can not be\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n  *\n  * @version $Revision$ $Date$\n  */\n-public class NormalDistributionImpl extends AbstractContinuousDistribution \n+public class NormalDistributionImpl extends AbstractContinuousDistribution\n         implements NormalDistribution, Serializable {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 8589540077390120676L;\n \n \n     /** The mean of this distribution. */\n     private double mean = 0;\n-    \n+\n     /** The standard deviation of this distribution. */\n     private double standardDeviation = 1;\n \n         setMean(mean);\n         setStandardDeviation(sd);\n     }\n-    \n+\n     /**\n      * Creates normal distribution with the mean equal to zero and standard\n-     * deviation equal to one. \n+     * deviation equal to one.\n      */\n     public NormalDistributionImpl(){\n         this(0.0, 1.0);\n     }\n-    \n+\n     /**\n      * Access the mean.\n      * @return mean for this distribution\n-     */ \n+     */\n     public double getMean() {\n         return mean;\n     }\n-    \n+\n     /**\n      * Modify the mean.\n      * @param mean for this distribution\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"standard deviation must be positive ({0})\",\n                   sd);\n-        }       \n+        }\n         standardDeviation = sd;\n     }\n \n     /**\n      * For this distribution, X, this method returns P(X &lt; <code>x</code>).\n      * @param x the value at which the CDF is evaluated.\n-     * @return CDF evaluted at <code>x</code>. \n+     * @return CDF evaluted at <code>x</code>.\n      * @throws MathException if the algorithm fails to converge; unless\n      * x is more than 20 standard deviations from the mean, in which case the\n      * convergence exception is caught and 0 or 1 is returned.\n             }\n         }\n     }\n-    \n+\n     /**\n      * For this distribution, X, this method returns the critical point x, such\n      * that P(X &lt; x) = <code>p</code>.\n      * <p>\n-     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and \n+     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and\n      * <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n      *\n      * @param p the desired probability\n      *         probability.\n      */\n     @Override\n-    public double inverseCumulativeProbability(final double p) \n+    public double inverseCumulativeProbability(final double p)\n     throws MathException {\n         if (p == 0) {\n             return Double.NEGATIVE_INFINITY;\n         }\n         return super.inverseCumulativeProbability(p);\n     }\n-    \n+\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n      */\n     @Override\n     protected double getDomainLowerBound(double p) {\n         } else {\n             ret = getMean();\n         }\n-        \n+\n         return ret;\n     }\n \n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n      */\n     @Override\n     protected double getDomainUpperBound(double p) {\n         } else {\n             ret = Double.MAX_VALUE;\n         }\n-        \n+\n         return ret;\n     }\n \n      * Access the initial domain value, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n         } else {\n             ret = getMean();\n         }\n-        \n+\n         return ret;\n     }\n }\n--- a/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java\n  * The Pascal distribution.  The Pascal distribution is a special case of the\n  * Negative Binomial distribution where the number of successes parameter is an\n  * integer.\n- * \n+ *\n  * There are various ways to express the probability mass and distribution\n  * functions for the Pascal distribution.  The convention employed by the\n  * library is to express these functions in terms of the number of failures in\n public interface PascalDistribution extends IntegerDistribution {\n     /**\n      * Access the number of successes for this distribution.\n-     * \n+     *\n      * @return the number of successes\n      */\n     int getNumberOfSuccesses();\n-    \n+\n     /**\n      * Access the probability of success for this distribution.\n-     * \n+     *\n      * @return the probability of success\n      */\n     double getProbabilityOfSuccess();\n-    \n+\n     /**\n      * Change the number of successes for this distribution.\n-     * \n+     *\n      * @param successes the new number of successes\n      */\n     void setNumberOfSuccesses(int successes);\n-    \n+\n     /**\n      * Change the probability of success for this distribution.\n-     * \n+     *\n      * @param p the new probability of success\n      */\n     void setProbabilityOfSuccess(double p);\n-}\n+}\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n \n /**\n  * Interface representing the Poisson Distribution.\n- * \n+ *\n  * <p>\n  * References:\n  * <ul>\n  * Poisson distribution</a></li>\n  * </ul>\n  * </p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public interface PoissonDistribution extends IntegerDistribution {\n \n     /**\n      * Get the mean for the distribution.\n-     * \n+     *\n      * @return the mean for the distribution.\n      */\n     public double getMean();\n \n     /**\n      * Set the mean for the distribution.\n-     * The parameter value must be positive; otherwise an \n+     * The parameter value must be positive; otherwise an\n      * <code>IllegalArgument</code> is thrown.\n-     * \n+     *\n      * @param p the mean\n      * @throws IllegalArgumentException if p &le; 0\n      */\n \n     /**\n      * Calculates the Poisson distribution function using a normal approximation.\n-     * \n+     *\n      * @param x the upper bound, inclusive\n      * @return the distribution function value calculated using a normal approximation\n      * @throws MathException if an error occurs computing the normal approximation\n      */\n     public double normalApproximateProbability(int x) throws MathException;\n-}\n+}\n--- a/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n \n /**\n  * Implementation for the {@link PoissonDistribution}.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class PoissonDistributionImpl extends AbstractIntegerDistribution\n \n     /** Distribution used to compute normal approximation. */\n     private NormalDistribution normal;\n-    \n+\n     /**\n      * Holds the Poisson mean for the distribution.\n      */\n \n     /**\n      * Create a new Poisson distribution with the given the mean.\n-     * The mean value must be positive; otherwise an \n+     * The mean value must be positive; otherwise an\n      * <code>IllegalArgument</code> is thrown.\n-     * \n+     *\n      * @param p the Poisson mean\n      * @throws IllegalArgumentException if p &le; 0\n      */\n \n     /**\n      * Create a new Poisson distribution with the given the mean.\n-     * The mean value must be positive; otherwise an \n+     * The mean value must be positive; otherwise an\n      * <code>IllegalArgument</code> is thrown.\n-     * \n+     *\n      * @param p the Poisson mean\n      * @param z a normal distribution used to compute normal approximations.\n      * @throws IllegalArgumentException if p &le; 0\n \n     /**\n      * Get the Poisson mean for the distribution.\n-     * \n+     *\n      * @return the Poisson mean for the distribution.\n      */\n     public double getMean() {\n \n     /**\n      * Set the Poisson mean for the distribution.\n-     * The mean value must be positive; otherwise an \n+     * The mean value must be positive; otherwise an\n      * <code>IllegalArgument</code> is thrown.\n-     * \n+     *\n      * @param p the Poisson mean value\n      * @throws IllegalArgumentException if p &le; 0\n      */\n \n     /**\n      * The probability mass function P(X = x) for a Poisson distribution.\n-     * \n+     *\n      * @param x the value at which the probability density function is evaluated.\n      * @return the value of the probability mass function at x\n      */\n         if (x < 0 || x == Integer.MAX_VALUE) {\n             return 0;\n         }\n-        return Math.pow(getMean(), x) / \n+        return Math.pow(getMean(), x) /\n             MathUtils.factorialDouble(x) * Math.exp(-mean);\n     }\n-    \n+\n     /**\n      * The probability distribution function P(X <= x) for a Poisson distribution.\n-     * \n+     *\n      * @param x the value at which the PDF is evaluated.\n      * @return Poisson distribution function evaluated at x\n      * @throws MathException if the cumulative probability can not be\n         if (x == Integer.MAX_VALUE) {\n             return 1;\n         }\n-        return Gamma.regularizedGammaQ((double)x + 1, mean, \n+        return Gamma.regularizedGammaQ((double)x + 1, mean,\n                 1E-12, Integer.MAX_VALUE);\n     }\n \n      * <p>\n      * The computation uses \"half-correction\" -- evaluating the normal\n      * distribution function at <code>x + 0.5</code></p>\n-     * \n+     *\n      * @param x the upper bound, inclusive\n      * @return the distribution function value calculated using a normal approximation\n      * @throws MathException if an error occurs computing the normal approximation\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain lower bound\n      */\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain upper bound\n      */\n     protected int getDomainUpperBound(double p) {\n         return Integer.MAX_VALUE;\n     }\n-    \n+\n     /**\n      * Modify the normal distribution used to compute normal approximations.\n      * The caller is responsible for insuring the normal distribution has the\n     public void setNormal(NormalDistribution value) {\n         normal = value;\n     }\n-    \n-}\n+\n+}\n--- a/src/main/java/org/apache/commons/math/distribution/TDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/TDistribution.java\n      * @param degreesOfFreedom the new degrees of freedom.\n      */\n     void setDegreesOfFreedom(double degreesOfFreedom);\n-    \n+\n     /**\n      * Access the degrees of freedom.\n      * @return the degrees of freedom.\n--- a/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -5852615386664158222L;\n-    \n+\n     /** The degrees of freedom*/\n     private double degreesOfFreedom;\n \n     /**\n      * For this distribution, X, this method returns P(X &lt; <code>x</code>).\n      * @param x the value at which the CDF is evaluated.\n-     * @return CDF evaluted at <code>x</code>. \n+     * @return CDF evaluted at <code>x</code>.\n      * @throws MathException if the cumulative probability can not be\n      *            computed due to convergence or other numerical errors.\n      */\n \n         return ret;\n     }\n-    \n+\n     /**\n      * For this distribution, X, this method returns the critical point x, such\n      * that P(X &lt; x) = <code>p</code>.\n      * <p>\n-     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and \n+     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and\n      * <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n      *\n      * @param p the desired probability\n      *         probability.\n      */\n     @Override\n-    public double inverseCumulativeProbability(final double p) \n+    public double inverseCumulativeProbability(final double p)\n     throws MathException {\n         if (p == 0) {\n             return Double.NEGATIVE_INFINITY;\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n      */\n     @Override\n     protected double getDomainLowerBound(double p) {\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n      */\n     @Override\n     protected double getDomainUpperBound(double p) {\n      * Access the initial domain value, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n--- a/src/main/java/org/apache/commons/math/distribution/WeibullDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistribution.java\n      * @return the shape parameter.\n      */\n     double getShape();\n-    \n+\n     /**\n      * Access the scale parameter.\n      * @return the scale parameter.\n      */\n     double getScale();\n-    \n+\n     /**\n      * Modify the shape parameter.\n      * @param alpha The new shape parameter value.\n      */\n     void setShape(double alpha);\n-    \n+\n     /**\n      * Modify the scale parameter.\n      * @param beta The new scale parameter value.\n--- a/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n  */\n public class WeibullDistributionImpl extends AbstractContinuousDistribution\n         implements WeibullDistribution, Serializable {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 8589540077390120676L;\n-    \n+\n     /** The shape parameter. */\n     private double shape;\n-    \n+\n     /** The scale parameter. */\n     private double scale;\n-    \n+\n     /**\n      * Creates weibull distribution with the given shape and scale and a\n      * location equal to zero.\n     /**\n      * For this distribution, X, this method returns P(X &lt; <code>x</code>).\n      * @param x the value at which the CDF is evaluated.\n-     * @return CDF evaluted at <code>x</code>. \n+     * @return CDF evaluted at <code>x</code>.\n      */\n     public double cumulativeProbability(double x) {\n         double ret;\n     public double getShape() {\n         return shape;\n     }\n-    \n+\n     /**\n      * Access the scale parameter.\n      * @return the scale parameter.\n     public double getScale() {\n         return scale;\n     }\n-    \n+\n     /**\n      * For this distribution, X, this method returns the critical point x, such\n      * that P(X &lt; x) = <code>p</code>.\n      * <p>\n-     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and \n+     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and\n      * <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n      *\n      * @param p the desired probability\n         }\n         return ret;\n     }\n-    \n+\n     /**\n      * Modify the shape parameter.\n      * @param alpha the new shape parameter value.\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"shape must be positive ({0})\",\n                   alpha);\n-        }       \n+        }\n         this.shape = alpha;\n     }\n-    \n+\n     /**\n      * Modify the scale parameter.\n      * @param beta the new scale parameter value.\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"scale must be positive ({0})\",\n                   beta);\n-        }       \n+        }\n         this.scale = beta;\n     }\n \n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n      */\n     @Override\n     protected double getDomainLowerBound(double p) {\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n      */\n     @Override\n     protected double getDomainUpperBound(double p) {\n      * Access the initial domain value, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n--- a/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java\n  * <p>\n  * References:\n  * <ul>\n- * <li><a href=\"http://mathworld.wolfram.com/ZipfDistribution.html\">Zipf \n+ * <li><a href=\"http://mathworld.wolfram.com/ZipfDistribution.html\">Zipf\n  * Distribution</a></li>\n  * </ul>\n  * </p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public interface ZipfDistribution extends IntegerDistribution {\n     /**\n      * Get the number of elements (e.g. corpus size) for the distribution.\n-     * \n+     *\n      * @return the number of elements\n      */\n     public int getNumberOfElements();\n \n     /**\n      * Set the number of elements (e.g. corpus size) for the distribution.\n-     * The parameter value must be positive; otherwise an \n+     * The parameter value must be positive; otherwise an\n      * <code>IllegalArgumentException</code> is thrown.\n-     * \n+     *\n      * @param n the number of elements\n      * @throws IllegalArgumentException if n &le; 0\n      */\n \n     /**\n      * Get the exponent characterising the distribution.\n-     * \n+     *\n      * @return the exponent\n      */\n     public double getExponent();\n \n     /**\n      * Set the exponent characterising the distribution.\n-     * The parameter value must be positive; otherwise an \n+     * The parameter value must be positive; otherwise an\n      * <code>IllegalArgumentException</code> is thrown.\n-     * \n+     *\n      * @param s the exponent\n      * @throws IllegalArgumentException if s &le; 0.0\n      */\n     public void setExponent(double s);\n-}\n+}\n--- a/src/main/java/org/apache/commons/math/distribution/ZipfDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ZipfDistributionImpl.java\n \n /**\n  * Implementation for the {@link ZipfDistribution}.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n-public class ZipfDistributionImpl extends AbstractIntegerDistribution \n+public class ZipfDistributionImpl extends AbstractIntegerDistribution\n     implements ZipfDistribution, Serializable {\n \n     /** Serializable version identifier. */\n     private double exponent;\n \n     /**\n-     * Create a new Zipf distribution with the given number of elements and \n-     * exponent. Both values must be positive; otherwise an \n+     * Create a new Zipf distribution with the given number of elements and\n+     * exponent. Both values must be positive; otherwise an\n      * <code>IllegalArgumentException</code> is thrown.\n-     * \n+     *\n      * @param numberOfElements the number of elements\n      * @param exponent the exponent\n      * @exception IllegalArgumentException if n &le; 0 or s &le; 0.0\n \n     /**\n      * Get the number of elements (e.g. corpus size) for the distribution.\n-     * \n+     *\n      * @return the number of elements\n      */\n     public int getNumberOfElements() {\n \n     /**\n      * Set the number of elements (e.g. corpus size) for the distribution.\n-     * The parameter value must be positive; otherwise an \n+     * The parameter value must be positive; otherwise an\n      * <code>IllegalArgumentException</code> is thrown.\n-     * \n+     *\n      * @param n the number of elements\n      * @exception IllegalArgumentException if n &le; 0\n      */\n         }\n         this.numberOfElements = n;\n     }\n-    \n+\n     /**\n      * Get the exponent characterising the distribution.\n-     * \n+     *\n      * @return the exponent\n      */\n     public double getExponent() {\n \n     /**\n      * Set the exponent characterising the distribution.\n-     * The parameter value must be positive; otherwise an \n+     * The parameter value must be positive; otherwise an\n      * <code>IllegalArgumentException</code> is thrown.\n-     * \n+     *\n      * @param s the exponent\n      * @exception IllegalArgumentException if s &le; 0.0\n      */\n \n     /**\n      * The probability mass function P(X = x) for a Zipf distribution.\n-     * \n+     *\n      * @param x the value at which the probability density function is evaluated.\n      * @return the value of the probability mass function at x\n      */\n         return (1.0 / Math.pow(x, exponent)) / generalizedHarmonic(numberOfElements, exponent);\n \n     }\n-    \n+\n     /**\n      * The probability distribution function P(X <= x) for a Zipf distribution.\n-     * \n+     *\n      * @param x the value at which the PDF is evaluated.\n      * @return Zipf distribution function evaluated at x\n      */\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a PDF root.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n      */\n     @Override\n     protected int getDomainLowerBound(final double p) {\n     /**\n      * Access the domain value upper bound, based on <code>p</code>, used to\n      * bracket a PDF root.\n-     * \n+     *\n      * @param p the desired probability for the critical value\n      * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n      */\n     @Override\n     protected int getDomainUpperBound(final double p) {\n \n \n     /**\n-     * Calculates the Nth generalized harmonic number. See \n-     * <a href=\"http://mathworld.wolfram.com/HarmonicSeries.html\">Harmonic \n+     * Calculates the Nth generalized harmonic number. See\n+     * <a href=\"http://mathworld.wolfram.com/HarmonicSeries.html\">Harmonic\n      * Series</a>.\n-     * \n+     *\n      * @param n the term in the series to calculate (must be &ge; 1)\n      * @param m the exponent; special case m == 1.0 is the harmonic series\n      * @return the nth generalized harmonic number\n--- a/src/main/java/org/apache/commons/math/estimation/AbstractEstimator.java\n+++ b/src/main/java/org/apache/commons/math/estimation/AbstractEstimator.java\n \n     /**\n      * Set the maximal number of cost evaluations allowed.\n-     * \n+     *\n      * @param maxCostEval maximal number of cost evaluations allowed\n      * @see #estimate\n      */\n \n     /**\n      * Get the number of cost evaluations.\n-     * \n+     *\n      * @return number of cost evaluations\n      * */\n     public final int getCostEvaluations() {\n         return costEvaluations;\n     }\n \n-    /** \n+    /**\n      * Get the number of jacobian evaluations.\n-     * \n+     *\n      * @return number of jacobian evaluations\n      * */\n     public final int getJacobianEvaluations() {\n         return jacobianEvaluations;\n     }\n \n-    /** \n+    /**\n      * Update the jacobian matrix.\n      */\n     protected void updateJacobian() {\n       ++jacobianEvaluations;\n     }\n \n-    /** \n+    /**\n      * Update the residuals array and cost function value.\n      * @exception EstimationException if the number of cost evaluations\n      * exceeds the maximum allowed\n \n     }\n \n-    /** \n+    /**\n      * Get the Root Mean Square value.\n      * Get the Root Mean Square value, i.e. the root of the arithmetic\n      * mean of the square of all weighted residuals. This is related to the\n      * criterion that is minimized by the estimator as follows: if\n      * <em>c</em> if the criterion, and <em>n</em> is the number of\n      * measurements, then the RMS is <em>sqrt (c/n)</em>.\n-     * \n+     *\n      * @param problem estimation problem\n      * @return RMS value\n      */\n      */\n     public double[][] getCovariances(EstimationProblem problem)\n       throws EstimationException {\n- \n+\n         // set up the jacobian\n         updateJacobian();\n \n \n     }\n \n-    /** \n+    /**\n      * Solve an estimation problem.\n      *\n      * <p>The method should set the parameters of the problem to several\n     /** Array of parameters. */\n     protected EstimatedParameter[] parameters;\n \n-    /** \n+    /**\n      * Jacobian matrix.\n      * <p>This matrix is in canonical form just after the calls to\n      * {@link #updateJacobian()}, but may be modified by the solver\n     /** Number of jacobian evaluations. */\n     private int jacobianEvaluations;\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/estimation/EstimationException.java\n+++ b/src/main/java/org/apache/commons/math/estimation/EstimationException.java\n \n import org.apache.commons.math.MathException;\n \n-/** \n+/**\n  * This class represents exceptions thrown by the estimation solvers.\n  *\n  * @version $Revision$ $Date$\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -573038581493881337L;\n \n-    /** \n+    /**\n      * Simple constructor.\n      * Build an exception by translating and formating a message\n      * @param specifier format specifier (to be translated)\n--- a/src/main/java/org/apache/commons/math/estimation/EstimationProblem.java\n+++ b/src/main/java/org/apache/commons/math/estimation/EstimationProblem.java\n \n package org.apache.commons.math.estimation;\n \n-/** \n+/**\n  * This interface represents an estimation problem.\n  *\n  * <p>This interface should be implemented by all real estimation\n  */\n @Deprecated\n public interface EstimationProblem {\n-  /** \n+  /**\n    * Get the measurements of an estimation problem.\n    * @return measurements\n    */\n   public WeightedMeasurement[] getMeasurements();\n \n-  /** \n+  /**\n    * Get the unbound parameters of the problem.\n    * @return unbound parameters\n    */\n   public EstimatedParameter[] getUnboundParameters();\n \n-  /** \n+  /**\n    * Get all the parameters of the problem.\n    * @return parameters\n    */\n--- a/src/main/java/org/apache/commons/math/estimation/Estimator.java\n+++ b/src/main/java/org/apache/commons/math/estimation/Estimator.java\n @Deprecated\n public interface Estimator {\n \n-  /** \n+  /**\n    * Solve an estimation problem.\n    *\n    * <p>The method should set the parameters of the problem to several\n   public void estimate(EstimationProblem problem)\n     throws EstimationException;\n \n-  /** \n+  /**\n    * Get the Root Mean Square value.\n    * Get the Root Mean Square value, i.e. the root of the arithmetic\n    * mean of the square of all weighted residuals. This is related to the\n    * <em>c</em> is the criterion, and <em>n</em> is the number of\n    * measurements, then the RMS is <em>sqrt (c/n)</em>.\n    * @see #guessParametersErrors(EstimationProblem)\n-   * \n+   *\n    * @param problem estimation problem\n    * @return RMS value\n    */\n--- a/src/main/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n+++ b/src/main/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n import org.apache.commons.math.linear.RealVector;\n import org.apache.commons.math.linear.ArrayRealVector;\n \n-/** \n+/**\n  * This class implements a solver for estimation problems.\n  *\n  * <p>This class solves estimation problems using a weighted least\n      */\n     public GaussNewtonEstimator() {\n         this.steadyStateThreshold = DEFAULT_STEADY_STATE_THRESHOLD;\n-        this.convergence          = DEFAULT_CONVERGENCE;        \n-    }\n-\n-    /** \n+        this.convergence          = DEFAULT_CONVERGENCE;\n+    }\n+\n+    /**\n      * Simple constructor.\n      *\n      * <p>This constructor builds an estimator and stores its convergence\n         this.steadyStateThreshold = steadyStateThreshold;\n     }\n \n-    /** \n+    /**\n      * Solve an estimation problem using a least squares criterion.\n      *\n      * <p>This method set the unbound parameters of the given problem\n--- a/src/main/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n+++ b/src/main/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n import java.util.Arrays;\n \n \n-/** \n+/**\n  * This class solves a least squares problem.\n  *\n  * <p>This implementation <em>should</em> work even for over-determined systems\n @Deprecated\n public class LevenbergMarquardtEstimator extends AbstractEstimator implements Serializable {\n \n-  /** \n+  /**\n    * Build an estimator for least squares problems.\n    * <p>The default values for the algorithm settings are:\n    *   <ul>\n \n   }\n \n-  /** \n+  /**\n    * Set the positive input variable used in determining the initial step bound.\n    * This bound is set to the product of initialStepBoundFactor and the euclidean norm of diag*x if nonzero,\n    * or else to initialStepBoundFactor itself. In most cases factor should lie\n    * in the interval (0.1, 100.0). 100.0 is a generally recommended value\n-   * \n+   *\n    * @param initialStepBoundFactor initial step bound factor\n    * @see #estimate\n    */\n     this.initialStepBoundFactor = initialStepBoundFactor;\n   }\n \n-  /** \n+  /**\n    * Set the desired relative error in the sum of squares.\n-   * \n+   *\n    * @param costRelativeTolerance desired relative error in the sum of squares\n    * @see #estimate\n    */\n     this.costRelativeTolerance = costRelativeTolerance;\n   }\n \n-  /** \n+  /**\n    * Set the desired relative error in the approximate solution parameters.\n-   * \n+   *\n    * @param parRelativeTolerance desired relative error\n    * in the approximate solution parameters\n    * @see #estimate\n     this.parRelativeTolerance = parRelativeTolerance;\n   }\n \n-  /** \n+  /**\n    * Set the desired max cosine on the orthogonality.\n-   * \n+   *\n    * @param orthoTolerance desired max cosine on the orthogonality\n    * between the function vector and the columns of the jacobian\n    * @see #estimate\n     this.orthoTolerance = orthoTolerance;\n   }\n \n-  /** \n+  /**\n    * Solve an estimation problem using the Levenberg-Marquardt algorithm.\n    * <p>The algorithm used is a modified Levenberg-Marquardt one, based\n    * on the MINPACK <a href=\"http://www.netlib.org/minpack/lmder.f\">lmder</a>\n    *   <li>Jorge   J. More</li>\n    *   </ul>\n    * <p>Luc Maisonobe did the Java translation.</p>\n-   * \n+   *\n    * @param problem estimation problem to solve\n    * @exception EstimationException if convergence cannot be\n    * reached with the specified algorithm settings or if there are more variables\n \n     // evaluate the function at the starting point and calculate its norm\n     updateResidualsAndCost();\n-    \n+\n     // outer loop\n     lmPar = 0;\n     boolean firstIteration = true;\n           diag[k] = dk;\n         }\n         xNorm = Math.sqrt(xNorm);\n-        \n+\n         // initialize the step bound delta\n         delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n- \n+\n       }\n \n       // check orthogonality between function vector and jacobian columns\n         double[] tmpVec = residuals;\n         residuals = oldRes;\n         oldRes    = tmpVec;\n-        \n+\n         // determine the Levenberg-Marquardt parameter\n         determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n \n           residuals = oldRes;\n           oldRes    = tmpVec;\n         }\n-   \n+\n         // tests for convergence.\n         if (((Math.abs(actRed) <= costRelativeTolerance) &&\n              (preRed <= costRelativeTolerance) &&\n \n   }\n \n-  /** \n+  /**\n    * Determine the Levenberg-Marquardt parameter.\n    * <p>This implementation is a translation in Java of the MINPACK\n    * <a href=\"http://www.netlib.org/minpack/lmpar.f\">lmpar</a>\n    *   <li>Jorge   J. More</li>\n    * </ul>\n    * <p>Luc Maisonobe did the Java translation.</p>\n-   * \n+   *\n    * @param qy array containing qTy\n    * @param delta upper bound on the euclidean norm of diagR * lmDir\n    * @param diag diagonal matrix\n     if (rank == solvedCols) {\n       for (int j = 0; j < solvedCols; ++j) {\n         int pj = permutation[j];\n-        work1[pj] *= diag[pj] / dxNorm; \n+        work1[pj] *= diag[pj] / dxNorm;\n       }\n       sum2 = 0;\n       for (int j = 0; j < solvedCols; ++j) {\n           ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\n         return;\n       }\n- \n+\n       // compute the Newton correction\n       for (int j = 0; j < solvedCols; ++j) {\n        int pj = permutation[j];\n-        work1[pj] = work3[pj] * diag[pj] / dxNorm; \n+        work1[pj] = work3[pj] * diag[pj] / dxNorm;\n       }\n       for (int j = 0; j < solvedCols; ++j) {\n         int pj = permutation[j];\n     }\n   }\n \n-  /** \n+  /**\n    * Solve a*x = b and d*x = 0 in the least squares sense.\n    * <p>This implementation is a translation in Java of the MINPACK\n    * <a href=\"http://www.netlib.org/minpack/qrsolv.f\">qrsolv</a>\n    *   <li>Jorge   J. More</li>\n    * </ul>\n    * <p>Luc Maisonobe did the Java translation.</p>\n-   * \n+   *\n    * @param qy array containing qTy\n    * @param diag diagonal matrix\n    * @param lmDiag diagonal elements associated with lmDir\n \n   }\n \n-  /** \n+  /**\n    * Decompose a matrix A as A.P = Q.R using Householder transforms.\n    * <p>As suggested in the P. Lascaux and R. Theodor book\n    * <i>Analyse num&eacute;rique matricielle appliqu&eacute;e &agrave;\n \n   }\n \n-  /** \n+  /**\n    * Compute the product Qt.y for some Q.R. decomposition.\n-   * \n+   *\n    * @param y vector to multiply (will be overwritten with the result)\n    */\n   private void qTy(double[] y) {\n--- a/src/main/java/org/apache/commons/math/estimation/SimpleEstimationProblem.java\n+++ b/src/main/java/org/apache/commons/math/estimation/SimpleEstimationProblem.java\n         measurements = new ArrayList<WeightedMeasurement>();\n     }\n \n-    /** \n+    /**\n      * Get all the parameters of the problem.\n      * @return parameters\n      */\n         return parameters.toArray(new EstimatedParameter[parameters.size()]);\n     }\n \n-    /** \n+    /**\n      * Get the unbound parameters of the problem.\n      * @return unbound parameters\n      */\n \n         // convert to an array\n         return unbound.toArray(new EstimatedParameter[unbound.size()]);\n-        \n+\n     }\n \n-    /** \n+    /**\n      * Get the measurements of an estimation problem.\n      * @return measurements\n      */\n--- a/src/main/java/org/apache/commons/math/estimation/WeightedMeasurement.java\n+++ b/src/main/java/org/apache/commons/math/estimation/WeightedMeasurement.java\n \n import java.io.Serializable;\n \n-/** \n+/**\n  * This class represents measurements in estimation problems.\n  *\n  * <p>This abstract class implements all the methods needed to handle\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 4360046376796901941L;\n \n-    /** \n+    /**\n    * Simple constructor.\n    * Build a measurement with the given parameters, and set its ignore\n    * flag to false.\n    * (two common choices are either to use 1.0 for all measurements, or to\n    * use a value proportional to the inverse of the variance of the measurement\n    * type)\n-   * \n+   *\n    * @param measuredValue measured value\n    */\n   public WeightedMeasurement(double weight, double measuredValue) {\n   }\n \n   /** Simple constructor.\n-   * \n+   *\n    * Build a measurement with the given parameters\n-   * \n+   *\n    * @param weight weight of the measurement in the least squares problem\n    * @param measuredValue measured value\n    * @param ignored true if the measurement should be ignored\n     this.ignored       = ignored;\n   }\n \n-  /** \n+  /**\n    * Get the weight of the measurement in the least squares problem\n-   * \n+   *\n    * @return weight\n    */\n   public double getWeight() {\n     return weight;\n   }\n \n-  /** \n+  /**\n    * Get the measured value\n-   * \n+   *\n    * @return measured value\n    */\n   public double getMeasuredValue() {\n     return measuredValue;\n   }\n \n-  /** \n+  /**\n    * Get the residual for this measurement\n    * The residual is the measured value minus the theoretical value.\n-   * \n+   *\n    * @return residual\n    */\n   public double getResidual() {\n     return measuredValue - getTheoreticalValue();\n   }\n \n-  /** \n+  /**\n    * Get the theoretical value expected for this measurement\n    * <p>The theoretical value is the value expected for this measurement\n    * if the model and its parameter were all perfectly known.</p>\n    * <p>The value must be computed using the current estimate of the parameters\n    * set by the solver in the problem.</p>\n-   * \n+   *\n    * @return theoretical value\n    */\n   public abstract double getTheoreticalValue();\n \n-  /** \n+  /**\n    * Get the partial derivative of the {@link #getTheoreticalValue\n    * theoretical value} according to the parameter.\n    * <p>The value must be computed using the current estimate of the parameters\n    * set by the solver in the problem.</p>\n-   * \n+   *\n    * @param parameter parameter against which the partial derivative\n    * should be computed\n    * @return partial derivative of the {@link #getTheoreticalValue\n    */\n   public abstract double getPartial(EstimatedParameter parameter);\n \n-  /** \n+  /**\n    * Set the ignore flag to the specified value\n    * Setting the ignore flag to true allow to reject wrong\n    * measurements, which sometimes can be detected only rather late.\n-   * \n+   *\n    * @param ignored value for the ignore flag\n    */\n   public void setIgnored(boolean ignored) {\n     this.ignored = ignored;\n   }\n \n-  /** \n+  /**\n    * Check if this measurement should be ignored\n-   * \n+   *\n    * @return true if the measurement should be ignored\n    */\n   public boolean isIgnored() {\n--- a/src/main/java/org/apache/commons/math/fraction/AbstractFormat.java\n+++ b/src/main/java/org/apache/commons/math/fraction/AbstractFormat.java\n \n     /**\n      * Create an improper formatting instance with the default number format\n-     * for the numerator and denominator.  \n+     * for the numerator and denominator.\n      */\n     protected AbstractFormat() {\n         this(getDefaultNumberFormat());\n     /**\n      * Create a default number format.  The default number format is based on\n      * {@link NumberFormat#getNumberInstance(java.util.Locale)} with the only\n-     * customizing is the maximum number of BigFraction digits, which is set to 0.  \n+     * customizing is the maximum number of BigFraction digits, which is set to 0.\n      * @return the default number format.\n      */\n     protected static NumberFormat getDefaultNumberFormat() {\n     /**\n      * Create a default number format.  The default number format is based on\n      * {@link NumberFormat#getNumberInstance(java.util.Locale)} with the only\n-     * customizing is the maximum number of BigFraction digits, which is set to 0.  \n+     * customizing is the maximum number of BigFraction digits, which is set to 0.\n      * @param locale the specific locale used by the format.\n      * @return the default number format specific to the given locale.\n      */\n                  c = source.charAt(index++);\n              } while (Character.isWhitespace(c) && index < n);\n              pos.setIndex(index);\n-         \n+\n              if (index < n) {\n                  ret = c;\n              }\n          }\n-         \n+\n          return ret;\n     }\n \n     /**\n-     * Formats a double value as a fraction and appends the result to a StringBuffer. \n+     * Formats a double value as a fraction and appends the result to a StringBuffer.\n      *\n      * @param value the double value to format\n      * @param buffer StringBuffer to append to\n         return format(Double.valueOf(value), buffer, position);\n     }\n \n-    \n-    /**\n-     * Formats a long value as a fraction and appends the result to a StringBuffer. \n+\n+    /**\n+     * Formats a long value as a fraction and appends the result to a StringBuffer.\n      *\n      * @param value the long value to format\n      * @param buffer StringBuffer to append to\n         return format(Long.valueOf(value), buffer, position);\n     }\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n /**\n  * Representation of a rational number without any overflow. This class is\n  * immutable.\n- * \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n      * Creates a <code>BigFraction</code> instance with the 2 parts of a fraction\n      * Y/Z.\n      * </p>\n-     * \n+     *\n      * <p>\n      * Any negative signs are resolved to be on the numerator.\n      * </p>\n-     * \n+     *\n      * @param numerator\n      *            the numerator, for example the three in 'three sevenths'.\n      * @param denominator\n      * Create a {@link BigFraction} equivalent to the passed <tt>BigInteger</tt>, ie\n      * \"num / 1\".\n      * </p>\n-     * \n+     *\n      * @param num\n      *            the numerator.\n      */\n      * Create a {@link BigFraction} given the numerator and denominator as\n      * <code>BigInteger</code>. The {@link BigFraction} is reduced to lowest terms.\n      * </p>\n-     * \n+     *\n      * @param num\n      *            the numerator, must not be <code>null</code>.\n      * @param den\n      * Continued Fraction</a> equations (11) and (22)-(26)</li>\n      * </ul>\n      * </p>\n-     * \n+     *\n      * @param value\n      *            the double value to convert to a fraction.\n      * @param epsilon\n      * Create a fraction given the double value and either the maximum error\n      * allowed or the maximum number of denominator digits.\n      * <p>\n-     * \n+     *\n      * NOTE: This constructor is called with EITHER - a valid epsilon value and\n      * the maxDenominator set to Integer.MAX_VALUE (that way the maxDenominator\n      * has no effect). OR - a valid maxDenominator value and the epsilon value\n      * before the maxDenominator value is reached).\n      * </p>\n      * <p>\n-     * \n+     *\n      * It has been done this way so that the same code can be (re)used for both\n      * scenarios. However this could be confusing to users if it were part of\n      * the public API and this constructor should therefore remain PRIVATE.\n      * </p>\n-     * \n+     *\n      * See JIRA issue ticket MATH-181 for more details:\n-     * \n+     *\n      * https://issues.apache.org/jira/browse/MATH-181\n-     * \n+     *\n      * @param value\n      *            the double value to convert to a fraction.\n      * @param epsilon\n      * Continued Fraction</a> equations (11) and (22)-(26)</li>\n      * </ul>\n      * </p>\n-     * \n+     *\n      * @param value\n      *            the double value to convert to a fraction.\n      * @param maxDenominator\n      * Create a {@link BigFraction} equivalent to the passed <tt>int</tt>, ie\n      * \"num / 1\".\n      * </p>\n-     * \n+     *\n      * @param num\n      *            the numerator.\n      */\n      * Create a {@link BigFraction} given the numerator and denominator as simple\n      * <tt>int</tt>. The {@link BigFraction} is reduced to lowest terms.\n      * </p>\n-     * \n+     *\n      * @param num\n      *            the numerator.\n      * @param den\n      * <p>\n      * Create a {@link BigFraction} equivalent to the passed long, ie \"num / 1\".\n      * </p>\n-     * \n+     *\n      * @param num\n      *            the numerator.\n      */\n      * Create a {@link BigFraction} given the numerator and denominator as simple\n      * <tt>long</tt>. The {@link BigFraction} is reduced to lowest terms.\n      * </p>\n-     * \n+     *\n      * @param num\n      *            the numerator.\n      * @param den\n      * <p>\n      * Returns the absolute value of this {@link BigFraction}.\n      * </p>\n-     * \n+     *\n      * @return the absolute value as a {@link BigFraction}.\n      */\n     public BigFraction abs() {\n      * Adds the value of this fraction to the passed {@link BigInteger},\n      * returning the result in reduced form.\n      * </p>\n-     * \n+     *\n      * @param bg\n      *            the {@link BigInteger} to add, must'nt be <code>null</code>.\n      * @return a <code>BigFraction</code> instance with the resulting values.\n      * Adds the value of this fraction to the passed <tt>integer</tt>, returning\n      * the result in reduced form.\n      * </p>\n-     * \n+     *\n      * @param i\n      *            the <tt>integer</tt> to add.\n      * @return a <code>BigFraction</code> instance with the resulting values.\n      * Adds the value of this fraction to the passed <tt>long</tt>, returning\n      * the result in reduced form.\n      * </p>\n-     * \n+     *\n      * @param l\n      *            the <tt>long</tt> to add.\n      * @return a <code>BigFraction</code> instance with the resulting values.\n      * Adds the value of this fraction to another, returning the result in\n      * reduced form.\n      * </p>\n-     * \n+     *\n      * @param fraction\n      *            the {@link BigFraction} to add, must not be <code>null</code>.\n      * @return a {@link BigFraction} instance with the resulting values.\n      * Gets the fraction as a <code>BigDecimal</code>. This calculates the\n      * fraction as the numerator divided by denominator.\n      * </p>\n-     * \n+     *\n      * @return the fraction as a <code>BigDecimal</code>.\n      * @throws ArithmeticException\n      *             if the exact quotient does not have a terminating decimal\n      * rounding mode. This calculates the fraction as the numerator divided by\n      * denominator.\n      * </p>\n-     * \n+     *\n      * @param roundingMode\n      *            rounding mode to apply. see {@link BigDecimal} constants.\n      * @return the fraction as a <code>BigDecimal</code>.\n      * and rounding mode. This calculates the fraction as the numerator divided\n      * by denominator.\n      * </p>\n-     * \n+     *\n      * @param scale\n      *            scale of the <code>BigDecimal</code> quotient to be returned.\n      *            see {@link BigDecimal} for more information.\n      * <p>\n      * Compares this object to another based on size.\n      * </p>\n-     * \n+     *\n      * @param object\n      *            the object to compare to, must not be <code>null</code>.\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      * Divide the value of this fraction by the passed <code>BigInteger</code>,\n      * ie \"this * 1 / bg\", returning the result in reduced form.\n      * </p>\n-     * \n+     *\n      * @param bg\n      *            the <code>BigInteger</code> to divide by, must not be\n      *            <code>null</code>.\n      * Divide the value of this fraction by the passed <tt>int</tt>, ie\n      * \"this * 1 / i\", returning the result in reduced form.\n      * </p>\n-     * \n+     *\n      * @param i\n      *            the <tt>int</tt> to divide by.\n      * @return a {@link BigFraction} instance with the resulting values.\n      * Divide the value of this fraction by the passed <tt>long</tt>, ie\n      * \"this * 1 / l\", returning the result in reduced form.\n      * </p>\n-     * \n+     *\n      * @param l\n      *            the <tt>long</tt> to divide by.\n      * @return a {@link BigFraction} instance with the resulting values.\n      * Divide the value of this fraction by another, returning the result in\n      * reduced form.\n      * </p>\n-     * \n+     *\n      * @param fraction\n      *            the fraction to divide by, must not be <code>null</code>.\n      * @return a {@link BigFraction} instance with the resulting values.\n      * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n      * the numerator divided by denominator.\n      * </p>\n-     * \n+     *\n      * @return the fraction as a <tt>double</tt>\n      * @see java.lang.Number#doubleValue()\n      */\n      * denominators are the same for both fractions, the two fractions are\n      * considered to be equal.\n      * </p>\n-     * \n+     *\n      * @param other\n      *            fraction to test for equality to this fraction, can be\n      *            <code>null</code>.\n      * Gets the fraction as a <tt>float</tt>. This calculates the fraction as\n      * the numerator divided by denominator.\n      * </p>\n-     * \n+     *\n      * @return the fraction as a <tt>float</tt>.\n      * @see java.lang.Number#floatValue()\n      */\n      * <p>\n      * Access the denominator as a <code>BigInteger</code>.\n      * </p>\n-     * \n+     *\n      * @return the denominator as a <code>BigInteger</code>.\n      */\n     public BigInteger getDenominator() {\n      * <p>\n      * Access the denominator as a <tt>int</tt>.\n      * </p>\n-     * \n+     *\n      * @return the denominator as a <tt>int</tt>.\n      */\n     public int getDenominatorAsInt() {\n      * <p>\n      * Access the denominator as a <tt>long</tt>.\n      * </p>\n-     * \n+     *\n      * @return the denominator as a <tt>long</tt>.\n      */\n     public long getDenominatorAsLong() {\n      * <p>\n      * Access the numerator as a <code>BigInteger</code>.\n      * </p>\n-     * \n+     *\n      * @return the numerator as a <code>BigInteger</code>.\n      */\n     public BigInteger getNumerator() {\n      * <p>\n      * Access the numerator as a <tt>int</tt>.\n      * </p>\n-     * \n+     *\n      * @return the numerator as a <tt>int</tt>.\n      */\n     public int getNumeratorAsInt() {\n      * <p>\n      * Access the numerator as a <tt>long</tt>.\n      * </p>\n-     * \n+     *\n      * @return the numerator as a <tt>long</tt>.\n      */\n     public long getNumeratorAsLong() {\n      * <p>\n      * Gets a hashCode for the fraction.\n      * </p>\n-     * \n+     *\n      * @return a hash code value for this object.\n      * @see java.lang.Object#hashCode()\n      */\n      * Gets the fraction as an <tt>int</tt>. This returns the whole number part\n      * of the fraction.\n      * </p>\n-     * \n+     *\n      * @return the whole number fraction part.\n      * @see java.lang.Number#intValue()\n      */\n      * Gets the fraction as a <tt>long</tt>. This returns the whole number part\n      * of the fraction.\n      * </p>\n-     * \n+     *\n      * @return the whole number fraction part.\n      * @see java.lang.Number#longValue()\n      */\n      * Multiplies the value of this fraction by the passed\n      * <code>BigInteger</code>, returning the result in reduced form.\n      * </p>\n-     * \n+     *\n      * @param bg\n      *            the <code>BigInteger</code> to multiply by.\n      * @return a <code>BigFraction</code> instance with the resulting values.\n      * Multiply the value of this fraction by the passed <tt>int</tt>, returning\n      * the result in reduced form.\n      * </p>\n-     * \n+     *\n      * @param i\n      *            the <tt>int</tt> to multiply by.\n      * @return a {@link BigFraction} instance with the resulting values.\n      * Multiply the value of this fraction by the passed <tt>long</tt>,\n      * returning the result in reduced form.\n      * </p>\n-     * \n+     *\n      * @param l\n      *            the <tt>long</tt> to multiply by.\n      * @return a {@link BigFraction} instance with the resulting values.\n      * Multiplies the value of this fraction by another, returning the result in\n      * reduced form.\n      * </p>\n-     * \n+     *\n      * @param fraction\n      *            the fraction to multiply by, must not be <code>null</code>.\n      * @return a {@link BigFraction} instance with the resulting values.\n      * Return the additive inverse of this fraction, returning the result in\n      * reduced form.\n      * </p>\n-     * \n+     *\n      * @return the negation of this fraction.\n      */\n     public BigFraction negate() {\n      * Gets the fraction percentage as a <tt>double</tt>. This calculates the\n      * fraction as the numerator divided by denominator multiplied by 100.\n      * </p>\n-     * \n+     *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n     public double percentageValue() {\n      * Returns a <tt>integer</tt> whose value is\n      * <tt>(this<sup>exponent</sup>)</tt>, returning the result in reduced form.\n      * </p>\n-     * \n+     *\n      * @param exponent\n      *            exponent to which this <code>BigInteger</code> is to be\n      *            raised.\n      * Returns a <code>BigFraction</code> whose value is\n      * <tt>(this<sup>exponent</sup>)</tt>, returning the result in reduced form.\n      * </p>\n-     * \n+     *\n      * @param exponent\n      *            exponent to which this <code>BigFraction</code> is to be raised.\n      * @return <tt>this<sup>exponent</sup></tt> as a <code>BigFraction</code>.\n         return new BigFraction(MathUtils.pow(numerator,   exponent),\n                                MathUtils.pow(denominator, exponent));\n     }\n- \n+\n     /**\n      * <p>\n      * Returns a <code>BigFraction</code> whose value is\n      * <tt>(this<sup>exponent</sup>)</tt>, returning the result in reduced form.\n      * </p>\n-     * \n+     *\n      * @param exponent\n      *            exponent to which this <code>BigFraction</code> is to be raised.\n      * @return <tt>this<sup>exponent</sup></tt> as a <code>BigFraction</code>.\n      * Returns a <code>double</code> whose value is\n      * <tt>(this<sup>exponent</sup>)</tt>, returning the result in reduced form.\n      * </p>\n-     * \n+     *\n      * @param exponent\n      *            exponent to which this <code>BigFraction</code> is to be raised.\n      * @return <tt>this<sup>exponent</sup></tt>.\n      * <p>\n      * Return the multiplicative inverse of this fraction.\n      * </p>\n-     * \n+     *\n      * @return the reciprocal fraction.\n      */\n     public BigFraction reciprocal() {\n      * <p>\n      * Reduce this <code>BigFraction</code> to its lowest terms.\n      * </p>\n-     * \n+     *\n      * @return the reduced <code>BigFraction</code>. It doesn't change anything if\n      *         the fraction can be reduced.\n      */\n      * Subtracts the value of an {@link BigInteger} from the value of this one,\n      * returning the result in reduced form.\n      * </p>\n-     * \n+     *\n      * @param bg\n      *            the {@link BigInteger} to subtract, must'nt be\n      *            <code>null</code>.\n      * Subtracts the value of an <tt>integer</tt> from the value of this one,\n      * returning the result in reduced form.\n      * </p>\n-     * \n+     *\n      * @param i\n      *            the <tt>integer</tt> to subtract.\n      * @return a <code>BigFraction</code> instance with the resulting values.\n      * Subtracts the value of an <tt>integer</tt> from the value of this one,\n      * returning the result in reduced form.\n      * </p>\n-     * \n+     *\n      * @param l\n      *            the <tt>long</tt> to subtract.\n      * @return a <code>BigFraction</code> instance with the resulting values, or\n      * Subtracts the value of another fraction from the value of this one,\n      * returning the result in reduced form.\n      * </p>\n-     * \n+     *\n      * @param fraction\n      *            the {@link BigFraction} to subtract, must not be\n      *            <code>null</code>.\n      * Returns the <code>String</code> representing this fraction, ie\n      * \"num / dem\" or just \"num\" if the denominator is one.\n      * </p>\n-     * \n+     *\n      * @return a string representation of the fraction.\n      * @see java.lang.Object#toString()\n      */\n--- a/src/main/java/org/apache/commons/math/fraction/BigFractionField.java\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFractionField.java\n      */\n     private Object readResolve() {\n         // return the singleton instance\n-        return LazyHolder.INSTANCE; \n+        return LazyHolder.INSTANCE;\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/fraction/BigFractionFormat.java\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFractionFormat.java\n  * @version $Revision$ $Date$\n  */\n public class BigFractionFormat extends AbstractFormat implements Serializable {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -2932167925527338976L;\n \n     /**\n      * Create an improper formatting instance with the default number format\n-     * for the numerator and denominator.  \n+     * for the numerator and denominator.\n      */\n     public BigFractionFormat() {\n     }\n \n     /**\n      * Get the set of locales for which complex formats are available.  This\n-     * is the same set as the {@link NumberFormat} set. \n+     * is the same set as the {@link NumberFormat} set.\n      * @return available complex format locales.\n      */\n     public static Locale[] getAvailableLocales() {\n     public static String formatBigFraction(final BigFraction f) {\n         return getImproperInstance().format(f);\n     }\n-    \n+\n     /**\n      * Returns the default complex format for the current locale.\n      * @return the default complex format.\n     public static BigFractionFormat getImproperInstance() {\n         return getImproperInstance(Locale.getDefault());\n     }\n-    \n+\n     /**\n      * Returns the default complex format for the given locale.\n      * @param locale the specific locale used by the format.\n     public static BigFractionFormat getImproperInstance(final Locale locale) {\n         return new BigFractionFormat(getDefaultNumberFormat(locale));\n     }\n-    \n+\n     /**\n      * Returns the default complex format for the current locale.\n      * @return the default complex format.\n     public static BigFractionFormat getProperInstance() {\n         return getProperInstance(Locale.getDefault());\n     }\n-    \n+\n     /**\n      * Returns the default complex format for the given locale.\n      * @param locale the specific locale used by the format.\n     public static BigFractionFormat getProperInstance(final Locale locale) {\n         return new ProperBigFractionFormat(getDefaultNumberFormat(locale));\n     }\n-    \n+\n     /**\n      * Formats a {@link BigFraction} object to produce a string.  The BigFraction is\n      * output in improper format.\n      */\n     public StringBuffer format(final BigFraction BigFraction,\n                                final StringBuffer toAppendTo, final FieldPosition pos) {\n-        \n+\n         pos.setBeginIndex(0);\n         pos.setEndIndex(0);\n \n         getNumeratorFormat().format(BigFraction.getNumerator(), toAppendTo, pos);\n         toAppendTo.append(\" / \");\n         getDenominatorFormat().format(BigFraction.getDenominator(), toAppendTo, pos);\n-        \n+\n         return toAppendTo;\n     }\n-    \n+\n     /**\n      * Formats an object and appends the result to a StringBuffer.\n      * <code>obj</code> must be either a  {@link BigFraction} object or a\n         } else if (obj instanceof Number) {\n             ret = format(new BigFraction(((Number) obj).doubleValue()),\n                          toAppendTo, pos);\n-        } else { \n+        } else {\n             throw MathRuntimeException.createIllegalArgumentException(\n                 \"cannot format given object as a fraction number\");\n         }\n-        \n+\n         return ret;\n     }\n \n         }\n         return result;\n     }\n-    \n+\n     /**\n      * Parses a string to produce a {@link BigFraction} object.\n-     * This method expects the string to be formatted as an improper BigFraction.  \n+     * This method expects the string to be formatted as an improper BigFraction.\n      * @param source the string to parse\n      * @param pos input/ouput parsing parameter.\n      * @return the parsed {@link BigFraction} object.\n--- a/src/main/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math/fraction/Fraction.java\n  * Representation of a rational number.\n  *\n  * implements Serializable since 2.0\n- * \n+ *\n  * @since 1.1\n  * @version $Revision$ $Date$\n  */\n \n     /** The denominator. */\n     private final int denominator;\n-    \n+\n     /** The numerator. */\n     private final int numerator;\n \n             if ((p2 > overflow) || (q2 > overflow)) {\n                 throw new FractionConversionException(value, p2, q2);\n             }\n-            \n+\n             double convergent = (double)p2 / (double)q2;\n             if (n < maxIterations && Math.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                 p0 = p1;\n         if (n >= maxIterations) {\n             throw new FractionConversionException(value, maxIterations);\n         }\n-        \n+\n         if (q2 < maxDenominator) {\n             this.numerator = (int) p2;\n             this.denominator = (int) q2;\n         }\n \n     }\n-    \n-    /**\n-     * Create a fraction from an int. \n+\n+    /**\n+     * Create a fraction from an int.\n      * The fraction is num / 1.\n      * @param num the numerator.\n      */\n     public Fraction(int num) {\n         this(num, 1);\n     }\n-    \n+\n     /**\n      * Create a fraction given the numerator and denominator.  The fraction is\n      * reduced to lowest terms.\n             num /= d;\n             den /= d;\n         }\n-        \n+\n         // move sign to numerator.\n         if (den < 0) {\n             num = -num;\n         this.numerator   = num;\n         this.denominator = den;\n     }\n-    \n+\n     /**\n      * Returns the absolute value of this fraction.\n      * @return the absolute value.\n         } else {\n             ret = negate();\n         }\n-        return ret;        \n-    }\n-    \n+        return ret;\n+    }\n+\n     /**\n      * Compares this object to another based on size.\n      * @param object the object to compare to\n     public double doubleValue() {\n         return (double)numerator / (double)denominator;\n     }\n-    \n+\n     /**\n      * Test for the equality of two fractions.  If the lowest term\n      * numerator and denominators are the same for both fractions, the two\n     @Override\n     public boolean equals(Object other) {\n         boolean ret;\n-        \n-        if (this == other) { \n+\n+        if (this == other) {\n             ret = true;\n         } else if (other == null) {\n             ret = false;\n                 ret = false;\n             }\n         }\n-        \n+\n         return ret;\n     }\n-    \n+\n     /**\n      * Gets the fraction as a <tt>float</tt>. This calculates the fraction as\n      * the numerator divided by denominator.\n     public float floatValue() {\n         return (float)doubleValue();\n     }\n-    \n+\n     /**\n      * Access the denominator.\n      * @return the denominator.\n     public int getDenominator() {\n         return denominator;\n     }\n-    \n+\n     /**\n      * Access the numerator.\n      * @return the numerator.\n     public int getNumerator() {\n         return numerator;\n     }\n-    \n+\n     /**\n      * Gets a hashCode for the fraction.\n      * @return a hash code value for this object\n     public int hashCode() {\n         return 37 * (37 * 17 + getNumerator()) + getDenominator();\n     }\n-    \n+\n     /**\n      * Gets the fraction as an <tt>int</tt>. This returns the whole number part\n      * of the fraction.\n     public int intValue() {\n         return (int)doubleValue();\n     }\n-    \n+\n     /**\n      * Gets the fraction as a <tt>long</tt>. This returns the whole number part\n      * of the fraction.\n     public long longValue() {\n         return (long)doubleValue();\n     }\n-    \n+\n     /**\n      * Return the additive inverse of this fraction.\n      * @return the negation of this fraction.\n     public Fraction reciprocal() {\n         return new Fraction(denominator, numerator);\n     }\n-    \n+\n     /**\n      * <p>Adds the value of this fraction to another, returning the result in reduced form.\n      * The algorithm follows Knuth, 4.5.1.</p>\n     }\n \n     /**\n-     * <p>Subtracts the value of another fraction from the value of this one, \n+     * <p>Subtracts the value of another fraction from the value of this one,\n      * returning the result in reduced form.</p>\n      *\n      * @param fraction  the fraction to subtract, must not be <code>null</code>\n         return new Fraction(numerator - i * denominator, denominator);\n     }\n \n-    /** \n+    /**\n      * Implement add and subtract using algorithm described in Knuth 4.5.1.\n-     * \n+     *\n      * @param fraction the fraction to subtract, must not be <code>null</code>\n      * @param isAdd true to add, false to subtract\n      * @return a <code>Fraction</code> instance with the resulting values\n         }\n         if (fraction.numerator == 0) {\n             return this;\n-        }     \n+        }\n         // if denominators are randomly distributed, d1 will be 1 about 61%\n         // of the time.\n         int d1 = MathUtils.gcd(denominator, fraction.denominator);\n             int uvp = MathUtils.mulAndCheck(numerator, fraction.denominator);\n             int upv = MathUtils.mulAndCheck(fraction.numerator, denominator);\n             return new Fraction\n-                (isAdd ? MathUtils.addAndCheck(uvp, upv) : \n+                (isAdd ? MathUtils.addAndCheck(uvp, upv) :\n                  MathUtils.subAndCheck(uvp, upv),\n                  MathUtils.mulAndCheck(denominator, fraction.denominator));\n         }\n             throw MathRuntimeException.createArithmeticException(\"overflow, numerator too large after multiply: {0}\",\n                                                                  w);\n         }\n-        return new Fraction (w.intValue(), \n-                MathUtils.mulAndCheck(denominator/d1, \n+        return new Fraction (w.intValue(),\n+                MathUtils.mulAndCheck(denominator/d1,\n                         fraction.denominator/d2));\n     }\n \n     /**\n-     * <p>Multiplies the value of this fraction by another, returning the \n+     * <p>Multiplies the value of this fraction by another, returning the\n      * result in reduced form.</p>\n      *\n      * @param fraction  the fraction to multiply by, must not be <code>null</code>\n      * Returns the <code>String</code> representing this fraction, ie\n      * \"num / dem\" or just \"num\" if the denominator is one.\n      * </p>\n-     * \n+     *\n      * @return a string representation of the fraction.\n      * @see java.lang.Object#toString()\n      */\n--- a/src/main/java/org/apache/commons/math/fraction/FractionConversionException.java\n+++ b/src/main/java/org/apache/commons/math/fraction/FractionConversionException.java\n      * Constructs an exception with specified formatted detail message.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param value double value to convert\n-     * @param p current numerator \n+     * @param p current numerator\n      * @param q current denominator\n      */\n     public FractionConversionException(double value, long p, long q) {\n--- a/src/main/java/org/apache/commons/math/fraction/FractionField.java\n+++ b/src/main/java/org/apache/commons/math/fraction/FractionField.java\n      */\n     private Object readResolve() {\n         // return the singleton instance\n-        return LazyHolder.INSTANCE; \n+        return LazyHolder.INSTANCE;\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/fraction/FractionFormat.java\n+++ b/src/main/java/org/apache/commons/math/fraction/FractionFormat.java\n  * @version $Revision$ $Date$\n  */\n public class FractionFormat extends AbstractFormat {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 3008655719530972611L;\n \n     /**\n      * Create an improper formatting instance with the default number format\n-     * for the numerator and denominator.  \n+     * for the numerator and denominator.\n      */\n     public FractionFormat() {\n     }\n \n     /**\n      * Get the set of locales for which complex formats are available.  This\n-     * is the same set as the {@link NumberFormat} set. \n+     * is the same set as the {@link NumberFormat} set.\n      * @return available complex format locales.\n      */\n     public static Locale[] getAvailableLocales() {\n     public static String formatFraction(Fraction f) {\n         return getImproperInstance().format(f);\n     }\n-    \n+\n     /**\n      * Returns the default complex format for the current locale.\n      * @return the default complex format.\n     public static FractionFormat getImproperInstance() {\n         return getImproperInstance(Locale.getDefault());\n     }\n-    \n+\n     /**\n      * Returns the default complex format for the given locale.\n      * @param locale the specific locale used by the format.\n     public static FractionFormat getImproperInstance(final Locale locale) {\n         return new FractionFormat(getDefaultNumberFormat(locale));\n     }\n-    \n+\n     /**\n      * Returns the default complex format for the current locale.\n      * @return the default complex format.\n     public static FractionFormat getProperInstance() {\n         return getProperInstance(Locale.getDefault());\n     }\n-    \n+\n     /**\n      * Returns the default complex format for the given locale.\n      * @param locale the specific locale used by the format.\n     public static FractionFormat getProperInstance(final Locale locale) {\n         return new ProperFractionFormat(getDefaultNumberFormat(locale));\n     }\n-    \n+\n     /**\n      * Create a default number format.  The default number format is based on\n      * {@link NumberFormat#getNumberInstance(java.util.Locale)} with the only\n-     * customizing is the maximum number of fraction digits, which is set to 0.  \n+     * customizing is the maximum number of fraction digits, which is set to 0.\n      * @return the default number format.\n      */\n     protected static NumberFormat getDefaultNumberFormat() {\n         return getDefaultNumberFormat(Locale.getDefault());\n     }\n-    \n+\n     /**\n      * Formats a {@link Fraction} object to produce a string.  The fraction is\n      * output in improper format.\n      */\n     public StringBuffer format(final Fraction fraction,\n                                final StringBuffer toAppendTo, final FieldPosition pos) {\n-        \n+\n         pos.setBeginIndex(0);\n         pos.setEndIndex(0);\n \n         toAppendTo.append(\" / \");\n         getDenominatorFormat().format(fraction.getDenominator(), toAppendTo,\n             pos);\n-        \n+\n         return toAppendTo;\n     }\n-    \n-    /**\n-     * Formats an object and appends the result to a StringBuffer. <code>obj</code> must be either a \n+\n+    /**\n+     * Formats an object and appends the result to a StringBuffer. <code>obj</code> must be either a\n      * {@link Fraction} object or a {@link Number} object.  Any other type of\n      * object will result in an {@link IllegalArgumentException} being thrown.\n      *\n     public StringBuffer format(final Object obj,\n                                final StringBuffer toAppendTo, final FieldPosition pos) {\n         StringBuffer ret = null;\n-        \n+\n         if (obj instanceof Fraction) {\n             ret = format((Fraction) obj, toAppendTo, pos);\n         } else if (obj instanceof Number) {\n                     \"cannot convert given object to a fraction number: {0}\",\n                     ex.getLocalizedMessage());\n             }\n-        } else { \n+        } else {\n             throw MathRuntimeException.createIllegalArgumentException(\n                 \"cannot format given object as a fraction number\");\n         }\n-        \n+\n         return ret;\n     }\n \n         }\n         return result;\n     }\n-    \n+\n     /**\n      * Parses a string to produce a {@link Fraction} object.  This method\n-     * expects the string to be formatted as an improper fraction.  \n+     * expects the string to be formatted as an improper fraction.\n      * @param source the string to parse\n      * @param pos input/ouput parsing parameter.\n      * @return the parsed {@link Fraction} object.\n \n         return new Fraction(num.intValue(), den.intValue());\n     }\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/math/fraction/ProperBigFractionFormat.java\n+++ b/src/main/java/org/apache/commons/math/fraction/ProperBigFractionFormat.java\n  * Minus signs are only allowed in the whole number part - i.e.,\n  * \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n  * will result in a <code>ParseException</code>.</p>\n- * \n+ *\n  * @since 1.1\n  * @version $Revision$ $Date$\n  */\n public class ProperBigFractionFormat extends BigFractionFormat {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6337346779577272307L;\n-    \n+\n     /** The format used for the whole number. */\n     private NumberFormat wholeFormat;\n \n     /**\n      * Create a proper formatting instance with the default number format for\n-     * the whole, numerator, and denominator.  \n+     * the whole, numerator, and denominator.\n      */\n     public ProperBigFractionFormat() {\n         this(getDefaultNumberFormat());\n     }\n-    \n+\n     /**\n      * Create a proper formatting instance with a custom number format for the\n      * whole, numerator, and denominator.\n     public ProperBigFractionFormat(final NumberFormat format) {\n         this(format, (NumberFormat)format.clone(), (NumberFormat)format.clone());\n     }\n-    \n+\n     /**\n      * Create a proper formatting instance with a custom number format for each\n      * of the whole, numerator, and denominator.\n         super(numeratorFormat, denominatorFormat);\n         setWholeFormat(wholeFormat);\n     }\n-    \n+\n     /**\n      * Formats a {@link BigFraction} object to produce a string.  The BigFraction\n      * is output in proper format.\n     @Override\n     public StringBuffer format(final BigFraction fraction,\n                                final StringBuffer toAppendTo, final FieldPosition pos) {\n-        \n+\n         pos.setBeginIndex(0);\n         pos.setEndIndex(0);\n \n         BigInteger den = fraction.getDenominator();\n         BigInteger whole = num.divide(den);\n         num = num.remainder(den);\n-        \n+\n         if (!BigInteger.ZERO.equals(whole)) {\n             getWholeFormat().format(whole, toAppendTo, pos);\n             toAppendTo.append(' ');\n         getNumeratorFormat().format(num, toAppendTo, pos);\n         toAppendTo.append(\" / \");\n         getDenominatorFormat().format(den, toAppendTo, pos);\n-        \n+\n         return toAppendTo;\n     }\n \n     public NumberFormat getWholeFormat() {\n         return wholeFormat;\n     }\n-    \n+\n     /**\n      * Parses a string to produce a {@link BigFraction} object.  This method\n      * expects the string to be formatted as a proper BigFraction.\n      * Minus signs are only allowed in the whole number part - i.e.,\n      * \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n      * will result in a <code>ParseException</code>.</p>\n-     * \n+     *\n      * @param source the string to parse\n      * @param pos input/ouput parsing parameter.\n      * @return the parsed {@link BigFraction} object.\n         if (ret != null) {\n             return ret;\n         }\n-        \n+\n         final int initialIndex = pos.getIndex();\n \n         // parse whitespace\n \n         // parse whitespace\n         parseAndIgnoreWhitespace(source, pos);\n-        \n+\n         // parse numerator\n         BigInteger num = parseNextBigInteger(source, pos);\n         if (num == null) {\n             pos.setIndex(initialIndex);\n             return null;\n         }\n-        \n+\n         if (num.compareTo(BigInteger.ZERO) < 0) {\n             // minus signs should be leading, invalid expression\n             pos.setIndex(initialIndex);\n             pos.setIndex(initialIndex);\n             return null;\n         }\n-        \n+\n         if (den.compareTo(BigInteger.ZERO) < 0) {\n             // minus signs must be leading, invalid\n             pos.setIndex(initialIndex);\n         return new BigFraction(num, den);\n \n     }\n-    \n+\n     /**\n      * Modify the whole format.\n      * @param format The new whole format value.\n--- a/src/main/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n+++ b/src/main/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n  * Minus signs are only allowed in the whole number part - i.e.,\n  * \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n  * will result in a <code>ParseException</code>.</p>\n- * \n+ *\n  * @since 1.1\n  * @version $Revision$ $Date$\n  */\n public class ProperFractionFormat extends FractionFormat {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 760934726031766749L;\n \n \n     /**\n      * Create a proper formatting instance with the default number format for\n-     * the whole, numerator, and denominator.  \n+     * the whole, numerator, and denominator.\n      */\n     public ProperFractionFormat() {\n         this(getDefaultNumberFormat());\n     }\n-    \n+\n     /**\n      * Create a proper formatting instance with a custom number format for the\n      * whole, numerator, and denominator.\n     public ProperFractionFormat(NumberFormat format) {\n         this(format, (NumberFormat)format.clone(), (NumberFormat)format.clone());\n     }\n-    \n+\n     /**\n      * Create a proper formatting instance with a custom number format for each\n      * of the whole, numerator, and denominator.\n         super(numeratorFormat, denominatorFormat);\n         setWholeFormat(wholeFormat);\n     }\n-    \n+\n     /**\n      * Formats a {@link Fraction} object to produce a string.  The fraction\n      * is output in proper format.\n     @Override\n     public StringBuffer format(Fraction fraction, StringBuffer toAppendTo,\n             FieldPosition pos) {\n-        \n+\n         pos.setBeginIndex(0);\n         pos.setEndIndex(0);\n \n         int den = fraction.getDenominator();\n         int whole = num / den;\n         num = num % den;\n-        \n+\n         if (whole != 0) {\n             getWholeFormat().format(whole, toAppendTo, pos);\n             toAppendTo.append(' ');\n         toAppendTo.append(\" / \");\n         getDenominatorFormat().format(den, toAppendTo,\n             pos);\n-        \n+\n         return toAppendTo;\n     }\n \n     public NumberFormat getWholeFormat() {\n         return wholeFormat;\n     }\n-    \n+\n     /**\n      * Parses a string to produce a {@link Fraction} object.  This method\n      * expects the string to be formatted as a proper fraction.\n      * Minus signs are only allowed in the whole number part - i.e.,\n      * \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n      * will result in a <code>ParseException</code>.</p>\n-     * \n+     *\n      * @param source the string to parse\n      * @param pos input/ouput parsing parameter.\n      * @return the parsed {@link Fraction} object.\n         if (ret != null) {\n             return ret;\n         }\n-        \n+\n         int initialIndex = pos.getIndex();\n \n         // parse whitespace\n \n         // parse whitespace\n         parseAndIgnoreWhitespace(source, pos);\n-        \n+\n         // parse numerator\n         Number num = getNumeratorFormat().parse(source, pos);\n         if (num == null) {\n             pos.setIndex(initialIndex);\n             return null;\n         }\n-        \n+\n         if (num.intValue() < 0) {\n             // minus signs should be leading, invalid expression\n             pos.setIndex(initialIndex);\n             pos.setIndex(initialIndex);\n             return null;\n         }\n-        \n+\n         if (den.intValue() < 0) {\n             // minus signs must be leading, invalid\n             pos.setIndex(initialIndex);\n         int d = den.intValue();\n         return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n     }\n-    \n+\n     /**\n      * Modify the whole format.\n      * @param format The new whole format value.\n--- a/src/main/java/org/apache/commons/math/genetics/AbstractListChromosome.java\n+++ b/src/main/java/org/apache/commons/math/genetics/AbstractListChromosome.java\n \n /**\n  * Chromosome represented by an immutable list of a fixed length.\n- * \n+ *\n  * @param <T> type of the representation list\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public abstract class AbstractListChromosome<T> extends Chromosome {\n-    \n+\n     /** List representing the chromosome */\n     private final List<T> representation;\n-    \n+\n     /**\n      * Constructor.\n      * @param representation inner representation of the chromosome\n         }\n         this.representation = Collections.unmodifiableList(new ArrayList<T> (representation));\n     }\n-    \n+\n     /**\n      * Constructor.\n      * @param representation inner representation of the chromosome\n     }\n \n     /**\n-     * \n+     *\n      * Asserts that <code>representation</code> can represent a valid chromosome.\n      * @param chromosomeRepresentation representation of the chromosome\n      * @throws InvalidRepresentationException iff the <code>representation</code> can not represent\n      * given <code>arrayRepresentation</code>. This is needed in crossover and\n      * mutation operators, where we need a new instance of the same class, but\n      * with different array representation.\n-     * \n+     *\n      * Usually, this method just calls a constructor of the class.\n-     * \n+     *\n      * @param chromosomeRepresentation\n      *            the inner array representation of the new chromosome.\n      * @return new instance extended from FixedLengthChromosome with the given\n      *         arrayRepresentation\n      */\n     public abstract AbstractListChromosome<T> newFixedLengthChromosome(final List<T> chromosomeRepresentation);\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n--- a/src/main/java/org/apache/commons/math/genetics/BinaryChromosome.java\n+++ b/src/main/java/org/apache/commons/math/genetics/BinaryChromosome.java\n \n /**\n  * Chromosome represented by a vector of 0s and 1s.\n- * \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public abstract class BinaryChromosome extends AbstractListChromosome<Integer> {\n-    \n+\n     /**\n      * Constructor.\n      * @param representation list of {0,1} values representing the chromosome\n     public BinaryChromosome(List<Integer> representation) {\n         super(representation);\n     }\n-    \n+\n     /**\n      * Constructor.\n      * @param representation array of {0,1} values representing the chromosome\n     public BinaryChromosome(Integer[] representation) {\n         super(representation);\n     }\n-     \n+\n     /**\n      * {@inheritDoc}\n      */\n         }\n         return rList;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         // size check\n         if (getLength() != anotherBc.getLength())\n             return false;\n-        \n+\n         for (int i=0; i< getRepresentation().size(); i++) {\n             if (!(getRepresentation().get(i).equals(anotherBc.getRepresentation().get(i))))\n                 return false;\n--- a/src/main/java/org/apache/commons/math/genetics/BinaryMutation.java\n+++ b/src/main/java/org/apache/commons/math/genetics/BinaryMutation.java\n      */\n     public Chromosome mutate(Chromosome original) {\n         if (!(original instanceof BinaryChromosome)) {\n-            throw new IllegalArgumentException(\"Binary mutation works on BinaryChromosome only.\"); \n+            throw new IllegalArgumentException(\"Binary mutation works on BinaryChromosome only.\");\n         }\n-        \n+\n         BinaryChromosome origChrom = (BinaryChromosome) original;\n         List<Integer> newRepr = new ArrayList<Integer>(origChrom.getRepresentation());\n-        \n+\n         // randomly select a gene\n         int geneIndex = GeneticAlgorithm.getRandomGenerator().nextInt(origChrom.getLength());\n         // and change it\n         newRepr.set(geneIndex, origChrom.getRepresentation().get(geneIndex) == 0 ? 1 : 0);\n-        \n+\n         Chromosome newChrom = origChrom.newFixedLengthChromosome(newRepr);\n         return newChrom;\n     }\n--- a/src/main/java/org/apache/commons/math/genetics/Chromosome.java\n+++ b/src/main/java/org/apache/commons/math/genetics/Chromosome.java\n \n /**\n  * Individual in a population. Chromosomes are compared based on their fitness.\n- * \n+ *\n  * The chromosomes are IMMUTABLE, and so their fitness is also immutable and\n  * therefore it can be cached.\n- * \n+ *\n  * @since 2.0\n- * @version $Revision:$ $Date:$\n+ * @version $Revision$ $Date$\n  */\n public abstract class Chromosome implements Comparable<Chromosome>,Fitness {\n-    \n+\n     /**\n      * Cached value of the fitness of this chromosome.\n      */\n     private double fitness = Double.MIN_VALUE;\n-    \n+\n     /**\n      * Access the fitness of this chromosome. The bigger the fitness, the better\n      * the chromosome.\n-     * \n+     *\n      * Computation of fitness is usually very time-consuming task, therefore the\n      * fitness is cached.\n-     * \n+     *\n      * @return the fitness.\n      */\n     public double getFitness() {\n         }\n         return this.fitness;\n     }\n-        \n+\n     /**\n      * Compares two chromosomes based on their fitness. The bigger the fitness,\n      * the better the chromosome.\n-     * \n+     *\n      * @param another another chromosome to compare\n      * @return\n      * <ul>\n     /**\n      * Returns <code>true<code> iff <code>another</code> has the same\n      * representation and therefore the same fitness. By default, it returns\n-     * false -- override it in your implementation if you need it. \n+     * false -- override it in your implementation if you need it.\n      * @param another chromosome to compare\n      * @return true if <code>another</code> is equivalent to this chromosome\n      */\n      * Searches the <code>population</code> for another chromosome with the same\n      * representation. If such chromosome is found, it is returned, if no such\n      * chromosome exists, returns <code>null</code>.\n-     * \n+     *\n      * @param population\n      *            Population to search\n      * @return Chromosome with the same representation, or <code>null</code> if\n     /**\n      * Searches the population for a chromosome representing the same solution,\n      * and if it finds one, updates the fitness to its value.\n-     * \n+     *\n      * @param population\n      *            Population to search\n      */\n             fitness = sameChromosome.getFitness();\n         }\n     }\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/math/genetics/ChromosomePair.java\n+++ b/src/main/java/org/apache/commons/math/genetics/ChromosomePair.java\n /**\n  * A pair of {@link Chromosome} objects.\n  * @since 2.0\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class ChromosomePair {\n \n     /**\n      * Create a chromosome pair.\n-     * \n+     *\n      * @param c1 the first chromosome.\n      * @param c2 the second chromosome.\n      */\n \n     /**\n      * Access the first chromosome.\n-     * \n+     *\n      * @return the first chromosome.\n      */\n     public Chromosome getFirst() {\n \n     /**\n      * Access the second chromosome.\n-     * \n+     *\n      * @return the second chromosome.\n      */\n     public Chromosome getSecond() {\n         return second;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public String toString() {        \n+    public String toString() {\n         return String.format(\"(%s,%s)\", getFirst(), getSecond());\n     }\n }\n--- a/src/main/java/org/apache/commons/math/genetics/CrossoverPolicy.java\n+++ b/src/main/java/org/apache/commons/math/genetics/CrossoverPolicy.java\n /**\n  * Policy used to create a pair of new chromosomes by performing a crossover\n  * operation on a source pair of chromosomes.\n- * \n+ *\n  * @since 2.0\n  * @version $Revision$ $Date$\n  */\n public interface CrossoverPolicy {\n     /**\n      * Perform a crossover operation on the given chromosomes.\n-     * \n+     *\n      * @param first the first chromosome.\n      * @param second the second chromosome.\n      * @return the pair of new chromosomes that resulted from the crossover.\n--- a/src/main/java/org/apache/commons/math/genetics/ElitisticListPopulation.java\n+++ b/src/main/java/org/apache/commons/math/genetics/ElitisticListPopulation.java\n /**\n  * Population of chromosomes which uses elitism (certain percentace of the best\n  * chromosomes is directly copied to the next generation).\n- * \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public class ElitisticListPopulation extends ListPopulation {\n-    \n+\n     /** percentage of chromosomes copied to the next generation */\n     private double elitismRate = 0.9;\n \n     /**\n      * Creates a new ElitisticListPopulation instance.\n-     * \n+     *\n      * @param chromosomes\n      *            list of chromosomes in the population\n      * @param populationLimit\n     /**\n      * Creates a new ListPopulation instance and initializes its inner\n      * chromosome list.\n-     * \n+     *\n      * @param populationLimit maximal size of the population\n      * @param elitismRate\n      *            how many best chromosomes will be directly transferred to the\n-     *            next generation [in %] \n+     *            next generation [in %]\n      */\n     public ElitisticListPopulation(int populationLimit, double elitismRate) {\n         super(populationLimit);\n \n     /**\n      * Start the population for the next generation. The\n-     * <code>{@link #elitismRate}<code> percents of the best \n+     * <code>{@link #elitismRate}<code> percents of the best\n      * chromosomes are directly copied to the next generation.\n-     * \n+     *\n      * @return the beginnings of the next generation.\n      */\n     public Population nextGeneration() {\n         // initialize a new generation with the same parameters\n         ElitisticListPopulation nextGeneration = new ElitisticListPopulation(this.getPopulationLimit(), this.getElitismRate());\n-        \n+\n         List<Chromosome> oldChromosomes = this.getChromosomes();\n         Collections.sort(oldChromosomes);\n-        \n-        // index of the last \"not good enough\" chromosome \n+\n+        // index of the last \"not good enough\" chromosome\n         int boundIndex = (int) Math.ceil((1.0 - this.getElitismRate()) * oldChromosomes.size());\n         for (int i=boundIndex; i<oldChromosomes.size(); i++) {\n             nextGeneration.addChromosome(oldChromosomes.get(i));\n     /**\n      * Sets the elitism rate, i.e. how many best chromosomes will be directly\n      * transferred to the next generation [in %].\n-     * \n+     *\n      * @param elitismRate\n      *            how many best chromosomes will be directly transferred to the\n      *            next generation [in %]\n--- a/src/main/java/org/apache/commons/math/genetics/Fitness.java\n+++ b/src/main/java/org/apache/commons/math/genetics/Fitness.java\n /**\n  * Fitness of a chromosome.\n  *\n- * @version $Revision:$ $Date:$\n+ * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public interface Fitness {\n     /**\n      * Compute the fitness. This is usually very time-consuming, so the value\n      * should be cached.\n-     * \n+     *\n      * @return fitness\n      */\n     public double fitness();\n--- a/src/main/java/org/apache/commons/math/genetics/FixedGenerationCount.java\n+++ b/src/main/java/org/apache/commons/math/genetics/FixedGenerationCount.java\n package org.apache.commons.math.genetics;\n \n /**\n- * Stops after a fixed number of generations.  Each time \n+ * Stops after a fixed number of generations.  Each time\n  * {@link #isSatisfied(Population)} is invoked, a generation counter is\n- * incremented.  Once the counter reaches the configured \n+ * incremented.  Once the counter reaches the configured\n  * <code>maxGenerations</code> value, {@link #isSatisfied(Population)} returns\n  * true.\n- * \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public class FixedGenerationCount implements StoppingCondition {\n     /** Number of generations that have passed */\n     private int numGenerations = 0;\n-    \n+\n     /** Maximum number of generations (stopping criteria) */\n     private final int maxGenerations;\n-    \n+\n     /**\n      * Create a new FixedGenerationCount instance.\n-     * \n+     *\n      * @param maxGenerations number of generations to evolve\n      */\n     public FixedGenerationCount(int maxGenerations) {\n-        if (maxGenerations <= 0) \n+        if (maxGenerations <= 0)\n             throw new IllegalArgumentException(\"The number of generations has to be >= 0\");\n         this.maxGenerations = maxGenerations;\n     }\n-    \n+\n     /**\n      * Determine whether or not the given number of generations have passed.\n      * Increments the number of generations counter if the maximum has not\n      * been reached.\n-     * \n+     *\n      * @param population ignored (no impact on result)\n      * @return <code>true</code> IFF the maximum number of generations has been exceeded\n      */\n--- a/src/main/java/org/apache/commons/math/genetics/GeneticAlgorithm.java\n+++ b/src/main/java/org/apache/commons/math/genetics/GeneticAlgorithm.java\n \n     /**\n      * Static random number generator shared by GA implementation classes.\n-     * Set the randomGenerator seed to get reproducible results.  \n+     * Set the randomGenerator seed to get reproducible results.\n      * Use {@link #setRandomGenerator(RandomGenerator)} to supply an alternative\n      * to the default JDK-provided PRNG.\n      */\n     //@GuardedBy(\"this\")\n     private static RandomGenerator randomGenerator = new JDKRandomGenerator();\n-    \n+\n     /**\n      * Set the (static) random generator.\n-     * \n+     *\n      * @param random random generator\n      */\n     public synchronized static void setRandomGenerator(RandomGenerator random) {\n         randomGenerator = random;\n     }\n-    \n+\n     /**\n      * Returns the (static) random generator.\n-     * \n+     *\n      * @return the static random generator shared by GA implementation classes\n      */\n     public synchronized static RandomGenerator getRandomGenerator() {\n         return randomGenerator;\n     }\n-      \n+\n     /** the crossover policy used by the algorithm. */\n     private final CrossoverPolicy crossoverPolicy;\n \n \n     /** the selection policy used by the algorithm. */\n     private final SelectionPolicy selectionPolicy;\n-    \n+\n     /**\n      * @param crossoverPolicy The {@link CrossoverPolicy}\n      * @param crossoverRate The crossover rate as a percentage (0-1 inclusive)\n         this.mutationRate = mutationRate;\n         this.selectionPolicy = selectionPolicy;\n     }\n-    \n+\n     /**\n      * Evolve the given population. Evolution stops when the stopping condition\n      * is satisfied.\n-     * \n+     *\n      * @param initial the initial, seed population.\n      * @param condition the stopping condition used to stop evolution.\n      * @return the population that satisfies the stopping condition.\n      *    <li>Return nextGeneration</li>\n      *    </ol>\n      * </p>\n-     * \n+     *\n      * @param current the current population.\n      * @return the population for the next generation.\n      */\n         Population nextGeneration = current.nextGeneration();\n \n         RandomGenerator randGen = getRandomGenerator();\n-        \n+\n         while (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {\n             // select parent chromosomes\n             ChromosomePair pair = getSelectionPolicy().select(current);\n         }\n \n         return nextGeneration;\n-    }    \n-    \n+    }\n+\n     /**\n      * Returns the crossover policy.\n      * @return crossover policy\n     public SelectionPolicy getSelectionPolicy() {\n         return selectionPolicy;\n     }\n-        \n+\n }\n--- a/src/main/java/org/apache/commons/math/genetics/InvalidRepresentationException.java\n+++ b/src/main/java/org/apache/commons/math/genetics/InvalidRepresentationException.java\n \n /**\n  * Exception indicating that the representation of a chromosome is not valid.\n- * \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n \n     /**\n      * Construct an InvalidRepresentationException\n-     * \n+     *\n      * @param arg0 exception message\n      * @param arg1 cause\n      */\n--- a/src/main/java/org/apache/commons/math/genetics/ListPopulation.java\n+++ b/src/main/java/org/apache/commons/math/genetics/ListPopulation.java\n  * @version $Revision$ $Date$\n  */\n public abstract class ListPopulation implements Population {\n-    \n+\n     /** List of chromosomes */\n     private List<Chromosome> chromosomes;\n-    \n+\n     /** maximial size of the population */\n     private int populationLimit;\n-    \n-    \n+\n+\n     /**\n      * Creates a new ListPopulation instance.\n-     * \n+     *\n      * @param chromosomes list of chromosomes in the population\n      * @param populationLimit maximal size of the population\n      */\n         if (populationLimit < 0) {\n             throw new IllegalArgumentException(\"Population limit has to be >= 0\");\n         }\n-            \n+\n         this.chromosomes = chromosomes;\n         this.populationLimit = populationLimit;\n     }\n-    \n+\n     /**\n      * Creates a new ListPopulation instance and initializes its inner\n      * chromosome list.\n-     * \n+     *\n      * @param populationLimit maximal size of the population\n      */\n     public ListPopulation (int populationLimit) {\n     public void setChromosomes(List<Chromosome> chromosomes) {\n         this.chromosomes = chromosomes;\n     }\n-    \n+\n     /**\n      * Access the list of chromosomes.\n      * @return the list of chromosomes\n      */\n     public Chromosome getFittestChromosome() {\n         // best so far\n-        Chromosome bestChromosome = this.chromosomes.get(0);    \n+        Chromosome bestChromosome = this.chromosomes.get(0);\n         for (Chromosome chromosome : this.chromosomes) {\n             if (chromosome.compareTo(bestChromosome) > 0) {\n                 // better chromosome found\n         }\n         return bestChromosome;\n     }\n-    \n+\n     /**\n      * Access the maximum population size.\n      * @return the maximum population size.\n     public int getPopulationLimit() {\n         return this.populationLimit;\n     }\n-    \n+\n     /**\n      * Sets the maximal population size.\n      * @param populationLimit maximal population size.\n      * Access the current population size.\n      * @return the current population size.\n      */\n-    public int getPopulationSize() {        \n+    public int getPopulationSize() {\n         return this.chromosomes.size();\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public String toString() {\n         return this.chromosomes.toString();\n     }\n-    \n+\n     /**\n      * Chromosome list iterator\n-     * \n+     *\n      * @return chromosome iterator\n      */\n-    public Iterator<Chromosome> iterator() {        \n+    public Iterator<Chromosome> iterator() {\n         return chromosomes.iterator();\n     }\n }\n--- a/src/main/java/org/apache/commons/math/genetics/MutationPolicy.java\n+++ b/src/main/java/org/apache/commons/math/genetics/MutationPolicy.java\n \n /**\n  * Algorithm used to mutate a chrommosome.\n- * \n+ *\n  * @since 2.0\n  * @version $Revision$ $Date$\n  */\n--- a/src/main/java/org/apache/commons/math/genetics/OnePointCrossover.java\n+++ b/src/main/java/org/apache/commons/math/genetics/OnePointCrossover.java\n  * One point crossover policy. A random crossover point is selected and the\n  * first part from each parent is copied to the corresponding child, and the\n  * second parts are copied crosswise.\n- * \n+ *\n  * Example:\n  * <pre>\n  * -C- denotes a crossover point\n  *      /------------\\ /-----\\              /------------\\ /-----\\\n  * c1 = (1 0 1 0 0 1  | 1 1 1)    X    p2 = (0 1 1 0 1 0  | 0 1 1)\n  * </pre>\n- * \n- * This policy works only on {@link AbstractListChromosome}, and therefore it \n+ *\n+ * This policy works only on {@link AbstractListChromosome}, and therefore it\n  * is parametrized by T. Moreover, the chromosomes must have same lengths.\n- * \n+ *\n  * @param <T> generic type of the {@link AbstractListChromosome}s for crossover\n  * @since 2.0\n  * @version $Revision$ $Date$\n- * \n+ *\n  */\n public class OnePointCrossover<T> implements CrossoverPolicy {\n-    \n+\n     /**\n      * Performs one point crossover. A random crossover point is selected and the\n      * first part from each parent is copied to the corresponding child, and the\n      * second parts are copied crosswise.\n-     * \n+     *\n      * Example:\n      * -C- denotes a crossover point\n      *                   -C-                                -C-\n      *            VV         (**)                      VV        (*)\n      *      /------------\\ /-----\\              /------------\\ /-----\\\n      * c1 = (1 0 1 0 0 1  | 1 1 1)    X    p2 = (0 1 1 0 1 0  | 0 1 1)\n-     * \n+     *\n      * @param first first parent (p1)\n      * @param second second parent (p2)\n      * @return pair of two children (c1,c2)\n \n     /**\n      * Helper for {@link #crossover(Chromosome, Chromosome)}. Performs the actual crossover.\n-     * \n+     *\n      * @param first the first chromosome.\n      * @param second the second chromosome.\n      * @return the pair of new chromosomes that resulted from the crossover.\n      */\n     private ChromosomePair crossover(AbstractListChromosome<T> first, AbstractListChromosome<T> second) {\n         int length = first.getLength();\n-        if (length != second.getLength()) \n+        if (length != second.getLength())\n             throw new IllegalArgumentException(\"Both chromosomes must have same lengths.\");\n-        \n+\n         // array representations of the parents\n         List<T> parent1Rep = first.getRepresentation();\n         List<T> parent2Rep = second.getRepresentation();\n         // and of the children\n         ArrayList<T> child1Rep = new ArrayList<T> (first.getLength());\n         ArrayList<T> child2Rep = new ArrayList<T> (second.getLength());\n-        \n+\n         // select a crossover point at random (0 and length makes no sense)\n         int crossoverIndex = 1 + (GeneticAlgorithm.getRandomGenerator().nextInt(length-2));\n \n             child1Rep.add(parent2Rep.get(i));\n             child2Rep.add(parent1Rep.get(i));\n         }\n-        \n+\n         return new ChromosomePair(\n                 first.newFixedLengthChromosome(child1Rep),\n                 second.newFixedLengthChromosome(child2Rep)\n--- a/src/main/java/org/apache/commons/math/genetics/PermutationChromosome.java\n+++ b/src/main/java/org/apache/commons/math/genetics/PermutationChromosome.java\n \n /**\n  * Interface indicating that the chromosome represents a permutation of objects.\n- * \n+ *\n  * @param <T>\n  *            type of the permuted objects\n  * @since 2.0\n      * permutation this chromosome represents. For example, if this chromosome\n      * represents a permutation (3,0,1,2), and the unpermuted sequence is\n      * (a,b,c,d), this yields (d,a,b,c).\n-     * \n+     *\n      * @param sequence\n      *            the unpermuted (original) sequence of objects\n      * @return permutation of <code>sequence</code> represented by this\n      *         permutation\n      */\n     public List<T> decode(List<T> sequence);\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/math/genetics/Population.java\n+++ b/src/main/java/org/apache/commons/math/genetics/Population.java\n \n /**\n  * A collection of chromosomes that facilitates generational evolution.\n- * \n+ *\n  * @since 2.0\n- * @version $Revision:$ $Date:$\n+ * @version $Revision$ $Date$\n  */\n public interface Population extends Iterable<Chromosome> {\n     /**\n--- a/src/main/java/org/apache/commons/math/genetics/RandomKey.java\n+++ b/src/main/java/org/apache/commons/math/genetics/RandomKey.java\n  * of a fixed length of real numbers in [0,1] interval. The index of the i-th\n  * smallest value in the vector represents an i-th member of the permutation.\n  * </p>\n- * \n+ *\n  * <p>\n  * For example, the random key [0.2, 0.3, 0.8, 0.1] corresponds to the\n  * permutation of indices (3,0,1,2). If the original (unpermuted) sequence would\n  * be (a,b,c,d), this would mean the sequence (d,a,b,c).\n  * </p>\n- * \n+ *\n  * <p>\n  * With this representation, common operators like n-point crossover can be\n  * used, because any such chromosome represents a valid permutation.\n  * </p>\n- * \n+ *\n  * <p>\n  * Since the chromosome (and thus its arrayRepresentation) is immutable, the\n  * array representation is sorted only once in the constructor.\n  * </p>\n- * \n+ *\n  * <p>\n  * For details, see:\n  * <ul>\n  * Heidelberg (2002)</li>\n  * </ul>\n  * </p>\n- * \n+ *\n  * @param <T>\n  *            type of the permuted objects\n  * @since 2.0\n  * @version $Revision$ $Date$\n  */\n public abstract class RandomKey<T> extends AbstractListChromosome<Double> implements PermutationChromosome<T> {\n-    \n+\n     /**\n      * Cache of sorted representation (unmodifiable).\n      */\n     private final List<Double> sortedRepresentation;\n-    \n+\n     /**\n      * Base sequence [0,1,...,n-1], permuted accorting to the representation (unmodifiable).\n      */\n     private final List<Integer> baseSeqPermutation;\n-    \n+\n     /**\n      * Constructor.\n-     * \n+     *\n      * @param representation list of [0,1] values representing the permutation\n      */\n     public RandomKey(List<Double> representation) {\n             decodeGeneric(baseSequence(getLength()), getRepresentation(), sortedRepresentation)\n         );\n     }\n-    \n+\n     /**\n      * Constructor.\n-     * \n+     *\n      * @param representation array of [0,1] values representing the permutation\n      */\n     public RandomKey(Double[] representation) {\n     /**\n      * Decodes a permutation represented by <code>representation</code> and\n      * returns a (generic) list with the permuted values.\n-     * \n+     *\n      * @param <S> generic type of the sequence values\n      * @param sequence the unpermuted sequence\n      * @param representation representation of the permutation ([0,1] vector)\n      */\n     private static <S> List<S> decodeGeneric(List<S> sequence, List<Double> representation, List<Double> sortedRepr) {\n         int l = sequence.size();\n-        \n+\n         if (representation.size() != l) {\n             throw new IllegalArgumentException(String.format(\"Length of sequence for decoding (%s) has to be equal to the length of the RandomKey (%s)\", l, representation.size()));\n         }\n         if (representation.size() != sortedRepr.size()) {\n             throw new IllegalArgumentException(String.format(\"Representation and sortedRepr must have same sizes, %d != %d\", representation.size(), sortedRepr.size()));\n         }\n-        \n+\n         List<Double> reprCopy = new ArrayList<Double> (representation);// do not modify the orig. representation\n-        \n+\n         // now find the indices in the original repr and use them for permuting\n         List<S> res = new ArrayList<S> (l);\n         for (int i=0; i<l; i++) {\n     /**\n      * Returns <code>true</code> iff <code>another</code> is a RandomKey and\n      * encodes the same permutation.\n-     * \n+     *\n      * @param another chromosome to compare\n      * @return true iff chromosomes encode the same permutation\n      */\n         // size check\n         if (getLength() != anotherRk.getLength())\n             return false;\n-        \n+\n         // two different representations can still encode the same permutation\n         // the ordering is what counts\n         List<Integer> thisPerm = this.baseSeqPermutation;\n         List<Integer> anotherPerm = anotherRk.baseSeqPermutation;\n-        \n+\n         for (int i=0; i<getLength(); i++) {\n             if (thisPerm.get(i) != anotherPerm.get(i))\n                 return false;\n         // the permutations are the same\n         return true;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n-    @Override    \n+    @Override\n     protected void checkValidity(java.util.List<Double> chromosomeRepresentation) throws InvalidRepresentationException {\n         for (double val : chromosomeRepresentation) {\n             if (val < 0 || val > 1) {\n             }\n         }\n     }\n-    \n+\n \n     /**\n      * Generates a representation corresponding to a random permutation of\n      * length l which can be passed to the RandomKey constructor.\n-     * \n+     *\n      * @param l\n      *            length of the permutation\n      * @return representation of a random permutation\n     /**\n      * Generates a representation corresponding to an identity permutation of\n      * length l which can be passed to the RandomKey constructor.\n-     * \n+     *\n      * @param l\n      *            length of the permutation\n      * @return representation of an identity permutation\n      * Generates a representation of a permutation corresponding to the\n      * <code>data</code> sorted by <code>comparator</code>. The\n      * <code>data</code> is not modified during the process.\n-     * \n+     *\n      * This is useful if you want to inject some permutations to the initial\n      * population.\n-     * \n+     *\n      * @param <S> type of the data\n      * @param data list of data determining the order\n      * @param comparator how the data will be compared\n     public static <S> List<Double> comparatorPermutation(List<S> data, Comparator<S> comparator) {\n         List<S> sortedData = new ArrayList<S> (data);\n         Collections.sort(sortedData, comparator);\n-        \n+\n         return inducedPermutation(data, sortedData);\n     }\n \n      * Generates a representation of a permutation corresponding to a\n      * permutation which yields <code>permutedData</code> when applied to\n      * <code>originalData</code>.\n-     * \n+     *\n      * This method can be viewed as an inverse to {@link #decode(List)}.\n-     * \n+     *\n      * @param <S> type of the data\n      * @param originalData the original, unpermuted data\n      * @param permutedData the data, somehow permuted\n      * @return representation of a permutation corresponding to the permutation <code>originalData -> permutedData</code>\n-     * @throws IllegalArgumentException iff the <code>permutedData</code> and <code>originalData</code> contains different data \n+     * @throws IllegalArgumentException iff the <code>permutedData</code> and <code>originalData</code> contains different data\n      */\n     public static <S> List<Double> inducedPermutation(List<S> originalData, List<S> permutedData) throws IllegalArgumentException {\n         if (originalData.size() != permutedData.size()) {\n             throw new IllegalArgumentException(\"originalData and permutedData must have same length\");\n         }\n         int l = originalData.size();\n-        \n+\n         List<S> origDataCopy = new ArrayList<S> (originalData);\n-        \n+\n         Double[] res = new Double[l];\n         for (int i=0; i<l; i++) {\n             int index = origDataCopy.indexOf(permutedData.get(i));\n         }\n         return Arrays.asList(res);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n \n     /**\n      * Helper for constructor. Generates a list of natural numbers (0,1,...,l-1).\n-     * \n+     *\n      * @param l length of list to generate\n      * @return list of integers from 0 to l-1\n      */\n--- a/src/main/java/org/apache/commons/math/genetics/RandomKeyMutation.java\n+++ b/src/main/java/org/apache/commons/math/genetics/RandomKeyMutation.java\n /**\n  * Mutation operator for {@link RandomKey}s. Changes a randomly chosen element\n  * of the array representation to a random value uniformly distributed in [0,1].\n- * \n+ *\n  * @since 2.0\n  * @version $Revision$ $Date$\n  */\n \n     /**\n      * {@inheritDoc}\n-     * \n-     * @throws IllegalArgumentException if <code>original</code> is not a \n+     *\n+     * @throws IllegalArgumentException if <code>original</code> is not a\n      * {@link RandomKey} instance\n      */\n     public Chromosome mutate(Chromosome original) {\n                     \"RandomKeyMutation works only with RandomKeys, got \" +\n                     original.getClass().getSimpleName());\n         }\n-        \n+\n         RandomKey<?> originalRk = (RandomKey<?>) original;\n         List<Double> repr = originalRk.getRepresentation();\n         int rInd = GeneticAlgorithm.getRandomGenerator().nextInt(repr.size());\n-        \n+\n         List<Double> newRepr = new ArrayList<Double> (repr);\n         newRepr.set(rInd, GeneticAlgorithm.getRandomGenerator().nextDouble());\n-        \n+\n         return originalRk.newFixedLengthChromosome(newRepr);\n     }\n \n--- a/src/main/java/org/apache/commons/math/genetics/SelectionPolicy.java\n+++ b/src/main/java/org/apache/commons/math/genetics/SelectionPolicy.java\n \n /**\n  * Algorithm used to select a chromosome pair from a population.\n- * \n+ *\n  * @since 2.0\n- * @version $Revision:$ $Date:$\n+ * @version $Revision$ $Date$\n  */\n public interface SelectionPolicy {\n     /**\n--- a/src/main/java/org/apache/commons/math/genetics/StoppingCondition.java\n+++ b/src/main/java/org/apache/commons/math/genetics/StoppingCondition.java\n \n /**\n  * Algorithm used to determine when to stop evolution.\n- * \n+ *\n  * @since 2.0\n- * @version $Revision:$ $Date:$\n+ * @version $Revision$ $Date$\n  */\n public interface StoppingCondition {\n     /**\n      * Determine whether or not the given population satisfies the stopping\n      * condition.\n-     * \n+     *\n      * @param population the population to test.\n      * @return <code>true</code> if this stopping condition is met by the\n      *         given population. <code>false</code> otherwise.\n--- a/src/main/java/org/apache/commons/math/genetics/TournamentSelection.java\n+++ b/src/main/java/org/apache/commons/math/genetics/TournamentSelection.java\n  * Tournament selection scheme. Each of the two selected chromosomes is selected\n  * based on n-ary tournament -- this is done by drawing {@link #arity} random\n  * chromosomes without replacement from the population, and then selecting the\n- * fittest chromosome among them. \n- * \n+ * fittest chromosome among them.\n+ *\n  * @since 2.0\n  * @version $Revision$ $Date$\n  */\n public class TournamentSelection implements SelectionPolicy {\n-    \n+\n     /** number of chromosomes included in the tournament selections */\n     private int arity;\n-    \n+\n     /**\n      * Creates a new TournamentSelection instance.\n-     * \n+     *\n      * @param arity\n      *            how many chromosomes will be drawn to the tournament\n      */\n      * chromosomes is selected based on n-ary tournament -- this is done by\n      * drawing {@link #arity} random chromosomes without replacement from the\n      * population, and then selecting the fittest chromosome among them.\n-     * \n+     *\n      * @param population\n      *            the population from which the chromosomes are choosen.\n      * @return the selected chromosomes.\n                 tournament((ListPopulation)population)\n                 );\n     }\n-    \n+\n     /**\n      * Helper for {@link #select(Population)}. Draw {@link #arity} random\n      * chromosomes without replacement from the population, and then select the\n      * fittest chromosome among them.\n-     * \n+     *\n      * @param population\n      *            the population from which the chromosomes are choosen.\n      * @return the selected chromosome.\n                 return null;\n             }\n         };\n-        \n+\n         // create a copy of the chromosome list\n         List<Chromosome> chromosomes = new ArrayList<Chromosome> (population.getChromosomes());\n         for (int i=0; i<this.arity; i++) {\n \n     /**\n      * Gets the arity (number of chromosomes drawn to the tournament).\n-     * \n+     *\n      * @return arity of the tournament\n      */\n     public int getArity() {\n \n     /**\n      * Sets the arity (number of chromosomes drawn to the tournament).\n-     * \n+     *\n      * @param arity arity of the tournament\n      */\n     public void setArity(int arity) {\n--- a/src/main/java/org/apache/commons/math/geometry/CardanEulerSingularityException.java\n+++ b/src/main/java/org/apache/commons/math/geometry/CardanEulerSingularityException.java\n public class CardanEulerSingularityException\n   extends MathException {\n \n-  /** \n+  /**\n    * Simple constructor.\n    * build an exception with a default message.\n    * @param isCardan if true, the rotation is related to Cardan angles,\n--- a/src/main/java/org/apache/commons/math/geometry/NotARotationMatrixException.java\n+++ b/src/main/java/org/apache/commons/math/geometry/NotARotationMatrixException.java\n \n import org.apache.commons.math.MathException;\n \n-/** \n+/**\n  * This class represents exceptions thrown while building rotations\n  * from matrices.\n  *\n public class NotARotationMatrixException\n   extends MathException {\n \n-  /** \n+  /**\n    * Simple constructor.\n    * Build an exception by translating and formating a message\n    * @param specifier format specifier (to be translated)\n--- a/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n+++ b/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.MathUtils;\n \n-/** \n+/**\n  * This class implements vectors in a three-dimensional space.\n  * <p>Instance of this class are guaranteed to be immutable.</p>\n  * @version $Revision$ $Date$\n   }\n \n   /** Multiplicative constructor\n-   * Build a vector from another one and a scale factor. \n+   * Build a vector from another one and a scale factor.\n    * The vector built will be a * u\n    * @param a scale factor\n    * @param u base (unscaled) vector\n       }\n       return Math.PI - Math.asin(v3.getNorm() / normProduct);\n     }\n-    \n+\n     // the vectors are sufficiently separated to use the cosine\n     return Math.acos(dot / normProduct);\n \n    * @return  true if any coordinate of this vector is NaN; false otherwise\n    */\n   public boolean isNaN() {\n-      return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z);        \n-  }\n-  \n+      return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z);\n+  }\n+\n   /**\n    * Returns true if any coordinate of this vector is infinite and none are NaN;\n    * false otherwise\n    * false otherwise\n    */\n   public boolean isInfinite() {\n-      return !isNaN() && (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z));        \n-  }\n-  \n+      return !isNaN() && (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z));\n+  }\n+\n   /**\n    * Test for the equality of two 3D vectors.\n    * <p>\n    * @return true if two 3D vector objects are equal, false if\n    *         object is null, not an instance of Vector3D, or\n    *         not equal to this Vector3D instance\n-   * \n+   *\n    */\n   @Override\n   public boolean equals(Object other) {\n \n-    if (this == other) { \n+    if (this == other) {\n       return true;\n     }\n \n           return this.isNaN();\n       }\n \n-      return (x == rhs.x) && (y == rhs.y) && (z == rhs.z); \n+      return (x == rhs.x) && (y == rhs.y) && (z == rhs.z);\n \n     } catch (ClassCastException ex) {\n         // ignore exception\n     }\n \n   }\n-  \n+\n   /**\n    * Get a hashCode for the 3D vector.\n    * <p>\n    * All NaN values have the same hash code.</p>\n-   * \n+   *\n    * @return a hash code value for this object\n    */\n   @Override\n--- a/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n  * @since 2.0\n  */\n public abstract class AbstractFieldMatrix<T extends FieldElement<T>> implements FieldMatrix<T> {\n-    \n+\n     /** Field to which the elements belong. */\n     private final Field<T> field;\n \n     protected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d)\n         throws IllegalArgumentException {\n         if (d.length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n         }\n         if (d[0].length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n         }\n         return d[0][0].getField();\n     }\n     protected static <T extends FieldElement<T>> Field<T> extractField(final T[] d)\n         throws IllegalArgumentException {\n         if (d.length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n         }\n         return d[0].getField();\n     }\n                                                                   final int rows,\n                                                                   final int columns) {\n         if (columns < 0) {\n-            T[] dummyRow = (T[]) Array.newInstance(field.getZero().getClass(), 0); \n-            return (T[][]) Array.newInstance(dummyRow.getClass(), rows);            \n+            T[] dummyRow = (T[]) Array.newInstance(field.getZero().getClass(), 0);\n+            return (T[][]) Array.newInstance(dummyRow.getClass(), rows);\n         }\n         T[][] array =\n             (T[][]) Array.newInstance(field.getZero().getClass(), new int[] { rows, columns });\n     protected AbstractFieldMatrix() {\n         field = null;\n     }\n-    \n+\n     /**\n      * Creates a matrix with no data\n      * @param field field to which the elements belong\n         for (int row = 0; row < rowCount; ++row) {\n             for (int col = 0; col < columnCount; ++col) {\n                 out.setEntry(row, col, getEntry(row, col).add(m.getEntry(row, col)));\n-            }  \n+            }\n         }\n \n         return out;\n         for (int row = 0; row < rowCount; ++row) {\n             for (int col = 0; col < columnCount; ++col) {\n                 out.setEntry(row, col, getEntry(row, col).subtract(m.getEntry(row, col)));\n-            }  \n+            }\n         }\n \n         return out;\n \n         return subMatrix;\n \n-    } \n+    }\n \n     /** {@inheritDoc} */\n     public void copySubMatrix(final int startRow, final int endRow,\n     }\n \n     /** {@inheritDoc} */\n-    public void setSubMatrix(final T[][] subMatrix, final int row, final int column) \n+    public void setSubMatrix(final T[][] subMatrix, final int row, final int column)\n         throws MatrixIndexException {\n \n         final int nRows = subMatrix.length;\n         if (nRows == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n         }\n \n         final int nCols = subMatrix[0].length;\n         if (nCols == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n         }\n \n         for (int r = 1; r < nRows; ++r) {\n             if (subMatrix[r].length != nCols) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"some rows have length {0} while others have length {1}\",\n-                        nCols, subMatrix[r].length); \n+                        nCols, subMatrix[r].length);\n             }\n         }\n \n             for (int j = 0; j < nCols; ++j) {\n                 setEntry(row + i, column + j, subMatrix[i][j]);\n             }\n-        } \n+        }\n \n     }\n \n         return out;\n \n     }\n-    \n+\n     /** {@inheritDoc} */\n     public void setRowMatrix(final int row, final FieldMatrix<T> matrix)\n         throws MatrixIndexException, InvalidMatrixException {\n         }\n \n     }\n-    \n+\n     /** {@inheritDoc} */\n     public FieldMatrix<T> getColumnMatrix(final int column)\n         throws MatrixIndexException {\n         }\n \n     }\n-    \n+\n     /** {@inheritDoc} */\n     public FieldVector<T> getRowVector(final int row)\n         throws MatrixIndexException {\n         }\n \n     }\n-    \n+\n     /** {@inheritDoc} */\n     public FieldVector<T> getColumnVector(final int column)\n         throws MatrixIndexException {\n         }\n \n     }\n-    \n+\n     /** {@inheritDoc} */\n     public T[] getRow(final int row)\n         throws MatrixIndexException {\n         }\n \n     }\n-    \n+\n     /** {@inheritDoc} */\n     public T[] getColumn(final int column)\n         throws MatrixIndexException {\n         }\n \n     }\n-    \n+\n     /** {@inheritDoc} */\n     public abstract T getEntry(int row, int column)\n         throws MatrixIndexException;\n                     res.append(\",\");\n                 }\n                 res.append(getEntry(i, j));\n-            } \n+            }\n             res.append(\"}\");\n-        } \n+        }\n \n         res.append(\"}\");\n         return res.toString();\n \n-    } \n-    \n+    }\n+\n     /**\n      * Returns true iff <code>object</code> is a\n      * <code>FieldMatrix</code> instance with the same dimensions as this\n      * and all corresponding matrix entries are equal.\n-     * \n+     *\n      * @param object the object to test equality against.\n      * @return true if object equals this\n      */\n         }\n         return true;\n     }\n-    \n+\n     /**\n      * Computes a hashcode for the matrix.\n-     * \n+     *\n      * @return hashcode for matrix\n      */\n     @Override\n                                            startColumn, endColumn);\n         }\n \n-    \n+\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n  * @since 2.0\n  */\n public abstract class AbstractRealMatrix implements RealMatrix {\n-    \n-    \n+\n+\n     /** Cached LU solver.\n      * @deprecated as of release 2.0, since all methods using this are deprecated\n      */\n         for (int row = 0; row < rowCount; ++row) {\n             for (int col = 0; col < columnCount; ++col) {\n                 out.setEntry(row, col, getEntry(row, col) + m.getEntry(row, col));\n-            }  \n+            }\n         }\n \n         return out;\n         for (int row = 0; row < rowCount; ++row) {\n             for (int col = 0; col < columnCount; ++col) {\n                 out.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));\n-            }  \n+            }\n         }\n \n         return out;\n \n         });\n     }\n-    \n+\n     /** {@inheritDoc} */\n     public double getFrobeniusNorm() {\n         return walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\n \n         });\n     }\n-    \n+\n     /** {@inheritDoc} */\n     public RealMatrix getSubMatrix(final int startRow, final int endRow,\n                                    final int startColumn, final int endColumn)\n \n         return subMatrix;\n \n-    } \n+    }\n \n     /** {@inheritDoc} */\n     public void copySubMatrix(final int startRow, final int endRow,\n     }\n \n     /** {@inheritDoc} */\n-    public void setSubMatrix(final double[][] subMatrix, final int row, final int column) \n+    public void setSubMatrix(final double[][] subMatrix, final int row, final int column)\n         throws MatrixIndexException {\n \n         final int nRows = subMatrix.length;\n         if (nRows == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n         }\n \n         final int nCols = subMatrix[0].length;\n         if (nCols == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n         }\n \n         for (int r = 1; r < nRows; ++r) {\n             if (subMatrix[r].length != nCols) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"some rows have length {0} while others have length {1}\",\n-                        nCols, subMatrix[r].length); \n+                        nCols, subMatrix[r].length);\n             }\n         }\n \n             for (int j = 0; j < nCols; ++j) {\n                 setEntry(row + i, column + j, subMatrix[i][j]);\n             }\n-        } \n+        }\n \n         lu = null;\n \n         return out;\n \n     }\n-    \n+\n     /** {@inheritDoc} */\n     public void setRowMatrix(final int row, final RealMatrix matrix)\n         throws MatrixIndexException, InvalidMatrixException {\n         }\n \n     }\n-    \n+\n     /** {@inheritDoc} */\n     public RealMatrix getColumnMatrix(final int column)\n         throws MatrixIndexException {\n         }\n \n     }\n-    \n+\n     /** {@inheritDoc} */\n     public RealVector getRowVector(final int row)\n         throws MatrixIndexException {\n         }\n \n     }\n-    \n+\n     /** {@inheritDoc} */\n     public RealVector getColumnVector(final int column)\n         throws MatrixIndexException {\n         }\n \n     }\n-    \n+\n     /** {@inheritDoc} */\n     public double[] getRow(final int row)\n         throws MatrixIndexException {\n         }\n \n     }\n-    \n+\n     /** {@inheritDoc} */\n     public double[] getColumn(final int column)\n         throws MatrixIndexException {\n         }\n \n     }\n-    \n+\n     /** {@inheritDoc} */\n     public abstract double getEntry(int row, int column)\n         throws MatrixIndexException;\n                     res.append(\",\");\n                 }\n                 res.append(getEntry(i, j));\n-            } \n+            }\n             res.append(\"}\");\n-        } \n+        }\n \n         res.append(\"}\");\n         return res.toString();\n \n-    } \n-    \n+    }\n+\n     /**\n      * Returns true iff <code>object</code> is a\n      * <code>RealMatrix</code> instance with the same dimensions as this\n      * and all corresponding matrix entries are equal.\n-     * \n+     *\n      * @param object the object to test equality against.\n      * @return true if object equals this\n      */\n         }\n         return true;\n     }\n-    \n+\n     /**\n      * Computes a hashcode for the matrix.\n-     * \n+     *\n      * @return hashcode for matrix\n      */\n     @Override\n         ret = ret * 31 + nCols;\n         for (int row = 0; row < nRows; ++row) {\n             for (int col = 0; col < nCols; ++col) {\n-               ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * \n+               ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) *\n                    MathUtils.hash(getEntry(row, col));\n            }\n         }\n--- a/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java\n  * @version $Revision$ $Date$\n  */\n public class Array2DRowFieldMatrix<T extends FieldElement<T>> extends AbstractFieldMatrix<T> implements Serializable {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 7260756672015356458L;\n \n         } else {\n             if (d == null) {\n                 throw new NullPointerException();\n-            }   \n+            }\n             final int nRows = d.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n             }\n             final int nCols = d[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n             }\n             for (int r = 1; r < nRows; r++) {\n                 if (d[r].length != nCols) {\n                             \"some rows have length {0} while others have length {1}\",\n                             nCols, d[r].length);\n                 }\n-            }       \n+            }\n             data = d;\n         }\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public void setSubMatrix(final T[][] subMatrix, final int row, final int column) \n+    public void setSubMatrix(final T[][] subMatrix, final int row, final int column)\n     throws MatrixIndexException {\n         if (data == null) {\n             if (row > 0) {\n             }\n             final int nRows = subMatrix.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n             }\n \n             final int nCols = subMatrix[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n             }\n             data = buildArray(getField(), subMatrix.length, nCols);\n             for (int i = 0; i < data.length; ++i) {\n                 if (subMatrix[i].length != nCols) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n                             \"some rows have length {0} while others have length {1}\",\n-                            nCols, subMatrix[i].length); \n+                            nCols, subMatrix[i].length);\n                 }\n                 System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n             }\n             throw new MatrixIndexException(\n                     \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n                     row, column, getRowDimension(), getColumnDimension());\n-        }      \n+        }\n     }\n \n     /** {@inheritDoc} */\n             throw new MatrixIndexException(\n                     \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n                     row, column, getRowDimension(), getColumnDimension());\n-        }      \n+        }\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java\n  * <p>\n  * <strong>Usage notes</strong>:<br>\n  * <ul><li>\n- * The LU decomposition is cached and reused on subsequent calls.   \n+ * The LU decomposition is cached and reused on subsequent calls.\n  * If data are modified via references to the underlying array obtained using\n  * <code>getDataRef()</code>, then the stored LU decomposition will not be\n- * discarded.  In this case, you need to explicitly invoke \n+ * discarded.  In this case, you need to explicitly invoke\n  * <code>LUDecompose()</code> to recompute the decomposition\n  * before using any of the methods above.</li>\n  * <li>\n  * @version $Revision$ $Date$\n  */\n public class Array2DRowRealMatrix extends AbstractRealMatrix implements Serializable {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -1067294169172445528L;\n \n         } else {\n             if (d == null) {\n                 throw new NullPointerException();\n-            }   \n+            }\n             final int nRows = d.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n             }\n             final int nCols = d[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n             }\n             for (int r = 1; r < nRows; r++) {\n                 if (d[r].length != nCols) {\n                             \"some rows have length {0} while others have length {1}\",\n                             nCols, d[r].length);\n                 }\n-            }       \n+            }\n             data = d;\n         }\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public void setSubMatrix(final double[][] subMatrix, final int row, final int column) \n+    public void setSubMatrix(final double[][] subMatrix, final int row, final int column)\n     throws MatrixIndexException {\n         if (data == null) {\n             if (row > 0) {\n             }\n             final int nRows = subMatrix.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n             }\n \n             final int nCols = subMatrix[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n             }\n             data = new double[subMatrix.length][nCols];\n             for (int i = 0; i < data.length; ++i) {\n                 if (subMatrix[i].length != nCols) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n                             \"some rows have length {0} while others have length {1}\",\n-                            nCols, subMatrix[i].length); \n+                            nCols, subMatrix[i].length);\n                 }\n                 System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n             }\n             throw new MatrixIndexException(\n                     \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n                     row, column, getRowDimension(), getColumnDimension());\n-        }      \n+        }\n     }\n \n     /** {@inheritDoc} */\n             throw new MatrixIndexException(\n                     \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n                     row, column, getRowDimension(), getColumnDimension());\n-        }      \n+        }\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java\n             data = d.clone();\n         } catch (ArrayIndexOutOfBoundsException e) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                      \"vector must have at least one element\"); \n+                      \"vector must have at least one element\");\n         }\n     }\n \n \n     /**\n      * Set a set of consecutive elements.\n-     * \n+     *\n      * @param index index of first element to be set.\n      * @param v vector containing the values to set.\n      * @exception MatrixIndexException if the index is\n \n     /**\n      * Check if instance dimension is equal to some expected value.\n-     * \n+     *\n      * @param n expected dimension.\n      * @exception IllegalArgumentException if the dimension is\n      * inconsistent with vector size\n      * @return true if two 3D vector objects are equal, false if\n      *         object is null, not an instance of Vector3D, or\n      *         not equal to this Vector3D instance\n-     * \n+     *\n      */\n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public boolean equals(Object other) {\n \n-      if (this == other) { \n+      if (this == other) {\n         return true;\n       }\n \n       }\n \n     }\n-    \n+\n     /**\n      * Get a hashCode for the real vector.\n      * <p>All NaN values have the same hash code.</p>\n--- a/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n         throws NullPointerException, IllegalArgumentException {\n         if (d == null) {\n             throw new NullPointerException();\n-        }   \n+        }\n         if (d.length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"vector must have at least one element\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"vector must have at least one element\");\n         }\n         data = copyArray ? d.clone() :  d;\n     }\n             checkVectorDimensions(v);\n             double sum = 0;\n             for (int i = 0; i < data.length; ++i) {\n-                final double delta = data[i] - v.getEntry(i); \n+                final double delta = data[i] - v.getEntry(i);\n                 sum += delta * delta;\n             }\n             return Math.sqrt(sum);\n             checkVectorDimensions(v);\n             double sum = 0;\n             for (int i = 0; i < data.length; ++i) {\n-                final double delta = data[i] - v.getEntry(i); \n+                final double delta = data[i] - v.getEntry(i);\n                 sum += Math.abs(delta);\n             }\n             return sum;\n             checkVectorDimensions(v);\n             double max = 0;\n             for (int i = 0; i < data.length; ++i) {\n-                final double delta = data[i] - v.getEntry(i); \n+                final double delta = data[i] - v.getEntry(i);\n                 max = Math.max(max, Math.abs(delta));\n             }\n             return max;\n \n     /**\n      * Set a set of consecutive elements.\n-     * \n+     *\n      * @param index index of first element to be set.\n      * @param v vector containing the values to set.\n      * @exception MatrixIndexException if the index is\n \n     /**\n      * Check if instance dimension is equal to some expected value.\n-     * \n+     *\n      * @param n expected dimension.\n      * @exception IllegalArgumentException if the dimension is\n      * inconsistent with vector size\n         }\n         return false;\n     }\n-    \n+\n     /**\n      * Returns true if any coordinate of this vector is infinite and none are NaN;\n      * false otherwise\n         return false;\n \n     }\n-    \n+\n     /**\n      * Test for the equality of two real vectors.\n      * <p>\n      * @return true if two vector objects are equal, false if\n      *         object is null, not an instance of RealVector, or\n      *         not equal to this RealVector instance\n-     * \n+     *\n      */\n     @Override\n     public boolean equals(Object other) {\n \n-      if (this == other) { \n+      if (this == other) {\n         return true;\n       }\n \n       }\n \n     }\n-    \n+\n     /**\n      * Get a hashCode for the real vector.\n      * <p>All NaN values have the same hash code.</p>\n--- a/src/main/java/org/apache/commons/math/linear/BiDiagonalTransformer.java\n+++ b/src/main/java/org/apache/commons/math/linear/BiDiagonalTransformer.java\n     private RealMatrix cachedV;\n \n     /**\n-     * Build the transformation to bi-diagonal shape of a matrix. \n+     * Build the transformation to bi-diagonal shape of a matrix.\n      * @param matrix the matrix to transform.\n      */\n     public BiDiagonalTransformer(RealMatrix matrix) {\n     }\n \n     /**\n-     * Returns the matrix U of the transform. \n+     * Returns the matrix U of the transform.\n      * <p>U is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n      * @return the U matrix\n      */\n     }\n \n     /**\n-     * Returns the bi-diagonal matrix B of the transform. \n+     * Returns the bi-diagonal matrix B of the transform.\n      * @return the B matrix\n      */\n     public RealMatrix getB() {\n     }\n \n     /**\n-     * Returns the matrix V of the transform. \n+     * Returns the matrix V of the transform.\n      * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n      * @return the V matrix\n      */\n--- a/src/main/java/org/apache/commons/math/linear/BigMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BigMatrix.java\n      * @return matrix copy\n      */\n     BigMatrix copy();\n-    \n+\n     /**\n      * Compute the sum of this and m.\n      *\n      * @exception  IllegalArgumentException if m is not the same size as this\n      */\n     BigMatrix add(BigMatrix m) throws IllegalArgumentException;\n-    \n+\n     /**\n      * Compute this minus m.\n      *\n      * @exception  IllegalArgumentException if m is not the same size as this\n      */\n     BigMatrix subtract(BigMatrix m) throws IllegalArgumentException;\n-    \n+\n      /**\n      * Returns the result of adding d to each entry of this.\n      *\n      * @return     d + this\n      */\n     BigMatrix scalarAdd(BigDecimal d);\n-    \n+\n     /**\n      * Returns the result multiplying each entry of this by d.\n      *\n      * @return     d * this\n      */\n     BigMatrix scalarMultiply(BigDecimal d);\n-    \n+\n     /**\n      * Returns the result of postmultiplying this by m.\n      *\n      * @param m    matrix to postmultiply by\n      * @return     this * m\n-     * @throws     IllegalArgumentException \n+     * @throws     IllegalArgumentException\n      *             if columnDimension(this) != rowDimension(m)\n      */\n     BigMatrix multiply(BigMatrix m) throws IllegalArgumentException;\n-    \n+\n     /**\n      * Returns the result premultiplying this by <code>m</code>.\n      * @param m    matrix to premultiply by\n      *             if rowDimension(this) != columnDimension(m)\n      */\n     public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException;\n-    \n+\n     /**\n      * Returns matrix entries as a two-dimensional array.\n      *\n      * @return norm\n      */\n     BigDecimal getNorm();\n-    \n+\n     /**\n      * Gets a submatrix. Rows and columns are indicated\n      * counting from 0 to n-1.\n      */\n     BigMatrix getSubMatrix(int startRow, int endRow, int startColumn,\n             int endColumn) throws MatrixIndexException;\n-    \n+\n     /**\n      * Gets a submatrix. Rows and columns are indicated\n      * counting from 0 to n-1.\n      */\n     BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n     throws MatrixIndexException;\n-    \n+\n     /**\n      * Returns the entries in row number <code>row</code>\n      * as a row matrix.  Row indices start at 0.\n      * @throws MatrixIndexException if the specified row index is invalid\n      */\n     BigMatrix getRowMatrix(int row) throws MatrixIndexException;\n-    \n+\n     /**\n      * Returns the entries in column number <code>column</code>\n      * as a column matrix.  Column indices start at 0.\n      * @throws MatrixIndexException if the specified column index is invalid\n      */\n     BigMatrix getColumnMatrix(int column) throws MatrixIndexException;\n-    \n+\n     /**\n      * Returns the entries in row number <code>row</code> as an array.\n      * <p>\n     /**\n      * Returns the entry in the specified row and column.\n      * <p>\n-     * Row and column indices start at 0 and must satisfy \n+     * Row and column indices start at 0 and must satisfy\n      * <ul>\n      * <li><code>0 <= row < rowDimension</code></li>\n      * <li><code> 0 <= column < columnDimension</code></li>\n      * </ul>\n      * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n      *\n-     * @param row  row location of entry to be fetched  \n+     * @param row  row location of entry to be fetched\n      * @param column  column location of entry to be fetched\n      * @return matrix entry in row,column\n      * @throws MatrixIndexException if the row or column index is not valid\n      */\n     BigDecimal getEntry(int row, int column) throws MatrixIndexException;\n-    \n+\n     /**\n      * Returns the entry in the specified row and column as a double.\n      * <p>\n-     * Row and column indices start at 0 and must satisfy \n+     * Row and column indices start at 0 and must satisfy\n      * <ul>\n      * <li><code>0 <= row < rowDimension</code></li>\n      * <li><code> 0 <= column < columnDimension</code></li>\n      * @return transpose matrix\n      */\n     BigMatrix transpose();\n-    \n+\n     /**\n      * Returns the inverse of this matrix.\n      *\n      * @return inverse matrix\n-     * @throws org.apache.commons.math.linear.InvalidMatrixException if \n+     * @throws org.apache.commons.math.linear.InvalidMatrixException if\n      *     this is not invertible\n      */\n     BigMatrix inverse() throws InvalidMatrixException;\n-    \n+\n     /**\n      * Returns the determinant of this matrix.\n      *\n      * @return determinant\n-      *@throws org.apache.commons.math.linear.InvalidMatrixException if \n+      *@throws org.apache.commons.math.linear.InvalidMatrixException if\n       *    matrix is not square\n      */\n     BigDecimal getDeterminant() throws InvalidMatrixException;\n-    \n+\n     /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/MatrixTrace.html\">\n      * trace</a> of the matrix (the sum of the elements on the main diagonal).\n      * @return trace\n      */\n     BigDecimal getTrace();\n-    \n+\n     /**\n      * Returns the result of multiplying this by the vector <code>v</code>.\n      *\n      * @throws IllegalArgumentException if rowDimension != v.size()\n      */\n     BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException;\n-    \n+\n     /**\n      * Returns the solution vector for a linear system with coefficient\n      * matrix = this and constant vector = <code>b</code>.\n      *\n      * @param b  constant vector\n      * @return vector of solution values to AX = b, where A is *this\n-     * @throws IllegalArgumentException if this.rowDimension != b.length \n+     * @throws IllegalArgumentException if this.rowDimension != b.length\n      * @throws org.apache.commons.math.linear.InvalidMatrixException if this matrix is not square or is singular\n      */\n     BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException;\n     /**\n      * Returns a matrix of (column) solution vectors for linear systems with\n      * coefficient matrix = this and constant vectors = columns of\n-     * <code>b</code>. \n+     * <code>b</code>.\n      *\n      * @param b  matrix of constant vectors forming RHS of linear systems to\n      * to solve\n--- a/src/main/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/BigMatrixImpl.java\n /**\n  * Implementation of {@link BigMatrix} using a BigDecimal[][] array to store entries\n  * and <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n- * LU decompostion</a> to support linear system \n+ * LU decompostion</a> to support linear system\n  * solution and inverse.\n  * <p>\n  * The LU decompostion is performed as needed, to support the following operations: <ul>\n  * As specified in the {@link BigMatrix} interface, matrix element indexing\n  * is 0-based -- e.g., <code>getEntry(0, 0)</code>\n  * returns the element in the first row, first column of the matrix.</li></ul></p>\n- * \n+ *\n  * @deprecated as of 2.0, replaced by {@link Array2DRowFieldMatrix} with a {@link\n  * org.apache.commons.math.util.BigReal} parameter\n  * @version $Revision$ $Date$\n  */\n @Deprecated\n public class BigMatrixImpl implements BigMatrix, Serializable {\n-    \n+\n     /** Serialization id */\n     private static final long serialVersionUID = -1011428905656140431L;\n-    \n+\n     /** Entries of the matrix */\n     protected BigDecimal data[][] = null;\n-    \n+\n     /** Entries of cached LU decomposition.\n      *  All updates to data (other than luDecompose()) *must* set this to null\n      */\n     protected BigDecimal lu[][] = null;\n-    \n+\n     /** Permutation associated with LU decomposition */\n     protected int[] permutation = null;\n-    \n+\n     /** Parity of the permutation associated with the LU decomposition */\n     protected int parity = 1;\n-    \n+\n     /** Rounding mode for divisions **/\n     private int roundingMode = BigDecimal.ROUND_HALF_UP;\n-    \n+\n     /*** BigDecimal scale ***/\n     private int scale = 64;\n-    \n+\n     /** Bound to determine effective singularity in LU decomposition */\n     private static final BigDecimal TOO_SMALL = new BigDecimal(10E-12);\n-    \n+\n     /** BigDecimal 0 */\n     static final BigDecimal ZERO = new BigDecimal(0);\n     /** BigDecimal 1 */\n     static final BigDecimal ONE = new BigDecimal(1);\n-    \n-    /** \n+\n+    /**\n      * Creates a matrix with no data\n      */\n     public BigMatrixImpl() {\n     }\n-    \n+\n     /**\n      * Create a new BigMatrix with the supplied row and column dimensions.\n      *\n         data = new BigDecimal[rowDimension][columnDimension];\n         lu = null;\n     }\n-    \n+\n     /**\n      * Create a new BigMatrix using <code>d</code> as the underlying\n      * data array.\n         } else {\n             if (d == null) {\n                 throw new NullPointerException();\n-            }   \n+            }\n             final int nRows = d.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n             }\n \n             final int nCols = d[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n             }\n             for (int r = 1; r < nRows; r++) {\n                 if (d[r].length != nCols) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n                           \"some rows have length {0} while others have length {1}\",\n-                          nCols, d[r].length); \n+                          nCols, d[r].length);\n                 }\n-            }       \n+            }\n             data = d;\n         }\n         lu = null;\n     public BigMatrixImpl(double[][] d) {\n         final int nRows = d.length;\n         if (nRows == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n         }\n \n         final int nCols = d[0].length;\n         if (nCols == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n         }\n         for (int row = 1; row < nRows; row++) {\n             if (d[row].length != nCols) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                       \"some rows have length {0} while others have length {1}\",\n-                      nCols, d[row].length); \n+                      nCols, d[row].length);\n             }\n         }\n         this.copyIn(d);\n         lu = null;\n     }\n-    \n-    /**\n-     * Create a new BigMatrix using the values represented by the strings in \n+\n+    /**\n+     * Create a new BigMatrix using the values represented by the strings in\n      * <code>d</code> as the underlying data array.\n      *\n      * @param d data for new matrix\n     public BigMatrixImpl(String[][] d) {\n         final int nRows = d.length;\n         if (nRows == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n         }\n \n         final int nCols = d[0].length;\n         if (nCols == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n         }\n         for (int row = 1; row < nRows; row++) {\n             if (d[row].length != nCols) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                       \"some rows have length {0} while others have length {1}\",\n-                      nCols, d[row].length); \n+                      nCols, d[row].length);\n             }\n         }\n         this.copyIn(d);\n         lu = null;\n     }\n-    \n+\n     /**\n      * Create a new (column) BigMatrix using <code>v</code> as the\n-     * data for the unique column of the <code>v.length x 1</code> matrix \n+     * data for the unique column of the <code>v.length x 1</code> matrix\n      * created.\n      * <p>\n      * The input array is copied, not referenced.</p>\n             data[row][0] = v[row];\n         }\n     }\n-    \n+\n     /**\n      * Create a new BigMatrix which is a copy of this.\n      *\n     public BigMatrix copy() {\n         return new BigMatrixImpl(this.copyOut(), false);\n     }\n-    \n+\n     /**\n      * Compute the sum of this and <code>m</code>.\n      *\n                 final BigDecimal[] outDataRow = outData[row];\n                 for (int col = 0; col < columnCount; col++) {\n                     outDataRow[col] = dataRow[col].add(m.getEntry(row, col));\n-                }  \n+                }\n             }\n             return new BigMatrixImpl(outData, false);\n         }\n             final BigDecimal[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n                 outDataRow[col] = dataRow[col].add(mRow[col]);\n-            }  \n+            }\n         }\n         return new BigMatrixImpl(outData, false);\n     }\n                 final BigDecimal[] outDataRow = outData[row];\n                 for (int col = 0; col < columnCount; col++) {\n                     outDataRow[col] = dataRow[col].subtract(getEntry(row, col));\n-                }  \n+                }\n             }\n             return new BigMatrixImpl(outData, false);\n         }\n             final BigDecimal[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n                 outDataRow[col] = dataRow[col].subtract(mRow[col]);\n-            }  \n+            }\n         }\n         return new BigMatrixImpl(outData, false);\n     }\n                 }\n                 outDataRow[col] = sum;\n             }\n-        }            \n+        }\n         return new BigMatrixImpl(outData, false);\n     }\n \n     public BigDecimal[][] getData() {\n         return copyOut();\n     }\n-    \n+\n     /**\n      * Returns matrix entries as a two-dimensional array.\n      * <p>\n         }\n         return d;\n     }\n-    \n+\n     /**\n      * Returns a reference to the underlying data array.\n      * <p>\n     public BigDecimal[][] getDataRef() {\n         return data;\n     }\n-    \n+\n     /***\n      * Gets the rounding mode for division operations\n      * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}\n      * @see BigDecimal\n      * @return the rounding mode.\n-     */ \n+     */\n     public int getRoundingMode() {\n         return roundingMode;\n     }\n-    \n+\n     /***\n      * Sets the rounding mode for decimal divisions.\n      * @see BigDecimal\n     public void setRoundingMode(int roundingMode) {\n         this.roundingMode = roundingMode;\n     }\n-    \n+\n     /***\n      * Sets the scale for division operations.\n      * The default is 64\n     public int getScale() {\n         return scale;\n     }\n-    \n+\n     /***\n      * Sets the scale for division operations.\n      * @see BigDecimal\n     public void setScale(int scale) {\n         this.scale = scale;\n     }\n-    \n+\n     /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/MaximumAbsoluteRowSumNorm.html\">\n      * maximum absolute row sum norm</a> of the matrix.\n         }\n         return maxColSum;\n     }\n-    \n+\n     /**\n      * Gets a submatrix. Rows and columns are indicated\n      * counting from 0 to n-1.\n         return new BigMatrixImpl(subMatrixData, false);\n \n     }\n-    \n+\n     /**\n      * Gets a submatrix. Rows and columns are indicated\n      * counting from 0 to n-1.\n             }\n         }\n         return new BigMatrixImpl(subMatrixData, false);\n-    } \n-    \n+    }\n+\n     /**\n      * Replace the submatrix starting at <code>row, column</code> using data in\n      * the input <code>subMatrix</code> array. Indexes are 0-based.\n-     * <p> \n+     * <p>\n      * Example:<br>\n      * Starting with <pre>\n      * 1  2  3  4\n      * 5  6  7  8\n      * 9  0  1  2\n      * </pre>\n-     * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking \n+     * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking\n      * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>\n      * 1  2  3  4\n      * 5  3  4  8\n      * 9  5  6  2\n      * </pre></p>\n-     * \n+     *\n      * @param subMatrix  array containing the submatrix replacement data\n      * @param row  row coordinate of the top, left element to be replaced\n      * @param column  column coordinate of the top, left element to be replaced\n-     * @throws MatrixIndexException  if subMatrix does not fit into this \n-     *    matrix from element in (row, column) \n+     * @throws MatrixIndexException  if subMatrix does not fit into this\n+     *    matrix from element in (row, column)\n      * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular\n      *  (not all rows have the same length) or empty\n      * @throws NullPointerException if <code>subMatrix</code> is null\n      * @since 1.1\n      */\n-    public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column) \n+    public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column)\n     throws MatrixIndexException {\n \n         final int nRows = subMatrix.length;\n         if (nRows == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n         }\n \n         final int nCols = subMatrix[0].length;\n         if (nCols == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n         }\n \n         for (int r = 1; r < nRows; r++) {\n             if (subMatrix[r].length != nCols) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                       \"some rows have length {0} while others have length {1}\",\n-                      nCols, subMatrix[r].length); \n+                      nCols, subMatrix[r].length);\n             }\n         }\n \n                         column);\n             }\n             data = new BigDecimal[nRows][nCols];\n-            System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);          \n+            System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);\n         } else {\n             MatrixUtils.checkRowIndex(this, row);\n             MatrixUtils.checkColumnIndex(this, column);\n         }\n         for (int i = 0; i < nRows; i++) {\n             System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);\n-        } \n+        }\n \n         lu = null;\n \n     }\n-    \n+\n     /**\n      * Returns the entries in row number <code>row</code>\n      * as a row matrix.  Row indices start at 0.\n     public BigMatrix getRowMatrix(int row) throws MatrixIndexException {\n         MatrixUtils.checkRowIndex(this, row);\n         final int ncols = this.getColumnDimension();\n-        final BigDecimal[][] out = new BigDecimal[1][ncols]; \n+        final BigDecimal[][] out = new BigDecimal[1][ncols];\n         System.arraycopy(data[row], 0, out[0], 0, ncols);\n         return new BigMatrixImpl(out, false);\n-    } \n-    \n+    }\n+\n     /**\n      * Returns the entries in column number <code>column</code>\n      * as a column matrix.  Column indices start at 0.\n     public BigMatrix getColumnMatrix(int column) throws MatrixIndexException {\n         MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = this.getRowDimension();\n-        final BigDecimal[][] out = new BigDecimal[nRows][1]; \n+        final BigDecimal[][] out = new BigDecimal[nRows][1];\n         for (int row = 0; row < nRows; row++) {\n             out[row][0] = data[row][column];\n         }\n         return new BigMatrixImpl(out, false);\n     }\n-    \n+\n     /**\n      * Returns the entries in row number <code>row</code> as an array.\n      * <p>\n         System.arraycopy(data[row], 0, out, 0, ncols);\n         return out;\n     }\n-    \n+\n      /**\n      * Returns the entries in row number <code>row</code> as an array\n      * of double values.\n         }\n         return out;\n     }\n-    \n+\n      /**\n      * Returns the entries in column number <code>col</code> as an array.\n      * <p>\n         }\n         return out;\n     }\n-    \n+\n     /**\n      * Returns the entries in column number <code>col</code> as an array\n      * of double values.\n         }\n         return out;\n     }\n-    \n+\n      /**\n      * Returns the entry in the specified row and column.\n      * <p>\n-     * Row and column indices start at 0 and must satisfy \n+     * Row and column indices start at 0 and must satisfy\n      * <ul>\n      * <li><code>0 <= row < rowDimension</code></li>\n      * <li><code> 0 <= column < columnDimension</code></li>\n      * </ul>\n      * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n      *\n-     * @param row  row location of entry to be fetched  \n+     * @param row  row location of entry to be fetched\n      * @param column  column location of entry to be fetched\n      * @return matrix entry in row,column\n      * @throws MatrixIndexException if the row or column index is not valid\n                     row, column, getRowDimension(), getColumnDimension());\n         }\n     }\n-    \n+\n     /**\n      * Returns the entry in the specified row and column as a double.\n      * <p>\n-     * Row and column indices start at 0 and must satisfy \n+     * Row and column indices start at 0 and must satisfy\n      * <ul>\n      * <li><code>0 <= row < rowDimension</code></li>\n      * <li><code> 0 <= column < columnDimension</code></li>\n     public double getEntryAsDouble(int row, int column) throws MatrixIndexException {\n         return getEntry(row,column).doubleValue();\n     }\n-    \n+\n     /**\n      * Returns the transpose matrix.\n      *\n         }\n         return new BigMatrixImpl(outData, false);\n     }\n-    \n+\n     /**\n      * Returns the inverse matrix if this matrix is invertible.\n-     * \n+     *\n      * @return inverse matrix\n      * @throws InvalidMatrixException if this is not invertible\n      */\n     public BigMatrix inverse() throws InvalidMatrixException {\n         return solve(MatrixUtils.createBigIdentityMatrix(getRowDimension()));\n     }\n-    \n+\n     /**\n      * Returns the determinant of this matrix.\n      *\n             return det;\n         }\n     }\n-    \n+\n      /**\n      * Is this a square matrix?\n      * @return true if the matrix is square (rowDimension = columnDimension)\n     public boolean isSquare() {\n         return (this.getColumnDimension() == this.getRowDimension());\n     }\n-    \n+\n     /**\n      * Is this a singular matrix?\n      * @return true if the matrix is singular\n             return false; // so the matrix is not singular\n         }\n     }\n-    \n+\n     /**\n      * Returns the number of rows in the matrix.\n      *\n     public int getRowDimension() {\n         return data.length;\n     }\n-    \n+\n     /**\n      * Returns the number of columns in the matrix.\n      *\n     public int getColumnDimension() {\n         return data[0].length;\n     }\n-    \n+\n      /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/MatrixTrace.html\">\n      * trace</a> of the matrix (the sum of the elements on the main diagonal).\n      *\n      * @return trace\n-     * \n+     *\n      * @throws IllegalArgumentException if this matrix is not square.\n      */\n     public BigDecimal getTrace() throws IllegalArgumentException {\n         }\n         return trace;\n     }\n-    \n+\n     /**\n      * Returns the result of multiplying this by the vector <code>v</code>.\n      *\n         }\n         return out;\n     }\n-    \n+\n     /**\n      * Returns the result of multiplying this by the vector <code>v</code>.\n      *\n         }\n         return operate(bd);\n     }\n-    \n+\n     /**\n      * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n      *\n         }\n         return out;\n     }\n-    \n+\n     /**\n      * Returns a matrix of (column) solution vectors for linear systems with\n      * coefficient matrix = this and constant vectors = columns of\n-     * <code>b</code>. \n+     * <code>b</code>.\n      *\n      * @param b  array of constants forming RHS of linear systems to\n      * to solve\n         }\n         return out;\n     }\n-    \n+\n     /**\n      * Returns a matrix of (column) solution vectors for linear systems with\n      * coefficient matrix = this and constant vectors = columns of\n-     * <code>b</code>. \n+     * <code>b</code>.\n      *\n      * @param b  array of constants forming RHS of linear systems to\n      * to solve\n         }\n         return solve(bd);\n     }\n-    \n+\n     /**\n      * Returns a matrix of (column) solution vectors for linear systems with\n      * coefficient matrix = this and constant vectors = columns of\n-     * <code>b</code>. \n+     * <code>b</code>.\n      *\n      * @param b  matrix of constant vectors forming RHS of linear systems to\n      * to solve\n         if (this.isSingular()) { // side effect: compute LU decomp\n             throw new SingularMatrixException();\n         }\n-        \n+\n         final int nCol = this.getColumnDimension();\n         final int nColB = b.getColumnDimension();\n         final int nRowB = b.getRowDimension();\n-        \n+\n         // Apply permutations to b\n         final BigDecimal[][] bp = new BigDecimal[nRowB][nColB];\n         for (int row = 0; row < nRowB; row++) {\n                 bpRow[col] = b.getEntry(permutation[row], col);\n             }\n         }\n-        \n+\n         // Solve LY = b\n         for (int col = 0; col < nCol; col++) {\n             for (int i = col + 1; i < nCol; i++) {\n                 }\n             }\n         }\n-        \n+\n         // Solve UX = Y\n         for (int col = nCol - 1; col >= 0; col--) {\n             final BigDecimal[] bpCol = bp[col];\n         return new BigMatrixImpl(bp, false);\n \n     }\n-    \n-    /**\n-     * Computes a new \n+\n+    /**\n+     * Computes a new\n      * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n-     * LU decompostion</a> for this matrix, storing the result for use by other methods. \n+     * LU decompostion</a> for this matrix, storing the result for use by other methods.\n      * <p>\n      * <strong>Implementation Note</strong>:<br>\n      * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/people/sd/lectures/nummeth98/linear.htm\">\n      * @throws InvalidMatrixException if the matrix is non-square or singular.\n      */\n     public void luDecompose() throws InvalidMatrixException {\n-        \n+\n         final int nRows = this.getRowDimension();\n         final int nCols = this.getColumnDimension();\n         if (nRows != nCols) {\n             throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());\n         }\n         lu = this.getData();\n-        \n+\n         // Initialize permutation array and parity\n         permutation = new int[nRows];\n         for (int row = 0; row < nRows; row++) {\n             permutation[row] = row;\n         }\n         parity = 1;\n-        \n+\n         // Loop over columns\n         for (int col = 0; col < nCols; col++) {\n-            \n+\n             BigDecimal sum = ZERO;\n-            \n+\n             // upper\n             for (int row = 0; row < col; row++) {\n                 final BigDecimal[] luRow = lu[row];\n                 }\n                 luRow[col] = sum;\n             }\n-            \n+\n             // lower\n             int max = col; // permutation row\n             BigDecimal largest = ZERO;\n                     sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n                 }\n                 luRow[col] = sum;\n-                \n+\n                 // maintain best permutation choice\n                 if (sum.abs().compareTo(largest) == 1) {\n                     largest = sum.abs();\n                     max = row;\n                 }\n             }\n-            \n+\n             // Singularity check\n             if (lu[max][col].abs().compareTo(TOO_SMALL) <= 0) {\n                 lu = null;\n                 throw new SingularMatrixException();\n             }\n-            \n+\n             // Pivot if necessary\n             if (max != col) {\n                 BigDecimal tmp = ZERO;\n                 permutation[col] = temp;\n                 parity = -parity;\n             }\n-            \n+\n             // Divide the lower elements by the \"winning\" diagonal elt.\n             final BigDecimal luDiag = lu[col][col];\n             for (int row = col + 1; row < nRows; row++) {\n                 final BigDecimal[] luRow = lu[row];\n                 luRow[col] = luRow[col].divide(luDiag, scale, roundingMode);\n             }\n-            \n-        }\n-        \n-    }\n-    \n+\n+        }\n+\n+    }\n+\n     /**\n      * Get a string representation for this matrix.\n      * @return a string representation for this matrix\n                         res.append(\",\");\n                     }\n                     res.append(data[i][j]);\n-                } \n+                }\n                 res.append(\"}\");\n-            } \n+            }\n         }\n         res.append(\"}\");\n         return res.toString();\n-    } \n-    \n-    /**\n-     * Returns true iff <code>object</code> is a \n+    }\n+\n+    /**\n+     * Returns true iff <code>object</code> is a\n      * <code>BigMatrixImpl</code> instance with the same dimensions as this\n      * and all corresponding matrix entries are equal.  BigDecimal.equals\n      * is used to compare corresponding entries.\n-     * \n+     *\n      * @param object the object to test equality against.\n      * @return true if object equals this\n      */\n         }\n         return true;\n     }\n-    \n+\n     /**\n      * Computes a hashcode for the matrix.\n-     * \n+     *\n      * @return hashcode for matrix\n      */\n     @Override\n         for (int row = 0; row < nRows; row++) {\n             final BigDecimal[] dataRow = data[row];\n             for (int col = 0; col < nCols; col++) {\n-                ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * \n+                ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) *\n                 dataRow[col].hashCode();\n             }\n-        }   \n+        }\n         return ret;\n     }\n-    \n+\n     //------------------------ Protected methods\n-    \n+\n     /**\n      *  Returns the LU decomposition as a BigMatrix.\n-     *  Returns a fresh copy of the cached LU matrix if this has been computed; \n-     *  otherwise the composition is computed and cached for use by other methods.   \n-     *  Since a copy is returned in either case, changes to the returned matrix do not \n-     *  affect the LU decomposition property. \n-     * <p>\n-     * The matrix returned is a compact representation of the LU decomposition. \n-     * Elements below the main diagonal correspond to entries of the \"L\" matrix;   \n+     *  Returns a fresh copy of the cached LU matrix if this has been computed;\n+     *  otherwise the composition is computed and cached for use by other methods.\n+     *  Since a copy is returned in either case, changes to the returned matrix do not\n+     *  affect the LU decomposition property.\n+     * <p>\n+     * The matrix returned is a compact representation of the LU decomposition.\n+     * Elements below the main diagonal correspond to entries of the \"L\" matrix;\n      * elements on and above the main diagonal correspond to entries of the \"U\"\n      * matrix.</p>\n      * <p>\n      * Example: <pre>\n-     * \n+     *\n      *     Returned matrix                L                  U\n-     *         2  3  1                   1  0  0            2  3  1          \n+     *         2  3  1                   1  0  0            2  3  1\n      *         5  4  6                   5  1  0            0  4  6\n-     *         1  7  8                   1  7  1            0  0  8          \n+     *         1  7  8                   1  7  1            0  0  8\n      * </pre>\n-     * \n+     *\n      * The L and U matrices satisfy the matrix equation LU = permuteRows(this), <br>\n      *  where permuteRows reorders the rows of the matrix to follow the order determined\n      *  by the <a href=#getPermutation()>permutation</a> property.</p>\n-     * \n+     *\n      * @return LU decomposition matrix\n      * @throws InvalidMatrixException if the matrix is non-square or singular.\n      */\n         }\n         return new BigMatrixImpl(lu);\n     }\n-    \n+\n     /**\n      * Returns the permutation associated with the lu decomposition.\n      * The entries of the array represent a permutation of the numbers 0, ... , nRows - 1.\n      * and current first row is last.</p>\n      * <p>\n      * Returns a fresh copy of the array.</p>\n-     * \n+     *\n      * @return the permutation\n      */\n     protected int[] getPermutation() {\n         System.arraycopy(permutation, 0, out, 0, permutation.length);\n         return out;\n     }\n-    \n+\n     //------------------------ Private methods\n-    \n+\n     /**\n      * Returns a fresh copy of the underlying data array.\n      *\n         }\n         return out;\n     }\n-    \n+\n     /**\n      * Replaces data with a fresh copy of the input array.\n      * <p>\n     private void copyIn(BigDecimal[][] in) {\n         setSubMatrix(in,0,0);\n     }\n-    \n+\n     /**\n      * Replaces data with a fresh copy of the input array.\n      *\n         }\n         lu = null;\n     }\n-    \n+\n     /**\n      * Replaces data with BigDecimals represented by the strings in the input\n      * array.\n--- a/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n  * @since 2.0\n  */\n public class BlockFieldMatrix<T extends FieldElement<T>> extends AbstractFieldMatrix<T> implements Serializable {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -4602336630143123183L;\n \n             if (length != columns) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"some rows have length {0} while others have length {1}\",\n-                        columns, length); \n+                        columns, length);\n             }\n         }\n \n         }\n \n         return data;\n-        \n+\n     }\n \n     /** {@inheritDoc} */\n         // safety checks\n         final int refLength = subMatrix[0].length;\n         if (refLength < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");             \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n         }\n         final int endRow    = row + subMatrix.length - 1;\n         final int endColumn = column + refLength - 1;\n             if (subRow.length != refLength) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"some rows have length {0} while others have length {1}\",\n-                        refLength, subRow.length); \n+                        refLength, subRow.length);\n             }\n         }\n \n         }\n \n     }\n-    \n+\n     /** {@inheritDoc} */\n     @Override\n     public FieldMatrix<T> getColumnMatrix(final int column)\n--- a/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java\n  * @since 2.0\n  */\n public class BlockRealMatrix extends AbstractRealMatrix implements Serializable {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 4991895511313664478L;\n \n             if (length != columns) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"some rows have length {0} while others have length {1}\",\n-                        columns, length); \n+                        columns, length);\n             }\n         }\n \n         }\n \n         return data;\n-        \n+\n     }\n \n     /** {@inheritDoc} */\n         }\n         return maxColSum;\n     }\n-    \n+\n     /** {@inheritDoc} */\n     @Override\n     public double getFrobeniusNorm() {\n         // safety checks\n         final int refLength = subMatrix[0].length;\n         if (refLength < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");             \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n         }\n         final int endRow    = row + subMatrix.length - 1;\n         final int endColumn = column + refLength - 1;\n             if (subRow.length != refLength) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n                         \"some rows have length {0} while others have length {1}\",\n-                        refLength, subRow.length); \n+                        refLength, subRow.length);\n             }\n         }\n \n         }\n \n     }\n-    \n+\n     /** {@inheritDoc} */\n     @Override\n     public BlockRealMatrix getColumnMatrix(final int column)\n--- a/src/main/java/org/apache/commons/math/linear/CholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/CholeskyDecomposition.java\n \n \n /**\n- * An interface to classes that implement an algorithm to calculate the \n+ * An interface to classes that implement an algorithm to calculate the\n  * Cholesky decomposition of a real symmetric positive-definite matrix.\n  * <p>This interface is based on the class with similar name from the now defunct\n  * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n  *   #getSolver() getSolver} method and the equivalent method provided by\n  *   the returned {@link DecompositionSolver}.</li>\n  * </ul>\n- *   \n+ *\n  * @see <a href=\"http://mathworld.wolfram.com/CholeskyDecomposition.html\">MathWorld</a>\n  * @see <a href=\"http://en.wikipedia.org/wiki/Cholesky_decomposition\">Wikipedia</a>\n  * @version $Revision$ $Date$\n public interface CholeskyDecomposition {\n \n     /**\n-     * Returns the matrix L of the decomposition. \n+     * Returns the matrix L of the decomposition.\n      * <p>L is an lower-triangular matrix</p>\n      * @return the L matrix\n      */\n--- a/src/main/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n \n     /** Specialized solver. */\n     private static class Solver implements DecompositionSolver {\n-    \n+\n         /** Row-oriented storage for L<sup>T</sup> matrix data. */\n         private final double[][] lTData;\n \n--- a/src/main/java/org/apache/commons/math/linear/DecompositionSolver.java\n+++ b/src/main/java/org/apache/commons/math/linear/DecompositionSolver.java\n  * ||A &times; X - B|| is exactly 0. Other solvers can also find solutions\n  * with non-square matrix A and with non-null minimal norm. If an exact linear\n  * solution exists it is also the minimal norm solution.</p>\n- *   \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n--- a/src/main/java/org/apache/commons/math/linear/DefaultFieldMatrixChangingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/DefaultFieldMatrixChangingVisitor.java\n  * This class is a convenience to create custom visitors without defining all\n  * methods. This class provides default implementations that do nothing.\n  * </p>\n- * \n+ *\n  * @param <T> the type of the field elements\n  * @version $Revision$ $Date$\n  * @since 2.0\n--- a/src/main/java/org/apache/commons/math/linear/DefaultFieldMatrixPreservingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/DefaultFieldMatrixPreservingVisitor.java\n  * This class is a convenience to create custom visitors without defining all\n  * methods. This class provides default implementations that do nothing.\n  * </p>\n- * \n+ *\n  * @param <T> the type of the field elements\n  * @version $Revision$ $Date$\n  * @since 2.0\n--- a/src/main/java/org/apache/commons/math/linear/DefaultRealMatrixChangingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/DefaultRealMatrixChangingVisitor.java\n  * This class is a convenience to create custom visitors without defining all\n  * methods. This class provides default implementations that do nothing.\n  * </p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n--- a/src/main/java/org/apache/commons/math/linear/DefaultRealMatrixPreservingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/DefaultRealMatrixPreservingVisitor.java\n  * This class is a convenience to create custom visitors without defining all\n  * methods. This class provides default implementations that do nothing.\n  * </p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecomposition.java\n \n \n /**\n- * An interface to classes that implement an algorithm to calculate the \n+ * An interface to classes that implement an algorithm to calculate the\n  * eigen decomposition of a real matrix.\n  * <p>The eigen decomposition of matrix A is a set of two matrices:\n  * V and D such that A = V &times; D &times; V<sup>T</sup>.\n public interface EigenDecomposition {\n \n     /**\n-     * Returns the matrix V of the decomposition. \n+     * Returns the matrix V of the decomposition.\n      * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n      * <p>The columns of V are the eigenvectors of the original matrix.</p>\n      * @return the V matrix\n     RealMatrix getV();\n \n     /**\n-     * Returns the block diagonal matrix D of the decomposition. \n+     * Returns the block diagonal matrix D of the decomposition.\n      * <p>D is a block diagonal matrix.</p>\n      * <p>Real eigenvalues are on the diagonal while complex values are on\n      * 2x2 blocks { {real +imaginary}, {-imaginary, real} }.</p>\n     RealMatrix getD();\n \n     /**\n-     * Returns the transpose of the matrix V of the decomposition. \n+     * Returns the transpose of the matrix V of the decomposition.\n      * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n      * <p>The columns of V are the eigenvectors of the original matrix.</p>\n      * @return the transpose of the V matrix\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n     private RealMatrix cachedVt;\n \n     /**\n-     * Calculates the eigen decomposition of the given symmetric matrix. \n+     * Calculates the eigen decomposition of the given symmetric matrix.\n      * @param matrix The <strong>symmetric</strong> matrix to decompose.\n      * @param splitTolerance tolerance on the off-diagonal elements relative to the\n      * geometric mean to split the tridiagonal matrix (a suggested value is\n     }\n \n     /**\n-     * Calculates the eigen decomposition of the given tridiagonal symmetric matrix. \n+     * Calculates the eigen decomposition of the given tridiagonal symmetric matrix.\n      * @param main the main diagonal of the matrix (will be copied)\n      * @param secondary the secondary diagonal of the matrix (will be copied)\n      * @param splitTolerance tolerance on the off-diagonal elements relative to the\n     }\n \n     /**\n-     * Decompose a tridiagonal symmetric matrix. \n+     * Decompose a tridiagonal symmetric matrix.\n      * @exception InvalidMatrixException (wrapping a {@link\n      * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n      */\n \n     /** Specialized solver. */\n     private static class Solver implements DecompositionSolver {\n-    \n+\n         /** Real part of the realEigenvalues. */\n         private double[] realEigenvalues;\n \n                        final ArrayRealVector[] eigenvectors) {\n             this.realEigenvalues = realEigenvalues;\n             this.imagEigenvalues = imagEigenvalues;\n-            this.eigenvectors    = eigenvectors; \n+            this.eigenvectors    = eigenvectors;\n         }\n \n         /** Solve the linear equation A &times; X = B for symmetric matrices A.\n             final double upper = dCurrent + radius;\n             work[upperStart + i] = upper;\n             upperSpectra = Math.max(upperSpectra, upper);\n-            \n+\n         }\n \n         final double dCurrent = main[m - 1];\n                 } else {\n                     for (int i = 0; i < n; ++i) {\n                         realEigenvalues[begin + i] = lambda - work[4 * i];\n-                    }                    \n+                    }\n                 }\n \n             }\n             // in fact, there are solutions to the equation, but in the context\n             // of symmetric realEigenvalues problem, there should be three distinct\n             // real roots, so we throw an error if this condition is not met\n-            throw new InvalidMatrixException(\"cannot solve degree {0} equation\", 3);           \n+            throw new InvalidMatrixException(\"cannot solve degree {0} equation\", 3);\n         }\n         final double sqrtMq = Math.sqrt(-q);\n         final double theta  = Math.acos(r / (-q * sqrtMq));\n                     if (s <= t) {\n                         s = work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));\n                     } else {\n-                        s = work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));                      \n+                        s = work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));\n                     }\n                     t = work[k - 7] + (s + work[k - 5]);\n                     work[k - 3] *= work[k - 7] / t;\n         int nn = 4 * end + pingPong - 1;\n         switch (deflated) {\n \n-        case 0 : // no realEigenvalues deflated. \n+        case 0 : // no realEigenvalues deflated.\n             if (dMin == dN || dMin == dN1) {\n \n                 double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                 double a2 = work[nn - 7] + work[nn - 5];\n \n                 if (dMin == dN && dMin1 == dN1) {\n-                    // cases 2 and 3. \n+                    // cases 2 and 3.\n                     final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                     final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                     if (gap1 > 0.0 && gap1 > b1) {\n             break;\n \n         case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n-            if (dMin1 == dN1 && dMin2 == dN2) { \n+            if (dMin1 == dN1 && dMin2 == dN2) {\n \n                 // cases 7 and 8.\n                 tType = -7;\n         case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n \n             // cases 10 and 11.\n-            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { \n+            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                 tType = -10;\n                 final double s = 0.333 * dMin2;\n                 if (work[nn - 5] > work[nn - 7]) {\n     /**\n      * Find an eigenvector corresponding to an eigenvalue, using bidiagonals.\n      * <p>This method corresponds to algorithm X from Dhillon's thesis.</p>\n-     * \n+     *\n      * @param eigenvalue eigenvalue for which eigenvector is desired\n      * @param d diagonal elements of the initial non-shifted D matrix\n      * @param l off-diagonal elements of the initial non-shifted L matrix\n--- a/src/main/java/org/apache/commons/math/linear/FieldLUDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldLUDecomposition.java\n import org.apache.commons.math.FieldElement;\n \n /**\n- * An interface to classes that implement an algorithm to calculate the \n+ * An interface to classes that implement an algorithm to calculate the\n  * LU-decomposition of a real matrix.\n  * <p>The LU-decomposition of matrix A is a set of three matrices: P, L and U\n  * such that P&times;A = L&times;U. P is a rows permutation matrix that is used\n  *   by a {@link #getSolver() getSolver} method and the equivalent methods provided by\n  *   the returned {@link DecompositionSolver}.</li>\n  * </ul>\n- *   \n+ *\n  * @param <T> the type of the field elements\n  * @see <a href=\"http://mathworld.wolfram.com/LUDecomposition.html\">MathWorld</a>\n  * @see <a href=\"http://en.wikipedia.org/wiki/LU_decomposition\">Wikipedia</a>\n public interface FieldLUDecomposition<T extends FieldElement<T>> {\n \n     /**\n-     * Returns the matrix L of the decomposition. \n+     * Returns the matrix L of the decomposition.\n      * <p>L is an lower-triangular matrix</p>\n      * @return the L matrix (or null if decomposed matrix is singular)\n      */\n     FieldMatrix<T> getL();\n \n     /**\n-     * Returns the matrix U of the decomposition. \n+     * Returns the matrix U of the decomposition.\n      * <p>U is an upper-triangular matrix</p>\n      * @return the U matrix (or null if decomposed matrix is singular)\n      */\n--- a/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java\n     private FieldMatrix<T> cachedP;\n \n     /**\n-     * Calculates the LU-decomposition of the given matrix. \n+     * Calculates the LU-decomposition of the given matrix.\n      * @param matrix The matrix to decompose.\n      * @exception NonSquareMatrixException if matrix is not square\n      */\n--- a/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n  * <p>\n  * Matrix element indexing is 0-based -- e.g., <code>getEntry(0, 0)</code>\n  * returns the element in the first row, first column of the matrix.</p>\n- * \n+ *\n  * @param <T> the type of the field elements\n  * @version $Revision$ $Date$\n  */\n      */\n    FieldMatrix<T> getSubMatrix(int startRow, int endRow, int startColumn, int endColumn)\n        throws MatrixIndexException;\n-   \n+\n    /**\n     * Gets a submatrix. Rows and columns are indicated\n     * counting from 0 to n-1.\n   void copySubMatrix(int startRow, int endRow, int startColumn, int endColumn,\n                      T[][] destination)\n       throws MatrixIndexException, IllegalArgumentException;\n-  \n+\n   /**\n    * Copy a submatrix. Rows and columns are indicated\n    * counting from 0 to n-1.\n    */\n   void copySubMatrix(int[] selectedRows, int[] selectedColumns, T[][] destination)\n       throws MatrixIndexException, IllegalArgumentException;\n- \n+\n    /**\n     * Replace the submatrix starting at <code>row, column</code> using data in\n     * the input <code>subMatrix</code> array. Indexes are 0-based.\n-    * <p> \n+    * <p>\n     * Example:<br>\n     * Starting with <pre>\n     * 1  2  3  4\n     * 5  6  7  8\n     * 9  0  1  2\n     * </pre>\n-    * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking \n+    * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking\n     * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>\n     * 1  2  3  4\n     * 5  3  4  8\n     * 9  5  6  2\n     * </pre></p>\n-    * \n+    *\n     * @param subMatrix  array containing the submatrix replacement data\n     * @param row  row coordinate of the top, left element to be replaced\n     * @param column  column coordinate of the top, left element to be replaced\n-    * @throws MatrixIndexException  if subMatrix does not fit into this \n-    *    matrix from element in (row, column) \n+    * @throws MatrixIndexException  if subMatrix does not fit into this\n+    *    matrix from element in (row, column)\n     * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular\n     *  (not all rows have the same length) or empty\n     * @throws NullPointerException if <code>subMatrix</code> is null\n     * @since 2.0\n     */\n-   void setSubMatrix(T[][] subMatrix, int row, int column) \n+   void setSubMatrix(T[][] subMatrix, int row, int column)\n        throws MatrixIndexException;\n \n    /**\n     * @throws MatrixIndexException if the specified row index is invalid\n     */\n    FieldMatrix<T> getRowMatrix(int row) throws MatrixIndexException;\n-   \n+\n    /**\n     * Sets the entries in row number <code>row</code>\n     * as a row matrix.  Row indices start at 0.\n     */\n    void setRowMatrix(int row, FieldMatrix<T> matrix)\n        throws MatrixIndexException, InvalidMatrixException;\n-   \n+\n    /**\n     * Returns the entries in column number <code>column</code>\n     * as a column matrix.  Column indices start at 0.\n     */\n    void setColumnMatrix(int column, FieldMatrix<T> matrix)\n        throws MatrixIndexException, InvalidMatrixException;\n-   \n+\n    /**\n     * Returns the entries in row number <code>row</code>\n     * as a vector.  Row indices start at 0.\n     */\n    void setRowVector(int row, FieldVector<T> vector)\n        throws MatrixIndexException, InvalidMatrixException;\n-   \n+\n    /**\n     * Returns the entries in column number <code>column</code>\n     * as a vector.  Column indices start at 0.\n     */\n    void setColumnVector(int column, FieldVector<T> vector)\n        throws MatrixIndexException, InvalidMatrixException;\n-   \n+\n     /**\n      * Returns the entries in row number <code>row</code> as an array.\n      * <p>\n      */\n     void setRow(int row, T[] array)\n         throws MatrixIndexException, InvalidMatrixException;\n-    \n+\n     /**\n      * Returns the entries in column number <code>col</code> as an array.\n      * <p>\n      */\n     void setColumn(int column, T[] array)\n         throws MatrixIndexException, InvalidMatrixException;\n-    \n+\n     /**\n      * Returns the entry in the specified row and column.\n      * <p>\n-     * Row and column indices start at 0 and must satisfy \n+     * Row and column indices start at 0 and must satisfy\n      * <ul>\n      * <li><code>0 <= row < rowDimension</code></li>\n      * <li><code> 0 <= column < columnDimension</code></li>\n      * </ul>\n      * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n-     * \n+     *\n      * @param row  row location of entry to be fetched\n      * @param column  column location of entry to be fetched\n      * @return matrix entry in row,column\n     /**\n      * Set the entry in the specified row and column.\n      * <p>\n-     * Row and column indices start at 0 and must satisfy \n+     * Row and column indices start at 0 and must satisfy\n      * <ul>\n      * <li><code>0 <= row < rowDimension</code></li>\n      * <li><code> 0 <= column < columnDimension</code></li>\n      * </ul>\n      * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n-     * \n+     *\n      * @param row  row location of entry to be set\n      * @param column  column location of entry to be set\n      * @param value matrix entry to be set in row,column\n     /**\n      * Change an entry in the specified row and column.\n      * <p>\n-     * Row and column indices start at 0 and must satisfy \n+     * Row and column indices start at 0 and must satisfy\n      * <ul>\n      * <li><code>0 <= row < rowDimension</code></li>\n      * <li><code> 0 <= column < columnDimension</code></li>\n      * </ul>\n      * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n-     * \n+     *\n      * @param row  row location of entry to be set\n      * @param column  column location of entry to be set\n      * @param increment value to add to the current matrix entry in row,column\n     /**\n      * Change an entry in the specified row and column.\n      * <p>\n-     * Row and column indices start at 0 and must satisfy \n+     * Row and column indices start at 0 and must satisfy\n      * <ul>\n      * <li><code>0 <= row < rowDimension</code></li>\n      * <li><code> 0 <= column < columnDimension</code></li>\n      * </ul>\n      * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n-     * \n+     *\n      * @param row  row location of entry to be set\n      * @param column  column location of entry to be set\n      * @param factor multiplication factor for the current matrix entry in row,column\n--- a/src/main/java/org/apache/commons/math/linear/FieldMatrixChangingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrixChangingVisitor.java\n \n /**\n  * Interface defining a visitor for matrix entries.\n- * \n+ *\n  * @param <T> the type of the field elements\n  * @version $Revision$ $Date$\n  * @since 2.0\n--- a/src/main/java/org/apache/commons/math/linear/FieldMatrixPreservingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrixPreservingVisitor.java\n \n /**\n  * Interface defining a visitor for matrix entries.\n- * \n+ *\n  * @param <T> the type of the field elements\n  * @version $Revision$ $Date$\n  * @since 2.0\n--- a/src/main/java/org/apache/commons/math/linear/FieldVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldVector.java\n  * <pre>\n  *   RealVector result = v.mapAddToSelf(3.0).mapTanToSelf().mapSquareToSelf();\n  * </pre>\n- * \n+ *\n  * @param <T> the type of the field elements\n  * @version $Revision$ $Date$\n  * @since 2.0\n--- a/src/main/java/org/apache/commons/math/linear/LUDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/LUDecomposition.java\n \n \n /**\n- * An interface to classes that implement an algorithm to calculate the \n+ * An interface to classes that implement an algorithm to calculate the\n  * LU-decomposition of a real matrix.\n  * <p>The LU-decomposition of matrix A is a set of three matrices: P, L and U\n  * such that P&times;A = L&times;U. P is a rows permutation matrix that is used\n  *   by a {@link #getSolver() getSolver} method and the equivalent methods provided by\n  *   the returned {@link DecompositionSolver}.</li>\n  * </ul>\n- *   \n+ *\n  * @see <a href=\"http://mathworld.wolfram.com/LUDecomposition.html\">MathWorld</a>\n  * @see <a href=\"http://en.wikipedia.org/wiki/LU_decomposition\">Wikipedia</a>\n  * @version $Revision$ $Date$\n public interface LUDecomposition {\n \n     /**\n-     * Returns the matrix L of the decomposition. \n+     * Returns the matrix L of the decomposition.\n      * <p>L is an lower-triangular matrix</p>\n      * @return the L matrix (or null if decomposed matrix is singular)\n      */\n     RealMatrix getL();\n \n     /**\n-     * Returns the matrix U of the decomposition. \n+     * Returns the matrix U of the decomposition.\n      * <p>U is an upper-triangular matrix</p>\n      * @return the U matrix (or null if decomposed matrix is singular)\n      */\n--- a/src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n     private static final double DEFAULT_TOO_SMALL = 10E-12;\n \n     /**\n-     * Calculates the LU-decomposition of the given matrix. \n+     * Calculates the LU-decomposition of the given matrix.\n      * @param matrix The matrix to decompose.\n      * @exception InvalidMatrixException if matrix is not square\n      */\n     }\n \n     /**\n-     * Calculates the LU-decomposition of the given matrix. \n+     * Calculates the LU-decomposition of the given matrix.\n      * @param matrix The matrix to decompose.\n      * @param singularityThreshold threshold (based on partial row norm)\n      * under which a matrix is considered singular\n \n     /** Specialized solver. */\n     private static class Solver implements DecompositionSolver {\n-    \n+\n         /** Entries of LU decomposition. */\n         private final double lu[][];\n \n--- a/src/main/java/org/apache/commons/math/linear/MatrixUtils.java\n+++ b/src/main/java/org/apache/commons/math/linear/MatrixUtils.java\n \n /**\n  * A collection of static methods that operate on or return matrices.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class MatrixUtils {\n     private MatrixUtils() {\n         super();\n     }\n-    \n+\n     /**\n      * Returns a {@link RealMatrix} with specified dimensions.\n      * <p>The type of matrix returned depends on the dimension. Below\n      * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n      * BlockRealMatrix} instance is built.</p>\n      * <p>The input array is copied, not referenced.</p>\n-     * \n+     *\n      * @param data input array\n      * @return  RealMatrix containing the values of the array\n      * @throws IllegalArgumentException if <code>data</code> is not rectangular\n         }\n         return new BigMatrixImpl(d, false);\n     }\n-    \n+\n     /**\n      * Returns a diagonal matrix with specified elements.\n      *\n         }\n         return m;\n     }\n-    \n+\n     /**\n      * Returns a diagonal matrix with specified elements.\n      *\n         }\n         return m;\n     }\n-    \n+\n     /**\n      * Returns a {@link BigMatrix} whose entries are the the values in the\n      * the input array.  The input array is copied, not referenced.\n-     * \n+     *\n      * @param data input array\n      * @return  RealMatrix containing the values of the array\n      * @throws IllegalArgumentException if <code>data</code> is not rectangular\n     public static BigMatrix createBigMatrix(double[][] data) {\n         return new BigMatrixImpl(data);\n     }\n-    \n+\n     /**\n      * Returns a {@link BigMatrix} whose entries are the the values in the\n      * the input array.  The input array is copied, not referenced.\n-     * \n+     *\n      * @param data input array\n      * @return  RealMatrix containing the values of the array\n      * @throws IllegalArgumentException if <code>data</code> is not rectangular\n     /**\n      * Returns a {@link BigMatrix} whose entries are the the values in the\n      * the input array.  The input array is copied, not referenced.\n-     * \n+     *\n      * @param data input array\n      * @return  RealMatrix containing the values of the array\n      * @throws IllegalArgumentException if <code>data</code> is not rectangular\n     public static BigMatrix createBigMatrix(String[][] data) {\n         return new BigMatrixImpl(data);\n     }\n-    \n-    /**\n-     * Creates a {@link RealVector} using the data from the input array. \n-     * \n+\n+    /**\n+     * Creates a {@link RealVector} using the data from the input array.\n+     *\n      * @param data the input data\n      * @return a data.length RealVector\n      * @throws IllegalArgumentException if <code>data</code> is empty\n     public static RealVector createRealVector(double[] data) {\n         return new ArrayRealVector(data, true);\n     }\n-    \n-    /**\n-     * Creates a {@link FieldVector} using the data from the input array. \n-     * \n+\n+    /**\n+     * Creates a {@link FieldVector} using the data from the input array.\n+     *\n      * @param <T> the type of the field elements\n      * @param data the input data\n      * @return a data.length FieldVector\n     public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) {\n         return new ArrayFieldVector<T>(data, true);\n     }\n-    \n+\n     /**\n      * Creates a row {@link RealMatrix} using the data from the input\n-     * array. \n-     * \n+     * array.\n+     *\n      * @param rowData the input row data\n      * @return a 1 x rowData.length RealMatrix\n      * @throws IllegalArgumentException if <code>rowData</code> is empty\n         }\n         return m;\n     }\n-    \n+\n     /**\n      * Creates a row {@link FieldMatrix} using the data from the input\n-     * array. \n-     * \n+     * array.\n+     *\n      * @param <T> the type of the field elements\n      * @param rowData the input row data\n      * @return a 1 x rowData.length FieldMatrix\n         createRowFieldMatrix(final T[] rowData) {\n         final int nCols = rowData.length;\n         if (nCols == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n         }\n         final FieldMatrix<T> m = createFieldMatrix(rowData[0].getField(), 1, nCols);\n         for (int i = 0; i < nCols; ++i) {\n         }\n         return m;\n     }\n-    \n+\n     /**\n      * Creates a row {@link BigMatrix} using the data from the input\n-     * array. \n-     * \n+     * array.\n+     *\n      * @param rowData the input row data\n      * @return a 1 x rowData.length BigMatrix\n      * @throws IllegalArgumentException if <code>rowData</code> is empty\n         }\n         return new BigMatrixImpl(data, false);\n     }\n-    \n+\n     /**\n      * Creates a row {@link BigMatrix} using the data from the input\n-     * array. \n-     * \n+     * array.\n+     *\n      * @param rowData the input row data\n      * @return a 1 x rowData.length BigMatrix\n      * @throws IllegalArgumentException if <code>rowData</code> is empty\n         System.arraycopy(rowData, 0, data[0], 0, nCols);\n         return new BigMatrixImpl(data, false);\n     }\n-    \n+\n     /**\n      * Creates a row {@link BigMatrix} using the data from the input\n-     * array. \n-     * \n+     * array.\n+     *\n      * @param rowData the input row data\n      * @return a 1 x rowData.length BigMatrix\n      * @throws IllegalArgumentException if <code>rowData</code> is empty\n         }\n         return new BigMatrixImpl(data, false);\n     }\n-    \n+\n     /**\n      * Creates a column {@link RealMatrix} using the data from the input\n      * array.\n-     * \n+     *\n      * @param columnData  the input column data\n      * @return a columnData x 1 RealMatrix\n      * @throws IllegalArgumentException if <code>columnData</code> is empty\n         }\n         return m;\n     }\n-    \n+\n     /**\n      * Creates a column {@link FieldMatrix} using the data from the input\n      * array.\n-     * \n+     *\n      * @param <T> the type of the field elements\n      * @param columnData  the input column data\n      * @return a columnData x 1 FieldMatrix\n         createColumnFieldMatrix(final T[] columnData) {\n         final int nRows = columnData.length;\n         if (nRows == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n         }\n         final FieldMatrix<T> m = createFieldMatrix(columnData[0].getField(), nRows, 1);\n         for (int i = 0; i < nRows; ++i) {\n         }\n         return m;\n     }\n-    \n+\n     /**\n      * Creates a column {@link BigMatrix} using the data from the input\n      * array.\n-     * \n+     *\n      * @param columnData  the input column data\n      * @return a columnData x 1 BigMatrix\n      * @throws IllegalArgumentException if <code>columnData</code> is empty\n         }\n         return new BigMatrixImpl(data, false);\n     }\n-    \n+\n     /**\n      * Creates a column {@link BigMatrix} using the data from the input\n      * array.\n-     * \n+     *\n      * @param columnData  the input column data\n      * @return a columnData x 1 BigMatrix\n      * @throws IllegalArgumentException if <code>columnData</code> is empty\n         }\n         return new BigMatrixImpl(data, false);\n     }\n-    \n+\n     /**\n      * Creates a column {@link BigMatrix} using the data from the input\n      * array.\n-     * \n+     *\n      * @param columnData  the input column data\n      * @return a columnData x 1 BigMatrix\n      * @throws IllegalArgumentException if <code>columnData</code> is empty\n                                            startColumn, endColumn);\n         }\n \n-    \n+\n     }\n \n     /**\n      * }\n      * </code></pre>\n      * </p>\n-     * \n+     *\n      * @param vector real vector to serialize\n      * @param oos stream where the real vector should be written\n      * @exception IOException if object cannot be written to stream\n      * }\n      * </code></pre>\n      * </p>\n-     * \n+     *\n      * @param matrix real matrix to serialize\n      * @param oos stream where the real matrix should be written\n      * @exception IOException if object cannot be written to stream\n--- a/src/main/java/org/apache/commons/math/linear/NotPositiveDefiniteMatrixException.java\n+++ b/src/main/java/org/apache/commons/math/linear/NotPositiveDefiniteMatrixException.java\n \n import org.apache.commons.math.MathException;\n \n-/** \n+/**\n  * This class represents exceptions thrown when a matrix expected to\n  * be positive definite is not.\n- * \n+ *\n  * @since 1.2\n  * @version $Revision$ $Date$\n  */\n--- a/src/main/java/org/apache/commons/math/linear/NotSymmetricMatrixException.java\n+++ b/src/main/java/org/apache/commons/math/linear/NotSymmetricMatrixException.java\n \n import org.apache.commons.math.MathException;\n \n-/** \n+/**\n  * This class represents exceptions thrown when a matrix expected to\n  * be symmetric is not\n- * \n+ *\n  * @since 2.0\n  * @version $Revision$ $Date$\n  */\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n \n /**\n  * Sparse matrix implementation based on an open addressed map.\n- * \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n         this.columns = columnDimension;\n         this.entries = new OpenIntToDoubleHashMap(0.0);\n     }\n-  \n+\n     /**\n      * Build a matrix by copying another one.\n      * @param matrix matrix to copy\n         this.columns = matrix.columns;\n         this.entries = new OpenIntToDoubleHashMap(matrix.entries);\n     }\n-  \n+\n     /** {@inheritDoc} */\n     @Override\n     public OpenMapRealMatrix copy() {\n--- a/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n         return getData();\n     }\n \n-    /** {@inheritDoc} \n+    /** {@inheritDoc}\n      * <p> Implementation Note: This works on exact values, and as a result\n      * it is possible for {@code a.subtract(b)} to be the zero vector, while\n      * {@code a.hashCode() != b.hashCode()}.</p>\n         return result;\n     }\n \n-    /**  \n+    /**\n      * <p> Implementation Note: This performs an exact comparison, and as a result\n-     * it is possible for {@code a.subtract(b}} to be the zero vector, while \n+     * it is possible for {@code a.subtract(b}} to be the zero vector, while\n      * {@code  a.equals(b) == false}.</p>\n      * {@inheritDoc}\n      */\n     }\n \n     /**\n-     * \n+     *\n      * @return the percentage of none zero elements as a decimal percent.\n      */\n     public double getSparcity() {\n--- a/src/main/java/org/apache/commons/math/linear/QRDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/QRDecomposition.java\n \n \n /**\n- * An interface to classes that implement an algorithm to calculate the \n+ * An interface to classes that implement an algorithm to calculate the\n  * QR-decomposition of a real matrix.\n  * <p>This interface is based on the class with similar name from the now defunct\n  * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n  *   by a {@link #getSolver() getSolver} method and the equivalent methods provided by\n  *   the returned {@link DecompositionSolver}.</li>\n  * </ul>\n- *   \n+ *\n  * @see <a href=\"http://mathworld.wolfram.com/QRDecomposition.html\">MathWorld</a>\n  * @see <a href=\"http://en.wikipedia.org/wiki/QR_decomposition\">Wikipedia</a>\n  * @version $Revision$ $Date$\n public interface QRDecomposition {\n \n     /**\n-     * Returns the matrix R of the decomposition. \n+     * Returns the matrix R of the decomposition.\n      * <p>R is an upper-triangular matrix</p>\n      * @return the R matrix\n      */\n--- a/src/main/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n     private RealMatrix cachedH;\n \n     /**\n-     * Calculates the QR-decomposition of the given matrix. \n+     * Calculates the QR-decomposition of the given matrix.\n      * @param matrix The matrix to decompose.\n      */\n     public QRDecompositionImpl(RealMatrix matrix) {\n             final int m = qrt[0].length;\n             cachedQT = MatrixUtils.createRealMatrix(m, m);\n \n-            /* \n-             * Q = Q1 Q2 ... Q_m, so Q is formed by first constructing Q_m and then \n-             * applying the Householder transformations Q_(m-1),Q_(m-2),...,Q1 in \n-             * succession to the result \n-             */ \n+            /*\n+             * Q = Q1 Q2 ... Q_m, so Q is formed by first constructing Q_m and then\n+             * applying the Householder transformations Q_(m-1),Q_(m-2),...,Q1 in\n+             * succession to the result\n+             */\n             for (int minor = m - 1; minor >= Math.min(m, n); minor--) {\n                 cachedQT.setEntry(minor, minor, 1.0);\n             }\n \n     /** Specialized solver. */\n     private static class Solver implements DecompositionSolver {\n-    \n+\n         /**\n          * A packed TRANSPOSED representation of the QR decomposition.\n          * <p>The elements BELOW the diagonal are the elements of the UPPER triangular\n                 // apply Householder transforms to solve Q.y = b\n                 for (int minor = 0; minor < Math.min(m, n); minor++) {\n                     final double[] qrtMinor = qrt[minor];\n-                    final double factor     = 1.0 / (rDiag[minor] * qrtMinor[minor]); \n+                    final double factor     = 1.0 / (rDiag[minor] * qrtMinor[minor]);\n \n                     Arrays.fill(alpha, 0, kWidth, 0.0);\n                     for (int row = minor; row < m; ++row) {\n--- a/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n  * <p>\n  * Matrix element indexing is 0-based -- e.g., <code>getEntry(0, 0)</code>\n  * returns the element in the first row, first column of the matrix.</p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public interface RealMatrix extends AnyMatrix {\n      * @return norm\n      */\n     double getNorm();\n-    \n+\n     /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/FrobeniusNorm.html\">\n      * Frobenius norm</a> of the matrix.\n      * @return norm\n      */\n     double getFrobeniusNorm();\n-    \n+\n     /**\n      * Gets a submatrix. Rows and columns are indicated\n      * counting from 0 to n-1.\n      */\n    RealMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn)\n        throws MatrixIndexException;\n-   \n+\n    /**\n     * Gets a submatrix. Rows and columns are indicated\n     * counting from 0 to n-1.\n   void copySubMatrix(int startRow, int endRow, int startColumn, int endColumn,\n                      double[][] destination)\n       throws MatrixIndexException, IllegalArgumentException;\n-  \n+\n   /**\n    * Copy a submatrix. Rows and columns are indicated\n    * counting from 0 to n-1.\n    */\n   void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination)\n       throws MatrixIndexException, IllegalArgumentException;\n- \n+\n    /**\n     * Replace the submatrix starting at <code>row, column</code> using data in\n     * the input <code>subMatrix</code> array. Indexes are 0-based.\n-    * <p> \n+    * <p>\n     * Example:<br>\n     * Starting with <pre>\n     * 1  2  3  4\n     * 5  6  7  8\n     * 9  0  1  2\n     * </pre>\n-    * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking \n+    * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking\n     * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>\n     * 1  2  3  4\n     * 5  3  4  8\n     * 9  5  6  2\n     * </pre></p>\n-    * \n+    *\n     * @param subMatrix  array containing the submatrix replacement data\n     * @param row  row coordinate of the top, left element to be replaced\n     * @param column  column coordinate of the top, left element to be replaced\n-    * @throws MatrixIndexException  if subMatrix does not fit into this \n-    *    matrix from element in (row, column) \n+    * @throws MatrixIndexException  if subMatrix does not fit into this\n+    *    matrix from element in (row, column)\n     * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular\n     *  (not all rows have the same length) or empty\n     * @throws NullPointerException if <code>subMatrix</code> is null\n     * @since 2.0\n     */\n-   void setSubMatrix(double[][] subMatrix, int row, int column) \n+   void setSubMatrix(double[][] subMatrix, int row, int column)\n        throws MatrixIndexException;\n \n    /**\n     * @throws MatrixIndexException if the specified row index is invalid\n     */\n    RealMatrix getRowMatrix(int row) throws MatrixIndexException;\n-   \n+\n    /**\n     * Sets the entries in row number <code>row</code>\n     * as a row matrix.  Row indices start at 0.\n     */\n    void setRowMatrix(int row, RealMatrix matrix)\n        throws MatrixIndexException, InvalidMatrixException;\n-   \n+\n    /**\n     * Returns the entries in column number <code>column</code>\n     * as a column matrix.  Column indices start at 0.\n     */\n    void setColumnMatrix(int column, RealMatrix matrix)\n        throws MatrixIndexException, InvalidMatrixException;\n-   \n+\n    /**\n     * Returns the entries in row number <code>row</code>\n     * as a vector.  Row indices start at 0.\n     */\n    void setRowVector(int row, RealVector vector)\n        throws MatrixIndexException, InvalidMatrixException;\n-   \n+\n    /**\n     * Returns the entries in column number <code>column</code>\n     * as a vector.  Column indices start at 0.\n     */\n    void setColumnVector(int column, RealVector vector)\n        throws MatrixIndexException, InvalidMatrixException;\n-   \n+\n     /**\n      * Returns the entries in row number <code>row</code> as an array.\n      * <p>\n      */\n     void setRow(int row, double[] array)\n         throws MatrixIndexException, InvalidMatrixException;\n-    \n+\n     /**\n      * Returns the entries in column number <code>col</code> as an array.\n      * <p>\n      */\n     void setColumn(int column, double[] array)\n         throws MatrixIndexException, InvalidMatrixException;\n-    \n+\n     /**\n      * Returns the entry in the specified row and column.\n      * <p>\n-     * Row and column indices start at 0 and must satisfy \n+     * Row and column indices start at 0 and must satisfy\n      * <ul>\n      * <li><code>0 <= row < rowDimension</code></li>\n      * <li><code> 0 <= column < columnDimension</code></li>\n      * </ul>\n      * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n-     * \n+     *\n      * @param row  row location of entry to be fetched\n      * @param column  column location of entry to be fetched\n      * @return matrix entry in row,column\n     /**\n      * Set the entry in the specified row and column.\n      * <p>\n-     * Row and column indices start at 0 and must satisfy \n+     * Row and column indices start at 0 and must satisfy\n      * <ul>\n      * <li><code>0 <= row < rowDimension</code></li>\n      * <li><code> 0 <= column < columnDimension</code></li>\n      * </ul>\n      * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n-     * \n+     *\n      * @param row  row location of entry to be set\n      * @param column  column location of entry to be set\n      * @param value matrix entry to be set in row,column\n     /**\n      * Change an entry in the specified row and column.\n      * <p>\n-     * Row and column indices start at 0 and must satisfy \n+     * Row and column indices start at 0 and must satisfy\n      * <ul>\n      * <li><code>0 <= row < rowDimension</code></li>\n      * <li><code> 0 <= column < columnDimension</code></li>\n      * </ul>\n      * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n-     * \n+     *\n      * @param row  row location of entry to be set\n      * @param column  column location of entry to be set\n      * @param increment value to add to the current matrix entry in row,column\n     /**\n      * Change an entry in the specified row and column.\n      * <p>\n-     * Row and column indices start at 0 and must satisfy \n+     * Row and column indices start at 0 and must satisfy\n      * <ul>\n      * <li><code>0 <= row < rowDimension</code></li>\n      * <li><code> 0 <= column < columnDimension</code></li>\n      * </ul>\n      * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n-     * \n+     *\n      * @param row  row location of entry to be set\n      * @param column  column location of entry to be set\n      * @param factor multiplication factor for the current matrix entry in row,column\n--- a/src/main/java/org/apache/commons/math/linear/RealMatrixChangingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrixChangingVisitor.java\n \n /**\n  * Interface defining a visitor for matrix entries.\n- * \n+ *\n  * @see DefaultRealMatrixChangingVisitor\n  * @version $Revision$ $Date$\n  * @since 2.0\n--- a/src/main/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrixImpl.java\n  * <p>\n  * <strong>Usage notes</strong>:<br>\n  * <ul><li>\n- * The LU decomposition is cached and reused on subsequent calls.   \n+ * The LU decomposition is cached and reused on subsequent calls.\n  * If data are modified via references to the underlying array obtained using\n  * <code>getDataRef()</code>, then the stored LU decomposition will not be\n- * discarded.  In this case, you need to explicitly invoke \n+ * discarded.  In this case, you need to explicitly invoke\n  * <code>LUDecompose()</code> to recompute the decomposition\n  * before using any of the methods above.</li>\n  * <li>\n  */\n @Deprecated\n public class RealMatrixImpl extends AbstractRealMatrix implements Serializable {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -1067294169172445528L;\n \n         } else {\n             if (d == null) {\n                 throw new NullPointerException();\n-            }   \n+            }\n             final int nRows = d.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n             }\n             final int nCols = d[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n             }\n             for (int r = 1; r < nRows; r++) {\n                 if (d[r].length != nCols) {\n                             \"some rows have length {0} while others have length {1}\",\n                             nCols, d[r].length);\n                 }\n-            }       \n+            }\n             data = d;\n         }\n     }\n \n     /** {@inheritDoc} */\n     @Override\n-    public void setSubMatrix(final double[][] subMatrix, final int row, final int column) \n+    public void setSubMatrix(final double[][] subMatrix, final int row, final int column)\n     throws MatrixIndexException {\n         if (data == null) {\n             if (row > 0) {\n             }\n             final int nRows = subMatrix.length;\n             if (nRows == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n             }\n \n             final int nCols = subMatrix[0].length;\n             if (nCols == 0) {\n-                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n             }\n             data = new double[subMatrix.length][nCols];\n             for (int i = 0; i < data.length; ++i) {\n                 if (subMatrix[i].length != nCols) {\n                     throw MathRuntimeException.createIllegalArgumentException(\n                             \"some rows have length {0} while others have length {1}\",\n-                            nCols, subMatrix[i].length); \n+                            nCols, subMatrix[i].length);\n                 }\n                 System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n             }\n             throw new MatrixIndexException(\n                     \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n                     row, column, getRowDimension(), getColumnDimension());\n-        }      \n+        }\n     }\n \n     /** {@inheritDoc} */\n             throw new MatrixIndexException(\n                     \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n                     row, column, getRowDimension(), getColumnDimension());\n-        }      \n+        }\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/linear/RealMatrixPreservingVisitor.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrixPreservingVisitor.java\n \n /**\n  * Interface defining a visitor for matrix entries.\n- * \n+ *\n  * @see DefaultRealMatrixPreservingVisitor\n  * @version $Revision$ $Date$\n  * @since 2.0\n--- a/src/main/java/org/apache/commons/math/linear/RealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealVector.java\n  * <pre>\n  *   RealVector result = v.mapAddToSelf(3.0).mapTanToSelf().mapSquareToSelf();\n  * </pre>\n- * \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n      * @return  true if any coordinate of this vector is NaN; false otherwise\n      */\n     public boolean isNaN();\n-    \n+\n     /**\n      * Returns true if any coordinate of this vector is infinite and none are NaN;\n      * false otherwise\n      * false otherwise\n      */\n     public boolean isInfinite();\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n \n \n /**\n- * An interface to classes that implement an algorithm to calculate the \n+ * An interface to classes that implement an algorithm to calculate the\n  * Singular Value Decomposition of a real matrix.\n  * <p>The Singular Value Decomposition of matrix A is a set of three matrices:\n  * U, &Sigma; and V such that A = U &times; &Sigma; &times; V<sup>T</sup>.\n public interface SingularValueDecomposition {\n \n     /**\n-     * Returns the matrix U of the decomposition. \n+     * Returns the matrix U of the decomposition.\n      * <p>U is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n      * @return the U matrix\n      * @see #getUT()\n     RealMatrix getU();\n \n     /**\n-     * Returns the transpose of the matrix U of the decomposition. \n+     * Returns the transpose of the matrix U of the decomposition.\n      * <p>U is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n      * @return the U matrix (or null if decomposed matrix is singular)\n      * @see #getU()\n     RealMatrix getUT();\n \n     /**\n-     * Returns the diagonal matrix &Sigma; of the decomposition. \n+     * Returns the diagonal matrix &Sigma; of the decomposition.\n      * <p>&Sigma; is a diagonal matrix. The singular values are provided in\n      * non-increasing order, for compatibility with Jama.</p>\n      * @return the &Sigma; matrix\n     double[] getSingularValues();\n \n     /**\n-     * Returns the matrix V of the decomposition. \n+     * Returns the matrix V of the decomposition.\n      * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n      * @return the V matrix (or null if decomposed matrix is singular)\n      * @see #getVT()\n     RealMatrix getV();\n \n     /**\n-     * Returns the transpose of the matrix V of the decomposition. \n+     * Returns the transpose of the matrix V of the decomposition.\n      * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n      * @return the V matrix (or null if decomposed matrix is singular)\n      * @see #getV()\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n     private RealMatrix cachedVt;\n \n     /**\n-     * Calculates the Singular Value Decomposition of the given matrix. \n+     * Calculates the Singular Value Decomposition of the given matrix.\n      * @param matrix The matrix to decompose.\n      * @exception InvalidMatrixException (wrapping a {@link\n      * org.apache.commons.math.ConvergenceException} if algorithm fails to converge\n                 iData[0] = ei1;\n                 for (int i = 0; i < n - 1; ++i) {\n                     // compute Bt.E.S^(-1) where E is the eigenvectors matrix\n-                    // we reuse the array from matrix E to store the result \n+                    // we reuse the array from matrix E to store the result\n                     final double[] ei0 = ei1;\n                     ei1 = eData[i + 1];\n                     iData[i + 1] = ei1;\n                 iData[0] = ei1;\n                 for (int i = 0; i < m - 1; ++i) {\n                     // compute Bt.E.S^(-1) where E is the eigenvectors matrix\n-                    // we reuse the array from matrix E to store the result \n+                    // we reuse the array from matrix E to store the result\n                     final double[] ei0 = ei1;\n                     ei1 = eData[i + 1];\n                     iData[i + 1] = ei1;\n \n     /** Specialized solver. */\n     private static class Solver implements DecompositionSolver {\n-        \n+\n         /** Singular values. */\n         private final double[] singularValues;\n \n--- a/src/main/java/org/apache/commons/math/linear/SparseFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/SparseFieldMatrix.java\n \n /**\n  * Sparse matrix implementation based on an open addressed map.\n- * \n+ *\n  * @param <T> the type of the field elements\n  * @version $Revision$ $Date$\n  * @since 2.0\n      * column dimension\n      */\n     private final int columns;\n-    \n+\n \n     /**\n      * Creates a matrix with no data.\n         this.columns = columnDimension;\n         entries = new OpenIntToFieldHashMap<T>(field);\n     }\n-    \n+\n     /**\n      * Copy constructor.\n      * @param other The instance to copy\n         } else {\n             entries.put(key, value);\n         }\n-       \n+\n     }\n \n     /** {@inheritDoc} */\n         } else {\n             entries.put(key, value);\n         }\n-        \n+\n     }\n \n     /** {@inheritDoc} */\n         } else {\n             entries.put(computeKey(row, column), value);\n         }\n-        \n+\n     }\n     /**\n      * Compute the key to access a matrix element\n--- a/src/main/java/org/apache/commons/math/linear/SparseFieldVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/SparseFieldVector.java\n  * @since 2.0\n  */\n public class SparseFieldVector<T extends FieldElement<T>> implements FieldVector<T>, Serializable {\n-    \n+\n     /**\n      *  Serial version id\n      */\n         this(field, 0);\n     }\n \n-    \n+\n     /**\n      * Construct a (dimension)-length vector of zeros.\n      * @param field field to which the elements belong\n         entries = new OpenIntToFieldHashMap<T>(v.entries);\n     }\n \n-    \n+\n     /**\n      * Build a vector with known the sparseness (for advanced use only).\n      * @param field field to which the elements belong\n         }\n     }\n \n-     \n+\n \n     /**\n      * Copy constructor.\n     private OpenIntToFieldHashMap<T> getEntries() {\n         return entries;\n     }\n-    \n+\n     /**\n      * Optimized method to add sparse vectors.\n      * @param v vector to add\n \n     }\n \n-    \n+\n     /** {@inheritDoc} */\n     public FieldVector<T> add(T[] v) throws IllegalArgumentException {\n         checkVectorDimensions(v.length);\n             return append((SparseFieldVector<T>) v);\n         } else {\n             return append(v.toArray());\n-        }   \n+        }\n     }\n \n     /** {@inheritDoc} */\n      /** {@inheritDoc} */\n      public FieldVector<T> mapSubtract(T d) {\n         return copy().mapSubtractToSelf(d);\n-    }    \n+    }\n \n      /** {@inheritDoc} */\n      public FieldVector<T> mapSubtractToSelf(T d) {\n         for (int i = 0; i < v.length; i++) {\n             setEntry(i + index, v[i]);\n         }\n-        \n+\n     }\n \n     /**\n     public T[] toArray() {\n         return getData();\n     }\n-    \n+\n     /**\n      * Check if an index is valid.\n      *\n     }\n \n \n-    \n+\n }\n--- a/src/main/java/org/apache/commons/math/linear/SparseRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/SparseRealMatrix.java\n \n /**\n  * Marker interface for {@link RealMatrix} implementations that require sparse backing storage\n- * \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  *\n  */\n public interface SparseRealMatrix extends RealMatrix {\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/math/linear/SparseRealVector.java\n+++ b/src/main/java/org/apache/commons/math/linear/SparseRealVector.java\n  *\n  */\n public interface SparseRealVector extends RealVector {\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/math/linear/TriDiagonalTransformer.java\n+++ b/src/main/java/org/apache/commons/math/linear/TriDiagonalTransformer.java\n     }\n \n     /**\n-     * Returns the matrix Q of the transform. \n+     * Returns the matrix Q of the transform.\n      * <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n      * @return the Q matrix\n      */\n     }\n \n     /**\n-     * Returns the transpose of the matrix Q of the transform. \n+     * Returns the transpose of the matrix Q of the transform.\n      * <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n      * @return the Q matrix\n      */\n     }\n \n     /**\n-     * Returns the tridiagonal matrix T of the transform. \n+     * Returns the tridiagonal matrix T of the transform.\n      * @return the T matrix\n      */\n     public RealMatrix getT() {\n--- a/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n  */\n public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n \n-    \n+\n     /** Name of the method. */\n     private final String name;\n \n     protected AbstractIntegrator() {\n         this(null);\n     }\n-    \n+\n     /** {@inheritDoc} */\n     public String getName() {\n         return name;\n         /** {@inheritDoc} */\n         public void resetState(double t, double[] y) {\n         }\n-        \n-    }\n-\n-}\n+\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n+++ b/src/main/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n   public double getInitialTime() {\n     return initialTime;\n   }\n-    \n+\n   /**\n    * Get the final integration time.\n    * @return final integration time\n   public double getInterpolatedTime() {\n     return steps.get(index).getInterpolatedTime();\n   }\n-    \n+\n   /** Set the time of the interpolated point.\n    * <p>This method should <strong>not</strong> be called before the\n    * integration is over because some internal variables are set only\n     return steps.get(index).getInterpolatedState();\n   }\n \n-  /** Compare a step interval and a double. \n+  /** Compare a step interval and a double.\n    * @param time point to locate\n    * @param interval step interval\n    * @return -1 if the double is before the interval, 0 if it is in\n--- a/src/main/java/org/apache/commons/math/ode/DerivativeException.java\n+++ b/src/main/java/org/apache/commons/math/ode/DerivativeException.java\n  */\n public class DerivativeException\n   extends MathException {\n-    \n+\n   /** Serializable version identifier */\n   private static final long serialVersionUID = 5666710788967425123L;\n \n--- a/src/main/java/org/apache/commons/math/ode/FirstOrderConverter.java\n+++ b/src/main/java/org/apache/commons/math/ode/FirstOrderConverter.java\n     // build the result state derivative\n     System.arraycopy(zDot,  0, yDot, 0,         dimension);\n     System.arraycopy(zDDot, 0, yDot, dimension, dimension);\n-    \n+\n   }\n \n   /** Underlying second order equations set. */\n--- a/src/main/java/org/apache/commons/math/ode/FirstOrderDifferentialEquations.java\n+++ b/src/main/java/org/apache/commons/math/ode/FirstOrderDifferentialEquations.java\n  */\n \n public interface FirstOrderDifferentialEquations {\n-    \n+\n     /** Get the dimension of the problem.\n      * @return dimension of the problem\n      */\n     public int getDimension();\n-    \n+\n     /** Get the current time derivative of the state vector.\n      * @param t current value of the independent <I>time</I> variable\n      * @param y array containing the current value of the state vector\n      */\n     public void computeDerivatives(double t, double[] y, double[] yDot)\n     throws DerivativeException;\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/math/ode/SecondOrderDifferentialEquations.java\n+++ b/src/main/java/org/apache/commons/math/ode/SecondOrderDifferentialEquations.java\n    * @return dimension of the problem\n    */\n   public int getDimension();\n-    \n+\n   /** Get the current time derivative of the state vector.\n    * @param t current value of the independent <I>time</I> variable\n    * @param y array containing the current value of the state vector\n--- a/src/main/java/org/apache/commons/math/ode/events/EventHandler.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventHandler.java\n  * discontinuities, or simply when the user wants to monitor some\n  * states boundaries crossings.\n  * </p>\n- * \n+ *\n  * <p>These events are defined as occurring when a <code>g</code>\n  * switching function sign changes.</p>\n  *\n \n   /** Compute the value of the switching function.\n \n-   * <p>The discrete events are generated when the sign of this \n+   * <p>The discrete events are generated when the sign of this\n    * switching function changes. The integrator will take care to change\n    * the stepsize in such a way these events occur exactly at step boundaries.\n    * The switching function must be continuous in its roots neighborhood\n    * @exception EventException if the event occurrence triggers an error\n    */\n   public int eventOccurred(double t, double[] y, boolean increasing) throws EventException;\n-  \n+\n   /** Reset the state prior to continue the integration.\n \n    * <p>This method is called after the step handler has returned and\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n  *        [  -8  48 -256 1280  ... ]\n  *        [          ...           ]\n  * </pre></p>\n- * \n+ *\n  * <p>Using the Nordsieck vector has several advantages:\n  * <ul>\n  *   <li>it greatly simplifies step interpolation as the interpolator mainly applies\n  *   the step are triggered,</li>\n  *   <li>it allows to extend the methods in order to support adaptive stepsize.</li>\n  * </ul></p>\n- * \n+ *\n  * <p>The Nordsieck vector at step n+1 is computed from the Nordsieck vector at step n as follows:\n  * <ul>\n  *   <li>y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n) + u<sup>T</sup> r<sub>n</sub></li>\n         // reuse the step that was chosen by the starter integrator\n         double hNew = stepSize;\n         interpolator.rescale(hNew);\n-        \n+\n         boolean lastStep = false;\n         while (!lastStep) {\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n  *        [  -8  48 -256 1280  ... ]\n  *        [          ...           ]\n  * </pre></p>\n- * \n+ *\n  * <p>Using the Nordsieck vector has several advantages:\n  * <ul>\n  *   <li>it greatly simplifies step interpolation as the interpolator mainly applies\n  *   the step are triggered,</li>\n  *   <li>it allows to extend the methods in order to support adaptive stepsize.</li>\n  * </ul></p>\n- * \n+ *\n  * <p>The predicted Nordsieck vector at step n+1 is computed from the Nordsieck vector at step\n  * n as follows:\n  * <ul>\n         super(\"Adams-Moulton\", nSteps, nSteps + 1, minStep, maxStep,\n               vecAbsoluteTolerance, vecRelativeTolerance);\n     }\n-      \n-    \n+\n+\n     /** {@inheritDoc} */\n     @Override\n     public double integrate(final FirstOrderDifferentialEquations equations,\n \n         double hNew = stepSize;\n         interpolator.rescale(hNew);\n-        \n+\n         boolean lastStep = false;\n         while (!lastStep) {\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n public abstract class AdaptiveStepsizeIntegrator\n   extends AbstractIntegrator {\n \n-  \n+\n   /** Build an integrator with the given stepsize bounds.\n    * The default step handler does nothing.\n    * @param name name of the method\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n     }\n \n   }\n- \n+\n   /** {@inheritDoc} */\n   @Override\n   protected void doFinalize()\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n \n   /** Prototype of the step interpolator. */\n   private RungeKuttaStepInterpolator prototype;\n-                                         \n+\n   /** Stepsize control exponent. */\n   private double exp;\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n \n class GillStepInterpolator\n   extends RungeKuttaStepInterpolator {\n-    \n+\n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n    * {@link\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n     } else {\n       // step size sequence: 2, 4, 6, 8, ...\n       for (int k = 0; k < size; ++k) {\n-        sequence[k] = 2 * (k + 1); \n+        sequence[k] = 2 * (k + 1);\n       }\n     }\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n     }\n \n   }\n-    \n+\n   /** {@inheritDoc} */\n   @Override\n   public void writeExternal(final ObjectOutput out)\n   public void readExternal(final ObjectInput in)\n     throws IOException {\n \n-    // read the base class \n+    // read the base class\n     final double t = readBaseExternal(in);\n     final int dimension = (currentState == null) ? -1 : currentState.length;\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n \n class MidpointStepInterpolator\n   extends RungeKuttaStepInterpolator {\n-    \n+\n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n    * {@link\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n \n   /** Prototype of the step interpolator. */\n   private RungeKuttaStepInterpolator prototype;\n-                                         \n+\n   /** Integration step. */\n   private double step;\n \n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n   public void readExternal(final ObjectInput in)\n     throws IOException {\n \n-    // read the base class \n+    // read the base class\n     final double t = readBaseExternal(in);\n \n     // read the local attributes\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n \n class ThreeEighthesStepInterpolator\n   extends RungeKuttaStepInterpolator {\n-    \n+\n   /** Simple constructor.\n    * This constructor builds an instance that is not usable yet, the\n    * {@link\n--- a/src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n   public double getPreviousTime() {\n     return previousTime;\n   }\n-    \n+\n   /** {@inheritDoc} */\n   public double getCurrentTime() {\n     return currentTime;\n   }\n-    \n+\n   /** {@inheritDoc} */\n   public double getInterpolatedTime() {\n     return interpolatedTime;\n   }\n-    \n+\n   /** {@inheritDoc} */\n   public void setInterpolatedTime(final double time) {\n       interpolatedTime = time;\n   protected abstract void computeInterpolatedStateAndDerivatives(double theta,\n                                                                  double oneMinusThetaH)\n     throws DerivativeException;\n-    \n+\n   /** {@inheritDoc} */\n   public double[] getInterpolatedState() throws DerivativeException {\n \n--- a/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\n     throws DerivativeException {\n       System.arraycopy(currentState, 0, interpolatedState, 0, currentState.length);\n   }\n-    \n+\n   /** Write the instance to an output channel.\n    * @param out output channel\n    * @exception IOException if the instance cannot be written\n   public void readExternal(final ObjectInput in)\n     throws IOException {\n \n-    // read the base class \n+    // read the base class\n     final double t = readBaseExternal(in);\n \n     // we can now set the interpolated time and state\n--- a/src/main/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n     public void readExternal(final ObjectInput in)\n         throws IOException, ClassNotFoundException {\n \n-        // read the base class \n+        // read the base class\n         final double t = readBaseExternal(in);\n \n         // read the local attributes\n--- a/src/main/java/org/apache/commons/math/ode/sampling/StepHandler.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/StepHandler.java\n    */\n   public void handleStep(StepInterpolator interpolator, boolean isLast)\n     throws DerivativeException;\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/math/ode/sampling/StepInterpolator.java\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/StepInterpolator.java\n    * @return previous grid point time\n    */\n   public double getPreviousTime();\n-    \n+\n   /**\n    * Get the current grid point time.\n    * @return current grid point time\n    */\n   public double getCurrentTime();\n-    \n+\n   /**\n    * Get the time of the interpolated point.\n    * If {@link #setInterpolatedTime} has not been called, it returns\n    * @return interpolation point time\n    */\n   public double getInterpolatedTime();\n-    \n+\n   /**\n    * Set the time of the interpolated point.\n    * <p>Setting the time outside of the current step is now allowed, but\n--- a/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateRealOptimizer.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n \n-/** \n+/**\n  * This interface represents an optimization algorithm for {@link DifferentiableMultivariateRealFunction\n  * scalar differentiable objective functions}.\n  * <p>Optimization algorithms find the input point set that either {@link GoalType\n--- a/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateVectorialOptimizer.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n \n-/** \n+/**\n  * This interface represents an optimization algorithm for {@link DifferentiableMultivariateVectorialFunction\n  * vectorial differentiable objective functions}.\n  * <p>Optimization algorithms find the input point set that either {@link GoalType\n--- a/src/main/java/org/apache/commons/math/optimization/GoalType.java\n+++ b/src/main/java/org/apache/commons/math/optimization/GoalType.java\n \n import java.io.Serializable;\n \n-/** \n+/**\n  * Goal type for an optimization problem.\n  * @version $Revision$ $Date$\n  * @since 2.0\n--- a/src/main/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n      * odd elements are distance measurements in meters with a 15m standard deviation.\n      * In this case, the weights array should be initialized with value\n      * 1.0/(0.01<sup>2</sup>) in the even elements and 1.0/(15.0<sup>2</sup>) in the\n-     * odd elements (i.e. reciprocals of variances). \n+     * odd elements (i.e. reciprocals of variances).\n      * </p>\n      * <p>\n      * The array computed by the objective function, the observations array and the\n--- a/src/main/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizer.java\n import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n import org.apache.commons.math.random.RandomVectorGenerator;\n \n-/** \n+/**\n  * Special implementation of the {@link DifferentiableMultivariateRealOptimizer} interface adding\n  * multi-start features to an existing optimizer.\n  * <p>\n--- a/src/main/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizer.java\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.random.RandomVectorGenerator;\n \n-/** \n+/**\n  * Special implementation of the {@link DifferentiableMultivariateVectorialOptimizer} interface adding\n  * multi-start features to an existing optimizer.\n  * <p>\n--- a/src/main/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizer.java\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.random.RandomVectorGenerator;\n \n-/** \n+/**\n  * Special implementation of the {@link MultivariateRealOptimizer} interface adding\n  * multi-start features to an existing optimizer.\n  * <p>\n--- a/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.random.RandomGenerator;\n \n-/** \n+/**\n  * Special implementation of the {@link UnivariateRealOptimizer} interface adding\n  * multi-start features to an existing optimizer.\n  * <p>\n--- a/src/main/java/org/apache/commons/math/optimization/MultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/MultivariateRealOptimizer.java\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n \n-/** \n+/**\n  * This interface represents an optimization algorithm for {@link MultivariateRealFunction\n  * scalar objective functions}.\n  * <p>Optimization algorithms find the input point set that either {@link GoalType\n--- a/src/main/java/org/apache/commons/math/optimization/OptimizationException.java\n+++ b/src/main/java/org/apache/commons/math/optimization/OptimizationException.java\n \n import org.apache.commons.math.ConvergenceException;\n \n-/** \n+/**\n  * This class represents exceptions thrown by optimizers.\n  *\n  * @version $Revision$ $Date$\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -357696069587075016L;\n \n-    /** \n+    /**\n      * Simple constructor.\n      * Build an exception by translating and formating a message\n      * @param specifier format specifier (to be translated)\n--- a/src/main/java/org/apache/commons/math/optimization/RealPointValuePair.java\n+++ b/src/main/java/org/apache/commons/math/optimization/RealPointValuePair.java\n import java.io.Serializable;\n \n \n-/** \n+/**\n  * This class holds a point and the value of an objective function at this point.\n  * <p>This is a simple immutable container.</p>\n  * @see VectorialPointValuePair\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleRealPointChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleRealPointChecker.java\n \n import org.apache.commons.math.util.MathUtils;\n \n-/** \n+/**\n  * Simple implementation of the {@link RealConvergenceChecker} interface using\n  * only point coordinates.\n  * <p>\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleScalarValueChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleScalarValueChecker.java\n \n import org.apache.commons.math.util.MathUtils;\n \n-/** \n+/**\n  * Simple implementation of the {@link RealConvergenceChecker} interface using\n  * only objective function values.\n  * <p>\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleVectorialPointChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleVectorialPointChecker.java\n \n import org.apache.commons.math.util.MathUtils;\n \n-/** \n+/**\n  * Simple implementation of the {@link VectorialConvergenceChecker} interface using\n  * only point coordinates.\n  * <p>\n--- a/src/main/java/org/apache/commons/math/optimization/SimpleVectorialValueChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleVectorialValueChecker.java\n \n import org.apache.commons.math.util.MathUtils;\n \n-/** \n+/**\n  * Simple implementation of the {@link VectorialConvergenceChecker} interface using\n  * only objective function values.\n  * <p>\n--- a/src/main/java/org/apache/commons/math/optimization/UnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/UnivariateRealOptimizer.java\n \n /**\n  * Interface for (univariate real) optimization algorithms.\n- *  \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n \n     /**\n      * Get the result of the last run of the optimizer.\n-     * \n+     *\n      * @return the last result.\n      * @throws IllegalStateException if there is no result available, either\n      * because no result was yet computed or the last attempt failed.\n \n     /**\n      * Get the result of the last run of the optimizer.\n-     * \n+     *\n      * @return the value of the function at the last result.\n      * @throws IllegalStateException if there is no result available, either\n      * because no result was yet computed or the last attempt failed.\n      */\n     double getFunctionValue();\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/VectorialPointValuePair.java\n+++ b/src/main/java/org/apache/commons/math/optimization/VectorialPointValuePair.java\n \n import java.io.Serializable;\n \n-/** \n+/**\n  * This class holds a point and the vectorial value of an objective function at this point.\n  * <p>This is a simple immutable container.</p>\n  * @see RealPointValuePair\n--- a/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n \n-/** \n+/**\n  * This class implements simplex-based direct search optimization\n  * algorithms.\n  *\n  * algorithms.</p>\n  *\n  * implements MultivariateRealOptimizer since 2.0\n- * \n+ *\n  * @see MultivariateRealFunction\n  * @see NelderMead\n  * @see MultiDirectional\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n import org.apache.commons.math.optimization.RealConvergenceChecker;\n import org.apache.commons.math.optimization.RealPointValuePair;\n \n-/** \n+/**\n  * This class implements the multi-directional direct search method.\n  *\n  * @version $Revision$ $Date$\n--- a/src/main/java/org/apache/commons/math/optimization/direct/NelderMead.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/NelderMead.java\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n \n-/** \n+/**\n  * This class implements the Nelder-Mead direct search method.\n  *\n  * @version $Revision$ $Date$\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/ParametricRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/ParametricRealFunction.java\n /**\n  * An interface representing a real function that depends on one independent\n  * variable plus some extra parameters.\n- *  \n+ *\n  * @version $Revision$ $Date$\n  */\n public interface ParametricRealFunction {\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java\n             }\n             return y;\n         }\n-        \n+\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n     /** Convergence checker. */\n     protected VectorialConvergenceChecker checker;\n \n-    /** \n+    /**\n      * Jacobian matrix.\n      * <p>This matrix is in canonical form just after the calls to\n      * {@link #updateJacobian()}, but may be modified by the solver\n         }\n     }\n \n-    /** \n+    /**\n      * Update the jacobian matrix.\n      * @exception FunctionEvaluationException if the function jacobian\n      * cannot be evaluated or its dimension doesn't match problem dimension\n         }\n     }\n \n-    /** \n+    /**\n      * Update the residuals array and cost function value.\n      * @exception FunctionEvaluationException if the function cannot be evaluated\n      * or its dimension doesn't match problem dimension or maximal number of\n \n     }\n \n-    /** \n+    /**\n      * Get the Root Mean Square value.\n      * Get the Root Mean Square value, i.e. the root of the arithmetic\n      * mean of the square of all weighted residuals. This is related to the\n      * criterion that is minimized by the optimizer as follows: if\n      * <em>c</em> if the criterion, and <em>n</em> is the number of\n      * measurements, then the RMS is <em>sqrt (c/n)</em>.\n-     * \n+     *\n      * @return RMS value\n      */\n     public double getRMS() {\n     abstract protected VectorialPointValuePair doOptimize()\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n         }\n     }\n \n-    /** \n+    /**\n      * Compute the gradient vector.\n      * @param evaluationPoint point at which the gradient must be evaluated\n      * @return gradient at the specified point\n         return gradient.value(evaluationPoint);\n     }\n \n-    /** \n+    /**\n      * Compute the objective function value.\n      * @param evaluationPoint point at which the objective function must be evaluated\n      * @return objective function value at specified point\n     abstract protected RealPointValuePair doOptimize()\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n \n-/** \n+/**\n  * Gauss-Newton least-squares solver.\n  * <p>\n  * This class solve a least-square problem by solving the normal equations\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n \n \n-/** \n+/**\n  * This class solves a least squares problem using the Levenberg-Marquardt algorithm.\n  *\n  * <p>This implementation <em>should</em> work even for over-determined systems\n      * and the columns of the jacobian. */\n     private double orthoTolerance;\n \n-    /** \n+    /**\n      * Build an optimizer for least squares problems.\n      * <p>The default values for the algorithm settings are:\n      *   <ul>\n \n     }\n \n-    /** \n+    /**\n      * Set the positive input variable used in determining the initial step bound.\n      * This bound is set to the product of initialStepBoundFactor and the euclidean\n      * norm of diag*x if nonzero, or else to initialStepBoundFactor itself. In most\n         this.initialStepBoundFactor = initialStepBoundFactor;\n     }\n \n-    /** \n+    /**\n      * Set the desired relative error in the sum of squares.\n-     * \n+     *\n      * @param costRelativeTolerance desired relative error in the sum of squares\n      */\n     public void setCostRelativeTolerance(double costRelativeTolerance) {\n         this.costRelativeTolerance = costRelativeTolerance;\n     }\n \n-    /** \n+    /**\n      * Set the desired relative error in the approximate solution parameters.\n-     * \n+     *\n      * @param parRelativeTolerance desired relative error\n      * in the approximate solution parameters\n      */\n         this.parRelativeTolerance = parRelativeTolerance;\n     }\n \n-    /** \n+    /**\n      * Set the desired max cosine on the orthogonality.\n-     * \n+     *\n      * @param orthoTolerance desired max cosine on the orthogonality\n      * between the function vector and the columns of the jacobian\n      */\n \n     }\n \n-    /** \n+    /**\n      * Determine the Levenberg-Marquardt parameter.\n      * <p>This implementation is a translation in Java of the MINPACK\n      * <a href=\"http://www.netlib.org/minpack/lmpar.f\">lmpar</a>\n      *   <li>Jorge   J. More</li>\n      * </ul>\n      * <p>Luc Maisonobe did the Java translation.</p>\n-     * \n+     *\n      * @param qy array containing qTy\n      * @param delta upper bound on the euclidean norm of diagR * lmDir\n      * @param diag diagonal matrix\n         if (rank == solvedCols) {\n             for (int j = 0; j < solvedCols; ++j) {\n                 int pj = permutation[j];\n-                work1[pj] *= diag[pj] / dxNorm; \n+                work1[pj] *= diag[pj] / dxNorm;\n             }\n             sum2 = 0;\n             for (int j = 0; j < solvedCols; ++j) {\n             // compute the Newton correction\n             for (int j = 0; j < solvedCols; ++j) {\n                 int pj = permutation[j];\n-                work1[pj] = work3[pj] * diag[pj] / dxNorm; \n+                work1[pj] = work3[pj] * diag[pj] / dxNorm;\n             }\n             for (int j = 0; j < solvedCols; ++j) {\n                 int pj = permutation[j];\n         }\n     }\n \n-    /** \n+    /**\n      * Solve a*x = b and d*x = 0 in the least squares sense.\n      * <p>This implementation is a translation in Java of the MINPACK\n      * <a href=\"http://www.netlib.org/minpack/qrsolv.f\">qrsolv</a>\n      *   <li>Jorge   J. More</li>\n      * </ul>\n      * <p>Luc Maisonobe did the Java translation.</p>\n-     * \n+     *\n      * @param qy array containing qTy\n      * @param diag diagonal matrix\n      * @param lmDiag diagonal elements associated with lmDir\n \n     }\n \n-    /** \n+    /**\n      * Decompose a matrix A as A.P = Q.R using Householder transforms.\n      * <p>As suggested in the P. Lascaux and R. Theodor book\n      * <i>Analyse num&eacute;rique matricielle appliqu&eacute;e &agrave;\n \n     }\n \n-    /** \n+    /**\n      * Compute the product Qt.y for some Q.R. decomposition.\n-     * \n+     *\n      * @param y vector to multiply (will be overwritten with the result)\n      */\n     private void qTy(double[] y) {\n--- a/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n import org.apache.commons.math.optimization.DifferentiableMultivariateRealOptimizer;\n import org.apache.commons.math.optimization.RealPointValuePair;\n \n-/** \n+/**\n  * Non-linear conjugate gradient optimizer.\n  * <p>\n  * This class supports both the Fletcher-Reeves and the Polak-Ribi&egrave;re\n                     double deltaMid = 0;\n                     for (int i = 0; i < r.length; ++i) {\n                         deltaMid += r[i] * steepestDescent[i];\n-                    }                    \n+                    }\n                     beta = (delta - deltaMid) / deltaOld;\n                 }\n                 steepestDescent = newSteepestDescent;\n--- a/src/main/java/org/apache/commons/math/optimization/general/Preconditioner.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/Preconditioner.java\n \n import org.apache.commons.math.FunctionEvaluationException;\n \n-/** \n+/**\n  * This interface represents a preconditioner for differentiable scalar\n  * objective function optimizers.\n  * @version $Revision$ $Date$\n  */\n public interface Preconditioner {\n \n-    /** \n+    /**\n      * Precondition a search direction.\n      * <p>\n      * The returned preconditioned search direction must be computed fast or\n--- a/src/main/java/org/apache/commons/math/optimization/linear/AbstractLinearOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/AbstractLinearOptimizer.java\n     abstract protected RealPointValuePair doOptimize()\n         throws OptimizationException;\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/linear/LinearConstraint.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/LinearConstraint.java\n     @Override\n     public boolean equals(Object other) {\n \n-      if (this == other) { \n+      if (this == other) {\n         return true;\n       }\n \n       }\n \n     }\n-    \n+\n     /** {@inheritDoc} */\n     @Override\n     public int hashCode() {\n--- a/src/main/java/org/apache/commons/math/optimization/linear/LinearObjectiveFunction.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/LinearObjectiveFunction.java\n     @Override\n     public boolean equals(Object other) {\n \n-      if (this == other) { \n+      if (this == other) {\n         return true;\n       }\n \n       }\n \n     }\n-    \n+\n     /** {@inheritDoc} */\n     @Override\n     public int hashCode() {\n--- a/src/main/java/org/apache/commons/math/optimization/linear/LinearOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/LinearOptimizer.java\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n \n-/** \n+/**\n  * This interface represents an optimization algorithm for linear problems.\n  * <p>Optimization algorithms find the input point set that either {@link GoalType\n  * maximize or minimize} an objective function. In the linear case the form of\n--- a/src/main/java/org/apache/commons/math/optimization/linear/NoFeasibleSolutionException.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/NoFeasibleSolutionException.java\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -3044253632189082760L;\n \n-    /** \n+    /**\n      * Simple constructor using a default message.\n      */\n     public NoFeasibleSolutionException() {\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n  */\n public class SimplexSolver extends AbstractLinearOptimizer {\n \n-    /** Default amount of error to accept in floating point comparisons. */ \n+    /** Default amount of error to accept in floating point comparisons. */\n     private static final double DEFAULT_EPSILON = 1.0e-6;\n \n-    /** Amount of error to accept in floating point comparisons. */ \n-    protected final double epsilon;  \n+    /** Amount of error to accept in floating point comparisons. */\n+    protected final double epsilon;\n \n     /**\n      * Build a simplex solver with default settings.\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;\n-                    minRatioPos = i; \n+                    minRatioPos = i;\n                 }\n             }\n         }\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n \n /**\n  * A tableau for use in the Simplex method.\n- * \n+ *\n  * <p>\n  * Example:\n  * <pre>\n     /** Number of artificial variables. */\n     protected int numArtificialVariables;\n \n-    /** Amount of error to accept in floating point comparisons. */ \n+    /** Amount of error to accept in floating point comparisons. */\n     protected final double epsilon;\n-    \n+\n     /**\n      * Build a tableau for a linear problem.\n      * @param f linear objective function\n             // artificial variables\n             if ((constraint.getRelationship() == Relationship.EQ) ||\n                     (constraint.getRelationship() == Relationship.GEQ)) {\n-                matrix[0][getArtificialVariableOffset() + artificialVar] = 1; \n-                matrix[row][getArtificialVariableOffset() + artificialVar++] = 1; \n+                matrix[0][getArtificialVariableOffset() + artificialVar] = 1;\n+                matrix[row][getArtificialVariableOffset() + artificialVar++] = 1;\n             }\n         }\n \n                                         constraint.getRelationship().oppositeRelationship(),\n                                         -1 * constraint.getValue());\n         }\n-        return new LinearConstraint(constraint.getCoefficients(), \n+        return new LinearConstraint(constraint.getCoefficients(),\n                                     constraint.getRelationship(), constraint.getValue());\n     }\n \n     private Integer getBasicRowForSolution(final int col) {\n         return getBasicRow(col, false);\n     }\n-    \n+\n     /**\n      * Checks whether the given column is basic.\n      * @param col index of the column to check\n      * @param dest the destination array\n      */\n     private void copyArray(final double[] src, final double[] dest) {\n-        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); \n+        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length);\n     }\n \n     /**\n      * Get the current solution.\n-     * \n+     *\n      * @return current solution\n      */\n     protected RealPointValuePair getSolution() {\n       for (int i = 0; i < coefficients.length; i++) {\n           Integer basicRow = getBasicRowForSolution(getNumObjectiveFunctions() + i);\n           if (basicRows.contains(basicRow)) {\n-              // if multiple variables can take a given value \n+              // if multiple variables can take a given value\n               // then we choose the first and set the rest equal to 0\n               coefficients[i] = 0;\n           } else {\n     protected final int getRhsOffset() {\n         return getWidth() - 1;\n     }\n-    \n+\n     /**\n      * Returns the offset of the extra decision variable added when there is a\n      * negative decision variable in the original problem.\n     @Override\n     public boolean equals(Object other) {\n \n-      if (this == other) { \n+      if (this == other) {\n         return true;\n       }\n \n       }\n \n     }\n-    \n+\n     /** {@inheritDoc} */\n     @Override\n     public int hashCode() {\n--- a/src/main/java/org/apache/commons/math/optimization/linear/UnboundedSolutionException.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/UnboundedSolutionException.java\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 940539497277290619L;\n \n-    /** \n+    /**\n      * Simple constructor using a default message.\n      */\n     public UnboundedSolutionException() {\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n /**\n  * Provide a default implementation for several functions useful to generic\n  * optimizers.\n- *  \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n      * FunctionEvaluationExceptionFunctionEvaluationException\n      * @param defaultAbsoluteAccuracy maximum absolute error\n      * @param defaultMaximalIterationCount maximum number of iterations\n-     * @throws IllegalArgumentException if f is null or the \n+     * @throws IllegalArgumentException if f is null or the\n      * defaultAbsoluteAccuracy is not valid\n      */\n     protected AbstractUnivariateRealOptimizer(final int defaultMaximalIterationCount,\n \n     /**\n      * Convenience function for implementations.\n-     * \n+     *\n      * @param x the result to set\n      * @param fx the result to set\n      * @param iterationCount the iteration count to set\n         return evaluations;\n     }\n \n-    /** \n+    /**\n      * Compute the objective function value.\n      * @param f objective function\n      * @param point point at which the objective function must be evaluated\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n  * Implements Richard Brent's algorithm (from his book \"Algorithms for\n  * Minimization without Derivatives\", p. 79) for finding minima of real\n  * univariate functions.\n- *  \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public class BrentOptimizer extends AbstractUnivariateRealOptimizer {\n-    \n+\n     /**\n      * Golden section.\n      */\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n         return optimize(f, goalType, min, max);\n     }\n-    \n+\n     /** {@inheritDoc} */\n     public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n                            final double min, final double max)\n         clearResult();\n         return localMin(f, goalType, min, max, relativeAccuracy, absoluteAccuracy);\n     }\n-    \n+\n     /**\n      * Find the minimum of the function {@code f} within the interval {@code (a, b)}.\n      *\n      * @throws MaxIterationsExceededException if the maximum iteration count\n      * is exceeded.\n      * @throws FunctionEvaluationException if an error occurs evaluating\n-     * the function. \n+     * the function.\n      */\n     private double localMin(final UnivariateRealFunction f, final GoalType goalType,\n                             double a, double b, final double eps, final double t)\n--- a/src/main/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n /**\n  * Abstract class implementing the {@link  RandomGenerator} interface.\n  * Default implementations for all methods other than {@link #nextDouble()} and\n- * {@link #setSeed(long)} are provided. \n+ * {@link #setSeed(long)} are provided.\n  * <p>\n  * All data generation methods are based on <code>nextDouble().</code>\n  * Concrete implementations <strong>must</strong> override\n  * @version $Revision$ $Date$\n  */\n public abstract class AbstractRandomGenerator implements RandomGenerator {\n-    \n-    /** \n-     * Cached random normal value.  The default implementation for \n+\n+    /**\n+     * Cached random normal value.  The default implementation for\n      * {@link #nextGaussian} generates pairs of values and this field caches the\n      * second value so that the full algorithm is not executed for every\n      * activation.  The value <code>Double.NaN</code> signals that there is\n      * no cached value.  Use {@link #clear} to clear the cached value.\n      */\n     private double cachedNormalDeviate = Double.NaN;\n-    \n+\n     /**\n      * Construct a RandomGenerator.\n      */\n     public AbstractRandomGenerator() {\n         super();\n-        \n-    }\n-    \n-    /**\n-     * Clears the cache used by the default implementation of \n+\n+    }\n+\n+    /**\n+     * Clears the cache used by the default implementation of\n      * {@link #nextGaussian}. Implemementations that do not override the\n      * default implementation of <code>nextGaussian</code> should call this\n      * method in the implementation of {@link #setSeed(long)}\n     }\n \n     /**\n-     * Sets the seed of the underyling random number generator using a \n+     * Sets the seed of the underyling random number generator using a\n      * <code>long</code> seed.  Sequences of values generated starting with the\n      * same seeds should be identical.\n      * <p>\n-     * Implementations that do not override the default implementation of \n+     * Implementations that do not override the default implementation of\n      * <code>nextGaussian</code> should include a call to {@link #clear} in the\n      * implementation of this method.</p>\n      *\n      * @param seed the seed value\n      */\n-    public abstract void setSeed(long seed);  \n-\n-    /**\n-     * Generates random bytes and places them into a user-supplied \n-     * byte array.  The number of random bytes produced is equal to \n+    public abstract void setSeed(long seed);\n+\n+    /**\n+     * Generates random bytes and places them into a user-supplied\n+     * byte array.  The number of random bytes produced is equal to\n      * the length of the byte array.\n      * <p>\n      * The default implementation fills the array with bytes extracted from\n      * random integers generated using {@link #nextInt}.</p>\n-     * \n-     * @param bytes the non-null byte array in which to put the \n+     *\n+     * @param bytes the non-null byte array in which to put the\n      * random bytes\n      */\n     public void nextBytes(byte[] bytes) {\n \n      /**\n      * Returns the next pseudorandom, uniformly distributed <code>int</code>\n-     * value from this random number generator's sequence.  \n+     * value from this random number generator's sequence.\n      * All 2<font size=\"-1\"><sup>32</sup></font> possible <tt>int</tt> values\n-     * should be produced with  (approximately) equal probability. \n-     * <p>\n-     * The default implementation provided here returns \n+     * should be produced with  (approximately) equal probability.\n+     * <p>\n+     * The default implementation provided here returns\n      * <pre>\n      * <code>(int) (nextDouble() * Integer.MAX_VALUE)</code>\n      * </pre></p>\n     /**\n      * Returns a pseudorandom, uniformly distributed <tt>int</tt> value\n      * between 0 (inclusive) and the specified value (exclusive), drawn from\n-     * this random number generator's sequence. \n-     * <p>  \n-     * The default implementation returns \n+     * this random number generator's sequence.\n+     * <p>\n+     * The default implementation returns\n      * <pre>\n      * <code>(int) (nextDouble() * n</code>\n      * </pre></p>\n \n      /**\n      * Returns the next pseudorandom, uniformly distributed <code>long</code>\n-     * value from this random number generator's sequence.  All \n-     * 2<font size=\"-1\"><sup>64</sup></font> possible <tt>long</tt> values \n-     * should be produced with (approximately) equal probability. \n-     * <p>  \n-     * The default implementation returns \n+     * value from this random number generator's sequence.  All\n+     * 2<font size=\"-1\"><sup>64</sup></font> possible <tt>long</tt> values\n+     * should be produced with (approximately) equal probability.\n+     * <p>\n+     * The default implementation returns\n      * <pre>\n      * <code>(long) (nextDouble() * Long.MAX_VALUE)</code>\n      * </pre></p>\n     /**\n      * Returns the next pseudorandom, uniformly distributed\n      * <code>boolean</code> value from this random number generator's\n-     * sequence.  \n-     * <p>  \n-     * The default implementation returns \n+     * sequence.\n+     * <p>\n+     * The default implementation returns\n      * <pre>\n      * <code>nextDouble() <= 0.5</code>\n      * </pre></p>\n-     * \n+     *\n      * @return  the next pseudorandom, uniformly distributed\n      * <code>boolean</code> value from this random number generator's\n      * sequence\n      /**\n      * Returns the next pseudorandom, uniformly distributed <code>float</code>\n      * value between <code>0.0</code> and <code>1.0</code> from this random\n-     * number generator's sequence.  \n-     * <p>  \n-     * The default implementation returns \n+     * number generator's sequence.\n+     * <p>\n+     * The default implementation returns\n      * <pre>\n      * <code>(float) nextDouble() </code>\n      * </pre></p>\n     }\n \n     /**\n-     * Returns the next pseudorandom, uniformly distributed \n+     * Returns the next pseudorandom, uniformly distributed\n      * <code>double</code> value between <code>0.0</code> and\n-     * <code>1.0</code> from this random number generator's sequence.  \n+     * <code>1.0</code> from this random number generator's sequence.\n      * <p>\n      * This method provides the underlying source of random data used by the\n-     * other methods.</p>   \n-     *\n-     * @return  the next pseudorandom, uniformly distributed \n+     * other methods.</p>\n+     *\n+     * @return  the next pseudorandom, uniformly distributed\n      *  <code>double</code> value between <code>0.0</code> and\n      *  <code>1.0</code> from this random number generator's sequence\n-     */  \n-    public abstract double nextDouble();  \n+     */\n+    public abstract double nextDouble();\n \n     /**\n      * Returns the next pseudorandom, Gaussian (\"normally\") distributed\n      * deviation <code>1.0</code> from this random number generator's sequence.\n      * <p>\n      * The default implementation uses the <em>Polar Method</em>\n-     * due to G.E.P. Box, M.E. Muller and G. Marsaglia, as described in \n+     * due to G.E.P. Box, M.E. Muller and G. Marsaglia, as described in\n      * D. Knuth, <u>The Art of Computer Programming</u>, 3.4.1C.</p>\n      * <p>\n      * The algorithm generates a pair of independent random values.  One of\n      * these is cached for reuse, so the full algorithm is not executed on each\n      * activation.  Implementations that do not override this method should\n-     * make sure to call {@link #clear} to clear the cached value in the \n+     * make sure to call {@link #clear} to clear the cached value in the\n      * implementation of {@link #setSeed(long)}.</p>\n-     * \n+     *\n      * @return  the next pseudorandom, Gaussian (\"normally\") distributed\n      * <code>double</code> value with mean <code>0.0</code> and\n      * standard deviation <code>1.0</code> from this random number\n         double v1 = 0;\n         double v2 = 0;\n         double s = 1;\n-        while (s >=1 ) { \n-            v1 = 2 * nextDouble() - 1; \n-            v2 = 2 * nextDouble() - 1; \n+        while (s >=1 ) {\n+            v1 = 2 * nextDouble() - 1;\n+            v2 = 2 * nextDouble() - 1;\n             s = v1 * v1 + v2 * v2;\n         }\n         if (s != 0) {\n-            s = Math.sqrt(-2 * Math.log(s) / s);   \n+            s = Math.sqrt(-2 * Math.log(s) / s);\n         }\n         cachedNormalDeviate = v2 * s;\n-        return v1 * s;      \n+        return v1 * s;\n     }\n }\n--- a/src/main/java/org/apache/commons/math/random/BitsStreamGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/BitsStreamGenerator.java\n         }\n         int random = next(32);\n         while (i < bytes.length) {\n-            bytes[i++] = (byte) (random & 0xff); \n+            bytes[i++] = (byte) (random & 0xff);\n             random     = random >> 8;\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n import org.apache.commons.math.linear.NotPositiveDefiniteMatrixException;\n import org.apache.commons.math.linear.RealMatrix;\n \n-/** \n- * A {@link RandomVectorGenerator} that generates vectors with with \n+/**\n+ * A {@link RandomVectorGenerator} that generates vectors with with\n  * correlated components.\n  * <p>Random vectors with correlated components are built by combining\n  * the uncorrelated components of another random vector in such a way that\n--- a/src/main/java/org/apache/commons/math/random/EmpiricalDistribution.java\n+++ b/src/main/java/org/apache/commons/math/random/EmpiricalDistribution.java\n  * build grouped frequency histograms representing the input data or to\n  * generate random values \"like\" those in the input file -- i.e., the values\n  * generated will follow the distribution of the values in the file.</p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public interface EmpiricalDistribution {\n     /**\n      * Computes the empirical distribution from the provided\n      * array of numbers.\n-     * \n+     *\n      * @param dataArray the data array\n      */\n     void load(double[] dataArray);\n \n     /**\n      * Computes the empirical distribution from the input file.\n-     * \n+     *\n      * @param file the input file\n      * @throws IOException if an IO error occurs\n      */\n \n     /**\n      * Computes the empirical distribution using data read from a URL.\n-     * \n+     *\n      * @param url url of the input file\n      * @throws IOException if an IO error occurs\n      */\n      * <strong>Preconditions:</strong><ul>\n      * <li>the distribution must be loaded before invoking this method</li></ul>\n      * @return the random value.\n-     * \n+     *\n      * @throws IllegalStateException if the distribution has not been loaded\n      */\n     double getNextValue() throws IllegalStateException;\n \n \n     /**\n-     * Returns a \n-     * {@link org.apache.commons.math.stat.descriptive.StatisticalSummary} \n+     * Returns a\n+     * {@link org.apache.commons.math.stat.descriptive.StatisticalSummary}\n      * describing this distribution.\n      * <strong>Preconditions:</strong><ul>\n      * <li>the distribution must be loaded before invoking this method</li>\n      * </ul>\n-     * \n+     *\n      * @return the sample statistics\n      * @throws IllegalStateException if the distribution has not been loaded\n      */\n \n     /**\n      * Property indicating whether or not the distribution has been loaded.\n-     * \n+     *\n      * @return true if the distribution has been loaded\n      */\n     boolean isLoaded();\n \n      /**\n      * Returns the number of bins.\n-     * \n+     *\n      * @return the number of bins\n      */\n     int getBinCount();\n \n     /**\n-     * Returns a list of \n+     * Returns a list of\n      * {@link org.apache.commons.math.stat.descriptive.SummaryStatistics}\n      * containing statistics describing the values in each of the bins.  The\n      * List is indexed on the bin number.\n-     * \n+     *\n      * @return List of bin statistics\n      */\n     List<SummaryStatistics> getBinStats();\n      * Returns the array of upper bounds for the bins.  Bins are: <br/>\n      * [min,upperBounds[0]],(upperBounds[0],upperBounds[1]],...,\n      *  (upperBounds[binCount-1],max].\n-     * \n+     *\n      * @return array of bin upper bounds\n      */\n     double[] getUpperBounds();\n--- a/src/main/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n \n     /**\n      * Creates a new EmpiricalDistribution  with the specified bin count.\n-     * \n+     *\n      * @param binCount number of bins\n      */\n     public EmpiricalDistributionImpl(int binCount) {\n      /**\n      * Computes the empirical distribution from the provided\n      * array of numbers.\n-     * \n+     *\n      * @param in the input data array\n      */\n     public void load(double[] in) {\n     /**\n      * Computes the empirical distribution using data read from a URL.\n      * @param url  url of the input file\n-     * \n+     *\n      * @throws IOException if an IO error occurs\n      */\n     public void load(URL url) throws IOException {\n \n     /**\n      * Computes the empirical distribution from the input file.\n-     * \n+     *\n      * @param file the input file\n      * @throws IOException if an IO error occurs\n      */\n      * <code>beanStats</code> abstracting the source of data.\n      */\n     private abstract class DataAdapter{\n-        /** \n+        /**\n          * Compute bin stats.\n-         * \n+         *\n          * @param min minimum value\n          * @param delta  grid size\n          * @throws Exception  if an error occurs computing bin stats\n                 throws Exception;\n         /**\n          * Compute sample statistics.\n-         * \n+         *\n          * @throws Exception if an error occurs computing sample stats\n          */\n         public abstract void computeStats() throws Exception;\n     private class DataAdapterFactory{\n         /**\n          * Creates a DataAdapter from a data object\n-         * \n+         *\n          * @param in object providing access to the data\n          * @return DataAdapter instance\n          */\n      * <code>DataAdapter</code> for data provided through some input stream\n      */\n     private class StreamDataAdapter extends DataAdapter{\n-        \n+\n         /** Input stream providng access to the data */\n         private BufferedReader inputStream;\n-        \n+\n         /**\n          * Create a StreamDataAdapter from a BufferedReader\n-         * \n+         *\n          * @param in BufferedReader input stream\n          */\n         public StreamDataAdapter(BufferedReader in){\n         }\n         /**\n          * Computes binStats\n-         * \n+         *\n          * @param min  minimum value\n          * @param delta  grid size\n          * @throws IOException if an IO error occurs\n         }\n         /**\n          * Computes sampleStats\n-         * \n+         *\n          * @throws IOException if an IOError occurs\n          */\n         @Override\n      * <code>DataAdapter</code> for data provided as array of doubles.\n      */\n     private class ArrayDataAdapter extends DataAdapter{\n-        \n+\n         /** Array of input  data values */\n         private double[] inputArray;\n-        \n+\n         /**\n          * Construct an ArrayDataAdapter from a double[] array\n-         * \n+         *\n          * @param in double[] array holding the data\n          */\n         public ArrayDataAdapter(double[] in){\n         }\n         /**\n          * Computes sampleStats\n-         * \n+         *\n          * @throws IOException if an IO error occurs\n          */\n         @Override\n         }\n         /**\n          * Computes binStats\n-         * \n+         *\n          * @param min  minimum value\n          * @param delta  grid size\n          * @throws IOException  if an IO error occurs\n \n     /**\n      * Fills binStats array (second pass through data file).\n-     * \n+     *\n      * @param in object providing access to the data\n      * @throws IOException  if an IO error occurs\n      */\n         }\n         upperBounds[binCount-1] = 1.0d;\n     }\n-    \n+\n     /**\n      * Returns the index of the bin to which the given value belongs\n-     * \n+     *\n      * @param min  the minimum value\n      * @param value  the value whose bin we are trying to find\n      * @param delta  the grid size\n      */\n     private int findBin(double min, double value, double delta) {\n         return Math.min(\n-                Math.max((int) Math.ceil((value- min) / delta) - 1, 0), \n+                Math.max((int) Math.ceil((value- min) / delta) - 1, 0),\n                 binCount - 1);\n         }\n \n     /**\n      * Generates a random value from this distribution.\n-     * \n+     *\n      * @return the random value.\n      * @throws IllegalStateException if the distribution has not been loaded\n      */\n      * Returns a {@link StatisticalSummary} describing this distribution.\n      * <strong>Preconditions:</strong><ul>\n      * <li>the distribution must be loaded before invoking this method</li></ul>\n-     * \n+     *\n      * @return the sample statistics\n      * @throws IllegalStateException if the distribution has not been loaded\n      */\n \n     /**\n      * Returns the number of bins.\n-     * \n+     *\n      * @return the number of bins.\n      */\n     public int getBinCount() {\n      * Returns a List of {@link SummaryStatistics} instances containing\n      * statistics describing the values in each of the bins.  The list is\n      * indexed on the bin number.\n-     * \n+     *\n      * @return List of bin statistics.\n      */\n     public List<SummaryStatistics> getBinStats() {\n        Bins are: <br/>\n      * [min,upperBounds[0]],(upperBounds[0],upperBounds[1]],...,\n      *  (upperBounds[binCount-1],max]\n-     * \n+     *\n      * @return array of bin upper bounds\n      */\n     public double[] getUpperBounds() {\n \n     /**\n      * Property indicating whether or not the distribution has been loaded.\n-     * \n+     *\n      * @return true if the distribution has been loaded\n      */\n     public boolean isLoaded() {\n--- a/src/main/java/org/apache/commons/math/random/GaussianRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/GaussianRandomGenerator.java\n \n package org.apache.commons.math.random;\n \n-/** \n+/**\n  * This class is a gaussian normalized random generator for scalars.\n  * <p>This class is a simple wrapper around the {@link\n  * RandomGenerator#nextGaussian} method.</p>\n--- a/src/main/java/org/apache/commons/math/random/JDKRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/JDKRandomGenerator.java\n import java.util.Random;\n \n /**\n- * Extension of <code>java.util.Random</code> to implement \n+ * Extension of <code>java.util.Random</code> to implement\n  * {@link RandomGenerator}.\n  *\n  * @since 1.1\n--- a/src/main/java/org/apache/commons/math/random/MersenneTwister.java\n+++ b/src/main/java/org/apache/commons/math/random/MersenneTwister.java\n  *   <li>Redistributions in binary form must reproduce the above copyright\n  *       notice, this list of conditions and the following disclaimer in the\n  *       documentation and/or other materials provided with the distribution.</li>\n- *   <li>The names of its contributors may not be used to endorse or promote \n- *       products derived from this software without specific prior written \n+ *   <li>The names of its contributors may not be used to endorse or promote\n+ *       products derived from this software without specific prior written\n  *       permission.</li>\n  * </ol></td></tr>\n \n         for (mti = 1; mti < N; ++mti) {\n             // See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier.\n             // initializer from the 2002-01-09 C version by Makoto Matsumoto\n-            longMT = (1812433253l * (longMT ^ (longMT >> 30)) + mti) & 0xffffffffL; \n+            longMT = (1812433253l * (longMT ^ (longMT >> 30)) + mti) & 0xffffffffL;\n             mt[mti]= (int) longMT;\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/random/NormalizedRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/NormalizedRandomGenerator.java\n \n package org.apache.commons.math.random;\n \n-/** \n+/**\n  * This interface represent a normalized random generator for\n  * scalars.\n  * Normalized generator provide null mean and unit standard deviation scalars.\n--- a/src/main/java/org/apache/commons/math/random/RandomAdaptor.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomAdaptor.java\n \n /**\n  * Extension of <code>java.util.Random</code> wrapping a\n- * {@link RandomGenerator}.   \n+ * {@link RandomGenerator}.\n  *\n  * @since 1.1\n  * @version $Revision$ $Date$\n  */\n public class RandomAdaptor extends Random implements RandomGenerator {\n-    \n+\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = 2306581345647615033L;\n \n     /** Wrapped randomGenerator instance */\n     private RandomGenerator randomGenerator = null;\n \n-    /** \n+    /**\n      * Prevent instantiation without a generator argument\n-     */ \n+     */\n     @SuppressWarnings(\"unused\")\n     private RandomAdaptor() { }\n-    \n+\n     /**\n      * Construct a RandomAdaptor wrapping the supplied RandomGenerator.\n-     * \n+     *\n      * @param randomGenerator  the wrapped generator\n      */\n     public RandomAdaptor(RandomGenerator randomGenerator) {\n         this.randomGenerator = randomGenerator;\n-    } \n-    \n+    }\n+\n     /**\n      * Factory method to create a <code>Random</code> using the supplied\n      * <code>RandomGenerator</code>.\n-     * \n+     *\n      * @param randomGenerator  wrapped RandomGenerator instance\n      * @return a Random instance wrapping the RandomGenerator\n      */\n     public static Random createAdaptor(RandomGenerator randomGenerator) {\n         return new RandomAdaptor(randomGenerator);\n     }\n-    \n+\n     /**\n      * Returns the next pseudorandom, uniformly distributed\n      * <code>boolean</code> value from this random number generator's\n-     * sequence.  \n-     * \n+     * sequence.\n+     *\n      * @return  the next pseudorandom, uniformly distributed\n      * <code>boolean</code> value from this random number generator's\n      * sequence\n     }\n \n      /**\n-     * Generates random bytes and places them into a user-supplied \n-     * byte array.  The number of random bytes produced is equal to \n+     * Generates random bytes and places them into a user-supplied\n+     * byte array.  The number of random bytes produced is equal to\n      * the length of the byte array.\n-     * \n-     * @param bytes the non-null byte array in which to put the \n+     *\n+     * @param bytes the non-null byte array in which to put the\n      * random bytes\n      */\n     @Override\n     }\n \n      /**\n-     * Returns the next pseudorandom, uniformly distributed \n+     * Returns the next pseudorandom, uniformly distributed\n      * <code>double</code> value between <code>0.0</code> and\n-     * <code>1.0</code> from this random number generator's sequence.  \n+     * <code>1.0</code> from this random number generator's sequence.\n      *\n-     * @return  the next pseudorandom, uniformly distributed \n+     * @return  the next pseudorandom, uniformly distributed\n      *  <code>double</code> value between <code>0.0</code> and\n      *  <code>1.0</code> from this random number generator's sequence\n-     */  \n+     */\n     @Override\n     public double nextDouble() {\n         return randomGenerator.nextDouble();\n     /**\n      * Returns the next pseudorandom, uniformly distributed <code>float</code>\n      * value between <code>0.0</code> and <code>1.0</code> from this random\n-     * number generator's sequence.  \n+     * number generator's sequence.\n      *\n      * @return  the next pseudorandom, uniformly distributed <code>float</code>\n      * value between <code>0.0</code> and <code>1.0</code> from this\n      * Returns the next pseudorandom, Gaussian (\"normally\") distributed\n      * <code>double</code> value with mean <code>0.0</code> and standard\n      * deviation <code>1.0</code> from this random number generator's sequence.\n-     * \n+     *\n      * @return  the next pseudorandom, Gaussian (\"normally\") distributed\n      * <code>double</code> value with mean <code>0.0</code> and\n      * standard deviation <code>1.0</code> from this random number\n \n      /**\n      * Returns the next pseudorandom, uniformly distributed <code>int</code>\n-     * value from this random number generator's sequence.  \n+     * value from this random number generator's sequence.\n      * All 2<font size=\"-1\"><sup>32</sup></font> possible <tt>int</tt> values\n-     * should be produced with  (approximately) equal probability. \n+     * should be produced with  (approximately) equal probability.\n      *\n      * @return the next pseudorandom, uniformly distributed <code>int</code>\n      *  value from this random number generator's sequence\n     /**\n      * Returns a pseudorandom, uniformly distributed <tt>int</tt> value\n      * between 0 (inclusive) and the specified value (exclusive), drawn from\n-     * this random number generator's sequence.   \n+     * this random number generator's sequence.\n      *\n      * @param n the bound on the random number to be returned.  Must be\n      * positive.\n \n     /**\n      * Returns the next pseudorandom, uniformly distributed <code>long</code>\n-     * value from this random number generator's sequence.  All \n-     * 2<font size=\"-1\"><sup>64</sup></font> possible <tt>long</tt> values \n-     * should be produced with (approximately) equal probability. \n+     * value from this random number generator's sequence.  All\n+     * 2<font size=\"-1\"><sup>64</sup></font> possible <tt>long</tt> values\n+     * should be produced with (approximately) equal probability.\n      *\n      * @return  the next pseudorandom, uniformly distributed <code>long</code>\n      *value from this random number generator's sequence\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n  * This implementation is not synchronized.\n  * </ul>\n  * </p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class RandomDataImpl implements RandomData, Serializable {\n     /**\n      * Construct a RandomDataImpl using the supplied {@link RandomGenerator} as\n      * the source of (non-secure) random data.\n-     * \n+     *\n      * @param rand\n      *            the source of (non-secure) random data\n      * @since 1.1\n      * Each binary byte is translated into 2 hex digits</li>\n      * </ol>\n      * </p>\n-     * \n+     *\n      * @param len\n      *            the desired string length.\n      * @return the random string.\n     /**\n      * Generate a random int value uniformly distributed between\n      * <code>lower</code> and <code>upper</code>, inclusive.\n-     * \n+     *\n      * @param lower\n      *            the lower bound.\n      * @param upper\n     /**\n      * Generate a random long value uniformly distributed between\n      * <code>lower</code> and <code>upper</code>, inclusive.\n-     * \n+     *\n      * @param lower\n      *            the lower bound.\n      * @param upper\n      * Each byte of the binary digest is converted to 2 hex digits.</li>\n      * </ol>\n      * </p>\n-     * \n+     *\n      * @param len\n      *            the length of the generated string\n      * @return the random string\n      * Generate a random int value uniformly distributed between\n      * <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses\n      * a secure random number generator.\n-     * \n+     *\n      * @param lower\n      *            the lower bound.\n      * @param upper\n      * Generate a random long value uniformly distributed between\n      * <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses\n      * a secure random number generator.\n-     * \n+     *\n      * @param lower\n      *            the lower bound.\n      * @param upper\n      * <p>\n      * The Poisson process (and hence value returned) is bounded by 1000 * mean.\n      * </p>\n-     * \n+     *\n      * <p>\n      * For large means, uses a reject method as described in <a\n      * href=\"http://cg.scs.carleton.ca/~luc/rnbookindex.html\">Non-Uniform Random\n      * Variate Generation</a>\n      * </p>\n-     * \n+     *\n      * <p>\n      * References:\n      * <ul>\n      * New York, NY. Springer-Verlag</li>\n      * </ul>\n      * </p>\n-     * \n+     *\n      * @param mean\n      *            mean of the Poisson distribution.\n      * @return the random Poisson value.\n      * Generate a random value from a Normal (a.k.a. Gaussian) distribution with\n      * the given mean, <code>mu</code> and the given standard deviation,\n      * <code>sigma</code>.\n-     * \n+     *\n      * @param mu\n      *            the mean of the distribution\n      * @param sigma\n      * Method</a> to generate exponentially distributed random values from\n      * uniform deviates.\n      * </p>\n-     * \n+     *\n      * @param mean\n      *            the mean of the distribution\n      * @return the random Exponential value\n      * random double if Random.nextDouble() returns 0). This is necessary to\n      * provide a symmetric output interval (both endpoints excluded).\n      * </p>\n-     * \n+     *\n      * @param lower\n      *            the lower bound.\n      * @param upper\n      * <p>\n      * Creates and initializes a default generator if null.\n      * </p>\n-     * \n+     *\n      * @return the Random used to generate random data\n      * @since 1.1\n      */\n      * <p>\n      * Creates and initializes if null.\n      * </p>\n-     * \n+     *\n      * @return the SecureRandom used to generate secure random data\n      */\n     private SecureRandom getSecRan() {\n      * <p>\n      * Will create and initialize if null.\n      * </p>\n-     * \n+     *\n      * @param seed\n      *            the seed value to use\n      */\n      * <p>\n      * Will create and initialize if null.\n      * </p>\n-     * \n+     *\n      * @param seed\n      *            the seed value to use\n      */\n      * <strong>USAGE NOTE:</strong> This method carries <i>significant</i>\n      * overhead and may take several seconds to execute.\n      * </p>\n-     * \n+     *\n      * @param algorithm\n      *            the name of the PRNG algorithm\n      * @param provider\n      * href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n      * here</a>.\n      * </p>\n-     * \n+     *\n      * @param n\n      *            domain of the permutation (must be positive)\n      * @param k\n      * generate random samples, <a\n      * href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n      * here</a>\n-     * \n+     *\n      * @param c\n      *            Collection to sample from.\n      * @param k\n     /**\n      * Uses a 2-cycle permutation shuffle to randomly re-order the last elements\n      * of list.\n-     * \n+     *\n      * @param list\n      *            list to be shuffled\n      * @param end\n \n     /**\n      * Returns an array representing n.\n-     * \n+     *\n      * @param n\n      *            the natural number to represent\n      * @return array with entries = elements of n\n--- a/src/main/java/org/apache/commons/math/random/RandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomGenerator.java\n \n /**\n  * Interface extracted from <code>java.util.Random</code>.  This interface is\n- * implemented by {@link AbstractRandomGenerator}.  \n+ * implemented by {@link AbstractRandomGenerator}.\n  *\n  * @since 1.1\n  * @version $Revision$ $Date$\n  */\n public interface RandomGenerator {\n-    \n+\n     /**\n      * Sets the seed of the underyling random number generator using an\n      * <code>int</code> seed.\n      * @param seed the seed value\n      */\n     void setSeed(int[] seed);\n-    \n+\n     /**\n      * Sets the seed of the underyling random number generator using a\n      * <code>long</code> seed.\n      * @param seed the seed value\n      */\n     void setSeed(long seed);\n-    \n+\n     /**\n-     * Generates random bytes and places them into a user-supplied \n-     * byte array.  The number of random bytes produced is equal to \n+     * Generates random bytes and places them into a user-supplied\n+     * byte array.  The number of random bytes produced is equal to\n      * the length of the byte array.\n-     * \n-     * @param bytes the non-null byte array in which to put the \n+     *\n+     * @param bytes the non-null byte array in which to put the\n      * random bytes\n      */\n     void nextBytes(byte[] bytes);\n-    \n+\n     /**\n      * Returns the next pseudorandom, uniformly distributed <code>int</code>\n-     * value from this random number generator's sequence.  \n+     * value from this random number generator's sequence.\n      * All 2<font size=\"-1\"><sup>32</sup></font> possible <tt>int</tt> values\n-     * should be produced with  (approximately) equal probability. \n+     * should be produced with  (approximately) equal probability.\n      *\n      * @return the next pseudorandom, uniformly distributed <code>int</code>\n      *  value from this random number generator's sequence\n      */\n     int nextInt();\n-    \n+\n     /**\n      * Returns a pseudorandom, uniformly distributed <tt>int</tt> value\n      * between 0 (inclusive) and the specified value (exclusive), drawn from\n-     * this random number generator's sequence.   \n+     * this random number generator's sequence.\n      *\n      * @param n the bound on the random number to be returned.  Must be\n      * positive.\n      * @throws IllegalArgumentException  if n is not positive.\n      */\n     int nextInt(int n);\n-    \n+\n     /**\n      * Returns the next pseudorandom, uniformly distributed <code>long</code>\n-     * value from this random number generator's sequence.  All \n-     * 2<font size=\"-1\"><sup>64</sup></font> possible <tt>long</tt> values \n-     * should be produced with (approximately) equal probability. \n+     * value from this random number generator's sequence.  All\n+     * 2<font size=\"-1\"><sup>64</sup></font> possible <tt>long</tt> values\n+     * should be produced with (approximately) equal probability.\n      *\n      * @return  the next pseudorandom, uniformly distributed <code>long</code>\n      *value from this random number generator's sequence\n      */\n     long nextLong();\n-    \n+\n     /**\n      * Returns the next pseudorandom, uniformly distributed\n      * <code>boolean</code> value from this random number generator's\n-     * sequence.  \n-     * \n+     * sequence.\n+     *\n      * @return  the next pseudorandom, uniformly distributed\n      * <code>boolean</code> value from this random number generator's\n      * sequence\n      */\n     boolean nextBoolean();\n-    \n+\n     /**\n      * Returns the next pseudorandom, uniformly distributed <code>float</code>\n      * value between <code>0.0</code> and <code>1.0</code> from this random\n-     * number generator's sequence.  \n+     * number generator's sequence.\n      *\n      * @return  the next pseudorandom, uniformly distributed <code>float</code>\n      * value between <code>0.0</code> and <code>1.0</code> from this\n      * random number generator's sequence\n      */\n     float nextFloat();\n-    \n+\n     /**\n-     * Returns the next pseudorandom, uniformly distributed \n+     * Returns the next pseudorandom, uniformly distributed\n      * <code>double</code> value between <code>0.0</code> and\n-     * <code>1.0</code> from this random number generator's sequence.  \n+     * <code>1.0</code> from this random number generator's sequence.\n      *\n-     * @return  the next pseudorandom, uniformly distributed \n+     * @return  the next pseudorandom, uniformly distributed\n      *  <code>double</code> value between <code>0.0</code> and\n      *  <code>1.0</code> from this random number generator's sequence\n-     */  \n+     */\n     double nextDouble();\n-    \n+\n     /**\n      * Returns the next pseudorandom, Gaussian (\"normally\") distributed\n      * <code>double</code> value with mean <code>0.0</code> and standard\n      * deviation <code>1.0</code> from this random number generator's sequence.\n-     * \n+     *\n      * @return  the next pseudorandom, Gaussian (\"normally\") distributed\n      * <code>double</code> value with mean <code>0.0</code> and\n      * standard deviation <code>1.0</code> from this random number\n--- a/src/main/java/org/apache/commons/math/random/RandomVectorGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomVectorGenerator.java\n \n \n /** This interface represents a random generator for whole vectors.\n- * \n+ *\n  * @since 1.2\n  * @version $Revision$ $Date$\n  *\n--- a/src/main/java/org/apache/commons/math/random/UncorrelatedRandomVectorGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/UncorrelatedRandomVectorGenerator.java\n \n import org.apache.commons.math.MathRuntimeException;\n \n-/** \n+/**\n  * A {@link RandomVectorGenerator} that generates vectors with uncorrelated\n  * components. Components of generated vectors follow (independent) Gaussian\n  * distributions, with parameters supplied in the constructor.\n- * \n+ *\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n    */\n   public double[] nextVector() {\n \n-    double[] random = new double[mean.length]; \n+    double[] random = new double[mean.length];\n     for (int i = 0; i < random.length; ++i) {\n       random[i] = mean[i] + standardDeviation[i] * generator.nextNormalizedDouble();\n     }\n--- a/src/main/java/org/apache/commons/math/random/UniformRandomGenerator.java\n+++ b/src/main/java/org/apache/commons/math/random/UniformRandomGenerator.java\n \n package org.apache.commons.math.random;\n \n-/** \n+/**\n  * This class implements a normalized uniform random generator.\n  * <p>Since it is a normalized random generator, it generates values\n- * from a uniform distribution with mean equal to 0 and standard \n+ * from a uniform distribution with mean equal to 0 and standard\n  * deviation equal to 1. Generated values fall in the range\n  * [-&#x0221A;3, +&#x0221A;3].</p>\n- * \n+ *\n  * @since 1.2\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n \n--- a/src/main/java/org/apache/commons/math/random/ValueServer.java\n+++ b/src/main/java/org/apache/commons/math/random/ValueServer.java\n     /**\n      * Construct a ValueServer instance using a RandomData as its source\n      * of random data.\n-     * \n+     *\n      * @param randomData the RandomData instance used to source random data\n      * @since 1.1\n      */\n--- a/src/main/java/org/apache/commons/math/special/Beta.java\n+++ b/src/main/java/org/apache/commons/math/special/Beta.java\n      * Returns the\n      * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n      * regularized beta function</a> I(x, a, b).\n-     * \n+     *\n      * @param x the value.\n      * @param a the a parameter.\n      * @param b the b parameter.\n      * Returns the\n      * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n      * regularized beta function</a> I(x, a, b).\n-     * \n+     *\n      * @param x the value.\n      * @param a the a parameter.\n      * @param b the b parameter.\n \n     /**\n      * Returns the regularized beta function I(x, a, b).\n-     * \n-     * @param x the value.\n-     * @param a the a parameter.\n-     * @param b the b parameter.\n-     * @param maxIterations Maximum number of \"iterations\" to complete. \n+     *\n+     * @param x the value.\n+     * @param a the a parameter.\n+     * @param b the b parameter.\n+     * @param maxIterations Maximum number of \"iterations\" to complete.\n      * @return the regularized beta function I(x, a, b)\n      * @throws MathException if the algorithm fails to converge.\n      */\n     {\n         return regularizedBeta(x, a, b, DEFAULT_EPSILON, maxIterations);\n     }\n-    \n+\n     /**\n      * Returns the regularized beta function I(x, a, b).\n-     * \n+     *\n      * The implementation of this method is based on:\n      * <ul>\n      * <li>\n      * <a href=\"http://functions.wolfram.com/06.21.10.0001.01\">\n      * Regularized Beta Function</a>.</li>\n      * </ul>\n-     * \n+     *\n      * @param x the value.\n      * @param a the a parameter.\n      * @param b the b parameter.\n      * @param epsilon When the absolute value of the nth item in the\n      *                series is less than epsilon the approximation ceases\n      *                to calculate further elements in the series.\n-     * @param maxIterations Maximum number of \"iterations\" to complete. \n+     * @param maxIterations Maximum number of \"iterations\" to complete.\n      * @return the regularized beta function I(x, a, b)\n      * @throws MathException if the algorithm fails to converge.\n      */\n \n     /**\n      * Returns the natural logarithm of the beta function B(a, b).\n-     * \n+     *\n      * @param a the a parameter.\n      * @param b the b parameter.\n      * @return log(B(a, b))\n     public static double logBeta(double a, double b) {\n         return logBeta(a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n     }\n-    \n+\n     /**\n      * Returns the natural logarithm of the beta function B(a, b).\n      *\n      * <li><a href=\"http://mathworld.wolfram.com/BetaFunction.html\">\n      * Beta Function</a>, equation (1).</li>\n      * </ul>\n-     * \n+     *\n      * @param a the a parameter.\n      * @param b the b parameter.\n      * @param epsilon When the absolute value of the nth item in the\n      *                series is less than epsilon the approximation ceases\n      *                to calculate further elements in the series.\n-     * @param maxIterations Maximum number of \"iterations\" to complete. \n+     * @param maxIterations Maximum number of \"iterations\" to complete.\n      * @return log(B(a, b))\n      */\n     public static double logBeta(double a, double b, double epsilon,\n         int maxIterations) {\n-            \n+\n         double ret;\n \n         if (Double.isNaN(a) || Double.isNaN(b) || (a <= 0.0) || (b <= 0.0)) {\n--- a/src/main/java/org/apache/commons/math/special/Erf.java\n+++ b/src/main/java/org/apache/commons/math/special/Erf.java\n \n     /**\n      * Returns the error function erf(x).\n-     * \n+     *\n      * The implementation of this method is based on:\n      * <ul>\n      * <li>\n      * <a href=\"http://mathworld.wolfram.com/Erf.html\">\n      * Erf</a>, equation (3).</li>\n      * </ul>\n-     * \n+     *\n      * @param x the value.\n      * @return the error function erf(x)\n      * @throws MathException if the algorithm fails to converge.\n--- a/src/main/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/main/java/org/apache/commons/math/special/Gamma.java\n  * @version $Revision$ $Date$\n  */\n public class Gamma {\n-    \n-    /** \n+\n+    /**\n      * <a href=\"http://en.wikipedia.org/wiki/Euler-Mascheroni_constant\">Euler-Mascheroni constant</a>\n      * @since 2.0\n      */\n      * the computation of the convergent Lanczos complex Gamma approximation\n      * </a></li>\n      * </ul>\n-     * \n+     *\n      * @param x the value.\n      * @return log(&#915;(x))\n      */\n             ret = Double.NaN;\n         } else {\n             double g = 607.0 / 128.0;\n-            \n+\n             double sum = 0.0;\n             for (int i = LANCZOS.length - 1; i > 0; --i) {\n                 sum = sum + (LANCZOS[i] / (x + i));\n \n     /**\n      * Returns the regularized gamma function P(a, x).\n-     * \n+     *\n      * @param a the a parameter.\n      * @param x the value.\n      * @return the regularized gamma function P(a, x)\n     {\n         return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n     }\n-        \n-        \n+\n+\n     /**\n      * Returns the regularized gamma function P(a, x).\n-     * \n+     *\n      * The implementation of this method is based on:\n      * <ul>\n      * <li>\n      * Confluent Hypergeometric Function of the First Kind</a>, equation (1).\n      * </li>\n      * </ul>\n-     * \n+     *\n      * @param a the a parameter.\n      * @param x the value.\n      * @param epsilon When the absolute value of the nth item in the\n      *                series is less than epsilon the approximation ceases\n      *                to calculate further elements in the series.\n-     * @param maxIterations Maximum number of \"iterations\" to complete. \n+     * @param maxIterations Maximum number of \"iterations\" to complete.\n      * @return the regularized gamma function P(a, x)\n      * @throws MathException if the algorithm fails to converge.\n      */\n-    public static double regularizedGammaP(double a, \n-                                           double x, \n-                                           double epsilon, \n-                                           int maxIterations) \n+    public static double regularizedGammaP(double a,\n+                                           double x,\n+                                           double epsilon,\n+                                           int maxIterations)\n         throws MathException\n     {\n         double ret;\n \n         return ret;\n     }\n-    \n+\n     /**\n      * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).\n-     * \n+     *\n      * @param a the a parameter.\n      * @param x the value.\n      * @return the regularized gamma function Q(a, x)\n     {\n         return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n     }\n-    \n+\n     /**\n      * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).\n-     * \n+     *\n      * The implementation of this method is based on:\n      * <ul>\n      * <li>\n      * <a href=\"    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\">\n      * Regularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)</a></li>\n      * </ul>\n-     * \n+     *\n      * @param a the a parameter.\n      * @param x the value.\n      * @param epsilon When the absolute value of the nth item in the\n      *                series is less than epsilon the approximation ceases\n      *                to calculate further elements in the series.\n-     * @param maxIterations Maximum number of \"iterations\" to complete. \n+     * @param maxIterations Maximum number of \"iterations\" to complete.\n      * @return the regularized gamma function P(a, x)\n      * @throws MathException if the algorithm fails to converge.\n      */\n-    public static double regularizedGammaQ(final double a, \n-                                           double x, \n-                                           double epsilon, \n-                                           int maxIterations) \n+    public static double regularizedGammaQ(final double a,\n+                                           double x,\n+                                           double epsilon,\n+                                           int maxIterations)\n         throws MathException\n     {\n         double ret;\n                     return n * (a - n);\n                 }\n             };\n-            \n+\n             ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);\n             ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n         }\n \n     /**\n      * <p>Computes the digamma function of x.</p>\n-     * \n+     *\n      * <p>This is an independently written implementation of the algorithm described in\n      * Jose Bernardo, Algorithm AS 103: Psi (Digamma) Function, Applied Statistics, 1976.</p>\n-     * \n+     *\n      * <p>Some of the constants have been changed to increase accuracy at the moderate expense\n      * of run-time.  The result should be accurate to within 10^-8 absolute tolerance for\n      * x >= 10^-5 and within 10^-8 relative tolerance for x > 0.</p>\n-     * \n+     *\n      * <p>Performance for large negative values of x will be quite expensive (proportional to\n      * |x|).  Accuracy for negative values of x should be about 10^-8 absolute for results\n      * less than 10^5 and 10^-8 relative for results larger than that.</p>\n-     * \n+     *\n      * @param x  the argument\n      * @return   digamma(x) to within 10-8 relative or absolute error whichever is smaller\n      * @see <a href=\"http://en.wikipedia.org/wiki/Digamma_function\"> Digamma at wikipedia </a>\n     /**\n      * <p>Computes the trigamma function of x.  This function is derived by taking the derivative of\n      * the implementation of digamma.</p>\n-     * \n+     *\n      * @param x  the argument\n      * @return   trigamma(x) to within 10-8 relative or absolute error whichever is smaller\n      * @see <a href=\"http://en.wikipedia.org/wiki/Trigamma_function\"> Trigamma at wikipedia </a>\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n \n import org.apache.commons.math.MathRuntimeException;\n \n-/** \n+/**\n  * Maintains a frequency distribution.\n  * <p>\n- * Accepts int, long, char or Comparable values.  New values added must be \n- * comparable to those that have been added, otherwise the add method will \n+ * Accepts int, long, char or Comparable values.  New values added must be\n+ * comparable to those that have been added, otherwise the add method will\n  * throw an IllegalArgumentException.</p>\n  * <p>\n- * Integer values (int, long, Integer, Long) are not distinguished by type -- \n+ * Integer values (int, long, Integer, Long) are not distinguished by type --\n  * i.e. <code>addValue(Long.valueOf(2)), addValue(2), addValue(2l)</code> all have\n  * the same effect (similarly for arguments to <code>getCount,</code> etc.).</p>\n  * <p>\n  * to combine integral types with chars in a frequency distribution will fail.\n  * </p>\n  * <p>\n- * The values are ordered using the default (natural order), unless a  \n+ * The values are ordered using the default (natural order), unless a\n  * <code>Comparator</code> is supplied in the constructor.</p>\n  *\n  * @version $Revision$ $Date$\n  */\n public class Frequency implements Serializable {\n-    \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -3845586908418844111L;\n \n     public Frequency() {\n         freqTable = new TreeMap<Comparable<?>, Long>();\n     }\n-    \n+\n     /**\n      * Constructor allowing values Comparator to be specified.\n-     * \n+     *\n      * @param comparator Comparator used to order values\n      */\n     @SuppressWarnings(\"unchecked\")\n     /**\n      * Return a string representation of this frequency\n      * distribution.\n-     * \n+     *\n      * @return a string representation.\n      */\n     @Override\n      * If other objects have already been added to this Frequency, v must\n      * be comparable to those that have already been added.\n      * </p>\n-     * \n+     *\n      * @param v the value to add.\n-     * @throws IllegalArgumentException if <code>v</code> is not Comparable, \n+     * @throws IllegalArgumentException if <code>v</code> is not Comparable,\n      *         or is not comparable with previous entries\n      * @deprecated use {@link #addValue(Comparable)} instead\n      */\n     @Deprecated\n     public void addValue(Object v) {\n         if (v instanceof Comparable<?>){\n-            addValue((Comparable<?>) v);            \n+            addValue((Comparable<?>) v);\n         } else {\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"class ({0}) does not implement Comparable\",\n                   v.getClass().getName());\n         }\n     }\n-    \n+\n     /**\n      * Adds 1 to the frequency count for v.\n      * <p>\n      * If other objects have already been added to this Frequency, v must\n      * be comparable to those that have already been added.\n      * </p>\n-     * \n+     *\n      * @param v the value to add.\n      * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n      */\n             } else {\n                 freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n             }\n-        } catch (ClassCastException ex) {   \n+        } catch (ClassCastException ex) {\n             //TreeMap will throw ClassCastException if v is not comparable\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"instance of class {0} not comparable to existing values\",\n \n     /**\n      * Adds 1 to the frequency count for v.\n-     * \n+     *\n      * @param v the value to add.\n      */\n     public void addValue(int v) {\n         addValue(Long.valueOf(v));\n     }\n-    \n+\n     /**\n      * Adds 1 to the frequency count for v.\n-     * \n+     *\n      * @param v the value to add.\n      */\n     public void addValue(Integer v) {\n \n     /**\n      * Adds 1 to the frequency count for v.\n-     * \n+     *\n      * @param v the value to add.\n      */\n     public void addValue(long v) {\n         addValue(Long.valueOf(v));\n     }\n-    \n+\n     /**\n      * Adds 1 to the frequency count for v.\n-     * \n+     *\n      * @param v the value to add.\n      */\n     public void addValue(char v) {\n         addValue(Character.valueOf(v));\n     }\n-    \n+\n     /** Clears the frequency table */\n     public void clear() {\n         freqTable.clear();\n     }\n-    \n+\n     /**\n      * Returns an Iterator over the set of values that have been added.\n      * <p>\n-     * If added values are integral (i.e., integers, longs, Integers, or Longs), \n+     * If added values are integral (i.e., integers, longs, Integers, or Longs),\n      * they are converted to Longs when they are added, so the objects returned\n      * by the Iterator will in this case be Longs.</p>\n-     * \n+     *\n      * @return values Iterator\n      */\n     public Iterator<Comparable<?>> valuesIterator() {\n         return freqTable.keySet().iterator();\n     }\n-    \n+\n     //-------------------------------------------------------------------------\n-    \n+\n     /**\n      * Returns the sum of all frequencies.\n-     * \n+     *\n      * @return the total frequency count.\n      */\n     public long getSumFreq() {\n     /**\n      * Returns the number of values = v.\n      * Returns 0 if the value is not comparable.\n-     * \n+     *\n      * @param v the value to lookup.\n      * @return the frequency of v.\n      * @deprecated replaced by {@link #getCount(Comparable)} as of 2.0\n     /**\n      * Returns the number of values = v.\n      * Returns 0 if the value is not comparable.\n-     * \n+     *\n      * @param v the value to lookup.\n      * @return the frequency of v.\n      */\n             return getCount(((Integer) v).longValue());\n         }\n         long result = 0;\n-        try { \n+        try {\n             Long count =  freqTable.get(v);\n             if (count != null) {\n                 result = count.longValue();\n \n     /**\n      * Returns the number of values = v.\n-     * \n+     *\n      * @param v the value to lookup.\n      * @return the frequency of v.\n      */\n     public long getCount(int v) {\n         return getCount(Long.valueOf(v));\n     }\n-    \n+\n     /**\n      * Returns the number of values = v.\n-     * \n+     *\n      * @param v the value to lookup.\n      * @return the frequency of v.\n      */\n     public long getCount(long v) {\n         return getCount(Long.valueOf(v));\n     }\n-    \n+\n     /**\n      * Returns the number of values = v.\n-     * \n+     *\n      * @param v the value to lookup.\n      * @return the frequency of v.\n      */\n     public long getCount(char v) {\n         return getCount(Character.valueOf(v));\n     }\n-    \n+\n     //-------------------------------------------------------------\n \n     /**\n      * (as a proportion between 0 and 1).\n      * <p>\n      * Returns <code>Double.NaN</code> if no values have been added.</p>\n-     * \n+     *\n      * @param v the value to lookup\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      * (as a proportion between 0 and 1).\n      * <p>\n      * Returns <code>Double.NaN</code> if no values have been added.</p>\n-     * \n+     *\n      * @param v the value to lookup\n      * @return the proportion of values equal to v\n      */\n         if (sumFreq == 0) {\n             return Double.NaN;\n         }\n-        return (double) getCount(v) / (double) sumFreq;        \n-    }\n-    \n+        return (double) getCount(v) / (double) sumFreq;\n+    }\n+\n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n-     * \n+     *\n      * @param v the value to lookup\n      * @return the proportion of values equal to v\n      */\n     public double getPct(int v) {\n-        return getPct(Long.valueOf(v));       \n-    }\n-    \n+        return getPct(Long.valueOf(v));\n+    }\n+\n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n-     * \n+     *\n      * @param v the value to lookup\n      * @return the proportion of values equal to v\n      */\n     public double getPct(long v) {\n-        return getPct(Long.valueOf(v));         \n-    }\n-    \n+        return getPct(Long.valueOf(v));\n+    }\n+\n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).\n-     * \n+     *\n      * @param v the value to lookup\n      * @return the proportion of values equal to v\n      */\n     public double getPct(char v) {\n-        return getPct(Character.valueOf(v));         \n-    }\n-    \n+        return getPct(Character.valueOf(v));\n+    }\n+\n     //-----------------------------------------------------------------------------------------\n-    \n+\n     /**\n      * Returns the cumulative frequency of values less than or equal to v.\n      * <p>\n      * Returns 0 if v is not comparable to the values set.</p>\n-     * \n+     *\n      * @param v the value to lookup.\n      * @return the proportion of values equal to v\n      * @deprecated replaced by {@link #getCumFreq(Comparable)} as of 2.0\n      * Returns the cumulative frequency of values less than or equal to v.\n      * <p>\n      * Returns 0 if v is not comparable to the values set.</p>\n-     * \n+     *\n      * @param v the value to lookup.\n      * @return the proportion of values equal to v\n      */\n             c = new NaturalComparator();\n         }\n         long result = 0;\n-        \n+\n         try {\n             Long value = freqTable.get(v);\n             if (value != null) {\n         if (c.compare(v, freqTable.firstKey()) < 0) {\n             return 0;  // v is comparable, but less than first value\n         }\n-        \n+\n         if (c.compare(v, freqTable.lastKey()) >= 0) {\n             return getSumFreq();    // v is comparable, but greater than the last value\n         }\n-        \n+\n         Iterator<Comparable<?>> values = valuesIterator();\n         while (values.hasNext()) {\n             Comparable<?> nextValue = values.next();\n         }\n         return result;\n     }\n-    \n+\n      /**\n      * Returns the cumulative frequency of values less than or equal to v.\n      * <p>\n      * Returns 0 if v is not comparable to the values set.</p>\n-     * \n+     *\n      * @param v the value to lookup\n      * @return the proportion of values equal to v\n      */\n     public long getCumFreq(int v) {\n-        return getCumFreq(Long.valueOf(v));       \n-    }\n-    \n+        return getCumFreq(Long.valueOf(v));\n+    }\n+\n      /**\n      * Returns the cumulative frequency of values less than or equal to v.\n      * <p>\n      * Returns 0 if v is not comparable to the values set.</p>\n-     * \n+     *\n      * @param v the value to lookup\n      * @return the proportion of values equal to v\n      */\n     public long getCumFreq(long v) {\n-        return getCumFreq(Long.valueOf(v));         \n-    }\n-    \n+        return getCumFreq(Long.valueOf(v));\n+    }\n+\n     /**\n      * Returns the cumulative frequency of values less than or equal to v.\n      * <p>\n      * Returns 0 if v is not comparable to the values set.</p>\n-     * \n+     *\n      * @param v the value to lookup\n      * @return the proportion of values equal to v\n      */\n     public long getCumFreq(char v) {\n-        return getCumFreq(Character.valueOf(v));         \n-    }\n-    \n+        return getCumFreq(Character.valueOf(v));\n+    }\n+\n     //----------------------------------------------------------------------------------------------\n-    \n+\n     /**\n      * Returns the cumulative percentage of values less than or equal to v\n      * (as a proportion between 0 and 1).\n      * Returns <code>Double.NaN</code> if no values have been added.\n      * Returns 0 if at least one value has been added, but v is not comparable\n      * to the values set.</p>\n-     * \n+     *\n      * @param v the value to lookup\n      * @return the proportion of values less than or equal to v\n      * @deprecated replaced by {@link #getCumPct(Comparable)} as of 2.0\n     @Deprecated\n     public double getCumPct(Object v) {\n         return getCumPct((Comparable<?>) v);\n-        \n+\n     }\n \n     /**\n      * Returns <code>Double.NaN</code> if no values have been added.\n      * Returns 0 if at least one value has been added, but v is not comparable\n      * to the values set.</p>\n-     * \n+     *\n      * @param v the value to lookup\n      * @return the proportion of values less than or equal to v\n      */\n         if (sumFreq == 0) {\n             return Double.NaN;\n         }\n-        return (double) getCumFreq(v) / (double) sumFreq;        \n-    }\n-    \n+        return (double) getCumFreq(v) / (double) sumFreq;\n+    }\n+\n     /**\n      * Returns the cumulative percentage of values less than or equal to v\n      * (as a proportion between 0 and 1).\n      * <p>\n      * Returns 0 if v is not comparable to the values set.</p>\n-     * \n+     *\n      * @param v the value to lookup\n      * @return the proportion of values less than or equal to v\n      */\n     public double getCumPct(int v) {\n-        return getCumPct(Long.valueOf(v));       \n-    }\n-    \n+        return getCumPct(Long.valueOf(v));\n+    }\n+\n     /**\n      * Returns the cumulative percentage of values less than or equal to v\n      * (as a proportion between 0 and 1).\n      * <p>\n      * Returns 0 if v is not comparable to the values set.</p>\n-     * \n+     *\n      * @param v the value to lookup\n      * @return the proportion of values less than or equal to v\n      */\n     public double getCumPct(long v) {\n-        return getCumPct(Long.valueOf(v));         \n-    }\n-    \n+        return getCumPct(Long.valueOf(v));\n+    }\n+\n     /**\n      * Returns the cumulative percentage of values less than or equal to v\n      * (as a proportion between 0 and 1).\n      * <p>\n      * Returns 0 if v is not comparable to the values set.</p>\n-     * \n+     *\n      * @param v the value to lookup\n      * @return the proportion of values less than or equal to v\n      */\n     public double getCumPct(char v) {\n-        return getCumPct(Character.valueOf(v));         \n-    }\n-    \n+        return getCumPct(Character.valueOf(v));\n+    }\n+\n     /**\n      * A Comparator that compares comparable objects using the\n      * natural order.  Copied from Commons Collections ComparableComparator.\n          * Compare the two {@link Comparable Comparable} arguments.\n          * This method is equivalent to:\n          * <pre>(({@link Comparable Comparable})o1).{@link Comparable#compareTo compareTo}(o2)</pre>\n-         * \n-         * @param  o1 the first object \n+         *\n+         * @param  o1 the first object\n          * @param  o2 the second object\n          * @return  result of comparison\n-         * @throws NullPointerException when <i>o1</i> is <code>null</code>, \n+         * @throws NullPointerException when <i>o1</i> is <code>null</code>,\n          *         or when <code>((Comparable)o1).compareTo(o2)</code> does\n-         * @throws ClassCastException when <i>o1</i> is not a {@link Comparable Comparable}, \n+         * @throws ClassCastException when <i>o1</i> is not a {@link Comparable Comparable},\n          *         or when <code>((Comparable)o1).compareTo(o2)</code> does\n          */\n         @SuppressWarnings(\"unchecked\")\n--- a/src/main/java/org/apache/commons/math/stat/StatUtils.java\n+++ b/src/main/java/org/apache/commons/math/stat/StatUtils.java\n \n /**\n  * StatUtils provides static methods for computing statistics based on data\n- * stored in double[] arrays. \n- * \n+ * stored in double[] arrays.\n+ *\n  * @version $Revision$ $Date$\n  */\n public final class StatUtils {\n \n     /** percentile */\n     private static final Percentile PERCENTILE = new Percentile();\n-    \n+\n     /** geometric mean */\n     private static final GeometricMean GEOMETRIC_MEAN = new GeometricMean();\n \n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the input array\n      * is null.</p>\n-     * \n+     *\n      * @param values  array of values to sum\n      * @return the sum of the values or <code>Double.NaN</code> if the array\n      * is empty\n      * is empty.\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n-    public static double sum(final double[] values, final int begin, \n+    public static double sum(final double[] values, final int begin,\n             final int length) {\n         return SUM.evaluate(values, begin, length);\n     }\n \n     /**\n-     * Returns the sum of the squares of the entries in the input array, or \n-     * <code>Double.NaN</code> if the array is empty.\n-     * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n-     * \n+     * Returns the sum of the squares of the entries in the input array, or\n+     * <code>Double.NaN</code> if the array is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     *\n      * @param values  input array\n      * @return the sum of the squared values or <code>Double.NaN</code> if the\n      * array is empty\n      * is empty.\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n     }\n \n     /**\n-     * Returns the product of the entries in the input array, or \n-     * <code>Double.NaN</code> if the array is empty.\n-     * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n-     * \n+     * Returns the product of the entries in the input array, or\n+     * <code>Double.NaN</code> if the array is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     *\n      * @param values the input array\n      * @return the product of the values or Double.NaN if the array is empty\n      * @throws IllegalArgumentException if the array is null\n      * is empty.\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n     }\n \n     /**\n-     * Returns the sum of the natural logs of the entries in the input array, or \n+     * Returns the sum of the natural logs of the entries in the input array, or\n      * <code>Double.NaN</code> if the array is empty.\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * See {@link org.apache.commons.math.stat.descriptive.summary.SumOfLogs}.\n      * </p>\n-     * \n-     * @param values the input array\n-     * @return the sum of the natural logs of the values or Double.NaN if \n+     *\n+     * @param values the input array\n+     * @return the sum of the natural logs of the values or Double.NaN if\n      * the array is empty\n      * @throws IllegalArgumentException if the array is null\n      */\n      * <p>\n      * See {@link org.apache.commons.math.stat.descriptive.summary.SumOfLogs}.\n      * </p>\n-     * \n-     * @param values the input array\n-     * @param begin index of the first array element to include\n-     * @param length the number of elements to include\n-     * @return the sum of the natural logs of the values or Double.NaN if \n+     *\n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the sum of the natural logs of the values or Double.NaN if\n      * length = 0\n      * @throws IllegalArgumentException if the array is null or the array index\n      * parameters are not valid\n     }\n \n     /**\n-     * Returns the arithmetic mean of the entries in the input array, or \n+     * Returns the arithmetic mean of the entries in the input array, or\n      * <code>Double.NaN</code> if the array is empty.\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * See {@link org.apache.commons.math.stat.descriptive.moment.Mean} for\n      * details on the computing algorithm.</p>\n-     * \n+     *\n      * @param values the input array\n      * @return the mean of the values or Double.NaN if the array is empty\n      * @throws IllegalArgumentException if the array is null\n      * <p>\n      * See {@link org.apache.commons.math.stat.descriptive.moment.Mean} for\n      * details on the computing algorithm.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n             final int length) {\n         return MEAN.evaluate(values, begin, length);\n     }\n-    \n-    /**\n-     * Returns the geometric mean of the entries in the input array, or \n+\n+    /**\n+     * Returns the geometric mean of the entries in the input array, or\n      * <code>Double.NaN</code> if the array is empty.\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * See {@link org.apache.commons.math.stat.descriptive.moment.GeometricMean}\n      * for details on the computing algorithm.</p>\n-     * \n+     *\n      * @param values the input array\n      * @return the geometric mean of the values or Double.NaN if the array is empty\n      * @throws IllegalArgumentException if the array is null\n      * <p>\n      * See {@link org.apache.commons.math.stat.descriptive.moment.GeometricMean}\n      * for details on the computing algorithm.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n             final int length) {\n         return GEOMETRIC_MEAN.evaluate(values, begin, length);\n     }\n-    \n-\n-    /**\n-     * Returns the variance of the entries in the input array, or \n+\n+\n+    /**\n+     * Returns the variance of the entries in the input array, or\n      * <code>Double.NaN</code> if the array is empty.\n      * <p>\n      * See {@link org.apache.commons.math.stat.descriptive.moment.Variance} for\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n-     * \n+     *\n      * @param values the input array\n      * @return the variance of the values or Double.NaN if the array is empty\n      * @throws IllegalArgumentException if the array is null\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null or the\n      * array index parameters are not valid.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n             final int length) {\n         return VARIANCE.evaluate(values, begin, length);\n     }\n-    \n+\n     /**\n      * Returns the variance of the entries in the specified portion of\n-     * the input array, using the precomputed mean value.  Returns \n+     * the input array, using the precomputed mean value.  Returns\n      * <code>Double.NaN</code> if the designated subarray is empty.\n      * <p>\n      * See {@link org.apache.commons.math.stat.descriptive.moment.Variance} for\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null or the\n      * array index parameters are not valid.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param mean the precomputed mean value\n      * @param begin index of the first array element to include\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n      */\n-    public static double variance(final double[] values, final double mean, \n+    public static double variance(final double[] values, final double mean,\n             final int begin, final int length) {\n-        return VARIANCE.evaluate(values, mean, begin, length);    \n-    }\n-    \n+        return VARIANCE.evaluate(values, mean, begin, length);\n+    }\n+\n     /**\n      * Returns the variance of the entries in the input array, using the\n      * precomputed mean value.  Returns <code>Double.NaN</code> if the array\n-     * is empty.  \n+     * is empty.\n      * <p>\n      * See {@link org.apache.commons.math.stat.descriptive.moment.Variance} for\n-     * details on the computing algorithm.</p>  \n+     * details on the computing algorithm.</p>\n      * <p>\n      * The formula used assumes that the supplied mean value is the arithmetic\n      * mean of the sample data, not a known population parameter.  This method\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param mean the precomputed mean value\n      * @return the variance of the values or Double.NaN if the array is empty\n      * @throws IllegalArgumentException if the array is null\n      */\n     public static double variance(final double[] values, final double mean) {\n-        return VARIANCE.evaluate(values, mean);    \n-    }\n-\n-    /**\n-     * Returns the maximum of the entries in the input array, or \n+        return VARIANCE.evaluate(values, mean);\n+    }\n+\n+    /**\n+     * Returns the maximum of the entries in the input array, or\n      * <code>Double.NaN</code> if the array is empty.\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * <ul>\n-     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n      * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n-     * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>, \n+     * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>,\n      * the result is <code>Double.POSITIVE_INFINITY.</code></li>\n      * </ul></p>\n-     * \n+     *\n      * @param values the input array\n      * @return the maximum of the values or Double.NaN if the array is empty\n      * @throws IllegalArgumentException if the array is null\n      * the array index parameters are not valid.</p>\n      * <p>\n      * <ul>\n-     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n      * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n-     * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>, \n+     * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>,\n      * the result is <code>Double.POSITIVE_INFINITY.</code></li>\n      * </ul></p>\n-     * \n+     *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n     }\n \n      /**\n-     * Returns the minimum of the entries in the input array, or \n+     * Returns the minimum of the entries in the input array, or\n      * <code>Double.NaN</code> if the array is empty.\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * <ul>\n-     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n      * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n-     * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>, \n+     * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>,\n      * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n      * </ul> </p>\n-     * \n+     *\n      * @param values the input array\n      * @return the minimum of the values or Double.NaN if the array is empty\n      * @throws IllegalArgumentException if the array is null\n      * the array index parameters are not valid.</p>\n      * <p>\n      * <ul>\n-     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n      * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n-     * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>, \n+     * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>,\n      * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n      * </ul></p>\n-     * \n+     *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n             final int length) {\n         return MIN.evaluate(values, begin, length);\n     }\n-    \n+\n     /**\n      * Returns an estimate of the <code>p</code>th percentile of the values\n      * in the <code>values</code> array.\n      * <p>\n      * <ul>\n-     * <li>Returns <code>Double.NaN</code> if <code>values</code> has length \n+     * <li>Returns <code>Double.NaN</code> if <code>values</code> has length\n      * <code>0</code></li></p>\n      * <li>Returns (for any value of <code>p</code>) <code>values[0]</code>\n      *  if <code>values</code> has length <code>1</code></li>\n      * <p>\n      * See {@link org.apache.commons.math.stat.descriptive.rank.Percentile} for\n      * a description of the percentile estimation algorithm used.</p>\n-     * \n+     *\n      * @param values input array of values\n      * @param p the percentile value to compute\n      * @return the percentile value or Double.NaN if the array is empty\n-     * @throws IllegalArgumentException if <code>values</code> is null \n+     * @throws IllegalArgumentException if <code>values</code> is null\n      * or p is invalid\n      */\n     public static double percentile(final double[] values, final double p) {\n      * <li>Returns (for any value of <code>p</code>) <code>values[begin]</code>\n      *  if <code>length = 1 </code></li>\n      * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n-     *  is null , <code>begin</code> or <code>length</code> is invalid, or \n+     *  is null , <code>begin</code> or <code>length</code> is invalid, or\n      * <code>p</code> is not a valid quantile value (p must be greater than 0\n      * and less than or equal to 100)</li>\n      * </ul></p>\n      * <p>\n       * See {@link org.apache.commons.math.stat.descriptive.rank.Percentile} for\n       * a description of the percentile estimation algorithm used.</p>\n-     * \n+     *\n      * @param values array of input values\n      * @param p  the percentile to compute\n      * @param begin  the first (0-based) element to include in the computation\n      * @throws IllegalArgumentException if the parameters are not valid or the\n      * input array is null\n      */\n-    public static double percentile(final double[] values, final int begin, \n+    public static double percentile(final double[] values, final int begin,\n             final int length, final double p) {\n         return PERCENTILE.evaluate(values, begin, length, p);\n-    }   \n-    \n+    }\n+\n     /**\n      * Returns the sum of the (signed) differences between corresponding elements of the\n      * input arrays -- i.e., sum(sample1[i] - sample2[i]).\n-     * \n+     *\n      * @param sample1  the first array\n      * @param sample2  the second array\n      * @return sum of paired differences\n         }\n         return result;\n     }\n-    \n+\n     /**\n      * Returns the mean of the (signed) differences between corresponding elements of the\n      * input arrays -- i.e., sum(sample1[i] - sample2[i]) / sample1.length.\n-     * \n+     *\n      * @param sample1  the first array\n      * @param sample2  the second array\n      * @return mean of paired differences\n     throws IllegalArgumentException {\n         return sumDifference(sample1, sample2) / sample1.length;\n     }\n-    \n+\n     /**\n      * Returns the variance of the (signed) differences between corresponding elements of the\n      * input arrays -- i.e., var(sample1[i] - sample2[i]).\n-     * \n+     *\n      * @param sample1  the first array\n      * @param sample2  the second array\n-     * @param meanDifference   the mean difference between corresponding entries \n+     * @param meanDifference   the mean difference between corresponding entries\n      * @see #meanDifference(double[],double[])\n      * @return variance of paired differences\n      * @throws IllegalArgumentException if the arrays do not have the same\n      * length or their common length is less than 2.\n      */\n-    public static double varianceDifference(final double[] sample1, final double[] sample2, \n+    public static double varianceDifference(final double[] sample1, final double[] sample2,\n             double meanDifference)  throws IllegalArgumentException {\n         double sum1 = 0d;\n         double sum2 = 0d;\n             sum2 += diff - meanDifference;\n         }\n         return (sum1 - (sum2 * sum2 / n)) / (n - 1);\n-    }      \n-    \n-}\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math/stat/clustering/Clusterable.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/Clusterable.java\n \n     /**\n      * Returns the distance from the given point.\n-     * \n+     *\n      * @param p the point to compute the distance from\n      * @return the distance from the given point\n      */\n \n     /**\n      * Returns the centroid of the given Collection of points.\n-     * \n+     *\n      * @param p the Collection of points to compute the centroid of\n      * @return the centroid of the given Collection of Points\n      */\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n \n     /**\n      * Runs the K-means++ clustering algorithm.\n-     * \n+     *\n      * @param points the points to cluster\n      * @param k the number of clusters to split the data into\n      * @param maxIterations the maximum number of iterations to run the algorithm\n         assignPointsToClusters(clusters, points);\n \n         // iterate through updating the centers until we're done\n-        final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations; \n+        final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations;\n         for (int count = 0; count < max; count++) {\n             boolean clusteringChanged = false;\n             List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>();\n \n     /**\n      * Adds the given points to the closest {@link Cluster}.\n-     * \n+     *\n      * @param <T> type of the points to cluster\n      * @param clusters the {@link Cluster}s to add the points to\n      * @param points the points to add to the given {@link Cluster}s\n \n     /**\n      * Use K-means++ to choose the initial centers.\n-     * \n+     *\n      * @param <T> type of the points to cluster\n      * @param points the points to choose the initial centers from\n      * @param k the number of centers to choose\n \n         final double[] dx2 = new double[pointSet.size()];\n         while (resultSet.size() < k) {\n-            // For each data point x, compute D(x), the distance between x and \n+            // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n             int sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n \n     /**\n      * Returns the nearest {@link Cluster} to the given point\n-     * \n+     *\n      * @param <T> type of the points to cluster\n      * @param clusters the {@link Cluster}s to search\n      * @param point the point to find the nearest {@link Cluster} for\n--- a/src/main/java/org/apache/commons/math/stat/correlation/Covariance.java\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/Covariance.java\n \n /**\n  * Computes covariances for pairs of arrays or columns of a matrix.\n- * \n- * <p>The constructors that take <code>RealMatrix</code> or \n+ *\n+ * <p>The constructors that take <code>RealMatrix</code> or\n  * <code>double[][]</code> arguments generate covariance matrices.  The\n  * columns of the input matrices are assumed to represent variable values.</p>\n- * \n+ *\n  * <p>The constructor argument <code>biasCorrected</code> determines whether or\n  * not computed covariances are bias-corrected.</p>\n- * \n+ *\n  * <p>Unbiased covariances are given by the formula</p>\n  * <code>cov(X, Y) = &Sigma;[(x<sub>i</sub> - E(X))(y<sub>i</sub> - E(Y))] / (n - 1)</code>\n  * where <code>E(X)</code> is the mean of <code>X</code> and <code>E(Y)</code>\n  * is the mean of the <code>Y</code> values.\n- * \n+ *\n  * <p>Non-bias-corrected estimates use <code>n</code> in place of <code>n - 1</code>\n- * \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public class Covariance {\n-    \n+\n     /** covariance matrix */\n     private final RealMatrix covarianceMatrix;\n \n      */\n     /** Number of observations (length of covariate vectors) */\n     private final int n;\n-    \n-    /** \n+\n+    /**\n      * Create a Covariance with no data\n      */\n     public Covariance() {\n         covarianceMatrix = null;\n         n = 0;\n     }\n-    \n+\n     /**\n      * Create a Covariance matrix from a rectangular array\n      * whose columns represent covariates.\n-     * \n+     *\n      * <p>The <code>biasCorrected</code> parameter determines whether or not\n      * covariance estimates are bias-corrected.</p>\n-     * \n+     *\n      * <p>The input array must be rectangular with at least two columns\n      * and two rows.</p>\n-     * \n+     *\n      * @param data rectangular array with columns representing covariates\n      * @param biasCorrected true means covariances are bias-corrected\n      * @throws IllegalArgumentException if the input data array is not\n     public Covariance(double[][] data, boolean biasCorrected) {\n         this(new BlockRealMatrix(data), biasCorrected);\n     }\n-    \n+\n     /**\n      * Create a Covariance matrix from a rectangular array\n      * whose columns represent covariates.\n-     * \n+     *\n      * <p>The input array must be rectangular with at least two columns\n      * and two rows</p>\n-     * \n+     *\n      * @param data rectangular array with columns representing covariates\n      * @throws IllegalArgumentException if the input data array is not\n      * rectangular with at least two rows and two columns.\n     public Covariance(double[][] data) {\n         this(data, true);\n     }\n-    \n+\n     /**\n      * Create a covariance matrix from a matrix whose columns\n      * represent covariates.\n-     * \n+     *\n      * <p>The <code>biasCorrected</code> parameter determines whether or not\n      * covariance estimates are bias-corrected.</p>\n-     * \n+     *\n      * <p>The matrix must have at least two columns and two rows</p>\n-     * \n+     *\n      * @param matrix matrix with columns representing covariates\n      * @param biasCorrected true means covariances are bias-corrected\n      * @throws IllegalArgumentException if the input matrix does not have\n        n = matrix.getRowDimension();\n        covarianceMatrix = computeCovarianceMatrix(matrix, biasCorrected);\n     }\n-    \n+\n     /**\n      * Create a covariance matrix from a matrix whose columns\n      * represent covariates.\n-     * \n+     *\n      * <p>The matrix must have at least two columns and two rows</p>\n-     * \n+     *\n      * @param matrix matrix with columns representing covariates\n      * @throws IllegalArgumentException if the input matrix does not have\n      * at least two rows and two columns\n     public Covariance(RealMatrix matrix) {\n         this(matrix, true);\n     }\n-    \n+\n     /**\n      * Returns the covariance matrix\n-     * \n+     *\n      * @return covariance matrix\n      */\n     public RealMatrix getCovarianceMatrix() {\n         return covarianceMatrix;\n     }\n-    \n+\n     /**\n      * Returns the number of observations (length of covariate vectors)\n-     * \n+     *\n      * @return number of observations\n      */\n-    \n+\n     public int getN() {\n         return n;\n     }\n-    \n+\n     /**\n      * Compute a covariance matrix from a matrix whose columns represent\n      * covariates.\n         }\n         return outMatrix;\n     }\n-    \n+\n     /**\n      * Create a covariance matrix from a matrix whose columns represent\n      * covariates. Covariances are computed using the bias-corrected formula.\n     protected RealMatrix computeCovarianceMatrix(RealMatrix matrix) {\n         return computeCovarianceMatrix(matrix, true);\n     }\n-    \n+\n     /**\n      * Compute a covariance matrix from a rectangular array whose columns represent\n      * covariates.\n     protected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected) {\n         return computeCovarianceMatrix(new BlockRealMatrix(data), biasCorrected);\n     }\n-    \n+\n     /**\n      * Create a covariance matrix from a rectangual array whose columns represent\n      * covariates. Covariances are computed using the bias-corrected formula.\n     protected RealMatrix computeCovarianceMatrix(double[][] data) {\n         return computeCovarianceMatrix(data, true);\n     }\n-    \n+\n     /**\n      * Computes the covariance between the two arrays.\n-     * \n+     *\n      * <p>Array lengths must match and the common length must be at least 2.</p>\n      *\n      * @param xArray first data array\n      * @param yArray second data array\n-     * @param biasCorrected if true, returned value will be bias-corrected \n-     * @return returns the covariance for the two arrays \n+     * @param biasCorrected if true, returned value will be bias-corrected\n+     * @return returns the covariance for the two arrays\n      * @throws  IllegalArgumentException if the arrays lengths do not match or\n      * there is insufficient data\n      */\n-    public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected) \n+    public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected)\n         throws IllegalArgumentException {\n         Mean mean = new Mean();\n         double result = 0d;\n         }\n         return biasCorrected ? result * ((double) length / (double)(length - 1)) : result;\n     }\n-    \n+\n     /**\n      * Computes the covariance between the two arrays, using the bias-corrected\n      * formula.\n-     * \n+     *\n      * <p>Array lengths must match and the common length must be at least 2.</p>\n      *\n      * @param xArray first data array\n      * @param yArray second data array\n-     * @return returns the covariance for the two arrays \n+     * @return returns the covariance for the two arrays\n      * @throws  IllegalArgumentException if the arrays lengths do not match or\n      * there is insufficient data\n      */\n-    public double covariance(final double[] xArray, final double[] yArray) \n+    public double covariance(final double[] xArray, final double[] yArray)\n         throws IllegalArgumentException {\n         return covariance(xArray, yArray, true);\n     }\n-    \n+\n     /**\n      * Throws IllegalArgumentException of the matrix does not have at least\n      * two columns and two rows\n--- a/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n /**\n  * Computes Pearson's product-moment correlation coefficients for pairs of arrays\n  * or columns of a matrix.\n- * \n- * <p>The constructors that take <code>RealMatrix</code> or \n+ *\n+ * <p>The constructors that take <code>RealMatrix</code> or\n  * <code>double[][]</code> arguments generate correlation matrices.  The\n  * columns of the input matrices are assumed to represent variable values.\n  * Correlations are given by the formula</p>\n  * <code>cor(X, Y) = &Sigma;[(x<sub>i</sub> - E(X))(y<sub>i</sub> - E(Y))] / [(n - 1)s(X)s(Y)]</code>\n  * where <code>E(X)</code> is the mean of <code>X</code>, <code>E(Y)</code>\n  * is the mean of the <code>Y</code> values and s(X), s(Y) are standard deviations.\n- * \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public class PearsonsCorrelation {\n-    \n+\n     /** correlation matrix */\n     private final RealMatrix correlationMatrix;\n-    \n+\n     /** number of observations */\n     private final int nObs;\n-    \n+\n     /**\n      * Create a PearsonsCorrelation instance without data\n      */\n         correlationMatrix = null;\n         nObs = 0;\n     }\n-    \n+\n     /**\n      * Create a PearsonsCorrelation from a rectangular array\n      * whose columns represent values of variables to be correlated.\n-     * \n+     *\n      * @param data rectangular array with columns representing variables\n      * @throws IllegalArgumentException if the input data array is not\n      * rectangular with at least two rows and two columns.\n     public PearsonsCorrelation(double[][] data) {\n         this(new BlockRealMatrix(data));\n     }\n-    \n+\n     /**\n      * Create a PearsonsCorrelation from a RealMatrix whose columns\n      * represent variables to be correlated.\n-     * \n+     *\n      * @param matrix matrix with columns representing variables to correlate\n      */\n     public PearsonsCorrelation(RealMatrix matrix) {\n         nObs = matrix.getRowDimension();\n         correlationMatrix = computeCorrelationMatrix(matrix);\n     }\n-    \n+\n     /**\n      * Create a PearsonsCorrelation from a {@link Covariance}.  The correlation\n      * matrix is computed by scaling the Covariance's covariance matrix.\n      * The Covariance instance must have been created from a data matrix with\n      * columns representing variable values.\n-     * \n+     *\n      * @param covariance Covariance instance\n      */\n     public PearsonsCorrelation(Covariance covariance) {\n         nObs = covariance.getN();\n         correlationMatrix = covarianceToCorrelation(covarianceMatrix);\n     }\n-    \n+\n     /**\n      * Create a PearsonsCorrelation from a covariance matrix.  The correlation\n      * matrix is computed by scaling the covariance matrix.\n-     * \n+     *\n      * @param covarianceMatrix covariance matrix\n      * @param numberOfObservations the number of observations in the dataset used to compute\n      * the covariance matrix\n     public PearsonsCorrelation(RealMatrix covarianceMatrix, int numberOfObservations) {\n         nObs = numberOfObservations;\n         correlationMatrix = covarianceToCorrelation(covarianceMatrix);\n-        \n-    }\n-    \n+\n+    }\n+\n     /**\n      * Returns the correlation matrix\n-     * \n+     *\n      * @return correlation matrix\n      */\n     public RealMatrix getCorrelationMatrix() {\n-        return correlationMatrix;  \n-    }\n-    \n+        return correlationMatrix;\n+    }\n+\n     /**\n      * Returns a matrix of standard errors associated with the estimates\n      * in the correlation matrix.<br/>\n      * error associated with <code>getCorrelationMatrix.getEntry(i,j)</code>\n      * <p>The formula used to compute the standard error is <br/>\n      * <code>SE<sub>r</sub> = ((1 - r<sup>2</sup>) / (n - 2))<sup>1/2</sup></code>\n-     * where <code>r</code> is the estimated correlation coefficient and \n+     * where <code>r</code> is the estimated correlation coefficient and\n      * <code>n</code> is the number of observations in the source dataset.</p>\n-     * \n+     *\n      * @return matrix of correlation standard errors\n      */\n     public RealMatrix getCorrelationStandardErrors() {\n      * that a random variable distributed as <code>t<sub>n-2</sub></code> takes\n      * a value with absolute value greater than or equal to <br>\n      * <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p>\n-     * <p>The values in the matrix are sometimes referred to as the \n+     * <p>The values in the matrix are sometimes referred to as the\n      * <i>significance</i> of the corresponding correlation coefficients.</p>\n-     * \n+     *\n      * @return matrix of p-values\n      * @throws MathException if an error occurs estimating probabilities\n      */\n         }\n         return new BlockRealMatrix(out);\n     }\n-    \n-    \n+\n+\n     /**\n      * Computes the correlation matrix for the columns of the\n      * input matrix.\n-     * \n+     *\n      * @param matrix matrix with columns representing variables to correlate\n      * @return correlation matrix\n      */\n         }\n         return outMatrix;\n     }\n-    \n+\n     /**\n      * Computes the correlation matrix for the columns of the\n      * input rectangular array.  The colums of the array represent values\n      * of variables to be correlated.\n-     * \n+     *\n      * @param data matrix with columns representing variables to correlate\n      * @return correlation matrix\n      */\n     public RealMatrix computeCorrelationMatrix(double[][] data) {\n        return computeCorrelationMatrix(new BlockRealMatrix(data));\n     }\n-    \n+\n     /**\n      * Computes the Pearson's product-moment correlation coefficient between the two arrays.\n-     * \n+     *\n      * </p>Throws IllegalArgumentException if the arrays do not have the same length\n      * or their common length is less than 2</p>\n      *\n      * @param xArray first data array\n      * @param yArray second data array\n-     * @return Returns Pearson's correlation coefficient for the two arrays \n+     * @return Returns Pearson's correlation coefficient for the two arrays\n      * @throws  IllegalArgumentException if the arrays lengths do not match or\n      * there is insufficient data\n      */\n                     xArray.length, yArray.length);\n         }\n     }\n-    \n+\n     /**\n      * Derives a correlation matrix from a covariance matrix.\n-     * \n+     *\n      * <p>Uses the formula <br/>\n-     * <code>r(X,Y) = cov(X,Y)/s(X)s(Y)</code> where \n+     * <code>r(X,Y) = cov(X,Y)/s(X)s(Y)</code> where\n      * <code>r(&middot,&middot;)</code> is the correlation coefficient and\n      * <code>s(&middot;)</code> means standard deviation.</p>\n-     * \n+     *\n      * @param covarianceMatrix the covariance matrix\n      * @return correlation matrix\n      */\n             double sigma = Math.sqrt(covarianceMatrix.getEntry(i, i));\n             outMatrix.setEntry(i, i, 1d);\n             for (int j = 0; j < i; j++) {\n-                double entry = covarianceMatrix.getEntry(i, j) / \n+                double entry = covarianceMatrix.getEntry(i, j) /\n                        (sigma * Math.sqrt(covarianceMatrix.getEntry(j, j)));\n                 outMatrix.setEntry(i, j, entry);\n                 outMatrix.setEntry(j, i, entry);\n         }\n         return outMatrix;\n     }\n-    \n+\n     /**\n      * Throws IllegalArgumentException of the matrix does not have at least\n      * two columns and two rows\n-     * \n+     *\n      * @param matrix matrix to check for sufficiency\n      */\n     private void checkSufficientData(final RealMatrix matrix) {\n--- a/src/main/java/org/apache/commons/math/stat/correlation/SpearmansCorrelation.java\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/SpearmansCorrelation.java\n  * <p>Spearman's rank correlation. This implementation performs a rank\n  * transformation on the input data and then computes {@link PearsonsCorrelation}\n  * on the ranked data.</p>\n- * \n+ *\n  * <p>By default, ranks are computed using {@link NaturalRanking} with default\n  * strategies for handling NaNs and ties in the data (NaNs maximal, ties averaged).\n  * The ranking algorithm can be set using a constructor argument.</p>\n- * \n+ *\n  * @since 2.0\n  * @version $Revision$ $Date$\n  */\n \n-public class SpearmansCorrelation {   \n-   \n+public class SpearmansCorrelation {\n+\n     /** Input data */\n     private final RealMatrix data;\n-    \n+\n     /** Ranking algorithm  */\n     private final RankingAlgorithm rankingAlgorithm;\n-    \n+\n     /** Rank correlation */\n     private final PearsonsCorrelation rankCorrelation;\n-    \n+\n     /**\n      * Create a SpearmansCorrelation with the given input data matrix\n      * and ranking algorithm.\n-     * \n+     *\n      * @param dataMatrix matrix of data with columns representing\n      * variables to correlate\n      * @param rankingAlgorithm ranking algorithm\n-     */    \n+     */\n     public SpearmansCorrelation(final RealMatrix dataMatrix, final RankingAlgorithm rankingAlgorithm) {\n-        this.data = dataMatrix.copy(); \n+        this.data = dataMatrix.copy();\n         this.rankingAlgorithm = rankingAlgorithm;\n         rankTransform(data);\n         rankCorrelation = new PearsonsCorrelation(data);\n     }\n-    \n+\n     /**\n      * Create a SpearmansCorrelation from the given data matrix.\n-     * \n+     *\n      * @param dataMatrix matrix of data with columns representing\n      * variables to correlate\n      */\n     public SpearmansCorrelation(final RealMatrix dataMatrix) {\n         this(dataMatrix, new NaturalRanking());\n     }\n-    \n+\n     /**\n      * Create a SpearmansCorrelation without data.\n      */\n     public SpearmansCorrelation() {\n-        data = null; \n+        data = null;\n         this.rankingAlgorithm = new NaturalRanking();\n         rankCorrelation = null;\n     }\n-    \n+\n     /**\n-     * Calculate the Spearman Rank Correlation Matrix. \n-     * \n+     * Calculate the Spearman Rank Correlation Matrix.\n+     *\n      * @return Spearman Rank Correlation Matrix\n      */\n     public RealMatrix getCorrelationMatrix() {\n         return rankCorrelation.getCorrelationMatrix();\n     }\n-    \n+\n     /**\n      * Returns a {@link PearsonsCorrelation} instance constructed from the\n      * ranked input data. That is,\n      * <code>new SpearmansCorrelation(matrix).getRankCorrelation()</code>\n-     * is equivalent to \n+     * is equivalent to\n      * <code>new PearsonsCorrelation(rankTransform(matrix))</code> where\n      * <code>rankTransform(matrix)</code> is the result of applying the\n      * configured <code>RankingAlgorithm</code> to each of the columns of\n      * <code>matrix.</code>\n-     * \n+     *\n      * @return PearsonsCorrelation among ranked column data\n      */\n     public PearsonsCorrelation getRankCorrelation() {\n         return rankCorrelation;\n     }\n-    \n+\n     /**\n      * Computes the Spearman's rank correlation matrix for the columns of the\n      * input matrix.\n-     * \n+     *\n      * @param matrix matrix with columns representing variables to correlate\n      * @return correlation matrix\n      */\n         rankTransform(matrixCopy);\n         return new PearsonsCorrelation().computeCorrelationMatrix(matrixCopy);\n     }\n-    \n+\n     /**\n      * Computes the Spearman's rank correlation matrix for the columns of the\n      * input rectangular array.  The columns of the array represent values\n      * of variables to be correlated.\n-     * \n+     *\n      * @param matrix matrix with columns representing variables to correlate\n      * @return correlation matrix\n      */\n     public RealMatrix computeCorrelationMatrix(double[][] matrix) {\n        return computeCorrelationMatrix(new BlockRealMatrix(matrix));\n     }\n-    \n+\n     /**\n      * Computes the Spearman's rank correlation coefficient between the two arrays.\n-     * \n+     *\n      * </p>Throws IllegalArgumentException if the arrays do not have the same length\n      * or their common length is less than 2</p>\n      *\n      * @param xArray first data array\n      * @param yArray second data array\n-     * @return Returns Spearman's rank correlation coefficient for the two arrays \n+     * @return Returns Spearman's rank correlation coefficient for the two arrays\n      * @throws  IllegalArgumentException if the arrays lengths do not match or\n      * there is insufficient data\n      */\n                     xArray.length, yArray.length);\n         }\n     }\n-    \n+\n     /**\n      * Applies rank transform to each of the columns of <code>matrix</code>\n      * using the current <code>rankingAlgorithm</code>\n-     * \n+     *\n      * @param matrix matrix to transform\n      */\n     private void rankTransform(RealMatrix matrix) {\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n public abstract class AbstractStorelessUnivariateStatistic\n     extends AbstractUnivariateStatistic\n     implements StorelessUnivariateStatistic {\n-    \n+\n     /**\n-     * This default implementation calls {@link #clear}, then invokes \n-     * {@link #increment} in a loop over the the input array, and then uses \n-     * {@link #getResult} to compute the return value.  \n+     * This default implementation calls {@link #clear}, then invokes\n+     * {@link #increment} in a loop over the the input array, and then uses\n+     * {@link #getResult} to compute the return value.\n      * <p>\n      * Note that this implementation changes the internal state of the\n      * statistic.  Its side effects are the same as invoking {@link #clear} and\n         }\n         return evaluate(values, 0, values.length);\n     }\n-    \n+\n     /**\n-     * This default implementation calls {@link #clear}, then invokes \n-     * {@link #increment} in a loop over the specified portion of the input \n-     * array, and then uses {@link #getResult} to compute the return value.  \n+     * This default implementation calls {@link #clear}, then invokes\n+     * {@link #increment} in a loop over the specified portion of the input\n+     * array, and then uses {@link #getResult} to compute the return value.\n      * <p>\n      * Note that this implementation changes the internal state of the\n      * statistic.  Its side effects are the same as invoking {@link #clear} and\n      * possibly more accurate implementation that works directly with the\n      * input array.</p>\n      * <p>\n-     * If the array is null or the index parameters are not valid, an \n+     * If the array is null or the index parameters are not valid, an\n      * IllegalArgumentException is thrown.</p>\n      * @param values the input array\n      * @param begin the index of the first element to include\n      * {@inheritDoc}\n      */\n     public abstract void increment(final double d);\n-    \n+\n     /**\n      * This default implementation just calls {@link #increment} in a loop over\n-     * the input array.   \n+     * the input array.\n      * <p>\n      * Throws IllegalArgumentException if the input values array is null.</p>\n-     * \n+     *\n      * @param values values to add\n      * @throws IllegalArgumentException if values is null\n      * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#incrementAll(double[])\n             throw MathRuntimeException.createIllegalArgumentException(\"input values array is null\");\n         }\n         incrementAll(values, 0, values.length);\n-    } \n-   \n+    }\n+\n     /**\n      * This default implementation just calls {@link #increment} in a loop over\n      * the specified portion of the input array.\n      * <p>\n      * Throws IllegalArgumentException if the input values array is null.</p>\n-     * \n+     *\n      * @param values  array holding values to add\n      * @param begin   index of the first array element to add\n      * @param length  number of array elements to add\n             int k = begin + length;\n             for (int i = begin; i < k; i++) {\n                 increment(values[i]);\n-            }   \n+            }\n         }\n     }\n-    \n+\n     /**\n-     * Returns true iff <code>object</code> is an \n+     * Returns true iff <code>object</code> is an\n      * <code>AbstractStorelessUnivariateStatistic</code> returning the same\n      * values as this for <code>getResult()</code> and <code>getN()</code>\n      * @param object object to test equality against.\n             return false;\n         }\n         AbstractStorelessUnivariateStatistic stat = (AbstractStorelessUnivariateStatistic) object;\n-        return (MathUtils.equals(stat.getResult(), this.getResult()) && \n+        return (MathUtils.equals(stat.getResult(), this.getResult()) &&\n                 MathUtils.equals(stat.getN(), this.getN()));\n     }\n-    \n+\n     /**\n      * Returns hash code based on getResult() and getN()\n-     * \n+     *\n      * @return hash code\n      */\n     @Override\n         return 31* (31 + MathUtils.hash(getResult())) + MathUtils.hash(getN());\n     }\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n import org.apache.commons.math.MathRuntimeException;\n \n /**\n- * Abstract base class for all implementations of the \n+ * Abstract base class for all implementations of the\n  * {@link UnivariateStatistic} interface.\n  * <p>\n- * Provides a default implementation of <code>evaluate(double[]),</code> \n+ * Provides a default implementation of <code>evaluate(double[]),</code>\n  * delegating to <code>evaluate(double[], int, int)</code> in the natural way.\n  * </p>\n  * <p>\n  * Also includes a <code>test</code> method that performs generic parameter\n  * validation for the <code>evaluate</code> methods.</p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public abstract class AbstractUnivariateStatistic\n                 containsPositiveWeight = true;\n             }\n         }\n-        \n+\n         if (!containsPositiveWeight) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"weight array must contain at least one non-zero value\");\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/AggregateSummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/AggregateSummaryStatistics.java\n  * aggregate statistics directly from a Collection of SummaryStatistics instances.\n  * </p><p>\n  * When {@link #createContributingStatistics()} is used to create SummaryStatistics\n- * instances to be aggregated concurrently, the created instances' \n+ * instances to be aggregated concurrently, the created instances'\n  * {@link SummaryStatistics#addValue(double)} methods must synchronize on the aggregating\n  * instance maintained by this class.  In multithreaded environments, if the functionality\n  * provided by {@link #aggregate(Collection)} is adequate, that method should be used\n  *\n  * @since 2.0\n  * @version $Revision$ $Date$\n- * \n+ *\n  */\n public class AggregateSummaryStatistics implements StatisticalSummary,\n         Serializable {\n \n- \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = -8207112444016386906L;\n \n     /**\n      * A SummaryStatistics serving as a prototype for creating SummaryStatistics\n-     * contributing to this aggregate \n+     * contributing to this aggregate\n      */\n     private final SummaryStatistics statisticsPrototype;\n-    \n+\n     /**\n      * The SummaryStatistics in which aggregate statistics are accumulated.\n      */\n     private final SummaryStatistics statistics;\n-    \n+\n     /**\n      * Initializes a new AggregateSummaryStatistics with default statistics\n      * implementations.\n-     * \n+     *\n      */\n     public AggregateSummaryStatistics() {\n         this(new SummaryStatistics());\n     }\n-    \n+\n     /**\n      * Initializes a new AggregateSummaryStatistics with the specified statistics\n      * object as a prototype for contributing statistics and for the internal\n      *      prototype both for the internal aggregate statistics and for\n      *      contributing statistics obtained via the\n      *      {@code createContributingStatistics()} method.  Being a prototype\n-     *      means that other objects are initialized by copying this object's state. \n+     *      means that other objects are initialized by copying this object's state.\n      *      If {@code null}, a new, default statistics object is used.  Any statistic\n      *      values in the prototype are propagated to contributing statistics\n      *      objects and (once) into these aggregate statistics.\n         this(prototypeStatistics, (prototypeStatistics == null ? null :\n                 new SummaryStatistics(prototypeStatistics)));\n     }\n-    \n+\n     /**\n      * Initializes a new AggregateSummaryStatistics with the specified statistics\n      * object as a prototype for contributing statistics and for the internal\n      *      prototype both for the internal aggregate statistics and for\n      *      contributing statistics obtained via the\n      *      {@code createContributingStatistics()} method.  Being a prototype\n-     *      means that other objects are initialized by copying this object's state. \n+     *      means that other objects are initialized by copying this object's state.\n      *      If {@code null}, a new, default statistics object is used.  Any statistic\n      *      values in the prototype are propagated to contributing statistics\n      *      objects, but not into these aggregate statistics.\n         this.statistics = ((initialStatistics == null) ?\n                 new SummaryStatistics() : initialStatistics);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}.  This version returns the maximum over all the aggregated\n      * data.\n             return statistics.getVariance();\n         }\n     }\n-    \n+\n     /**\n      * Returns the sum of the logs of all the aggregated data.\n-     * \n+     *\n      * @return the sum of logs\n      * @see SummaryStatistics#getSumOfLogs()\n      */\n             return statistics.getSumOfLogs();\n         }\n     }\n-    \n+\n     /**\n      * Returns the geometric mean of all the aggregated data.\n-     * \n+     *\n      * @return the geometric mean\n      * @see SummaryStatistics#getGeometricMean()\n      */\n             return statistics.getGeometricMean();\n         }\n     }\n-    \n+\n     /**\n      * Returns the sum of the squares of all the aggregated data.\n-     * \n+     *\n      * @return The sum of squares\n      * @see SummaryStatistics#getSumsq()\n      */\n             return statistics.getSumsq();\n         }\n     }\n-    \n+\n     /**\n      * Returns a statistic related to the Second Central Moment.  Specifically,\n      * what is returned is the sum of squared deviations from the sample mean\n      * among the all of the aggregated data.\n-     * \n+     *\n      * @return second central moment statistic\n      * @see SummaryStatistics#getSecondMoment()\n      */\n             return statistics.getSecondMoment();\n         }\n     }\n-    \n+\n     /**\n      * Return a {@link StatisticalSummaryValues} instance reporting current\n      * aggregate statistics.\n-     * \n+     *\n      * @return Current values of aggregate statistics\n      */\n     public StatisticalSummary getSummary() {\n         synchronized (statistics) {\n-            return new StatisticalSummaryValues(getMean(), getVariance(), getN(), \n+            return new StatisticalSummaryValues(getMean(), getVariance(), getN(),\n                     getMax(), getMin(), getSum());\n         }\n     }\n \n     /**\n      * Creates and returns a {@code SummaryStatistics} whose data will be\n-     * aggregated with those of this {@code AggregateSummaryStatistics}. \n+     * aggregated with those of this {@code AggregateSummaryStatistics}.\n      *\n      * @return a {@code SummaryStatistics} whose data will be aggregated with\n      *      those of this {@code AggregateSummaryStatistics}.  The initial state\n     public SummaryStatistics createContributingStatistics() {\n         SummaryStatistics contributingStatistics\n                 = new AggregatingSummaryStatistics(statistics);\n-        \n+\n         SummaryStatistics.copy(statisticsPrototype, contributingStatistics);\n-        \n+\n         return contributingStatistics;\n     }\n-    \n+\n     /**\n      * Computes aggregate summary statistics. This method can be used to combine statistics\n      * computed over partitions or subsamples - i.e., the StatisticalSummaryValues returned\n      * <p>\n      * Returns null if the collection is empty or null.\n      * </p>\n-     * \n+     *\n      * @param statistics collection of SummaryStatistics to aggregate\n      * @return summary statistics for the combined dataset\n      */\n             n += curN;\n             final double meanDiff = current.getMean() - mean;\n             mean = sum / n;\n-            m2 = m2 + current.getSecondMoment() + meanDiff * meanDiff * oldN * curN / n; \n+            m2 = m2 + current.getSecondMoment() + meanDiff * meanDiff * oldN * curN / n;\n         }\n         final double variance;\n         if (n == 0) {\n         }\n         return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n     }\n-    \n+\n     /**\n      * A SummaryStatistics that also forwards all values added to it to a second\n      * {@code SummaryStatistics} for aggregation.\n      * @since 2.0\n      */\n     private static class AggregatingSummaryStatistics extends SummaryStatistics {\n-        \n+\n         /**\n          * The serialization version of this class\n          */\n         private static final long serialVersionUID = 1L;\n-        \n+\n         /**\n          * An additional SummaryStatistics into which values added to these\n          * statistics (and possibly others) are aggregated\n          */\n         private final SummaryStatistics aggregateStatistics;\n-        \n+\n         /**\n          * Initializes a new AggregatingSummaryStatistics with the specified\n          * aggregate statistics object\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n /**\n  * Maintains a dataset of values of a single variable and computes descriptive\n  * statistics based on stored data. The {@link #getWindowSize() windowSize}\n- * property sets a limit on the number of values that can be stored in the \n+ * property sets a limit on the number of values that can be stored in the\n  * dataset.  The default value, INFINITE_WINDOW, puts no limit on the size of\n  * the dataset.  This value should be used with caution, as the backing store\n- * will grow without bound in this case.  For very large datasets, \n+ * will grow without bound in this case.  For very large datasets,\n  * {@link SummaryStatistics}, which does not store the dataset, should be used\n  * instead of this class. If <code>windowSize</code> is not INFINITE_WINDOW and\n  * more values are added than can be stored in the dataset, new values are\n- * added in a \"rolling\" manner, with new values replacing the \"oldest\" values \n+ * added in a \"rolling\" manner, with new values replacing the \"oldest\" values\n  * in the dataset.\n- * \n- * <p>Note: this class is not threadsafe.  Use \n+ *\n+ * <p>Note: this class is not threadsafe.  Use\n  * {@link SynchronizedDescriptiveStatistics} if concurrent access from multiple\n  * threads is required.</p>\n  *\n  * @version $Revision$ $Date$\n  */\n public class DescriptiveStatistics implements StatisticalSummary, Serializable {\n-    \n+\n     /** Serialization UID */\n     private static final long serialVersionUID = 4133067267405273064L;\n \n     /** hold the window size **/\n     protected int windowSize = INFINITE_WINDOW;\n-    \n-    /** \n+\n+    /**\n      *  Stored data values\n      */\n     protected ResizableDoubleArray eDA = new ResizableDoubleArray();\n-  \n+\n     /** Mean statistic implementation - can be reset by setter. */\n     private UnivariateStatistic meanImpl = new Mean();\n-    \n+\n     /** Geometric mean statistic implementation - can be reset by setter. */\n     private UnivariateStatistic geometricMeanImpl = new GeometricMean();\n-    \n+\n     /** Kurtosis statistic implementation - can be reset by setter. */\n     private UnivariateStatistic kurtosisImpl = new Kurtosis();\n-    \n+\n     /** Maximum statistic implementation - can be reset by setter. */\n     private UnivariateStatistic maxImpl = new Max();\n-    \n+\n     /** Minimum statistic implementation - can be reset by setter. */\n     private UnivariateStatistic minImpl = new Min();\n-    \n+\n     /** Percentile statistic implementation - can be reset by setter. */\n     private UnivariateStatistic percentileImpl = new Percentile();\n-    \n+\n     /** Skewness statistic implementation - can be reset by setter. */\n     private UnivariateStatistic skewnessImpl = new Skewness();\n-    \n+\n     /** Variance statistic implementation - can be reset by setter. */\n     private UnivariateStatistic varianceImpl = new Variance();\n-    \n+\n     /** Sum of squares statistic implementation - can be reset by setter. */\n     private UnivariateStatistic sumsqImpl = new SumOfSquares();\n-    \n+\n     /** Sum statistic implementation - can be reset by setter. */\n     private UnivariateStatistic sumImpl = new Sum();\n-    \n+\n     /**\n      * Construct a DescriptiveStatistics instance with an infinite window\n      */\n     public DescriptiveStatistics() {\n     }\n-    \n+\n     /**\n      * Construct a DescriptiveStatistics instance with the specified window\n-     * \n+     *\n      * @param window the window size.\n      */\n     public DescriptiveStatistics(int window) {\n         setWindowSize(window);\n     }\n-    \n+\n     /**\n      * Copy constructor.  Construct a new DescriptiveStatistics instance that\n      * is a copy of original.\n-     * \n+     *\n      * @param original DescriptiveStatistics instance to copy\n      */\n     public DescriptiveStatistics(DescriptiveStatistics original) {\n         copy(original, this);\n     }\n-    \n+\n     /**\n      * Represents an infinite window size.  When the {@link #getWindowSize()}\n      * returns this value, there is no limit to the number of data values\n      * (i.e., the number of stored elements equals the currently configured\n      * windowSize), the first (oldest) element in the dataset is discarded\n      * to make room for the new value.\n-     * \n-     * @param v the value to be added \n+     *\n+     * @param v the value to be added\n      */\n     public void addValue(double v) {\n         if (windowSize != INFINITE_WINDOW) {\n     /**\n      * Replaces the most recently stored value with the given value.\n      * There must be at least one element stored to call this method.\n-     * \n+     *\n      * @param v the value to replace the most recent stored value\n      * @return replaced value\n      */\n         return eDA.substituteMostRecentElement(v);\n     }\n \n-    /** \n+    /**\n      * Returns the <a href=\"http://www.xycoon.com/arithmetic_mean.htm\">\n-     * arithmetic mean </a> of the available values \n+     * arithmetic mean </a> of the available values\n      * @return The mean or Double.NaN if no values have been added.\n      */\n     public double getMean() {\n         return apply(meanImpl);\n     }\n \n-    /** \n+    /**\n      * Returns the <a href=\"http://www.xycoon.com/geometric_mean.htm\">\n      * geometric mean </a> of the available values\n-     * @return The geometricMean, Double.NaN if no values have been added, \n+     * @return The geometricMean, Double.NaN if no values have been added,\n      * or if the product of the available values is less than or equal to 0.\n      */\n     public double getGeometricMean() {\n         return apply(geometricMeanImpl);\n     }\n \n-    /** \n+    /**\n      * Returns the variance of the available values.\n-     * @return The variance, Double.NaN if no values have been added \n-     * or 0.0 for a single value set.  \n+     * @return The variance, Double.NaN if no values have been added\n+     * or 0.0 for a single value set.\n      */\n     public double getVariance() {\n         return apply(varianceImpl);\n     }\n \n-    /** \n+    /**\n      * Returns the standard deviation of the available values.\n-     * @return The standard deviation, Double.NaN if no values have been added \n-     * or 0.0 for a single value set. \n+     * @return The standard deviation, Double.NaN if no values have been added\n+     * or 0.0 for a single value set.\n      */\n     public double getStandardDeviation() {\n         double stdDev = Double.NaN;\n     }\n \n     /**\n-     * Returns the skewness of the available values. Skewness is a \n+     * Returns the skewness of the available values. Skewness is a\n      * measure of the asymmetry of a given distribution.\n-     * @return The skewness, Double.NaN if no values have been added \n-     * or 0.0 for a value set &lt;=2. \n+     * @return The skewness, Double.NaN if no values have been added\n+     * or 0.0 for a value set &lt;=2.\n      */\n     public double getSkewness() {\n         return apply(skewnessImpl);\n     }\n \n     /**\n-     * Returns the Kurtosis of the available values. Kurtosis is a \n+     * Returns the Kurtosis of the available values. Kurtosis is a\n      * measure of the \"peakedness\" of a distribution\n-     * @return The kurtosis, Double.NaN if no values have been added, or 0.0 \n-     * for a value set &lt;=3. \n+     * @return The kurtosis, Double.NaN if no values have been added, or 0.0\n+     * for a value set &lt;=3.\n      */\n     public double getKurtosis() {\n         return apply(kurtosisImpl);\n     }\n \n-    /** \n+    /**\n      * Returns the maximum of the available values\n      * @return The max or Double.NaN if no values have been added.\n      */\n         return apply(maxImpl);\n     }\n \n-    /** \n+    /**\n     * Returns the minimum of the available values\n     * @return The min or Double.NaN if no values have been added.\n     */\n         return apply(minImpl);\n     }\n \n-    /** \n+    /**\n      * Returns the number of available values\n      * @return The number of available values\n      */\n \n     /**\n      * Returns the sum of the squares of the available values.\n-     * @return The sum of the squares or Double.NaN if no \n+     * @return The sum of the squares or Double.NaN if no\n      * values have been added.\n      */\n     public double getSumsq() {\n         return apply(sumsqImpl);\n     }\n \n-    /** \n+    /**\n      * Resets all statistics and storage\n      */\n     public void clear() {\n     /**\n      * Returns the maximum number of values that can be stored in the\n      * dataset, or INFINITE_WINDOW (-1) if there is no limit.\n-     * \n+     *\n      * @return The current window size or -1 if its Infinite.\n      */\n     public int getWindowSize() {\n     }\n \n     /**\n-     * WindowSize controls the number of values which contribute \n-     * to the reported statistics.  For example, if \n-     * windowSize is set to 3 and the values {1,2,3,4,5} \n-     * have been added <strong> in that order</strong> \n+     * WindowSize controls the number of values which contribute\n+     * to the reported statistics.  For example, if\n+     * windowSize is set to 3 and the values {1,2,3,4,5}\n+     * have been added <strong> in that order</strong>\n      * then the <i>available values</i> are {3,4,5} and all\n      * reported statistics will be based on these values\n      * @param windowSize sets the size of the window.\n                       \"window size must be positive ({0})\", windowSize);\n             }\n         }\n-        \n+\n         this.windowSize = windowSize;\n \n         // We need to check to see if we need to discard elements\n-        // from the front of the array.  If the windowSize is less than \n+        // from the front of the array.  If the windowSize is less than\n         // the current number of elements.\n         if (windowSize != INFINITE_WINDOW && windowSize < eDA.getNumElements()) {\n             eDA.discardFrontElements(eDA.getNumElements() - windowSize);\n         }\n     }\n-    \n-    /**\n-     * Returns the current set of values in an array of double primitives.  \n+\n+    /**\n+     * Returns the current set of values in an array of double primitives.\n      * The order of addition is preserved.  The returned array is a fresh\n      * copy of the underlying data -- i.e., it is not a reference to the\n      * stored data.\n-     * \n-     * @return returns the current set of numbers in the order in which they \n+     *\n+     * @return returns the current set of numbers in the order in which they\n      *         were added to this set\n      */\n     public double[] getValues() {\n     }\n \n     /**\n-     * Returns the current set of values in an array of double primitives,  \n+     * Returns the current set of values in an array of double primitives,\n      * sorted in ascending order.  The returned array is a fresh\n      * copy of the underlying data -- i.e., it is not a reference to the\n      * stored data.\n-     * @return returns the current set of \n-     * numbers sorted in ascending order        \n+     * @return returns the current set of\n+     * numbers sorted in ascending order\n      */\n     public double[] getSortedValues() {\n         double[] sort = getValues();\n     }\n \n     /**\n-     * Returns an estimate for the pth percentile of the stored values. \n+     * Returns an estimate for the pth percentile of the stored values.\n      * <p>\n      * The implementation provided here follows the first estimation procedure presented\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section2/prc252.htm\">here.</a>\n      * </p><p>\n      * <strong>Preconditions</strong>:<ul>\n-     * <li><code>0 &lt; p &le; 100</code> (otherwise an \n+     * <li><code>0 &lt; p &le; 100</code> (otherwise an\n      * <code>IllegalArgumentException</code> is thrown)</li>\n      * <li>at least one value must be stored (returns <code>Double.NaN\n      *     </code> otherwise)</li>\n      * </ul></p>\n-     * \n+     *\n      * @param p the requested percentile (scaled from 0 - 100)\n-     * @return An estimate for the pth percentile of the stored data \n+     * @return An estimate for the pth percentile of the stored data\n      * @throws IllegalStateException if percentile implementation has been\n      *  overridden and the supplied implementation does not support setQuantile\n      * values\n             ((Percentile) percentileImpl).setQuantile(p);\n         } else {\n             try {\n-                percentileImpl.getClass().getMethod(\"setQuantile\", \n+                percentileImpl.getClass().getMethod(\"setQuantile\",\n                         new Class[] {Double.TYPE}).invoke(percentileImpl,\n                                 new Object[] {Double.valueOf(p)});\n             } catch (NoSuchMethodException e1) { // Setter guard should prevent\n                       \"cannot access setQuantile method in percentile implementation {0}\",\n                       percentileImpl.getClass().getName());\n             } catch (InvocationTargetException e3) {\n-                throw MathRuntimeException.createIllegalArgumentException(e3.getCause()); \n+                throw MathRuntimeException.createIllegalArgumentException(e3.getCause());\n             }\n         }\n         return apply(percentileImpl);\n     }\n-    \n+\n     /**\n      * Generates a text report displaying univariate statistics from values\n      * that have been added.  Each statistic is displayed on a separate\n      * line.\n-     * \n+     *\n      * @return String with line feeds displaying statistics\n      */\n     @Override\n         outBuffer.append(\"kurtosis: \").append(getKurtosis()).append(endl);\n         return outBuffer.toString();\n     }\n-    \n+\n     /**\n      * Apply the given statistic to the data associated with this set of statistics.\n      * @param stat the statistic to apply\n     }\n \n     // Implementation getters and setter\n-    \n+\n     /**\n      * Returns the currently configured mean implementation.\n-     * \n+     *\n      * @return the UnivariateStatistic implementing the mean\n      * @since 1.2\n      */\n \n     /**\n      * <p>Sets the implementation for the mean.</p>\n-     * \n+     *\n      * @param meanImpl the UnivariateStatistic instance to use\n      * for computing the mean\n      * @since 1.2\n \n     /**\n      * Returns the currently configured geometric mean implementation.\n-     * \n+     *\n      * @return the UnivariateStatistic implementing the geometric mean\n      * @since 1.2\n      */\n \n     /**\n      * <p>Sets the implementation for the gemoetric mean.</p>\n-     * \n+     *\n      * @param geometricMeanImpl the UnivariateStatistic instance to use\n      * for computing the geometric mean\n      * @since 1.2\n \n     /**\n      * Returns the currently configured kurtosis implementation.\n-     * \n+     *\n      * @return the UnivariateStatistic implementing the kurtosis\n      * @since 1.2\n      */\n \n     /**\n      * <p>Sets the implementation for the kurtosis.</p>\n-     * \n+     *\n      * @param kurtosisImpl the UnivariateStatistic instance to use\n      * for computing the kurtosis\n      * @since 1.2\n \n     /**\n      * Returns the currently configured maximum implementation.\n-     * \n+     *\n      * @return the UnivariateStatistic implementing the maximum\n      * @since 1.2\n      */\n \n     /**\n      * <p>Sets the implementation for the maximum.</p>\n-     * \n+     *\n      * @param maxImpl the UnivariateStatistic instance to use\n      * for computing the maximum\n      * @since 1.2\n \n     /**\n      * Returns the currently configured minimum implementation.\n-     * \n+     *\n      * @return the UnivariateStatistic implementing the minimum\n      * @since 1.2\n      */\n \n     /**\n      * <p>Sets the implementation for the minimum.</p>\n-     * \n+     *\n      * @param minImpl the UnivariateStatistic instance to use\n      * for computing the minimum\n      * @since 1.2\n \n     /**\n      * Returns the currently configured percentile implementation.\n-     * \n+     *\n      * @return the UnivariateStatistic implementing the percentile\n      * @since 1.2\n      */\n     /**\n      * Sets the implementation to be used by {@link #getPercentile(double)}.\n      * The supplied <code>UnivariateStatistic</code> must provide a\n-     * <code>setQuantile(double)</code> method; otherwise \n+     * <code>setQuantile(double)</code> method; otherwise\n      * <code>IllegalArgumentException</code> is thrown.\n-     * \n+     *\n      * @param percentileImpl the percentileImpl to set\n      * @throws IllegalArgumentException if the supplied implementation does not\n      *  provide a <code>setQuantile</code> method\n     public synchronized void setPercentileImpl(\n             UnivariateStatistic percentileImpl) {\n         try {\n-            percentileImpl.getClass().getMethod(\"setQuantile\", \n+            percentileImpl.getClass().getMethod(\"setQuantile\",\n                     new Class[] {Double.TYPE}).invoke(percentileImpl,\n                             new Object[] {Double.valueOf(50.0d)});\n-        } catch (NoSuchMethodException e1) { \n+        } catch (NoSuchMethodException e1) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"percentile implementation {0} does not support setQuantile\",\n                   percentileImpl.getClass().getName());\n                   \"cannot access setQuantile method in percentile implementation {0}\",\n                   percentileImpl.getClass().getName());\n         } catch (InvocationTargetException e3) {\n-            throw MathRuntimeException.createIllegalArgumentException(e3.getCause()); \n+            throw MathRuntimeException.createIllegalArgumentException(e3.getCause());\n         }\n         this.percentileImpl = percentileImpl;\n     }\n \n     /**\n      * Returns the currently configured skewness implementation.\n-     * \n+     *\n      * @return the UnivariateStatistic implementing the skewness\n      * @since 1.2\n      */\n \n     /**\n      * <p>Sets the implementation for the skewness.</p>\n-     * \n+     *\n      * @param skewnessImpl the UnivariateStatistic instance to use\n      * for computing the skewness\n      * @since 1.2\n \n     /**\n      * Returns the currently configured variance implementation.\n-     * \n+     *\n      * @return the UnivariateStatistic implementing the variance\n      * @since 1.2\n      */\n \n     /**\n      * <p>Sets the implementation for the variance.</p>\n-     * \n+     *\n      * @param varianceImpl the UnivariateStatistic instance to use\n      * for computing the variance\n      * @since 1.2\n \n     /**\n      * Returns the currently configured sum of squares implementation.\n-     * \n+     *\n      * @return the UnivariateStatistic implementing the sum of squares\n      * @since 1.2\n      */\n \n     /**\n      * <p>Sets the implementation for the sum of squares.</p>\n-     * \n+     *\n      * @param sumsqImpl the UnivariateStatistic instance to use\n      * for computing the sum of squares\n      * @since 1.2\n \n     /**\n      * Returns the currently configured sum implementation.\n-     * \n+     *\n      * @return the UnivariateStatistic implementing the sum\n      * @since 1.2\n      */\n \n     /**\n      * <p>Sets the implementation for the sum.</p>\n-     * \n+     *\n      * @param sumImpl the UnivariateStatistic instance to use\n      * for computing the sum\n      * @since 1.2\n      */\n     public synchronized void setSumImpl(UnivariateStatistic sumImpl) {\n         this.sumImpl = sumImpl;\n-    }  \n-    \n+    }\n+\n     /**\n      * Returns a copy of this DescriptiveStatistics instance with the same internal state.\n-     * \n+     *\n      * @return a copy of this\n      */\n     public DescriptiveStatistics copy() {\n         DescriptiveStatistics result = new DescriptiveStatistics();\n         copy(this, result);\n-        return result; \n-    }\n-     \n+        return result;\n+    }\n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n-     * \n+     *\n      * @param source DescriptiveStatistics to copy\n      * @param dest DescriptiveStatistics to copy to\n      * @throws NullPointerException if either source or dest is null\n         // Copy data and window size\n         dest.eDA = source.eDA.copy();\n         dest.windowSize = source.windowSize;\n-        \n+\n         // Copy implementations\n         dest.maxImpl = source.maxImpl.copy();\n         dest.meanImpl = source.meanImpl.copy();\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n import org.apache.commons.math.util.MathUtils;\n \n /**\n- * <p>Computes summary statistics for a stream of n-tuples added using the \n+ * <p>Computes summary statistics for a stream of n-tuples added using the\n  * {@link #addValue(double[]) addValue} method. The data values are not stored\n  * in memory, so this class can be used to compute statistics for very large\n  * n-tuple streams.</p>\n- * \n+ *\n  * <p>The {@link StorelessUnivariateStatistic} instances used to maintain\n  * summary state and compute statistics are configurable via setters.\n  * For example, the default implementation for the mean can be overridden by\n  * calling {@link #setMeanImpl(StorelessUnivariateStatistic[])}. Actual\n- * parameters to these methods must implement the \n+ * parameters to these methods must implement the\n  * {@link StorelessUnivariateStatistic} interface and configuration must be\n  * completed before <code>addValue</code> is called. No configuration is\n  * necessary to use the default, commons-math provided implementations.</p>\n- * \n+ *\n  * <p>To compute statistics for a stream of n-tuples, construct a\n- * MultivariateStatistics instance with dimension n and then use \n+ * MultivariateStatistics instance with dimension n and then use\n  * {@link #addValue(double[])} to add n-tuples. The <code>getXxx</code>\n  * methods where Xxx is a statistic return an array of <code>double</code>\n  * values, where for <code>i = 0,...,n-1</code> the i<sup>th</sup> array element is the\n  * with actual parameters {0, 1, 2}, then {3, 4, 5} and finally {6, 7, 8},\n  * <code>getSum</code> will return a three-element array with values\n  * {0+3+6, 1+4+7, 2+5+8}</p>\n- * \n- * <p>Note: This class is not thread-safe. Use \n+ *\n+ * <p>Note: This class is not thread-safe. Use\n  * {@link SynchronizedMultivariateSummaryStatistics} if concurrent access from multiple\n  * threads is required.</p>\n  *\n \n     /** Count of values that have been added */\n     private long n = 0;\n-    \n+\n     /** Sum statistic implementation - can be reset by setter. */\n     private StorelessUnivariateStatistic[] sumImpl;\n-    \n+\n     /** Sum of squares statistic implementation - can be reset by setter. */\n     private StorelessUnivariateStatistic[] sumSqImpl;\n-    \n+\n     /** Minimum statistic implementation - can be reset by setter. */\n     private StorelessUnivariateStatistic[] minImpl;\n-    \n+\n     /** Maximum statistic implementation - can be reset by setter. */\n     private StorelessUnivariateStatistic[] maxImpl;\n-    \n+\n     /** Sum of log statistic implementation - can be reset by setter. */\n     private StorelessUnivariateStatistic[] sumLogImpl;\n-    \n+\n     /** Geometric mean statistic implementation - can be reset by setter. */\n     private StorelessUnivariateStatistic[] geoMeanImpl;\n-    \n+\n     /** Mean statistic implementation - can be reset by setter. */\n     private StorelessUnivariateStatistic[] meanImpl;\n-    \n+\n     /** Covariance statistic implementation - cannot be reset. */\n     private VectorialCovariance covarianceImpl;\n \n     /**\n      * Add an n-tuple to the data\n-     * \n+     *\n      * @param value  the n-tuple to add\n      * @throws DimensionMismatchException if the length of the array\n      * does not match the one used at construction\n         n++;\n     }\n \n-    /** \n+    /**\n      * Returns the dimension of the data\n      * @return The dimension of the data\n      */\n         return k;\n     }\n \n-    /** \n+    /**\n      * Returns the number of available values\n      * @return The number of available values\n      */\n \n     /**\n      * Returns an array whose i<sup>th</sup> entry is the sum of the\n-     * i<sup>th</sup> entries of the arrays that have been added using \n-     * {@link #addValue(double[])}\n-     * \n+     * i<sup>th</sup> entries of the arrays that have been added using\n+     * {@link #addValue(double[])}\n+     *\n      * @return the array of component sums\n      */\n     public double[] getSum() {\n \n     /**\n      * Returns an array whose i<sup>th</sup> entry is the sum of squares of the\n-     * i<sup>th</sup> entries of the arrays that have been added using \n-     * {@link #addValue(double[])}\n-     * \n+     * i<sup>th</sup> entries of the arrays that have been added using\n+     * {@link #addValue(double[])}\n+     *\n      * @return the array of component sums of squares\n      */\n     public double[] getSumSq() {\n \n     /**\n      * Returns an array whose i<sup>th</sup> entry is the sum of logs of the\n-     * i<sup>th</sup> entries of the arrays that have been added using \n-     * {@link #addValue(double[])}\n-     * \n+     * i<sup>th</sup> entries of the arrays that have been added using\n+     * {@link #addValue(double[])}\n+     *\n      * @return the array of component log sums\n      */\n     public double[] getSumLog() {\n \n     /**\n      * Returns an array whose i<sup>th</sup> entry is the mean of the\n-     * i<sup>th</sup> entries of the arrays that have been added using \n-     * {@link #addValue(double[])}\n-     * \n+     * i<sup>th</sup> entries of the arrays that have been added using\n+     * {@link #addValue(double[])}\n+     *\n      * @return the array of component means\n      */\n     public double[] getMean() {\n \n     /**\n      * Returns an array whose i<sup>th</sup> entry is the standard deviation of the\n-     * i<sup>th</sup> entries of the arrays that have been added using \n-     * {@link #addValue(double[])}\n-     * \n+     * i<sup>th</sup> entries of the arrays that have been added using\n+     * {@link #addValue(double[])}\n+     *\n      * @return the array of component standard deviations\n      */\n     public double[] getStandardDeviation() {\n     /**\n      * Returns the covariance matrix of the values that have been added.\n      *\n-     * @return the covariance matrix \n+     * @return the covariance matrix\n      */\n     public RealMatrix getCovariance() {\n         return covarianceImpl.getResult();\n \n     /**\n      * Returns an array whose i<sup>th</sup> entry is the maximum of the\n-     * i<sup>th</sup> entries of the arrays that have been added using \n-     * {@link #addValue(double[])}\n-     * \n+     * i<sup>th</sup> entries of the arrays that have been added using\n+     * {@link #addValue(double[])}\n+     *\n      * @return the array of component maxima\n      */\n     public double[] getMax() {\n \n     /**\n      * Returns an array whose i<sup>th</sup> entry is the minimum of the\n-     * i<sup>th</sup> entries of the arrays that have been added using \n-     * {@link #addValue(double[])}\n-     * \n+     * i<sup>th</sup> entries of the arrays that have been added using\n+     * {@link #addValue(double[])}\n+     *\n      * @return the array of component minima\n      */\n     public double[] getMin() {\n \n     /**\n      * Returns an array whose i<sup>th</sup> entry is the geometric mean of the\n-     * i<sup>th</sup> entries of the arrays that have been added using \n-     * {@link #addValue(double[])}\n-     * \n+     * i<sup>th</sup> entries of the arrays that have been added using\n+     * {@link #addValue(double[])}\n+     *\n      * @return the array of component geometric means\n      */\n     public double[] getGeometricMean() {\n         return getResults(geoMeanImpl);\n     }\n-    \n+\n     /**\n      * Generates a text report displaying\n      * summary statistics from values that\n         buffer.append(suffix);\n     }\n \n-    /** \n+    /**\n      * Resets all statistics and storage\n      */\n     public void clear() {\n         }\n         covarianceImpl.clear();\n     }\n-    \n+\n     /**\n      * Returns true iff <code>object</code> is a <code>SummaryStatistics</code>\n      * instance and all statistics have the same values as this.\n             return false;\n         }\n         MultivariateSummaryStatistics stat = (MultivariateSummaryStatistics) object;\n-        return (MathUtils.equals(stat.getGeometricMean(), \n+        return (MathUtils.equals(stat.getGeometricMean(),\n                 this.getGeometricMean()) &&\n-                MathUtils.equals(stat.getMax(), this.getMax()) && \n+                MathUtils.equals(stat.getMax(), this.getMax()) &&\n                 MathUtils.equals(stat.getMean(),this.getMean()) &&\n                 MathUtils.equals(stat.getMin(),this.getMin()) &&\n                 MathUtils.equals(stat.getN(), this.getN()) &&\n                 MathUtils.equals(stat.getSumLog(),this.getSumLog()) &&\n                 stat.getCovariance().equals(this.getCovariance()));\n     }\n-    \n+\n     /**\n      * Returns hash code based on values of statistics\n-     * \n+     *\n      * @return hash code\n      */\n     @Override\n \n     /**\n      * Returns the currently configured Sum implementation\n-     * \n+     *\n      * @return the StorelessUnivariateStatistic implementing the sum\n      */\n     public StorelessUnivariateStatistic[] getSumImpl() {\n     /**\n      * <p>Sets the implementation for the Sum.</p>\n      * <p>This method must be activated before any data has been added - i.e.,\n-     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * before {@link #addValue(double[]) addValue} has been used to add data;\n      * otherwise an IllegalStateException will be thrown.</p>\n-     * \n+     *\n      * @param sumImpl the StorelessUnivariateStatistic instance to use\n      * for computing the Sum\n      * @throws DimensionMismatchException if the array dimension\n \n     /**\n      * Returns the currently configured sum of squares implementation\n-     * \n+     *\n      * @return the StorelessUnivariateStatistic implementing the sum of squares\n      */\n     public StorelessUnivariateStatistic[] getSumsqImpl() {\n     /**\n      * <p>Sets the implementation for the sum of squares.</p>\n      * <p>This method must be activated before any data has been added - i.e.,\n-     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * before {@link #addValue(double[]) addValue} has been used to add data;\n      * otherwise an IllegalStateException will be thrown.</p>\n-     * \n+     *\n      * @param sumsqImpl the StorelessUnivariateStatistic instance to use\n      * for computing the sum of squares\n      * @throws DimensionMismatchException if the array dimension\n \n     /**\n      * Returns the currently configured minimum implementation\n-     * \n+     *\n      * @return the StorelessUnivariateStatistic implementing the minimum\n      */\n     public StorelessUnivariateStatistic[] getMinImpl() {\n     /**\n      * <p>Sets the implementation for the minimum.</p>\n      * <p>This method must be activated before any data has been added - i.e.,\n-     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * before {@link #addValue(double[]) addValue} has been used to add data;\n      * otherwise an IllegalStateException will be thrown.</p>\n-     * \n+     *\n      * @param minImpl the StorelessUnivariateStatistic instance to use\n      * for computing the minimum\n      * @throws DimensionMismatchException if the array dimension\n \n     /**\n      * Returns the currently configured maximum implementation\n-     * \n+     *\n      * @return the StorelessUnivariateStatistic implementing the maximum\n      */\n     public StorelessUnivariateStatistic[] getMaxImpl() {\n     /**\n      * <p>Sets the implementation for the maximum.</p>\n      * <p>This method must be activated before any data has been added - i.e.,\n-     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * before {@link #addValue(double[]) addValue} has been used to add data;\n      * otherwise an IllegalStateException will be thrown.</p>\n-     * \n+     *\n      * @param maxImpl the StorelessUnivariateStatistic instance to use\n      * for computing the maximum\n      * @throws DimensionMismatchException if the array dimension\n \n     /**\n      * Returns the currently configured sum of logs implementation\n-     * \n+     *\n      * @return the StorelessUnivariateStatistic implementing the log sum\n      */\n     public StorelessUnivariateStatistic[] getSumLogImpl() {\n     /**\n      * <p>Sets the implementation for the sum of logs.</p>\n      * <p>This method must be activated before any data has been added - i.e.,\n-     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * before {@link #addValue(double[]) addValue} has been used to add data;\n      * otherwise an IllegalStateException will be thrown.</p>\n-     * \n+     *\n      * @param sumLogImpl the StorelessUnivariateStatistic instance to use\n      * for computing the log sum\n      * @throws DimensionMismatchException if the array dimension\n      * does not match the one used at construction\n-     * @throws IllegalStateException if data has already been added \n+     * @throws IllegalStateException if data has already been added\n      *  (i.e if n > 0)\n      */\n     public void setSumLogImpl(StorelessUnivariateStatistic[] sumLogImpl)\n \n     /**\n      * Returns the currently configured geometric mean implementation\n-     * \n+     *\n      * @return the StorelessUnivariateStatistic implementing the geometric mean\n      */\n     public StorelessUnivariateStatistic[] getGeoMeanImpl() {\n     /**\n      * <p>Sets the implementation for the geometric mean.</p>\n      * <p>This method must be activated before any data has been added - i.e.,\n-     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * before {@link #addValue(double[]) addValue} has been used to add data;\n      * otherwise an IllegalStateException will be thrown.</p>\n-     * \n+     *\n      * @param geoMeanImpl the StorelessUnivariateStatistic instance to use\n      * for computing the geometric mean\n      * @throws DimensionMismatchException if the array dimension\n \n     /**\n      * Returns the currently configured mean implementation\n-     * \n+     *\n      * @return the StorelessUnivariateStatistic implementing the mean\n      */\n     public StorelessUnivariateStatistic[] getMeanImpl() {\n     /**\n      * <p>Sets the implementation for the mean.</p>\n      * <p>This method must be activated before any data has been added - i.e.,\n-     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * before {@link #addValue(double[]) addValue} has been used to add data;\n      * otherwise an IllegalStateException will be thrown.</p>\n-     * \n+     *\n      * @param meanImpl the StorelessUnivariateStatistic instance to use\n      * for computing the mean\n      * @throws DimensionMismatchException if the array dimension\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalMultivariateSummary.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalMultivariateSummary.java\n  * @version $Revision$ $Date$\n  */\n public interface StatisticalMultivariateSummary {\n-    /** \n+    /**\n      * Returns the dimension of the data\n      * @return The dimension of the data\n      */\n      * Returns an array whose i<sup>th</sup> entry is the\n      * mean of the i<sup>th</sup> entries of the arrays\n      * that correspond to each multivariate sample\n-     * \n+     *\n      * @return the array of component means\n      */\n     public abstract double[] getMean();\n-    /** \n+    /**\n      * Returns the covariance of the available values.\n      * @return The covariance, null if no multivariate sample\n-     * have been added or a zeroed matrix for a single value set.  \n+     * have been added or a zeroed matrix for a single value set.\n      */\n     public abstract RealMatrix getCovariance();\n     /**\n      * Returns an array whose i<sup>th</sup> entry is the\n      * standard deviation of the i<sup>th</sup> entries of the arrays\n      * that correspond to each multivariate sample\n-     * \n+     *\n      * @return the array of component standard deviations\n      */\n     public abstract double[] getStandardDeviation();\n      * Returns an array whose i<sup>th</sup> entry is the\n      * maximum of the i<sup>th</sup> entries of the arrays\n      * that correspond to each multivariate sample\n-     * \n+     *\n      * @return the array of component maxima\n      */\n     public abstract double[] getMax();\n      * Returns an array whose i<sup>th</sup> entry is the\n      * minimum of the i<sup>th</sup> entries of the arrays\n      * that correspond to each multivariate sample\n-     * \n+     *\n      * @return the array of component minima\n      */\n     public abstract double[] getMin();\n-    /** \n+    /**\n      * Returns the number of available values\n      * @return The number of available values\n      */\n      * Returns an array whose i<sup>th</sup> entry is the\n      * geometric mean of the i<sup>th</sup> entries of the arrays\n      * that correspond to each multivariate sample\n-     * \n+     *\n      * @return the array of component geometric means\n      */\n     public double[] getGeometricMean();\n      * Returns an array whose i<sup>th</sup> entry is the\n      * sum of the i<sup>th</sup> entries of the arrays\n      * that correspond to each multivariate sample\n-     * \n+     *\n      * @return the array of component sums\n      */\n     public abstract double[] getSum();\n      * Returns an array whose i<sup>th</sup> entry is the\n      * sum of squares of the i<sup>th</sup> entries of the arrays\n      * that correspond to each multivariate sample\n-     * \n+     *\n      * @return the array of component sums of squares\n      */\n     public abstract double[] getSumSq();\n      * Returns an array whose i<sup>th</sup> entry is the\n      * sum of logs of the i<sup>th</sup> entries of the arrays\n      * that correspond to each multivariate sample\n-     * \n+     *\n      * @return the array of component log sums\n      */\n     public abstract double[] getSumLog();\n-}\n+}\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalSummary.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalSummary.java\n   * @version $Revision$ $Date$\n  */\n public interface StatisticalSummary {\n-    /** \n+    /**\n      * Returns the <a href=\"http://www.xycoon.com/arithmetic_mean.htm\">\n-     * arithmetic mean </a> of the available values \n+     * arithmetic mean </a> of the available values\n      * @return The mean or Double.NaN if no values have been added.\n      */\n     public abstract double getMean();\n-    /** \n+    /**\n      * Returns the variance of the available values.\n-     * @return The variance, Double.NaN if no values have been added \n-     * or 0.0 for a single value set.  \n+     * @return The variance, Double.NaN if no values have been added\n+     * or 0.0 for a single value set.\n      */\n     public abstract double getVariance();\n-    /** \n+    /**\n      * Returns the standard deviation of the available values.\n-     * @return The standard deviation, Double.NaN if no values have been added \n-     * or 0.0 for a single value set. \n+     * @return The standard deviation, Double.NaN if no values have been added\n+     * or 0.0 for a single value set.\n      */\n     public abstract double getStandardDeviation();\n-    /** \n+    /**\n      * Returns the maximum of the available values\n      * @return The max or Double.NaN if no values have been added.\n      */\n     public abstract double getMax();\n-    /** \n+    /**\n     * Returns the minimum of the available values\n     * @return The min or Double.NaN if no values have been added.\n     */\n     public abstract double getMin();\n-    /** \n+    /**\n      * Returns the number of available values\n      * @return The number of available values\n      */\n      * @return The sum or Double.NaN if no values have been added\n      */\n     public abstract double getSum();\n-}\n+}\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java\n  *\n  * @version $Revision$ $Date$\n  */\n-public class StatisticalSummaryValues implements Serializable, \n+public class StatisticalSummaryValues implements Serializable,\n     StatisticalSummary {\n-   \n+\n     /** Serialization id */\n     private static final long serialVersionUID = -5108854841843722536L;\n \n     /** The sample mean */\n     private final double mean;\n-    \n+\n     /** The sample variance */\n     private final double variance;\n-    \n+\n     /** The number of observations in the sample */\n     private final long n;\n-    \n+\n     /** The maximum value */\n     private final double max;\n-    \n+\n     /** The minimum value */\n     private final double min;\n-    \n+\n     /** The sum of the sample values */\n     private final double sum;\n-    \n+\n     /**\n       * Constructor\n-      * \n+      *\n       * @param mean  the sample mean\n       * @param variance  the sample variance\n-      * @param n  the number of observations in the sample \n+      * @param n  the number of observations in the sample\n       * @param max  the maximum value\n       * @param min  the minimum value\n       * @param sum  the sum of the values\n     public double getSum() {\n         return sum;\n     }\n-    \n+\n     /**\n      * @return Returns the standard deviation\n      */\n     public double getVariance() {\n         return variance;\n     }\n-    \n+\n     /**\n-     * Returns true iff <code>object</code> is a \n+     * Returns true iff <code>object</code> is a\n      * <code>StatisticalSummaryValues</code> instance and all statistics have\n      *  the same values as this.\n-     * \n+     *\n      * @param object the object to test equality against.\n      * @return true if object equals this\n      */\n             return false;\n         }\n         StatisticalSummaryValues stat = (StatisticalSummaryValues) object;\n-        return (MathUtils.equals(stat.getMax(), this.getMax()) && \n+        return (MathUtils.equals(stat.getMax(), this.getMax()) &&\n                 MathUtils.equals(stat.getMean(),this.getMean()) &&\n                 MathUtils.equals(stat.getMin(),this.getMin()) &&\n                 MathUtils.equals(stat.getN(), this.getN()) &&\n                 MathUtils.equals(stat.getSum(), this.getSum()) &&\n                 MathUtils.equals(stat.getVariance(),this.getVariance()));\n     }\n-    \n+\n     /**\n      * Returns hash code based on values of statistics\n-     * \n+     *\n      * @return hash code\n      */\n     @Override\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatistic.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatistic.java\n package org.apache.commons.math.stat.descriptive;\n \n /**\n- * Extends the definition of {@link UnivariateStatistic} with \n+ * Extends the definition of {@link UnivariateStatistic} with\n  * {@link #increment} and {@link #incrementAll(double[])} methods for adding\n- * values and updating internal state.  \n+ * values and updating internal state.\n  * <p>\n  * This interface is designed to be used for calculating statistics that can be\n  * computed in one pass through the data without storing the full array of\n      * @param d  the new value.\n      */\n     void increment(double d);\n-    \n+\n     /**\n      * Updates the internal state of the statistic to reflect addition of\n      * all values in the values array.  Does not clear the statistic first --\n      * i.e., the values are added <strong>incrementally</strong> to the dataset.\n-     * \n+     *\n      * @param values  array holding the new values to add\n      * @throws IllegalArgumentException if the array is null\n      */\n     void incrementAll(double[] values);\n-    \n+\n     /**\n      * Updates the internal state of the statistic to reflect addition of\n      * the values in the designated portion of the values array.  Does not\n-     * clear the statistic first -- i.e., the values are added \n+     * clear the statistic first -- i.e., the values are added\n      * <strong>incrementally</strong> to the dataset.\n-     * \n+     *\n      * @param values  array holding the new values to add\n      * @param start  the array index of the first value to add\n      * @param length  the number of elements to add\n      * Clears the internal state of the Statistic\n      */\n     void clear();\n-    \n+\n     /**\n      * Returns a copy of the statistic with the same internal state.\n-     * \n+     *\n      * @return a copy of the statistic\n      */\n     StorelessUnivariateStatistic copy();\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n \n     /**\n      * A copy constructor. Creates a deep-copy of the {@code original}.\n-     * \n+     *\n      * @param original the {@code SummaryStatistics} instance to copy\n      */\n     public SummaryStatistics(SummaryStatistics original) {\n      * @return Current values of statistics\n      */\n     public StatisticalSummary getSummary() {\n-        return new StatisticalSummaryValues(getMean(), getVariance(), getN(), \n+        return new StatisticalSummaryValues(getMean(), getVariance(), getN(),\n                 getMax(), getMin(), getSum());\n     }\n \n     public double getSumOfLogs() {\n         return sumLogImpl.getResult();\n     }\n-    \n+\n     /**\n      * Returns a statistic related to the Second Central Moment.  Specifically,\n      * what is returned is the sum of squared deviations from the sample mean\n                     n);\n         }\n     }\n-    \n+\n     /**\n      * Returns a copy of this SummaryStatistics instance with the same internal state.\n-     * \n+     *\n      * @return a copy of this\n      */\n     public SummaryStatistics copy() {\n         SummaryStatistics result = new SummaryStatistics();\n         copy(this, result);\n-        return result; \n-    }\n-     \n+        return result;\n+    }\n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n-     * \n+     *\n      * @param source SummaryStatistics to copy\n      * @param dest SummaryStatistics to copy to\n      * @throws NullPointerException if either source or dest is null\n         }\n         SecondMoment.copy(source.secondMoment, dest.secondMoment);\n         dest.n = source.n;\n-        \n+\n         // Make sure that if stat == statImpl in source, same\n         // holds in dest; otherwise copy stat\n         if (source.geoMean == source.geoMeanImpl) {\n             dest.geoMean = (GeometricMean) dest.geoMeanImpl;\n         } else {\n             GeometricMean.copy(source.geoMean, dest.geoMean);\n-        } \n+        }\n         if (source.max == source.maxImpl) {\n             dest.max = (Max) dest.maxImpl;\n         } else {\n             Max.copy(source.max, dest.max);\n-        } \n+        }\n         if (source.mean == source.meanImpl) {\n             dest.mean = (Mean) dest.meanImpl;\n         } else {\n             Mean.copy(source.mean, dest.mean);\n-        } \n+        }\n         if (source.min == source.minImpl) {\n             dest.min = (Min) dest.minImpl;\n         } else {\n             Min.copy(source.min, dest.min);\n-        } \n+        }\n         if (source.sum == source.sumImpl) {\n             dest.sum = (Sum) dest.sumImpl;\n         } else {\n             Sum.copy(source.sum, dest.sum);\n-        } \n+        }\n         if (source.variance == source.varianceImpl) {\n             dest.variance = (Variance) dest.varianceImpl;\n         } else {\n             Variance.copy(source.variance, dest.variance);\n-        } \n+        }\n         if (source.sumLog == source.sumLogImpl) {\n             dest.sumLog = (SumOfLogs) dest.sumLogImpl;\n         } else {\n             SumOfLogs.copy(source.sumLog, dest.sumLog);\n-        } \n+        }\n         if (source.sumsq == source.sumsqImpl) {\n             dest.sumsq = (SumOfSquares) dest.sumsqImpl;\n         } else {\n             SumOfSquares.copy(source.sumsq, dest.sumsq);\n-        } \n+        }\n     }\n }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SynchronizedDescriptiveStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SynchronizedDescriptiveStatistics.java\n  * conditions.  In effect, this implementation makes modification and access\n  * methods atomic operations for a single instance.  That is to say, as one\n  * thread is computing a statistic from the instance, no other thread can modify\n- * the instance nor compute another statistic. \n+ * the instance nor compute another statistic.\n  *\n  * @since 1.2\n  * @version $Revision$ $Date$\n     public SynchronizedDescriptiveStatistics(int window) {\n         super(window);\n     }\n-    \n+\n     /**\n      * A copy constructor. Creates a deep-copy of the {@code original}.\n-     * \n+     *\n      * @param original the {@code SynchronizedDescriptiveStatistics} instance to copy\n      */\n     public SynchronizedDescriptiveStatistics(SynchronizedDescriptiveStatistics original) {\n         return super.getN();\n     }\n \n-    /** \n+    /**\n      * {@inheritDoc}\n      */\n     @Override\n     public synchronized String toString() {\n         return super.toString();\n     }\n-    \n+\n     /**\n      * Returns a copy of this SynchronizedDescriptiveStatistics instance with the\n      * same internal state.\n-     * \n+     *\n      * @return a copy of this\n      */\n     @Override\n     public synchronized SynchronizedDescriptiveStatistics copy() {\n-        SynchronizedDescriptiveStatistics result = \n+        SynchronizedDescriptiveStatistics result =\n             new SynchronizedDescriptiveStatistics();\n         copy(this, result);\n-        return result; \n+        return result;\n     }\n-     \n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n      * <p>Acquires synchronization lock on source, then dest before copying.</p>\n-     * \n+     *\n      * @param source SynchronizedDescriptiveStatistics to copy\n      * @param dest SynchronizedDescriptiveStatistics to copy to\n      * @throws NullPointerException if either source or dest is null\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SynchronizedMultivariateSummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SynchronizedMultivariateSummaryStatistics.java\n     public synchronized double[] getGeometricMean() {\n         return super.getGeometricMean();\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public synchronized void clear() {\n         super.clear();\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public synchronized boolean equals(Object object) {\n         return super.equals(object);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/SynchronizedSummaryStatistics.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SynchronizedSummaryStatistics.java\n  * conditions.  In effect, this implementation makes modification and access\n  * methods atomic operations for a single instance.  That is to say, as one\n  * thread is computing a statistic from the instance, no other thread can modify\n- * the instance nor compute another statistic. \n+ * the instance nor compute another statistic.\n  *\n  * @since 1.2\n  * @version $Revision$ $Date$\n     public SynchronizedSummaryStatistics() {\n         super();\n     }\n-    \n+\n     /**\n      * A copy constructor. Creates a deep-copy of the {@code original}.\n-     * \n+     *\n      * @param original the {@code SynchronizedSummaryStatistics} instance to copy\n      */\n     public SynchronizedSummaryStatistics(SynchronizedSummaryStatistics original) {\n         super.addValue(value);\n     }\n \n-    /** \n+    /**\n      * {@inheritDoc}\n      */\n     @Override\n         return super.toString();\n     }\n \n-    /** \n+    /**\n      * {@inheritDoc}\n      */\n     @Override\n     public synchronized void setVarianceImpl(StorelessUnivariateStatistic varianceImpl) {\n         super.setVarianceImpl(varianceImpl);\n     }\n-    \n+\n     /**\n      * Returns a copy of this SynchronizedSummaryStatistics instance with the\n      * same internal state.\n-     * \n+     *\n      * @return a copy of this\n      */\n     @Override\n     public synchronized SynchronizedSummaryStatistics copy() {\n-        SynchronizedSummaryStatistics result = \n+        SynchronizedSummaryStatistics result =\n             new SynchronizedSummaryStatistics();\n         copy(this, result);\n-        return result; \n-    }\n-     \n+        return result;\n+    }\n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n      * <p>Acquires synchronization lock on source, then dest before copying.</p>\n-     * \n+     *\n      * @param source SynchronizedSummaryStatistics to copy\n      * @param dest SynchronizedSummaryStatistics to copy to\n      * @throws NullPointerException if either source or dest is null\n             }\n         }\n     }\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/UnivariateStatistic.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/UnivariateStatistic.java\n \n /**\n  * Base interface implemented by all statistics.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public interface UnivariateStatistic {\n \n     /**\n      * Returns the result of evaluating the statistic over the input array.\n-     * \n+     *\n      * @param values input array\n      * @return the value of the statistic applied to the input array\n      */\n     /**\n      * Returns the result of evaluating the statistic over the specified entries\n      * in the input array.\n-     * \n+     *\n      * @param values the input array\n      * @param begin the index of the first element to include\n      * @param length the number of elements to include\n      * @return the value of the statistic applied to the included array entries\n      */\n     double evaluate(double[] values, int begin, int length);\n-    \n+\n     /**\n      * Returns a copy of the statistic with the same internal state.\n-     * \n+     *\n      * @return a copy of the statistic\n      */\n     UnivariateStatistic copy();\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/FirstMoment.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/FirstMoment.java\n  * <p>\n  *  Returns <code>Double.NaN</code> if the dataset is empty.</p>\n  * <p>\n- * <strong>Note that this implementation is not synchronized.</strong> If \n+ * <strong>Note that this implementation is not synchronized.</strong> If\n  * multiple threads access an instance of this class concurrently, and at least\n- * one of the threads invokes the <code>increment()</code> or \n+ * one of the threads invokes the <code>increment()</code> or\n  * <code>clear()</code> method, it must be synchronized externally.</p>\n  *\n  * @version $Revision$ $Date$\n  */\n-public class FirstMoment extends AbstractStorelessUnivariateStatistic \n+public class FirstMoment extends AbstractStorelessUnivariateStatistic\n     implements Serializable {\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = 6112755307178490473L;\n \n-    \n+\n     /** Count of values that have been added */\n     protected long n;\n \n     /** First moment of values that have been added */\n     protected double m1;\n-    \n-    /** \n+\n+    /**\n      * Deviation of most recently added value from previous first moment.\n      * Retained to prevent repeated computation in higher order moments.\n      */\n     protected double dev;\n-    \n+\n     /**\n      * Deviation of most recently added value from previous first moment,\n      * normalized by previous sample size.  Retained to prevent repeated\n         dev = Double.NaN;\n         nDev = Double.NaN;\n     }\n-    \n+\n     /**\n      * Copy constructor, creates a new {@code FirstMoment} identical\n      * to the {@code original}\n-     * \n+     *\n      * @param original the {@code FirstMoment} instance to copy\n      */\n      public FirstMoment(FirstMoment original) {\n          super();\n          copy(original, this);\n      }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public long getN() {\n         return n;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public FirstMoment copy() {\n         FirstMoment result = new FirstMoment();\n         copy(this, result);\n-        return result; \n+        return result;\n     }\n-     \n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n-     * \n+     *\n      * @param source FirstMoment to copy\n      * @param dest FirstMoment to copy to\n      * @throws NullPointerException if either source or dest is null\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/FourthMoment.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/FourthMoment.java\n \n /**\n  * Computes a statistic related to the Fourth Central Moment.  Specifically,\n- * what is computed is the sum of \n+ * what is computed is the sum of\n  * <p>\n  * (x_i - xbar) ^ 4, </p>\n  * <p>\n- * where the x_i are the \n+ * where the x_i are the\n  * sample observations and xbar is the sample mean. </p>\n  * <p>\n  * The following recursive updating formula is used: </p>\n  * Returns <code>Double.NaN</code> if no data values have been added and\n  * returns <code>0</code> if there is just one value in the data set. </p>\n  * <p>\n- * <strong>Note that this implementation is not synchronized.</strong> If \n+ * <strong>Note that this implementation is not synchronized.</strong> If\n  * multiple threads access an instance of this class concurrently, and at least\n- * one of the threads invokes the <code>increment()</code> or \n+ * one of the threads invokes the <code>increment()</code> or\n  * <code>clear()</code> method, it must be synchronized externally. </p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class FourthMoment extends ThirdMoment implements Serializable{\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = 4763990447117157611L;\n-        \n+\n     /** fourth moment of values that have been added */\n     protected double m4;\n \n         super();\n         m4 = Double.NaN;\n     }\n-    \n+\n     /**\n      * Copy constructor, creates a new {@code FourthMoment} identical\n      * to the {@code original}\n-     * \n+     *\n      * @param original the {@code FourthMoment} instance to copy\n      */\n      public FourthMoment(FourthMoment original) {\n          super();\n          copy(original, this);\n      }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n \n         double prevM3 = m3;\n         double prevM2 = m2;\n-        \n+\n         super.increment(d);\n-        \n+\n         double n0 = n;\n \n         m4 = m4 - 4.0 * nDev * prevM3 + 6.0 * nDevSq * prevM2 +\n         super.clear();\n         m4 = Double.NaN;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         copy(this, result);\n         return result;\n     }\n-    \n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n-     * \n+     *\n      * @param source FourthMoment to copy\n      * @param dest FourthMoment to copy to\n      * @throws NullPointerException if either source or dest is null\n     public static void copy(FourthMoment source, FourthMoment dest) {\n         ThirdMoment.copy(source, dest);\n         dest.m4 = source.m4;\n-    }  \n+    }\n }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n  * <code> exp( 1/n  (sum of logs) ).</code>  Therefore, </p>\n  * <ul>\n  * <li>If any of values are < 0, the result is <code>NaN.</code></li>\n- * <li>If all values are non-negative and less than \n- * <code>Double.POSITIVE_INFINITY</code>,  but at least one value is 0, the \n+ * <li>If all values are non-negative and less than\n+ * <code>Double.POSITIVE_INFINITY</code>,  but at least one value is 0, the\n  * result is <code>0.</code></li>\n- * <li>If both <code>Double.POSITIVE_INFINITY</code> and \n+ * <li>If both <code>Double.POSITIVE_INFINITY</code> and\n  * <code>Double.NEGATIVE_INFINITY</code> are among the values, the result is\n  * <code>NaN.</code></li>\n  * </ul> </p>\n  * <p>\n- * <strong>Note that this implementation is not synchronized.</strong> If \n+ * <strong>Note that this implementation is not synchronized.</strong> If\n  * multiple threads access an instance of this class concurrently, and at least\n- * one of the threads invokes the <code>increment()</code> or \n+ * one of the threads invokes the <code>increment()</code> or\n  * <code>clear()</code> method, it must be synchronized externally.</p>\n- * \n+ *\n  *\n  * @version $Revision$ $Date$\n  */\n public class GeometricMean extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -8178734905303459453L;  \n-    \n+    private static final long serialVersionUID = -8178734905303459453L;\n+\n     /** Wrapped SumOfLogs instance */\n     private StorelessUnivariateStatistic sumOfLogs;\n \n     public GeometricMean() {\n         sumOfLogs = new SumOfLogs();\n     }\n-    \n+\n     /**\n      * Copy constructor, creates a new {@code GeometricMean} identical\n      * to the {@code original}\n-     * \n+     *\n      * @param original the {@code GeometricMean} instance to copy\n      */\n     public GeometricMean(GeometricMean original) {\n         super();\n         copy(original, this);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         copy(this, result);\n         return result;\n     }\n-    \n+\n     /**\n      * Create a GeometricMean instance using the given SumOfLogs instance\n      * @param sumOfLogs sum of logs instance to use for computation\n     public GeometricMean(SumOfLogs sumOfLogs) {\n         this.sumOfLogs = sumOfLogs;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n      * See {@link GeometricMean} for details on the computing algorithm.</p>\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n-     * \n+     *\n      * @param values input array containing the values\n      * @param begin first array element to include\n      * @param length the number of elements to include\n         return Math.exp(\n             sumOfLogs.evaluate(values, begin, length) / length);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public long getN() {\n         return sumOfLogs.getN();\n     }\n-    \n+\n     /**\n      * <p>Sets the implementation for the sum of logs.</p>\n      * <p>This method must be activated before any data has been added - i.e.,\n-     * before {@link #increment(double) increment} has been used to add data; \n+     * before {@link #increment(double) increment} has been used to add data;\n      * otherwise an IllegalStateException will be thrown.</p>\n-     * \n+     *\n      * @param sumLogImpl the StorelessUnivariateStatistic instance to use\n      * for computing the log sum\n-     * @throws IllegalStateException if data has already been added \n+     * @throws IllegalStateException if data has already been added\n      *  (i.e if n > 0)\n      */\n     public void setSumLogImpl(\n         checkEmpty();\n         this.sumOfLogs = sumLogImpl;\n     }\n-    \n+\n     /**\n      * Returns the currently configured sum of logs implementation\n-     * \n+     *\n      * @return the StorelessUnivariateStatistic implementing the log sum\n      */\n     public StorelessUnivariateStatistic getSumLogImpl() {\n         return sumOfLogs;\n     }\n-    \n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n-     * \n+     *\n      * @param source GeometricMean to copy\n      * @param dest GeometricMean to copy to\n      * @throws NullPointerException if either source or dest is null\n     public static void copy(GeometricMean source, GeometricMean dest) {\n         dest.sumOfLogs = source.sumOfLogs.copy();\n     }\n-    \n-    \n+\n+\n     /**\n      * Throws IllegalStateException if n > 0.\n      */\n         }\n     }\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n  *  Note that this statistic is undefined for n < 4.  <code>Double.Nan</code>\n  *  is returned when there is not sufficient data to compute the statistic.</p>\n  * <p>\n- * <strong>Note that this implementation is not synchronized.</strong> If \n+ * <strong>Note that this implementation is not synchronized.</strong> If\n  * multiple threads access an instance of this class concurrently, and at least\n- * one of the threads invokes the <code>increment()</code> or \n+ * one of the threads invokes the <code>increment()</code> or\n  * <code>clear()</code> method, it must be synchronized externally.</p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class Kurtosis extends AbstractStorelessUnivariateStatistic  implements Serializable {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 2784465764798260919L;  \n-      \n+    private static final long serialVersionUID = 2784465764798260919L;\n+\n     /**Fourth Moment on which this statistic is based */\n     protected FourthMoment moment;\n \n-    /** \n+    /**\n      * Determines whether or not this statistic can be incremented or cleared.\n      * <p>\n      * Statistics based on (constructed from) external moments cannot\n \n     /**\n      * Construct a Kurtosis from an external moment\n-     * \n+     *\n      * @param m4 external Moment\n      */\n     public Kurtosis(final FourthMoment m4) {\n         incMoment = false;\n         this.moment = m4;\n     }\n-    \n+\n     /**\n      * Copy constructor, creates a new {@code Kurtosis} identical\n      * to the {@code original}\n-     * \n+     *\n      * @param original the {@code Kurtosis} instance to copy\n      */\n     public Kurtosis(Kurtosis original) {\n     public long getN() {\n         return moment.getN();\n     }\n-    \n+\n     /* UnvariateStatistic Approach  */\n \n     /**\n      * Returns the kurtosis of the entries in the specified portion of the\n-     * input array.  \n+     * input array.\n      * <p>\n      * See {@link Kurtosis} for details on the computing algorithm.</p>\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n      */\n     @Override\n     public double evaluate(final double[] values,final int begin, final int length) {\n-        // Initialize the kurtosis  \n-        double kurt = Double.NaN;   \n-        \n-        if (test(values, begin, length) && length > 3) {       \n-            \n+        // Initialize the kurtosis\n+        double kurt = Double.NaN;\n+\n+        if (test(values, begin, length) && length > 3) {\n+\n             // Compute the mean and standard deviation\n             Variance variance = new Variance();\n             variance.incrementAll(values, begin, length);\n             double mean = variance.moment.m1;\n             double stdDev = Math.sqrt(variance.getResult());\n-            \n+\n             // Sum the ^4 of the distance from the mean divided by the\n             // standard deviation\n             double accum3 = 0.0;\n                 accum3 += Math.pow((values[i] - mean), 4.0);\n             }\n             accum3 /= Math.pow(stdDev, 4.0d);\n-            \n+\n             // Get N\n             double n0 = length;\n-            \n+\n             double coefficientOne =\n                 (n0 * (n0 + 1)) / ((n0 - 1) * (n0 - 2) * (n0 - 3));\n             double termTwo =\n                 ((3 * Math.pow(n0 - 1, 2.0)) / ((n0 - 2) * (n0 - 3)));\n-            \n+\n             // Calculate kurtosis\n             kurt = (coefficientOne * accum3) - termTwo;\n-        }       \n+        }\n         return kurt;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         copy(this, result);\n         return result;\n     }\n-    \n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n-     * \n+     *\n      * @param source Kurtosis to copy\n      * @param dest Kurtosis to copy to\n      * @throws NullPointerException if either source or dest is null\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n  * <p>\n  *  Returns <code>Double.NaN</code> if the dataset is empty.\n  * </p>\n- * <strong>Note that this implementation is not synchronized.</strong> If \n+ * <strong>Note that this implementation is not synchronized.</strong> If\n  * multiple threads access an instance of this class concurrently, and at least\n- * one of the threads invokes the <code>increment()</code> or \n+ * one of the threads invokes the <code>increment()</code> or\n  * <code>clear()</code> method, it must be synchronized externally.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n-public class Mean extends AbstractStorelessUnivariateStatistic \n+public class Mean extends AbstractStorelessUnivariateStatistic\n     implements Serializable {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -1296043746617791564L;    \n-    \n+    private static final long serialVersionUID = -1296043746617791564L;\n+\n     /** First moment on which this statistic is based. */\n     protected FirstMoment moment;\n \n-    /** \n+    /**\n      * Determines whether or not this statistic can be incremented or cleared.\n      * <p>\n      * Statistics based on (constructed from) external moments cannot\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/SecondMoment.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/SecondMoment.java\n  * Returns <code>Double.NaN</code> if no data values have been added and\n  * returns <code>0</code> if there is just one value in the data set.</p>\n  * <p>\n- * <strong>Note that this implementation is not synchronized.</strong> If \n+ * <strong>Note that this implementation is not synchronized.</strong> If\n  * multiple threads access an instance of this class concurrently, and at least\n- * one of the threads invokes the <code>increment()</code> or \n+ * one of the threads invokes the <code>increment()</code> or\n  * <code>clear()</code> method, it must be synchronized externally.</p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class SecondMoment extends FirstMoment implements Serializable {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 3942403127395076445L;  \n-      \n+    private static final long serialVersionUID = 3942403127395076445L;\n+\n     /** second moment of values that have been added */\n     protected double m2;\n \n         super();\n         m2 = Double.NaN;\n     }\n-    \n+\n     /**\n      * Copy constructor, creates a new {@code SecondMoment} identical\n      * to the {@code original}\n-     * \n+     *\n      * @param original the {@code SecondMoment} instance to copy\n      */\n     public SecondMoment(SecondMoment original) {\n         super(original);\n         this.m2 = original.m2;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public double getResult() {\n         return m2;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public SecondMoment copy() {\n         SecondMoment result = new SecondMoment();\n         copy(this, result);\n-        return result; \n+        return result;\n     }\n-    \n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n-     * \n+     *\n      * @param source SecondMoment to copy\n      * @param dest SecondMoment to copy to\n      * @throws NullPointerException if either source or dest is null\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n  * <p>\n  * skewness = [n / (n -1) (n - 2)] sum[(x_i - mean)^3] / std^3 </p>\n  * <p>\n- * where n is the number of values, mean is the {@link Mean} and std is the \n+ * where n is the number of values, mean is the {@link Mean} and std is the\n  * {@link StandardDeviation} </p>\n  * <p>\n- * <strong>Note that this implementation is not synchronized.</strong> If \n+ * <strong>Note that this implementation is not synchronized.</strong> If\n  * multiple threads access an instance of this class concurrently, and at least\n- * one of the threads invokes the <code>increment()</code> or \n+ * one of the threads invokes the <code>increment()</code> or\n  * <code>clear()</code> method, it must be synchronized externally. </p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class Skewness extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 7101857578996691352L;    \n-    \n+    private static final long serialVersionUID = 7101857578996691352L;\n+\n     /** Third moment on which this statistic is based */\n     protected ThirdMoment moment = null;\n \n-     /** \n+     /**\n      * Determines whether or not this statistic can be incremented or cleared.\n      * <p>\n      * Statistics based on (constructed from) external moments cannot\n         incMoment = false;\n         this.moment = m3;\n     }\n-     \n+\n     /**\n      * Copy constructor, creates a new {@code Skewness} identical\n      * to the {@code original}\n-     * \n+     *\n      * @param original the {@code Skewness} instance to copy\n      */\n     public Skewness(Skewness original) {\n      * Returns the value of the statistic based on the values that have been added.\n      * <p>\n      * See {@link Skewness} for the definition used in the computation.</p>\n-     * \n+     *\n      * @return the skewness of the available values.\n      */\n     @Override\n     public double getResult() {\n-        \n+\n         if (moment.n < 3) {\n             return Double.NaN;\n         }\n     public long getN() {\n         return moment.getN();\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n      * See {@link Skewness} for the definition used in the computation.</p>\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param begin the index of the first array element to include\n      * @param length the number of elements to include\n      *  parameters are not valid\n      */\n     @Override\n-    public double evaluate(final double[] values,final int begin, \n+    public double evaluate(final double[] values,final int begin,\n             final int length) {\n \n         // Initialize the skewness\n             Mean mean = new Mean();\n             // Get the mean and the standard deviation\n             double m = mean.evaluate(values, begin, length);\n-            \n+\n             // Calc the std, this is implemented here instead\n             // of using the standardDeviation method eliminate\n             // a duplicate pass to get the mean\n             }\n             double stdDev = Math.sqrt((accum - (Math.pow(accum2, 2) / length)) /\n                     (length - 1));\n-            \n+\n             double accum3 = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n                 accum3 += Math.pow(values[i] - m, 3.0d);\n             }\n             accum3 /= Math.pow(stdDev, 3.0d);\n-            \n+\n             // Get N\n             double n0 = length;\n-            \n+\n             // Calculate skewness\n             skew = (n0 / ((n0 - 1) * (n0 - 2))) * accum3;\n         }\n         return skew;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         copy(this, result);\n         return result;\n     }\n-    \n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n-     * \n+     *\n      * @param source Skewness to copy\n      * @param dest Skewness to copy to\n      * @throws NullPointerException if either source or dest is null\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java\n  * is the positive square root of the variance.  This implementation wraps a\n  * {@link Variance} instance.  The <code>isBiasCorrected</code> property of the\n  * wrapped Variance instance is exposed, so that this class can be used to\n- * compute both the \"sample standard deviation\" (the square root of the \n+ * compute both the \"sample standard deviation\" (the square root of the\n  * bias-corrected \"sample variance\") or the \"population standard deviation\"\n- * (the square root of the non-bias-corrected \"population variance\"). See \n- * {@link Variance} for more information.  \n+ * (the square root of the non-bias-corrected \"population variance\"). See\n+ * {@link Variance} for more information.\n  * <p>\n- * <strong>Note that this implementation is not synchronized.</strong> If \n+ * <strong>Note that this implementation is not synchronized.</strong> If\n  * multiple threads access an instance of this class concurrently, and at least\n- * one of the threads invokes the <code>increment()</code> or \n+ * one of the threads invokes the <code>increment()</code> or\n  * <code>clear()</code> method, it must be synchronized externally.</p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class StandardDeviation extends AbstractStorelessUnivariateStatistic\n     implements Serializable {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 5728716329662425188L;  \n-    \n+    private static final long serialVersionUID = 5728716329662425188L;\n+\n     /** Wrapped Variance instance */\n     private Variance variance = null;\n \n \n     /**\n      * Constructs a StandardDeviation from an external second moment.\n-     * \n+     *\n      * @param m2 the external moment\n      */\n     public StandardDeviation(final SecondMoment m2) {\n         variance = new Variance(m2);\n     }\n-    \n+\n     /**\n      * Copy constructor, creates a new {@code StandardDeviation} identical\n      * to the {@code original}\n-     * \n+     *\n      * @param original the {@code StandardDeviation} instance to copy\n      */\n     public StandardDeviation(StandardDeviation original) {\n         copy(original, this);\n     }\n-    \n+\n     /**\n      * Contructs a StandardDeviation with the specified value for the\n-     * <code>isBiasCorrected</code> property.  If this property is set to \n+     * <code>isBiasCorrected</code> property.  If this property is set to\n      * <code>true</code>, the {@link Variance} used in computing results will\n      * use the bias-corrected, or \"sample\" formula.  See {@link Variance} for\n      * details.\n-     * \n+     *\n      * @param isBiasCorrected  whether or not the variance computation will use\n      * the bias-corrected formula\n      */\n     public StandardDeviation(boolean isBiasCorrected) {\n         variance = new Variance(isBiasCorrected);\n     }\n-    \n+\n     /**\n      * Contructs a StandardDeviation with the specified value for the\n      * <code>isBiasCorrected</code> property and the supplied external moment.\n      * If <code>isBiasCorrected</code> is set to <code>true</code>, the\n      * {@link Variance} used in computing results will use the bias-corrected,\n      * or \"sample\" formula.  See {@link Variance} for details.\n-     * \n+     *\n      * @param isBiasCorrected  whether or not the variance computation will use\n      * the bias-corrected formula\n       * @param m2 the external moment\n     public void increment(final double d) {\n         variance.increment(d);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     }\n \n     /**\n-     * Returns the Standard Deviation of the entries in the input array, or \n+     * Returns the Standard Deviation of the entries in the input array, or\n      * <code>Double.NaN</code> if the array is empty.\n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * Does not change the internal state of the statistic.</p>\n-     * \n+     *\n      * @param values the input array\n      * @return the standard deviation of the values or Double.NaN if length = 0\n      * @throws IllegalArgumentException if the array is null\n-     */  \n+     */\n     @Override\n     public double evaluate(final double[] values)  {\n         return Math.sqrt(variance.evaluate(values));\n     }\n-    \n+\n     /**\n      * Returns the Standard Deviation of the entries in the specified portion of\n      * the input array, or <code>Double.NaN</code> if the designated subarray\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * Does not change the internal state of the statistic.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n     public double evaluate(final double[] values, final int begin, final int length)  {\n        return Math.sqrt(variance.evaluate(values, begin, length));\n     }\n-    \n+\n     /**\n      * Returns the Standard Deviation of the entries in the specified portion of\n      * the input array, using the precomputed mean value.  Returns\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * Does not change the internal state of the statistic.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param mean the precomputed mean value\n      * @param begin index of the first array element to include\n             final int begin, final int length)  {\n         return Math.sqrt(variance.evaluate(values, mean, begin, length));\n     }\n-    \n+\n     /**\n      * Returns the Standard Deviation of the entries in the input array, using\n      * the precomputed mean value.  Returns\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * Does not change the internal state of the statistic.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param mean the precomputed mean value\n      * @return the standard deviation of the values or Double.NaN if length = 0\n     public double evaluate(final double[] values, final double mean)  {\n         return Math.sqrt(variance.evaluate(values, mean));\n     }\n-    \n+\n     /**\n      * @return Returns the isBiasCorrected.\n      */\n     public void setBiasCorrected(boolean isBiasCorrected) {\n         variance.setBiasCorrected(isBiasCorrected);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         copy(this, result);\n         return result;\n     }\n-    \n-    \n+\n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n-     * \n+     *\n      * @param source StandardDeviation to copy\n      * @param dest StandardDeviation to copy to\n      * @throws NullPointerException if either source or dest is null\n     public static void copy(StandardDeviation source, StandardDeviation dest) {\n         dest.variance = source.variance.copy();\n     }\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/ThirdMoment.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/ThirdMoment.java\n  * Returns <code>Double.NaN</code> if no data values have been added and\n  * returns <code>0</code> if there is just one value in the data set.</p>\n  * <p>\n- * <strong>Note that this implementation is not synchronized.</strong> If \n+ * <strong>Note that this implementation is not synchronized.</strong> If\n  * multiple threads access an instance of this class concurrently, and at least\n- * one of the threads invokes the <code>increment()</code> or \n+ * one of the threads invokes the <code>increment()</code> or\n  * <code>clear()</code> method, it must be synchronized externally.</p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class ThirdMoment extends SecondMoment implements Serializable {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -7818711964045118679L;  \n-      \n+    private static final long serialVersionUID = -7818711964045118679L;\n+\n     /** third moment of values that have been added */\n     protected double m3;\n \n      /**\n-     * Square of deviation of most recently added value from previous first \n-     * moment, normalized by previous sample size.  Retained to prevent \n+     * Square of deviation of most recently added value from previous first\n+     * moment, normalized by previous sample size.  Retained to prevent\n      * repeated computation in higher order moments.  nDevSq = nDev * nDev.\n      */\n     protected double nDevSq;\n         m3 = Double.NaN;\n         nDevSq = Double.NaN;\n     }\n-    \n+\n     /**\n      * Copy constructor, creates a new {@code ThirdMoment} identical\n      * to the {@code original}\n-     * \n+     *\n      * @param original the {@code ThirdMoment} instance to copy\n      */\n     public ThirdMoment(ThirdMoment original) {\n     public void increment(final double d) {\n         if (n < 1) {\n             m3 = m2 = m1 = 0.0;\n-        }  \n-       \n+        }\n+\n         double prevM2 = m2;\n         super.increment(d);\n         nDevSq = nDev * nDev;\n         m3 = Double.NaN;\n         nDevSq = Double.NaN;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public ThirdMoment copy() {\n         ThirdMoment result = new ThirdMoment();\n         copy(this, result);\n-        return result; \n+        return result;\n     }\n-    \n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n-     * \n+     *\n      * @param source ThirdMoment to copy\n      * @param dest ThirdMoment to copy to\n      * @throws NullPointerException if either source or dest is null\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n  * To compute population variances, set this property to <code>false.</code>\n  * </p>\n  * <p>\n- * <strong>Note that this implementation is not synchronized.</strong> If \n+ * <strong>Note that this implementation is not synchronized.</strong> If\n  * multiple threads access an instance of this class concurrently, and at least\n- * one of the threads invokes the <code>increment()</code> or \n+ * one of the threads invokes the <code>increment()</code> or\n  * <code>clear()</code> method, it must be synchronized externally.</p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class Variance extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -9111962718267217978L;  \n-      \n+    private static final long serialVersionUID = -9111962718267217978L;\n+\n     /** SecondMoment is used in incremental calculation of Variance*/\n     protected SecondMoment moment = null;\n \n                 for (int i = 0; i < weights.length; i++) {\n                     sumWts += weights[i];\n                 }\n-                \n+\n                 if (isBiasCorrected) {\n                     var = accum / (sumWts - 1);\n                 } else {\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/VectorialCovariance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/VectorialCovariance.java\n         return true;\n     }\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/VectorialMean.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/VectorialMean.java\n         return true;\n     }\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/rank/Max.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/rank/Max.java\n  * Returns the maximum of the available values.\n  * <p>\n  * <ul>\n- * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+ * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n  * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n- * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>, \n+ * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>,\n  * the result is <code>Double.POSITIVE_INFINITY.</code></li>\n  * </ul></p>\n * <p>\n- * <strong>Note that this implementation is not synchronized.</strong> If \n+ * <strong>Note that this implementation is not synchronized.</strong> If\n  * multiple threads access an instance of this class concurrently, and at least\n- * one of the threads invokes the <code>increment()</code> or \n+ * one of the threads invokes the <code>increment()</code> or\n  * <code>clear()</code> method, it must be synchronized externally.</p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class Max extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -5593383832225844641L;    \n-    \n+    private static final long serialVersionUID = -5593383832225844641L;\n+\n     /** Number of values that have been added */\n     private long n;\n-        \n+\n     /** Current value of the statistic */\n     private double value;\n \n         n = 0;\n         value = Double.NaN;\n     }\n-    \n+\n     /**\n      * Copy constructor, creates a new {@code Max} identical\n      * to the {@code original}\n-     * \n+     *\n      * @param original the {@code Max} instance to copy\n      */\n     public Max(Max original) {\n         copy(original, this);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public long getN() {\n         return n;\n     }\n-    \n+\n     /**\n      * Returns the maximum of the entries in the specified portion of\n      * the input array, or <code>Double.NaN</code> if the designated subarray\n      * the array index parameters are not valid.</p>\n      * <p>\n      * <ul>\n-     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n      * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n-     * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>, \n+     * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>,\n      * the result is <code>Double.POSITIVE_INFINITY.</code></li>\n      * </ul></p>\n-     * \n+     *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n         }\n         return max;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         copy(this, result);\n         return result;\n     }\n-    \n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n-     * \n+     *\n      * @param source Max to copy\n      * @param dest Max to copy to\n      * @throws NullPointerException if either source or dest is null\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/rank/Median.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/rank/Median.java\n  * Returns the median of the available values.  This is the same as the 50th percentile.\n  * See {@link Percentile} for a description of the algorithm used.\n  * <p>\n- * <strong>Note that this implementation is not synchronized.</strong> If \n+ * <strong>Note that this implementation is not synchronized.</strong> If\n  * multiple threads access an instance of this class concurrently, and at least\n- * one of the threads invokes the <code>increment()</code> or \n+ * one of the threads invokes the <code>increment()</code> or\n  * <code>clear()</code> method, it must be synchronized externally.</p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class Median extends Percentile implements Serializable {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -3961477041290915687L;    \n+    private static final long serialVersionUID = -3961477041290915687L;\n \n     /**\n      * Default constructor.\n     public Median() {\n         super(50.0);\n     }\n-    \n+\n     /**\n      * Copy constructor, creates a new {@code Median} identical\n      * to the {@code original}\n-     * \n+     *\n      * @param original the {@code Median} instance to copy\n      */\n     public Median(Median original) {\n         super(original);\n-    }        \n+    }\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/rank/Min.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/rank/Min.java\n  * Returns the minimum of the available values.\n  * <p>\n  * <ul>\n- * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+ * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n  * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n- * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>, \n+ * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>,\n  * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n  * </ul></p>\n  * <p>\n- * <strong>Note that this implementation is not synchronized.</strong> If \n+ * <strong>Note that this implementation is not synchronized.</strong> If\n  * multiple threads access an instance of this class concurrently, and at least\n- * one of the threads invokes the <code>increment()</code> or \n+ * one of the threads invokes the <code>increment()</code> or\n  * <code>clear()</code> method, it must be synchronized externally.</p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class Min extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -2941995784909003131L;  \n-      \n+    private static final long serialVersionUID = -2941995784909003131L;\n+\n     /**Number of values that have been added */\n     private long n;\n-    \n+\n     /**Current value of the statistic */\n     private double value;\n \n         n = 0;\n         value = Double.NaN;\n     }\n-    \n+\n     /**\n      * Copy constructor, creates a new {@code Min} identical\n      * to the {@code original}\n-     * \n+     *\n      * @param original the {@code Min} instance to copy\n      */\n     public Min(Min original) {\n         copy(original, this);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public long getN() {\n         return n;\n     }\n-    \n+\n     /**\n      * Returns the minimum of the entries in the specified portion of\n      * the input array, or <code>Double.NaN</code> if the designated subarray\n      * the array index parameters are not valid.</p>\n      * <p>\n      * <ul>\n-     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code>\n      * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n-     * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>, \n+     * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>,\n      * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n      * </ul> </p>\n-     * \n+     *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n         }\n         return min;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         copy(this, result);\n         return result;\n     }\n-    \n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n-     * \n+     *\n      * @param source Min to copy\n      * @param dest Min to copy to\n      * @throws NullPointerException if either source or dest is null\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n /**\n  * Provides percentile computation.\n  * <p>\n- * There are several commonly used methods for estimating percentiles (a.k.a. \n- * quantiles) based on sample data.  For large samples, the different methods \n+ * There are several commonly used methods for estimating percentiles (a.k.a.\n+ * quantiles) based on sample data.  For large samples, the different methods\n  * agree closely, but when sample sizes are small, different methods will give\n  * significantly different results.  The algorithm implemented here works as follows:\n  * <ol>\n- * <li>Let <code>n</code> be the length of the (sorted) array and \n+ * <li>Let <code>n</code> be the length of the (sorted) array and\n  * <code>0 < p <= 100</code> be the desired percentile.</li>\n- * <li>If <code> n = 1 </code> return the unique array element (regardless of \n+ * <li>If <code> n = 1 </code> return the unique array element (regardless of\n  * the value of <code>p</code>); otherwise </li>\n- * <li>Compute the estimated percentile position  \n+ * <li>Compute the estimated percentile position\n  * <code> pos = p * (n + 1) / 100</code> and the difference, <code>d</code>\n  * between <code>pos</code> and <code>floor(pos)</code> (i.e. the fractional\n  * part of <code>pos</code>).  If <code>pos >= n</code> return the largest\n  * element in the array; otherwise</li>\n- * <li>Let <code>lower</code> be the element in position \n+ * <li>Let <code>lower</code> be the element in position\n  * <code>floor(pos)</code> in the array and let <code>upper</code> be the\n  * next element in the array.  Return <code>lower + d * (upper - lower)</code>\n  * </li>\n  * To compute percentiles, the data must be (totally) ordered.  Input arrays\n  * are copied and then sorted using  {@link java.util.Arrays#sort(double[])}.\n  * The ordering used by <code>Arrays.sort(double[])</code> is the one determined\n- * by {@link java.lang.Double#compareTo(Double)}.  This ordering makes \n- * <code>Double.NaN</code> larger than any other value (including \n+ * by {@link java.lang.Double#compareTo(Double)}.  This ordering makes\n+ * <code>Double.NaN</code> larger than any other value (including\n  * <code>Double.POSITIVE_INFINITY</code>).  Therefore, for example, the median\n- * (50th percentile) of  \n+ * (50th percentile) of\n  * <code>{0, 1, 2, 3, 4, Double.NaN}</code> evaluates to <code>2.5.</code></p>\n  * <p>\n- * Since percentile estimation usually involves interpolation between array \n+ * Since percentile estimation usually involves interpolation between array\n  * elements, arrays containing  <code>NaN</code> or infinite values will often\n  * result in <code>NaN<code> or infinite values returned.</p>\n  * <p>\n- * <strong>Note that this implementation is not synchronized.</strong> If \n+ * <strong>Note that this implementation is not synchronized.</strong> If\n  * multiple threads access an instance of this class concurrently, and at least\n- * one of the threads invokes the <code>increment()</code> or \n+ * one of the threads invokes the <code>increment()</code> or\n  * <code>clear()</code> method, it must be synchronized externally.</p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class Percentile extends AbstractUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -8091216485095130416L; \n-       \n-    /** Determines what percentile is computed when evaluate() is activated \n+    private static final long serialVersionUID = -8091216485095130416L;\n+\n+    /** Determines what percentile is computed when evaluate() is activated\n      * with no quantile argument */\n     private double quantile = 0.0;\n \n     /**\n      * Copy constructor, creates a new {@code Percentile} identical\n      * to the {@code original}\n-     * \n+     *\n      * @param original the {@code Percentile} instance to copy\n      */\n     public Percentile(Percentile original) {\n         copy(original, this);\n-    }        \n-    \n+    }\n+\n     /**\n      * Returns an estimate of the <code>p</code>th percentile of the values\n      * in the <code>values</code> array.\n      * state of this statistic.</p>\n      * <p>\n      * <ul>\n-     * <li>Returns <code>Double.NaN</code> if <code>values</code> has length \n+     * <li>Returns <code>Double.NaN</code> if <code>values</code> has length\n      * <code>0</code></li>\n      * <li>Returns (for any value of <code>p</code>) <code>values[0]</code>\n      *  if <code>values</code> has length <code>1</code></li>\n      * <p>\n      * See {@link Percentile} for a description of the percentile estimation\n      * algorithm used.</p>\n-     * \n+     *\n      * @param values input array of values\n      * @param p the percentile value to compute\n      * @return the percentile value or Double.NaN if the array is empty\n-     * @throws IllegalArgumentException if <code>values</code> is null \n+     * @throws IllegalArgumentException if <code>values</code> is null\n      *     or p is invalid\n      */\n     public double evaluate(final double[] values, final double p) {\n      * <p>\n      * <ul>\n      * <li>Returns <code>Double.NaN</code> if <code>length = 0</code></li>\n-     * <li>Returns (for any value of <code>quantile</code>) \n+     * <li>Returns (for any value of <code>quantile</code>)\n      * <code>values[begin]</code> if <code>length = 1 </code></li>\n      * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n-     * is null,  or <code>start</code> or <code>length</code> \n+     * is null,  or <code>start</code> or <code>length</code>\n      * is invalid</li>\n      * </ul></p>\n      * <p>\n      * See {@link Percentile} for a description of the percentile estimation\n      * algorithm used.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param start index of the first array element to include\n      * @param length the number of elements to include\n      * @return the percentile value\n      * @throws IllegalArgumentException if the parameters are not valid\n-     * \n+     *\n      */\n     @Override\n     public double evaluate( final double[] values, final int start, final int length) {\n      * <li>Returns (for any value of <code>p</code>) <code>values[begin]</code>\n      *  if <code>length = 1 </code></li>\n      * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n-     *  is null , <code>begin</code> or <code>length</code> is invalid, or \n+     *  is null , <code>begin</code> or <code>length</code> is invalid, or\n      * <code>p</code> is not a valid quantile value (p must be greater than 0\n      * and less than or equal to 100)</li>\n      * </ul></p>\n      * <p>\n      * See {@link Percentile} for a description of the percentile estimation\n      * algorithm used.</p>\n-     * \n+     *\n      * @param values array of input values\n      * @param p  the percentile to compute\n      * @param begin  the first (0-based) element to include in the computation\n      * @throws IllegalArgumentException if the parameters are not valid or the\n      * input array is null\n      */\n-    public double evaluate(final double[] values, final int begin, \n+    public double evaluate(final double[] values, final int begin,\n             final int length, final double p) {\n \n         test(values, begin, length);\n     /**\n      * Returns the value of the quantile field (determines what percentile is\n      * computed when evaluate() is called with no quantile argument).\n-     * \n+     *\n      * @return quantile\n      */\n     public double getQuantile() {\n     }\n \n     /**\n-     * Sets the value of the quantile field (determines what percentile is \n+     * Sets the value of the quantile field (determines what percentile is\n      * computed when evaluate() is called with no quantile argument).\n-     * \n-     * @param p a value between 0 < p <= 100 \n+     *\n+     * @param p a value between 0 < p <= 100\n      * @throws IllegalArgumentException  if p is not greater than 0 and less\n      * than or equal to 100\n      */\n         }\n         quantile = p;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         copy(this, result);\n         return result;\n     }\n-    \n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n-     * \n+     *\n      * @param source Percentile to copy\n      * @param dest Percentile to copy to\n      * @throws NullPointerException if either source or dest is null\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n /**\n  * Returns the product of the available values.\n  * <p>\n- * If there are no values in the dataset, or any of the values are \n+ * If there are no values in the dataset, or any of the values are\n  * <code>NaN</code>, then <code>NaN</code> is returned.</p>\n  * <p>\n- * <strong>Note that this implementation is not synchronized.</strong> If \n+ * <strong>Note that this implementation is not synchronized.</strong> If\n  * multiple threads access an instance of this class concurrently, and at least\n- * one of the threads invokes the <code>increment()</code> or \n+ * one of the threads invokes the <code>increment()</code> or\n  * <code>clear()</code> method, it must be synchronized externally.</p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class Product extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 2824226005990582538L;   \n-     \n+    private static final long serialVersionUID = 2824226005990582538L;\n+\n     /**The number of values that have been added */\n     private long n;\n-    \n+\n     /**\n      * The current Running Product.\n      */\n      * <p>Returns the weighted product of the entries in the specified portion of\n      * the input array, or <code>Double.NaN</code> if the designated subarray\n      * is empty.</p>\n-     * \n+     *\n      * <p>Throws <code>IllegalArgumentException</code> if any of the following are true:\n      * <ul><li>the values array is null</li>\n      *     <li>the weights array is null</li>\n      *     <li>the weights array contains negative values</li>\n      *     <li>the start and length arguments do not determine a valid array</li>\n      * </ul></p>\n-     * \n+     *\n      * <p>Uses the formula, <pre>\n      *    weighted product = &prod;values[i]<sup>weights[i]</sup>\n      * </pre>\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n /**\n   * Returns the sum of the available values.\n  * <p>\n- * If there are no values in the dataset, or any of the values are \n+ * If there are no values in the dataset, or any of the values are\n  * <code>NaN</code>, then <code>NaN</code> is returned.</p>\n  * <p>\n- * <strong>Note that this implementation is not synchronized.</strong> If \n+ * <strong>Note that this implementation is not synchronized.</strong> If\n  * multiple threads access an instance of this class concurrently, and at least\n- * one of the threads invokes the <code>increment()</code> or \n+ * one of the threads invokes the <code>increment()</code> or\n  * <code>clear()</code> method, it must be synchronized externally.</p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class Sum extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -8231831954703408316L;  \n-      \n+    private static final long serialVersionUID = -8231831954703408316L;\n+\n     /** */\n     private long n;\n-    \n+\n     /**\n      * The currently running sum.\n      */\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n \n /**\n- * Returns the sum of the natural logs for this collection of values.  \n+ * Returns the sum of the natural logs for this collection of values.\n  * <p>\n  * Uses {@link java.lang.Math#log(double)} to compute the logs.  Therefore,\n  * <ul>\n  * <li>If any of values are < 0, the result is <code>NaN.</code></li>\n- * <li>If all values are non-negative and less than \n+ * <li>If all values are non-negative and less than\n  * <code>Double.POSITIVE_INFINITY</code>,  but at least one value is 0, the\n  * result is <code>Double.NEGATIVE_INFINITY.</code></li>\n- * <li>If both <code>Double.POSITIVE_INFINITY</code> and \n+ * <li>If both <code>Double.POSITIVE_INFINITY</code> and\n  * <code>Double.NEGATIVE_INFINITY</code> are among the values, the result is\n  * <code>NaN.</code></li>\n  * </ul></p>\n  * <p>\n- * <strong>Note that this implementation is not synchronized.</strong> If \n+ * <strong>Note that this implementation is not synchronized.</strong> If\n  * multiple threads access an instance of this class concurrently, and at least\n- * one of the threads invokes the <code>increment()</code> or \n+ * one of the threads invokes the <code>increment()</code> or\n  * <code>clear()</code> method, it must be synchronized externally.</p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class SumOfLogs extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -370076995648386763L;    \n+    private static final long serialVersionUID = -370076995648386763L;\n \n     /**Number of values that have been added */\n     private int n;\n-    \n+\n     /**\n      * The currently running value\n      */\n     private double value;\n-    \n+\n     /**\n      * Create a SumOfLogs instance\n      */\n        value = 0d;\n        n = 0;\n     }\n-    \n+\n     /**\n      * Copy constructor, creates a new {@code SumOfLogs} identical\n      * to the {@code original}\n-     * \n+     *\n      * @param original the {@code SumOfLogs} instance to copy\n      */\n     public SumOfLogs(SumOfLogs original) {\n     public long getN() {\n         return n;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n      * <p>\n      * See {@link SumOfLogs}.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the sum of the natural logs of the values or Double.NaN if \n+     * @return the sum of the natural logs of the values or Double.NaN if\n      * length = 0\n      * @throws IllegalArgumentException if the array is null or the array index\n      *  parameters are not valid\n         }\n         return sumLog;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         copy(this, result);\n         return result;\n     }\n-    \n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n-     * \n+     *\n      * @param source SumOfLogs to copy\n      * @param dest SumOfLogs to copy to\n      * @throws NullPointerException if either source or dest is null\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n /**\n  * Returns the sum of the squares of the available values.\n  * <p>\n- * If there are no values in the dataset, or any of the values are \n+ * If there are no values in the dataset, or any of the values are\n  * <code>NaN</code>, then <code>NaN</code> is returned.</p>\n  * <p>\n- * <strong>Note that this implementation is not synchronized.</strong> If \n+ * <strong>Note that this implementation is not synchronized.</strong> If\n  * multiple threads access an instance of this class concurrently, and at least\n- * one of the threads invokes the <code>increment()</code> or \n+ * one of the threads invokes the <code>increment()</code> or\n  * <code>clear()</code> method, it must be synchronized externally.</p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class SumOfSquares extends AbstractStorelessUnivariateStatistic implements Serializable {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 1460986908574398008L;  \n-      \n+    private static final long serialVersionUID = 1460986908574398008L;\n+\n     /** */\n     private long n;\n-    \n+\n     /**\n      * The currently running sumSq\n      */\n         n = 0;\n         value = Double.NaN;\n     }\n-    \n+\n     /**\n      * Copy constructor, creates a new {@code SumOfSquares} identical\n      * to the {@code original}\n-     * \n+     *\n      * @param original the {@code SumOfSquares} instance to copy\n      */\n     public SumOfSquares(SumOfSquares original) {\n         copy(original, this);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public long getN() {\n         return n;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n      * is empty.\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n-     * \n+     *\n      * @param values the input array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n         }\n         return sumSq;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n         copy(this, result);\n         return result;\n     }\n-    \n+\n     /**\n      * Copies source to dest.\n      * <p>Neither source nor dest can be null.</p>\n-     * \n+     *\n      * @param source SumOfSquares to copy\n      * @param dest SumOfSquares to copy to\n      * @throws NullPointerException if either source or dest is null\n--- a/src/main/java/org/apache/commons/math/stat/inference/ChiSquareTest.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/ChiSquareTest.java\n  * <p>This interface handles only known distributions. If the distribution is\n  * unknown and should be provided by a sample, then the {@link UnknownDistributionChiSquareTest\n  * UnknownDistributionChiSquareTest} extended interface should be used instead.</p>\n- * @version $Revision$ $Date$ \n+ * @version $Revision$ $Date$\n  */\n public interface ChiSquareTest {\n-     \n+\n      /**\n      * Computes the <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm\">\n-     * Chi-Square statistic</a> comparing <code>observed</code> and <code>expected</code> \n-     * frequency counts. \n+     * Chi-Square statistic</a> comparing <code>observed</code> and <code>expected</code>\n+     * frequency counts.\n      * <p>\n      * This statistic can be used to perform a Chi-Square test evaluating the null hypothesis that\n      *  the observed counts follow the expected distribution.</p>\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n-     * <li>Expected counts must all be positive.  \n-     * </li>\n-     * <li>Observed counts must all be >= 0.   \n+     * <li>Expected counts must all be positive.\n+     * </li>\n+     * <li>Observed counts must all be >= 0.\n      * </li>\n      * <li>The observed and expected arrays must have the same length and\n-     * their common length must be at least 2.  \n-     * </li></ul></p><p>\n-     * If any of the preconditions are not met, an \n+     * their common length must be at least 2.\n+     * </li></ul></p><p>\n+     * If any of the preconditions are not met, an\n      * <code>IllegalArgumentException</code> is thrown.</p>\n      *\n      * @param observed array of observed frequency counts\n      * @return chiSquare statistic\n      * @throws IllegalArgumentException if preconditions are not met\n      */\n-    double chiSquare(double[] expected, long[] observed) \n+    double chiSquare(double[] expected, long[] observed)\n         throws IllegalArgumentException;\n-    \n+\n     /**\n      * Returns the <i>observed significance level</i>, or <a href=\n      * \"http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue\">\n-     * p-value</a>, associated with a \n+     * p-value</a>, associated with a\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm\">\n-     * Chi-square goodness of fit test</a> comparing the <code>observed</code> \n+     * Chi-square goodness of fit test</a> comparing the <code>observed</code>\n      * frequency counts to those in the <code>expected</code> array.\n      * <p>\n-     * The number returned is the smallest significance level at which one can reject \n-     * the null hypothesis that the observed counts conform to the frequency distribution \n+     * The number returned is the smallest significance level at which one can reject\n+     * the null hypothesis that the observed counts conform to the frequency distribution\n      * described by the expected counts.</p>\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n-     * <li>Expected counts must all be positive.  \n-     * </li>\n-     * <li>Observed counts must all be >= 0.   \n+     * <li>Expected counts must all be positive.\n+     * </li>\n+     * <li>Observed counts must all be >= 0.\n      * </li>\n      * <li>The observed and expected arrays must have the same length and\n-     * their common length must be at least 2.  \n-     * </li></ul></p><p>\n-     * If any of the preconditions are not met, an \n+     * their common length must be at least 2.\n+     * </li></ul></p><p>\n+     * If any of the preconditions are not met, an\n      * <code>IllegalArgumentException</code> is thrown.</p>\n      *\n      * @param observed array of observed frequency counts\n      * @throws IllegalArgumentException if preconditions are not met\n      * @throws MathException if an error occurs computing the p-value\n      */\n-    double chiSquareTest(double[] expected, long[] observed) \n+    double chiSquareTest(double[] expected, long[] observed)\n         throws IllegalArgumentException, MathException;\n-    \n+\n     /**\n      * Performs a <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm\">\n-     * Chi-square goodness of fit test</a> evaluating the null hypothesis that the observed counts \n-     * conform to the frequency distribution described by the expected counts, with \n+     * Chi-square goodness of fit test</a> evaluating the null hypothesis that the observed counts\n+     * conform to the frequency distribution described by the expected counts, with\n      * significance level <code>alpha</code>.  Returns true iff the null hypothesis can be rejected\n      * with 100 * (1 - alpha) percent confidence.\n      * <p>\n      * <strong>Example:</strong><br>\n-     * To test the hypothesis that <code>observed</code> follows \n+     * To test the hypothesis that <code>observed</code> follows\n      * <code>expected</code> at the 99% level, use </p><p>\n      * <code>chiSquareTest(expected, observed, 0.01) </code></p>\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n-     * <li>Expected counts must all be positive.  \n-     * </li>\n-     * <li>Observed counts must all be >= 0.   \n+     * <li>Expected counts must all be positive.\n+     * </li>\n+     * <li>Observed counts must all be >= 0.\n      * </li>\n      * <li>The observed and expected arrays must have the same length and\n-     * their common length must be at least 2.  \n+     * their common length must be at least 2.\n      * <li> <code> 0 < alpha < 0.5 </code>\n      * </li></ul></p><p>\n-     * If any of the preconditions are not met, an \n+     * If any of the preconditions are not met, an\n      * <code>IllegalArgumentException</code> is thrown.</p>\n      *\n      * @param observed array of observed frequency counts\n      * @throws IllegalArgumentException if preconditions are not met\n      * @throws MathException if an error occurs performing the test\n      */\n-    boolean chiSquareTest(double[] expected, long[] observed, double alpha) \n+    boolean chiSquareTest(double[] expected, long[] observed, double alpha)\n         throws IllegalArgumentException, MathException;\n-    \n-    /**\n-     *  Computes the Chi-Square statistic associated with a \n+\n+    /**\n+     *  Computes the Chi-Square statistic associated with a\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm\">\n      *  chi-square test of independence</a> based on the input <code>counts</code>\n-     *  array, viewed as a two-way table.  \n-     * <p>\n-     * The rows of the 2-way table are \n+     *  array, viewed as a two-way table.\n+     * <p>\n+     * The rows of the 2-way table are\n      * <code>count[0], ... , count[count.length - 1] </code></p>\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n-     * <li>All counts must be >= 0.  \n+     * <li>All counts must be >= 0.\n      * </li>\n      * <li>The count array must be rectangular (i.e. all count[i] subarrays\n-     *  must have the same length). \n+     *  must have the same length).\n      * </li>\n      * <li>The 2-way table represented by <code>counts</code> must have at\n      *  least 2 columns and at least 2 rows.\n      * </li>\n      * </li></ul></p><p>\n-     * If any of the preconditions are not met, an \n+     * If any of the preconditions are not met, an\n      * <code>IllegalArgumentException</code> is thrown.</p>\n      *\n      * @param counts array representation of 2-way table\n      * @return chiSquare statistic\n      * @throws IllegalArgumentException if preconditions are not met\n      */\n-    double chiSquare(long[][] counts) \n+    double chiSquare(long[][] counts)\n     throws IllegalArgumentException;\n-    \n+\n     /**\n      * Returns the <i>observed significance level</i>, or <a href=\n      * \"http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue\">\n-     * p-value</a>, associated with a \n+     * p-value</a>, associated with a\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm\">\n      * chi-square test of independence</a> based on the input <code>counts</code>\n-     * array, viewed as a two-way table.  \n-     * <p>\n-     * The rows of the 2-way table are \n+     * array, viewed as a two-way table.\n+     * <p>\n+     * The rows of the 2-way table are\n      * <code>count[0], ... , count[count.length - 1] </code></p>\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n-     * <li>All counts must be >= 0.  \n-     * </li>\n-     * <li>The count array must be rectangular (i.e. all count[i] subarrays must have the same length). \n+     * <li>All counts must be >= 0.\n+     * </li>\n+     * <li>The count array must be rectangular (i.e. all count[i] subarrays must have the same length).\n      * </li>\n      * <li>The 2-way table represented by <code>counts</code> must have at least 2 columns and\n      *        at least 2 rows.\n      * </li>\n      * </li></ul></p><p>\n-     * If any of the preconditions are not met, an \n+     * If any of the preconditions are not met, an\n      * <code>IllegalArgumentException</code> is thrown.</p>\n      *\n      * @param counts array representation of 2-way table\n      * @throws IllegalArgumentException if preconditions are not met\n      * @throws MathException if an error occurs computing the p-value\n      */\n-    double chiSquareTest(long[][] counts) \n+    double chiSquareTest(long[][] counts)\n     throws IllegalArgumentException, MathException;\n-    \n+\n     /**\n      * Performs a <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm\">\n-     * chi-square test of independence</a> evaluating the null hypothesis that the classifications \n+     * chi-square test of independence</a> evaluating the null hypothesis that the classifications\n      * represented by the counts in the columns of the input 2-way table are independent of the rows,\n      * with significance level <code>alpha</code>.  Returns true iff the null hypothesis can be rejected\n      * with 100 * (1 - alpha) percent confidence.\n      * <p>\n-     * The rows of the 2-way table are \n+     * The rows of the 2-way table are\n      * <code>count[0], ... , count[count.length - 1] </code></p>\n      * <p>\n      * <strong>Example:</strong><br>\n      * <code>chiSquareTest(counts, 0.01) </code></p>\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n-     * <li>All counts must be >= 0.  \n-     * </li>\n-     * <li>The count array must be rectangular (i.e. all count[i] subarrays must have the same length). \n+     * <li>All counts must be >= 0.\n+     * </li>\n+     * <li>The count array must be rectangular (i.e. all count[i] subarrays must have the same length).\n      * </li>\n      * <li>The 2-way table represented by <code>counts</code> must have at least 2 columns and\n      *        at least 2 rows.\n      * </li>\n      * </li></ul></p><p>\n-     * If any of the preconditions are not met, an \n+     * If any of the preconditions are not met, an\n      * <code>IllegalArgumentException</code> is thrown.</p>\n      *\n      * @param counts array representation of 2-way table\n      * @throws IllegalArgumentException if preconditions are not met\n      * @throws MathException if an error occurs performing the test\n      */\n-    boolean chiSquareTest(long[][] counts, double alpha) \n+    boolean chiSquareTest(long[][] counts, double alpha)\n     throws IllegalArgumentException, MathException;\n \n }\n--- a/src/main/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n \n     /** Distribution used to compute inference statistics. */\n     private ChiSquaredDistribution distribution;\n-  \n-    /**\n-     * Construct a ChiSquareTestImpl \n+\n+    /**\n+     * Construct a ChiSquareTestImpl\n      */\n     public ChiSquareTestImpl() {\n         this(new ChiSquaredDistributionImpl(1.0));\n     }\n      /**\n      * {@inheritDoc}\n-     * <p><strong>Note: </strong>This implementation rescales the \n+     * <p><strong>Note: </strong>This implementation rescales the\n      * <code>expected</code> array if necessary to ensure that the sum of the\n      * expected and observed counts are equal.</p>\n-     * \n+     *\n      * @param observed array of observed frequency counts\n      * @param expected array of expected frequency counts\n      * @return chi-square test statistic\n \n     /**\n      * {@inheritDoc}\n-     * <p><strong>Note: </strong>This implementation rescales the \n+     * <p><strong>Note: </strong>This implementation rescales the\n      * <code>expected</code> array if necessary to ensure that the sum of the\n      * expected and observed counts are equal.</p>\n-     * \n+     *\n      * @param observed array of observed frequency counts\n      * @param expected array of expected frequency counts\n      * @return p-value\n \n     /**\n      * {@inheritDoc}\n-     * <p><strong>Note: </strong>This implementation rescales the \n+     * <p><strong>Note: </strong>This implementation rescales the\n      * <code>expected</code> array if necessary to ensure that the sum of the\n      * expected and observed counts are equal.</p>\n-     * \n+     *\n      * @param observed array of observed frequency counts\n      * @param expected array of expected frequency counts\n      * @param alpha significance level of the test\n      * @throws IllegalArgumentException if preconditions are not met\n      * @throws MathException if an error occurs performing the test\n      */\n-    public boolean chiSquareTest(double[] expected, long[] observed, \n+    public boolean chiSquareTest(double[] expected, long[] observed,\n             double alpha) throws IllegalArgumentException, MathException {\n         if ((alpha <= 0) || (alpha > 0.5)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n         }\n         return (chiSquareTest(expected, observed) < alpha);\n     }\n-    \n+\n     /**\n      * @param counts array representation of 2-way table\n      * @return chi-square test statistic\n      * @throws IllegalArgumentException if preconditions are not met\n      */\n     public double chiSquare(long[][] counts) throws IllegalArgumentException {\n-        \n+\n         checkArray(counts);\n         int nRows = counts.length;\n         int nCols = counts[0].length;\n-        \n+\n         // compute row, column and total sums\n         double[] rowSum = new double[nRows];\n         double[] colSum = new double[nCols];\n                 total += counts[row][col];\n             }\n         }\n-        \n+\n         // compute expected counts and chi-square\n         double sumSq = 0.0d;\n         double expected = 0.0d;\n         for (int row = 0; row < nRows; row++) {\n             for (int col = 0; col < nCols; col++) {\n                 expected = (rowSum[row] * colSum[col]) / total;\n-                sumSq += ((counts[row][col] - expected) * \n-                        (counts[row][col] - expected)) / expected; \n-            }\n-        } \n+                sumSq += ((counts[row][col] - expected) *\n+                        (counts[row][col] - expected)) / expected;\n+            }\n+        }\n         return sumSq;\n     }\n \n         }\n         return (chiSquareTest(counts) < alpha);\n     }\n-    \n+\n     /**\n      * @param observed1 array of observed frequency counts of the first data set\n      * @param observed2 array of observed frequency counts of the second data set\n      */\n     public double chiSquareDataSetsComparison(long[] observed1, long[] observed2)\n         throws IllegalArgumentException {\n-        \n+\n         // Make sure lengths are same\n         if (observed1.length < 2) {\n             throw MathRuntimeException.createIllegalArgumentException(\n         double weight = 0.0;\n         for (int i = 0; i < observed1.length; i++) {\n             countSum1 += observed1[i];\n-            countSum2 += observed2[i];   \n+            countSum2 += observed2[i];\n         }\n         // Ensure neither sample is uniformly 0\n         if (countSum1 == 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"observed counts are all 0 in first observed array\"); \n+                  \"observed counts are all 0 in first observed array\");\n         }\n         if (countSum2 == 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  \"observed counts are all 0 in second observed array\"); \n+                  \"observed counts are all 0 in second observed array\");\n         }\n         // Compare and compute weight only if different\n         unequalCounts = (countSum1 != countSum2);\n      * Checks to make sure that the input long[][] array is rectangular,\n      * has at least 2 rows and 2 columns, and has all non-negative entries,\n      * throwing IllegalArgumentException if any of these checks fail.\n-     * \n+     *\n      * @param in input 2-way table to check\n      * @throws IllegalArgumentException if the array is not valid\n      */\n     private void checkArray(long[][] in) throws IllegalArgumentException {\n-        \n+\n         if (in.length < 2) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"invalid row dimension: {0} (must be at least 2)\",\n                   in.length);\n         }\n-        \n+\n         if (in[0].length < 2) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                   \"invalid column dimension: {0} (must be at least 2)\",\n                   in[0].length);\n-        }    \n-        \n+        }\n+\n         checkRectangular(in);\n         checkNonNegative(in);\n-        \n-    }\n-    \n+\n+    }\n+\n     //---------------------  Private array methods -- should find a utility home for these\n-    \n+\n     /**\n      * Throws IllegalArgumentException if the input array is not rectangular.\n-     * \n+     *\n      * @param in array to be tested\n      * @throws NullPointerException if input array is null\n      * @throws IllegalArgumentException if input array is not rectangular\n                       \"some rows have length {0} while others have length {1}\",\n                       in[i].length, in[0].length);\n             }\n-        }  \n-    }\n-    \n+        }\n+    }\n+\n     /**\n      * Check all entries of the input array are > 0.\n-     * \n+     *\n      * @param in array to be tested\n      * @exception IllegalArgumentException if one entry is not positive\n      */\n             }\n         }\n     }\n-    \n+\n     /**\n      * Check all entries of the input array are >= 0.\n-     * \n+     *\n      * @param in array to be tested\n      * @exception IllegalArgumentException if one entry is negative\n      */\n             }\n         }\n     }\n-    \n+\n     /**\n      * Check all entries of the input array are >= 0.\n-     * \n+     *\n      * @param in array to be tested\n      * @exception IllegalArgumentException if one entry is negative\n      */\n             }\n         }\n     }\n- \n+\n     /**\n      * Modify the distribution used to compute inference statistics.\n-     * \n+     *\n      * @param value\n      *            the new distribution\n      * @since 1.2\n--- a/src/main/java/org/apache/commons/math/stat/inference/OneWayAnova.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/OneWayAnova.java\n import java.util.Collection;\n \n /**\n- * An interface for one-way ANOVA (analysis of variance). \n+ * An interface for one-way ANOVA (analysis of variance).\n  *\n  * <p> Tests for differences between two or more categories of univariate data\n  * (for example, the body mass index of accountants, lawyers, doctors and\n  * </p>\n  *\n  * @since 1.2\n- * @version $Revision$ $Date$ \n+ * @version $Revision$ $Date$\n  */\n public interface OneWayAnova {\n     /**\n      * Computes the ANOVA F-value for a collection of <code>double[]</code>\n      * arrays.\n-     * \n+     *\n      * <p><strong>Preconditions</strong>: <ul>\n      * <li>The categoryData <code>Collection</code> must contain\n      * <code>double[]</code> arrays.</li>\n     /**\n      * Performs an ANOVA test, evaluating the null hypothesis that there\n      * is no difference among the means of the data categories.\n-     * \n+     *\n      * <p><strong>Preconditions</strong>: <ul>\n      * <li>The categoryData <code>Collection</code> must contain\n      * <code>double[]</code> arrays.</li>\n      * @param categoryData <code>Collection</code> of <code>double[]</code>\n      * arrays each containing data for one category\n      * @param alpha significance level of the test\n-     * @return true if the null hypothesis can be rejected with \n+     * @return true if the null hypothesis can be rejected with\n      * confidence 1 - alpha\n      * @throws IllegalArgumentException if the preconditions are not met\n      * @throws MathException if the statistic can not be computed do to a\n     public boolean anovaTest(Collection<double[]> categoryData, double alpha)\n         throws IllegalArgumentException, MathException;\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/stat/inference/OneWayAnovaImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/OneWayAnovaImpl.java\n /**\n  * Implements one-way ANOVA statistics defined in the {@link OneWayAnovaImpl}\n  * interface.\n- * \n- * <p>Uses the \n+ *\n+ * <p>Uses the\n  * {@link org.apache.commons.math.distribution.FDistribution\n  *  commons-math F Distribution implementation} to estimate exact p-values.</p>\n  *\n- * <p>This implementation is based on a description at \n+ * <p>This implementation is based on a description at\n  * http://faculty.vassar.edu/lowry/ch13pt1.html</p>\n  * <pre>\n  * Abbreviations: bg = between groups,\n      */\n     public OneWayAnovaImpl() {\n     }\n-    \n+\n     /**\n      * {@inheritDoc}<p>\n-     * This implementation computes the F statistic using the definitional \n+     * This implementation computes the F statistic using the definitional\n      * formula<pre>\n      *   F = msbg/mswg</pre>\n      * where<pre>\n \n     /**\n      * This method actually does the calculations (except P-value).\n-     * \n+     *\n      * @param categoryData <code>Collection</code> of <code>double[]</code>\n      * arrays each containing data for one category\n      * @return computed AnovaStats\n                   \"two or more categories required, got {0}\",\n                   categoryData.size());\n         }\n-        \n+\n         // check if each category has enough data and all is double[]\n         for (double[] array : categoryData) {\n             if (array.length <= 1) {\n         Sum totsum = new Sum();\n         SumOfSquares totsumsq = new SumOfSquares();\n         int totnum = 0;\n-        \n+\n         for (double[] data : categoryData) {\n \n             Sum sum = new Sum();\n             double ss = sumsq.getResult() - sum.getResult() * sum.getResult() / num;\n             sswg += ss;\n         }\n-        double sst = totsumsq.getResult() - totsum.getResult() * \n+        double sst = totsumsq.getResult() - totsum.getResult() *\n             totsum.getResult()/totnum;\n         double ssbg = sst - sswg;\n         int dfbg = categoryData.size() - 1;\n         return new AnovaStats(dfbg, dfwg, F);\n     }\n \n-    /** \n+    /**\n         Convenience class to pass dfbg,dfwg,F values around within AnovaImpl.\n         No get/set methods provided.\n     */\n         }\n     }\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/stat/inference/TTest.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/TTest.java\n  * Significance levels are always specified as numbers between 0 and 0.5\n  * (e.g. tests at the 95% level  use <code>alpha=0.05</code>).</p>\n  * <p>\n- * Input to tests can be either <code>double[]</code> arrays or \n+ * Input to tests can be either <code>double[]</code> arrays or\n  * {@link StatisticalSummary} instances.</p>\n- * \n  *\n- * @version $Revision$ $Date$ \n+ *\n+ * @version $Revision$ $Date$\n  */\n public interface TTest {\n     /**\n-     * Computes a paired, 2-sample t-statistic based on the data in the input \n+     * Computes a paired, 2-sample t-statistic based on the data in the input\n      * arrays.  The t-statistic returned is equivalent to what would be returned by\n      * computing the one-sample t-statistic {@link #t(double, double[])}, with\n-     * <code>mu = 0</code> and the sample array consisting of the (signed) \n-     * differences between corresponding entries in <code>sample1</code> and \n+     * <code>mu = 0</code> and the sample array consisting of the (signed)\n+     * differences between corresponding entries in <code>sample1</code> and\n      * <code>sample2.</code>\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n     public abstract double pairedT(double[] sample1, double[] sample2)\n         throws IllegalArgumentException, MathException;\n     /**\n-     * Returns the <i>observed significance level</i>, or \n-     * <i> p-value</i>, associated with a paired, two-sample, two-tailed t-test \n+     * Returns the <i>observed significance level</i>, or\n+     * <i> p-value</i>, associated with a paired, two-sample, two-tailed t-test\n      * based on the data in the input arrays.\n      * <p>\n      * The number returned is the smallest significance level\n      * at which one can reject the null hypothesis that the mean of the paired\n-     * differences is 0 in favor of the two-sided alternative that the mean paired \n-     * difference is not equal to 0. For a one-sided test, divide the returned \n+     * differences is 0 in favor of the two-sided alternative that the mean paired\n+     * difference is not equal to 0. For a one-sided test, divide the returned\n      * value by 2.</p>\n      * <p>\n      * This test is equivalent to a one-sample t-test computed using\n      * {@link #tTest(double, double[])} with <code>mu = 0</code> and the sample\n-     * array consisting of the signed differences between corresponding elements of \n+     * array consisting of the signed differences between corresponding elements of\n      * <code>sample1</code> and <code>sample2.</code></p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the p-value depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n      * here</a></p>\n      * <p>\n     public abstract double pairedTTest(double[] sample1, double[] sample2)\n         throws IllegalArgumentException, MathException;\n     /**\n-     * Performs a paired t-test evaluating the null hypothesis that the \n+     * Performs a paired t-test evaluating the null hypothesis that the\n      * mean of the paired differences between <code>sample1</code> and\n-     * <code>sample2</code> is 0 in favor of the two-sided alternative that the \n-     * mean paired difference is not equal to 0, with significance level \n+     * <code>sample2</code> is 0 in favor of the two-sided alternative that the\n+     * mean paired difference is not equal to 0, with significance level\n      * <code>alpha</code>.\n      * <p>\n-     * Returns <code>true</code> iff the null hypothesis can be rejected with \n-     * confidence <code>1 - alpha</code>.  To perform a 1-sided test, use \n+     * Returns <code>true</code> iff the null hypothesis can be rejected with\n+     * confidence <code>1 - alpha</code>.  To perform a 1-sided test, use\n      * <code>alpha * 2</code></p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the test depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n-     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n-     * here</a></p>\n-     * <p>\n-     * <strong>Preconditions</strong>: <ul>\n-     * <li>The input array lengths must be the same and their common length \n+     * t-test procedure, as discussed\n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n+     * here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The input array lengths must be the same and their common length\n      * must be at least 2.\n      * </li>\n      * <li> <code> 0 < alpha < 0.5 </code>\n      * @param sample1 array of sample data values\n      * @param sample2 array of sample data values\n      * @param alpha significance level of the test\n-     * @return true if the null hypothesis can be rejected with \n+     * @return true if the null hypothesis can be rejected with\n      * confidence 1 - alpha\n      * @throws IllegalArgumentException if the preconditions are not met\n      * @throws MathException if an error occurs performing the test\n         double alpha)\n         throws IllegalArgumentException, MathException;\n     /**\n-     * Computes a <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula\"> \n+     * Computes a <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula\">\n      * t statistic </a> given observed values and a comparison constant.\n      * <p>\n      * This statistic can be used to perform a one sample t-test for the mean.\n         throws IllegalArgumentException;\n     /**\n      * Computes a <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula\">\n-     * t statistic </a> to use in comparing the mean of the dataset described by \n+     * t statistic </a> to use in comparing the mean of the dataset described by\n      * <code>sampleStats</code> to <code>mu</code>.\n      * <p>\n      * This statistic can be used to perform a one sample t-test for the mean.\n     public abstract double t(double mu, StatisticalSummary sampleStats)\n         throws IllegalArgumentException;\n     /**\n-     * Computes a 2-sample t statistic,  under the hypothesis of equal \n+     * Computes a 2-sample t statistic,  under the hypothesis of equal\n      * subpopulation variances.  To compute a t-statistic without the\n      * equal variances hypothesis, use {@link #t(double[], double[])}.\n      * <p>\n      * <p>\n      * &nbsp;&nbsp;<code>  t = (m1 - m2) / (sqrt(1/n1 +1/n2) sqrt(var))</code>\n      * </p><p>\n-     * where <strong><code>n1</code></strong> is the size of first sample; \n-     * <strong><code> n2</code></strong> is the size of second sample; \n-     * <strong><code> m1</code></strong> is the mean of first sample;  \n+     * where <strong><code>n1</code></strong> is the size of first sample;\n+     * <strong><code> n2</code></strong> is the size of second sample;\n+     * <strong><code> m1</code></strong> is the mean of first sample;\n      * <strong><code> m2</code></strong> is the mean of second sample</li>\n      * </ul>\n      * and <strong><code>var</code></strong> is the pooled variance estimate:\n      * </p><p>\n      * <code>var = sqrt(((n1 - 1)var1 + (n2 - 1)var2) / ((n1-1) + (n2-1)))</code>\n-     * </p><p> \n+     * </p><p>\n      * with <strong><code>var1<code></strong> the variance of the first sample and\n      * <strong><code>var2</code></strong> the variance of the second sample.\n      * </p><p>\n      * &nbsp;&nbsp; <code>  t = (m1 - m2) / sqrt(var1/n1 + var2/n2)</code>\n      * </p><p>\n      *  where <strong><code>n1</code></strong> is the size of the first sample\n-     * <strong><code> n2</code></strong> is the size of the second sample; \n-     * <strong><code> m1</code></strong> is the mean of the first sample;  \n+     * <strong><code> n2</code></strong> is the size of the second sample;\n+     * <strong><code> m1</code></strong> is the mean of the first sample;\n      * <strong><code> m2</code></strong> is the mean of the second sample;\n      * <strong><code> var1</code></strong> is the variance of the first sample;\n-     * <strong><code> var2</code></strong> is the variance of the second sample;  \n+     * <strong><code> var2</code></strong> is the variance of the second sample;\n      * </p><p>\n      * <strong>Preconditions</strong>: <ul>\n      * <li>The observed array lengths must both be at least 2.\n     /**\n      * Computes a 2-sample t statistic </a>, comparing the means of the datasets\n      * described by two {@link StatisticalSummary} instances, without the\n-     * assumption of equal subpopulation variances.  Use \n+     * assumption of equal subpopulation variances.  Use\n      * {@link #homoscedasticT(StatisticalSummary, StatisticalSummary)} to\n      * compute a t-statistic under the equal variances assumption.\n      * <p>\n      * <p>\n      * &nbsp;&nbsp; <code>  t = (m1 - m2) / sqrt(var1/n1 + var2/n2)</code>\n      * </p><p>\n-     * where <strong><code>n1</code></strong> is the size of the first sample; \n-     * <strong><code> n2</code></strong> is the size of the second sample; \n-     * <strong><code> m1</code></strong> is the mean of the first sample;  \n+     * where <strong><code>n1</code></strong> is the size of the first sample;\n+     * <strong><code> n2</code></strong> is the size of the second sample;\n+     * <strong><code> m1</code></strong> is the mean of the first sample;\n      * <strong><code> m2</code></strong> is the mean of the second sample\n-     * <strong><code> var1</code></strong> is the variance of the first sample;  \n+     * <strong><code> var1</code></strong> is the variance of the first sample;\n      * <strong><code> var2</code></strong> is the variance of the second sample\n      * </p><p>\n      * <strong>Preconditions</strong>: <ul>\n      * Computes a 2-sample t statistic, comparing the means of the datasets\n      * described by two {@link StatisticalSummary} instances, under the\n      * assumption of equal subpopulation variances.  To compute a t-statistic\n-     * without the equal variances assumption, use \n+     * without the equal variances assumption, use\n      * {@link #t(StatisticalSummary, StatisticalSummary)}.\n      * <p>\n      * This statistic can be used to perform a (homoscedastic) two-sample\n      * <p>\n      * &nbsp;&nbsp;<code>  t = (m1 - m2) / (sqrt(1/n1 +1/n2) sqrt(var))</code>\n      * </p><p>\n-     * where <strong><code>n1</code></strong> is the size of first sample; \n-     * <strong><code> n2</code></strong> is the size of second sample; \n-     * <strong><code> m1</code></strong> is the mean of first sample;  \n+     * where <strong><code>n1</code></strong> is the size of first sample;\n+     * <strong><code> n2</code></strong> is the size of second sample;\n+     * <strong><code> m1</code></strong> is the mean of first sample;\n      * <strong><code> m2</code></strong> is the mean of second sample\n      * and <strong><code>var</code></strong> is the pooled variance estimate:\n      * </p><p>\n      * <code>var = sqrt(((n1 - 1)var1 + (n2 - 1)var2) / ((n1-1) + (n2-1)))</code>\n-     * </p><p> \n+     * </p><p>\n      * with <strong><code>var1<code></strong> the variance of the first sample and\n      * <strong><code>var2</code></strong> the variance of the second sample.\n      * </p><p>\n         StatisticalSummary sampleStats2)\n         throws IllegalArgumentException;\n     /**\n-     * Returns the <i>observed significance level</i>, or \n-     * <i>p-value</i>, associated with a one-sample, two-tailed t-test \n+     * Returns the <i>observed significance level</i>, or\n+     * <i>p-value</i>, associated with a one-sample, two-tailed t-test\n      * comparing the mean of the input array with the constant <code>mu</code>.\n      * <p>\n      * The number returned is the smallest significance level\n-     * at which one can reject the null hypothesis that the mean equals \n+     * at which one can reject the null hypothesis that the mean equals\n      * <code>mu</code> in favor of the two-sided alternative that the mean\n-     * is different from <code>mu</code>. For a one-sided test, divide the \n+     * is different from <code>mu</code>. For a one-sided test, divide the\n      * returned value by 2.</p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the test depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">here</a>\n      * </p><p>\n      * <strong>Preconditions</strong>: <ul>\n      * two-sided t-test</a> evaluating the null hypothesis that the mean of the population from\n      * which <code>sample</code> is drawn equals <code>mu</code>.\n      * <p>\n-     * Returns <code>true</code> iff the null hypothesis can be \n-     * rejected with confidence <code>1 - alpha</code>.  To \n+     * Returns <code>true</code> iff the null hypothesis can be\n+     * rejected with confidence <code>1 - alpha</code>.  To\n      * perform a 1-sided test, use <code>alpha * 2</code></p>\n      * <p>\n      * <strong>Examples:</strong><br><ol>\n      * the 95% level, use <br><code>tTest(mu, sample, 0.05) </code>\n      * </li>\n      * <li>To test the (one-sided) hypothesis <code> sample mean < mu </code>\n-     * at the 99% level, first verify that the measured sample mean is less \n-     * than <code>mu</code> and then use \n+     * at the 99% level, first verify that the measured sample mean is less\n+     * than <code>mu</code> and then use\n      * <br><code>tTest(mu, sample, 0.02) </code>\n      * </li></ol></p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n-     * The validity of the test depends on the assumptions of the one-sample \n-     * parametric t-test procedure, as discussed \n+     * The validity of the test depends on the assumptions of the one-sample\n+     * parametric t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/sg_glos.html#one-sample\">here</a>\n      * </p><p>\n      * <strong>Preconditions</strong>: <ul>\n     public abstract boolean tTest(double mu, double[] sample, double alpha)\n         throws IllegalArgumentException, MathException;\n     /**\n-     * Returns the <i>observed significance level</i>, or \n-     * <i>p-value</i>, associated with a one-sample, two-tailed t-test \n+     * Returns the <i>observed significance level</i>, or\n+     * <i>p-value</i>, associated with a one-sample, two-tailed t-test\n      * comparing the mean of the dataset described by <code>sampleStats</code>\n      * with the constant <code>mu</code>.\n      * <p>\n      * The number returned is the smallest significance level\n-     * at which one can reject the null hypothesis that the mean equals \n+     * at which one can reject the null hypothesis that the mean equals\n      * <code>mu</code> in favor of the two-sided alternative that the mean\n-     * is different from <code>mu</code>. For a one-sided test, divide the \n+     * is different from <code>mu</code>. For a one-sided test, divide the\n      * returned value by 2.</p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the test depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n      * here</a></p>\n      * <p>\n      * the 95% level, use <br><code>tTest(mu, sampleStats, 0.05) </code>\n      * </li>\n      * <li>To test the (one-sided) hypothesis <code> sample mean < mu </code>\n-     * at the 99% level, first verify that the measured sample mean is less \n-     * than <code>mu</code> and then use \n+     * at the 99% level, first verify that the measured sample mean is less\n+     * than <code>mu</code> and then use\n      * <br><code>tTest(mu, sampleStats, 0.02) </code>\n      * </li></ol></p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n-     * The validity of the test depends on the assumptions of the one-sample \n-     * parametric t-test procedure, as discussed \n+     * The validity of the test depends on the assumptions of the one-sample\n+     * parametric t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/sg_glos.html#one-sample\">here</a>\n      * </p><p>\n      * <strong>Preconditions</strong>: <ul>\n         double alpha)\n         throws IllegalArgumentException, MathException;\n     /**\n-     * Returns the <i>observed significance level</i>, or \n-     * <i>p-value</i>, associated with a two-sample, two-tailed t-test \n+     * Returns the <i>observed significance level</i>, or\n+     * <i>p-value</i>, associated with a two-sample, two-tailed t-test\n      * comparing the means of the input arrays.\n      * <p>\n      * The number returned is the smallest significance level\n      * at which one can reject the null hypothesis that the two means are\n-     * equal in favor of the two-sided alternative that they are different. \n+     * equal in favor of the two-sided alternative that they are different.\n      * For a one-sided test, divide the returned value by 2.</p>\n      * <p>\n      * The test does not assume that the underlying popuation variances are\n-     * equal  and it uses approximated degrees of freedom computed from the \n+     * equal  and it uses approximated degrees of freedom computed from the\n      * sample data to compute the p-value.  The t-statistic used is as defined in\n      * {@link #t(double[], double[])} and the Welch-Satterthwaite approximation\n-     * to the degrees of freedom is used, \n-     * as described \n+     * to the degrees of freedom is used,\n+     * as described\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm\">\n      * here.</a>  To perform the test under the assumption of equal subpopulation\n      * variances, use {@link #homoscedasticTTest(double[], double[])}.</p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the p-value depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n      * here</a></p>\n      * <p>\n     public abstract double tTest(double[] sample1, double[] sample2)\n         throws IllegalArgumentException, MathException;\n     /**\n-     * Returns the <i>observed significance level</i>, or \n-     * <i>p-value</i>, associated with a two-sample, two-tailed t-test \n+     * Returns the <i>observed significance level</i>, or\n+     * <i>p-value</i>, associated with a two-sample, two-tailed t-test\n      * comparing the means of the input arrays, under the assumption that\n      * the two samples are drawn from subpopulations with equal variances.\n      * To perform the test without the equal variances assumption, use\n      * <p>\n      * The number returned is the smallest significance level\n      * at which one can reject the null hypothesis that the two means are\n-     * equal in favor of the two-sided alternative that they are different. \n+     * equal in favor of the two-sided alternative that they are different.\n      * For a one-sided test, divide the returned value by 2.</p>\n      * <p>\n      * A pooled variance estimate is used to compute the t-statistic.  See\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the p-value depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n      * here</a></p>\n      * <p>\n         double[] sample2)\n         throws IllegalArgumentException, MathException;\n     /**\n-     * Performs a \n+     * Performs a\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm\">\n-     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code> \n-     * and <code>sample2</code> are drawn from populations with the same mean, \n+     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code>\n+     * and <code>sample2</code> are drawn from populations with the same mean,\n      * with significance level <code>alpha</code>.  This test does not assume\n      * that the subpopulation variances are equal.  To perform the test assuming\n-     * equal variances, use \n+     * equal variances, use\n      * {@link #homoscedasticTTest(double[], double[], double)}.\n      * <p>\n      * Returns <code>true</code> iff the null hypothesis that the means are\n-     * equal can be rejected with confidence <code>1 - alpha</code>.  To \n+     * equal can be rejected with confidence <code>1 - alpha</code>.  To\n      * perform a 1-sided test, use <code>alpha * 2</code></p>\n      * <p>\n      * See {@link #t(double[], double[])} for the formula used to compute the\n      * <p>\n      * <strong>Examples:</strong><br><ol>\n      * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at\n-     * the 95% level,  use \n+     * the 95% level,  use\n      * <br><code>tTest(sample1, sample2, 0.05). </code>\n      * </li>\n      * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code>,\n      * at the 99% level, first verify that the measured  mean of <code>sample 1</code>\n-     * is less than the mean of <code>sample 2</code> and then use \n+     * is less than the mean of <code>sample 2</code> and then use\n      * <br><code>tTest(sample1, sample2, 0.02) </code>\n      * </li></ol></p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the test depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n      * here</a></p>\n      * <p>\n      * @param sample1 array of sample data values\n      * @param sample2 array of sample data values\n      * @param alpha significance level of the test\n-     * @return true if the null hypothesis can be rejected with \n+     * @return true if the null hypothesis can be rejected with\n      * confidence 1 - alpha\n      * @throws IllegalArgumentException if the preconditions are not met\n      * @throws MathException if an error occurs performing the test\n         double alpha)\n         throws IllegalArgumentException, MathException;\n     /**\n-     * Performs a \n+     * Performs a\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm\">\n-     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code> \n-     * and <code>sample2</code> are drawn from populations with the same mean, \n+     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code>\n+     * and <code>sample2</code> are drawn from populations with the same mean,\n      * with significance level <code>alpha</code>,  assuming that the\n-     * subpopulation variances are equal.  Use \n+     * subpopulation variances are equal.  Use\n      * {@link #tTest(double[], double[], double)} to perform the test without\n      * the assumption of equal variances.\n      * <p>\n      * Returns <code>true</code> iff the null hypothesis that the means are\n-     * equal can be rejected with confidence <code>1 - alpha</code>.  To \n+     * equal can be rejected with confidence <code>1 - alpha</code>.  To\n      * perform a 1-sided test, use <code>alpha * 2.</code>  To perform the test\n-     * without the assumption of equal subpopulation variances, use \n+     * without the assumption of equal subpopulation variances, use\n      * {@link #tTest(double[], double[], double)}.</p>\n      * <p>\n      * A pooled variance estimate is used to compute the t-statistic. See\n      * the 95% level, use <br><code>tTest(sample1, sample2, 0.05). </code>\n      * </li>\n      * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2, </code>\n-     * at the 99% level, first verify that the measured mean of \n+     * at the 99% level, first verify that the measured mean of\n      * <code>sample 1</code> is less than the mean of <code>sample 2</code>\n      * and then use\n      * <br><code>tTest(sample1, sample2, 0.02) </code>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the test depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n      * here</a></p>\n      * <p>\n      * @param sample1 array of sample data values\n      * @param sample2 array of sample data values\n      * @param alpha significance level of the test\n-     * @return true if the null hypothesis can be rejected with \n+     * @return true if the null hypothesis can be rejected with\n      * confidence 1 - alpha\n      * @throws IllegalArgumentException if the preconditions are not met\n      * @throws MathException if an error occurs performing the test\n         double alpha)\n         throws IllegalArgumentException, MathException;\n     /**\n-     * Returns the <i>observed significance level</i>, or \n-     * <i>p-value</i>, associated with a two-sample, two-tailed t-test \n+     * Returns the <i>observed significance level</i>, or\n+     * <i>p-value</i>, associated with a two-sample, two-tailed t-test\n      * comparing the means of the datasets described by two StatisticalSummary\n      * instances.\n      * <p>\n      * The number returned is the smallest significance level\n      * at which one can reject the null hypothesis that the two means are\n-     * equal in favor of the two-sided alternative that they are different. \n+     * equal in favor of the two-sided alternative that they are different.\n      * For a one-sided test, divide the returned value by 2.</p>\n      * <p>\n      * The test does not assume that the underlying popuation variances are\n-     * equal  and it uses approximated degrees of freedom computed from the \n+     * equal  and it uses approximated degrees of freedom computed from the\n      * sample data to compute the p-value.   To perform the test assuming\n-     * equal variances, use \n+     * equal variances, use\n      * {@link #homoscedasticTTest(StatisticalSummary, StatisticalSummary)}.</p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the p-value depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n      * here</a></p>\n      * <p>\n         StatisticalSummary sampleStats2)\n         throws IllegalArgumentException, MathException;\n     /**\n-     * Returns the <i>observed significance level</i>, or \n-     * <i>p-value</i>, associated with a two-sample, two-tailed t-test \n+     * Returns the <i>observed significance level</i>, or\n+     * <i>p-value</i>, associated with a two-sample, two-tailed t-test\n      * comparing the means of the datasets described by two StatisticalSummary\n      * instances, under the hypothesis of equal subpopulation variances. To\n      * perform a test without the equal variances assumption, use\n      * <p>\n      * The number returned is the smallest significance level\n      * at which one can reject the null hypothesis that the two means are\n-     * equal in favor of the two-sided alternative that they are different. \n+     * equal in favor of the two-sided alternative that they are different.\n      * For a one-sided test, divide the returned value by 2.</p>\n      * <p>\n      * See {@link #homoscedasticT(double[], double[])} for the formula used to\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the p-value depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">here</a>\n      * </p><p>\n      * <strong>Preconditions</strong>: <ul>\n         StatisticalSummary sampleStats2)\n         throws IllegalArgumentException, MathException;\n     /**\n-     * Performs a \n+     * Performs a\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm\">\n-     * two-sided t-test</a> evaluating the null hypothesis that \n+     * two-sided t-test</a> evaluating the null hypothesis that\n      * <code>sampleStats1</code> and <code>sampleStats2</code> describe\n      * datasets drawn from populations with the same mean, with significance\n      * level <code>alpha</code>.   This test does not assume that the\n      * {@link #homoscedasticTTest(StatisticalSummary, StatisticalSummary)}.\n      * <p>\n      * Returns <code>true</code> iff the null hypothesis that the means are\n-     * equal can be rejected with confidence <code>1 - alpha</code>.  To \n+     * equal can be rejected with confidence <code>1 - alpha</code>.  To\n      * perform a 1-sided test, use <code>alpha * 2</code></p>\n      * <p>\n      * See {@link #t(double[], double[])} for the formula used to compute the\n      * <p>\n      * <strong>Examples:</strong><br><ol>\n      * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at\n-     * the 95%, use \n+     * the 95%, use\n      * <br><code>tTest(sampleStats1, sampleStats2, 0.05) </code>\n      * </li>\n      * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code>\n-     * at the 99% level,  first verify that the measured mean of  \n+     * at the 99% level,  first verify that the measured mean of\n      * <code>sample 1</code> is less than  the mean of <code>sample 2</code>\n-     * and then use \n+     * and then use\n      * <br><code>tTest(sampleStats1, sampleStats2, 0.02) </code>\n      * </li></ol></p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the test depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n      * here</a></p>\n      * <p>\n      * @param sampleStats1 StatisticalSummary describing sample data values\n      * @param sampleStats2 StatisticalSummary describing sample data values\n      * @param alpha significance level of the test\n-     * @return true if the null hypothesis can be rejected with \n+     * @return true if the null hypothesis can be rejected with\n      * confidence 1 - alpha\n      * @throws IllegalArgumentException if the preconditions are not met\n      * @throws MathException if an error occurs performing the test\n         StatisticalSummary sampleStats2,\n         double alpha)\n         throws IllegalArgumentException, MathException;\n-}\n+}\n--- a/src/main/java/org/apache/commons/math/stat/inference/TTestImpl.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/TTestImpl.java\n \n     /** Distribution used to compute inference statistics. */\n     private TDistribution distribution;\n-    \n+\n     /**\n      * Default constructor.\n      */\n     public TTestImpl() {\n         this(new TDistributionImpl(1.0));\n     }\n-    \n+\n     /**\n      * Create a test instance using the given distribution for computing\n      * inference statistics.\n         super();\n         setDistribution(t);\n     }\n-    \n-    /**\n-     * Computes a paired, 2-sample t-statistic based on the data in the input \n+\n+    /**\n+     * Computes a paired, 2-sample t-statistic based on the data in the input\n      * arrays.  The t-statistic returned is equivalent to what would be returned by\n      * computing the one-sample t-statistic {@link #t(double, double[])}, with\n-     * <code>mu = 0</code> and the sample array consisting of the (signed) \n-     * differences between corresponding entries in <code>sample1</code> and \n+     * <code>mu = 0</code> and the sample array consisting of the (signed)\n+     * differences between corresponding entries in <code>sample1</code> and\n      * <code>sample2.</code>\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n         checkSampleData(sample1);\n         checkSampleData(sample2);\n         double meanDifference = StatUtils.meanDifference(sample1, sample2);\n-        return t(meanDifference, 0,  \n+        return t(meanDifference, 0,\n                 StatUtils.varianceDifference(sample1, sample2, meanDifference),\n                 sample1.length);\n     }\n \n      /**\n-     * Returns the <i>observed significance level</i>, or \n-     * <i> p-value</i>, associated with a paired, two-sample, two-tailed t-test \n+     * Returns the <i>observed significance level</i>, or\n+     * <i> p-value</i>, associated with a paired, two-sample, two-tailed t-test\n      * based on the data in the input arrays.\n      * <p>\n      * The number returned is the smallest significance level\n      * at which one can reject the null hypothesis that the mean of the paired\n-     * differences is 0 in favor of the two-sided alternative that the mean paired \n-     * difference is not equal to 0. For a one-sided test, divide the returned \n+     * differences is 0 in favor of the two-sided alternative that the mean paired\n+     * difference is not equal to 0. For a one-sided test, divide the returned\n      * value by 2.</p>\n      * <p>\n      * This test is equivalent to a one-sample t-test computed using\n      * {@link #tTest(double, double[])} with <code>mu = 0</code> and the sample\n-     * array consisting of the signed differences between corresponding elements of \n+     * array consisting of the signed differences between corresponding elements of\n      * <code>sample1</code> and <code>sample2.</code></p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the p-value depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n      * here</a></p>\n      * <p>\n     public double pairedTTest(double[] sample1, double[] sample2)\n         throws IllegalArgumentException, MathException {\n         double meanDifference = StatUtils.meanDifference(sample1, sample2);\n-        return tTest(meanDifference, 0, \n-                StatUtils.varianceDifference(sample1, sample2, meanDifference), \n+        return tTest(meanDifference, 0,\n+                StatUtils.varianceDifference(sample1, sample2, meanDifference),\n                 sample1.length);\n     }\n \n      /**\n-     * Performs a paired t-test evaluating the null hypothesis that the \n+     * Performs a paired t-test evaluating the null hypothesis that the\n      * mean of the paired differences between <code>sample1</code> and\n-     * <code>sample2</code> is 0 in favor of the two-sided alternative that the \n-     * mean paired difference is not equal to 0, with significance level \n+     * <code>sample2</code> is 0 in favor of the two-sided alternative that the\n+     * mean paired difference is not equal to 0, with significance level\n      * <code>alpha</code>.\n      * <p>\n-     * Returns <code>true</code> iff the null hypothesis can be rejected with \n-     * confidence <code>1 - alpha</code>.  To perform a 1-sided test, use \n+     * Returns <code>true</code> iff the null hypothesis can be rejected with\n+     * confidence <code>1 - alpha</code>.  To perform a 1-sided test, use\n      * <code>alpha * 2</code></p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the test depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n      * here</a></p>\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n-     * <li>The input array lengths must be the same and their common length \n+     * <li>The input array lengths must be the same and their common length\n      * must be at least 2.\n      * </li>\n      * <li> <code> 0 < alpha < 0.5 </code>\n      * @param sample1 array of sample data values\n      * @param sample2 array of sample data values\n      * @param alpha significance level of the test\n-     * @return true if the null hypothesis can be rejected with \n+     * @return true if the null hypothesis can be rejected with\n      * confidence 1 - alpha\n      * @throws IllegalArgumentException if the preconditions are not met\n      * @throws MathException if an error occurs performing the test\n     }\n \n     /**\n-     * Computes a <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula\"> \n+     * Computes a <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula\">\n      * t statistic </a> given observed values and a comparison constant.\n      * <p>\n      * This statistic can be used to perform a one sample t-test for the mean.\n \n     /**\n      * Computes a <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula\">\n-     * t statistic </a> to use in comparing the mean of the dataset described by \n+     * t statistic </a> to use in comparing the mean of the dataset described by\n      * <code>sampleStats</code> to <code>mu</code>.\n      * <p>\n      * This statistic can be used to perform a one sample t-test for the mean.\n     }\n \n     /**\n-     * Computes a 2-sample t statistic,  under the hypothesis of equal \n+     * Computes a 2-sample t statistic,  under the hypothesis of equal\n      * subpopulation variances.  To compute a t-statistic without the\n      * equal variances hypothesis, use {@link #t(double[], double[])}.\n      * <p>\n      * <p>\n      * &nbsp;&nbsp;<code>  t = (m1 - m2) / (sqrt(1/n1 +1/n2) sqrt(var))</code>\n      * </p><p>\n-     * where <strong><code>n1</code></strong> is the size of first sample; \n-     * <strong><code> n2</code></strong> is the size of second sample; \n-     * <strong><code> m1</code></strong> is the mean of first sample;  \n+     * where <strong><code>n1</code></strong> is the size of first sample;\n+     * <strong><code> n2</code></strong> is the size of second sample;\n+     * <strong><code> m1</code></strong> is the mean of first sample;\n      * <strong><code> m2</code></strong> is the mean of second sample</li>\n      * </ul>\n      * and <strong><code>var</code></strong> is the pooled variance estimate:\n      * </p><p>\n      * <code>var = sqrt(((n1 - 1)var1 + (n2 - 1)var2) / ((n1-1) + (n2-1)))</code>\n-     * </p><p> \n+     * </p><p>\n      * with <strong><code>var1<code></strong> the variance of the first sample and\n      * <strong><code>var2</code></strong> the variance of the second sample.\n      * </p><p>\n                 StatUtils.variance(sample1), StatUtils.variance(sample2),\n                 sample1.length, sample2.length);\n     }\n-    \n+\n     /**\n      * Computes a 2-sample t statistic, without the hypothesis of equal\n      * subpopulation variances.  To compute a t-statistic assuming equal\n      * &nbsp;&nbsp; <code>  t = (m1 - m2) / sqrt(var1/n1 + var2/n2)</code>\n      * </p><p>\n      *  where <strong><code>n1</code></strong> is the size of the first sample\n-     * <strong><code> n2</code></strong> is the size of the second sample; \n-     * <strong><code> m1</code></strong> is the mean of the first sample;  \n+     * <strong><code> n2</code></strong> is the size of the second sample;\n+     * <strong><code> m1</code></strong> is the mean of the first sample;\n      * <strong><code> m2</code></strong> is the mean of the second sample;\n      * <strong><code> var1</code></strong> is the variance of the first sample;\n-     * <strong><code> var2</code></strong> is the variance of the second sample;  \n+     * <strong><code> var2</code></strong> is the variance of the second sample;\n      * </p><p>\n      * <strong>Preconditions</strong>: <ul>\n      * <li>The observed array lengths must both be at least 2.\n     /**\n      * Computes a 2-sample t statistic </a>, comparing the means of the datasets\n      * described by two {@link StatisticalSummary} instances, without the\n-     * assumption of equal subpopulation variances.  Use \n+     * assumption of equal subpopulation variances.  Use\n      * {@link #homoscedasticT(StatisticalSummary, StatisticalSummary)} to\n      * compute a t-statistic under the equal variances assumption.\n      * <p>\n      * <p>\n      * &nbsp;&nbsp; <code>  t = (m1 - m2) / sqrt(var1/n1 + var2/n2)</code>\n      * </p><p>\n-     * where <strong><code>n1</code></strong> is the size of the first sample; \n-     * <strong><code> n2</code></strong> is the size of the second sample; \n-     * <strong><code> m1</code></strong> is the mean of the first sample;  \n+     * where <strong><code>n1</code></strong> is the size of the first sample;\n+     * <strong><code> n2</code></strong> is the size of the second sample;\n+     * <strong><code> m1</code></strong> is the mean of the first sample;\n      * <strong><code> m2</code></strong> is the mean of the second sample\n-     * <strong><code> var1</code></strong> is the variance of the first sample;  \n+     * <strong><code> var1</code></strong> is the variance of the first sample;\n      * <strong><code> var2</code></strong> is the variance of the second sample\n      * </p><p>\n      * <strong>Preconditions</strong>: <ul>\n      * @return t statistic\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n-    public double t(StatisticalSummary sampleStats1, \n+    public double t(StatisticalSummary sampleStats1,\n                     StatisticalSummary sampleStats2)\n     throws IllegalArgumentException {\n         checkSampleData(sampleStats1);\n         checkSampleData(sampleStats2);\n-        return t(sampleStats1.getMean(), sampleStats2.getMean(), \n+        return t(sampleStats1.getMean(), sampleStats2.getMean(),\n                 sampleStats1.getVariance(), sampleStats2.getVariance(),\n                 sampleStats1.getN(), sampleStats2.getN());\n     }\n-    \n+\n     /**\n      * Computes a 2-sample t statistic, comparing the means of the datasets\n      * described by two {@link StatisticalSummary} instances, under the\n      * assumption of equal subpopulation variances.  To compute a t-statistic\n-     * without the equal variances assumption, use \n+     * without the equal variances assumption, use\n      * {@link #t(StatisticalSummary, StatisticalSummary)}.\n      * <p>\n      * This statistic can be used to perform a (homoscedastic) two-sample\n      * <p>\n      * &nbsp;&nbsp;<code>  t = (m1 - m2) / (sqrt(1/n1 +1/n2) sqrt(var))</code>\n      * </p><p>\n-     * where <strong><code>n1</code></strong> is the size of first sample; \n-     * <strong><code> n2</code></strong> is the size of second sample; \n-     * <strong><code> m1</code></strong> is the mean of first sample;  \n+     * where <strong><code>n1</code></strong> is the size of first sample;\n+     * <strong><code> n2</code></strong> is the size of second sample;\n+     * <strong><code> m1</code></strong> is the mean of first sample;\n      * <strong><code> m2</code></strong> is the mean of second sample\n      * and <strong><code>var</code></strong> is the pooled variance estimate:\n      * </p><p>\n      * <code>var = sqrt(((n1 - 1)var1 + (n2 - 1)var2) / ((n1-1) + (n2-1)))</code>\n-     * <p> \n+     * <p>\n      * with <strong><code>var1<code></strong> the variance of the first sample and\n      * <strong><code>var2</code></strong> the variance of the second sample.\n      * </p><p>\n      * @return t statistic\n      * @throws IllegalArgumentException if the precondition is not met\n      */\n-    public double homoscedasticT(StatisticalSummary sampleStats1, \n+    public double homoscedasticT(StatisticalSummary sampleStats1,\n             StatisticalSummary sampleStats2)\n     throws IllegalArgumentException {\n         checkSampleData(sampleStats1);\n         checkSampleData(sampleStats2);\n-        return homoscedasticT(sampleStats1.getMean(), sampleStats2.getMean(), \n-                sampleStats1.getVariance(), sampleStats2.getVariance(), \n+        return homoscedasticT(sampleStats1.getMean(), sampleStats2.getMean(),\n+                sampleStats1.getVariance(), sampleStats2.getVariance(),\n                 sampleStats1.getN(), sampleStats2.getN());\n     }\n \n      /**\n-     * Returns the <i>observed significance level</i>, or \n-     * <i>p-value</i>, associated with a one-sample, two-tailed t-test \n+     * Returns the <i>observed significance level</i>, or\n+     * <i>p-value</i>, associated with a one-sample, two-tailed t-test\n      * comparing the mean of the input array with the constant <code>mu</code>.\n      * <p>\n      * The number returned is the smallest significance level\n-     * at which one can reject the null hypothesis that the mean equals \n+     * at which one can reject the null hypothesis that the mean equals\n      * <code>mu</code> in favor of the two-sided alternative that the mean\n-     * is different from <code>mu</code>. For a one-sided test, divide the \n+     * is different from <code>mu</code>. For a one-sided test, divide the\n      * returned value by 2.</p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the test depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">here</a>\n      * </p><p>\n      * <strong>Preconditions</strong>: <ul>\n      * two-sided t-test</a> evaluating the null hypothesis that the mean of the population from\n      * which <code>sample</code> is drawn equals <code>mu</code>.\n      * <p>\n-     * Returns <code>true</code> iff the null hypothesis can be \n-     * rejected with confidence <code>1 - alpha</code>.  To \n+     * Returns <code>true</code> iff the null hypothesis can be\n+     * rejected with confidence <code>1 - alpha</code>.  To\n      * perform a 1-sided test, use <code>alpha * 2</code>\n      * </p><p>\n      * <strong>Examples:</strong><br><ol>\n      * the 95% level, use <br><code>tTest(mu, sample, 0.05) </code>\n      * </li>\n      * <li>To test the (one-sided) hypothesis <code> sample mean < mu </code>\n-     * at the 99% level, first verify that the measured sample mean is less \n-     * than <code>mu</code> and then use \n+     * at the 99% level, first verify that the measured sample mean is less\n+     * than <code>mu</code> and then use\n      * <br><code>tTest(mu, sample, 0.02) </code>\n      * </li></ol></p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n-     * The validity of the test depends on the assumptions of the one-sample \n-     * parametric t-test procedure, as discussed \n+     * The validity of the test depends on the assumptions of the one-sample\n+     * parametric t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/sg_glos.html#one-sample\">here</a>\n      * </p><p>\n      * <strong>Preconditions</strong>: <ul>\n     }\n \n     /**\n-     * Returns the <i>observed significance level</i>, or \n-     * <i>p-value</i>, associated with a one-sample, two-tailed t-test \n+     * Returns the <i>observed significance level</i>, or\n+     * <i>p-value</i>, associated with a one-sample, two-tailed t-test\n      * comparing the mean of the dataset described by <code>sampleStats</code>\n      * with the constant <code>mu</code>.\n      * <p>\n      * The number returned is the smallest significance level\n-     * at which one can reject the null hypothesis that the mean equals \n+     * at which one can reject the null hypothesis that the mean equals\n      * <code>mu</code> in favor of the two-sided alternative that the mean\n-     * is different from <code>mu</code>. For a one-sided test, divide the \n+     * is different from <code>mu</code>. For a one-sided test, divide the\n      * returned value by 2.</p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the test depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n      * here</a></p>\n      * <p>\n      * the 95% level, use <br><code>tTest(mu, sampleStats, 0.05) </code>\n      * </li>\n      * <li>To test the (one-sided) hypothesis <code> sample mean < mu </code>\n-     * at the 99% level, first verify that the measured sample mean is less \n-     * than <code>mu</code> and then use \n+     * at the 99% level, first verify that the measured sample mean is less\n+     * than <code>mu</code> and then use\n      * <br><code>tTest(mu, sampleStats, 0.02) </code>\n      * </li></ol></p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n-     * The validity of the test depends on the assumptions of the one-sample \n-     * parametric t-test procedure, as discussed \n+     * The validity of the test depends on the assumptions of the one-sample\n+     * parametric t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/sg_glos.html#one-sample\">here</a>\n      * </p><p>\n      * <strong>Preconditions</strong>: <ul>\n     }\n \n     /**\n-     * Returns the <i>observed significance level</i>, or \n-     * <i>p-value</i>, associated with a two-sample, two-tailed t-test \n+     * Returns the <i>observed significance level</i>, or\n+     * <i>p-value</i>, associated with a two-sample, two-tailed t-test\n      * comparing the means of the input arrays.\n      * <p>\n      * The number returned is the smallest significance level\n      * at which one can reject the null hypothesis that the two means are\n-     * equal in favor of the two-sided alternative that they are different. \n+     * equal in favor of the two-sided alternative that they are different.\n      * For a one-sided test, divide the returned value by 2.</p>\n      * <p>\n      * The test does not assume that the underlying popuation variances are\n-     * equal  and it uses approximated degrees of freedom computed from the \n+     * equal  and it uses approximated degrees of freedom computed from the\n      * sample data to compute the p-value.  The t-statistic used is as defined in\n      * {@link #t(double[], double[])} and the Welch-Satterthwaite approximation\n-     * to the degrees of freedom is used, \n-     * as described \n+     * to the degrees of freedom is used,\n+     * as described\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm\">\n      * here.</a>  To perform the test under the assumption of equal subpopulation\n      * variances, use {@link #homoscedasticTTest(double[], double[])}.</p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the p-value depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n      * here</a></p>\n      * <p>\n                 StatUtils.variance(sample1), StatUtils.variance(sample2),\n                 sample1.length, sample2.length);\n     }\n-    \n-    /**\n-     * Returns the <i>observed significance level</i>, or \n-     * <i>p-value</i>, associated with a two-sample, two-tailed t-test \n+\n+    /**\n+     * Returns the <i>observed significance level</i>, or\n+     * <i>p-value</i>, associated with a two-sample, two-tailed t-test\n      * comparing the means of the input arrays, under the assumption that\n      * the two samples are drawn from subpopulations with equal variances.\n      * To perform the test without the equal variances assumption, use\n      * <p>\n      * The number returned is the smallest significance level\n      * at which one can reject the null hypothesis that the two means are\n-     * equal in favor of the two-sided alternative that they are different. \n+     * equal in favor of the two-sided alternative that they are different.\n      * For a one-sided test, divide the returned value by 2.</p>\n      * <p>\n      * A pooled variance estimate is used to compute the t-statistic.  See\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the p-value depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n      * here</a></p>\n      * <p>\n     throws IllegalArgumentException, MathException {\n         checkSampleData(sample1);\n         checkSampleData(sample2);\n-        return homoscedasticTTest(StatUtils.mean(sample1), \n+        return homoscedasticTTest(StatUtils.mean(sample1),\n                 StatUtils.mean(sample2), StatUtils.variance(sample1),\n-                StatUtils.variance(sample2), sample1.length, \n+                StatUtils.variance(sample2), sample1.length,\n                 sample2.length);\n     }\n-    \n+\n \n      /**\n-     * Performs a \n+     * Performs a\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm\">\n-     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code> \n-     * and <code>sample2</code> are drawn from populations with the same mean, \n+     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code>\n+     * and <code>sample2</code> are drawn from populations with the same mean,\n      * with significance level <code>alpha</code>.  This test does not assume\n      * that the subpopulation variances are equal.  To perform the test assuming\n-     * equal variances, use \n+     * equal variances, use\n      * {@link #homoscedasticTTest(double[], double[], double)}.\n      * <p>\n      * Returns <code>true</code> iff the null hypothesis that the means are\n-     * equal can be rejected with confidence <code>1 - alpha</code>.  To \n+     * equal can be rejected with confidence <code>1 - alpha</code>.  To\n      * perform a 1-sided test, use <code>alpha / 2</code></p>\n      * <p>\n      * See {@link #t(double[], double[])} for the formula used to compute the\n      * t-statistic.  Degrees of freedom are approximated using the\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm\">\n      * Welch-Satterthwaite approximation.</a></p>\n-      \n+\n      * <p>\n      * <strong>Examples:</strong><br><ol>\n      * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at\n-     * the 95% level,  use \n+     * the 95% level,  use\n      * <br><code>tTest(sample1, sample2, 0.05). </code>\n      * </li>\n      * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code> at\n      * the 99% level, first verify that the measured  mean of <code>sample 1</code>\n-     * is less than the mean of <code>sample 2</code> and then use \n+     * is less than the mean of <code>sample 2</code> and then use\n      * <br><code>tTest(sample1, sample2, 0.02) </code>\n      * </li></ol></p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the test depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n      * here</a></p>\n      * <p>\n      * @param sample1 array of sample data values\n      * @param sample2 array of sample data values\n      * @param alpha significance level of the test\n-     * @return true if the null hypothesis can be rejected with \n+     * @return true if the null hypothesis can be rejected with\n      * confidence 1 - alpha\n      * @throws IllegalArgumentException if the preconditions are not met\n      * @throws MathException if an error occurs performing the test\n         checkSignificanceLevel(alpha);\n         return (tTest(sample1, sample2) < alpha);\n     }\n-    \n-    /**\n-     * Performs a \n+\n+    /**\n+     * Performs a\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm\">\n-     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code> \n-     * and <code>sample2</code> are drawn from populations with the same mean, \n+     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code>\n+     * and <code>sample2</code> are drawn from populations with the same mean,\n      * with significance level <code>alpha</code>,  assuming that the\n-     * subpopulation variances are equal.  Use \n+     * subpopulation variances are equal.  Use\n      * {@link #tTest(double[], double[], double)} to perform the test without\n      * the assumption of equal variances.\n      * <p>\n      * Returns <code>true</code> iff the null hypothesis that the means are\n-     * equal can be rejected with confidence <code>1 - alpha</code>.  To \n+     * equal can be rejected with confidence <code>1 - alpha</code>.  To\n      * perform a 1-sided test, use <code>alpha * 2.</code>  To perform the test\n-     * without the assumption of equal subpopulation variances, use \n+     * without the assumption of equal subpopulation variances, use\n      * {@link #tTest(double[], double[], double)}.</p>\n      * <p>\n      * A pooled variance estimate is used to compute the t-statistic. See\n      * the 95% level, use <br><code>tTest(sample1, sample2, 0.05). </code>\n      * </li>\n      * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2, </code>\n-     * at the 99% level, first verify that the measured mean of \n+     * at the 99% level, first verify that the measured mean of\n      * <code>sample 1</code> is less than the mean of <code>sample 2</code>\n      * and then use\n      * <br><code>tTest(sample1, sample2, 0.02) </code>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the test depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n      * here</a></p>\n      * <p>\n      * @param sample1 array of sample data values\n      * @param sample2 array of sample data values\n      * @param alpha significance level of the test\n-     * @return true if the null hypothesis can be rejected with \n+     * @return true if the null hypothesis can be rejected with\n      * confidence 1 - alpha\n      * @throws IllegalArgumentException if the preconditions are not met\n      * @throws MathException if an error occurs performing the test\n     }\n \n      /**\n-     * Returns the <i>observed significance level</i>, or \n-     * <i>p-value</i>, associated with a two-sample, two-tailed t-test \n+     * Returns the <i>observed significance level</i>, or\n+     * <i>p-value</i>, associated with a two-sample, two-tailed t-test\n      * comparing the means of the datasets described by two StatisticalSummary\n      * instances.\n      * <p>\n      * The number returned is the smallest significance level\n      * at which one can reject the null hypothesis that the two means are\n-     * equal in favor of the two-sided alternative that they are different. \n+     * equal in favor of the two-sided alternative that they are different.\n      * For a one-sided test, divide the returned value by 2.</p>\n      * <p>\n      * The test does not assume that the underlying popuation variances are\n-     * equal  and it uses approximated degrees of freedom computed from the \n+     * equal  and it uses approximated degrees of freedom computed from the\n      * sample data to compute the p-value.   To perform the test assuming\n-     * equal variances, use \n+     * equal variances, use\n      * {@link #homoscedasticTTest(StatisticalSummary, StatisticalSummary)}.</p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the p-value depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n      * here</a></p>\n      * <p>\n         checkSampleData(sampleStats1);\n         checkSampleData(sampleStats2);\n         return tTest(sampleStats1.getMean(), sampleStats2.getMean(), sampleStats1.getVariance(),\n-                sampleStats2.getVariance(), sampleStats1.getN(), \n+                sampleStats2.getVariance(), sampleStats1.getN(),\n                 sampleStats2.getN());\n     }\n-    \n-    /**\n-     * Returns the <i>observed significance level</i>, or \n-     * <i>p-value</i>, associated with a two-sample, two-tailed t-test \n+\n+    /**\n+     * Returns the <i>observed significance level</i>, or\n+     * <i>p-value</i>, associated with a two-sample, two-tailed t-test\n      * comparing the means of the datasets described by two StatisticalSummary\n      * instances, under the hypothesis of equal subpopulation variances. To\n      * perform a test without the equal variances assumption, use\n      * <p>\n      * The number returned is the smallest significance level\n      * at which one can reject the null hypothesis that the two means are\n-     * equal in favor of the two-sided alternative that they are different. \n+     * equal in favor of the two-sided alternative that they are different.\n      * For a one-sided test, divide the returned value by 2.</p>\n      * <p>\n      * See {@link #homoscedasticT(double[], double[])} for the formula used to\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the p-value depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">here</a>\n      * </p><p>\n      * <strong>Preconditions</strong>: <ul>\n      * @throws IllegalArgumentException if the precondition is not met\n      * @throws MathException if an error occurs computing the p-value\n      */\n-    public double homoscedasticTTest(StatisticalSummary sampleStats1, \n+    public double homoscedasticTTest(StatisticalSummary sampleStats1,\n                                      StatisticalSummary sampleStats2)\n     throws IllegalArgumentException, MathException {\n         checkSampleData(sampleStats1);\n         checkSampleData(sampleStats2);\n         return homoscedasticTTest(sampleStats1.getMean(),\n                 sampleStats2.getMean(), sampleStats1.getVariance(),\n-                sampleStats2.getVariance(), sampleStats1.getN(), \n+                sampleStats2.getVariance(), sampleStats1.getN(),\n                 sampleStats2.getN());\n     }\n \n     /**\n-     * Performs a \n+     * Performs a\n      * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm\">\n-     * two-sided t-test</a> evaluating the null hypothesis that \n+     * two-sided t-test</a> evaluating the null hypothesis that\n      * <code>sampleStats1</code> and <code>sampleStats2</code> describe\n      * datasets drawn from populations with the same mean, with significance\n      * level <code>alpha</code>.   This test does not assume that the\n      * {@link #homoscedasticTTest(StatisticalSummary, StatisticalSummary)}.\n      * <p>\n      * Returns <code>true</code> iff the null hypothesis that the means are\n-     * equal can be rejected with confidence <code>1 - alpha</code>.  To \n+     * equal can be rejected with confidence <code>1 - alpha</code>.  To\n      * perform a 1-sided test, use <code>alpha * 2</code></p>\n      * <p>\n      * See {@link #t(double[], double[])} for the formula used to compute the\n      * <p>\n      * <strong>Examples:</strong><br><ol>\n      * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at\n-     * the 95%, use \n+     * the 95%, use\n      * <br><code>tTest(sampleStats1, sampleStats2, 0.05) </code>\n      * </li>\n      * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code>\n-     * at the 99% level,  first verify that the measured mean of  \n+     * at the 99% level,  first verify that the measured mean of\n      * <code>sample 1</code> is less than  the mean of <code>sample 2</code>\n-     * and then use \n+     * and then use\n      * <br><code>tTest(sampleStats1, sampleStats2, 0.02) </code>\n      * </li></ol></p>\n      * <p>\n      * <strong>Usage Note:</strong><br>\n      * The validity of the test depends on the assumptions of the parametric\n-     * t-test procedure, as discussed \n+     * t-test procedure, as discussed\n      * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n      * here</a></p>\n      * <p>\n      * @param sampleStats1 StatisticalSummary describing sample data values\n      * @param sampleStats2 StatisticalSummary describing sample data values\n      * @param alpha significance level of the test\n-     * @return true if the null hypothesis can be rejected with \n+     * @return true if the null hypothesis can be rejected with\n      * confidence 1 - alpha\n      * @throws IllegalArgumentException if the preconditions are not met\n      * @throws MathException if an error occurs performing the test\n         checkSignificanceLevel(alpha);\n         return (tTest(sampleStats1, sampleStats2) < alpha);\n     }\n-    \n-    //----------------------------------------------- Protected methods \n+\n+    //----------------------------------------------- Protected methods\n \n     /**\n      * Computes approximate degrees of freedom for 2-sample t-test.\n-     * \n+     *\n      * @param v1 first sample variance\n      * @param v2 second sample variance\n      * @param n1 first sample n\n \n     /**\n      * Computes t test statistic for 1-sample t-test.\n-     * \n+     *\n      * @param m sample mean\n      * @param mu constant to test against\n      * @param v sample variance\n     protected double t(double m, double mu, double v, double n) {\n         return (m - mu) / Math.sqrt(v / n);\n     }\n-    \n+\n     /**\n      * Computes t test statistic for 2-sample t-test.\n      * <p>\n      * Does not assume that subpopulation variances are equal.</p>\n-     * \n+     *\n      * @param m1 first sample mean\n      * @param m2 second sample mean\n      * @param v1 first sample variance\n             double n2)  {\n             return (m1 - m2) / Math.sqrt((v1 / n1) + (v2 / n2));\n     }\n-    \n+\n     /**\n      * Computes t test statistic for 2-sample t-test under the hypothesis\n      * of equal subpopulation variances.\n-     * \n+     *\n      * @param m1 first sample mean\n      * @param m2 second sample mean\n      * @param v1 first sample variance\n      */\n     protected double homoscedasticT(double m1, double m2,  double v1,\n             double v2, double n1, double n2)  {\n-            double pooledVariance = ((n1  - 1) * v1 + (n2 -1) * v2 ) / (n1 + n2 - 2); \n+            double pooledVariance = ((n1  - 1) * v1 + (n2 -1) * v2 ) / (n1 + n2 - 2);\n             return (m1 - m2) / Math.sqrt(pooledVariance * (1d / n1 + 1d / n2));\n     }\n-    \n+\n     /**\n      * Computes p-value for 2-sided, 1-sample t-test.\n-     * \n+     *\n      * @param m sample mean\n      * @param mu constant to test against\n      * @param v sample variance\n      * <p>\n      * Does not assume subpopulation variances are equal. Degrees of freedom\n      * are estimated from the data.</p>\n-     * \n+     *\n      * @param m1 first sample mean\n      * @param m2 second sample mean\n      * @param v1 first sample variance\n      * @return p-value\n      * @throws MathException if an error occurs computing the p-value\n      */\n-    protected double tTest(double m1, double m2, double v1, double v2, \n+    protected double tTest(double m1, double m2, double v1, double v2,\n             double n1, double n2)\n     throws MathException {\n         double t = Math.abs(t(m1, m2, v1, v2, n1, n2));\n         distribution.setDegreesOfFreedom(degreesOfFreedom);\n         return 2.0 * distribution.cumulativeProbability(-t);\n     }\n-    \n+\n     /**\n      * Computes p-value for 2-sided, 2-sample t-test, under the assumption\n      * of equal subpopulation variances.\n      * <p>\n      * The sum of the sample sizes minus 2 is used as degrees of freedom.</p>\n-     * \n+     *\n      * @param m1 first sample mean\n      * @param m2 second sample mean\n      * @param v1 first sample variance\n         distribution.setDegreesOfFreedom(degreesOfFreedom);\n         return 2.0 * distribution.cumulativeProbability(-t);\n     }\n-    \n+\n     /**\n      * Modify the distribution used to compute inference statistics.\n      * @param value the new distribution\n--- a/src/main/java/org/apache/commons/math/stat/inference/TestUtils.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/TestUtils.java\n  * perform inference tests.\n  *\n  * @since 1.1\n- * @version $Revision$ $Date$ \n+ * @version $Revision$ $Date$\n  */\n public class TestUtils  {\n     /**\n     protected TestUtils() {\n         super();\n     }\n-    \n+\n     /** Singleton TTest instance using default implementation. */\n     private static TTest tTest = new TTestImpl();\n-   \n+\n     /** Singleton ChiSquareTest instance using default implementation. */\n-    private static ChiSquareTest chiSquareTest = \n+    private static ChiSquareTest chiSquareTest =\n         new ChiSquareTestImpl();\n-    \n+\n     /** Singleton ChiSquareTest instance using default implementation. */\n-    private static UnknownDistributionChiSquareTest unknownDistributionChiSquareTest = \n+    private static UnknownDistributionChiSquareTest unknownDistributionChiSquareTest =\n         new ChiSquareTestImpl();\n-    \n+\n     /** Singleton OneWayAnova instance using default implementation. */\n     private static OneWayAnova oneWayAnova =\n         new OneWayAnovaImpl();\n-    \n+\n     /**\n      * Set the (singleton) TTest instance.\n-     * \n+     *\n      * @param chiSquareTest the new instance to use\n      * @since 1.2\n      */\n     public static void setChiSquareTest(TTest chiSquareTest) {\n         TestUtils.tTest = chiSquareTest;\n     }\n-    \n+\n     /**\n      * Return a (singleton) TTest instance.  Does not create a new instance.\n-     * \n+     *\n      * @return a TTest instance\n      */\n     public static TTest getTTest() {\n         return tTest;\n     }\n-    \n+\n     /**\n      * Set the (singleton) ChiSquareTest instance.\n-     * \n+     *\n      * @param chiSquareTest the new instance to use\n      * @since 1.2\n      */\n     public static void setChiSquareTest(ChiSquareTest chiSquareTest) {\n         TestUtils.chiSquareTest = chiSquareTest;\n     }\n-    \n+\n     /**\n      * Return a (singleton) ChiSquareTest instance.  Does not create a new instance.\n-     * \n+     *\n      * @return a ChiSquareTest instance\n      */\n     public static ChiSquareTest getChiSquareTest() {\n         return chiSquareTest;\n     }\n-    \n+\n     /**\n      * Set the (singleton) UnknownDistributionChiSquareTest instance.\n-     * \n+     *\n      * @param unknownDistributionChiSquareTest the new instance to use\n      * @since 1.2\n      */\n     public static void setUnknownDistributionChiSquareTest(UnknownDistributionChiSquareTest unknownDistributionChiSquareTest) {\n         TestUtils.unknownDistributionChiSquareTest = unknownDistributionChiSquareTest;\n     }\n-    \n+\n     /**\n      * Return a (singleton) UnknownDistributionChiSquareTest instance.  Does not create a new instance.\n-     * \n+     *\n      * @return a UnknownDistributionChiSquareTest instance\n      */\n     public static UnknownDistributionChiSquareTest getUnknownDistributionChiSquareTest() {\n         return unknownDistributionChiSquareTest;\n     }\n-    \n+\n     /**\n      * Set the (singleton) OneWayAnova instance\n-     * \n+     *\n      * @param oneWayAnova the new instance to use\n      * @since 1.2\n      */\n     public static void setOneWayAnova(OneWayAnova oneWayAnova) {\n         TestUtils.oneWayAnova = oneWayAnova;\n     }\n-    \n+\n     /**\n      * Return a (singleton) OneWayAnova instance.  Does not create a new instance.\n-     * \n+     *\n      * @return a OneWayAnova instance\n      * @since 1.2\n      */\n     public static OneWayAnova getOneWayAnova() {\n         return oneWayAnova;\n     }\n-    \n-    \n+\n+\n     // CHECKSTYLE: stop JavadocMethodCheck\n \n     /**\n     /**\n      * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquare(long[][])\n      */\n-    public static double chiSquare(long[][] counts) \n+    public static double chiSquare(long[][] counts)\n         throws IllegalArgumentException {\n         return chiSquareTest.chiSquare(counts);\n     }\n         throws IllegalArgumentException, MathException {\n         return unknownDistributionChiSquareTest.chiSquareTestDataSetsComparison(observed1, observed2, alpha);\n     }\n-    \n+\n     /**\n      * @see org.apache.commons.math.stat.inference.OneWayAnova#anovaFValue(Collection)\n      *\n     throws IllegalArgumentException, MathException {\n         return oneWayAnova.anovaFValue(categoryData);\n     }\n-    \n+\n     /**\n      * @see org.apache.commons.math.stat.inference.OneWayAnova#anovaPValue(Collection)\n-     * \n+     *\n      * @since 1.2\n      */\n     public static double oneWayAnovaPValue(Collection<double[]> categoryData)\n     throws IllegalArgumentException, MathException {\n         return oneWayAnova.anovaPValue(categoryData);\n     }\n-    \n+\n     /**\n      * @see org.apache.commons.math.stat.inference.OneWayAnova#anovaTest(Collection,double)\n      *\n--- a/src/main/java/org/apache/commons/math/stat/inference/UnknownDistributionChiSquareTest.java\n+++ b/src/main/java/org/apache/commons/math/stat/inference/UnknownDistributionChiSquareTest.java\n  * but provided by one sample. We compare the second sample against the first.</p>\n  *\n  * @version $Revision$ $Date$\n- * @since 1.2 \n+ * @since 1.2\n  */\n public interface UnknownDistributionChiSquareTest extends ChiSquareTest {\n-     \n+\n     /**\n-     * <p>Computes a \n+     * <p>Computes a\n      * <a href=\"http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/chi2samp.htm\">\n      * Chi-Square two sample test statistic</a> comparing bin frequency counts\n      * in <code>observed1</code> and <code>observed2</code>.  The\n      * same.  The formula used to compute the test statistic is</p>\n      * <code>\n      * &sum;[(K * observed1[i] - observed2[i]/K)<sup>2</sup> / (observed1[i] + observed2[i])]\n-     * </code> where \n+     * </code> where\n      * <br/><code>K = &sqrt;[&sum(observed2 / &sum;(observed1)]</code>\n      * </p>\n      * <p>This statistic can be used to perform a Chi-Square test evaluating the null hypothesis that\n      * <p>Returns the <i>observed significance level</i>, or <a href=\n      * \"http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue\">\n      * p-value</a>, associated with a Chi-Square two sample test comparing\n-     * bin frequency counts in <code>observed1</code> and \n+     * bin frequency counts in <code>observed1</code> and\n      * <code>observed2</code>.\n      * </p>\n      * <p>The number returned is the smallest significance level at which one\n      * significance level <code>alpha</code>.  Returns true iff the null\n      * hypothesis can be rejected with 100 * (1 - alpha) percent confidence.\n      * </p>\n-     * <p>See {@link #chiSquareDataSetsComparison(long[], long[])} for \n+     * <p>See {@link #chiSquareDataSetsComparison(long[], long[])} for\n      * details on the formula used to compute the Chisquare statistic used\n      * in the test. The degrees of of freedom used to perform the test is\n      * one less than the common length of the input observed count arrays.\n--- a/src/main/java/org/apache/commons/math/stat/ranking/NaNStrategy.java\n+++ b/src/main/java/org/apache/commons/math/stat/ranking/NaNStrategy.java\n  * @version $Revision$ $Date$\n  */\n public enum NaNStrategy {\n-    \n+\n     /** NaNs are considered minimal in the ordering */\n     MINIMAL,\n-    \n+\n     /** NaNs are considered maximal in the ordering */\n     MAXIMAL,\n-    \n+\n     /** NaNs are removed before computing ranks */\n     REMOVED,\n-    \n+\n     /** NaNs are left in place */\n     FIXED\n }\n--- a/src/main/java/org/apache/commons/math/stat/ranking/NaturalRanking.java\n+++ b/src/main/java/org/apache/commons/math/stat/ranking/NaturalRanking.java\n /**\n  * <p> Ranking based on the natural ordering on doubles.</p>\n  * <p>NaNs are treated according to the configured {@link NaNStrategy} and ties\n- * are handled using the selected {@link TiesStrategy}. \n+ * are handled using the selected {@link TiesStrategy}.\n  * Configuration settings are supplied in optional constructor arguments.\n  * Defaults are {@link NaNStrategy#MAXIMAL} and {@link TiesStrategy#AVERAGE},\n- * respectively. When using {@link TiesStrategy#RANDOM}, a \n+ * respectively. When using {@link TiesStrategy#RANDOM}, a\n  * {@link RandomGenerator} may be supplied as a constructor argument.</p>\n  * <p>Examples:\n  * <table border=\"1\" cellpadding=\"3\">\n  * <td>MINIMAL</td>\n  * <td>MAXIMUM</td>\n  * <td>(6, 5, 7, 8, 5, 9, 2, 2, 5)</td></tr></table></p>\n- * \n+ *\n  * @since 2.0\n  * @version $Revision$ $Date$\n  */\n public class NaturalRanking implements RankingAlgorithm {\n-   \n+\n     /** NaN strategy - defaults to NaNs maximal */\n     private final NaNStrategy nanStrategy;\n-    \n+\n     /** Ties strategy - defaults to ties averaged */\n     private final TiesStrategy tiesStrategy;\n-    \n+\n     /** Source of random data - used only when ties strategy is RANDOM */\n     private final RandomData randomData;\n-    \n+\n     /** default NaN strategy */\n     public static final NaNStrategy DEFAULT_NAN_STRATEGY = NaNStrategy.MAXIMAL;\n-    \n+\n     /** default ties strategy */\n     public static final TiesStrategy DEFAULT_TIES_STRATEGY = TiesStrategy.AVERAGE;\n-    \n+\n     /**\n      * Create a NaturalRanking with default strategies for handling ties and NaNs.\n      */\n \n     /**\n      * Create a NaturalRanking with the given TiesStrategy.\n-     * \n+     *\n      * @param tiesStrategy the TiesStrategy to use\n      */\n     public NaturalRanking(TiesStrategy tiesStrategy) {\n \n     /**\n      * Create a NaturalRanking with the given NaNStrategy.\n-     * \n+     *\n      * @param nanStrategy the NaNStrategy to use\n      */\n     public NaturalRanking(NaNStrategy nanStrategy) {\n         super();\n         this.nanStrategy = nanStrategy;\n         tiesStrategy = DEFAULT_TIES_STRATEGY;\n-        randomData = null; \n+        randomData = null;\n     }\n \n     /**\n      * Create a NaturalRanking with the given NaNStrategy and TiesStrategy.\n-     * \n+     *\n      * @param nanStrategy NaNStrategy to use\n      * @param tiesStrategy TiesStrategy to use\n      */\n         this.tiesStrategy = tiesStrategy;\n         randomData = new RandomDataImpl();\n     }\n-    \n+\n     /**\n      * Create a NaturalRanking with TiesStrategy.RANDOM and the given\n      * RandomGenerator as the source of random data.\n-     * \n+     *\n      * @param randomGenerator source of random data\n      */\n     public NaturalRanking(RandomGenerator randomGenerator) {\n     /**\n      * Create a NaturalRanking with the given NaNStrategy, TiesStrategy.RANDOM\n      * and the given source of random data.\n-     * \n+     *\n      * @param nanStrategy NaNStrategy to use\n      * @param randomGenerator source of random data\n      */\n         this.tiesStrategy = TiesStrategy.RANDOM;\n         randomData = new RandomDataImpl(randomGenerator);\n     }\n-    \n+\n     /**\n      * Return the NaNStrategy\n-     * \n+     *\n      * @return returns the NaNStrategy\n      */\n     public NaNStrategy getNanStrategy() {\n \n     /**\n      * Return the TiesStrategy\n-     * \n+     *\n      * @return the TiesStrategy\n      */\n     public TiesStrategy getTiesStrategy() {\n      * Rank <code>data</code> using the natural ordering on Doubles, with\n      * NaN values handled according to <code>nanStrategy</code> and ties\n      * resolved using <code>tiesStrategy.</code>\n-     * \n+     *\n      * @param data array to be ranked\n      * @return array of ranks\n      */\n     public double[] rank(double[] data) {\n-        \n+\n         // Array recording initial positions of data to be ranked\n-        IntDoublePair[] ranks = new IntDoublePair[data.length];  \n+        IntDoublePair[] ranks = new IntDoublePair[data.length];\n         for (int i = 0; i < data.length; i++) {\n             ranks[i] = new IntDoublePair(data[i], i);\n         }\n-        \n+\n         // Recode, remove or record positions of NaNs\n         List<Integer> nanPositions = null;\n         switch (nanStrategy) {\n             default: // this should not happen unless NaNStrategy enum is changed\n                 throw MathRuntimeException.createInternalError(null);\n         }\n-        \n+\n         // Sort the IntDoublePairs\n         Arrays.sort(ranks);\n-        \n+\n         // Walk the sorted array, filling output array using sorted positions,\n         // resolving ties as we go\n         double[] out = new double[ranks.length];\n-        int pos = 1;  // position in sorted array \n+        int pos = 1;  // position in sorted array\n         out[ranks[0].getPosition()] = pos;\n         List<Integer> tiesTrace = new ArrayList<Integer>();\n         tiesTrace.add(ranks[0].getPosition());\n         }\n         return out;\n     }\n-    \n+\n     /**\n      * Returns an array that is a copy of the input array with IntDoublePairs\n      * having NaN values removed.\n-     * \n+     *\n      * @param ranks input array\n      * @return array with NaN-valued entries removed\n      */\n     }\n \n     /**\n-     * Recodes NaN values to the given value. \n-     * \n+     * Recodes NaN values to the given value.\n+     *\n      * @param ranks array to recode\n      * @param value the value to replace NaNs with\n      */\n             }\n         }\n     }\n-    \n+\n     /**\n      * Checks for presence of NaNs in <code>ranks.</code>\n-     * \n+     *\n      * @param ranks array to be searched for NaNs\n      * @return true iff ranks contains one or more NaNs\n      */\n         }\n         return false;\n     }\n-    \n+\n     /**\n      * Resolve a sequence of ties, using the configured {@link TiesStrategy}.\n      * The input <code>ranks</code> array is expected to take the same value\n      * tiesTrace = <2,4,7> and tiesStrategy is MINIMUM, ranks will be unchanged.\n      * The same array and trace with tiesStrategy AVERAGE will come out\n      * <5,8,3,6,3,7,1,3>.\n-     * \n-     * @param ranks array of ranks \n+     *\n+     * @param ranks array of ranks\n      * @param tiesTrace list of indices where <code>ranks</code> is constant\n-     * -- that is, for any i and j in TiesTrace, <code> ranks[i] == ranks[j] \n+     * -- that is, for any i and j in TiesTrace, <code> ranks[i] == ranks[j]\n      * </code>\n      */\n     private void resolveTie(double[] ranks, List<Integer> tiesTrace) {\n-        \n+\n         // constant value of ranks over tiesTrace\n         final double c = ranks[tiesTrace.get(0)];\n-        \n+\n         // length of sequence of tied ranks\n         final int length = tiesTrace.size();\n-        \n+\n         switch (tiesStrategy) {\n             case  AVERAGE:  // Replace ranks with average\n                 fill(ranks, tiesTrace, (2 * c + length - 1) / 2d);\n                 Iterator<Integer> iterator = tiesTrace.iterator();\n                 long f = Math.round(c);\n                 while (iterator.hasNext()) {\n-                    ranks[iterator.next()] = \n+                    ranks[iterator.next()] =\n                         randomData.nextLong(f, f + length - 1);\n                 }\n                 break;\n                 break;\n             default: // this should not happen unless TiesStrategy enum is changed\n                 throw MathRuntimeException.createInternalError(null);\n-        }   \n-    }\n-    \n+        }\n+    }\n+\n     /**\n      * Sets<code>data[i] = value</code> for each i in <code>tiesTrace.</code>\n-     * \n+     *\n      * @param data array to modify\n      * @param tiesTrace list of index values to set\n      * @param value value to set\n             data[iterator.next()] = value;\n         }\n     }\n-    \n+\n     /**\n      * Set <code>ranks[i] = Double.NaN</code> for each i in <code>nanPositions.</code>\n-     * \n+     *\n      * @param ranks array to modify\n      * @param nanPositions list of index values to set to <code>Double.NaN</code>\n      */\n         }\n         Iterator<Integer> iterator = nanPositions.iterator();\n         while (iterator.hasNext()) {\n-            ranks[iterator.next().intValue()] = Double.NaN;  \n-        }\n-        \n-    }\n-    \n+            ranks[iterator.next().intValue()] = Double.NaN;\n+        }\n+\n+    }\n+\n     /**\n      * Returns a list of indexes where <code>ranks</code> is <code>NaN.</code>\n-     * \n+     *\n      * @param ranks array to search for <code>NaNs</code>\n      * @return list of indexes i such that <code>ranks[i] = NaN</code>\n      */\n                 out.add(Integer.valueOf(i));\n             }\n         }\n-        return out;     \n-    }\n-    \n+        return out;\n+    }\n+\n     /**\n      * Represents the position of a double value in an ordering.\n      * Comparable interface is implemented so Arrays.sort can be used\n         /**\n          * Compare this IntDoublePair to another pair.\n          * Only the <strong>values</strong> are compared.\n-         * \n+         *\n          * @param other the other pair to compare this to\n          * @return result of <code>Double.compare(value, other.value)</code>\n          */\n--- a/src/main/java/org/apache/commons/math/stat/ranking/RankingAlgorithm.java\n+++ b/src/main/java/org/apache/commons/math/stat/ranking/RankingAlgorithm.java\n \n /**\n  * Interface representing a rank transformation.\n- * \n+ *\n  * @since 2.0\n  * @version $Revision$ $Date$\n  */\n     /**\n      * <p>Performs a rank transformation on the input data, returning an array\n      * of ranks.</p>\n-     * \n+     *\n      * <p>Ranks should be 1-based - that is, the smallest value\n      * returned in an array of ranks should be greater than or equal to one,\n      * rather than 0. Ranks should in general take integer values, though\n      * implementations may return averages or other floating point values\n      * to resolve ties in the input data.</p>\n-     * \n+     *\n      * @param data array of data to be ranked\n      * @return an array of ranks corresponding to the elements of the input array\n      */\n--- a/src/main/java/org/apache/commons/math/stat/ranking/TiesStrategy.java\n+++ b/src/main/java/org/apache/commons/math/stat/ranking/TiesStrategy.java\n  * of the first occurrence. For example, (1,3,4,3) is ranked as (1,2,4,2)</li>\n  * <li>MAXIMUM - Tied values are assigned the maximum applicable rank, or the rank\n  * of the last occurrence. For example, (1,3,4,3) is ranked as (1,3,4,3)</li>\n- * <li>AVERAGE - Tied values are assigned the average of the applicable ranks.  \n+ * <li>AVERAGE - Tied values are assigned the average of the applicable ranks.\n  * For example, (1,3,4,3) is ranked as (1,2.5,4,2.5)</li>\n  * <li>AVERAGE - Tied values are assigned a random integer rank from among the\n  * applicable values. The assigned rank will always be an integer, (inclusively)\n  * @version $Revision$ $Date$\n  */\n public enum TiesStrategy {\n-    \n+\n     /** Ties assigned sequential ranks in order of occurrence */\n     SEQUENTIAL,\n-    \n+\n     /** Ties get the minimum applicable rank */\n     MINIMUM,\n-    \n+\n     /** Ties get the maximum applicable rank */\n     MAXIMUM,\n-    \n+\n     /** Ties get the average of applicable ranks */\n     AVERAGE,\n-    \n+\n     /** Ties get a random integral value from among applicable ranks */\n     RANDOM\n }\n--- a/src/main/java/org/apache/commons/math/stat/regression/AbstractMultipleLinearRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/AbstractMultipleLinearRegression.java\n     /**\n      * Loads model x and y sample data from a flat array of data, overriding any previous sample.\n      * Assumes that rows are concatenated with y values first in each row.\n-     * \n+     *\n      * @param data input data array\n      * @param nobs number of observations (rows)\n      * @param nvars number of independent variables (columns, not counting y)\n         this.X = new Array2DRowRealMatrix(x);\n         this.Y = new ArrayRealVector(y);\n     }\n-    \n+\n     /**\n      * Loads new y sample data, overriding any previous sample\n-     * \n+     *\n      * @param y the [n,1] array representing the y sample\n      */\n     protected void newYSampleData(double[] y) {\n \n     /**\n      * Loads new x sample data, overriding any previous sample\n-     * \n+     *\n      * @param x the [n,k] array representing the x sample\n      */\n     protected void newXSampleData(double[][] x) {\n \n     /**\n      * Validates sample data.\n-     * \n+     *\n      * @param x the [n,k] array representing the x sample\n      * @param y the [n,1] array representing the y sample\n      * @throws IllegalArgumentException if the x and y array data are not\n \n     /**\n      * Validates sample data.\n-     * \n+     *\n      * @param x the [n,k] array representing the x sample\n      * @param covariance the [n,n] array representing the covariance matrix\n      * @throws IllegalArgumentException if the x sample data or covariance\n     public double[][] estimateRegressionParametersVariance() {\n         return calculateBetaVariance().getData();\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n \n     /**\n      * Calculates the beta of multiple linear regression in matrix notation.\n-     * \n+     *\n      * @return beta\n      */\n     protected abstract RealVector calculateBeta();\n     /**\n      * Calculates the beta variance of multiple linear regression in matrix\n      * notation.\n-     * \n+     *\n      * @return beta variance\n      */\n     protected abstract RealMatrix calculateBetaVariance();\n \n     /**\n      * Calculates the Y variance of multiple linear regression.\n-     * \n+     *\n      * @return Y variance\n      */\n     protected abstract double calculateYVariance();\n     /**\n      * Calculates the residuals of multiple linear regression in matrix\n      * notation.\n-     * \n+     *\n      * <pre>\n      * u = y - X * b\n      * </pre>\n-     * \n+     *\n      * @return The residuals [n,1] matrix\n      */\n     protected RealVector calculateResiduals() {\n--- a/src/main/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegression.java\n \n /**\n  * The GLS implementation of the multiple linear regression.\n- * \n+ *\n  * GLS assumes a general covariance matrix Omega of the error\n  * <pre>\n  * u ~ N(0, Omega)\n  * </pre>\n- * \n- * Estimated by GLS, \n+ *\n+ * Estimated by GLS,\n  * <pre>\n  * b=(X' Omega^-1 X)^-1X'Omega^-1 y\n  * </pre>\n  * @since 2.0\n  */\n public class GLSMultipleLinearRegression extends AbstractMultipleLinearRegression {\n-    \n+\n     /** Covariance matrix. */\n     private RealMatrix Omega;\n \n \n     /**\n      * Add the covariance data.\n-     * \n+     *\n      * @param omega the [n,n] array representing the covariance\n      */\n     protected void newCovarianceData(double[][] omega){\n         }\n         return OmegaInverse;\n     }\n-    \n+\n     /**\n      * Calculates beta by GLS.\n      * <pre>\n         double t = residuals.dotProduct(getOmegaInverse().operate(residuals));\n         return t / (X.getRowDimension() - X.getColumnDimension());\n     }\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/math/stat/regression/MultipleLinearRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/MultipleLinearRegression.java\n  * where y is an <code>n-vector</code> <b>regressand</b>, X is a <code>[n,k]</code> matrix whose <code>k</code> columns are called\n  * <b>regressors</b>, b is <code>k-vector</code> of <b>regression parameters</b> and <code>u</code> is an <code>n-vector</code>\n  * of <b>error terms</b> or <b>residuals</b>.\n- * \n- * The notation is quite standard in literature, \n+ *\n+ * The notation is quite standard in literature,\n  * cf eg <a href=\"http://www.econ.queensu.ca/ETM\">Davidson and MacKinnon, Econometrics Theory and Methods, 2004</a>.\n  * @version $Revision$ $Date$\n  * @since 2.0\n \n     /**\n      * Estimates the regression parameters b.\n-     * \n+     *\n      * @return The [k,1] array representing b\n      */\n     double[] estimateRegressionParameters();\n \n     /**\n      * Estimates the variance of the regression parameters, ie Var(b).\n-     * \n+     *\n      * @return The [k,k] array representing the variance of b\n      */\n     double[][] estimateRegressionParametersVariance();\n-    \n+\n     /**\n      * Estimates the residuals, ie u = y - X*b.\n-     * \n+     *\n      * @return The [n,1] array representing the residuals\n      */\n     double[] estimateResiduals();\n \n     /**\n      * Returns the variance of the regressand, ie Var(y).\n-     * \n+     *\n      * @return The double representing the variance of y\n      */\n     double estimateRegressandVariance();\n-    \n+\n     /**\n      * Returns the standard errors of the regression parameters.\n-     * \n+     *\n      * @return standard errors of estimated regression parameters\n      */\n      double[] estimateRegressionParametersStandardErrors();\n--- a/src/main/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n import org.apache.commons.math.linear.ArrayRealVector;\n \n /**\n- * <p>Implements ordinary least squares (OLS) to estimate the parameters of a \n+ * <p>Implements ordinary least squares (OLS) to estimate the parameters of a\n  * multiple linear regression model.</p>\n- * \n+ *\n  * <p>OLS assumes the covariance matrix of the error to be diagonal and with\n  * equal variance.</p>\n  * <p>\n  * u ~ N(0, &sigma;<sup>2</sup>I)\n  * </p>\n- * \n+ *\n  * <p>The regression coefficients, b, satisfy the normal equations:\n  * <p>\n  * X<sup>T</sup> X b = X<sup>T</sup> y\n  * </p>\n- * \n+ *\n  * <p>To solve the normal equations, this implementation uses QR decomposition\n  * of the X matrix. (See {@link QRDecompositionImpl} for details on the\n  * decomposition algorithm.)\n  * R b = Q<sup>T</sup> y\n  * </p>\n  * Given Q and R, the last equation is solved by back-subsitution.</p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n public class OLSMultipleLinearRegression extends AbstractMultipleLinearRegression {\n-    \n+\n     /** Cached QR decomposition of X matrix */\n     private QRDecomposition qr = null;\n \n     /**\n      * Loads model x and y sample data, overriding any previous sample.\n-     * \n+     *\n      * Computes and caches QR decomposition of the X matrix.\n      * @param y the [n,1] array representing the y sample\n      * @param x the [n,k] array representing the x sample\n         newYSampleData(y);\n         newXSampleData(x);\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n-     * \n+     *\n      * Computes and caches QR decomposition of the X matrix\n      */\n     @Override\n         super.newSampleData(data, nobs, nvars);\n         qr = new QRDecompositionImpl(X);\n     }\n-    \n+\n     /**\n      * <p>Compute the \"hat\" matrix.\n      * </p>\n      * hat matrix as Q I<sub>p</sub>Q<sup>T</sup> where I<sub>p</sub> is the\n      * p-dimensional identity matrix augmented by 0's.  This computational\n      * formula is from \"The Hat Matrix in Regression and ANOVA\",\n-     * David C. Hoaglin and Roy E. Welsch, \n+     * David C. Hoaglin and Roy E. Welsch,\n      * <i>The American Statistician</i>, Vol. 32, No. 1 (Feb., 1978), pp. 17-22.\n-     * \n+     *\n      * @return the hat matrix\n      */\n     public RealMatrix calculateHat() {\n                 }\n             }\n         }\n-        \n+\n         // Compute and return Hat matrix\n         return Q.multiply(augI).multiply(Q.transpose());\n     }\n-   \n+\n     /**\n      * Loads new x sample data, overriding any previous sample\n-     * \n+     *\n      * @param x the [n,k] array representing the x sample\n      */\n     @Override\n         this.X = new Array2DRowRealMatrix(x);\n         qr = new QRDecompositionImpl(X);\n     }\n-    \n+\n     /**\n      * Calculates regression coefficients using OLS.\n-     * \n+     *\n      * @return beta\n      */\n     @Override\n      * </p>\n      * <p>Uses QR decomposition to reduce (X<sup>T</sup>X)<sup>-1</sup>\n      * to (R<sup>T</sup>R)<sup>-1</sup>, with only the top p rows of\n-     * R included, where p = the length of the beta vector.</p> \n-     * \n+     * R included, where p = the length of the beta vector.</p>\n+     *\n      * @return The beta variance\n      */\n     @Override\n         RealMatrix Rinv = new LUDecompositionImpl(Raug).getSolver().getInverse();\n         return Rinv.multiply(Rinv.transpose());\n     }\n-    \n+\n \n     /**\n      * <p>Calculates the variance on the Y by OLS.\n         return residuals.dotProduct(residuals) /\n                (X.getRowDimension() - X.getColumnDimension());\n     }\n-    \n-    /** TODO:  Find a home for the following methods in the linear package */   \n-    \n+\n+    /** TODO:  Find a home for the following methods in the linear package */\n+\n     /**\n      * <p>Uses back substitution to solve the system</p>\n-     * \n+     *\n      * <p>coefficients X = constants</p>\n-     * \n-     * <p>coefficients must upper-triangular and constants must be a column \n+     *\n+     * <p>coefficients must upper-triangular and constants must be a column\n      * matrix.  The solution is returned as a column matrix.</p>\n-     * \n+     *\n      * <p>The number of columns in coefficients determines the length\n      * of the returned solution vector (column matrix).  If constants\n      * has more rows than coefficients has columns, excess rows are ignored.\n      * Similarly, extra (zero) rows in coefficients are ignored</p>\n-     * \n+     *\n      * @param coefficients upper-triangular coefficients matrix\n      * @param constants column RHS constants vector\n      * @return solution matrix as a column vector\n-     * \n+     *\n      */\n     private static RealVector solveUpperTriangular(RealMatrix coefficients,\n                                                    RealVector constants) {\n                 sum += coefficients.getEntry(index, j) * x[j];\n             }\n             x[index] = (constants.getEntry(index) - sum) / coefficients.getEntry(index, index);\n-        } \n+        }\n         return new ArrayRealVector(x);\n     }\n-    \n+\n     /**\n      * <p>Check if a matrix is upper-triangular.</p>\n-     * \n+     *\n      * <p>Makes sure all below-diagonal elements are within epsilon of 0.</p>\n-     * \n+     *\n      * @param m matrix to check\n      * @param epsilon maximum allowable absolute value for elements below\n      * the main diagonal\n-     * \n+     *\n      * @throws IllegalArgumentException if m is not upper-triangular\n      */\n     private static void checkUpperTriangular(RealMatrix m, double epsilon) {\n--- a/src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n+++ b/src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n  * <p>\n  * <code> y = intercept + slope * x  </code></p>\n  * <p>\n- * Standard errors for <code>intercept</code> and <code>slope</code> are \n+ * Standard errors for <code>intercept</code> and <code>slope</code> are\n  * available as well as ANOVA, r-square and Pearson's r statistics.</p>\n  * <p>\n- * Observations (x,y pairs) can be added to the model one at a time or they \n+ * Observations (x,y pairs) can be added to the model one at a time or they\n  * can be provided in a 2-dimensional array.  The observations are not stored\n  * in memory, so there is no limit to the number of observations that can be\n- * added to the model.</p> \n+ * added to the model.</p>\n  * <p>\n  * <strong>Usage Notes</strong>: <ul>\n  * <li> When there are fewer than two observations in the model, or when\n- * there is no variation in the x values (i.e. all x values are the same) \n+ * there is no variation in the x values (i.e. all x values are the same)\n  * all statistics return <code>NaN</code>. At least two observations with\n- * different x coordinates are requred to estimate a bivariate regression \n+ * different x coordinates are requred to estimate a bivariate regression\n  * model.\n  * </li>\n  * <li> getters for the statistics always compute values based on the current\n  * set of observations -- i.e., you can get statistics, then add more data\n- * and get updated statistics without using a new instance.  There is no \n+ * and get updated statistics without using a new instance.  There is no\n  * \"compute\" method that updates all statistics.  Each of the getters performs\n  * the necessary computations to return the requested statistic.</li>\n  * </ul></p>\n \n     /** the distribution used to compute inference statistics. */\n     private TDistribution distribution;\n-    \n+\n     /** sum of x values */\n     private double sumX = 0d;\n \n     public SimpleRegression() {\n         this(new TDistributionImpl(1.0));\n     }\n-    \n+\n     /**\n      * Create an empty SimpleRegression using the given distribution object to\n      * compute inference statistics.\n         super();\n         setDistribution(t);\n     }\n-    \n+\n     /**\n      * Adds the observation (x,y) to the regression data set.\n      * <p>\n-     * Uses updating formulas for means and sums of squares defined in \n+     * Uses updating formulas for means and sums of squares defined in\n      * \"Algorithms for Computing the Sample Variance: Analysis and\n-     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J. \n+     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J.\n      * 1983, American Statistician, vol. 37, pp. 242-247, referenced in\n      * Weisberg, S. \"Applied Linear Regression\". 2nd Ed. 1985.</p>\n      *\n         sumX += x;\n         sumY += y;\n         n++;\n-        \n+\n         if (n > 2) {\n             distribution.setDegreesOfFreedom(n - 2);\n         }\n     }\n \n-    \n+\n     /**\n      * Removes the observation (x,y) from the regression data set.\n      * <p>\n-     * Mirrors the addData method.  This method permits the use of \n-     * SimpleRegression instances in streaming mode where the regression \n-     * is applied to a sliding \"window\" of observations, however the caller is \n+     * Mirrors the addData method.  This method permits the use of\n+     * SimpleRegression instances in streaming mode where the regression\n+     * is applied to a sliding \"window\" of observations, however the caller is\n      * responsible for maintaining the set of observations in the window.</p>\n-     * \n+     *\n      * The method has no effect if there are no points of data (i.e. n=0)\n      *\n      * @param x independent variable value\n             sumX -= x;\n             sumY -= y;\n             n--;\n-            \n+\n             if (n > 2) {\n                 distribution.setDegreesOfFreedom(n - 2);\n-            } \n-        }\n-    }\n-\n-    /**\n-     * Adds the observations represented by the elements in \n+            }\n+        }\n+    }\n+\n+    /**\n+     * Adds the observations represented by the elements in\n      * <code>data</code>.\n      * <p>\n      * <code>(data[0][0],data[0][1])</code> will be the first observation, then\n      * <code>(data[1][0],data[1][1])</code>, etc.</p>\n-     * <p> \n+     * <p>\n      * This method does not replace data that has already been added.  The\n      * observations represented by <code>data</code> are added to the existing\n      * dataset.</p>\n-     * <p> \n-     * To replace all data, use <code>clear()</code> before adding the new \n+     * <p>\n+     * To replace all data, use <code>clear()</code> before adding the new\n      * data.</p>\n-     * \n+     *\n      * @param data array of observations to be added\n      */\n     public void addData(double[][] data) {\n \n     /**\n      * Removes observations represented by the elements in <code>data</code>.\n-      * <p> \n-     * If the array is larger than the current n, only the first n elements are \n-     * processed.  This method permits the use of SimpleRegression instances in \n-     * streaming mode where the regression is applied to a sliding \"window\" of \n-     * observations, however the caller is responsible for maintaining the set \n+      * <p>\n+     * If the array is larger than the current n, only the first n elements are\n+     * processed.  This method permits the use of SimpleRegression instances in\n+     * streaming mode where the regression is applied to a sliding \"window\" of\n+     * observations, however the caller is responsible for maintaining the set\n      * of observations in the window.</p>\n-     * <p> \n+     * <p>\n      * To remove all data, use <code>clear()</code>.</p>\n-     * \n+     *\n      * @param data array of observations to be removed\n      */\n     public void removeData(double[][] data) {\n     }\n \n     /**\n-     * Returns the \"predicted\" <code>y</code> value associated with the \n+     * Returns the \"predicted\" <code>y</code> value associated with the\n      * supplied <code>x</code> value,  based on the data that has been\n      * added to the model when this method is activated.\n      * <p>\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n      * <li>At least two observations (with at least two different x values)\n-     * must have been added before invoking this method. If this method is \n+     * must have been added before invoking this method. If this method is\n      * invoked before a model can be estimated, <code>Double,NaN</code> is\n      * returned.\n      * </li></ul></p>\n     /**\n      * Returns the intercept of the estimated regression line.\n      * <p>\n-     * The least squares estimate of the intercept is computed using the \n+     * The least squares estimate of the intercept is computed using the\n      * <a href=\"http://www.xycoon.com/estimation4.htm\">normal equations</a>.\n      * The intercept is sometimes denoted b0.</p>\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n      * <li>At least two observations (with at least two different x values)\n-     * must have been added before invoking this method. If this method is \n+     * must have been added before invoking this method. If this method is\n      * invoked before a model can be estimated, <code>Double,NaN</code> is\n      * returned.\n      * </li></ul></p>\n     }\n \n     /**\n-    * Returns the slope of the estimated regression line.  \n+    * Returns the slope of the estimated regression line.\n     * <p>\n-    * The least squares estimate of the slope is computed using the \n+    * The least squares estimate of the slope is computed using the\n     * <a href=\"http://www.xycoon.com/estimation4.htm\">normal equations</a>.\n     * The slope is sometimes denoted b1.</p>\n     * <p>\n     * <strong>Preconditions</strong>: <ul>\n     * <li>At least two observations (with at least two different x values)\n-    * must have been added before invoking this method. If this method is \n+    * must have been added before invoking this method. If this method is\n     * invoked before a model can be estimated, <code>Double.NaN</code> is\n     * returned.\n     * </li></ul></p>\n     */\n     public double getSlope() {\n         if (n < 2) {\n-            return Double.NaN; //not enough data \n+            return Double.NaN; //not enough data\n         }\n         if (Math.abs(sumXX) < 10 * Double.MIN_VALUE) {\n             return Double.NaN; //not enough variation in x\n \n     /**\n      * Returns the <a href=\"http://www.xycoon.com/SumOfSquares.htm\">\n-     * sum of squared errors</a> (SSE) associated with the regression \n+     * sum of squared errors</a> (SSE) associated with the regression\n      * model.\n      * <p>\n      * The sum is computed using the computational formula</p>\n      * values about their mean, <code>SXX</code> is similarly defined and\n      * <code>SXY</code> is the sum of the products of x and y mean deviations.\n      * </p><p>\n-     * The sums are accumulated using the updating algorithm referenced in \n+     * The sums are accumulated using the updating algorithm referenced in\n      * {@link #addData}.</p>\n      * <p>\n-     * The return value is constrained to be non-negative - i.e., if due to \n-     * rounding errors the computational formula returns a negative result, \n+     * The return value is constrained to be non-negative - i.e., if due to\n+     * rounding errors the computational formula returns a negative result,\n      * 0 is returned.</p>\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n      * <li>At least two observations (with at least two different x values)\n-     * must have been added before invoking this method. If this method is \n+     * must have been added before invoking this method. If this method is\n      * invoked before a model can be estimated, <code>Double,NaN</code> is\n      * returned.\n      * </li></ul></p>\n     /**\n      * Returns the sum of squared deviations of the y values about their mean.\n      * <p>\n-     * This is defined as SSTO \n+     * This is defined as SSTO\n      * <a href=\"http://www.xycoon.com/SumOfSquares.htm\">here</a>.</p>\n      * <p>\n      * If <code>n < 2</code>, this returns <code>Double.NaN</code>.</p>\n         }\n         return sumYY;\n     }\n-    \n+\n     /**\n      * Returns the sum of squared deviations of the x values about their mean.\n      *\n         }\n         return sumXX;\n     }\n-    \n+\n     /**\n      * Returns the sum of crossproducts, x<sub>i</sub>*y<sub>i</sub>.\n      *\n     }\n \n     /**\n-     * Returns the sum of squared deviations of the predicted y values about \n+     * Returns the sum of squared deviations of the predicted y values about\n      * their mean (which equals the mean of y).\n      * <p>\n-     * This is usually abbreviated SSR or SSM.  It is defined as SSM \n+     * This is usually abbreviated SSR or SSM.  It is defined as SSM\n      * <a href=\"http://www.xycoon.com/SumOfSquares.htm\">here</a></p>\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n      * <li>At least two observations (with at least two different x values)\n-     * must have been added before invoking this method. If this method is \n+     * must have been added before invoking this method. If this method is\n      * invoked before a model can be estimated, <code>Double.NaN</code> is\n      * returned.\n      * </li></ul></p>\n \n     /**\n      * Returns the sum of squared errors divided by the degrees of freedom,\n-     * usually abbreviated MSE. \n+     * usually abbreviated MSE.\n      * <p>\n      * If there are fewer than <strong>three</strong> data pairs in the model,\n-     * or if there is no variation in <code>x</code>, this returns \n+     * or if there is no variation in <code>x</code>, this returns\n      * <code>Double.NaN</code>.</p>\n      *\n      * @return sum of squared deviations of y values\n     /**\n      * Returns <a href=\"http://mathworld.wolfram.com/CorrelationCoefficient.html\">\n      * Pearson's product moment correlation coefficient</a>,\n-     * usually denoted r. \n+     * usually denoted r.\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n      * <li>At least two observations (with at least two different x values)\n-     * must have been added before invoking this method. If this method is \n+     * must have been added before invoking this method. If this method is\n      * invoked before a model can be estimated, <code>Double,NaN</code> is\n      * returned.\n      * </li></ul></p>\n         return result;\n     }\n \n-    /** \n-     * Returns the <a href=\"http://www.xycoon.com/coefficient1.htm\"> \n+    /**\n+     * Returns the <a href=\"http://www.xycoon.com/coefficient1.htm\">\n      * coefficient of determination</a>,\n-     * usually denoted r-square. \n+     * usually denoted r-square.\n      * <p>\n      * <strong>Preconditions</strong>: <ul>\n      * <li>At least two observations (with at least two different x values)\n-     * must have been added before invoking this method. If this method is \n+     * must have been added before invoking this method. If this method is\n      * invoked before a model can be estimated, <code>Double,NaN</code> is\n      * returned.\n      * </li></ul></p>\n \n     /**\n      * Returns the <a href=\"http://www.xycoon.com/standarderrorb0.htm\">\n-     * standard error of the intercept estimate</a>, \n-     * usually denoted s(b0). \n-     * <p>\n-     * If there are fewer that <strong>three</strong> observations in the \n-     * model, or if there is no variation in x, this returns \n+     * standard error of the intercept estimate</a>,\n+     * usually denoted s(b0).\n+     * <p>\n+     * If there are fewer that <strong>three</strong> observations in the\n+     * model, or if there is no variation in x, this returns\n      * <code>Double.NaN</code>.</p>\n      *\n      * @return standard error associated with intercept estimate\n     /**\n      * Returns the <a href=\"http://www.xycoon.com/standerrorb(1).htm\">standard\n      * error of the slope estimate</a>,\n-     * usually denoted s(b1). \n+     * usually denoted s(b1).\n      * <p>\n      * If there are fewer that <strong>three</strong> data pairs in the model,\n      * or if there is no variation in x, this returns <code>Double.NaN</code>.\n      * </p>\n-     * \n+     *\n      * @return standard error associated with slope estimate\n      */\n     public double getSlopeStdErr() {\n      * <p>\n      * The 95% confidence interval is</p>\n      * <p>\n-     * <code>(getSlope() - getSlopeConfidenceInterval(), \n+     * <code>(getSlope() - getSlopeConfidenceInterval(),\n      * getSlope() + getSlopeConfidenceInterval())</code></p>\n      * <p>\n-     * If there are fewer that <strong>three</strong> observations in the \n-     * model, or if there is no variation in x, this returns \n+     * If there are fewer that <strong>three</strong> observations in the\n+     * model, or if there is no variation in x, this returns\n      * <code>Double.NaN</code>.</p>\n      * <p>\n      * <strong>Usage Note</strong>:<br>\n-     * The validity of this statistic depends on the assumption that the \n+     * The validity of this statistic depends on the assumption that the\n      * observations included in the model are drawn from a\n      * <a href=\"http://mathworld.wolfram.com/BivariateNormalDistribution.html\">\n      * Bivariate Normal Distribution</a>.</p>\n     }\n \n     /**\n-     * Returns the half-width of a (100-100*alpha)% confidence interval for \n+     * Returns the half-width of a (100-100*alpha)% confidence interval for\n      * the slope estimate.\n      * <p>\n      * The (100-100*alpha)% confidence interval is </p>\n      * <p>\n-     * <code>(getSlope() - getSlopeConfidenceInterval(), \n+     * <code>(getSlope() - getSlopeConfidenceInterval(),\n      * getSlope() + getSlopeConfidenceInterval())</code></p>\n      * <p>\n-     * To request, for example, a 99% confidence interval, use \n+     * To request, for example, a 99% confidence interval, use\n      * <code>alpha = .01</code></p>\n      * <p>\n      * <strong>Usage Note</strong>:<br>\n-     * The validity of this statistic depends on the assumption that the \n+     * The validity of this statistic depends on the assumption that the\n      * observations included in the model are drawn from a\n      * <a href=\"http://mathworld.wolfram.com/BivariateNormalDistribution.html\">\n      * Bivariate Normal Distribution</a>.</p>\n      * <p>\n      * <strong> Preconditions:</strong><ul>\n-     * <li>If there are fewer that <strong>three</strong> observations in the \n-     * model, or if there is no variation in x, this returns \n+     * <li>If there are fewer that <strong>three</strong> observations in the\n+     * model, or if there is no variation in x, this returns\n      * <code>Double.NaN</code>.\n      * </li>\n-     * <li><code>(0 < alpha < 1)</code>; otherwise an \n+     * <li><code>(0 < alpha < 1)</code>; otherwise an\n      * <code>IllegalArgumentException</code> is thrown.\n-     * </li></ul></p> \n-     *\n-     * @param alpha the desired significance level \n+     * </li></ul></p>\n+     *\n+     * @param alpha the desired significance level\n      * @return half-width of 95% confidence interval for the slope estimate\n      * @throws MathException if the confidence interval can not be computed.\n      */\n     }\n \n     /**\n-     * Returns the significance level of the slope (equiv) correlation. \n+     * Returns the significance level of the slope (equiv) correlation.\n      * <p>\n      * Specifically, the returned value is the smallest <code>alpha</code>\n      * such that the slope confidence interval with significance level\n      * On regression output, this is often denoted <code>Prob(|t| > 0)</code>\n      * </p><p>\n      * <strong>Usage Note</strong>:<br>\n-     * The validity of this statistic depends on the assumption that the \n+     * The validity of this statistic depends on the assumption that the\n      * observations included in the model are drawn from a\n      * <a href=\"http://mathworld.wolfram.com/BivariateNormalDistribution.html\">\n      * Bivariate Normal Distribution</a>.</p>\n      * <p>\n-     * If there are fewer that <strong>three</strong> observations in the \n-     * model, or if there is no variation in x, this returns \n+     * If there are fewer that <strong>three</strong> observations in the\n+     * model, or if there is no variation in x, this returns\n      * <code>Double.NaN</code>.</p>\n      *\n      * @return significance level for slope/correlation\n \n     /**\n      * Computes SSR from b1.\n-     * \n+     *\n      * @param slope regression slope estimate\n      * @return sum of squared deviations of predicted y values\n      */\n     private double getRegressionSumSquares(double slope) {\n         return slope * slope * sumXX;\n     }\n-    \n+\n     /**\n      * Modify the distribution used to compute inference statistics.\n      * @param value the new distribution\n      */\n     public void setDistribution(TDistribution value) {\n         distribution = value;\n-        \n+\n         // modify degrees of freedom\n         if (n > 2) {\n             distribution.setDegreesOfFreedom(n - 2);\n--- a/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n      * The formula is F<sub>n</sub> = (1/2) [f<sub>0</sub> + (-1)<sup>n</sup> f<sub>N</sub>] +\n      *                        &sum;<sub>k=1</sub><sup>N-1</sup> f<sub>k</sub> cos(&pi; nk/N)\n      * </p>\n-     * \n+     *\n      * @param f the real data array to be transformed\n      * @return the real transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      * The formula is F<sub>n</sub> = (1/2) [f<sub>0</sub> + (-1)<sup>n</sup> f<sub>N</sub>] +\n      *                        &sum;<sub>k=1</sub><sup>N-1</sup> f<sub>k</sub> cos(&pi; nk/N)\n      * </p>\n-     * \n+     *\n      * @param f the function to be sampled and transformed\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * The formula is F<sub>n</sub> = &radic;(1/2N) [f<sub>0</sub> + (-1)<sup>n</sup> f<sub>N</sub>] +\n      *                        &radic;(2/N) &sum;<sub>k=1</sub><sup>N-1</sup> f<sub>k</sub> cos(&pi; nk/N)\n      * </p>\n-     * \n+     *\n      * @param f the real data array to be transformed\n      * @return the real transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      *                        &radic;(2/N) &sum;<sub>k=1</sub><sup>N-1</sup> f<sub>k</sub> cos(&pi; nk/N)\n      *\n      * </p>\n-     * \n+     *\n      * @param f the function to be sampled and transformed\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * The formula is f<sub>k</sub> = (1/N) [F<sub>0</sub> + (-1)<sup>k</sup> F<sub>N</sub>] +\n      *                        (2/N) &sum;<sub>n=1</sub><sup>N-1</sup> F<sub>n</sub> cos(&pi; nk/N)\n      * </p>\n-     * \n+     *\n      * @param f the real data array to be inversely transformed\n      * @return the real inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      * The formula is f<sub>k</sub> = (1/N) [F<sub>0</sub> + (-1)<sup>k</sup> F<sub>N</sub>] +\n      *                        (2/N) &sum;<sub>n=1</sub><sup>N-1</sup> F<sub>n</sub> cos(&pi; nk/N)\n      * </p>\n-     * \n+     *\n      * @param f the function to be sampled and inversely transformed\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * The formula is f<sub>k</sub> = &radic;(1/2N) [F<sub>0</sub> + (-1)<sup>k</sup> F<sub>N</sub>] +\n      *                        &radic;(2/N) &sum;<sub>n=1</sub><sup>N-1</sup> F<sub>n</sub> cos(&pi; nk/N)\n      * </p>\n-     * \n+     *\n      * @param f the real data array to be inversely transformed\n      * @return the real inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      * The formula is f<sub>k</sub> = &radic;(1/2N) [F<sub>0</sub> + (-1)<sup>k</sup> F<sub>N</sub>] +\n      *                        &radic;(2/N) &sum;<sub>n=1</sub><sup>N-1</sup> F<sub>n</sub> cos(&pi; nk/N)\n      * </p>\n-     * \n+     *\n      * @param f the function to be sampled and inversely transformed\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n--- a/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n      * <p>\n      * The formula is $ y_n = \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k $\n      * </p>\n-     * \n+     *\n      * @param f the real data array to be transformed\n      * @return the complex transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      * <p>\n      * The formula is $ y_n = \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k $\n      * </p>\n-     * \n+     *\n      * @param f the function to be sampled and transformed\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * <p>\n      * The formula is $ y_n = \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k $\n      * </p>\n-     * \n+     *\n      * @param f the complex data array to be transformed\n      * @return the complex transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      * <p>\n      * The formula is $y_n = (1/\\sqrt{N}) \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k$\n      * </p>\n-     * \n+     *\n      * @param f the real data array to be transformed\n      * @return the complex transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      * <p>\n      * The formula is $y_n = (1/\\sqrt{N}) \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k$\n      * </p>\n-     * \n+     *\n      * @param f the function to be sampled and transformed\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * <p>\n      * The formula is $y_n = (1/\\sqrt{N}) \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k$\n      * </p>\n-     * \n+     *\n      * @param f the complex data array to be transformed\n      * @return the complex transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      * <p>\n      * The formula is $ x_k = (1/N) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n $\n      * </p>\n-     * \n+     *\n      * @param f the real data array to be inversely transformed\n      * @return the complex inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      * <p>\n      * The formula is $ x_k = (1/N) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n $\n      * </p>\n-     * \n+     *\n      * @param f the function to be sampled and inversely transformed\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * <p>\n      * The formula is $ x_k = (1/N) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n $\n      * </p>\n-     * \n+     *\n      * @param f the complex data array to be inversely transformed\n      * @return the complex inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      * <p>\n      * The formula is $x_k = (1/\\sqrt{N}) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n$\n      * </p>\n-     * \n+     *\n      * @param f the real data array to be inversely transformed\n      * @return the complex inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      * <p>\n      * The formula is $x_k = (1/\\sqrt{N}) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n$\n      * </p>\n-     * \n+     *\n      * @param f the function to be sampled and inversely transformed\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * <p>\n      * The formula is $x_k = (1/\\sqrt{N}) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n$\n      * </p>\n-     * \n+     *\n      * @param f the complex data array to be inversely transformed\n      * @return the complex inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n                         f[i+j+k].getImaginary() * omega_k_times_m_imaginary,\n                         f[i+j+k].getReal() * omega_k_times_m_imaginary +\n                         f[i+j+k].getImaginary() * omega_k_times_m_real);\n-                  \n+\n                     f[i+j+k] = f[j+k].subtract(z);\n                     f[j+k] = f[j+k].add(z);\n                 }\n \n     /**\n      * Returns true if the argument is power of 2.\n-     * \n+     *\n      * @param n the number to test\n      * @return true if the argument is power of 2\n      */\n \n     /**\n      * Verifies that the data set has length of power of 2.\n-     * \n+     *\n      * @param d the data array\n      * @throws IllegalArgumentException if array length is not power of 2\n      */\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"{0} is not a power of 2, consider padding for fix\",\n                     d.length);\n-        }       \n+        }\n     }\n \n     /**\n      * Verifies that the data set has length of power of 2.\n-     * \n+     *\n      * @param o the data array\n      * @throws IllegalArgumentException if array length is not power of 2\n      */\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"{0} is not a power of 2, consider padding for fix\",\n                     o.length);\n-        }       \n+        }\n     }\n \n     /**\n      * Verifies that the endpoints specify an interval.\n-     * \n+     *\n      * @param lower lower endpoint\n      * @param upper upper endpoint\n      * @throws IllegalArgumentException if not interval\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"endpoints do not specify an interval: [{0}, {1}]\",\n                     lower, upper);\n-        }       \n-    }\n-    \n+        }\n+    }\n+\n     /**\n      * Performs a multi-dimensional Fourier transform on a given array.\n      * Use {@link #inversetransform2(Complex[])} and\n         }\n         return mdcm.getArray();\n     }\n-    \n+\n     /**\n      * Performs one dimension of a multi-dimensional Fourier transform.\n      *\n                 subVector[d] = i;\n                 temp[i] = mdcm.get(subVector);\n             }\n-            \n+\n             if (forward)\n                 temp = transform2(temp);\n             else\n                 temp = inversetransform2(temp);\n-            \n+\n             for (int i = 0; i < dimensionSize[d]; i++) {\n                 subVector[d] = i;\n                 mdcm.set(temp[i], subVector);\n                         \"some dimensions don't match: {0} != {1}\",\n                         vector.length, dimensionSize.length);\n             }\n-            \n+\n             Object lastDimension = multiDimensionalComplexArray;\n-            \n+\n             for (int i = 0; i < dimensionSize.length; i++) {\n                 lastDimension = ((Object[]) lastDimension)[vector[i]];\n             }\n             return (Complex) lastDimension;\n         }\n-        \n+\n         /**\n          * Set a matrix element.\n          * @param magnitude magnitude of the element\n             clone(mdcm);\n             return mdcm;\n         }\n-        \n+\n         /**\n          * Copy contents of current array into mdcm.\n          * @param mdcm array where to copy data\n                     }\n                 }\n             }\n-            \n+\n             for (int[] nextVector: vectorList) {\n                 mdcm.set(get(nextVector), nextVector);\n             }\n         }\n     }\n-    \n-    \n-    /** Computes the n<sup>th</sup> roots of unity. \n+\n+\n+    /** Computes the n<sup>th</sup> roots of unity.\n      * A cache of already computed values is maintained.\n      */\n     private static class RootsOfUnity implements Serializable {\n        * Build an engine for computing then <sup>th</sup> roots of unity\n        */\n       public RootsOfUnity() {\n-        \n+\n         omegaCount = 0;\n         omegaReal = null;\n         omegaImaginaryForward = null;\n         omegaImaginaryInverse = null;\n         isForward = true;\n-        \n+\n       }\n \n       /**\n        * @throws IllegalStateException if no roots of unity have been computed yet\n        */\n       public synchronized boolean isForward() throws IllegalStateException {\n-          \n+\n         if (omegaCount == 0) {\n           throw MathRuntimeException.createIllegalStateException(\n                   \"roots of unity have not been computed yet\");\n-        }        \n+        }\n         return isForward;\n-        \n+\n       }\n-      \n+\n       /** Computes the n<sup>th</sup> roots of unity.\n        * <p>The computed omega[] = { 1, w, w<sup>2</sup>, ... w<sup>(n-1)</sup> } where\n        * w = exp(-2 &pi; i / n), i = &sqrt;(-1).</p>\n         }\n \n         isForward = (n > 0);\n-        \n+\n         // avoid repetitive calculations\n         final int absN = Math.abs(n);\n-        \n+\n         if (absN == omegaCount) {\n             return;\n         }\n        */\n       public synchronized double getOmegaReal(int k)\n         throws IllegalStateException, IllegalArgumentException {\n-        \n+\n         if (omegaCount == 0) {\n             throw MathRuntimeException.createIllegalStateException(\n                     \"roots of unity have not been computed yet\");\n                     \"out of range root of unity index {0} (must be in [{1};{2}])\",\n                     k, 0, omegaCount - 1);\n         }\n-        \n+\n         return omegaReal[k];\n-        \n+\n       }\n \n       /**\n        */\n       public synchronized double getOmegaImaginary(int k)\n         throws IllegalStateException, IllegalArgumentException {\n-      \n+\n         if (omegaCount == 0) {\n             throw MathRuntimeException.createIllegalStateException(\n                     \"roots of unity have not been computed yet\");\n \n         return (isForward) ?\n             omegaImaginaryForward[k] : omegaImaginaryInverse[k];\n-        \n+\n       }\n \n     }\n-    \n+\n }\n--- a/src/main/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n      * +----+----------+---------+----------+\n      * </code>\n      * </pre>\n-     * \n+     *\n      * <b><u>How it works</u></b>\n      * <ol>\n-     * <li>Construct a matrix with N rows and n+1 columns<br>   <b>hadm[n+1][N]</b> \n+     * <li>Construct a matrix with N rows and n+1 columns<br>   <b>hadm[n+1][N]</b>\n      * <br><i>(If I use [x][y] it always means [row-offset][column-offset] of a Matrix with n rows and m columns. Its entries go from M[0][0] to M[n][m])</i></li>\n      * <li>Place the input vector <b>x[N]</b> in the first column of the matrix <b>hadm</b></li>\n      * <li>The entries of the submatrix D<sub>top</sub> are calculated as follows.\n      * <br>D<sub>top</sub> goes from entry [0][1] to [N/2-1][n+1].\n-     * <br>The columns of D<sub>top</sub> are the pairwise mutually exclusive sums of the previous column \n+     * <br>The columns of D<sub>top</sub> are the pairwise mutually exclusive sums of the previous column\n      * </li>\n      * <li>The entries of the submatrix D<sub>bottom</sub> are calculated as follows.\n      * <br>D<sub>bottom</sub> goes from entry [N/2][1] to [N][n+1].\n-     * <br>The columns of D<sub>bottom</sub> are the pairwise differences of the previous column \n+     * <br>The columns of D<sub>bottom</sub> are the pairwise differences of the previous column\n      * </li>\n      * <li>How D<sub>top</sub> and D<sub>bottom</sub> you can understand best with the example for N=8 above.\n      * <li>The output vector y is now in the last column of <b>hadm</b></li>\n-     * <li><i>Algorithm from: http://www.archive.chipcenter.com/dsp/DSP000517F1.html</i></li>    \n+     * <li><i>Algorithm from: http://www.archive.chipcenter.com/dsp/DSP000517F1.html</i></li>\n      * </ol>\n      * <br>\n      * <b><u>Visually</u></b>\n      * |N     | x<sub>N/2</sub>   |        \\/           |\n      * +------+--------+---+---+---+-----+---+\n      * </pre>\n-     * \n+     *\n      * @param x input vector\n      * @return y output vector\n      * @exception IllegalArgumentException if input array is not a power of 2\n             yPrevious = yTmp;\n \n             // iterate from top to bottom (row)\n-            for (int i = 0; i < halfN; ++i) { \n+            for (int i = 0; i < halfN; ++i) {\n                 // D<sub>top</sub>\n                 // The top part works with addition\n                 final int twoI = 2 * i;\n                 yCurrent[i] = yPrevious[twoI] + yPrevious[twoI + 1];\n             }\n-            for (int i = halfN; i < n; ++i) { \n-                // D<sub>bottom</sub>   \n+            for (int i = halfN; i < n; ++i) {\n+                // D<sub>bottom</sub>\n                 // The bottom part works with subtraction\n                 final int twoI = 2 * i;\n                 yCurrent[i] = yPrevious[twoI - n] - yPrevious[twoI - n + 1];\n             yPrevious = yTmp;\n \n             // iterate from top to bottom (row)\n-            for (int i = 0; i < halfN; ++i) { \n+            for (int i = 0; i < halfN; ++i) {\n                 // D<sub>top</sub>\n                 // The top part works with addition\n                 final int twoI = 2 * i;\n                 yCurrent[i] = yPrevious[twoI] + yPrevious[twoI + 1];\n             }\n-            for (int i = halfN; i < n; ++i) { \n-                // D<sub>bottom</sub>   \n+            for (int i = halfN; i < n; ++i) {\n+                // D<sub>bottom</sub>\n                 // The bottom part works with subtraction\n                 final int twoI = 2 * i;\n                 yCurrent[i] = yPrevious[twoI - n] - yPrevious[twoI - n + 1];\n--- a/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n  * In addition, the first element must be 0 and it's enforced in function\n  * transformation after sampling.</p>\n  * <p>As of version 2.0 this no longer implements Serializable</p>\n- * \n+ *\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n      * <p>\n      * The formula is F<sub>n</sub> = &sum;<sub>k=0</sub><sup>N-1</sup> f<sub>k</sub> sin(&pi; nk/N)\n      * </p>\n-     * \n+     *\n      * @param f the real data array to be transformed\n      * @return the real transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      * <p>\n      * The formula is F<sub>n</sub> = &sum;<sub>k=0</sub><sup>N-1</sup> f<sub>k</sub> sin(&pi; nk/N)\n      * </p>\n-     * \n+     *\n      * @param f the function to be sampled and transformed\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * <p>\n      * The formula is F<sub>n</sub> = &radic;(2/N) &sum;<sub>k=0</sub><sup>N-1</sup> f<sub>k</sub> sin(&pi; nk/N)\n      * </p>\n-     * \n+     *\n      * @param f the real data array to be transformed\n      * @return the real transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      * <p>\n      * The formula is F<sub>n</sub> = &radic;(2/N) &sum;<sub>k=0</sub><sup>N-1</sup> f<sub>k</sub> sin(&pi; nk/N)\n      * </p>\n-     * \n+     *\n      * @param f the function to be sampled and transformed\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * <p>\n      * The formula is f<sub>k</sub> = (2/N) &sum;<sub>n=0</sub><sup>N-1</sup> F<sub>n</sub> sin(&pi; nk/N)\n      * </p>\n-     * \n+     *\n      * @param f the real data array to be inversely transformed\n      * @return the real inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      * <p>\n      * The formula is f<sub>k</sub> = (2/N) &sum;<sub>n=0</sub><sup>N-1</sup> F<sub>n</sub> sin(&pi; nk/N)\n      * </p>\n-     * \n+     *\n      * @param f the function to be sampled and inversely transformed\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n      * <p>\n      * The formula is f<sub>k</sub> = &radic;(2/N) &sum;<sub>n=0</sub><sup>N-1</sup> F<sub>n</sub> sin(&pi; nk/N)\n      * </p>\n-     * \n+     *\n      * @param f the real data array to be inversely transformed\n      * @return the real inversely transformed array\n      * @throws IllegalArgumentException if any parameters are invalid\n      * <p>\n      * The formula is f<sub>k</sub> = &radic;(2/N) &sum;<sub>n=0</sub><sup>N-1</sup> F<sub>n</sub> sin(&pi; nk/N)\n      * </p>\n-     * \n+     *\n      * @param f the function to be sampled and inversely transformed\n      * @param min the lower bound for the interval\n      * @param max the upper bound for the interval\n--- a/src/main/java/org/apache/commons/math/transform/RealTransformer.java\n+++ b/src/main/java/org/apache/commons/math/transform/RealTransformer.java\n     double[] inversetransform(UnivariateRealFunction f, double min, double max, int n)\n         throws FunctionEvaluationException, IllegalArgumentException;\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/util/BigRealField.java\n+++ b/src/main/java/org/apache/commons/math/util/BigRealField.java\n      */\n     private Object readResolve() {\n         // return the singleton instance\n-        return LazyHolder.INSTANCE; \n+        return LazyHolder.INSTANCE;\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/util/CompositeFormat.java\n+++ b/src/main/java/org/apache/commons/math/util/CompositeFormat.java\n     /**\n      * Create a default number format.  The default number format is based on\n      * {@link NumberFormat#getInstance()} with the only customizing that the\n-     * maximum number of fraction digits is set to 2.  \n+     * maximum number of fraction digits is set to 2.\n      * @return the default number format.\n      */\n     protected static NumberFormat getDefaultNumberFormat() {\n     /**\n      * Create a default number format.  The default number format is based on\n      * {@link NumberFormat#getInstance(java.util.Locale)} with the only\n-     * customizing that the maximum number of fraction digits is set to 2.  \n+     * customizing that the maximum number of fraction digits is set to 2.\n      * @param locale the specific locale used by the format.\n      * @return the default number format specific to the given locale.\n      */\n          int index = pos.getIndex();\n          final int n = source.length();\n          char ret = 0;\n-    \n+\n          if (index < n) {\n              char c;\n              do {\n                  c = source.charAt(index++);\n              } while (Character.isWhitespace(c) && index < n);\n              pos.setIndex(index);\n-         \n+\n              if (index < n) {\n                  ret = c;\n              }\n          }\n-         \n+\n          return ret;\n     }\n \n     private Number parseNumber(final String source, final double value,\n                                final ParsePosition pos) {\n         Number ret = null;\n-        \n+\n         StringBuffer sb = new StringBuffer();\n         sb.append('(');\n         sb.append(value);\n         sb.append(')');\n-        \n+\n         final int n = sb.length();\n         final int startIndex = pos.getIndex();\n         final int endIndex = startIndex + n;\n                 pos.setIndex(endIndex);\n             }\n         }\n-        \n+\n         return ret;\n     }\n \n         final int startIndex = pos.getIndex();\n         Number number = format.parse(source, pos);\n         final int endIndex = pos.getIndex();\n-        \n+\n         // check for error parsing number\n         if (startIndex == endIndex) {\n             // try parsing special numbers\n                 }\n             }\n         }\n-        \n+\n         return number;\n     }\n \n         return toAppendTo;\n     }\n \n-}\n+}\n--- a/src/main/java/org/apache/commons/math/util/ContinuedFraction.java\n+++ b/src/main/java/org/apache/commons/math/util/ContinuedFraction.java\n  * @version $Revision$ $Date$\n  */\n public abstract class ContinuedFraction {\n-    \n+\n     /** Maximum allowed numerical error. */\n     private static final double DEFAULT_EPSILON = 10e-9;\n \n     /**\n      * Evaluates the continued fraction at the value x.\n      * @param x the evaluation point.\n-     * @return the value of the continued fraction evaluated at x. \n+     * @return the value of the continued fraction evaluated at x.\n      * @throws MathException if the algorithm fails to converge.\n      */\n     public double evaluate(double x) throws MathException {\n      * Evaluates the continued fraction at the value x.\n      * @param x the evaluation point.\n      * @param epsilon maximum error allowed.\n-     * @return the value of the continued fraction evaluated at x. \n+     * @return the value of the continued fraction evaluated at x.\n      * @throws MathException if the algorithm fails to converge.\n      */\n     public double evaluate(double x, double epsilon) throws MathException {\n      * Evaluates the continued fraction at the value x.\n      * @param x the evaluation point.\n      * @param maxIterations maximum number of convergents\n-     * @return the value of the continued fraction evaluated at x. \n+     * @return the value of the continued fraction evaluated at x.\n      * @throws MathException if the algorithm fails to converge.\n      */\n     public double evaluate(double x, int maxIterations) throws MathException {\n      * <p>\n      * Evaluates the continued fraction at the value x.\n      * </p>\n-     * \n+     *\n      * <p>\n      * The implementation of this method is based on equations 14-17 of:\n      * <ul>\n      * very large intermediate results which can result in numerical overflow.\n      * As a means to combat these overflow conditions, the intermediate results\n      * are scaled whenever they threaten to become numerically unstable.</p>\n-     *   \n+     *\n      * @param x the evaluation point.\n      * @param epsilon maximum error allowed.\n      * @param maxIterations maximum number of convergents\n-     * @return the value of the continued fraction evaluated at x. \n+     * @return the value of the continued fraction evaluated at x.\n      * @throws MathException if the algorithm fails to converge.\n      */\n     public double evaluate(double x, double epsilon, int maxIterations)\n             }\n             double r = p2 / q2;\n             relativeError = Math.abs(r / c - 1.0);\n-                \n+\n             // prepare for next iteration\n             c = p2 / q2;\n             p0 = p1;\n--- a/src/main/java/org/apache/commons/math/util/DefaultTransformer.java\n+++ b/src/main/java/org/apache/commons/math/util/DefaultTransformer.java\n import org.apache.commons.math.MathException;\n \n /**\n- * A Default NumberTransformer for java.lang.Numbers and Numeric Strings. This \n- * provides some simple conversion capabilities to turn any java.lang.Number \n- * into a primitive double or to turn a String representation of a Number into \n+ * A Default NumberTransformer for java.lang.Numbers and Numeric Strings. This\n+ * provides some simple conversion capabilities to turn any java.lang.Number\n+ * into a primitive double or to turn a String representation of a Number into\n  * a double.\n  *\n  * @version $Revision$ $Date$\n  */\n public class DefaultTransformer implements NumberTransformer, Serializable {\n-   \n+\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 4019938025047800455L;\n-    \n+\n     /**\n      * @param o  the object that gets transformed.\n      * @return a double primitive representation of the Object o.\n-     * @throws org.apache.commons.math.MathException If it cannot successfully \n+     * @throws org.apache.commons.math.MathException If it cannot successfully\n      * be transformed or is null.\n      * @see <a href=\"http://commons.apache.org/collections/api-release/org/apache/commons/collections/Transformer.html\"/>\n      */\n         if (o instanceof Number) {\n             return ((Number)o).doubleValue();\n         }\n-            \n+\n         try {\n             return Double.valueOf(o.toString()).doubleValue();\n         } catch (NumberFormatException e) {\n     /** {@inheritDoc} */\n     @Override\n     public boolean equals(Object other) {\n-        if (this == other) { \n+        if (this == other) {\n             return true;\n         }\n         if (other == null) {\n         }\n         return other instanceof DefaultTransformer;\n     }\n-    \n+\n     /** {@inheritDoc} */\n     @Override\n     public int hashCode() {\n--- a/src/main/java/org/apache/commons/math/util/DoubleArray.java\n+++ b/src/main/java/org/apache/commons/math/util/DoubleArray.java\n \n     /**\n      * Returns the number of elements currently in the array.  Please note\n-     * that this may be different from the length of the internal storage array.  \n-     * \n+     * that this may be different from the length of the internal storage array.\n+     *\n      * @return number of elements\n      */\n     int getNumElements();\n \n     /**\n      * Returns the element at the specified index.  Note that if an\n-     * out of bounds index is supplied a ArrayIndexOutOfBoundsException \n+     * out of bounds index is supplied a ArrayIndexOutOfBoundsException\n      * will be thrown.\n-     * \n+     *\n      * @param index index to fetch a value from\n      * @return value stored at the specified index\n      * @throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n     /**\n      * Sets the element at the specified index.  If the specified index is greater than\n      * <code>getNumElements() - 1</code>, the <code>numElements</code> property\n-     * is increased to <code>index +1</code> and additional storage is allocated \n-     * (if necessary) for the new element and all  (uninitialized) elements \n+     * is increased to <code>index +1</code> and additional storage is allocated\n+     * (if necessary) for the new element and all  (uninitialized) elements\n      * between the new element and the previous end of the array).\n-     * \n+     *\n      * @param index index to store a value in\n      * @param value value to store at the specified index\n      * @throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n \n     /**\n      * Adds an element to the end of this expandable array\n-     * \n+     *\n      * @param value to be added to end of array\n      */\n     void addElement(double value);\n      * and addElementRolling(5) is invoked, the result is an array containing\n      * the entries 2, 3, 4, 5 and the value returned is 1.\n      * </p>\n-     * \n+     *\n      * @param value the value to be added to the array\n      * @return the value which has been discarded or \"pushed\" out of the array\n      *         by this rolling insert\n     double addElementRolling(double value);\n \n     /**\n-     * Returns a double[] array containing the elements of this \n-     * <code>DoubleArray</code>.  If the underlying implementation is \n-     * array-based, this method should always return a copy, rather than a \n+     * Returns a double[] array containing the elements of this\n+     * <code>DoubleArray</code>.  If the underlying implementation is\n+     * array-based, this method should always return a copy, rather than a\n      * reference to the underlying array so that changes made to the returned\n      *  array have no effect on the <code>DoubleArray.</code>\n      *\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n \n     /**\n      * Add two integers, checking for overflow.\n-     * \n+     *\n      * @param x an addend\n      * @param y an addend\n      * @return the sum <code>x+y</code>\n \n     /**\n      * Add two long integers, checking for overflow.\n-     * \n+     *\n      * @param a an addend\n      * @param b an addend\n      * @return the sum <code>a+b</code>\n     public static long addAndCheck(long a, long b) {\n         return addAndCheck(a, b, \"overflow: add\");\n     }\n-    \n+\n     /**\n      * Add two long integers, checking for overflow.\n-     * \n+     *\n      * @param a an addend\n      * @param b an addend\n      * @param msg the message to use for any thrown exception.\n             ret = addAndCheck(b, a, msg);\n         } else {\n             // assert a <= b\n-            \n+\n             if (a < 0) {\n                 if (b < 0) {\n                     // check for negative overflow\n         }\n         return ret;\n     }\n-    \n+\n     /**\n      * Returns an exact representation of the <a\n      * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n      * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is\n      * thrown.</li>\n      * </ul></p>\n-     * \n+     *\n      * @param n the size of the set\n      * @param k the size of the subsets to be counted\n      * @return <code>n choose k</code>\n         // Use symmetry for large k\n         if (k > n / 2)\n             return binomialCoefficient(n, n - k);\n-        \n+\n         // We use the formula\n         // (n choose k) = n! / (n-k)! / k!\n         // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n      * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,\n      * Double.POSITIVE_INFINITY is returned</li>\n      * </ul></p>\n-     * \n+     *\n      * @param n the size of the set\n      * @param k the size of the subsets to be counted\n      * @return <code>n choose k</code>\n         if (n < 67) {\n             return binomialCoefficient(n,k);\n         }\n-        \n+\n         double result = 1d;\n         for (int i = 1; i <= k; i++) {\n              result *= (double)(n - k + i) / (double)i;\n         }\n-  \n+\n         return Math.floor(result + 0.5);\n     }\n-    \n+\n     /**\n      * Returns the natural <code>log</code> of the <a\n      * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n      * <li> <code>0 <= k <= n </code> (otherwise\n      * <code>IllegalArgumentException</code> is thrown)</li>\n      * </ul></p>\n-     * \n+     *\n      * @param n the size of the set\n      * @param k the size of the subsets to be counted\n      * @return <code>n choose k</code>\n         if ((k == 1) || (k == n - 1)) {\n             return Math.log(n);\n         }\n-        \n+\n         /*\n          * For values small enough to do exact integer computation,\n-         * return the log of the exact value \n+         * return the log of the exact value\n          */\n-        if (n < 67) {  \n+        if (n < 67) {\n             return Math.log(binomialCoefficient(n,k));\n         }\n-        \n+\n         /*\n          * Return the log of binomialCoefficientDouble for values that will not\n          * overflow binomialCoefficientDouble\n          */\n-        if (n < 1030) { \n+        if (n < 1030) {\n             return Math.log(binomialCoefficientDouble(n, k));\n-        } \n+        }\n \n         if (k > n / 2) {\n             return binomialCoefficientLog(n, n - k);\n             logSum -= Math.log(i);\n         }\n \n-        return logSum;      \n+        return logSum;\n     }\n \n     /**\n                   n);\n         }\n     }\n-    \n+\n     /**\n      * Compares two numbers given some amount of allowed error.\n-     * \n+     *\n      * @param x the first number\n      * @param y the second number\n      * @param eps the amount of error to allow when checking for equality\n         }\n         return 1;\n     }\n-    \n+\n     /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\">\n      * hyperbolic cosine</a> of x.\n-     * \n+     *\n      * @param x double value for which to find the hyperbolic cosine\n      * @return hyperbolic cosine of x\n      */\n     public static double cosh(double x) {\n         return (Math.exp(x) + Math.exp(-x)) / 2.0;\n     }\n-    \n+\n     /**\n      * Returns true iff both arguments are NaN or neither is NaN and they are\n      * equal\n-     * \n+     *\n      * @param x first value\n      * @param y second value\n      * @return true if the values are equal or both are NaN\n      * <p>\n      * Two NaNs are considered equals, as are two infinities with same sign.\n      * </p>\n-     * \n+     *\n      * @param x first value\n      * @param y second value\n      * @param eps the amount of absolute error to allow\n     public static boolean equals(double x, double y, double eps) {\n       return equals(x, y) || (Math.abs(y - x) <= eps);\n     }\n-    \n+\n     /**\n      * Returns true iff both arguments are equal or within the range of allowed\n      * error (inclusive).\n     /**\n      * Returns true iff both arguments are null or have same dimensions\n      * and all their elements are {@link #equals(double,double) equals}\n-     * \n+     *\n      * @param x first array\n      * @param y second array\n      * @return true if the values are both null or have same dimension\n         }\n         return true;\n     }\n-    \n+\n     /** All long-representable factorials */\n-    private static final long[] FACTORIALS = new long[] \n+    private static final long[] FACTORIALS = new long[]\n        {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800,\n         479001600, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l,\n         355687428096000l, 6402373705728000l, 121645100408832000l,\n      * an <code>ArithMeticException </code> is thrown.</li>\n      * </ul>\n      * </p>\n-     * \n+     *\n      * @param n argument\n      * @return <code>n!</code>\n      * @throws ArithmeticException if the result is too large to be represented\n      * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>\n      * </ul>\n      * </p>\n-     * \n+     *\n      * @param n argument\n      * @return <code>n!</code>\n      * @throws IllegalArgumentException if n < 0\n      * <li> <code>n >= 0</code> (otherwise\n      * <code>IllegalArgumentException</code> is thrown)</li>\n      * </ul></p>\n-     * \n+     *\n      * @param n argument\n      * @return <code>n!</code>\n      * @throws IllegalArgumentException if preconditions are not met.\n      * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns\n      * <code>0</code>.</li>\n      * </ul>\n-     * \n+     *\n      * @param p any number\n      * @param q any number\n      * @return the greatest common divisor, never negative\n \n     /**\n      * Returns an integer hash code representing the given double value.\n-     * \n+     *\n      * @param value the value to be hashed\n      * @return the hash code\n      */\n \n     /**\n      * Returns an integer hash code representing the given double array.\n-     * \n+     *\n      * @param value the value to be hashed (may be null)\n      * @return the hash code\n      * @since 1.2\n     /**\n      * For a byte value x, this method returns (byte)(+1) if x >= 0 and\n      * (byte)(-1) if x < 0.\n-     * \n+     *\n      * @param x the value, a byte\n      * @return (byte)(+1) or (byte)(-1), depending on the sign of x\n      */\n      * For a double precision value x, this method returns +1.0 if x >= 0 and\n      * -1.0 if x < 0. Returns <code>NaN</code> if <code>x</code> is\n      * <code>NaN</code>.\n-     * \n+     *\n      * @param x the value, a double\n      * @return +1.0 or -1.0, depending on the sign of x\n      */\n     /**\n      * For a float value x, this method returns +1.0F if x >= 0 and -1.0F if x <\n      * 0. Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.\n-     * \n+     *\n      * @param x the value, a float\n      * @return +1.0F or -1.0F, depending on the sign of x\n      */\n \n     /**\n      * For an int value x, this method returns +1 if x >= 0 and -1 if x < 0.\n-     * \n+     *\n      * @param x the value, an int\n      * @return +1 or -1, depending on the sign of x\n      */\n \n     /**\n      * For a long value x, this method returns +1L if x >= 0 and -1L if x < 0.\n-     * \n+     *\n      * @param x the value, a long\n      * @return +1L or -1L, depending on the sign of x\n      */\n     /**\n      * For a short value x, this method returns (short)(+1) if x >= 0 and\n      * (short)(-1) if x < 0.\n-     * \n+     *\n      * @param x the value, a short\n      * @return (short)(+1) or (short)(-1), depending on the sign of x\n      */\n      * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is\n      * <code>0</code> for any <code>x</code>.\n      * </ul>\n-     * \n+     *\n      * @param a any number\n      * @param b any number\n      * @return the least common multiple, never negative\n         return lcm;\n     }\n \n-    /** \n-     * <p>Returns the \n+    /**\n+     * <p>Returns the\n      * <a href=\"http://mathworld.wolfram.com/Logarithm.html\">logarithm</a>\n      * for base <code>b</code> of <code>x</code>.\n      * </p>\n-     * <p>Returns <code>NaN<code> if either argument is negative.  If \n+     * <p>Returns <code>NaN<code> if either argument is negative.  If\n      * <code>base</code> is 0 and <code>x</code> is positive, 0 is returned.\n-     * If <code>base</code> is positive and <code>x</code> is 0, \n+     * If <code>base</code> is positive and <code>x</code> is 0,\n      * <code>Double.NEGATIVE_INFINITY</code> is returned.  If both arguments\n      * are 0, the result is <code>NaN</code>.</p>\n-     * \n+     *\n      * @param base the base of the logarithm, must be greater than 0\n      * @param x argument, must be greater than 0\n      * @return the value of the logarithm - the number y such that base^y = x.\n      * @since 1.2\n-     */ \n+     */\n     public static double log(double base, double x) {\n         return Math.log(x)/Math.log(base);\n     }\n \n     /**\n      * Multiply two integers, checking for overflow.\n-     * \n+     *\n      * @param x a factor\n      * @param y a factor\n      * @return the product <code>x*y</code>\n \n     /**\n      * Multiply two long integers, checking for overflow.\n-     * \n+     *\n      * @param a first value\n      * @param b second value\n      * @return the product <code>a * b</code>\n                         ret = a * b;\n                     } else {\n                         throw new ArithmeticException(msg);\n-                        \n+\n                     }\n                 } else {\n                     // assert b == 0\n             } else if (a > 0) {\n                 // assert a > 0\n                 // assert b > 0\n-                \n+\n                 // check for positive overflow with positive a, positive b\n                 if (a <= Long.MAX_VALUE / b) {\n                     ret = a * b;\n      * strictly less than <code>d</code> is returned.</p>\n      * <p>\n      * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>\n-     * \n+     *\n      * @param d base number\n      * @param direction (the only important thing is whether\n      * direction is greater or smaller than d)\n     /**\n      * Scale a number by 2<sup>scaleFactor</sup>.\n      * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>\n-     * \n+     *\n      * @param d base number\n      * @param scaleFactor power of two by which d sould be multiplied\n      * @return d &times; 2<sup>scaleFactor</sup>\n      public static double normalizeAngle(double a, double center) {\n          return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);\n      }\n-     \n+\n      /**\n-      * <p>Normalizes an array to make it sum to a specified value.  \n+      * <p>Normalizes an array to make it sum to a specified value.\n       * Returns the result of the transformation <pre>\n       *    x |-> x * normalizedSum / sum\n       * </pre>\n       * applied to each non-NaN element x of the input array, where sum is the\n       * sum of the non-NaN entries in the input array.</p>\n-      * \n+      *\n       * <p>Throws IllegalArgumentException if <code>normalizedSum</code> is infinite\n       * or NaN and ArithmeticException if the input array contains any infinite elements\n       * or sums to 0</p>\n-      * \n+      *\n       * <p>Ignores (i.e., copies unchanged to the output array) NaNs in the input array.</p>\n-      * \n+      *\n       * @param values input array to be normalized\n       * @param normalizedSum target sum for the normalized array\n       * @return normalized array\n          }\n          if (sum == 0) {\n              throw MathRuntimeException.createArithmeticException(\n-                     \"Array sums to zero\"); \n+                     \"Array sums to zero\");\n          }\n          for (int i = 0; i < len; i++) {\n              if (Double.isNaN(values[i])) {\n                  out[i] = values[i] * normalizedSum / sum;\n              }\n          }\n-         return out;  \n+         return out;\n      }\n \n     /**\n      * Round the given value to the specified number of decimal places. The\n      * value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n-     * \n+     *\n      * @param x the value to round.\n      * @param scale the number of digits to the right of the decimal point.\n      * @return the rounded value.\n      * Round the given value to the specified number of decimal places. The\n      * value is rounded using the given method which is any method defined in\n      * {@link BigDecimal}.\n-     * \n+     *\n      * @param x the value to round.\n      * @param scale the number of digits to the right of the decimal point.\n      * @param roundingMethod the rounding method as defined in\n                    .doubleValue();\n         } catch (NumberFormatException ex) {\n             if (Double.isInfinite(x)) {\n-                return x;          \n+                return x;\n             } else {\n                 return Double.NaN;\n             }\n     /**\n      * Round the given value to the specified number of decimal places. The\n      * value is rounding using the {@link BigDecimal#ROUND_HALF_UP} method.\n-     * \n+     *\n      * @param x the value to round.\n      * @param scale the number of digits to the right of the decimal point.\n      * @return the rounded value.\n      * Round the given value to the specified number of decimal places. The\n      * value is rounded using the given method which is any method defined in\n      * {@link BigDecimal}.\n-     * \n+     *\n      * @param x the value to round.\n      * @param scale the number of digits to the right of the decimal point.\n      * @param roundingMethod the rounding method as defined in\n      * Round the given non-negative, value to the \"nearest\" integer. Nearest is\n      * determined by the rounding method specified. Rounding methods are defined\n      * in {@link BigDecimal}.\n-     * \n+     *\n      * @param unscaled the value to round.\n      * @param sign the sign of the original, scaled value.\n      * @param roundingMethod the rounding method as defined in\n      * <p>\n      * For a byte value x, this method returns (byte)(+1) if x > 0, (byte)(0) if\n      * x = 0, and (byte)(-1) if x < 0.</p>\n-     * \n+     *\n      * @param x the value, a byte\n      * @return (byte)(+1), (byte)(0), or (byte)(-1), depending on the sign of x\n      */\n      * <code>+1.0</code> if <code>x > 0</code>, <code>0.0</code> if\n      * <code>x = 0.0</code>, and <code>-1.0</code> if <code>x < 0</code>.\n      * Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.</p>\n-     * \n+     *\n      * @param x the value, a double\n      * @return +1.0, 0.0, or -1.0, depending on the sign of x\n      */\n      * For a float value x, this method returns +1.0F if x > 0, 0.0F if x =\n      * 0.0F, and -1.0F if x < 0. Returns <code>NaN</code> if <code>x</code>\n      * is <code>NaN</code>.</p>\n-     * \n+     *\n      * @param x the value, a float\n      * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x\n      */\n      * <p>\n      * For an int value x, this method returns +1 if x > 0, 0 if x = 0, and -1\n      * if x < 0.</p>\n-     * \n+     *\n      * @param x the value, an int\n      * @return +1, 0, or -1, depending on the sign of x\n      */\n      * <p>\n      * For a long value x, this method returns +1L if x > 0, 0L if x = 0, and\n      * -1L if x < 0.</p>\n-     * \n+     *\n      * @param x the value, a long\n      * @return +1L, 0L, or -1L, depending on the sign of x\n      */\n      * <p>\n      * For a short value x, this method returns (short)(+1) if x > 0, (short)(0)\n      * if x = 0, and (short)(-1) if x < 0.</p>\n-     * \n+     *\n      * @param x the value, a short\n      * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign of\n      *         x\n     /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\">\n      * hyperbolic sine</a> of x.\n-     * \n+     *\n      * @param x double value for which to find the hyperbolic sine\n      * @return hyperbolic sine of x\n      */\n \n     /**\n      * Subtract two integers, checking for overflow.\n-     * \n+     *\n      * @param x the minuend\n      * @param y the subtrahend\n      * @return the difference <code>x-y</code>\n \n     /**\n      * Subtract two long integers, checking for overflow.\n-     * \n+     *\n      * @param a first value\n      * @param b second value\n      * @return the difference <code>a-b</code>\n         }\n         return sum;\n     }\n-    \n+\n     /**\n      * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n      *\n         }\n         return Math.sqrt(sum);\n     }\n-    \n+\n     /**\n      * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n      *\n       }\n       return Math.sqrt(sum);\n     }\n-    \n+\n     /**\n      * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n      *\n         }\n         return max;\n     }\n-    \n+\n     /**\n      * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n      *\n         return max;\n     }\n \n-    \n+\n }\n--- a/src/main/java/org/apache/commons/math/util/NumberTransformer.java\n+++ b/src/main/java/org/apache/commons/math/util/NumberTransformer.java\n /**\n  * Subclasses implementing this interface can transform Objects to doubles.\n  * @version $Revision$ $Date$\n- * \n+ *\n  * No longer extends Serializable since 2.0\n- * \n+ *\n  */\n public interface NumberTransformer {\n-    \n+\n     /**\n      * Implementing this interface provides a facility to transform\n      * from Object to Double.\n-     * \n+     *\n      * @param o the Object to be transformed.\n      * @return the double value of the Object.\n-     * @throws MathException if the Object can not be transformed into a Double. \n+     * @throws MathException if the Object can not be transformed into a Double.\n      */\n     double transform(Object o) throws MathException;\n-}\n+}\n--- a/src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n+++ b/src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n                 j = probe(perturb, j);\n                 index = j & mask;\n                 perturb >>= PERTURB_SHIFT;\n-                \n+\n                 if (states[index] != FULL || keys[index] == key) {\n                     break;\n                 }\n         return size;\n     }\n \n-    \n+\n     /**\n      * Remove the value associated with a key.\n      * @param key key to which the value is associated\n         return h ^ (h >>> 7) ^ (h >>> 4);\n     }\n \n-    \n+\n     /** Iterator class for the map. */\n     public class Iterator {\n \n         count = 0;\n     }\n \n-            \n+\n }\n--- a/src/main/java/org/apache/commons/math/util/OpenIntToFieldHashMap.java\n+++ b/src/main/java/org/apache/commons/math/util/OpenIntToFieldHashMap.java\n  * @since 2.0\n  */\n public class OpenIntToFieldHashMap<T extends FieldElement<T>> implements Serializable {\n-    \n+\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -9179080286849120720L;\n \n \n     /** Field to which the elements belong. */\n     private final Field<T> field;\n-    \n+\n     /** Keys table. */\n     private int[] keys;\n \n                 j = probe(perturb, j);\n                 index = j & mask;\n                 perturb >>= PERTURB_SHIFT;\n-                \n+\n                 if (states[index] != FULL || keys[index] == key) {\n                     break;\n                 }\n         return size;\n     }\n \n-    \n+\n     /**\n      * Remove the value associated with a key.\n      * @param key key to which the value is associated\n         return h ^ (h >>> 7) ^ (h >>> 4);\n     }\n \n-    \n+\n     /** Iterator class for the map. */\n     public class Iterator {\n \n--- a/src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+++ b/src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java\n \n /**\n  * <p>\n- * A variable length {@link DoubleArray} implementation that automatically \n- * handles expanding and contracting its internal storage array as elements \n+ * A variable length {@link DoubleArray} implementation that automatically\n+ * handles expanding and contracting its internal storage array as elements\n  * are added and removed.\n  * </p>\n  * <p>\n  *  The internal storage array starts with capacity determined by the\n  * <code>initialCapacity</code> property, which can be set by the constructor.\n- * The default initial capacity is 16.  Adding elements using \n- * {@link #addElement(double)} appends elements to the end of the array.  When \n- * there are no open entries at the end of the internal storage array, the \n- * array is expanded.  The size of the expanded array depends on the \n- * <code>expansionMode</code> and <code>expansionFactor</code> properties.  \n- * The <code>expansionMode</code> determines whether the size of the array is \n- * multiplied by the <code>expansionFactor</code> (MULTIPLICATIVE_MODE) or if \n+ * The default initial capacity is 16.  Adding elements using\n+ * {@link #addElement(double)} appends elements to the end of the array.  When\n+ * there are no open entries at the end of the internal storage array, the\n+ * array is expanded.  The size of the expanded array depends on the\n+ * <code>expansionMode</code> and <code>expansionFactor</code> properties.\n+ * The <code>expansionMode</code> determines whether the size of the array is\n+ * multiplied by the <code>expansionFactor</code> (MULTIPLICATIVE_MODE) or if\n  * the expansion is additive (ADDITIVE_MODE -- <code>expansionFactor</code>\n- * storage locations added).  The default <code>expansionMode</code> is \n+ * storage locations added).  The default <code>expansionMode</code> is\n  * MULTIPLICATIVE_MODE and the default <code>expansionFactor</code>\n  * is 2.0.\n  * </p>\n  * <p>\n  * The {@link #addElementRolling(double)} method adds a new element to the end\n- * of the internal storage array and adjusts the \"usable window\" of the \n- * internal array forward by one position (effectively making what was the \n+ * of the internal storage array and adjusts the \"usable window\" of the\n+ * internal array forward by one position (effectively making what was the\n  * second element the first, and so on).  Repeated activations of this method\n  * (or activation of {@link #discardFrontElements(int)}) will effectively orphan\n  * the storage locations at the beginning of the internal storage array.  To\n  * reclaim this storage, each time one of these methods is activated, the size\n- * of the internal storage array is compared to the number of addressable \n+ * of the internal storage array is compared to the number of addressable\n  * elements (the <code>numElements</code> property) and if the difference\n- * is too large, the internal array is contracted to size \n+ * is too large, the internal array is contracted to size\n  * <code>numElements + 1.</code>  The determination of when the internal\n  * storage array is \"too large\" depends on the <code>expansionMode</code> and\n  * <code>contractionFactor</code> properties.  If  the <code>expansionMode</code>\n  * ratio between storage array length and <code>numElements</code> exceeds\n  * <code>contractionFactor.</code>  If the <code>expansionMode</code>\n  * is <code>ADDITIVE_MODE,</code> the number of excess storage locations\n- * is compared to <code>contractionFactor.</code>  \n+ * is compared to <code>contractionFactor.</code>\n  * </p>\n  * <p>\n- * To avoid cycles of expansions and contractions, the \n- * <code>expansionFactor</code> must not exceed the \n+ * To avoid cycles of expansions and contractions, the\n+ * <code>expansionFactor</code> must not exceed the\n  * <code>contractionFactor.</code> Constructors and mutators for both of these\n  * properties enforce this requirement, throwing IllegalArgumentException if it\n  * is violated.\n  * @version $Revision$ $Date$\n  */\n public class ResizableDoubleArray implements DoubleArray, Serializable {\n-    \n+\n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -3485529955529426875L; \n-    \n+    private static final long serialVersionUID = -3485529955529426875L;\n+\n     /** additive expansion mode */\n     public static final int ADDITIVE_MODE = 1;\n-    \n+\n     /** multiplicative expansion mode */\n     public static final int MULTIPLICATIVE_MODE = 0;\n-   \n-    /** \n-     * The contraction criteria determines when the internal array will be \n+\n+    /**\n+     * The contraction criteria determines when the internal array will be\n      * contracted to fit the number of elements contained in the element\n      *  array + 1.\n      */\n     protected float contractionCriteria = 2.5f;\n \n-    /** \n-     * The expansion factor of the array.  When the array needs to be expanded, \n-     * the new array size will be \n+    /**\n+     * The expansion factor of the array.  When the array needs to be expanded,\n+     * the new array size will be\n      * <code>internalArray.length * expansionFactor</code>\n      * if <code>expansionMode</code> is set to MULTIPLICATIVE_MODE, or\n-     * <code>internalArray.length + expansionFactor</code> if \n+     * <code>internalArray.length + expansionFactor</code> if\n      * <code>expansionMode</code> is set to ADDITIVE_MODE.\n      */\n     protected float expansionFactor = 2.0f;\n-    \n+\n     /**\n      * Determines whether array expansion by <code>expansionFactor</code>\n      * is additive or multiplicative.\n      * property as it is only meaningful when passed to a constructor.\n      */\n     protected int initialCapacity = 16;\n-    \n-    /** \n+\n+    /**\n      * The internal storage array.\n      */\n     protected double[] internalArray;\n \n-    /** \n+    /**\n      * The number of addressable elements in the array.  Note that this\n      * has nothing to do with the length of the internal storage array.\n      */\n     protected int numElements = 0;\n \n-    /** \n+    /**\n      * The position of the first addressable element in the internal storage\n      * array.  The addressable elements in the array are <code>\n      * internalArray[startIndex],...,internalArray[startIndex + numElements -1]\n \n     /**\n      * <p>\n-     * Create a ResizableArray with the specified initial capacity \n+     * Create a ResizableArray with the specified initial capacity\n      * and expansion factor.  The remaining properties take default\n      * values:\n      * <ul>\n      * <li><code>initialCapacity > 0</code></li>\n      * <li><code>expansionFactor > 1</code></li>\n      * </ul></p>\n-     * \n+     *\n      * @param initialCapacity The initial size of the internal storage array\n-     * @param expansionFactor the array will be expanded based on this \n+     * @param expansionFactor the array will be expanded based on this\n      *                        parameter\n      * @throws IllegalArgumentException if parameters are not valid\n      */\n \n     /**\n      * <p>\n-     * Create a ResizableArray with the specified initialCapacity, \n+     * Create a ResizableArray with the specified initialCapacity,\n      * expansionFactor, and contractionCriteria. The <code>expansionMode</code>\n      * will default to <code>MULTIPLICATIVE_MODE.</code></p>\n      * <p>\n      * <li><code>contractionFactor >= expansionFactor</code></li>\n      * </ul></p>\n      * @param initialCapacity The initial size of the internal storage array\n-     * @param expansionFactor the array will be expanded based on this \n+     * @param expansionFactor the array will be expanded based on this\n      *                        parameter\n      * @param contractionCriteria The contraction Criteria.\n      * @throws IllegalArgumentException if parameters are not valid\n         setInitialCapacity(initialCapacity);\n         internalArray = new double[initialCapacity];\n     }\n-    \n+\n     /**\n      * <p>\n      * Create a ResizableArray with the specified properties.</p>\n      * <li><code>expansionMode in {MULTIPLICATIVE_MODE, ADDITIVE_MODE}</code>\n      * </li>\n      * </ul></p>\n-     * \n+     *\n      * @param initialCapacity the initial size of the internal storage array\n-     * @param expansionFactor the array will be expanded based on this \n+     * @param expansionFactor the array will be expanded based on this\n      *                        parameter\n      * @param contractionCriteria the contraction Criteria\n      * @param expansionMode  the expansion mode\n         setExpansionMode(expansionMode);\n         internalArray = new double[initialCapacity];\n     }\n-    \n+\n     /**\n      * Copy constructor.  Creates a new ResizableDoubleArray that is a deep,\n      * fresh copy of the original. Needs to acquire synchronization lock\n      * on original.  Original may not be null; otherwise a NullPointerException\n      * is thrown.\n-     * \n+     *\n      * @param original array to copy\n      * @since 2.0\n      */\n \n     /**\n      * Adds an element to the end of this expandable array.\n-     * \n+     *\n      * @param value to be added to end of array\n      */\n     public synchronized void addElement(double value) {\n      * and addElementRolling(5) is invoked, the result is an array containing\n      * the entries 2, 3, 4, 5 and the value returned is 1.\n      * </p>\n-     * \n+     *\n      * @param value the value to be added to the array\n      * @return the value which has been discarded or \"pushed\" out of the array\n      *         by this rolling insert\n         }\n         return discarded;\n     }\n-       \n+\n     /**\n      * Substitutes <code>value</code> for the most recently added value.\n-     * Returns the value that has been replaced. If the array is empty (i.e. \n+     * Returns the value that has been replaced. If the array is empty (i.e.\n      * if {@link #numElements} is zero), a MathRuntimeException is thrown.\n-     * \n+     *\n      * @param value new value to substitute for the most recently added value\n      * @return value that has been replaced in the array\n      * @since 2.0\n         return discarded;\n     }\n \n-    \n-    /**\n-     * Checks the expansion factor and the contraction criteria and throws an \n-     * IllegalArgumentException if the contractionCriteria is less than the \n+\n+    /**\n+     * Checks the expansion factor and the contraction criteria and throws an\n+     * IllegalArgumentException if the contractionCriteria is less than the\n      * expansionCriteria\n-     * \n+     *\n      * @param expansion factor to be checked\n      * @param contraction criteria to be checked\n      * @throws IllegalArgumentException if the contractionCriteria is less than\n                     expansion);\n         }\n     }\n-    \n-    /**\n-     * Clear the array, reset the size to the initialCapacity and the number \n+\n+    /**\n+     * Clear the array, reset the size to the initialCapacity and the number\n      * of elements to zero.\n      */\n     public synchronized void clear() {\n         startIndex = 0;\n         internalArray = new double[initialCapacity];\n     }\n-    \n-    /**\n-     * Contracts the storage array to the (size of the element set) + 1 - to \n-     * avoid a zero length array. This function also resets the startIndex to \n-     * zero. \n+\n+    /**\n+     * Contracts the storage array to the (size of the element set) + 1 - to\n+     * avoid a zero length array. This function also resets the startIndex to\n+     * zero.\n      */\n     public synchronized void contract() {\n         double[] tempArray = new double[numElements + 1];\n \n     /**\n      * Discards the <code>i<code> initial elements of the array.  For example,\n-     * if the array contains the elements 1,2,3,4, invoking \n-     * <code>discardFrontElements(2)</code> will cause the first two elements \n+     * if the array contains the elements 1,2,3,4, invoking\n+     * <code>discardFrontElements(2)</code> will cause the first two elements\n      * to be discarded, leaving 3,4 in the array.  Throws illegalArgumentException\n      * if i exceeds numElements.\n-     * \n+     *\n      * @param i  the number of elements to discard from the front of the array\n      * @throws IllegalArgumentException if i is greater than numElements.\n      * @since 2.0\n     public synchronized void discardFrontElements(int i) {\n \n         discardExtremeElements(i,true);\n-        \n+\n     }\n \n     /**\n      * Discards the <code>i<code> last elements of the array.  For example,\n-     * if the array contains the elements 1,2,3,4, invoking \n-     * <code>discardMostRecentElements(2)</code> will cause the last two elements \n+     * if the array contains the elements 1,2,3,4, invoking\n+     * <code>discardMostRecentElements(2)</code> will cause the last two elements\n      * to be discarded, leaving 1,2 in the array.  Throws illegalArgumentException\n      * if i exceeds numElements.\n-     * \n+     *\n      * @param i  the number of elements to discard from the end of the array\n      * @throws IllegalArgumentException if i is greater than numElements.\n      * @since 2.0\n     public synchronized void discardMostRecentElements(int i) {\n \n         discardExtremeElements(i,false);\n-        \n-    }\n-    \n+\n+    }\n+\n     /**\n      * Discards the <code>i<code> first or last elements of the array,\n      * depending on the value of <code>front</code>.\n-     * For example, if the array contains the elements 1,2,3,4, invoking \n-     * <code>discardExtremeElements(2,false)</code> will cause the last two elements \n+     * For example, if the array contains the elements 1,2,3,4, invoking\n+     * <code>discardExtremeElements(2,false)</code> will cause the last two elements\n      * to be discarded, leaving 1,2 in the array.\n-     * For example, if the array contains the elements 1,2,3,4, invoking \n-     * <code>discardExtremeElements(2,true)</code> will cause the first two elements \n+     * For example, if the array contains the elements 1,2,3,4, invoking\n+     * <code>discardExtremeElements(2,true)</code> will cause the first two elements\n      * to be discarded, leaving 3,4 in the array.\n      * Throws illegalArgumentException\n      * if i exceeds numElements.\n-     * \n+     *\n      * @param i  the number of elements to discard from the front/end of the array\n      * @param front true if elements are to be discarded from the front\n      * of the array, false if elements are to be discarded from the end\n-     * of the array \n+     * of the array\n      * @throws IllegalArgumentException if i is greater than numElements.\n      * @since 2.0\n      */\n                    \"cannot discard a negative number of elements ({0})\",\n                    i);\n         } else {\n-            // \"Subtract\" this number of discarded from numElements \n+            // \"Subtract\" this number of discarded from numElements\n             numElements -= i;\n             if (front) startIndex += i;\n         }\n      */\n     protected synchronized void expand() {\n \n-        // notice the use of Math.ceil(), this guarantees that we will always \n-        // have an array of at least currentSize + 1.   Assume that the \n+        // notice the use of Math.ceil(), this guarantees that we will always\n+        // have an array of at least currentSize + 1.   Assume that the\n         // current initial capacity is 1 and the expansion factor\n-        // is 1.000000000000000001.  The newly calculated size will be \n+        // is 1.000000000000000001.  The newly calculated size will be\n         // rounded up to 2 after the multiplication is performed.\n         int newSize = 0;\n         if (expansionMode == MULTIPLICATIVE_MODE) {\n         System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n         internalArray = tempArray;\n     }\n-    \n+\n     /**\n      * Expands the internal storage array to the specified size.\n-     * \n+     *\n      * @param size Size of the new internal storage array\n      */\n     private synchronized void expandTo(int size) {\n     }\n \n     /**\n-     * The contraction criteria defines when the internal array will contract \n-     * to store only the number of elements in the element array.   \n+     * The contraction criteria defines when the internal array will contract\n+     * to store only the number of elements in the element array.\n      * If  the <code>expansionMode</code> is <code>MULTIPLICATIVE_MODE</code>,\n-     * contraction is triggered when the ratio between storage array length \n+     * contraction is triggered when the ratio between storage array length\n      * and <code>numElements</code> exceeds <code>contractionFactor</code>.\n      * If the <code>expansionMode</code> is <code>ADDITIVE_MODE</code>, the\n-     * number of excess storage locations is compared to \n-     * <code>contractionFactor.</code>   \n-     * \n+     * number of excess storage locations is compared to\n+     * <code>contractionFactor.</code>\n+     *\n      * @return the contraction criteria used to reclaim memory.\n      */\n     public float getContractionCriteria() {\n         return contractionCriteria;\n     }\n-    \n+\n     /**\n      * Returns the element at the specified index\n-     * \n+     *\n      * @param index index to fetch a value from\n      * @return value stored at the specified index\n      * @throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n                     index);\n         }\n     }\n-    \n+\n      /**\n-     * Returns a double array containing the elements of this \n+     * Returns a double array containing the elements of this\n      * <code>ResizableArray</code>.  This method returns a copy, not a\n      * reference to the underlying array, so that changes made to the returned\n      *  array have no effect on this <code>ResizableArray.</code>\n                 numElements);\n         return elementArray;\n     }\n-    \n-    /**\n-     * The expansion factor controls the size of a new array when an array \n+\n+    /**\n+     * The expansion factor controls the size of a new array when an array\n      * needs to be expanded.  The <code>expansionMode</code>\n-     * determines whether the size of the array is multiplied by the \n-     * <code>expansionFactor</code> (MULTIPLICATIVE_MODE) or if \n+     * determines whether the size of the array is multiplied by the\n+     * <code>expansionFactor</code> (MULTIPLICATIVE_MODE) or if\n      * the expansion is additive (ADDITIVE_MODE -- <code>expansionFactor</code>\n-     * storage locations added).  The default <code>expansionMode</code> is \n+     * storage locations added).  The default <code>expansionMode</code> is\n      * MULTIPLICATIVE_MODE and the default <code>expansionFactor</code>\n      * is 2.0.\n-     * \n+     *\n      * @return the expansion factor of this expandable double array\n      */\n     public float getExpansionFactor() {\n         return expansionFactor;\n     }\n-    \n-    /**\n-     * The <code>expansionMode</code> determines whether the internal storage \n-     * array grows additively (ADDITIVE_MODE) or multiplicatively \n+\n+    /**\n+     * The <code>expansionMode</code> determines whether the internal storage\n+     * array grows additively (ADDITIVE_MODE) or multiplicatively\n      * (MULTIPLICATIVE_MODE) when it is expanded.\n-     * \n+     *\n      * @return Returns the expansionMode.\n      */\n     public int getExpansionMode() {\n         return expansionMode;\n     }\n-    \n-    /**\n-     * Notice the package scope on this method.   This method is simply here \n-     * for the JUnit test, it allows us check if the expansion is working \n-     * properly after a number of expansions.  This is not meant to be a part \n+\n+    /**\n+     * Notice the package scope on this method.   This method is simply here\n+     * for the JUnit test, it allows us check if the expansion is working\n+     * properly after a number of expansions.  This is not meant to be a part\n      * of the public interface of this class.\n-     * \n+     *\n      * @return the length of the internal storage array.\n      */\n     synchronized int getInternalLength() {\n \n     /**\n      * Returns the number of elements currently in the array.  Please note\n-     * that this is different from the length of the internal storage array.  \n+     * that this is different from the length of the internal storage array.\n      *\n      * @return number of elements\n      */\n     public synchronized int getNumElements() {\n         return (numElements);\n     }\n-    \n+\n     /**\n      * Returns the internal storage array.  Note that this method returns\n      * a reference to the internal storage array, not a copy, and to correctly\n      * only be used in cases where copying the internal array is not practical.\n      * The {@link #getElements} method should be used in all other cases.\n      *\n-     * \n+     *\n      * @return the internal storage array used by this object\n      * @deprecated replaced by {@link #getInternalValues()} as of 2.0\n      */\n      * only be used in cases where copying the internal array is not practical.\n      * The {@link #getElements} method should be used in all other cases.\n      *\n-     * \n+     *\n      * @return the internal storage array used by this object\n      * @since 2.0\n      */\n     }\n \n     /**\n-     * Sets the contraction criteria for this ExpandContractDoubleArray. \n-     * \n+     * Sets the contraction criteria for this ExpandContractDoubleArray.\n+     *\n      * @param contractionCriteria contraction criteria\n      */\n     public void setContractionCriteria(float contractionCriteria) {\n             this.contractionCriteria = contractionCriteria;\n         }\n     }\n-    \n+\n \n     /**\n      * Sets the element at the specified index.  If the specified index is greater than\n      * <code>getNumElements() - 1</code>, the <code>numElements</code> property\n-     * is increased to <code>index +1</code> and additional storage is allocated \n-     * (if necessary) for the new element and all  (uninitialized) elements \n+     * is increased to <code>index +1</code> and additional storage is allocated\n+     * (if necessary) for the new element and all  (uninitialized) elements\n      * between the new element and the previous end of the array).\n-     * \n+     *\n      * @param index index to store a value in\n      * @param value value to store at the specified index\n      * @throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n         }\n         if (index + 1 > numElements) {\n             numElements = index + 1;\n-        }       \n+        }\n         if ((startIndex + index) >= internalArray.length) {\n             expandTo(startIndex + (index + 1));\n-        }    \n+        }\n         internalArray[startIndex + index] = value;\n     }\n \n     /**\n-     * Sets the expansionFactor.  Throws IllegalArgumentException if the \n+     * Sets the expansionFactor.  Throws IllegalArgumentException if the\n      * the following conditions are not met:\n      * <ul>\n      * <li><code>expansionFactor > 1</code></li>\n     /**\n      * Sets the <code>expansionMode</code>. The specified value must be one of\n      * ADDITIVE_MODE, MULTIPLICATIVE_MODE.\n-     * \n+     *\n      * @param expansionMode The expansionMode to set.\n      * @throws IllegalArgumentException if the specified mode value is not valid\n      */\n     public void setExpansionMode(int expansionMode) {\n-        if (expansionMode != MULTIPLICATIVE_MODE && \n+        if (expansionMode != MULTIPLICATIVE_MODE &&\n                 expansionMode != ADDITIVE_MODE) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                     \"unsupported expansion mode {0}, supported modes are {1} ({2}) and {3} ({4})\",\n             this.expansionMode = expansionMode;\n         }\n     }\n-    \n+\n     /**\n      * Sets the initial capacity.  Should only be invoked by constructors.\n-     * \n+     *\n      * @param initialCapacity of the array\n      * @throws IllegalArgumentException if <code>initialCapacity</code> is not\n      *         positive.\n                     initialCapacity);\n         }\n     }\n-    \n-    /**\n-     * This function allows you to control the number of elements contained \n-     * in this array, and can be used to \"throw out\" the last n values in an \n+\n+    /**\n+     * This function allows you to control the number of elements contained\n+     * in this array, and can be used to \"throw out\" the last n values in an\n      * array. This function will also expand the internal array as needed.\n-     * \n+     *\n      * @param i a new number of elements\n      * @throws IllegalArgumentException if <code>i</code> is negative.\n      */\n                     i);\n         }\n \n-        // Test the new num elements, check to see if the array needs to be \n+        // Test the new num elements, check to see if the array needs to be\n         // expanded to accommodate this new number of elements\n         if ((startIndex + i) > internalArray.length) {\n             expandTo(startIndex + i);\n     }\n \n     /**\n-     * Returns true if the internal storage array has too many unused \n-     * storage positions.  \n-     * \n+     * Returns true if the internal storage array has too many unused\n+     * storage positions.\n+     *\n      * @return true if array satisfies the contraction criteria\n      */\n     private synchronized boolean shouldContract() {\n-        if (expansionMode == MULTIPLICATIVE_MODE) { \n+        if (expansionMode == MULTIPLICATIVE_MODE) {\n             return (internalArray.length / ((float) numElements)) > contractionCriteria;\n         } else {\n             return (internalArray.length - numElements) > contractionCriteria;\n     public synchronized int start() {\n         return startIndex;\n     }\n-    \n+\n     /**\n      * <p>Copies source to dest, copying the underlying data, so dest is\n      * a new, independent copy of source.  Does not contract before\n      * the copy.</p>\n-     * \n+     *\n      * <p>Obtains synchronization locks on both source and dest\n      * (in that order) before performing the copy.</p>\n-     * \n+     *\n      * <p>Neither source nor dest may be null; otherwise a NullPointerException\n      * is thrown</p>\n-     * \n+     *\n      * @param source ResizableDoubleArray to copy\n      * @param dest ResizableArray to replace with a copy of the source array\n      * @since 2.0\n-     * \n+     *\n      */\n     public static void copy(ResizableDoubleArray source, ResizableDoubleArray dest) {\n        synchronized(source) {\n            }\n        }\n     }\n-    \n+\n     /**\n      * Returns a copy of the ResizableDoubleArray.  Does not contract before\n      * the copy, so the returned object is an exact copy of this.\n-     * \n+     *\n      * @return a new ResizableDoubleArray with the same data and configuration\n      * properties as this\n      * @since 2.0\n         copy(this, result);\n         return result;\n     }\n-    \n+\n     /**\n      * Returns true iff object is a ResizableDoubleArray with the same properties\n      * as this and an identical internal storage array.\n-     * \n+     *\n      * @param object object to be compared for equality with this\n      * @return true iff object is a ResizableDoubleArray with the same data and\n      * properties as this\n                result = result && (other.expansionMode == expansionMode);\n                result = result && (other.numElements == numElements);\n                result = result && (other.startIndex == startIndex);\n-               if (!result) { \n+               if (!result) {\n                    return false;\n                } else {\n                    return Arrays.equals(internalArray, other.internalArray);\n            }\n        }\n     }\n-    \n+\n     /**\n      * Returns a hash code consistent with equals.\n-     * \n+     *\n      * @return hash code representing this ResizableDoubleArray\n      * @since 2.0\n      */\n             hashData[6] = startIndex;\n         return Arrays.hashCode(hashData);\n     }\n-         \n+\n }\n--- a/src/main/java/org/apache/commons/math/util/TransformerMap.java\n+++ b/src/main/java/org/apache/commons/math/util/TransformerMap.java\n \n /**\n  * This TansformerMap automates the transformation of mixed object types.\n- * It provides a means to set NumberTransformers that will be selected \n+ * It provides a means to set NumberTransformers that will be selected\n  * based on the Class of the object handed to the Maps\n  * <code>double transform(Object o)</code> method.\n  * @version $Revision$ $Date$\n     }\n \n     /**\n-     * Returns the Set of NumberTransformers used as values \n+     * Returns the Set of NumberTransformers used as values\n      * in the map.\n      * @return Set of NumberTransformers\n      */\n     /**\n      * Attempts to transform the Object against the map of\n      * NumberTransformers. Otherwise it returns Double.NaN.\n-     * \n+     *\n      * @param o the Object to be transformed.\n      * @return the double value of the Object.\n-     * @throws MathException if the Object can not be transformed into a Double. \n+     * @throws MathException if the Object can not be transformed into a Double.\n      * @see org.apache.commons.math.util.NumberTransformer#transform(java.lang.Object)\n      */\n     public double transform(Object o) throws MathException {\n     /** {@inheritDoc} */\n     @Override\n     public boolean equals(Object other) {\n-        if (this == other) { \n+        if (this == other) {\n             return true;\n         }\n         if (other == null) {\n             return false;\n         }\n     }\n-    \n+\n     /** {@inheritDoc} */\n     @Override\n     public int hashCode() {\n--- a/src/test/java/org/apache/commons/math/ArgumentOutsideDomainExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/ArgumentOutsideDomainExceptionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * @version $Revision$ $Date$\n  */\n public class ArgumentOutsideDomainExceptionTest extends TestCase {\n-    \n+\n     public void testConstructor(){\n         ArgumentOutsideDomainException ex = new ArgumentOutsideDomainException(Math.PI, 10.0, 20.0);\n         assertNull(ex.getCause());\n         assertEquals(Math.PI, ex.getArgument()[0], 0);\n         assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/math/ConvergenceExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/ConvergenceExceptionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n         assertNotNull(ex.getMessage(Locale.FRENCH));\n         assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n     }\n-    \n+\n     public void testConstructorPatternArguments(){\n         String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n         Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         assertFalse(pattern.equals(ex.getMessage()));\n         assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n     }\n-    \n+\n     public void testConstructorCause(){\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         assertFalse(pattern.equals(ex.getMessage()));\n         assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/math/DuplicateSampleAbscissaExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/DuplicateSampleAbscissaExceptionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * @version $Revision$ $Date$\n  */\n public class DuplicateSampleAbscissaExceptionTest extends TestCase {\n-    \n+\n     public void testConstructor(){\n         DuplicateSampleAbscissaException ex = new DuplicateSampleAbscissaException(1.2, 10, 11);\n         assertNull(ex.getCause());\n         assertEquals(1.2, ex.getDuplicateAbscissa(), 0);\n         assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/math/FunctionEvaluationExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/FunctionEvaluationExceptionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * @version $Revision$ $Date$\n  */\n public class FunctionEvaluationExceptionTest extends TestCase {\n-    \n+\n     public void testConstructor(){\n         FunctionEvaluationException ex = new FunctionEvaluationException(0.0);\n         assertNull(ex.getCause());\n         assertTrue(ex.getMessage().indexOf(\"0\") > 0);\n         assertEquals(0.0, ex.getArgument()[0], 0);\n     }\n-    \n+\n     public void testConstructorArray(){\n         FunctionEvaluationException ex =\n             new FunctionEvaluationException(new double[] { 0, 1, 2 });\n         assertEquals(1.0, ex.getArgument()[1], 0);\n         assertEquals(2.0, ex.getArgument()[2], 0);\n     }\n-    \n+\n     public void testConstructorPatternArguments(){\n         String pattern = \"evaluation failed for argument = {0}\";\n         Object[] arguments = { Double.valueOf(0.0) };\n--- a/src/test/java/org/apache/commons/math/MathConfigurationExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/MathConfigurationExceptionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n         assertNull(ex.getMessage());\n         assertEquals(0, ex.getMessage(Locale.FRENCH).length());\n     }\n-    \n+\n     public void testConstructorPatternArguments(){\n         String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n         Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         assertFalse(pattern.equals(ex.getMessage()));\n         assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n     }\n-    \n+\n     public void testConstructorCause(){\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         assertFalse(pattern.equals(ex.getMessage()));\n         assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/math/MathExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/MathExceptionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n         assertNull(ex.getMessage());\n         assertEquals(0, ex.getMessage(Locale.FRENCH).length());\n     }\n-    \n+\n     public void testConstructorPatternArguments(){\n         String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n         Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         assertFalse(pattern.equals(ex.getMessage()));\n         assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n     }\n-    \n+\n     public void testConstructorCause(){\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         assertFalse(pattern.equals(ex.getMessage()));\n         assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n     }\n-    \n+\n     /**\n      * Tests the printStackTrace() operation.\n      */\n         ex.printStackTrace(ps);\n         String stack = baos.toString();\n         String outerMsg = \"org.apache.commons.math.MathException: outer message\";\n-        String innerMsg = \"Caused by: \" + \n+        String innerMsg = \"Caused by: \" +\n         \"org.apache.commons.math.MathConfigurationException: inner message\";\n         assertTrue(stack.startsWith(outerMsg));\n         assertTrue(stack.indexOf(innerMsg) > 0);\n-        \n+\n         PrintWriter pw = new PrintWriter(ps, true);\n         ex.printStackTrace(pw);\n         stack = baos.toString();\n         assertTrue(stack.startsWith(outerMsg));\n         assertTrue(stack.indexOf(innerMsg) > 0);\n     }\n-    \n+\n     /**\n      * Test serialization\n      */\n         MathException cause = new MathConfigurationException(inMsg);\n         MathException ex = new MathException(cause, outMsg);\n         MathException image = (MathException) TestUtils.serializeAndRecover(ex);\n-        \n+\n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         PrintStream ps = new PrintStream(baos);\n         ex.printStackTrace(ps);\n         String stack = baos.toString();\n-        \n+\n         ByteArrayOutputStream baos2 = new ByteArrayOutputStream();\n         PrintStream ps2 = new PrintStream(baos2);\n         image.printStackTrace(ps2);\n         String stack2 = baos2.toString();\n-        \n+\n         // See if JDK supports nested exceptions.  If not, stack trace of\n         // inner exception will not be serialized\n         boolean jdkSupportsNesting = false;\n         } catch (NoSuchMethodException e) {\n             jdkSupportsNesting = false;\n         }\n-        \n+\n         if (jdkSupportsNesting) {\n             assertEquals(stack, stack2);\n         } else {\n--- a/src/test/java/org/apache/commons/math/MaxIterationsExceededExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/MaxIterationsExceededExceptionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * @version $Revision$ $Date$\n  */\n public class MaxIterationsExceededExceptionTest extends TestCase {\n-    \n+\n     public void testSimpleConstructor(){\n         MaxIterationsExceededException ex = new MaxIterationsExceededException(1000000);\n         assertNull(ex.getCause());\n         assertEquals(1000000, ex.getMaxIterations());\n         assertFalse(ex.getMessage().equals(ex.getMessage(Locale.FRENCH)));\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/math/RetryTestCase.java\n+++ b/src/test/java/org/apache/commons/math/RetryTestCase.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n /**\n  * A TestCase that retries tests when assertions fail.\n  * <p>\n- * If one or more tests throw an AssertionFailedError, all tests are \n- * repeated one time.  \n+ * If one or more tests throw an AssertionFailedError, all tests are\n+ * repeated one time.\n  * <p>\n  * Errors or exceptions other than AssertionFailedError do not lead to retries.\n  *\n     public RetryTestCase(String arg0) {\n         super(arg0);\n     }\n-    \n+\n     /**\n      *  Override runTest() to catch AssertionFailedError and retry\n      */\n         } catch (AssertionFailedError err) {\n             // System.out.println(\"Retrying \" + this.getName());\n             super.runTest();\n-        }    \n+        }\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/TestUtils.java\n+++ b/src/test/java/org/apache/commons/math/TestUtils.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n             Assert.assertEquals(msg, expected, actual, delta);\n         }\n     }\n-    \n+\n     /**\n      * Verifies that the two arguments are exactly the same, either\n      * both NaN or infinities of same sign, or identical floating point values.\n     public static void assertSame(double expected, double actual) {\n      assertEquals(expected, actual, 0);\n     }\n-    \n+\n     /**\n      * Verifies that real and imaginary parts of the two complex arguments\n      * are exactly the same.  Also ensures that NaN / infinite components match.\n         assertSame(expected.getReal(), actual.getReal());\n         assertSame(expected.getImaginary(), actual.getImaginary());\n     }\n-    \n+\n     /**\n      * Verifies that real and imaginary parts of the two complex arguments\n      * differ by at most delta.  Also ensures that NaN / infinite components match.\n         assertEquals(expected.getReal(), actual.getReal(), delta);\n         assertEquals(expected.getImaginary(), actual.getImaginary(), delta);\n     }\n-    \n+\n     /**\n      * Verifies that two double arrays have equal entries, up to tolerance\n      */\n     public static void assertEquals(double expected[], double observed[], double tolerance) {\n         assertEquals(\"Array comparison failure\", expected, observed, tolerance);\n     }\n-    \n+\n     /**\n      * Serializes an object to a bytes array and then recovers the object from the bytes array.\n      * Returns the deserialized object.\n-     * \n+     *\n      * @param o  object to serialize and recover\n      * @return  the recovered, deserialized object\n      */\n             return null;\n         }\n     }\n-    \n+\n     /**\n      * Verifies that serialization preserves equals and hashCode.\n      * Serializes the object, then recovers it and checks equals and hash code.\n-     * \n+     *\n      * @param object  the object to serialize and recover\n      */\n     public static void checkSerializedEquality(Object object) {\n      * Verifies that the relative error in actual vs. expected is less than or\n      * equal to relativeError.  If expected is infinite or NaN, actual must be\n      * the same (NaN or infinity of the same sign).\n-     * \n+     *\n      * @param expected expected value\n      * @param actual  observed value\n      * @param relativeError  maximum allowable relative error\n             double relativeError) {\n         assertRelativelyEquals(null, expected, actual, relativeError);\n     }\n-    \n+\n     /**\n      * Verifies that the relative error in actual vs. expected is less than or\n      * equal to relativeError.  If expected is infinite or NaN, actual must be\n      * the same (NaN or infinity of the same sign).\n-     * \n+     *\n      * @param msg  message to return with failure\n      * @param expected expected value\n      * @param actual  observed value\n             Assert.assertEquals(msg, 0.0, x, relativeError);\n         }\n     }\n-    \n+\n     /**\n      * Fails iff values does not contain a number within epsilon of z.\n-     * \n+     *\n      * @param msg  message to return with failure\n      * @param values complex array to search\n      * @param z  value sought\n         while (!found && i < values.length) {\n             try {\n                 assertEquals(values[i], z, epsilon);\n-                found = true; \n+                found = true;\n             } catch (AssertionFailedError er) {\n                 // no match\n             }\n             i++;\n         }\n         if (!found) {\n-            Assert.fail(msg + \n+            Assert.fail(msg +\n                 \" Unable to find \" + ComplexFormat.formatComplex(z));\n         }\n     }\n-    \n+\n     /**\n      * Fails iff values does not contain a number within epsilon of z.\n-     * \n+     *\n      * @param values complex array to search\n      * @param z  value sought\n      * @param epsilon  tolerance\n      */\n     public static void assertContains(Complex[] values,\n             Complex z, double epsilon) {\n-        assertContains(null, values, z, epsilon);      \n-    }\n-    \n+        assertContains(null, values, z, epsilon);\n+    }\n+\n     /**\n      * Fails iff values does not contain a number within epsilon of x.\n-     * \n+     *\n      * @param msg  message to return with failure\n      * @param values double array to search\n      * @param x value sought\n         while (!found && i < values.length) {\n             try {\n                 assertEquals(values[i], x, epsilon);\n-                found = true; \n+                found = true;\n             } catch (AssertionFailedError er) {\n                 // no match\n             }\n             Assert.fail(msg + \" Unable to find\" + x);\n         }\n     }\n-    \n+\n     /**\n      * Fails iff values does not contain a number within epsilon of x.\n-     * \n+     *\n      * @param values double array to search\n      * @param x value sought\n      * @param epsilon  tolerance\n             double epsilon) {\n        assertContains(null, values, x, epsilon);\n     }\n-    \n-    /** verifies that two matrices are close (1-norm) */              \n+\n+    /** verifies that two matrices are close (1-norm) */\n     public static void assertEquals(String msg, RealMatrix expected, RealMatrix observed,\n         double tolerance) {\n-        \n+\n         if (observed == null) {\n             Assert.fail(msg + \"\\nObserved is null\");\n         }\n-        \n-        if (expected.getColumnDimension() != observed.getColumnDimension() || \n+\n+        if (expected.getColumnDimension() != observed.getColumnDimension() ||\n                 expected.getRowDimension() != observed.getRowDimension()) {\n             StringBuffer messageBuffer = new StringBuffer(msg);\n-            messageBuffer.append(\"\\nObserved has incorrect dimensions.\"); \n+            messageBuffer.append(\"\\nObserved has incorrect dimensions.\");\n             messageBuffer.append(\"\\nobserved is \" + observed.getRowDimension() +\n                     \" x \" + observed.getColumnDimension());\n             messageBuffer.append(\"\\nexpected \" + expected.getRowDimension() +\n             Assert.fail(messageBuffer.toString());\n         }\n     }\n-    \n-    /** verifies that two matrices are equal */              \n+\n+    /** verifies that two matrices are equal */\n     public static void assertEquals(FieldMatrix<? extends FieldElement<?>> expected,\n                                     FieldMatrix<? extends FieldElement<?>> observed) {\n-        \n+\n         if (observed == null) {\n             Assert.fail(\"Observed is null\");\n         }\n-        \n-        if (expected.getColumnDimension() != observed.getColumnDimension() || \n+\n+        if (expected.getColumnDimension() != observed.getColumnDimension() ||\n                 expected.getRowDimension() != observed.getRowDimension()) {\n             StringBuffer messageBuffer = new StringBuffer();\n-            messageBuffer.append(\"Observed has incorrect dimensions.\"); \n+            messageBuffer.append(\"Observed has incorrect dimensions.\");\n             messageBuffer.append(\"\\nobserved is \" + observed.getRowDimension() +\n                     \" x \" + observed.getColumnDimension());\n             messageBuffer.append(\"\\nexpected \" + expected.getRowDimension() +\n             }\n         }\n     }\n-    \n+\n     /** verifies that two arrays are close (sup norm) */\n     public static void assertEquals(String msg, double[] expected, double[] observed,\n         double tolerance) {\n                 out.append(\" expected = \");\n                 out.append(expected[i]);\n                 out.append(\" observed = \");\n-                out.append(observed[i]); \n+                out.append(observed[i]);\n             }\n         }\n         if (failure) {\n             Assert.fail(out.toString());\n         }\n     }\n-    \n+\n     /** verifies that two arrays are equal */\n     public static <T extends FieldElement<T>> void assertEquals(T[] m, T[] n) {\n         if (m.length != n.length) {\n             Assert.assertEquals(m[i],n[i]);\n         }\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/math/analysis/MonitoredFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/MonitoredFunction.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n /**\n  * Wrapper class for counting functions calls.\n  *\n- * @version $Revision$ $Date$ \n+ * @version $Revision$ $Date$\n  */\n public class MonitoredFunction implements UnivariateRealFunction {\n \n--- a/src/test/java/org/apache/commons/math/analysis/QuinticFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/QuinticFunction.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n /**\n  * Auxillary class for testing solvers.\n  *\n- * @version $Revision$ $Date$ \n+ * @version $Revision$ $Date$\n  */\n public class QuinticFunction implements DifferentiableUnivariateRealFunction {\n \n--- a/src/test/java/org/apache/commons/math/analysis/SinFunction.java\n+++ b/src/test/java/org/apache/commons/math/analysis/SinFunction.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * has an inflection point there (second order derivative is zero),\n  * which means linear approximation (Regula Falsi) will converge\n  * quadratically.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class SinFunction implements DifferentiableUnivariateRealFunction {\n--- a/src/test/java/org/apache/commons/math/analysis/integration/RombergIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/RombergIntegratorTest.java\n  * Romberg algorithm is very fast for good behavior integrand. Test runs\n  * show that for a default relative accuracy of 1E-6, it generally takes\n  * takes less than 5 iterations for the integral to converge.\n- * \n- * @version $Revision$ $Date$ \n+ *\n+ * @version $Revision$ $Date$\n  */\n public final class RombergIntegratorTest extends TestCase {\n \n--- a/src/test/java/org/apache/commons/math/analysis/integration/SimpsonIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/SimpsonIntegratorTest.java\n  * <p>\n  * Test runs show that for a default relative accuracy of 1E-6, it\n  * generally takes 5 to 10 iterations for the integral to converge.\n- * \n- * @version $Revision$ $Date$ \n+ *\n+ * @version $Revision$ $Date$\n  */\n public final class SimpsonIntegratorTest extends TestCase {\n \n--- a/src/test/java/org/apache/commons/math/analysis/integration/TrapezoidIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/integration/TrapezoidIntegratorTest.java\n  * <p>\n  * Test runs show that for a default relative accuracy of 1E-6, it\n  * generally takes 10 to 15 iterations for the integral to converge.\n- * \n- * @version $Revision$ $Date$ \n+ *\n+ * @version $Revision$ $Date$\n  */\n public final class TrapezoidIntegratorTest extends TestCase {\n \n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolatorTest.java\n  * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound\n  * it and use the absolute value upper bound for estimates. For reference,\n  * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2.\n- * \n- * @version $Revision$ $Date$ \n+ *\n+ * @version $Revision$ $Date$\n  */\n public final class DividedDifferenceInterpolatorTest extends TestCase {\n \n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolatorTest.java\n  * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound\n  * it and use the absolute value upper bound for estimates. For reference,\n  * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2.\n- * \n- * @version $Revision$ $Date$ \n+ *\n+ * @version $Revision$ $Date$\n  */\n public final class NevilleInterpolatorTest extends TestCase {\n \n--- a/src/test/java/org/apache/commons/math/analysis/interpolation/SplineInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/interpolation/SplineInterpolatorTest.java\n /**\n  * Test the SplineInterpolator.\n  *\n- * @version $Revision$ $Date$ \n+ * @version $Revision$ $Date$\n  */\n public class SplineInterpolatorTest extends TestCase {\n-    \n+\n     /** error tolerance for spline interpolator value at knot points */\n     protected double knotTolerance = 1E-12;\n-   \n+\n     /** error tolerance for interpolating polynomial coefficients */\n     protected double coefficientTolerance = 1E-6;\n-    \n+\n     /** error tolerance for interpolated values -- high value is from sin test */\n     protected double interpolationTolerance = 1E-2;\n \n         UnivariateRealFunction f = i.interpolate(x, y);\n         verifyInterpolation(f, x, y);\n         verifyConsistency((PolynomialSplineFunction) f, x);\n-        \n+\n         // Verify coefficients using analytical values\n         PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();\n         double target[] = {y[0], 1d};\n         TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);\n         target = new double[]{y[1], 1d};\n         TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);\n-        \n+\n         // Check interpolation\n         assertEquals(0.0,f.value(0.0), interpolationTolerance);\n         assertEquals(0.4,f.value(0.4), interpolationTolerance);\n         UnivariateRealInterpolator i = new SplineInterpolator();\n         UnivariateRealFunction f = i.interpolate(x, y);\n         verifyInterpolation(f, x, y);\n-        \n+\n         // Verify coefficients using analytical values\n         PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();\n         double target[] = {y[0], 1d};\n         TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);\n         target = new double[]{y[2], 1d};\n         TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);\n-        \n+\n         // Check interpolation\n         assertEquals(0,f.value(0), interpolationTolerance);\n         assertEquals(1.4,f.value(1.4), interpolationTolerance);\n         UnivariateRealFunction f = i.interpolate(x, y);\n         verifyInterpolation(f, x, y);\n         verifyConsistency((PolynomialSplineFunction) f, x);\n-        \n+\n         // Verify coefficients using analytical values\n         PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();\n         double target[] = {y[0], 1.5d, 0d, -2d};\n         TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);\n         target = new double[]{y[1], 0d, -3d, 2d};\n-        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);    \n-    }\n-    \n+        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);\n+    }\n+\n     public void testInterpolateSin() throws Exception {\n         double x[] =\n             {\n         UnivariateRealFunction f = i.interpolate(x, y);\n         verifyInterpolation(f, x, y);\n         verifyConsistency((PolynomialSplineFunction) f, x);\n-        \n+\n         /* Check coefficients against values computed using R (version 1.8.1, Red Hat Linux 9)\n-         * \n+         *\n          * To replicate in R:\n          *     x[1] <- 0\n          *     x[2] <- pi / 6, etc, same for y[] (could use y <- scan() for y values)\n          *     g <- splinefun(x, y, \"natural\")\n          *     splinecoef <- eval(expression(z), envir = environment(g))\n-         *     print(splinecoef) \n+         *     print(splinecoef)\n          */\n         PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();\n         double target[] = {y[0], 1.002676d, 0d, -0.17415829d};\n         target = new double[]{y[6], 3.466465e-16, 5.471344e-01, -0.08707914};\n         TestUtils.assertEquals(polynomials[6].getCoefficients(), target, coefficientTolerance);\n         target = new double[]{y[7], 8.594367e-01, 2.735672e-01, -0.17415829};\n-        TestUtils.assertEquals(polynomials[7].getCoefficients(), target, coefficientTolerance); \n-        \n+        TestUtils.assertEquals(polynomials[7].getCoefficients(), target, coefficientTolerance);\n+\n         //Check interpolation\n         assertEquals(Math.sqrt(2d) / 2d,f.value(Math.PI/4d),interpolationTolerance);\n-        assertEquals(Math.sqrt(2d) / 2d,f.value(3d*Math.PI/4d),interpolationTolerance);     \n-    }\n-    \n+        assertEquals(Math.sqrt(2d) / 2d,f.value(3d*Math.PI/4d),interpolationTolerance);\n+    }\n+\n \n     public void testIllegalArguments() throws MathException {\n         // Data set arrays of different size.\n         } catch (IllegalArgumentException iae) {\n         }\n     }\n-    \n+\n     /**\n      * verifies that f(x[i]) = y[i] for i = 0..n-1 where n is common length.\n      */\n-    protected void verifyInterpolation(UnivariateRealFunction f, double x[], double y[])  \n+    protected void verifyInterpolation(UnivariateRealFunction f, double x[], double y[])\n         throws Exception{\n         for (int i = 0; i < x.length; i++) {\n             assertEquals(f.value(x[i]), y[i], knotTolerance);\n-        }     \n-    }\n-    \n+        }\n+    }\n+\n     /**\n      * Verifies that interpolating polynomials satisfy consistency requirement:\n      *    adjacent polynomials must agree through two derivatives at knot points\n      */\n-    protected void verifyConsistency(PolynomialSplineFunction f, double x[]) \n+    protected void verifyConsistency(PolynomialSplineFunction f, double x[])\n         throws Exception {\n         PolynomialFunction polynomials[] = f.getPolynomials();\n         for (int i = 1; i < x.length - 2; i++) {\n-            // evaluate polynomials and derivatives at x[i + 1]  \n-            assertEquals(polynomials[i].value(x[i +1] - x[i]), polynomials[i + 1].value(0), 0.1); \n-            assertEquals(polynomials[i].derivative().value(x[i +1] - x[i]), \n-                    polynomials[i + 1].derivative().value(0), 0.5); \n-            assertEquals(polynomials[i].polynomialDerivative().derivative().value(x[i +1] - x[i]), \n-                    polynomials[i + 1].polynomialDerivative().derivative().value(0), 0.5); \n-        }\n-    }\n-    \n+            // evaluate polynomials and derivatives at x[i + 1]\n+            assertEquals(polynomials[i].value(x[i +1] - x[i]), polynomials[i + 1].value(0), 0.1);\n+            assertEquals(polynomials[i].derivative().value(x[i +1] - x[i]),\n+                    polynomials[i + 1].derivative().value(0), 0.5);\n+            assertEquals(polynomials[i].polynomialDerivative().derivative().value(x[i +1] - x[i]),\n+                    polynomials[i + 1].polynomialDerivative().derivative().value(0), 0.5);\n+        }\n+    }\n+\n }\n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeFormTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeFormTest.java\n  * give us the exact same polynomial as result. Thus we can use a very\n  * small tolerance to account only for round-off errors.\n  *\n- * @version $Revision$ $Date$ \n+ * @version $Revision$ $Date$\n  */\n public final class PolynomialFunctionLagrangeFormTest extends TestCase {\n \n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonFormTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonFormTest.java\n  * <p>\n  * The small tolerance number is used only to account for round-off errors.\n  *\n- * @version $Revision$ $Date$ \n+ * @version $Revision$ $Date$\n  */\n public final class PolynomialFunctionNewtonFormTest extends TestCase {\n \n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionTest.java\n         assertEquals( f.value( -123.5), c[0], tolerance );\n         assertEquals( f.value( 3.0), c[0], tolerance );\n         assertEquals( f.value( 456.89), c[0], tolerance );\n-        \n+\n         assertEquals(f.degree(), 0);\n         assertEquals(f.derivative().value(0), 0, tolerance);\n-        \n+\n         assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance);\n     }\n \n      * tests the value of a linear polynomial.\n      *\n      * <p>This will test the function f(x) = 3*x - 1.5</p>\n-     * <p>This will have the values \n+     * <p>This will have the values\n      *  <tt>f(0.0) = -1.5, f(-1.0) = -4.5, f(-2.5) = -9.0,\n      *      f(0.5) = 0.0, f(1.5) = 3.0</tt> and <tt>f(3.0) = 7.5</tt>\n      * </p>\n         assertEquals( 0.0, f.value( 0.5), tolerance );\n         assertEquals( 3.0, f.value( 1.5), tolerance );\n         assertEquals( 7.5, f.value( 3.0), tolerance );\n-        \n+\n         assertEquals(f.degree(), 1);\n-        \n+\n         assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance);\n-    \n+\n     }\n \n \n         assertEquals( -2.0, f.value( 1.5), tolerance );\n         assertEquals( 7.0, f.value( -1.5), tolerance );\n         assertEquals( 265.5312, f.value( 12.34), tolerance );\n-    \n-    }    \n-\n-\n-    /** \n-     * This will test the quintic function \n+\n+    }\n+\n+\n+    /**\n+     * This will test the quintic function\n      *   f(x) = x^2(x-5)(x+3)(x-1) = x^5 - 3x^4 -13x^3 + 15x^2</p>\n      *\n      */\n         assertEquals( 0.0, f.value( -3.0), tolerance );\n         assertEquals( 54.84375, f.value( -1.5), tolerance );\n         assertEquals( -8.06637, f.value( 1.3), tolerance );\n-        \n+\n         assertEquals(f.degree(), 5);\n-    \n-    }    \n+\n+    }\n \n \n     /**\n      * tests the firstDerivative function by comparison\n      *\n-     * <p>This will test the functions \n+     * <p>This will test the functions\n      * <tt>f(x) = x^3 - 2x^2 + 6x + 3, g(x) = 3x^2 - 4x + 6</tt>\n      * and <tt>h(x) = 6x - 4</tt>\n      */\n         PolynomialFunction p2 = new PolynomialFunction(new double[] { 3.0, 2.0, 1.0 });\n         assertEquals(p2, TestUtils.serializeAndRecover(p2));\n     }\n-    \n+\n     public void checkPolynomial(PolynomialFunction p, String reference) {\n         assertEquals(reference, p.toString());\n     }\n--- a/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunctionTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunctionTest.java\n \n     /** Error tolerance for tests */\n     protected double tolerance = 1.0e-12;\n-    \n-    /** \n-     * Quadratic polynomials used in tests: \n-     * \n+\n+    /**\n+     * Quadratic polynomials used in tests:\n+     *\n      * x^2 + x            [-1, 0)\n      * x^2 + x + 2        [0, 1)\n      * x^2 + x + 4        [1, 2)\n-     * \n+     *\n      * Defined so that evaluation using PolynomialSplineFunction evaluation\n      * algorithm agrees at knot point boundaries.\n      */\n     protected PolynomialFunction[] polynomials = {\n-        new PolynomialFunction(new double[] {0d, 1d, 1d}), \n+        new PolynomialFunction(new double[] {0d, 1d, 1d}),\n         new PolynomialFunction(new double[] {2d, 1d, 1d}),\n         new PolynomialFunction(new double[] {4d, 1d, 1d})\n     };\n-    \n+\n     /** Knot points  */\n     protected double[] knots = {-1, 0, 1, 2};\n-    \n+\n     /** Derivative of test polynomials -- 2x + 1  */\n-    protected PolynomialFunction dp = \n+    protected PolynomialFunction dp =\n         new PolynomialFunction(new double[] {1d, 2d});\n-    \n-    \n+\n+\n     public void testConstructor() {\n-        PolynomialSplineFunction spline = \n+        PolynomialSplineFunction spline =\n             new PolynomialSplineFunction(knots, polynomials);\n         assertTrue(Arrays.equals(knots, spline.getKnots()));\n         assertEquals(1d, spline.getPolynomials()[0].getCoefficients()[2], 0);\n         assertEquals(3, spline.getN());\n-        \n+\n         try { // too few knots\n             new PolynomialSplineFunction(new double[] {0}, polynomials);\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-        \n+\n         try { // too many knots\n             new PolynomialSplineFunction(new double[] {0,1,2,3,4}, polynomials);\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-        \n+\n         try { // knots not increasing\n             new PolynomialSplineFunction(new double[] {0,1, 3, 2}, polynomials);\n             fail(\"Expecting IllegalArgumentException\");\n             // expected\n         }\n     }\n-    \n+\n     public void testValues() throws Exception {\n-        PolynomialSplineFunction spline = \n+        PolynomialSplineFunction spline =\n             new PolynomialSplineFunction(knots, polynomials);\n         UnivariateRealFunction dSpline = spline.derivative();\n-        \n+\n         /**\n          * interior points -- spline value at x should equal p(x - knot)\n-         * where knot is the largest knot point less than or equal to x and p \n+         * where knot is the largest knot point less than or equal to x and p\n          * is the polynomial defined over the knot segment to which x belongs.\n          */\n         double x = -1;\n         for (int i = 0; i < 10; i++) {\n            x+=0.25;\n            index = findKnot(knots, x);\n-           assertEquals(\"spline function evaluation failed for x=\" + x, \n+           assertEquals(\"spline function evaluation failed for x=\" + x,\n                    polynomials[index].value(x - knots[index]), spline.value(x), tolerance);\n            assertEquals(\"spline derivative evaluation failed for x=\" + x,\n                    dp.value(x - knots[index]), dSpline.value(x), tolerance);\n         }\n-        \n+\n         // knot points -- centering should zero arguments\n         for (int i = 0; i < 3; i++) {\n             assertEquals(\"spline function evaluation failed for knot=\" + knots[i],\n             assertEquals(\"spline function evaluation failed for knot=\" + knots[i],\n                     dp.value(0), dSpline.value(knots[i]), tolerance);\n         }\n-        \n+\n         try { //outside of domain -- under min\n             x = spline.value(-1.5);\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (FunctionEvaluationException ex) {\n             // expected\n         }\n-        \n+\n         try { //outside of domain -- over max\n             x = spline.value(2.5);\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (FunctionEvaluationException ex) {\n             // expected\n-        }         \n-    }  \n-    \n+        }\n+    }\n+\n     /**\n      *  Do linear search to find largest knot point less than or equal to x.\n      *  Implementation does binary search.\n          throw new IllegalArgumentException(\"x is out of range\");\n      }\n }\n-    \n+\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BisectionSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BisectionSolverTest.java\n     public void testDeprecated() throws MathException {\n         UnivariateRealFunction f = new SinFunction();\n         double result;\n-        \n+\n         UnivariateRealSolver solver = new BisectionSolver(f);\n         result = solver.solve(3, 4);\n         assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n     public void testSinZero() throws MathException {\n         UnivariateRealFunction f = new SinFunction();\n         double result;\n-        \n+\n         UnivariateRealSolver solver = new BisectionSolver();\n         result = solver.solve(f, 3, 4);\n         assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(f, 0.85, 5);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n-        \n+\n         assertEquals(result, solver.getResult(), 0);\n         assertTrue(solver.getIterationCount() > 0);\n     }\n-    \n+\n     /**\n-     * \n+     *\n      */\n     public void testSetFunctionValueAccuracy(){\n-        double expected = 1.0e-2;    \n+        double expected = 1.0e-2;\n         UnivariateRealSolver solver = new BisectionSolver();\n         solver.setFunctionValueAccuracy(expected);\n         assertEquals(expected, solver.getFunctionValueAccuracy(), 1.0e-2);\n-    }        \n-    \n+    }\n+\n     /**\n-     * \n+     *\n      */\n     public void testResetFunctionValueAccuracy(){\n-        double newValue = 1.0e-2;    \n+        double newValue = 1.0e-2;\n         UnivariateRealSolver solver = new BisectionSolver();\n         double oldValue = solver.getFunctionValueAccuracy();\n         solver.setFunctionValueAccuracy(newValue);\n         solver.resetFunctionValueAccuracy();\n         assertEquals(oldValue, solver.getFunctionValueAccuracy(), 1.0e-2);\n-    }        \n-    \n+    }\n+\n     /**\n-     * \n+     *\n      */\n     public void testSetAbsoluteAccuracy(){\n-        double expected = 1.0e-2; \n+        double expected = 1.0e-2;\n         UnivariateRealSolver solver = new BisectionSolver();\n         solver.setAbsoluteAccuracy(expected);\n-        assertEquals(expected, solver.getAbsoluteAccuracy(), 1.0e-2); \n-    }        \n-    \n+        assertEquals(expected, solver.getAbsoluteAccuracy(), 1.0e-2);\n+    }\n+\n     /**\n-     * \n+     *\n      */\n     public void testResetAbsoluteAccuracy(){\n-        double newValue = 1.0e-2;       \n+        double newValue = 1.0e-2;\n         UnivariateRealSolver solver = new BisectionSolver();\n         double oldValue = solver.getAbsoluteAccuracy();\n         solver.setAbsoluteAccuracy(newValue);\n         solver.resetAbsoluteAccuracy();\n         assertEquals(oldValue, solver.getAbsoluteAccuracy(), 1.0e-2);\n-    }        \n-    \n+    }\n+\n     /**\n-     * \n+     *\n      */\n     public void testSetMaximalIterationCount(){\n         int expected = 100;\n         UnivariateRealSolver solver = new BisectionSolver();\n         solver.setMaximalIterationCount(expected);\n         assertEquals(expected, solver.getMaximalIterationCount());\n-    }        \n-    \n+    }\n+\n     /**\n-     * \n+     *\n      */\n     public void testResetMaximalIterationCount(){\n         int newValue = 10000;\n         solver.setMaximalIterationCount(newValue);\n         solver.resetMaximalIterationCount();\n         assertEquals(oldValue, solver.getMaximalIterationCount());\n-    }        \n-    \n+    }\n+\n     /**\n-     * \n+     *\n      */\n     public void testSetRelativeAccuracy(){\n         double expected = 1.0e-2;\n         UnivariateRealSolver solver = new BisectionSolver();\n         solver.setRelativeAccuracy(expected);\n         assertEquals(expected, solver.getRelativeAccuracy(), 1.0e-2);\n-    }        \n-    \n+    }\n+\n     /**\n-     * \n+     *\n      */\n     public void testResetRelativeAccuracy(){\n-        double newValue = 1.0e-2;        \n+        double newValue = 1.0e-2;\n         UnivariateRealSolver solver = new BisectionSolver();\n         double oldValue = solver.getRelativeAccuracy();\n         solver.setRelativeAccuracy(newValue);\n         solver.resetRelativeAccuracy();\n         assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);\n-    }        \n-    \n-   \n+    }\n+\n+\n }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * regressions. On average Brent-Dekker should use 4..5 iterations for the\n  * default absolute accuracy of 10E-8 for sinus and the quintic function around\n  * zero, and 5..10 iterations for the other zeros.\n- * \n- * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $ \n+ *\n+ * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $\n  */\n public final class BrentSolverTest extends TestCase {\n \n     public void testDeprecated() throws MathException {\n         // The sinus function is behaved well around the root at #pi. The second\n         // order derivative is zero, which means linar approximating methods will\n-        // still converge quadratically. \n+        // still converge quadratically.\n         UnivariateRealFunction f = new SinFunction();\n         double result;\n         UnivariateRealSolver solver = new BrentSolver(f);\n     public void testSinZero() throws MathException {\n         // The sinus function is behaved well around the root at #pi. The second\n         // order derivative is zero, which means linar approximating methods will\n-        // still converge quadratically. \n+        // still converge quadratically.\n         UnivariateRealFunction f = new SinFunction();\n         double result;\n         UnivariateRealSolver solver = new BrentSolver();\n         result = UnivariateRealSolverUtils.solve(f, 0.85, 5);\n         assertEquals(result, 1.0, 1E-6);\n     }\n-    \n+\n     public void testRootEndpoints() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealSolver solver = new BrentSolver();\n-        \n+\n         // endpoint is root\n         double result = solver.solve(f, Math.PI, 4);\n         assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n         result = solver.solve(f, 3, Math.PI);\n         assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n     }\n-    \n+\n     public void testBadEndpoints() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n         UnivariateRealSolver solver = new BrentSolver();\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         int referenceCallsCount = f.getCallsCount();\n         assertTrue(referenceCallsCount >= 13);\n- \n+\n         // invalid guess (it *is* a root, but outside of the range)\n         try {\n           result = solver.solve(f, 0.6, 7.0, 0.0);\n         } catch (Exception e) {\n             fail(\"wrong exception caught: \" + e.getMessage());\n         }\n- \n+\n         // bad guess\n         f.setCallsCount(0);\n         result = solver.solve(f, 0.6, 7.0, 0.61);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         assertTrue(f.getCallsCount() > referenceCallsCount);\n- \n+\n         // good guess\n         f.setCallsCount(0);\n         result = solver.solve(f, 0.6, 7.0, 0.999999);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n         assertEquals(0, solver.getIterationCount());\n         assertEquals(1, f.getCallsCount());\n- \n-    }\n-    \n+\n+    }\n+\n }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/LaguerreSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/LaguerreSolverTest.java\n  * show that for a default absolute accuracy of 1E-6, it generally takes\n  * less than 5 iterations to find one root, provided solveAll() is not\n  * invoked, and 15 to 20 iterations to find all roots for quintic function.\n- * \n- * @version $Revision$ $Date$ \n+ *\n+ * @version $Revision$ $Date$\n  */\n public final class LaguerreSolverTest extends TestCase {\n \n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n         TestUtils.assertContains(result, expected, tolerance);\n-        \n+\n         expected = new Complex(0.5, -0.5 * Math.sqrt(3.0));\n         tolerance = Math.max(solver.getAbsoluteAccuracy(),\n                     Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n  * <p>\n  * Tests for the exponential function illustrate the situations where\n  * Muller solver performs poorly.\n- * \n- * @version $Revision$ $Date$ \n+ *\n+ * @version $Revision$ $Date$\n  */\n public final class MullerSolverTest extends TestCase {\n \n--- a/src/test/java/org/apache/commons/math/analysis/solvers/NewtonSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/NewtonSolverTest.java\n     public void testDeprecated() throws MathException {\n         DifferentiableUnivariateRealFunction f = new SinFunction();\n         double result;\n-        \n+\n         UnivariateRealSolver solver = new NewtonSolver(f);\n         result = solver.solve(3, 4);\n         assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n \n         result = solver.solve(1, 4);\n         assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n-        \n+\n         assertEquals(result, solver.getResult(), 0);\n         assertTrue(solver.getIterationCount() > 0);\n     }\n    public void testSinZero() throws MathException {\n        DifferentiableUnivariateRealFunction f = new SinFunction();\n        double result;\n-       \n+\n        UnivariateRealSolver solver = new NewtonSolver();\n        result = solver.solve(f, 3, 4);\n        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n \n        result = solver.solve(f, 1, 4);\n        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n-       \n+\n        assertEquals(result, solver.getResult(), 0);\n        assertTrue(solver.getIterationCount() > 0);\n    }\n         result = solver.solve(f, 0.85, 5);\n         assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n  * accuracy of 1E-6, it generally takes less than 5 iterations for close\n  * initial bracket and 5 to 10 iterations for distant initial bracket\n  * to converge.\n- * \n- * @version $Revision$ $Date$ \n+ *\n+ * @version $Revision$ $Date$\n  */\n public final class RiddersSolverTest extends TestCase {\n \n--- a/src/test/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverFactoryImplTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverFactoryImplTest.java\n  * @version $Revision$ $Date$\n  */\n public class UnivariateRealSolverFactoryImplTest extends TestCase {\n-    \n+\n     /** solver factory */\n     private UnivariateRealSolverFactory factory;\n-    \n+\n     /**\n      * @throws java.lang.Exception\n      * @see junit.framework.TestCase#tearDown()\n         super.setUp();\n         factory = new UnivariateRealSolverFactoryImpl();\n     }\n-    \n+\n     /**\n      * @throws java.lang.Exception\n      * @see junit.framework.TestCase#tearDown()\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * @version $Revision$ $Date$\n  */\n public class UnivariateRealSolverUtilsTest extends TestCase {\n-    \n+\n     protected UnivariateRealFunction sin = new SinFunction();\n-    \n+\n     public void testSolveNull() throws MathException {\n         try {\n             UnivariateRealSolverUtils.solve(null, 0.0, 4.0);\n             // success\n         }\n     }\n-    \n+\n     public void testSolveBadParameters() throws MathException {\n         try { // bad endpoints\n-            UnivariateRealSolverUtils.solve(sin,0.0, 4.0, 4.0); \n+            UnivariateRealSolverUtils.solve(sin,0.0, 4.0, 4.0);\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }    \n+        }\n         try { // bad accuracy\n-            UnivariateRealSolverUtils.solve(sin, 0.0, 4.0, 0.0); \n+            UnivariateRealSolverUtils.solve(sin, 0.0, 4.0, 0.0);\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }        \n+        }\n     }\n-    \n-    public void testSolveSin() throws MathException {     \n+\n+    public void testSolveSin() throws MathException {\n         double x = UnivariateRealSolverUtils.solve(sin, 1.0, 4.0);\n         assertEquals(Math.PI, x, 1.0e-4);\n     }\n-    \n+\n     public void testSolveAccuracyNull()  throws MathException {\n         try {\n             double accuracy = 1.0e-6;\n             // success\n         }\n     }\n-    \n+\n     public void testSolveAccuracySin() throws MathException {\n         double accuracy = 1.0e-6;\n         double x = UnivariateRealSolverUtils.solve(sin, 1.0,\n                 4.0, accuracy);\n         assertEquals(Math.PI, x, accuracy);\n     }\n-    \n+\n     public void testSolveNoRoot() throws MathException {\n         try {\n-            UnivariateRealSolverUtils.solve(sin, 1.0, 1.5);  \n-            fail(\"Expecting IllegalArgumentException \");  \n+            UnivariateRealSolverUtils.solve(sin, 1.0, 1.5);\n+            fail(\"Expecting IllegalArgumentException \");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n     }\n-    \n+\n     public void testBracketSin() throws MathException {\n-        double[] result = UnivariateRealSolverUtils.bracket(sin, \n+        double[] result = UnivariateRealSolverUtils.bracket(sin,\n                 0.0, -2.0, 2.0);\n         assertTrue(sin.value(result[0]) < 0);\n         assertTrue(sin.value(result[1]) > 0);\n     }\n-    \n+\n     public void testBracketEndpointRoot() throws MathException {\n         double[] result = UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0);\n         assertEquals(0.0, sin.value(result[0]), 1.0e-15);\n         assertTrue(sin.value(result[1]) > 0);\n     }\n-    \n+\n     public void testBadParameters() throws MathException {\n         try { // null function\n             UnivariateRealSolverUtils.bracket(null, 1.5, 0, 2.0);\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }        \n+        }\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/math/complex/ComplexFormatAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexFormatAbstractTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n import junit.framework.TestCase;\n \n public abstract class ComplexFormatAbstractTest extends TestCase {\n- \n+\n     CompositeFormat complexFormat = null;\n     ComplexFormat complexFormatJ = null;\n \n         complexFormatJ = ComplexFormat.getInstance(getLocale());\n         complexFormatJ.setImaginaryCharacter(\"j\");\n     }\n-   \n+\n     public void testSimpleNoDecimals() {\n         Complex c = new Complex(1, 1);\n         String expected = \"1 + 1i\";\n-        String actual = complexFormat.format(c); \n+        String actual = complexFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n     public void testSimpleWithDecimals() {\n         Complex c = new Complex(1.23, 1.43);\n         String expected = \"1\" + getDecimalCharacter() + \"23 + 1\" + getDecimalCharacter() + \"43i\";\n-        String actual = complexFormat.format(c); \n+        String actual = complexFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n     public void testSimpleWithDecimalsTrunc() {\n         Complex c = new Complex(1.2323, 1.4343);\n         String expected = \"1\" + getDecimalCharacter() + \"23 + 1\" + getDecimalCharacter() + \"43i\";\n-        String actual = complexFormat.format(c); \n+        String actual = complexFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n     public void testNegativeReal() {\n         Complex c = new Complex(-1.2323, 1.4343);\n         String expected = \"-1\" + getDecimalCharacter() + \"23 + 1\" + getDecimalCharacter() + \"43i\";\n-        String actual = complexFormat.format(c); \n+        String actual = complexFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n     public void testNegativeImaginary() {\n         Complex c = new Complex(1.2323, -1.4343);\n         String expected = \"1\" + getDecimalCharacter() + \"23 - 1\" + getDecimalCharacter() + \"43i\";\n-        String actual = complexFormat.format(c); \n+        String actual = complexFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n     public void testNegativeBoth() {\n         Complex c = new Complex(-1.2323, -1.4343);\n         String expected = \"-1\" + getDecimalCharacter() + \"23 - 1\" + getDecimalCharacter() + \"43i\";\n-        String actual = complexFormat.format(c); \n+        String actual = complexFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n     public void testZeroReal() {\n         Complex c = new Complex(0.0, -1.4343);\n         String expected = \"0 - 1\" + getDecimalCharacter() + \"43i\";\n-        String actual = complexFormat.format(c); \n+        String actual = complexFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n     public void testZeroImaginary() {\n         Complex c = new Complex(30.233, 0);\n         String expected = \"30\" + getDecimalCharacter() + \"23\";\n-        String actual = complexFormat.format(c); \n+        String actual = complexFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n     public void testDifferentImaginaryChar() {\n         Complex c = new Complex(1, 1);\n         String expected = \"1 + 1j\";\n-        String actual = complexFormatJ.format(c); \n-        assertEquals(expected, actual);\n-    }\n-    \n+        String actual = complexFormatJ.format(c);\n+        assertEquals(expected, actual);\n+    }\n+\n     public void testStaticFormatComplex() {\n         Locale defaultLocal = Locale.getDefault();\n         Locale.setDefault(getLocale());\n-        \n+\n         Complex c = new Complex(232.222, -342.33);\n         String expected = \"232\" + getDecimalCharacter() + \"22 - 342\" + getDecimalCharacter() + \"33i\";\n-        String actual = ComplexFormat.formatComplex(c); \n-        assertEquals(expected, actual);\n-        \n+        String actual = ComplexFormat.formatComplex(c);\n+        assertEquals(expected, actual);\n+\n         Locale.setDefault(defaultLocal);\n     }\n \n     public void testNan() {\n         Complex c = new Complex(Double.NaN, Double.NaN);\n         String expected = \"(NaN) + (NaN)i\";\n-        String actual = complexFormat.format(c); \n+        String actual = complexFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n     public void testPositiveInfinity() {\n         Complex c = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n         String expected = \"(Infinity) + (Infinity)i\";\n-        String actual = complexFormat.format(c); \n+        String actual = complexFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n     public void testNegativeInfinity() {\n         Complex c = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n         String expected = \"(-Infinity) - (Infinity)i\";\n-        String actual = complexFormat.format(c); \n-        assertEquals(expected, actual);\n-    }\n-    \n+        String actual = complexFormat.format(c);\n+        assertEquals(expected, actual);\n+    }\n+\n     public void testParseSimpleNoDecimals() {\n         String source = \"1 + 1i\";\n         Complex expected = new Complex(1, 1);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source); \n+            Complex actual = (Complex)complexFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n         String source = \"1\" + getDecimalCharacter() + \"23 + 1\" + getDecimalCharacter() + \"43i\";\n         Complex expected = new Complex(1.23, 1.43);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source); \n+            Complex actual = (Complex)complexFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n         String source = \"1\" + getDecimalCharacter() + \"2323 + 1\" + getDecimalCharacter() + \"4343i\";\n         Complex expected = new Complex(1.2323, 1.4343);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source); \n+            Complex actual = (Complex)complexFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n         String source = \"-1\" + getDecimalCharacter() + \"2323 + 1\" + getDecimalCharacter() + \"4343i\";\n         Complex expected = new Complex(-1.2323, 1.4343);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source); \n+            Complex actual = (Complex)complexFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n         String source = \"1\" + getDecimalCharacter() + \"2323 - 1\" + getDecimalCharacter() + \"4343i\";\n         Complex expected = new Complex(1.2323, -1.4343);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source); \n+            Complex actual = (Complex)complexFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n         String source = \"-1\" + getDecimalCharacter() + \"2323 - 1\" + getDecimalCharacter() + \"4343i\";\n         Complex expected = new Complex(-1.2323, -1.4343);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source); \n+            Complex actual = (Complex)complexFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n         String source = \"0\" + getDecimalCharacter() + \"0 - 1\" + getDecimalCharacter() + \"4343i\";\n         Complex expected = new Complex(0.0, -1.4343);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source); \n+            Complex actual = (Complex)complexFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n         String source = \"-1\" + getDecimalCharacter() + \"2323\";\n         Complex expected = new Complex(-1.2323, 0);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source); \n+            Complex actual = (Complex)complexFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n         String source = \"-1\" + getDecimalCharacter() + \"2323 - 1\" + getDecimalCharacter() + \"4343j\";\n         Complex expected = new Complex(-1.2323, -1.4343);\n         try {\n-            Complex actual = (Complex)complexFormatJ.parseObject(source); \n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-    \n+            Complex actual = (Complex)complexFormatJ.parseObject(source);\n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n     public void testParseNan() {\n         String source = \"(NaN) + (NaN)i\";\n         Complex expected = new Complex(Double.NaN, Double.NaN);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source); \n+            Complex actual = (Complex)complexFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n         String source = \"(Infinity) + (Infinity)i\";\n         Complex expected = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source); \n+            Complex actual = (Complex)complexFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n         String source = \"(-Infinity) - (Infinity)i\";\n         Complex expected = new Complex(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n         try {\n-            Complex actual = (Complex)complexFormat.parseObject(source); \n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-    \n+            Complex actual = (Complex)complexFormat.parseObject(source);\n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n     public void testConstructorSingleFormat() {\n         NumberFormat nf = NumberFormat.getInstance();\n         ComplexFormat cf = new ComplexFormat(nf);\n         assertNotNull(cf);\n         assertEquals(nf, cf.getRealFormat());\n     }\n-    \n+\n     public void testGetImaginaryFormat() {\n         NumberFormat nf = NumberFormat.getInstance();\n         ComplexFormat cf = new ComplexFormat();\n-        \n+\n         assertNotSame(nf, cf.getImaginaryFormat());\n         cf.setImaginaryFormat(nf);\n         assertSame(nf, cf.getImaginaryFormat());\n     }\n-    \n+\n     public void testSetImaginaryFormatNull() {\n         try {\n             ComplexFormat cf = new ComplexFormat();\n             // success\n         }\n     }\n-    \n+\n     public void testSetRealFormatNull() {\n         try {\n             ComplexFormat cf = new ComplexFormat();\n             // success\n         }\n     }\n-    \n+\n     public void testGetRealFormat() {\n         NumberFormat nf = NumberFormat.getInstance();\n         ComplexFormat cf = new ComplexFormat();\n-        \n+\n         assertNotSame(nf, cf.getRealFormat());\n         cf.setRealFormat(nf);\n         assertSame(nf, cf.getRealFormat());\n     }\n-    \n+\n     public void testSetImaginaryCharacterNull() {\n         try {\n             ComplexFormat cf = new ComplexFormat();\n             // success\n         }\n     }\n-    \n+\n     public void testSetImaginaryCharacterEmpty() {\n         try {\n             ComplexFormat cf = new ComplexFormat();\n             // success\n         }\n     }\n-    \n+\n     public void testFormatNumber() {\n         CompositeFormat cf = ComplexFormat.getInstance(getLocale());\n         Double pi = Double.valueOf(Math.PI);\n         String text = cf.format(pi);\n         assertEquals(\"3\" + getDecimalCharacter() + \"14\", text);\n     }\n-    \n+\n     public void testFormatObject() {\n         try {\n             CompositeFormat cf = new ComplexFormat();\n--- a/src/test/java/org/apache/commons/math/complex/ComplexFormatTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexFormatTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     protected char getDecimalCharacter() {\n         return '.';\n     }\n-    \n+\n     @Override\n     protected Locale getLocale() {\n         return Locale.US;\n--- a/src/test/java/org/apache/commons/math/complex/ComplexTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * @version $Revision$ $Date$\n  */\n public class ComplexTest extends TestCase {\n-    \n+\n \n     private double inf = Double.POSITIVE_INFINITY;\n     private double neginf = Double.NEGATIVE_INFINITY;\n     private Complex nanInf = new Complex(nan, inf);\n     private Complex nanNegInf = new Complex(nan, neginf);\n     private Complex nanZero = new Complex(nan, 0);\n-    \n+\n     public void testConstructor() {\n         Complex z = new Complex(3.0, 4.0);\n         assertEquals(3.0, z.getReal(), 1.0e-5);\n         assertEquals(4.0, z.getImaginary(), 1.0e-5);\n     }\n-    \n+\n     public void testConstructorNaN() {\n         Complex z = new Complex(3.0, Double.NaN);\n         assertTrue(z.isNaN());\n         z = new Complex(3.0, 4.0);\n         assertFalse(z.isNaN());\n     }\n-    \n+\n     public void testAbs() {\n         Complex z = new Complex(3.0, 4.0);\n         assertEquals(5.0, z.abs(), 1.0e-5);\n     }\n-    \n+\n     public void testAbsNaN() {\n         assertTrue(Double.isNaN(Complex.NaN.abs()));\n         Complex z = new Complex(inf, nan);\n         assertTrue(Double.isNaN(z.abs()));\n     }\n-    \n+\n     public void testAbsInfinite() {\n         Complex z = new Complex(inf, 0);\n         assertEquals(inf, z.abs(), 0);\n         z = new Complex(0, neginf);\n         assertEquals(inf, z.abs(), 0);\n         z = new Complex(inf, neginf);\n-        assertEquals(inf, z.abs(), 0);     \n-    }\n-    \n+        assertEquals(inf, z.abs(), 0);\n+    }\n+\n     public void testAdd() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex y = new Complex(5.0, 6.0);\n         assertEquals(8.0, z.getReal(), 1.0e-5);\n         assertEquals(10.0, z.getImaginary(), 1.0e-5);\n     }\n-    \n+\n     public void testAddNaN() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.add(Complex.NaN);\n         assertEquals(w.getReal(), 4.0, 0);\n         assertTrue(Double.isNaN(w.getImaginary()));\n     }\n-    \n+\n     public void testAddInfinite() {\n         Complex x = new Complex(1, 1);\n         Complex z = new Complex(inf, 0);\n         Complex w = x.add(z);\n         assertEquals(w.getImaginary(), 1, 0);\n         assertEquals(inf, w.getReal(), 0);\n-        \n+\n         x = new Complex(neginf, 0);\n         assertTrue(Double.isNaN(x.add(z).getReal()));\n     }\n-    \n+\n     public void testConjugate() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.conjugate();\n         assertEquals(3.0, z.getReal(), 1.0e-5);\n         assertEquals(-4.0, z.getImaginary(), 1.0e-5);\n     }\n-    \n+\n     public void testConjugateNaN() {\n         Complex z = Complex.NaN.conjugate();\n         assertTrue(z.isNaN());\n     }\n-    \n+\n     public void testConjugateInfiinite() {\n         Complex z = new Complex(0, inf);\n         assertEquals(neginf, z.conjugate().getImaginary(), 0);\n         z = new Complex(0, neginf);\n         assertEquals(inf, z.conjugate().getImaginary(), 0);\n     }\n-    \n+\n     public void testDivide() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex y = new Complex(5.0, 6.0);\n         assertEquals(39.0 / 61.0, z.getReal(), 1.0e-5);\n         assertEquals(2.0 / 61.0, z.getImaginary(), 1.0e-5);\n     }\n-    \n+\n     public void testDivideInfinite() {\n         Complex x = new Complex(3, 4);\n         Complex w = new Complex(neginf, inf);\n         assertTrue(x.divide(w).equals(Complex.ZERO));\n-        \n+\n         Complex z = w.divide(x);\n         assertTrue(Double.isNaN(z.getReal()));\n         assertEquals(inf, z.getImaginary(), 0);\n-        \n+\n         w = new Complex(inf, inf);\n         z = w.divide(x);\n         assertTrue(Double.isNaN(z.getImaginary()));\n         assertEquals(inf, z.getReal(), 0);\n-        \n+\n         w = new Complex(1, inf);\n         z = w.divide(w);\n         assertTrue(Double.isNaN(z.getReal()));\n         assertTrue(Double.isNaN(z.getImaginary()));\n     }\n-    \n+\n     public void testDivideNaN() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.divide(Complex.NaN);\n         assertTrue(z.isNaN());\n     }\n-    \n-    public void testDivideNaNInf() {  \n+\n+    public void testDivideNaNInf() {\n        Complex z = oneInf.divide(Complex.ONE);\n        assertTrue(Double.isNaN(z.getReal()));\n        assertEquals(inf, z.getImaginary(), 0);\n-       \n+\n        z = negInfNegInf.divide(oneNaN);\n        assertTrue(Double.isNaN(z.getReal()));\n        assertTrue(Double.isNaN(z.getImaginary()));\n-       \n+\n        z = negInfInf.divide(Complex.ONE);\n        assertTrue(Double.isNaN(z.getReal()));\n        assertTrue(Double.isNaN(z.getImaginary()));\n     }\n-    \n+\n     public void testMultiply() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex y = new Complex(5.0, 6.0);\n         assertEquals(-9.0, z.getReal(), 1.0e-5);\n         assertEquals(38.0, z.getImaginary(), 1.0e-5);\n     }\n-    \n+\n     public void testMultiplyNaN() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.multiply(Complex.NaN);\n         assertTrue(z.isNaN());\n     }\n-    \n+\n     public void testMultiplyNaNInf() {\n         Complex z = new Complex(1,1);\n         Complex w = z.multiply(infOne);\n         assertTrue(new Complex( 1,0).multiply(infInf).equals(Complex.INF));\n         assertTrue(new Complex(-1,0).multiply(infInf).equals(Complex.INF));\n         assertTrue(new Complex( 1,0).multiply(negInfZero).equals(Complex.INF));\n-        \n+\n         w = oneInf.multiply(oneNegInf);\n         assertEquals(w.getReal(), inf, 0);\n         assertEquals(w.getImaginary(), inf, 0);\n-        \n+\n         w = negInfNegInf.multiply(oneNaN);\n         assertTrue(Double.isNaN(w.getReal()));\n-        assertTrue(Double.isNaN(w.getImaginary()));  \n-    }\n-    \n+        assertTrue(Double.isNaN(w.getImaginary()));\n+    }\n+\n     public void testScalarMultiply() {\n         Complex x = new Complex(3.0, 4.0);\n         double y = 2.0;\n         assertEquals(6.0, z.getReal(), 1.0e-5);\n         assertEquals(8.0, z.getImaginary(), 1.0e-5);\n     }\n-    \n+\n     public void testScalarMultiplyNaN() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.multiply(Double.NaN);\n         assertTrue(z.isNaN());\n     }\n-    \n+\n     public void testScalarMultiplyInf() {\n         Complex z = new Complex(1,1);\n         Complex w = z.multiply(Double.POSITIVE_INFINITY);\n         assertEquals(w.getReal(), inf, 0);\n         assertEquals(w.getImaginary(), inf, 0);\n     }\n-    \n+\n     public void testNegate() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.negate();\n         assertEquals(-3.0, z.getReal(), 1.0e-5);\n         assertEquals(-4.0, z.getImaginary(), 1.0e-5);\n     }\n-    \n+\n     public void testNegateNaN() {\n         Complex z = Complex.NaN.negate();\n         assertTrue(z.isNaN());\n     }\n-    \n+\n     public void testSubtract() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex y = new Complex(5.0, 6.0);\n         assertEquals(-2.0, z.getReal(), 1.0e-5);\n         assertEquals(-2.0, z.getImaginary(), 1.0e-5);\n     }\n-    \n+\n     public void testSubtractNaN() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex z = x.subtract(Complex.NaN);\n         assertTrue(z.isNaN());\n     }\n-    \n+\n     public void testEqualsNull() {\n         Complex x = new Complex(3.0, 4.0);\n         assertFalse(x.equals(null));\n     }\n-    \n+\n     public void testEqualsClass() {\n         Complex x = new Complex(3.0, 4.0);\n         assertFalse(x.equals(this));\n     }\n-    \n+\n     public void testEqualsSame() {\n         Complex x = new Complex(3.0, 4.0);\n         assertTrue(x.equals(x));\n     }\n-    \n+\n     public void testEqualsTrue() {\n         Complex x = new Complex(3.0, 4.0);\n         Complex y = new Complex(3.0, 4.0);\n         assertTrue(x.equals(y));\n     }\n-    \n+\n     public void testEqualsRealDifference() {\n         Complex x = new Complex(0.0, 0.0);\n         Complex y = new Complex(0.0 + Double.MIN_VALUE, 0.0);\n         assertFalse(x.equals(y));\n     }\n-    \n+\n     public void testEqualsImaginaryDifference() {\n         Complex x = new Complex(0.0, 0.0);\n         Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);\n         assertFalse(x.equals(y));\n     }\n-    \n+\n     public void testEqualsNaN() {\n         Complex realNaN = new Complex(Double.NaN, 0.0);\n         Complex imaginaryNaN = new Complex(0.0, Double.NaN);\n         assertTrue(imaginaryNaN.equals(complexNaN));\n         assertTrue(realNaN.equals(complexNaN));\n     }\n-    \n+\n     public void testHashCode() {\n         Complex x = new Complex(0.0, 0.0);\n         Complex y = new Complex(0.0, 0.0 + Double.MIN_VALUE);\n         assertEquals(realNaN.hashCode(), imaginaryNaN.hashCode());\n         assertEquals(imaginaryNaN.hashCode(), Complex.NaN.hashCode());\n     }\n-    \n+\n     public void testAcos() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(0.936812, -2.30551);\n         TestUtils.assertEquals(expected, z.acos(), 1.0e-5);\n-        TestUtils.assertEquals(new Complex(Math.acos(0), 0), \n+        TestUtils.assertEquals(new Complex(Math.acos(0), 0),\n                 Complex.ZERO.acos(), 1.0e-12);\n     }\n-    \n+\n     public void testAcosInf() {\n         TestUtils.assertSame(Complex.NaN, oneInf.acos());\n         TestUtils.assertSame(Complex.NaN, oneNegInf.acos());\n         TestUtils.assertSame(Complex.NaN, negInfInf.acos());\n         TestUtils.assertSame(Complex.NaN, negInfNegInf.acos());\n     }\n-    \n+\n     public void testAcosNaN() {\n         assertTrue(Complex.NaN.acos().isNaN());\n     }\n-    \n+\n     public void testAsin() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(0.633984, 2.30551);\n         TestUtils.assertEquals(expected, z.asin(), 1.0e-5);\n     }\n-    \n+\n     public void testAsinNaN() {\n         assertTrue(Complex.NaN.asin().isNaN());\n     }\n-    \n+\n     public void testAsinInf() {\n         TestUtils.assertSame(Complex.NaN, oneInf.asin());\n         TestUtils.assertSame(Complex.NaN, oneNegInf.asin());\n         TestUtils.assertSame(Complex.NaN, negInfInf.asin());\n         TestUtils.assertSame(Complex.NaN, negInfNegInf.asin());\n     }\n-    \n-   \n+\n+\n     public void testAtan() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(1.44831, 0.158997);\n         TestUtils.assertEquals(expected, z.atan(), 1.0e-5);\n     }\n-    \n+\n     public void testAtanInf() {\n         TestUtils.assertSame(Complex.NaN, oneInf.atan());\n         TestUtils.assertSame(Complex.NaN, oneNegInf.atan());\n         TestUtils.assertSame(Complex.NaN, infNegInf.atan());\n         TestUtils.assertSame(Complex.NaN, negInfInf.atan());\n         TestUtils.assertSame(Complex.NaN, negInfNegInf.atan());\n-    } \n-    \n+    }\n+\n     public void testAtanNaN() {\n         assertTrue(Complex.NaN.atan().isNaN());\n         assertTrue(Complex.I.atan().isNaN());\n     }\n-    \n+\n     public void testCos() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(-27.03495, -3.851153);\n         TestUtils.assertEquals(expected, z.cos(), 1.0e-5);\n     }\n-    \n+\n     public void testCosNaN() {\n         assertTrue(Complex.NaN.cos().isNaN());\n     }\n-    \n+\n     public void testCosInf() {\n         TestUtils.assertSame(infNegInf, oneInf.cos());\n         TestUtils.assertSame(infInf, oneNegInf.cos());\n         TestUtils.assertSame(Complex.NaN, infNegInf.cos());\n         TestUtils.assertSame(Complex.NaN, negInfInf.cos());\n         TestUtils.assertSame(Complex.NaN, negInfNegInf.cos());\n-    } \n-    \n+    }\n+\n     public void testCosh() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(-6.58066, -7.58155);\n         TestUtils.assertEquals(expected, z.cosh(), 1.0e-5);\n     }\n-    \n+\n     public void testCoshNaN() {\n         assertTrue(Complex.NaN.cosh().isNaN());\n     }\n-    \n-    public void testCoshInf() {  \n+\n+    public void testCoshInf() {\n         TestUtils.assertSame(Complex.NaN, oneInf.cosh());\n         TestUtils.assertSame(Complex.NaN, oneNegInf.cosh());\n         TestUtils.assertSame(infInf, infOne.cosh());\n         TestUtils.assertSame(Complex.NaN, infNegInf.cosh());\n         TestUtils.assertSame(Complex.NaN, negInfInf.cosh());\n         TestUtils.assertSame(Complex.NaN, negInfNegInf.cosh());\n-    } \n-    \n+    }\n+\n     public void testExp() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(-13.12878, -15.20078);\n         TestUtils.assertEquals(expected, z.exp(), 1.0e-5);\n-        TestUtils.assertEquals(Complex.ONE, \n+        TestUtils.assertEquals(Complex.ONE,\n                 Complex.ZERO.exp(), 10e-12);\n         Complex iPi = Complex.I.multiply(new Complex(pi,0));\n-        TestUtils.assertEquals(Complex.ONE.negate(), \n+        TestUtils.assertEquals(Complex.ONE.negate(),\n                 iPi.exp(), 10e-12);\n     }\n-    \n+\n     public void testExpNaN() {\n         assertTrue(Complex.NaN.exp().isNaN());\n     }\n-    \n+\n     public void testExpInf() {\n         TestUtils.assertSame(Complex.NaN, oneInf.exp());\n         TestUtils.assertSame(Complex.NaN, oneNegInf.exp());\n         TestUtils.assertSame(Complex.NaN, negInfInf.exp());\n         TestUtils.assertSame(Complex.NaN, negInfNegInf.exp());\n     }\n-    \n+\n     public void testLog() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(1.60944, 0.927295);\n         TestUtils.assertEquals(expected, z.log(), 1.0e-5);\n     }\n-    \n+\n     public void testLogNaN() {\n         assertTrue(Complex.NaN.log().isNaN());\n     }\n-    \n+\n     public void testLogInf() {\n         TestUtils.assertEquals(new Complex(inf, pi / 2),\n                 oneInf.log(), 10e-12);\n         TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4),\n                 negInfNegInf.log(), 10e-12);\n     }\n-    \n+\n     public void testLogZero() {\n         TestUtils.assertSame(negInfZero, Complex.ZERO.log());\n     }\n-    \n+\n     public void testPow() {\n         Complex x = new Complex(3, 4);\n         Complex y = new Complex(5, 6);\n         Complex expected = new Complex(-1.860893, 11.83677);\n         TestUtils.assertEquals(expected, x.pow(y), 1.0e-5);\n     }\n-    \n+\n     public void testPowNaNBase() {\n         Complex x = new Complex(3, 4);\n         assertTrue(Complex.NaN.pow(x).isNaN());\n     }\n-    \n+\n     public void testPowNaNExponent() {\n         Complex x = new Complex(3, 4);\n         assertTrue(x.pow(Complex.NaN).isNaN());\n     }\n-    \n+\n    public void testPowInf() {\n        TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneInf));\n        TestUtils.assertSame(Complex.NaN,Complex.ONE.pow(oneNegInf));\n        TestUtils.assertSame(Complex.NaN,infInf.pow(infInf));\n        TestUtils.assertSame(Complex.NaN,infNegInf.pow(infNegInf));\n        TestUtils.assertSame(Complex.NaN,infNegInf.pow(negInfNegInf));\n-       TestUtils.assertSame(Complex.NaN,infNegInf.pow(infInf));   \n+       TestUtils.assertSame(Complex.NaN,infNegInf.pow(infInf));\n    }\n-   \n+\n    public void testPowZero() {\n-       TestUtils.assertSame(Complex.NaN, \n+       TestUtils.assertSame(Complex.NaN,\n                Complex.ZERO.pow(Complex.ONE));\n-       TestUtils.assertSame(Complex.NaN, \n+       TestUtils.assertSame(Complex.NaN,\n                Complex.ZERO.pow(Complex.ZERO));\n-       TestUtils.assertSame(Complex.NaN, \n+       TestUtils.assertSame(Complex.NaN,\n                Complex.ZERO.pow(Complex.I));\n        TestUtils.assertEquals(Complex.ONE,\n                Complex.ONE.pow(Complex.ZERO), 10e-12);\n        TestUtils.assertEquals(Complex.ONE,\n                new Complex(-1, 3).pow(Complex.ZERO), 10e-12);\n    }\n-    \n+\n     public void testpowNull() {\n         try {\n-            Complex.ONE.pow(null); \n+            Complex.ONE.pow(null);\n             fail(\"Expecting NullPointerException\");\n         } catch (NullPointerException ex) {\n             // expected\n         }\n     }\n-    \n+\n     public void testSin() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(3.853738, -27.01681);\n         TestUtils.assertEquals(expected, z.sin(), 1.0e-5);\n     }\n-    \n+\n     public void testSinInf() {\n         TestUtils.assertSame(infInf, oneInf.sin());\n         TestUtils.assertSame(infNegInf, oneNegInf.sin());\n         TestUtils.assertSame(Complex.NaN, negInfInf.sin());\n         TestUtils.assertSame(Complex.NaN, negInfNegInf.sin());\n     }\n-    \n+\n     public void testSinNaN() {\n         assertTrue(Complex.NaN.sin().isNaN());\n     }\n-    \n+\n     public void testSinh() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(-6.54812, -7.61923);\n         TestUtils.assertEquals(expected, z.sinh(), 1.0e-5);\n     }\n-    \n+\n     public void testSinhNaN() {\n         assertTrue(Complex.NaN.sinh().isNaN());\n     }\n-    \n+\n     public void testSinhInf() {\n         TestUtils.assertSame(Complex.NaN, oneInf.sinh());\n         TestUtils.assertSame(Complex.NaN, oneNegInf.sinh());\n         TestUtils.assertSame(Complex.NaN, negInfInf.sinh());\n         TestUtils.assertSame(Complex.NaN, negInfNegInf.sinh());\n     }\n-    \n+\n     public void testSqrtRealPositive() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(2, 1);\n         TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n     }\n-    \n+\n     public void testSqrtRealZero() {\n         Complex z = new Complex(0.0, 4);\n         Complex expected = new Complex(1.41421, 1.41421);\n         TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n     }\n-    \n+\n     public void testSqrtRealNegative() {\n         Complex z = new Complex(-3.0, 4);\n         Complex expected = new Complex(1, 2);\n         TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n     }\n-    \n+\n     public void testSqrtImaginaryZero() {\n         Complex z = new Complex(-3.0, 0.0);\n         Complex expected = new Complex(0.0, 1.73205);\n         TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n     }\n-    \n+\n     public void testSqrtImaginaryNegative() {\n         Complex z = new Complex(-3.0, -4.0);\n         Complex expected = new Complex(1.0, -2.0);\n         TestUtils.assertEquals(expected, z.sqrt(), 1.0e-5);\n     }\n-    \n+\n     public void testSqrtPolar() {\n         double r = 1;\n         for (int i = 0; i < 5; i++) {\n                 Complex sqrtz = ComplexUtils.polar2Complex(Math.sqrt(r), theta / 2);\n                 TestUtils.assertEquals(sqrtz, z.sqrt(), 10e-12);\n             }\n-        }       \n-    }\n-    \n+        }\n+    }\n+\n     public void testSqrtNaN() {\n         assertTrue(Complex.NaN.sqrt().isNaN());\n     }\n-      \n+\n     public void testSqrtInf() {\n         TestUtils.assertSame(infNaN, oneInf.sqrt());\n         TestUtils.assertSame(infNaN, oneNegInf.sqrt());\n         TestUtils.assertSame(nanInf, negInfInf.sqrt());\n         TestUtils.assertSame(nanNegInf, negInfNegInf.sqrt());\n     }\n-    \n+\n     public void testSqrt1z() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(4.08033, -2.94094);\n         TestUtils.assertEquals(expected, z.sqrt1z(), 1.0e-5);\n     }\n-    \n+\n     public void testSqrt1zNaN() {\n         assertTrue(Complex.NaN.sqrt1z().isNaN());\n     }\n-    \n+\n     public void testTan() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(-0.000187346, 0.999356);\n         TestUtils.assertEquals(expected, z.tan(), 1.0e-5);\n     }\n-    \n+\n     public void testTanNaN() {\n         assertTrue(Complex.NaN.tan().isNaN());\n     }\n-    \n+\n     public void testTanInf() {\n         TestUtils.assertSame(zeroNaN, oneInf.tan());\n         TestUtils.assertSame(zeroNaN, oneNegInf.tan());\n         TestUtils.assertSame(Complex.NaN, negInfInf.tan());\n         TestUtils.assertSame(Complex.NaN, negInfNegInf.tan());\n     }\n-    \n+\n    public void testTanCritical() {\n         TestUtils.assertSame(infNaN, new Complex(pi/2, 0).tan());\n         TestUtils.assertSame(negInfNaN, new Complex(-pi/2, 0).tan());\n     }\n-    \n+\n     public void testTanh() {\n         Complex z = new Complex(3, 4);\n         Complex expected = new Complex(1.00071, 0.00490826);\n         TestUtils.assertEquals(expected, z.tanh(), 1.0e-5);\n     }\n-    \n+\n     public void testTanhNaN() {\n         assertTrue(Complex.NaN.tanh().isNaN());\n     }\n-    \n+\n     public void testTanhInf() {\n         TestUtils.assertSame(Complex.NaN, oneInf.tanh());\n         TestUtils.assertSame(Complex.NaN, oneNegInf.tanh());\n         TestUtils.assertSame(Complex.NaN, negInfInf.tanh());\n         TestUtils.assertSame(Complex.NaN, negInfNegInf.tanh());\n     }\n-    \n+\n     public void testTanhCritical() {\n         TestUtils.assertSame(nanInf, new Complex(0, pi/2).tanh());\n     }\n     public void testMath221() {\n         assertEquals(new Complex(0,-1), new Complex(0,1).multiply(new Complex(-1,0)));\n     }\n-    \n-    /** \n+\n+    /**\n      * Test: computing <b>third roots</b> of z.\n      * <pre>\n      * <code>\n         // Returned Collection must not be empty!\n         assertEquals(3, thirdRootsOfZ.length);\n         // test z_0\n-        assertEquals(1.0,                  thirdRootsOfZ[0].getReal(),      1.0e-5); \n+        assertEquals(1.0,                  thirdRootsOfZ[0].getReal(),      1.0e-5);\n         assertEquals(1.0,                  thirdRootsOfZ[0].getImaginary(), 1.0e-5);\n         // test z_1\n         assertEquals(-1.3660254037844386,  thirdRootsOfZ[1].getReal(),      1.0e-5);\n     }\n \n \n-    /** \n+    /**\n      * Test: computing <b>fourth roots</b> of z.\n      * <pre>\n      * <code>\n         // Returned Collection must not be empty!\n         assertEquals(4, fourthRootsOfZ.length);\n         // test z_0\n-        assertEquals(1.5164629308487783,     fourthRootsOfZ[0].getReal(),      1.0e-5); \n+        assertEquals(1.5164629308487783,     fourthRootsOfZ[0].getReal(),      1.0e-5);\n         assertEquals(-0.14469266210702247,   fourthRootsOfZ[0].getImaginary(), 1.0e-5);\n         // test z_1\n         assertEquals(0.14469266210702256,    fourthRootsOfZ[1].getReal(),      1.0e-5);\n         assertEquals(-1.5164629308487783,    fourthRootsOfZ[3].getImaginary(), 1.0e-5);\n     }\n \n-    /** \n+    /**\n      * Test: computing <b>third roots</b> of z.\n      * <pre>\n      * <code>\n         // Returned Collection must not be empty!\n         assertEquals(3, thirdRootsOfZ.length);\n         // test z_0\n-        assertEquals(2.0,                thirdRootsOfZ[0].getReal(),      1.0e-5); \n+        assertEquals(2.0,                thirdRootsOfZ[0].getReal(),      1.0e-5);\n         assertEquals(0.0,                thirdRootsOfZ[0].getImaginary(), 1.0e-5);\n         // test z_1\n         assertEquals(-1.0,               thirdRootsOfZ[1].getReal(),      1.0e-5);\n     }\n \n \n-    /** \n+    /**\n      * Test: computing <b>third roots</b> of z with real part 0.\n      * <pre>\n      * <code>\n         // Returned Collection must not be empty!\n         assertEquals(3, thirdRootsOfZ.length);\n         // test z_0\n-        assertEquals(1.0911236359717216,      thirdRootsOfZ[0].getReal(),      1.0e-5); \n+        assertEquals(1.0911236359717216,      thirdRootsOfZ[0].getReal(),      1.0e-5);\n         assertEquals(0.6299605249474365,      thirdRootsOfZ[0].getImaginary(), 1.0e-5);\n         // test z_1\n         assertEquals(-1.0911236359717216,     thirdRootsOfZ[1].getReal(),      1.0e-5);\n         List<Complex> roots = oneNaN.nthRoot(3);\n         assertEquals(1,roots.size());\n         assertEquals(Complex.NaN, roots.get(0));\n-        \n+\n         roots = nanZero.nthRoot(3);\n         assertEquals(1,roots.size());\n         assertEquals(Complex.NaN, roots.get(0));\n-        \n+\n         // NaN + infinite -> NaN\n         roots = nanInf.nthRoot(3);\n         assertEquals(1,roots.size());\n         assertEquals(Complex.NaN, roots.get(0));\n-        \n+\n         // finite + infinite -> Inf\n         roots = oneInf.nthRoot(3);\n         assertEquals(1,roots.size());\n         assertEquals(Complex.INF, roots.get(0));\n-        \n+\n         // infinite + infinite -> Inf\n         roots = negInfInf.nthRoot(3);\n         assertEquals(1,roots.size());\n         assertEquals(Complex.INF, roots.get(0));\n     }\n-    \n+\n     /**\n      * Test standard values\n      */\n     public void testGetArgument() {\n         Complex z = new Complex(1, 0);\n         assertEquals(0.0, z.getArgument(), 1.0e-12);\n-        \n+\n         z = new Complex(1, 1);\n         assertEquals(Math.PI/4, z.getArgument(), 1.0e-12);\n-        \n+\n         z = new Complex(0, 1);\n         assertEquals(Math.PI/2, z.getArgument(), 1.0e-12);\n-        \n+\n         z = new Complex(-1, 1);\n         assertEquals(3 * Math.PI/4, z.getArgument(), 1.0e-12);\n-        \n+\n         z = new Complex(-1, 0);\n         assertEquals(Math.PI, z.getArgument(), 1.0e-12);\n-        \n+\n         z = new Complex(-1, -1);\n         assertEquals(-3 * Math.PI/4, z.getArgument(), 1.0e-12);\n-        \n+\n         z = new Complex(0, -1);\n         assertEquals(-Math.PI/2, z.getArgument(), 1.0e-12);\n-        \n+\n         z = new Complex(1, -1);\n         assertEquals(-Math.PI/4, z.getArgument(), 1.0e-12);\n-        \n-    }\n-    \n+\n+    }\n+\n     /**\n      * Verify atan2-style handling of infinite parts\n      */\n         assertEquals(Math.PI/2, zeroInf.getArgument(), 1.0e-12);\n         assertEquals(0.0, infZero.getArgument(), 1.0e-12);\n         assertEquals(Math.PI, negInfOne.getArgument(), 1.0e-12);\n-        assertEquals(-3.0*Math.PI/4, negInfNegInf.getArgument(), 1.0e-12);  \n-        assertEquals(-Math.PI/2, oneNegInf.getArgument(), 1.0e-12);        \n-    }\n-    \n+        assertEquals(-3.0*Math.PI/4, negInfNegInf.getArgument(), 1.0e-12);\n+        assertEquals(-Math.PI/2, oneNegInf.getArgument(), 1.0e-12);\n+    }\n+\n     /**\n      * Verify that either part NaN results in NaN\n      */\n     public void testGetArgumentNaN() {\n         assertEquals(nan, nanZero.getArgument());\n         assertEquals(nan, zeroNaN.getArgument());\n-        assertEquals(nan, Complex.NaN.getArgument());  \n-    }\n-    \n+        assertEquals(nan, Complex.NaN.getArgument());\n+    }\n+\n     public void testSerial() {\n         Complex z = new Complex(3.0, 4.0);\n         assertEquals(z, TestUtils.serializeAndRecover(z));\n         assertEquals(infInf, inftcmplx);\n         assertTrue(inftcmplx.isInfinite());\n     }\n-    \n+\n     /**\n      * Class to test extending Complex\n      */\n         public TestComplex(double real, double imaginary) {\n             super(real, imaginary);\n         }\n-        \n+\n         public TestComplex(Complex other){\n             this(other.getReal(), other.getImaginary());\n         }\n--- a/src/test/java/org/apache/commons/math/complex/ComplexUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/ComplexUtilsTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * @version $Revision$ $Date$\n  */\n public class ComplexUtilsTest extends TestCase {\n-    \n+\n     private double inf = Double.POSITIVE_INFINITY;\n     private double negInf = Double.NEGATIVE_INFINITY;\n     private double nan = Double.NaN;\n     private double pi = Math.PI;\n-    \n+\n     private Complex negInfInf = new Complex(negInf, inf);\n     private Complex infNegInf = new Complex(inf, negInf);\n     private Complex infInf = new Complex(inf, inf);\n     private Complex infNaN = new Complex(inf, nan);\n \n     public void testPolar2Complex() {\n-        TestUtils.assertEquals(Complex.ONE, \n+        TestUtils.assertEquals(Complex.ONE,\n                 ComplexUtils.polar2Complex(1, 0), 10e-12);\n-        TestUtils.assertEquals(Complex.ZERO, \n+        TestUtils.assertEquals(Complex.ZERO,\n                 ComplexUtils.polar2Complex(0, 1), 10e-12);\n-        TestUtils.assertEquals(Complex.ZERO, \n+        TestUtils.assertEquals(Complex.ZERO,\n                 ComplexUtils.polar2Complex(0, -1), 10e-12);\n-        TestUtils.assertEquals(Complex.I, \n+        TestUtils.assertEquals(Complex.I,\n                 ComplexUtils.polar2Complex(1, pi/2), 10e-12);\n-        TestUtils.assertEquals(Complex.I.negate(), \n+        TestUtils.assertEquals(Complex.I.negate(),\n                 ComplexUtils.polar2Complex(1, -pi/2), 10e-12);\n         double r = 0;\n         for (int i = 0; i < 5; i++) {\n           double theta = 0;\n           for (int j =0; j < 20; j++) {\n               theta += pi / 6;\n-              TestUtils.assertEquals(altPolar(r, theta), \n+              TestUtils.assertEquals(altPolar(r, theta),\n                       ComplexUtils.polar2Complex(r, theta), 10e-12);\n           }\n           theta = -2 * pi;\n           for (int j =0; j < 20; j++) {\n               theta -= pi / 6;\n-              TestUtils.assertEquals(altPolar(r, theta), \n+              TestUtils.assertEquals(altPolar(r, theta),\n                       ComplexUtils.polar2Complex(r, theta), 10e-12);\n           }\n-        }   \n+        }\n     }\n \n     protected Complex altPolar(double r, double theta) {\n         return Complex.I.multiply(new Complex(theta, 0)).exp().multiply(new Complex(r, 0));\n     }\n-    \n+\n     public void testPolar2ComplexIllegalModulus() {\n         try {\n             ComplexUtils.polar2Complex(-1, 0);\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }       \n+        }\n     }\n-    \n+\n     public void testPolar2ComplexNaN() {\n         TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(nan, 1));\n         TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, nan));\n-        TestUtils.assertSame(Complex.NaN, \n-                ComplexUtils.polar2Complex(nan, nan));     \n+        TestUtils.assertSame(Complex.NaN,\n+                ComplexUtils.polar2Complex(nan, nan));\n     }\n-    \n+\n     public void testPolar2ComplexInf() {\n         TestUtils.assertSame(Complex.NaN, ComplexUtils.polar2Complex(1, inf));\n         TestUtils.assertSame(Complex.NaN,\n--- a/src/test/java/org/apache/commons/math/complex/FrenchComplexFormatTest.java\n+++ b/src/test/java/org/apache/commons/math/complex/FrenchComplexFormatTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/test/java/org/apache/commons/math/distribution/BinomialDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/BinomialDistributionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * Test cases for BinomialDistribution.\n  * Extends IntegerDistributionAbstractTest.  See class javadoc for\n  * IntegerDistributionAbstractTest for details.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class BinomialDistributionTest extends IntegerDistributionAbstractTest {\n-    \n+\n     /**\n      * Constructor for BinomialDistributionTest.\n      * @param name\n     public BinomialDistributionTest(String name) {\n         super(name);\n     }\n-    \n+\n     //-------------- Implementations for abstract methods -----------------------\n-    \n+\n     /** Creates the default discrete distribution instance to use in tests. */\n     @Override\n     public IntegerDistribution makeDistribution() {\n         return new BinomialDistributionImpl(10,0.70);\n     }\n-    \n+\n     /** Creates the default probability density test input values */\n     @Override\n     public int[] makeDensityTestPoints() {\n         return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n     }\n-    \n+\n     /** Creates the default probability density test expected values */\n     @Override\n     public double[] makeDensityTestValues() {\n-        return new double[] {0d, 0.0000d, 0.0001d, 0.0014d, 0.0090d, 0.0368d, 0.1029d, \n+        return new double[] {0d, 0.0000d, 0.0001d, 0.0014d, 0.0090d, 0.0368d, 0.1029d,\n                 0.2001d, 0.2668d, 0.2335d, 0.1211d, 0.0282d, 0d};\n     }\n-    \n+\n     /** Creates the default cumulative probability density test input values */\n     @Override\n     public int[] makeCumulativeTestPoints() {\n         return makeDensityTestPoints();\n     }\n-    \n+\n     /** Creates the default cumulative probability density test expected values */\n     @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0d, 0.0000d, 0.0001d, 0.0016d, 0.0106d, 0.0473d,\n                 0.1503d, 0.3504d, 0.6172d, 0.8507d, 0.9718d, 1d, 1d};\n         }\n-    \n+\n     /** Creates the default inverse cumulative probability test input values */\n     @Override\n     public double[] makeInverseCumulativeTestPoints() {\n         return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,\n-                0.990d, 0.975d, 0.950d, 0.900d,1}; \n+                0.990d, 0.975d, 0.950d, 0.900d,1};\n         }\n-    \n+\n     /** Creates the default inverse cumulative probability density test expected values */\n     @Override\n     public int[] makeInverseCumulativeTestValues() {\n     }\n \n     //----------------- Additional test cases ---------------------------------\n-   \n+\n     /** Test degenerate case p = 0   */\n     public void testDegenerate0() throws Exception {\n         setDistribution(new BinomialDistributionImpl(5,0.0d));\n         setInverseCumulativeTestValues(new int[] {-1, -1});\n         verifyDensities();\n         verifyCumulativeProbabilities();\n-        verifyInverseCumulativeProbabilities();     \n+        verifyInverseCumulativeProbabilities();\n     }\n-    \n+\n     /** Test degenerate case p = 1   */\n     public void testDegenerate1() throws Exception {\n         setDistribution(new BinomialDistributionImpl(5,1.0d));\n         setInverseCumulativeTestValues(new int[] {4, 4});\n         verifyDensities();\n         verifyCumulativeProbabilities();\n-        verifyInverseCumulativeProbabilities();     \n+        verifyInverseCumulativeProbabilities();\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/CauchyDistributionTest.java\n  * Test cases for CauchyDistribution.\n  * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n  * ContinuousDistributionAbstractTest for details.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class CauchyDistributionTest extends ContinuousDistributionAbstractTest  {\n-    \n+\n     /**\n      * Constructor for CauchyDistributionTest.\n      * @param arg0\n     public CauchyDistributionTest(String arg0) {\n         super(arg0);\n     }\n-    \n+\n     //-------------- Implementations for abstract methods -----------------------\n-    \n+\n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n     public ContinuousDistribution makeDistribution() {\n         return new CauchyDistributionImpl(1.2, 2.1);\n-    }   \n-    \n+    }\n+\n     /** Creates the default cumulative probability distribution test input values */\n     @Override\n     public double[] makeCumulativeTestPoints() {\n-        // quantiles computed using Mathematica \n+        // quantiles computed using Mathematica\n         return new double[] {-667.2485619d, -65.6230835d, -25.48302995d,\n                 -12.05887818d, -5.263135428d, 7.663135428d, 14.45887818d,\n                 27.88302995d, 68.0230835d, 669.6485619d};\n     }\n-    \n+\n     /** Creates the default cumulative probability density test expected values */\n     @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,\n                 0.975d, 0.990d, 0.999d};\n     }\n-    \n+\n     //---------------------------- Additional test cases -------------------------\n-    \n+\n     public void testInverseCumulativeProbabilityExtremes() throws Exception {\n         setInverseCumulativeTestPoints(new double[] {0.0, 1.0});\n         setInverseCumulativeTestValues(\n                 new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});\n         verifyInverseCumulativeProbabilities();\n     }\n-    \n+\n     public void testMedian() {\n         CauchyDistribution distribution = (CauchyDistribution) getDistribution();\n         double expected = Math.random();\n         distribution.setMedian(expected);\n         assertEquals(expected, distribution.getMedian(), 0.0);\n     }\n-    \n+\n     public void testScale() {\n         CauchyDistribution distribution = (CauchyDistribution) getDistribution();\n         double expected = Math.random();\n         distribution.setScale(expected);\n         assertEquals(expected, distribution.getScale(), 0.0);\n     }\n-    \n+\n     public void testSetScale() {\n         CauchyDistribution distribution = (CauchyDistribution) getDistribution();\n         try {\n         } catch (IllegalArgumentException ex) {\n             // success\n         }\n-        \n+\n         try {\n             distribution.setScale(-1.0);\n             fail(\"Can not have negative scale.\");\n--- a/src/test/java/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * Test cases for ChiSquareDistribution.\n  * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n  * ContinuousDistributionAbstractTest for details.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class ChiSquareDistributionTest extends ContinuousDistributionAbstractTest {\n-    \n+\n     /**\n      * Constructor for ChiSquareDistributionTest.\n      * @param name\n     public ChiSquareDistributionTest(String name) {\n         super(name);\n     }\n-    \n+\n     //-------------- Implementations for abstract methods -----------------------\n-    \n+\n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n     public ContinuousDistribution makeDistribution() {\n         return new ChiSquaredDistributionImpl(5.0);\n-    }   \n-    \n+    }\n+\n     /** Creates the default cumulative probability distribution test input values */\n     @Override\n     public double[] makeCumulativeTestPoints() {\n         // quantiles computed using R version 1.8.1 (linux version)\n-        return new double[] {0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d, \n+        return new double[] {0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d,\n                 20.51501d, 15.08627d, 12.83250d, 11.07050d, 9.236357d};\n     }\n-    \n+\n     /** Creates the default cumulative probability density test expected values */\n     @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n-                0.990d, 0.975d, 0.950d, 0.900d}; \n+                0.990d, 0.975d, 0.950d, 0.900d};\n     }\n-    \n+\n     /** Creates the default inverse cumulative probability test input values */\n     @Override\n     public double[] makeInverseCumulativeTestPoints() {\n         return new double[] {0, 0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n-                0.990d, 0.975d, 0.950d, 0.900d, 1};     \n+                0.990d, 0.975d, 0.950d, 0.900d, 1};\n     }\n-    \n+\n     /** Creates the default inverse cumulative probability density test expected values */\n     @Override\n     public double[] makeInverseCumulativeTestValues() {\n-        return new double[] {0, 0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d, \n-                20.51501d, 15.08627d, 12.83250d, 11.07050d, 9.236357d, \n+        return new double[] {0, 0.210216d, 0.5542981d, 0.8312116d, 1.145476d, 1.610308d,\n+                20.51501d, 15.08627d, 12.83250d, 11.07050d, 9.236357d,\n                 Double.POSITIVE_INFINITY};\n     }\n-    \n+\n  // --------------------- Override tolerance  --------------\n     @Override\n     protected void setUp() throws Exception {\n     }\n \n  //---------------------------- Additional test cases -------------------------\n-    \n+\n     public void testSmallDf() throws Exception {\n         setDistribution(new ChiSquaredDistributionImpl(0.1d));\n         setTolerance(1E-4);\n         // quantiles computed using R version 1.8.1 (linux version)\n-        setCumulativeTestPoints(new double[] {1.168926E-60, 1.168926E-40, 1.063132E-32, \n-                1.144775E-26, 1.168926E-20, 5.472917, 2.175255, 1.13438, \n+        setCumulativeTestPoints(new double[] {1.168926E-60, 1.168926E-40, 1.063132E-32,\n+                1.144775E-26, 1.168926E-20, 5.472917, 2.175255, 1.13438,\n                 0.5318646, 0.1526342});\n         setInverseCumulativeTestValues(getCumulativeTestPoints());\n         setInverseCumulativeTestPoints(getCumulativeTestValues());\n         verifyCumulativeProbabilities();\n         verifyInverseCumulativeProbabilities();\n     }\n-    \n+\n     public void testDfAccessors() {\n         ChiSquaredDistribution distribution = (ChiSquaredDistribution) getDistribution();\n         assertEquals(5d, distribution.getDegreesOfFreedom(), Double.MIN_VALUE);\n--- a/src/test/java/org/apache/commons/math/distribution/ContinuousDistributionAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ContinuousDistributionAbstractTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * <p>\n  * To implement additional test cases with different distribution instances and\n  * test data, use the setXxx methods for the instance data in test cases and\n- * call the verifyXxx methods to verify results. \n+ * call the verifyXxx methods to verify results.\n  * <p>\n  * Error tolerance can be overriden by implementing getTolerance().\n  * <p>\n  * <p>\n  * See {@link NormalDistributionTest} and {@link ChiSquareDistributionTest}\n  * for examples.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public abstract class ContinuousDistributionAbstractTest extends TestCase {\n-    \n+\n //-------------------- Private test instance data -------------------------\n     /**  Distribution instance used to perform tests */\n     private ContinuousDistribution distribution;\n-    \n+\n     /** Tolerance used in comparing expected and returned values */\n     private double tolerance = 1E-4;\n-    \n+\n     /** Arguments used to test cumulative probability density calculations */\n     private double[] cumulativeTestPoints;\n-    \n+\n     /** Values used to test cumulative probability density calculations */\n     private double[] cumulativeTestValues;\n-    \n+\n     /** Arguments used to test inverse cumulative probability density calculations */\n     private double[] inverseCumulativeTestPoints;\n-    \n+\n     /** Values used to test inverse cumulative probability density calculations */\n     private double[] inverseCumulativeTestValues;\n-    \n+\n     //-------------------------------------------------------------------------\n-    \n+\n     /**\n      * Constructor for ContinuousDistributionAbstractTest.\n      * @param name\n     public ContinuousDistributionAbstractTest(String name) {\n         super(name);\n     }\n-    \n+\n     //-------------------- Abstract methods -----------------------------------\n-    \n+\n     /** Creates the default continuous distribution instance to use in tests. */\n     public abstract ContinuousDistribution makeDistribution();\n-    \n+\n     /** Creates the default cumulative probability density test input values */\n     public abstract double[] makeCumulativeTestPoints();\n-    \n+\n     /** Creates the default cumulative probability density test expected values */\n     public abstract double[] makeCumulativeTestValues();\n-    \n+\n     //---- Default implementations of inverse test data generation methods ----\n-    \n+\n     /** Creates the default inverse cumulative probability test input values */\n     public double[] makeInverseCumulativeTestPoints() {\n         return makeCumulativeTestValues();\n     }\n-    \n+\n     /** Creates the default inverse cumulative probability density test expected values */\n     public double[] makeInverseCumulativeTestValues() {\n         return makeCumulativeTestPoints();\n     }\n-    \n+\n     //-------------------- Setup / tear down ----------------------------------\n-     \n-    /**\n-     * Setup sets all test instance data to default values \n+\n+    /**\n+     * Setup sets all test instance data to default values\n      */\n     @Override\n     protected void setUp() throws Exception {\n         cumulativeTestPoints = makeCumulativeTestPoints();\n         cumulativeTestValues = makeCumulativeTestValues();\n         inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();\n-        inverseCumulativeTestValues = makeInverseCumulativeTestValues();   \n-    }\n-    \n+        inverseCumulativeTestValues = makeInverseCumulativeTestValues();\n+    }\n+\n     /**\n      * Cleans up test instance data\n      */\n     @Override\n-    protected void tearDown() throws Exception {      \n+    protected void tearDown() throws Exception {\n         super.tearDown();\n         distribution = null;\n         cumulativeTestPoints = null;\n         cumulativeTestValues = null;\n         inverseCumulativeTestPoints = null;\n-        inverseCumulativeTestValues = null;   \n-    }\n-    \n+        inverseCumulativeTestValues = null;\n+    }\n+\n     //-------------------- Verification methods -------------------------------\n-    \n+\n     /**\n      * Verifies that cumulative probability density calculations match expected values\n      * using current test instance data\n-     */   \n+     */\n     protected void verifyCumulativeProbabilities() throws Exception {\n         for (int i = 0; i < cumulativeTestPoints.length; i++) {\n-            TestUtils.assertEquals(\"Incorrect cumulative probability value returned for \" \n-                + cumulativeTestPoints[i], cumulativeTestValues[i], \n-                distribution.cumulativeProbability(cumulativeTestPoints[i]), \n+            TestUtils.assertEquals(\"Incorrect cumulative probability value returned for \"\n+                + cumulativeTestPoints[i], cumulativeTestValues[i],\n+                distribution.cumulativeProbability(cumulativeTestPoints[i]),\n                 getTolerance());\n-        }           \n-    }\n-    \n+        }\n+    }\n+\n     /**\n      * Verifies that inverse cumulative probability density calculations match expected values\n      * using current test instance data\n      */\n     protected void verifyInverseCumulativeProbabilities() throws Exception {\n         for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {\n-            TestUtils.assertEquals(\"Incorrect inverse cumulative probability value returned for \" \n-                + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i], \n-                 distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]), \n+            TestUtils.assertEquals(\"Incorrect inverse cumulative probability value returned for \"\n+                + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i],\n+                 distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]),\n                  getTolerance());\n-        }           \n-    }\n-    \n+        }\n+    }\n+\n     //------------------------ Default test cases -----------------------------\n-    \n+\n     /**\n      * Verifies that cumulative probability density calculations match expected values\n      * using default test instance data\n      */\n     public void testCumulativeProbabilities() throws Exception {\n-        verifyCumulativeProbabilities();      \n-    }\n-    \n+        verifyCumulativeProbabilities();\n+    }\n+\n     /**\n      * Verifies that inverse cumulative probability density calculations match expected values\n      * using default test instance data\n      */\n     public void testInverseCumulativeProbabilities() throws Exception {\n-        verifyInverseCumulativeProbabilities();       \n-    }\n-    \n+        verifyInverseCumulativeProbabilities();\n+    }\n+\n     /**\n      * Verifies that probability computations are consistent\n      */\n     public void testConsistency() throws Exception {\n         for (int i=1; i < cumulativeTestPoints.length; i++) {\n-            \n+\n             // check that cdf(x, x) = 0\n-            TestUtils.assertEquals(0d, \n+            TestUtils.assertEquals(0d,\n                distribution.cumulativeProbability\n                  (cumulativeTestPoints[i], cumulativeTestPoints[i]), tolerance);\n-            \n+\n             // check that P(a < X < b) = P(X < b) - P(X < a)\n             double upper = Math.max(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);\n             double lower = Math.min(cumulativeTestPoints[i], cumulativeTestPoints[i -1]);\n-            double diff = distribution.cumulativeProbability(upper) - \n+            double diff = distribution.cumulativeProbability(upper) -\n                 distribution.cumulativeProbability(lower);\n             double direct = distribution.cumulativeProbability(lower, upper);\n-            TestUtils.assertEquals(\"Inconsistent cumulative probabilities for (\" \n+            TestUtils.assertEquals(\"Inconsistent cumulative probabilities for (\"\n                     + lower + \",\" + upper + \")\", diff, direct, tolerance);\n         }\n     }\n-    \n+\n     /**\n      * Verifies that illegal arguments are correctly handled\n      */\n             fail(\"Expecting IllegalArgumentException for p = 2\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }       \n-    }\n-    \n+        }\n+    }\n+\n     //------------------ Getters / Setters for test instance data -----------\n     /**\n      * @return Returns the cumulativeTestPoints.\n--- a/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * Test cases for ExponentialDistribution.\n  * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n  * ContinuousDistributionAbstractTest for details.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class ExponentialDistributionTest extends ContinuousDistributionAbstractTest {\n     }\n \n     //-------------- Implementations for abstract methods -----------------------\n-    \n+\n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n     public ContinuousDistribution makeDistribution() {\n         return new ExponentialDistributionImpl(5.0);\n-    }   \n-    \n+    }\n+\n     /** Creates the default cumulative probability distribution test input values */\n     @Override\n     public double[] makeCumulativeTestPoints() {\n         // quantiles computed using R version 1.8.1 (linux version)\n-        return new double[] {0.005002502d, 0.05025168d, 0.1265890d, 0.2564665d, 0.5268026d, \n+        return new double[] {0.005002502d, 0.05025168d, 0.1265890d, 0.2564665d, 0.5268026d,\n                 34.53878d, 23.02585d, 18.44440d, 14.97866d, 11.51293d};\n     }\n-    \n+\n     /** Creates the default cumulative probability density test expected values */\n     @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n-                0.990d, 0.975d, 0.950d, 0.900d}; \n+                0.990d, 0.975d, 0.950d, 0.900d};\n     }\n-    \n+\n     //------------ Additional tests -------------------------------------------\n- \n+\n     public void testCumulativeProbabilityExtremes() throws Exception {\n         setCumulativeTestPoints(new double[] {-2, 0});\n         setCumulativeTestValues(new double[] {0, 0});\n         // computed using  print(dexp(2, rate=1/3), digits=10) in R 2.5\n         assertEquals(0.1711390397, d2.density(2.0), 1e-8);\n     }\n-    \n+\n     public void testMeanAccessors() {\n         ExponentialDistribution distribution = (ExponentialDistribution) getDistribution();\n         assertEquals(5d, distribution.getMean(), Double.MIN_VALUE);\n             // expected\n         }\n     }\n-   \n+\n }\n--- a/src/test/java/org/apache/commons/math/distribution/FDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/FDistributionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * Test cases for FDistribution.\n  * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n  * ContinuousDistributionAbstractTest for details.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class FDistributionTest extends ContinuousDistributionAbstractTest {\n     }\n \n     //-------------- Implementations for abstract methods -----------------------\n-    \n+\n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n     public ContinuousDistribution makeDistribution() {\n         return new FDistributionImpl(5.0, 6.0);\n-    }   \n-    \n+    }\n+\n     /** Creates the default cumulative probability distribution test input values */\n     @Override\n     public double[] makeCumulativeTestPoints() {\n         // quantiles computed using R version 1.8.1 (linux version)\n         return new double[] {0.03468084d ,0.09370091d, 0.1433137d,\n-            0.2020084d, 0.2937283d, 20.80266d, 8.745895d, 5.987565d, \n+            0.2020084d, 0.2937283d, 20.80266d, 8.745895d, 5.987565d,\n             4.387374d, 3.107512d};\n     }\n-    \n+\n     /** Creates the default cumulative probability density test expected values */\n     @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n-                0.990d, 0.975d, 0.950d, 0.900d}; \n+                0.990d, 0.975d, 0.950d, 0.900d};\n     }\n-    \n+\n     // --------------------- Override tolerance  --------------\n     @Override\n     protected void setUp() throws Exception {\n         setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});\n         verifyInverseCumulativeProbabilities();\n     }\n-    \n+\n     public void testDfAccessors() {\n         FDistribution distribution = (FDistribution) getDistribution();\n         assertEquals(5d, distribution.getNumeratorDegreesOfFreedom(), Double.MIN_VALUE);\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-    } \n+    }\n \n     public void testLargeDegreesOfFreedom() throws Exception {\n         org.apache.commons.math.distribution.FDistributionImpl fd =\n--- a/src/test/java/org/apache/commons/math/distribution/GammaDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/GammaDistributionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * Test cases for GammaDistribution.\n  * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n  * ContinuousDistributionAbstractTest for details.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class GammaDistributionTest extends ContinuousDistributionAbstractTest {\n-    \n+\n     /**\n      * Constructor for GammaDistributionTest.\n      * @param name\n--- a/src/test/java/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/HypergeometricDistributionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * Test cases for HyperGeometriclDistribution.\n  * Extends IntegerDistributionAbstractTest.  See class javadoc for\n  * IntegerDistributionAbstractTest for details.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class HypergeometricDistributionTest extends IntegerDistributionAbstractTest {\n     }\n \n //-------------- Implementations for abstract methods -----------------------\n-    \n+\n     /** Creates the default discrete distribution instance to use in tests. */\n     @Override\n     public IntegerDistribution makeDistribution() {\n         return new HypergeometricDistributionImpl(10,5, 5);\n     }\n-    \n+\n     /** Creates the default probability density test input values */\n     @Override\n     public int[] makeDensityTestPoints() {\n         return new int[] {-1, 0, 1, 2, 3, 4, 5, 10};\n     }\n-    \n+\n     /** Creates the default probability density test expected values */\n     @Override\n     public double[] makeDensityTestValues() {\n-        return new double[] {0d, 0.003968d, 0.099206d, 0.396825d, 0.396825d, \n+        return new double[] {0d, 0.003968d, 0.099206d, 0.396825d, 0.396825d,\n                 0.099206d, 0.003968d, 0d};\n     }\n-    \n+\n     /** Creates the default cumulative probability density test input values */\n     @Override\n     public int[] makeCumulativeTestPoints() {\n         return makeDensityTestPoints();\n     }\n-    \n+\n     /** Creates the default cumulative probability density test expected values */\n     @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0d, .003968d, .103175d, .50000d, .896825d, .996032d,\n                 1.00000d, 1d};\n     }\n-    \n+\n     /** Creates the default inverse cumulative probability test input values */\n     @Override\n     public double[] makeInverseCumulativeTestPoints() {\n         return new double[] {0d, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,\n-                0.990d, 0.975d, 0.950d, 0.900d, 1d}; \n-    }\n-    \n+                0.990d, 0.975d, 0.950d, 0.900d, 1d};\n+    }\n+\n     /** Creates the default inverse cumulative probability density test expected values */\n     @Override\n     public int[] makeInverseCumulativeTestValues() {\n         return new int[] {-1, -1, 0, 0, 0, 0, 4, 3, 3, 3, 3, 5};\n     }\n-    \n+\n     //-------------------- Additional test cases ------------------------------\n-    \n+\n     /** Verify that if there are no failures, mass is concentrated on sampleSize */\n     public void testDegenerateNoFailures() throws Exception {\n         setDistribution(new HypergeometricDistributionImpl(5,5,3));\n         setInverseCumulativeTestValues(new int[] {2, 2});\n         verifyDensities();\n         verifyCumulativeProbabilities();\n-        verifyInverseCumulativeProbabilities();     \n-    }\n-    \n+        verifyInverseCumulativeProbabilities();\n+    }\n+\n     /** Verify that if there are no successes, mass is concentrated on 0 */\n     public void testDegenerateNoSuccesses() throws Exception {\n         setDistribution(new HypergeometricDistributionImpl(5,0,3));\n         setInverseCumulativeTestValues(new int[] {-1, -1});\n         verifyDensities();\n         verifyCumulativeProbabilities();\n-        verifyInverseCumulativeProbabilities();     \n-    }\n-    \n+        verifyInverseCumulativeProbabilities();\n+    }\n+\n     /** Verify that if sampleSize = populationSize, mass is concentrated on numberOfSuccesses */\n     public void testDegenerateFullSample() throws Exception {\n         setDistribution(new HypergeometricDistributionImpl(5,3,5));\n         setInverseCumulativeTestValues(new int[] {2, 2});\n         verifyDensities();\n         verifyCumulativeProbabilities();\n-        verifyInverseCumulativeProbabilities();     \n+        verifyInverseCumulativeProbabilities();\n     }\n \n     public void testPopulationSize() {\n             fail(\"negative population size.  IllegalArgumentException expected\");\n         } catch(IllegalArgumentException ex) {\n         }\n-        \n+\n         dist.setPopulationSize(10);\n         assertEquals(10, dist.getPopulationSize());\n     }\n-    \n+\n     public void testLargeValues() {\n         int populationSize = 3456;\n         int sampleSize = 789;\n             {3.0, 1.32724172984193e-8, 1.46736255879763e-8, 0.999999998598792},\n             {4.0, 9.94501711734089e-8, 1.14123796761385e-7, 0.999999985326375},\n             {5.0, 5.89080768883643e-7, 7.03204565645028e-7, 0.999999885876203},\n-            {20.0, 0.0760051397707708, 0.27349758476299, 0.802507555007781}, \n-            {21.0, 0.087144222047629, 0.360641806810619, 0.72650241523701}, \n-            {22.0, 0.0940378846881819, 0.454679691498801, 0.639358193189381}, \n-            {23.0, 0.0956897500614809, 0.550369441560282, 0.545320308501199}, \n-            {24.0, 0.0919766921922999, 0.642346133752582, 0.449630558439718}, \n-            {25.0, 0.083641637261095, 0.725987771013677, 0.357653866247418}, \n+            {20.0, 0.0760051397707708, 0.27349758476299, 0.802507555007781},\n+            {21.0, 0.087144222047629, 0.360641806810619, 0.72650241523701},\n+            {22.0, 0.0940378846881819, 0.454679691498801, 0.639358193189381},\n+            {23.0, 0.0956897500614809, 0.550369441560282, 0.545320308501199},\n+            {24.0, 0.0919766921922999, 0.642346133752582, 0.449630558439718},\n+            {25.0, 0.083641637261095, 0.725987771013677, 0.357653866247418},\n             {96.0, 5.93849188852098e-57, 1.0, 6.01900244560712e-57},\n-            {97.0, 7.96593036832547e-59, 1.0, 8.05105570861321e-59}, \n+            {97.0, 7.96593036832547e-59, 1.0, 8.05105570861321e-59},\n             {98.0, 8.44582921934367e-61, 1.0, 8.5125340287733e-61},\n-            {99.0, 6.63604297068222e-63, 1.0, 6.670480942963e-63}, \n+            {99.0, 6.63604297068222e-63, 1.0, 6.670480942963e-63},\n             {100.0, 3.43501099007557e-65, 1.0, 3.4437972280786e-65},\n             {101.0, 8.78623800302957e-68, 1.0, 8.78623800302957e-68},\n         };\n-        \n+\n         testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);\n     }\n \n             TestUtils.assertRelativelyEquals(cdf1, actualCdf1, 1.0e-9);\n         }\n     }\n-    \n+\n     public void testMoreLargeValues() {\n         int populationSize = 26896;\n         int sampleSize = 895;\n         int numberOfSucceses = 55;\n         double[][] data = {\n-            {0.0, 0.155168304750504, 0.155168304750504, 1.0}, \n-            {1.0, 0.29437545000746, 0.449543754757964, 0.844831695249496}, \n-            {2.0, 0.273841321577003, 0.723385076334967, 0.550456245242036}, \n-            {3.0, 0.166488572570786, 0.889873648905753, 0.276614923665033}, \n-            {4.0, 0.0743969744713231, 0.964270623377076, 0.110126351094247}, \n-            {5.0, 0.0260542785784855, 0.990324901955562, 0.0357293766229237}, \n-            {20.0, 3.57101101678792e-16, 1.0, 3.78252101622096e-16}, \n-            {21.0, 2.00551638598312e-17, 1.0, 2.11509999433041e-17}, \n-            {22.0, 1.04317070180562e-18, 1.0, 1.09583608347287e-18}, \n-            {23.0, 5.03153504903308e-20, 1.0, 5.266538166725e-20}, \n-            {24.0, 2.2525984149695e-21, 1.0, 2.35003117691919e-21}, \n-            {25.0, 9.3677424515947e-23, 1.0, 9.74327619496943e-23}, \n-            {50.0, 9.83633962945521e-69, 1.0, 9.8677629437617e-69}, \n-            {51.0, 3.13448949497553e-71, 1.0, 3.14233143064882e-71}, \n-            {52.0, 7.82755221928122e-74, 1.0, 7.84193567329055e-74}, \n-            {53.0, 1.43662126065532e-76, 1.0, 1.43834540093295e-76}, \n-            {54.0, 1.72312692517348e-79, 1.0, 1.7241402776278e-79}, \n-            {55.0, 1.01335245432581e-82, 1.0, 1.01335245432581e-82},        \n+            {0.0, 0.155168304750504, 0.155168304750504, 1.0},\n+            {1.0, 0.29437545000746, 0.449543754757964, 0.844831695249496},\n+            {2.0, 0.273841321577003, 0.723385076334967, 0.550456245242036},\n+            {3.0, 0.166488572570786, 0.889873648905753, 0.276614923665033},\n+            {4.0, 0.0743969744713231, 0.964270623377076, 0.110126351094247},\n+            {5.0, 0.0260542785784855, 0.990324901955562, 0.0357293766229237},\n+            {20.0, 3.57101101678792e-16, 1.0, 3.78252101622096e-16},\n+            {21.0, 2.00551638598312e-17, 1.0, 2.11509999433041e-17},\n+            {22.0, 1.04317070180562e-18, 1.0, 1.09583608347287e-18},\n+            {23.0, 5.03153504903308e-20, 1.0, 5.266538166725e-20},\n+            {24.0, 2.2525984149695e-21, 1.0, 2.35003117691919e-21},\n+            {25.0, 9.3677424515947e-23, 1.0, 9.74327619496943e-23},\n+            {50.0, 9.83633962945521e-69, 1.0, 9.8677629437617e-69},\n+            {51.0, 3.13448949497553e-71, 1.0, 3.14233143064882e-71},\n+            {52.0, 7.82755221928122e-74, 1.0, 7.84193567329055e-74},\n+            {53.0, 1.43662126065532e-76, 1.0, 1.43834540093295e-76},\n+            {54.0, 1.72312692517348e-79, 1.0, 1.7241402776278e-79},\n+            {55.0, 1.01335245432581e-82, 1.0, 1.01335245432581e-82},\n         };\n         testHypergeometricDistributionProbabilities(populationSize, sampleSize, numberOfSucceses, data);\n     }\n--- a/src/test/java/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/IntegerDistributionAbstractTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * Abstract base class for {@link IntegerDistribution} tests.\n  * <p>\n  * To create a concrete test class for an integer distribution implementation,\n- *  implement makeDistribution() to return a distribution instance to use in \n+ *  implement makeDistribution() to return a distribution instance to use in\n  *  tests and each of the test data generation methods below.  In each case, the\n- *  test points and test values arrays returned represent parallel arrays of \n+ *  test points and test values arrays returned represent parallel arrays of\n  *  inputs and expected values for the distribution returned by makeDistribution().\n  *  <p>\n  *  makeDensityTestPoints() -- arguments used to test probability density calculation\n  * <p>\n  *  To implement additional test cases with different distribution instances and test data,\n  *  use the setXxx methods for the instance data in test cases and call the verifyXxx methods\n- *  to verify results. \n- * \n+ *  to verify results.\n+ *\n  * @version $Revision$ $Date$\n  */\n public abstract class IntegerDistributionAbstractTest extends TestCase {\n-    \n+\n //-------------------- Private test instance data -------------------------\n     /** Discrete distribution instance used to perform tests */\n     private IntegerDistribution distribution;\n-    \n+\n     /** Tolerance used in comparing expected and returned values */\n     private double tolerance = 1E-4;\n-    \n+\n     /** Arguments used to test probability density calculations */\n     private int[] densityTestPoints;\n-    \n+\n     /** Values used to test probability density calculations */\n     private double[] densityTestValues;\n-    \n+\n     /** Arguments used to test cumulative probability density calculations */\n     private int[] cumulativeTestPoints;\n-    \n+\n     /** Values used to test cumulative probability density calculations */\n     private double[] cumulativeTestValues;\n-    \n+\n     /** Arguments used to test inverse cumulative probability density calculations */\n     private double[] inverseCumulativeTestPoints;\n-    \n+\n     /** Values used to test inverse cumulative probability density calculations */\n     private int[] inverseCumulativeTestValues;\n-    \n+\n     //-------------------------------------------------------------------------\n-    \n+\n     /**\n      * Constructor for IntegerDistributionAbstractTest.\n      * @param name\n     public IntegerDistributionAbstractTest(String name) {\n         super(name);\n     }\n-    \n+\n     //-------------------- Abstract methods -----------------------------------\n-    \n+\n     /** Creates the default discrete distribution instance to use in tests. */\n     public abstract IntegerDistribution makeDistribution();\n-    \n+\n     /** Creates the default probability density test input values */\n     public abstract int[] makeDensityTestPoints();\n-    \n+\n     /** Creates the default probability density test expected values */\n     public abstract double[] makeDensityTestValues();\n-    \n+\n     /** Creates the default cumulative probability density test input values */\n     public abstract int[] makeCumulativeTestPoints();\n-    \n+\n     /** Creates the default cumulative probability density test expected values */\n     public abstract double[] makeCumulativeTestValues();\n-    \n+\n     /** Creates the default inverse cumulative probability test input values */\n     public abstract double[] makeInverseCumulativeTestPoints();\n-    \n+\n     /** Creates the default inverse cumulative probability density test expected values */\n     public abstract int[] makeInverseCumulativeTestValues();\n-    \n+\n     //-------------------- Setup / tear down ----------------------------------\n-     \n-    /**\n-     * Setup sets all test instance data to default values \n+\n+    /**\n+     * Setup sets all test instance data to default values\n      */\n     @Override\n     protected void setUp() throws Exception {\n         cumulativeTestPoints = makeCumulativeTestPoints();\n         cumulativeTestValues = makeCumulativeTestValues();\n         inverseCumulativeTestPoints = makeInverseCumulativeTestPoints();\n-        inverseCumulativeTestValues = makeInverseCumulativeTestValues();   \n-    }\n-    \n+        inverseCumulativeTestValues = makeInverseCumulativeTestValues();\n+    }\n+\n     /**\n      * Cleans up test instance data\n      */\n     @Override\n-    protected void tearDown() throws Exception {      \n+    protected void tearDown() throws Exception {\n         super.tearDown();\n         distribution = null;\n         densityTestPoints = null;\n         cumulativeTestPoints = null;\n         cumulativeTestValues = null;\n         inverseCumulativeTestPoints = null;\n-        inverseCumulativeTestValues = null;   \n-    }\n-    \n+        inverseCumulativeTestValues = null;\n+    }\n+\n     //-------------------- Verification methods -------------------------------\n-    \n+\n     /**\n      * Verifies that probability density calculations match expected values\n      * using current test instance data\n     protected void verifyDensities() throws Exception {\n         for (int i = 0; i < densityTestPoints.length; i++) {\n             assertEquals(\"Incorrect density value returned for \" + densityTestPoints[i],\n-                    densityTestValues[i], \n+                    densityTestValues[i],\n                     distribution.probability(densityTestPoints[i]), tolerance);\n-        }     \n-    }\n-    \n+        }\n+    }\n+\n     /**\n      * Verifies that cumulative probability density calculations match expected values\n      * using current test instance data\n-     */   \n+     */\n     protected void verifyCumulativeProbabilities() throws Exception {\n         for (int i = 0; i < cumulativeTestPoints.length; i++) {\n             assertEquals(\"Incorrect cumulative probability value returned for \" + cumulativeTestPoints[i],\n-                    cumulativeTestValues[i], \n+                    cumulativeTestValues[i],\n                     distribution.cumulativeProbability(cumulativeTestPoints[i]), tolerance);\n-        }           \n-    }\n-    \n-    \n+        }\n+    }\n+\n+\n     /**\n      * Verifies that inverse cumulative probability density calculations match expected values\n      * using current test instance data\n      */\n     protected void verifyInverseCumulativeProbabilities() throws Exception {\n         for (int i = 0; i < inverseCumulativeTestPoints.length; i++) {\n-            assertEquals(\"Incorrect inverse cumulative probability value returned for \" \n-                    + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i], \n+            assertEquals(\"Incorrect inverse cumulative probability value returned for \"\n+                    + inverseCumulativeTestPoints[i], inverseCumulativeTestValues[i],\n                     distribution.inverseCumulativeProbability(inverseCumulativeTestPoints[i]));\n-        }           \n-    }\n-    \n+        }\n+    }\n+\n     //------------------------ Default test cases -----------------------------\n \n     /**\n      * using default test instance data\n      */\n     public void testDensities() throws Exception {\n-        verifyDensities();     \n-    }\n-    \n+        verifyDensities();\n+    }\n+\n     /**\n      * Verifies that cumulative probability density calculations match expected values\n      * using default test instance data\n      */\n     public void testCumulativeProbabilities() throws Exception {\n-        verifyCumulativeProbabilities();      \n-    }\n-    \n+        verifyCumulativeProbabilities();\n+    }\n+\n     /**\n      * Verifies that floating point arguments are correctly handled by\n      * cumulativeProbablility(-,-)\n             assertEquals(\n                     \"Incorrect cumulative probability value returned for \" +\n                     cumulativeTestPoints[i],\n-                    cumulativeTestValues[i], \n+                    cumulativeTestValues[i],\n                     distribution.cumulativeProbability(arg), tolerance);\n             if (i < cumulativeTestPoints.length - 1) {\n                 double arg2 = cumulativeTestPoints[i + 1];\n                            cumulativeTestPoints[i + 1]),\n                    distribution.cumulativeProbability(arg, arg2), tolerance);\n             }\n-        } \n+        }\n         int one = 1;\n         int ten = 10;\n         int two = 2;\n         double oned = one;\n         double twod = two;\n         double tend = ten;\n-        assertEquals(distribution.cumulativeProbability(one, two), \n+        assertEquals(distribution.cumulativeProbability(one, two),\n                 distribution.cumulativeProbability(oned, twod), tolerance);\n-        assertEquals(distribution.cumulativeProbability(one, two), \n+        assertEquals(distribution.cumulativeProbability(one, two),\n                 distribution.cumulativeProbability(oned - tolerance,\n                         twod + 0.9), tolerance);\n-        assertEquals(distribution.cumulativeProbability(two, ten), \n+        assertEquals(distribution.cumulativeProbability(two, ten),\n                 distribution.cumulativeProbability(twod, tend), tolerance);\n-        assertEquals(distribution.cumulativeProbability(two, ten), \n+        assertEquals(distribution.cumulativeProbability(two, ten),\n                 distribution.cumulativeProbability(twod - tolerance,\n                         tend + 0.9), tolerance);\n     }\n-    \n+\n     /**\n      * Verifies that inverse cumulative probability density calculations match expected values\n      * using default test instance data\n      */\n     public void testInverseCumulativeProbabilities() throws Exception {\n-        verifyInverseCumulativeProbabilities();       \n-    }\n-    \n+        verifyInverseCumulativeProbabilities();\n+    }\n+\n     /**\n      * Verifies that illegal arguments are correctly handled\n      */\n             fail(\"Expecting IllegalArgumentException for p = 2\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }       \n-    }\n-    \n+        }\n+    }\n+\n     //------------------ Getters / Setters for test instance data -----------\n     /**\n      * @return Returns the cumulativeTestPoints.\n--- a/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/NormalDistributionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * Test cases for NormalDistribution.\n  * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n  * ContinuousDistributionAbstractTest for details.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class NormalDistributionTest extends ContinuousDistributionAbstractTest  {\n-    \n+\n     /**\n      * Constructor for NormalDistributionTest.\n      * @param arg0\n     public NormalDistributionTest(String arg0) {\n         super(arg0);\n     }\n-    \n+\n     //-------------- Implementations for abstract methods -----------------------\n-    \n+\n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n     public ContinuousDistribution makeDistribution() {\n         return new NormalDistributionImpl(2.1, 1.4);\n-    }   \n-    \n+    }\n+\n     /** Creates the default cumulative probability distribution test input values */\n     @Override\n     public double[] makeCumulativeTestPoints() {\n-        // quantiles computed using R \n-        return new double[] {-2.226325d, -1.156887d, -0.6439496d, -0.2027951d, 0.3058278d, \n+        // quantiles computed using R\n+        return new double[] {-2.226325d, -1.156887d, -0.6439496d, -0.2027951d, 0.3058278d,\n                 6.426325d, 5.356887d, 4.84395d, 4.402795d, 3.894172d};\n     }\n-    \n+\n     /** Creates the default cumulative probability density test expected values */\n     @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n-                0.990d, 0.975d, 0.950d, 0.900d}; \n+                0.990d, 0.975d, 0.950d, 0.900d};\n     }\n-    \n+\n     // --------------------- Override tolerance  --------------\n     @Override\n     protected void setUp() throws Exception {\n         super.setUp();\n         setTolerance(1E-6);\n     }\n-    \n+\n     //---------------------------- Additional test cases -------------------------\n-    \n+\n     private void verifyQuantiles() throws Exception {\n         NormalDistribution distribution = (NormalDistribution) getDistribution();\n         double mu = distribution.getMean();\n         double sigma = distribution.getStandardDeviation();\n-        setCumulativeTestPoints( new double[] {mu - 2 *sigma, mu - sigma, \n+        setCumulativeTestPoints( new double[] {mu - 2 *sigma, mu - sigma,\n                 mu, mu + sigma, mu +2 * sigma,  mu +3 * sigma, mu + 4 * sigma,\n                 mu + 5 * sigma});\n         // Quantiles computed using R (same as Mathematica)\n-        setCumulativeTestValues(new double[] {0.02275013, 0.1586553, 0.5, 0.8413447, \n+        setCumulativeTestValues(new double[] {0.02275013, 0.1586553, 0.5, 0.8413447,\n                 0.9772499, 0.9986501, 0.9999683,  0.9999997});\n-        verifyCumulativeProbabilities();       \n+        verifyCumulativeProbabilities();\n     }\n-    \n+\n     public void testQuantiles() throws Exception {\n         verifyQuantiles();\n         setDistribution(new NormalDistributionImpl(0, 1));\n         setDistribution(new NormalDistributionImpl(0, 0.1));\n         verifyQuantiles();\n     }\n-    \n+\n     public void testInverseCumulativeProbabilityExtremes() throws Exception {\n         setInverseCumulativeTestPoints(new double[] {0, 1});\n         setInverseCumulativeTestValues(\n                 new double[] {Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY});\n         verifyInverseCumulativeProbabilities();\n     }\n-    \n+\n     public void testGetMean() {\n         NormalDistribution distribution = (NormalDistribution) getDistribution();\n         assertEquals(2.1, distribution.getMean(), 0);\n     }\n-    \n+\n     public void testSetMean() throws Exception {\n         double mu = Math.random();\n         NormalDistribution distribution = (NormalDistribution) getDistribution();\n         distribution.setMean(mu);\n         verifyQuantiles();\n     }\n-    \n+\n     public void testGetStandardDeviation() {\n         NormalDistribution distribution = (NormalDistribution) getDistribution();\n-        assertEquals(1.4, distribution.getStandardDeviation(), 0);  \n+        assertEquals(1.4, distribution.getStandardDeviation(), 0);\n     }\n-    \n+\n     public void testSetStandardDeviation() throws Exception {\n         double sigma = 0.1d + Math.random();\n         NormalDistribution distribution = (NormalDistribution) getDistribution();\n         double [] x = new double[]{-2, -1, 0, 1, 2};\n         // R 2.5: print(dnorm(c(-2,-1,0,1,2)), digits=10)\n         checkDensity(0, 1, x, new double[]{0.05399096651, 0.24197072452, 0.39894228040, 0.24197072452, 0.05399096651});\n-        // R 2.5: print(dnorm(c(-2,-1,0,1,2), mean=1.1), digits=10) \n+        // R 2.5: print(dnorm(c(-2,-1,0,1,2), mean=1.1), digits=10)\n         checkDensity(1.1, 1, x, new double[]{0.003266819056,0.043983595980,0.217852177033,0.396952547477,0.266085249899});\n     }\n \n                 assertTrue(lowerTail < 0.00001);\n                 assertTrue(upperTail > 0.99999);\n             }\n-        } \n+        }\n    }\n \n     public void testMath280() throws MathException {\n--- a/src/test/java/org/apache/commons/math/distribution/PascalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/PascalDistributionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * Test cases for PascalDistribution.\n  * Extends IntegerDistributionAbstractTest.  See class javadoc for\n  * IntegerDistributionAbstractTest for details.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class PascalDistributionTest extends IntegerDistributionAbstractTest {\n-    \n+\n     /**\n      * Constructor for PascalDistributionTest.\n      * @param name\n     public PascalDistributionTest(String name) {\n         super(name);\n     }\n-    \n+\n     //-------------- Implementations for abstract methods -----------------------\n-    \n+\n     /** Creates the default discrete distribution instance to use in tests. */\n     @Override\n     public IntegerDistribution makeDistribution() {\n         return new PascalDistributionImpl(10,0.70);\n     }\n-    \n+\n     /** Creates the default probability density test input values */\n     @Override\n     public int[] makeDensityTestPoints() {\n       return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n     }\n-    \n+\n     /** Creates the default probability density test expected values */\n     @Override\n     public double[] makeDensityTestValues() {\n-      return new double[] {0d, 0.02824d, 0.08474d, 0.13982d, \n+      return new double[] {0d, 0.02824d, 0.08474d, 0.13982d,\n           0.16779d, 0.16359d, 0.1374d, 0.10306d, 0.070673d, 0.04505d, 0.02703d, 0.01540d, 0.0084};\n     }\n-    \n+\n     /** Creates the default cumulative probability density test input values */\n     @Override\n     public int[] makeCumulativeTestPoints() {\n       return makeDensityTestPoints();\n     }\n-    \n+\n     /** Creates the default cumulative probability density test expected values */\n     @Override\n     public double[] makeCumulativeTestValues() {\n       return new double[] {0d, 0.02824d, 0.11299d, 0.25281d, 0.42060d, 0.58420d,\n           0.72162d, 0.82468d, 0.89535d, 0.94041d, 0.967446d, 0.98285, 0.99125d};\n         }\n-    \n+\n     /** Creates the default inverse cumulative probability test input values */\n     @Override\n     public double[] makeInverseCumulativeTestPoints() {\n       return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.100d, 0.999d,\n-          0.990d, 0.975d, 0.950d, 0.900d, 1}; \n+          0.990d, 0.975d, 0.950d, 0.900d, 1};\n         }\n-    \n+\n     /** Creates the default inverse cumulative probability density test expected values */\n     @Override\n     public int[] makeInverseCumulativeTestValues() {\n     }\n \n     //----------------- Additional test cases ---------------------------------\n-   \n+\n     /** Test degenerate case p = 0   */\n     public void testDegenerate0() throws Exception {\n         setDistribution(new PascalDistributionImpl(5,0.0d));\n         setInverseCumulativeTestValues(new int[] {Integer.MAX_VALUE - 1, Integer.MAX_VALUE - 1});\n         verifyDensities();\n         verifyCumulativeProbabilities();\n-        verifyInverseCumulativeProbabilities();     \n+        verifyInverseCumulativeProbabilities();\n     }\n-    \n+\n     /** Test degenerate case p = 1   */\n     public void testDegenerate1() throws Exception {\n         setDistribution(new PascalDistributionImpl(5,1.0d));\n         setInverseCumulativeTestValues(new int[] {-1, -1});\n         verifyDensities();\n         verifyCumulativeProbabilities();\n-        verifyInverseCumulativeProbabilities();     \n+        verifyInverseCumulativeProbabilities();\n     }\n }\n--- a/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/PoissonDistributionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n /**\n  * <code>PoissonDistributionTest</code>\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class PoissonDistributionTest extends IntegerDistributionAbstractTest {\n         setTolerance(1e-12);\n     }\n \n-    /** \n-     * Creates the default discrete distribution instance to use in tests. \n+    /**\n+     * Creates the default discrete distribution instance to use in tests.\n      */\n     @Override\n     public IntegerDistribution makeDistribution() {\n-        return new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);  \n+        return new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);\n     }\n \n-    /** \n+    /**\n      * Creates the default probability density test input values.\n      */\n     @Override\n     @Override\n     public double[] makeDensityTestValues() {\n         return new double[] { 0d, 0.0183156388887d,  0.073262555555d,\n-                0.14652511111d, 0.195366814813d, 0.195366814813, \n+                0.14652511111d, 0.195366814813d, 0.195366814813,\n                 0.156293451851d, 0.00529247667642d, 8.27746364655e-09};\n     }\n \n      */\n     @Override\n     public double[] makeCumulativeTestValues() {\n-        return new double[] { 0d,  0.0183156388887d, 0.0915781944437d, \n+        return new double[] { 0d,  0.0183156388887d, 0.0915781944437d,\n                 0.238103305554d, 0.433470120367d, 0.62883693518,\n                 0.78513038703d,  0.99716023388d, 0.999999998077 };\n     }\n \n-    /** \n+    /**\n      * Creates the default inverse cumulative probability test input values.\n      * Increased 3rd and 7th values slightly as computed cumulative\n-     * probabilities for corresponding values exceeds the target value (still \n+     * probabilities for corresponding values exceeds the target value (still\n      * within tolerance).\n      */\n     @Override\n     public double[] makeInverseCumulativeTestPoints() {\n-        return new double[] { 0d,  0.018315638889d, 0.0915781944437d, \n+        return new double[] { 0d,  0.018315638889d, 0.0915781944437d,\n                 0.238103305554d, 0.433470120367d, 0.62883693518,\n                 0.78513038704d,  0.99716023388d, 0.999999998077 };\n     }\n         assertEquals(Integer.MAX_VALUE, dist.inverseCumulativeProbability(1.0d));\n         assertEquals(-1, dist.inverseCumulativeProbability(0d));\n     }\n-    \n+\n     public void testMean() {\n         PoissonDistribution dist = new PoissonDistributionImpl(DEFAULT_TEST_POISSON_PARAMETER);\n         try {\n             fail(\"negative mean.  IllegalArgumentException expected\");\n         } catch(IllegalArgumentException ex) {\n         }\n-        \n+\n         dist.setMean(10.0);\n         assertEquals(10.0, dist.getMean(), 0.0);\n     }\n-    \n+\n     public void testLargeMeanCumulativeProbability() {\n         PoissonDistribution dist = new PoissonDistributionImpl(1.0);\n         double mean = 1.0;\n         while (mean <= 10000000.0) {\n             dist.setMean(mean);\n-            \n+\n             double x = mean * 2.0;\n             double dx = x / 10.0;\n             while (x >= 0) {\n                 }\n                 x -= dx;\n             }\n-            \n+\n             mean *= 10.0;\n         }\n     }\n-    \n+\n     public void testLargeMeanInverseCumulativeProbability() {\n         PoissonDistribution dist = new PoissonDistributionImpl(1.0);\n         double mean = 1.0;\n         while (mean <= 10000000.0) {\n             dist.setMean(mean);\n-            \n+\n             double p = 0.1;\n             double dp = p;\n             while (p < 1.0) {\n                 }\n                 p += dp;\n             }\n-            \n+\n             mean *= 10.0;\n         }\n     }\n-}\n+}\n--- a/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/WeibullDistributionTest.java\n  * Test cases for WeibullDistribution.\n  * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n  * ContinuousDistributionAbstractTest for details.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class WeibullDistributionTest extends ContinuousDistributionAbstractTest  {\n-    \n+\n     /**\n      * Constructor for CauchyDistributionTest.\n      * @param arg0\n     public WeibullDistributionTest(String arg0) {\n         super(arg0);\n     }\n-    \n+\n     //-------------- Implementations for abstract methods -----------------------\n-    \n+\n     /** Creates the default continuous distribution instance to use in tests. */\n     @Override\n     public ContinuousDistribution makeDistribution() {\n         return new WeibullDistributionImpl(1.2, 2.1);\n-    }   \n-    \n+    }\n+\n     /** Creates the default cumulative probability distribution test input values */\n     @Override\n     public double[] makeCumulativeTestPoints() {\n-        // quantiles computed using Mathematica \n+        // quantiles computed using Mathematica\n         return new double[] {0.00664355181d, 0.04543282833d, 0.09811627374d,\n                 0.1767135246d, 0.3219468654d, 4.207902826d, 5.23968437d,\n                 6.232056007d, 7.497630467d, 10.51154969d};\n     }\n-    \n+\n     /** Creates the default cumulative probability density test expected values */\n     @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.900d, 0.950d,\n                 0.975d, 0.990d, 0.999d};\n     }\n-    \n+\n     //---------------------------- Additional test cases -------------------------\n-    \n+\n     public void testInverseCumulativeProbabilityExtremes() throws Exception {\n         setInverseCumulativeTestPoints(new double[] {0.0, 1.0});\n         setInverseCumulativeTestValues(\n                 new double[] {0.0, Double.POSITIVE_INFINITY});\n         verifyInverseCumulativeProbabilities();\n     }\n-    \n+\n     public void testAlpha() {\n         WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n         double expected = Math.random();\n         distribution.setShape(expected);\n         assertEquals(expected, distribution.getShape(), 0.0);\n     }\n-    \n+\n     public void testBeta() {\n         WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n         double expected = Math.random();\n         distribution.setScale(expected);\n         assertEquals(expected, distribution.getScale(), 0.0);\n     }\n-    \n+\n     public void testSetAlpha() {\n         WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n         try {\n         } catch (IllegalArgumentException ex) {\n             // success\n         }\n-        \n+\n         try {\n             distribution.setShape(-1.0);\n             fail(\"Can not have negative alpha.\");\n             // success\n         }\n     }\n-    \n+\n     public void testSetBeta() {\n         WeibullDistribution distribution = (WeibullDistribution) getDistribution();\n         try {\n         } catch (IllegalArgumentException ex) {\n             // success\n         }\n-        \n+\n         try {\n             distribution.setScale(-1.0);\n             fail(\"Can not have negative beta.\");\n--- a/src/test/java/org/apache/commons/math/distribution/ZipfDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/ZipfDistributionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * Test cases for {@link ZipfDistribution}.\n  * Extends IntegerDistributionAbstractTest.  See class javadoc for\n  * IntegerDistributionAbstractTest for details.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class ZipfDistributionTest extends IntegerDistributionAbstractTest {\n     public ZipfDistributionTest(String name) {\n         super(name);\n     }\n-    \n+\n     //-------------- Implementations for abstract methods -----------------------\n-    \n+\n     /** Creates the default discrete distribution instance to use in tests. */\n     @Override\n     public IntegerDistribution makeDistribution() {\n         return new ZipfDistributionImpl(10, 1);\n     }\n-    \n+\n     /** Creates the default probability density test input values */\n     @Override\n     public int[] makeDensityTestPoints() {\n         return new int[] {-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n     }\n-    \n+\n     /** Creates the default probability density test expected values */\n     @Override\n     public double[] makeDensityTestValues() {\n-        return new double[] {0d, 0d, 0.3414d, 0.1707d, 0.1138d, 0.0854d, 0.0683d, \n+        return new double[] {0d, 0d, 0.3414d, 0.1707d, 0.1138d, 0.0854d, 0.0683d,\n                 0.0569d, 0.0488d, 0.0427d, 0.0379d, 0.0341d, 0d};\n     }\n-    \n+\n     /** Creates the default cumulative probability density test input values */\n     @Override\n     public int[] makeCumulativeTestPoints() {\n         return makeDensityTestPoints();\n     }\n-    \n+\n     /** Creates the default cumulative probability density test expected values */\n     @Override\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0d, 0.0000d, 0.3414d, 0.5121d, 0.6259d, 0.7113d,\n                 0.7796d, 0.8365d, 0.8852d, 0.9279d, 0.9659d, 1d, 1d};\n         }\n-    \n+\n     /** Creates the default inverse cumulative probability test input values */\n     @Override\n     public double[] makeInverseCumulativeTestPoints() {\n         return new double[] {0, 0.001d, 0.010d, 0.025d, 0.050d, 0.3414d, 0.3415d, 0.999d,\n-                0.990d, 0.975d, 0.950d, 0.900d, 1}; \n+                0.990d, 0.975d, 0.950d, 0.900d, 1};\n         }\n-    \n+\n     /** Creates the default inverse cumulative probability density test expected values */\n     @Override\n     public int[] makeInverseCumulativeTestValues() {\n         return new int[] {0, 0, 0, 0, 0, 0, 1, 9, 9, 9, 8, 7, 10};\n     }\n-}\n+}\n--- a/src/test/java/org/apache/commons/math/estimation/GaussNewtonEstimatorTest.java\n+++ b/src/test/java/org/apache/commons/math/estimation/GaussNewtonEstimatorTest.java\n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n  * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n- * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files. \n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files.\n  * The redistribution policy for MINPACK is available <a\n  * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n  * convenience, it is reproduced below.</p>\n--- a/src/test/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimatorTest.java\n+++ b/src/test/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimatorTest.java\n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n  * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n- * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files. \n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files.\n  * The redistribution policy for MINPACK is available <a\n  * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n  * convenience, it is reproduced below.</p>\n       double[] errors = estimator.guessParametersErrors(circle);\n       assertEquals(1.384, errors[0], 0.001);\n       assertEquals(0.905, errors[1], 0.001);\n-  \n+\n       // add perfect measurements and check errors are reduced\n       double cx = circle.getX();\n       double cy = circle.getY();\n       }\n       return set.toArray(new EstimatedParameter[set.size()]);\n     }\n-  \n+\n     private LinearMeasurement[] measurements;\n \n   }\n--- a/src/test/java/org/apache/commons/math/estimation/MinpackTest.java\n+++ b/src/test/java/org/apache/commons/math/estimation/MinpackTest.java\n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n  * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n- * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files. \n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files.\n  * The redistribution policy for MINPACK is available <a\n  * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n  * convenience, it is reproduced below.</p>\n     minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0},\n                                           991.261822123701), false);\n   }\n-    \n+\n   public void testMinpackPowellSingular() {\n     minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 },\n                                            14.6628782986152), false);\n     minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 },\n                                            126887.903284750), false);\n   }\n-    \n+\n   public void testMinpackFreudensteinRoth() {\n     minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },\n                                              20.0124960961895, 6.99887517584575,\n                                                -0.89680510749204\n                                              }), false);\n   }\n-    \n+\n   public void testMinpackBard() {\n     minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466,\n                                  new double[] {\n                                    -164464906.857771\n                                  }), false);\n   }\n-    \n+\n   public void testMinpackKowalikOsborne() {\n     minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 },\n                                            0.0728915102882945,\n                                              0.134575665392506\n                                            }), true);\n   }\n-    \n+\n   public void testMinpackMeyer() {\n     minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 },\n                                   41153.4665543031, 9.37794514651874,\n                                     901.268527953801\n                                   }), true);\n   }\n-    \n+\n   public void testMinpackWatson() {\n-  \n+\n     minpackTest(new WatsonFunction(6, 0.0,\n                                    5.47722557505166, 0.0478295939097601,\n                                    new double[] {\n                                    }), false);\n \n   }\n-    \n+\n   public void testMinpackBox3Dimensional() {\n     minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 },\n                                             32.1115837449572), false);\n   }\n-    \n+\n   public void testMinpackJennrichSampson() {\n     minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },\n                                             64.5856498144943, 11.1517793413499,\n                                          -0.403688070279258, 0.236665033746463\n                                         }), false);\n   }\n-    \n+\n   public void testMinpackChebyquad() {\n     minpackTest(new ChebyquadFunction(1, 8, 1.0,\n                                       1.88623796907732, 1.88623796907732,\n                                         0.833291216194063,  0.940379732824644\n                                       }), false);\n   }\n-    \n+\n   public void testMinpackBrownAlmostLinear() {\n     minpackTest(new BrownAlmostLinearFunction(10, 0.5,\n                                               16.5302162063499, 0.0,\n                                                0.979430303349865, 0.979430303349865,\n                                                0.979430303349865, 0.979430303349865,\n                                                0.979430303349865, 1.20569696650135\n-                                              }), false);  \n+                                              }), false);\n     minpackTest(new BrownAlmostLinearFunction(10, 50.0,\n                                               0.9765625e17, 0.0,\n                                               new double[] {\n                                                 0.999999999999121\n                                               }), false);\n     }\n-    \n+\n   public void testMinpackOsborne1() {\n       minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, },\n                                        0.937564021037838, 0.00739249260904843,\n                                          0.0221227011813076\n                                        }), false);\n     }\n-    \n+\n   public void testMinpackOsborne2() {\n-      \n+\n     minpackTest(new Osborne2Function(new double[] {\n                                        1.3, 0.65, 0.65, 0.7, 0.6,\n                                        3.0, 5.0, 7.0, 2.0, 4.5, 5.5\n   }\n \n   private static abstract class MinpackFunction implements EstimationProblem {\n- \n+\n     protected MinpackFunction(int m,\n                               double[] startParams,\n                               double   theoreticalStartCost,\n       }\n       return true;\n     }\n- \n+\n     public WeightedMeasurement[] getMeasurements() {\n       WeightedMeasurement[] measurements = new WeightedMeasurement[m];\n       for (int i = 0; i < m; ++i) {\n       34780.0, 28610.0, 23650.0, 19630.0,\n       16370.0, 13720.0, 11540.0,  9744.0,\n        8261.0,  7030.0,  6005.0,  5147.0,\n-       4427.0,  3820.0,  3307.0,  2872.0                  \n+       4427.0,  3820.0,  3307.0,  2872.0\n     };\n \n   }\n--- a/src/test/java/org/apache/commons/math/fraction/BigFractionFormatTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/BigFractionFormatTest.java\n import junit.framework.TestCase;\n \n public class BigFractionFormatTest extends TestCase {\n- \n+\n     BigFractionFormat properFormat = null;\n     BigFractionFormat improperFormat = null;\n \n         properFormat = BigFractionFormat.getProperInstance(getLocale());\n         improperFormat = BigFractionFormat.getImproperInstance(getLocale());\n     }\n-   \n+\n     public void testFormat() {\n         BigFraction c = new BigFraction(1, 2);\n         String expected = \"1 / 2\";\n-        \n-        String actual = properFormat.format(c); \n+\n+        String actual = properFormat.format(c);\n         assertEquals(expected, actual);\n \n         actual = improperFormat.format(c);\n         BigFraction c = new BigFraction(-1, 2);\n         String expected = \"-1 / 2\";\n \n-        String actual = properFormat.format(c); \n-        assertEquals(expected, actual);\n-\n-        actual = improperFormat.format(c); \n+        String actual = properFormat.format(c);\n+        assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n         BigFraction c = new BigFraction(0, 1);\n         String expected = \"0 / 1\";\n \n-        String actual = properFormat.format(c); \n-        assertEquals(expected, actual);\n-\n-        actual = improperFormat.format(c); \n-        assertEquals(expected, actual);\n-    }\n-    \n+        String actual = properFormat.format(c);\n+        assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c);\n+        assertEquals(expected, actual);\n+    }\n+\n     public void testFormatImproper() {\n         BigFraction c = new BigFraction(5, 3);\n \n-        String actual = properFormat.format(c); \n+        String actual = properFormat.format(c);\n         assertEquals(\"1 2 / 3\", actual);\n \n-        actual = improperFormat.format(c); \n+        actual = improperFormat.format(c);\n         assertEquals(\"5 / 3\", actual);\n     }\n-    \n+\n     public void testFormatImproperNegative() {\n         BigFraction c = new BigFraction(-5, 3);\n \n-        String actual = properFormat.format(c); \n+        String actual = properFormat.format(c);\n         assertEquals(\"-1 2 / 3\", actual);\n \n-        actual = improperFormat.format(c); \n+        actual = improperFormat.format(c);\n         assertEquals(\"-5 / 3\", actual);\n     }\n-    \n+\n     public void testParse() {\n         String source = \"1 / 2\";\n \n             assertNotNull(c);\n             assertEquals(BigInteger.ONE, c.getNumerator());\n             assertEquals(BigInteger.valueOf(2l), c.getDenominator());\n-            \n+\n             c = improperFormat.parse(source);\n             assertNotNull(c);\n             assertEquals(BigInteger.ONE, c.getNumerator());\n             fail(ex.getMessage());\n         }\n     }\n-    \n+\n     public void testParseInteger() {\n         String source = \"10\";\n         try {\n             fail(ex.getMessage());\n         }\n     }\n-    \n+\n     public void testParseInvalid() {\n         String source = \"a\";\n         String msg = \"should not be able to parse '10 / a'.\";\n             // success\n         }\n     }\n-    \n+\n     public void testParseInvalidDenominator() {\n         String source = \"10 / a\";\n         String msg = \"should not be able to parse '10 / a'.\";\n             // success\n         }\n     }\n-    \n+\n     public void testParseNegative() {\n \n         try {\n             assertNotNull(c);\n             assertEquals(-1, c.getNumeratorAsInt());\n             assertEquals(2, c.getDenominatorAsInt());\n-            \n+\n             c = improperFormat.parse(source);\n             assertNotNull(c);\n             assertEquals(-1, c.getNumeratorAsInt());\n             assertNotNull(c);\n             assertEquals(-1, c.getNumeratorAsInt());\n             assertEquals(2, c.getDenominatorAsInt());\n-            \n+\n             c = improperFormat.parse(source);\n             assertNotNull(c);\n             assertEquals(-1, c.getNumeratorAsInt());\n             fail(ex.getMessage());\n         }\n     }\n-    \n+\n     public void testParseProper() {\n         String source = \"1 2 / 3\";\n \n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n         }\n-        \n+\n         try {\n             improperFormat.parse(source);\n             fail(\"invalid improper fraction.\");\n             // success\n         }\n     }\n-    \n+\n     public void testParseProperNegative() {\n         String source = \"-1 2 / 3\";\n         try {\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n         }\n-        \n+\n         try {\n             improperFormat.parse(source);\n             fail(\"invalid improper fraction.\");\n             // success\n         }\n     }\n-    \n+\n     public void testParseProperInvalidMinus() {\n         String source = \"2 -2 / 3\";\n         try {\n             new BigDecimal(\"3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068\");\n         assertEquals(pi, f1.bigDecimalValue(99, BigDecimal.ROUND_HALF_EVEN));\n     }\n-    \n+\n     public void testNumeratorFormat() {\n         NumberFormat old = properFormat.getNumeratorFormat();\n         NumberFormat nf = NumberFormat.getInstance();\n         assertEquals(nf, improperFormat.getNumeratorFormat());\n         improperFormat.setNumeratorFormat(old);\n     }\n-    \n+\n     public void testDenominatorFormat() {\n         NumberFormat old = properFormat.getDenominatorFormat();\n         NumberFormat nf = NumberFormat.getInstance();\n         assertEquals(nf, improperFormat.getDenominatorFormat());\n         improperFormat.setDenominatorFormat(old);\n     }\n-    \n+\n     public void testWholeFormat() {\n         ProperBigFractionFormat format = (ProperBigFractionFormat)properFormat;\n-        \n+\n         NumberFormat old = format.getWholeFormat();\n         NumberFormat nf = NumberFormat.getInstance();\n         nf.setParseIntegerOnly(true);\n         assertEquals(nf, format.getWholeFormat());\n         format.setWholeFormat(old);\n     }\n-    \n+\n     public void testLongFormat() {\n         assertEquals(\"10 / 1\", improperFormat.format(10l));\n     }\n-    \n+\n     public void testDoubleFormat() {\n         assertEquals(\"1 / 16\", improperFormat.format(0.0625));\n     }\n--- a/src/test/java/org/apache/commons/math/fraction/FractionFormatTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/FractionFormatTest.java\n import junit.framework.TestCase;\n \n public class FractionFormatTest extends TestCase {\n- \n+\n     FractionFormat properFormat = null;\n     FractionFormat improperFormat = null;\n \n         properFormat = FractionFormat.getProperInstance(getLocale());\n         improperFormat = FractionFormat.getImproperInstance(getLocale());\n     }\n-   \n+\n     public void testFormat() {\n         Fraction c = new Fraction(1, 2);\n         String expected = \"1 / 2\";\n-        \n-        String actual = properFormat.format(c); \n+\n+        String actual = properFormat.format(c);\n         assertEquals(expected, actual);\n \n         actual = improperFormat.format(c);\n         Fraction c = new Fraction(-1, 2);\n         String expected = \"-1 / 2\";\n \n-        String actual = properFormat.format(c); \n-        assertEquals(expected, actual);\n-\n-        actual = improperFormat.format(c); \n+        String actual = properFormat.format(c);\n+        assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n         Fraction c = new Fraction(0, 1);\n         String expected = \"0 / 1\";\n \n-        String actual = properFormat.format(c); \n-        assertEquals(expected, actual);\n-\n-        actual = improperFormat.format(c); \n-        assertEquals(expected, actual);\n-    }\n-    \n+        String actual = properFormat.format(c);\n+        assertEquals(expected, actual);\n+\n+        actual = improperFormat.format(c);\n+        assertEquals(expected, actual);\n+    }\n+\n     public void testFormatImproper() {\n         Fraction c = new Fraction(5, 3);\n \n-        String actual = properFormat.format(c); \n+        String actual = properFormat.format(c);\n         assertEquals(\"1 2 / 3\", actual);\n \n-        actual = improperFormat.format(c); \n+        actual = improperFormat.format(c);\n         assertEquals(\"5 / 3\", actual);\n     }\n-    \n+\n     public void testFormatImproperNegative() {\n         Fraction c = new Fraction(-5, 3);\n \n-        String actual = properFormat.format(c); \n+        String actual = properFormat.format(c);\n         assertEquals(\"-1 2 / 3\", actual);\n \n-        actual = improperFormat.format(c); \n+        actual = improperFormat.format(c);\n         assertEquals(\"-5 / 3\", actual);\n     }\n-    \n+\n     public void testParse() {\n         String source = \"1 / 2\";\n \n             assertNotNull(c);\n             assertEquals(1, c.getNumerator());\n             assertEquals(2, c.getDenominator());\n-            \n+\n             c = improperFormat.parse(source);\n             assertNotNull(c);\n             assertEquals(1, c.getNumerator());\n             fail(ex.getMessage());\n         }\n     }\n-    \n+\n     public void testParseInteger() {\n         String source = \"10\";\n         try {\n             fail(ex.getMessage());\n         }\n     }\n-    \n+\n     public void testParseInvalid() {\n         String source = \"a\";\n         String msg = \"should not be able to parse '10 / a'.\";\n             // success\n         }\n     }\n-    \n+\n     public void testParseInvalidDenominator() {\n         String source = \"10 / a\";\n         String msg = \"should not be able to parse '10 / a'.\";\n             // success\n         }\n     }\n-    \n+\n     public void testParseNegative() {\n \n         try {\n             assertNotNull(c);\n             assertEquals(-1, c.getNumerator());\n             assertEquals(2, c.getDenominator());\n-            \n+\n             c = improperFormat.parse(source);\n             assertNotNull(c);\n             assertEquals(-1, c.getNumerator());\n             assertNotNull(c);\n             assertEquals(-1, c.getNumerator());\n             assertEquals(2, c.getDenominator());\n-            \n+\n             c = improperFormat.parse(source);\n             assertNotNull(c);\n             assertEquals(-1, c.getNumerator());\n             fail(ex.getMessage());\n         }\n     }\n-    \n+\n     public void testParseProper() {\n         String source = \"1 2 / 3\";\n \n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n         }\n-        \n+\n         try {\n             improperFormat.parse(source);\n             fail(\"invalid improper fraction.\");\n             // success\n         }\n     }\n-    \n+\n     public void testParseProperNegative() {\n         String source = \"-1 2 / 3\";\n         try {\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n         }\n-        \n+\n         try {\n             improperFormat.parse(source);\n             fail(\"invalid improper fraction.\");\n             // success\n         }\n     }\n-    \n+\n     public void testParseProperInvalidMinus() {\n         String source = \"2 -2 / 3\";\n         try {\n             // expected\n         }\n     }\n-    \n+\n     public void testNumeratorFormat() {\n         NumberFormat old = properFormat.getNumeratorFormat();\n         NumberFormat nf = NumberFormat.getInstance();\n         assertEquals(nf, improperFormat.getNumeratorFormat());\n         improperFormat.setNumeratorFormat(old);\n     }\n-    \n+\n     public void testDenominatorFormat() {\n         NumberFormat old = properFormat.getDenominatorFormat();\n         NumberFormat nf = NumberFormat.getInstance();\n         assertEquals(nf, improperFormat.getDenominatorFormat());\n         improperFormat.setDenominatorFormat(old);\n     }\n-    \n+\n     public void testWholeFormat() {\n         ProperFractionFormat format = (ProperFractionFormat)properFormat;\n-        \n+\n         NumberFormat old = format.getWholeFormat();\n         NumberFormat nf = NumberFormat.getInstance();\n         nf.setParseIntegerOnly(true);\n         assertEquals(nf, format.getWholeFormat());\n         format.setWholeFormat(old);\n     }\n-    \n+\n     public void testLongFormat() {\n         assertEquals(\"10 / 1\", improperFormat.format(10l));\n     }\n-    \n+\n     public void testDoubleFormat() {\n         assertEquals(\"355 / 113\", improperFormat.format(Math.PI));\n     }\n--- a/src/test/java/org/apache/commons/math/fraction/FractionTest.java\n+++ b/src/test/java/org/apache/commons/math/fraction/FractionTest.java\n         assertEquals(expectedNumerator, actual.getNumerator());\n         assertEquals(expectedDenominator, actual.getDenominator());\n     }\n-    \n+\n     public void testConstructor() {\n         assertFraction(0, 1, new Fraction(0, 1));\n         assertFraction(0, 1, new Fraction(0, 2));\n         assertFraction(-1, 2, new Fraction(1, -2));\n         assertFraction(-1, 2, new Fraction(-2, 4));\n         assertFraction(-1, 2, new Fraction(2, -4));\n-        \n+\n         // overflow\n         try {\n             new Fraction(Integer.MIN_VALUE, -1);\n         } catch (ArithmeticException ex) {\n             // success\n         }\n-        try {        \n+        try {\n             assertFraction(0, 1, new Fraction(0.00000000000001));\n             assertFraction(2, 5, new Fraction(0.40000000000001));\n             assertFraction(15, 1, new Fraction(15.0000000000001));\n-            \n+\n         } catch (ConvergenceException ex) {\n             fail(ex.getMessage());\n         }\n         Fraction first = new Fraction(1, 2);\n         Fraction second = new Fraction(1, 3);\n         Fraction third = new Fraction(1, 2);\n-        \n+\n         assertEquals(0, first.compareTo(first));\n         assertEquals(0, first.compareTo(third));\n         assertEquals(1, first.compareTo(second));\n         assertEquals( 1, pi2.compareTo(pi1));\n         assertEquals(0.0, pi1.doubleValue() - pi2.doubleValue(), 1.0e-20);\n     }\n-    \n+\n     public void testDoubleValue() {\n         Fraction first = new Fraction(1, 2);\n         Fraction second = new Fraction(1, 3);\n         assertEquals(0.5, first.doubleValue(), 0.0);\n         assertEquals(1.0 / 3.0, second.doubleValue(), 0.0);\n     }\n-    \n+\n     public void testFloatValue() {\n         Fraction first = new Fraction(1, 2);\n         Fraction second = new Fraction(1, 3);\n         assertEquals(0.5f, first.floatValue(), 0.0f);\n         assertEquals((float)(1.0 / 3.0), second.floatValue(), 0.0f);\n     }\n-    \n+\n     public void testIntValue() {\n         Fraction first = new Fraction(1, 2);\n         Fraction second = new Fraction(3, 2);\n         assertEquals(0, first.intValue());\n         assertEquals(1, second.intValue());\n     }\n-    \n+\n     public void testLongValue() {\n         Fraction first = new Fraction(1, 2);\n         Fraction second = new Fraction(3, 2);\n         assertEquals(0L, first.longValue());\n         assertEquals(1L, second.longValue());\n     }\n-    \n+\n     public void testConstructorDouble() {\n         try {\n             assertFraction(1, 2, new Fraction(0.5));\n             fail(ex.getMessage());\n         }\n     }\n-    \n+\n     public void testAbs() {\n         Fraction a = new Fraction(10, 21);\n         Fraction b = new Fraction(-10, 21);\n         Fraction c = new Fraction(10, -21);\n-        \n+\n         assertFraction(10, 21, a.abs());\n         assertFraction(10, 21, b.abs());\n         assertFraction(10, 21, c.abs());\n     }\n-    \n+\n     public void testReciprocal() {\n         Fraction f = null;\n-        \n+\n         f = new Fraction(50, 75);\n         f = f.reciprocal();\n         assertEquals(3, f.getNumerator());\n         assertEquals(2, f.getDenominator());\n-        \n+\n         f = new Fraction(4, 3);\n         f = f.reciprocal();\n         assertEquals(3, f.getNumerator());\n         assertEquals(4, f.getDenominator());\n-        \n+\n         f = new Fraction(-15, 47);\n         f = f.reciprocal();\n         assertEquals(-47, f.getNumerator());\n         assertEquals(15, f.getDenominator());\n-        \n+\n         f = new Fraction(0, 3);\n         try {\n             f = f.reciprocal();\n         assertEquals(1, f.getNumerator());\n         assertEquals(Integer.MAX_VALUE, f.getDenominator());\n     }\n-    \n+\n     public void testNegate() {\n         Fraction f = null;\n-        \n+\n         f = new Fraction(50, 75);\n         f = f.negate();\n         assertEquals(-2, f.getNumerator());\n         assertEquals(3, f.getDenominator());\n-        \n+\n         f = new Fraction(-50, 75);\n         f = f.negate();\n         assertEquals(2, f.getNumerator());\n             fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n     }\n-    \n+\n     public void testAdd() {\n         Fraction a = new Fraction(1, 2);\n         Fraction b = new Fraction(2, 3);\n-        \n+\n         assertFraction(1, 1, a.add(a));\n         assertFraction(7, 6, a.add(b));\n         assertFraction(7, 6, b.add(a));\n         assertFraction(4, 3, b.add(b));\n-        \n+\n         Fraction f1 = new Fraction(Integer.MAX_VALUE - 1, 1);\n         Fraction f2 = Fraction.ONE;\n         Fraction f = f1.add(f2);\n         f = f1.add(1);\n         assertEquals(Integer.MAX_VALUE, f.getNumerator());\n         assertEquals(1, f.getDenominator());\n-        \n+\n         f1 = new Fraction(-1, 13*13*2*2);\n         f2 = new Fraction(-2, 13*17*2);\n         f = f1.add(f2);\n         assertEquals(13*13*17*2*2, f.getDenominator());\n         assertEquals(-17 - 2*13*2, f.getNumerator());\n-        \n+\n         try {\n             f.add(null);\n             fail(\"expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {}\n-        \n+\n         // if this fraction is added naively, it will overflow.\n         // check that it doesn't.\n         f1 = new Fraction(1,32768*3);\n         f = f1.add(f2);\n         assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n         assertEquals(3, f.getDenominator());\n-        \n+\n         f1 = new Fraction(Integer.MAX_VALUE - 1, 1);\n         f2 = Fraction.ONE;\n         f = f1.add(f2);\n         assertEquals(Integer.MAX_VALUE, f.getNumerator());\n         assertEquals(1, f.getDenominator());\n-        \n+\n         try {\n             f = f.add(Fraction.ONE); // should overflow\n             fail(\"expecting ArithmeticException but got: \" + f.toString());\n         } catch (ArithmeticException ex) {}\n-        \n+\n         // denominator should not be a multiple of 2 or 3 to trigger overflow\n         f1 = new Fraction(Integer.MIN_VALUE, 5);\n         f2 = new Fraction(-1,5);\n             f = f1.add(f2); // should overflow\n             fail(\"expecting ArithmeticException but got: \" + f.toString());\n         } catch (ArithmeticException ex) {}\n-        \n+\n         try {\n             f= new Fraction(-Integer.MAX_VALUE, 1);\n             f = f.add(f);\n             fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n-        \n+\n         try {\n             f= new Fraction(-Integer.MAX_VALUE, 1);\n             f = f.add(f);\n             fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n-        \n+\n         f1 = new Fraction(3,327680);\n         f2 = new Fraction(2,59049);\n         try {\n             fail(\"expecting ArithmeticException but got: \" + f.toString());\n         } catch (ArithmeticException ex) {}\n     }\n-    \n+\n     public void testDivide() {\n         Fraction a = new Fraction(1, 2);\n         Fraction b = new Fraction(2, 3);\n-        \n+\n         assertFraction(1, 1, a.divide(a));\n         assertFraction(3, 4, a.divide(b));\n         assertFraction(4, 3, b.divide(a));\n         assertFraction(1, 1, b.divide(b));\n-        \n+\n         Fraction f1 = new Fraction(3, 5);\n         Fraction f2 = Fraction.ZERO;\n         try {\n             f1.divide(f2);\n             fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n-        \n+\n         f1 = new Fraction(0, 5);\n         f2 = new Fraction(2, 7);\n         Fraction f = f1.divide(f2);\n         assertSame(Fraction.ZERO, f);\n-        \n+\n         f1 = new Fraction(2, 7);\n         f2 = Fraction.ONE;\n         f = f1.divide(f2);\n         assertEquals(2, f.getNumerator());\n         assertEquals(7, f.getDenominator());\n-        \n+\n         f1 = new Fraction(1, Integer.MAX_VALUE);\n-        f = f1.divide(f1);  \n+        f = f1.divide(f1);\n         assertEquals(1, f.getNumerator());\n         assertEquals(1, f.getDenominator());\n-        \n+\n         f1 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n         f2 = new Fraction(1, Integer.MAX_VALUE);\n         f = f1.divide(f2);\n             f.divide(null);\n             fail(\"IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {}\n-        \n+\n         try {\n             f1 = new Fraction(1, Integer.MAX_VALUE);\n             f = f1.divide(f1.reciprocal());  // should overflow\n         assertEquals(175, f.getDenominator());\n \n     }\n-    \n+\n     public void testMultiply() {\n         Fraction a = new Fraction(1, 2);\n         Fraction b = new Fraction(2, 3);\n-        \n+\n         assertFraction(1, 4, a.multiply(a));\n         assertFraction(1, 3, a.multiply(b));\n         assertFraction(1, 3, b.multiply(a));\n         assertFraction(4, 9, b.multiply(b));\n-        \n+\n         Fraction f1 = new Fraction(Integer.MAX_VALUE, 1);\n         Fraction f2 = new Fraction(Integer.MIN_VALUE, Integer.MAX_VALUE);\n         Fraction f = f1.multiply(f2);\n         assertEquals(18, f.getNumerator());\n         assertEquals(7, f.getDenominator());\n     }\n-    \n+\n     public void testSubtract() {\n         Fraction a = new Fraction(1, 2);\n         Fraction b = new Fraction(2, 3);\n-        \n+\n         assertFraction(0, 1, a.subtract(a));\n         assertFraction(-1, 6, a.subtract(b));\n         assertFraction(1, 6, b.subtract(a));\n         assertFraction(0, 1, b.subtract(b));\n-        \n+\n         Fraction f = new Fraction(1,1);\n         try {\n             f.subtract(null);\n             fail(\"expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {}\n-        \n+\n         // if this fraction is subtracted naively, it will overflow.\n         // check that it doesn't.\n         Fraction f1 = new Fraction(1,32768*3);\n         f = f1.subtract(f2);\n         assertEquals(Integer.MIN_VALUE+1, f.getNumerator());\n         assertEquals(3, f.getDenominator());\n-        \n+\n         f1 = new Fraction(Integer.MAX_VALUE, 1);\n         f2 = Fraction.ONE;\n         f = f1.subtract(f2);\n             f = f1.subtract(f2);\n             fail(\"expecting ArithmeticException\");  //should overflow\n         } catch (ArithmeticException ex) {}\n-        \n+\n         // denominator should not be a multiple of 2 or 3 to trigger overflow\n         f1 = new Fraction(Integer.MIN_VALUE, 5);\n         f2 = new Fraction(1,5);\n             f = f1.subtract(f2); // should overflow\n             fail(\"expecting ArithmeticException but got: \" + f.toString());\n         } catch (ArithmeticException ex) {}\n-        \n+\n         try {\n             f= new Fraction(Integer.MIN_VALUE, 1);\n             f = f.subtract(Fraction.ONE);\n             fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n-        \n+\n         try {\n             f= new Fraction(Integer.MAX_VALUE, 1);\n             f = f.subtract(Fraction.ONE.negate());\n             fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n-        \n+\n         f1 = new Fraction(3,327680);\n         f2 = new Fraction(2,59049);\n         try {\n             fail(\"expecting ArithmeticException but got: \" + f.toString());\n         } catch (ArithmeticException ex) {}\n     }\n-    \n+\n     public void testEqualsAndHashCode() {\n         Fraction zero  = new Fraction(0,1);\n         Fraction nullFraction = null;\n         Fraction one = new Fraction(1,1);\n         assertFalse((one.equals(zero) ||zero.equals(one)));\n     }\n-    \n+\n     public void testGetReducedFraction() {\n         Fraction threeFourths = new Fraction(3, 4);\n         assertTrue(threeFourths.equals(Fraction.getReducedFraction(6, 8)));\n--- a/src/test/java/org/apache/commons/math/genetics/BinaryChromosomeTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/BinaryChromosomeTest.java\n import org.junit.Test;\n \n public class BinaryChromosomeTest {\n-    \n+\n     @Test\n-    public void testInvalidConstructor() {        \n+    public void testInvalidConstructor() {\n         Integer[][] reprs = new Integer[][] {\n                 new Integer[] {0,1,0,1,2},\n                 new Integer[] {0,1,0,1,-1}\n         };\n-        \n+\n         for (Integer[] repr : reprs) {\n             try {\n                 new DummyBinaryChromosome(repr);\n                 fail(\"Exception not caught\");\n             } catch (IllegalArgumentException e) {\n-                \n+\n             }\n         }\n     }\n-    \n+\n     @Test\n     public void testRandomConstructor() {\n         for (int i=0; i<20; i++) {\n             new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(10));\n         }\n     }\n-    \n+\n     @Test\n     public void testIsSame() {\n         Chromosome c1 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1});\n         Chromosome c4 = new DummyBinaryChromosome(new Integer[] {1,1,0,1,0,1});\n         Chromosome c5 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,0});\n         Chromosome c6 = new DummyBinaryChromosome(new Integer[] {0,1,0,1,0,1});\n-        \n+\n         assertFalse(c1.isSame(c2));\n         assertFalse(c1.isSame(c3));\n         assertFalse(c1.isSame(c4));\n--- a/src/test/java/org/apache/commons/math/genetics/BinaryMutationTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/BinaryMutationTest.java\n     @Test\n     public void testMutate() {\n         BinaryMutation mutation = new BinaryMutation();\n-        \n+\n         // stochastic testing :)\n         for (int i=0; i<20; i++) {\n-            DummyBinaryChromosome original = new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(10));            \n+            DummyBinaryChromosome original = new DummyBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(10));\n             DummyBinaryChromosome mutated = (DummyBinaryChromosome) mutation.mutate(original);\n-            \n+\n             // one gene should be different\n             int numDifferent = 0;\n             for (int j=0; j<original.getRepresentation().size(); j++) {\n--- a/src/test/java/org/apache/commons/math/genetics/ChromosomeTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/ChromosomeTest.java\n     @Test\n     public void testCompareTo() {\n         Chromosome c1 = new Chromosome() {\n-            public double fitness() {                \n+            public double fitness() {\n                 return 0;\n             }\n         };\n         Chromosome c2 = new Chromosome() {\n-            public double fitness() {                \n+            public double fitness() {\n                 return 10;\n             }\n         };\n         Chromosome c3 = new Chromosome() {\n-            public double fitness() {                \n+            public double fitness() {\n                 return 10;\n             }\n         };\n-        \n+\n         assertTrue(c1.compareTo(c2) < 0);\n         assertTrue(c2.compareTo(c1) > 0);\n         assertEquals(0,c3.compareTo(c2));\n         assertEquals(0,c2.compareTo(c3));\n     }\n-    \n+\n     private abstract static class DummyChromosome extends Chromosome {\n         private final int repr;\n \n             return ((DummyChromosome) another).repr == repr;\n         }\n     }\n-    \n+\n     @Test\n     public void testFindSameChromosome() {\n         Chromosome c1 = new DummyChromosome(1) {\n                 return 15;\n             }\n         };\n-        \n+\n         List<Chromosome> popChr = new ArrayList<Chromosome>();\n         popChr.add(c1);\n         popChr.add(c2);\n                 return null;\n             }\n         };\n-        \n+\n         assertNull(c5.findSameChromosome(pop));\n         assertEquals(c1, c4.findSameChromosome(pop));\n-        \n+\n         c4.searchForFitnessUpdate(pop);\n         assertEquals(1, c4.getFitness(),0);\n     }\n--- a/src/test/java/org/apache/commons/math/genetics/DummyBinaryChromosome.java\n+++ b/src/test/java/org/apache/commons/math/genetics/DummyBinaryChromosome.java\n     public DummyBinaryChromosome(List<Integer> representation) {\n         super(representation);\n     }\n-    \n+\n     public DummyBinaryChromosome(Integer[] representation) {\n         super(representation);\n     }\n--- a/src/test/java/org/apache/commons/math/genetics/DummyRandomKey.java\n+++ b/src/test/java/org/apache/commons/math/genetics/DummyRandomKey.java\n     public DummyRandomKey(List<Double> representation) {\n         super(representation);\n     }\n-    \n+\n     public DummyRandomKey(Double[] representation) {\n         super(representation);\n     }\n         // unimportant\n         return 0;\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/math/genetics/ElitisticListPopulationTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/ElitisticListPopulationTest.java\n import org.junit.Test;\n \n public class ElitisticListPopulationTest {\n-    \n+\n     private static int counter = 0;\n \n     @Test\n     public void testNextGeneration() {\n         ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203);\n-        \n+\n         for (int i=0; i<pop.getPopulationLimit(); i++) {\n             pop.addChromosome(new DummyChromosome());\n         }\n-        \n+\n         Population nextGeneration = pop.nextGeneration();\n-        \n+\n         assertEquals(20, nextGeneration.getPopulationSize());\n     }\n-    \n+\n     private static class DummyChromosome extends Chromosome {\n         private final int fitness;\n-        \n+\n         public DummyChromosome() {\n             this.fitness = counter;\n             counter++;\n         }\n-        \n-        public double fitness() {            \n+\n+        public double fitness() {\n             return this.fitness;\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/genetics/FitnessCachingTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/FitnessCachingTest.java\n \n \n public class FitnessCachingTest {\n-    \n+\n     // parameters for the GA\n-    private static final int DIMENSION = 50; \n+    private static final int DIMENSION = 50;\n     private static final double CROSSOVER_RATE = 1;\n     private static final double MUTATION_RATE = 0.1;\n     private static final int TOURNAMENT_ARITY = 5;\n-    \n+\n     private static final int POPULATION_SIZE = 10;\n     private static final int NUM_GENERATIONS = 50;\n     private static final double ELITISM_RATE = 0.2;\n                 MUTATION_RATE, // no mutation\n                 new TournamentSelection(TOURNAMENT_ARITY)\n         );\n-        \n+\n         // initial population\n         Population initial = randomPopulation();\n         // stopping conditions\n         StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);\n-        \n+\n         // run the algorithm\n         ga.evolve(initial, stopCond);\n-        \n+\n         int neededCalls =\n             POPULATION_SIZE /*initial population*/ +\n             (NUM_GENERATIONS - 1) /*for each population*/ * (int)(POPULATION_SIZE * (1.0 - ELITISM_RATE)) /*some chromosomes are copied*/\n      */\n     private static ElitisticListPopulation randomPopulation() {\n         List<Chromosome> popList = new LinkedList<Chromosome>();\n-        \n+\n         for (int i=0; i<POPULATION_SIZE; i++) {\n             BinaryChromosome randChrom = new DummyCountingBinaryChromosome(BinaryChromosome.randomBinaryRepresentation(DIMENSION));\n             popList.add(randChrom);\n-        }        \n+        }\n         return new ElitisticListPopulation(popList, popList.size(), ELITISM_RATE);\n     }\n-    \n+\n     private static class DummyCountingBinaryChromosome extends DummyBinaryChromosome {\n \n         public DummyCountingBinaryChromosome(List<Integer> representation) {\n             super(representation);\n-        }        \n+        }\n \n         @Override\n         public double fitness() {\n--- a/src/test/java/org/apache/commons/math/genetics/FixedGenerationCountTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/FixedGenerationCountTest.java\n     @Test\n     public void testIsSatisfied() {\n         FixedGenerationCount fgc = new FixedGenerationCount(20);\n-        \n+\n         int cnt = 0;\n         Population pop = new Population() {\n             public void addChromosome(Chromosome chromosome) {\n                 return null;\n             }\n         };\n-        \n+\n         while (!fgc.isSatisfied(pop))\n             cnt++;\n         assertEquals(20, cnt);\n--- a/src/test/java/org/apache/commons/math/genetics/GeneticAlgorithmTestBinary.java\n+++ b/src/test/java/org/apache/commons/math/genetics/GeneticAlgorithmTestBinary.java\n  * This is also an example of usage.\n  */\n public class GeneticAlgorithmTestBinary {\n-    \n+\n     // parameters for the GA\n-    private static final int DIMENSION = 50;    \n-    private static final int POPULATION_SIZE = 50; \n+    private static final int DIMENSION = 50;\n+    private static final int POPULATION_SIZE = 50;\n     private static final int NUM_GENERATIONS = 50;\n     private static final double ELITISM_RATE = 0.2;\n     private static final double CROSSOVER_RATE = 1;\n     @Test\n     public void test() {\n         // to test a stochastic algorithm is hard, so this will rather be an usage example\n-        \n+\n         // initialize a new genetic algorithm\n         GeneticAlgorithm ga = new GeneticAlgorithm(\n                 new OnePointCrossover<Integer>(),\n                 MUTATION_RATE,\n                 new TournamentSelection(TOURNAMENT_ARITY)\n         );\n-        \n+\n         // initial population\n         Population initial = randomPopulation();\n         // stopping conditions\n         StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);\n-        \n+\n         // best initial chromosome\n         Chromosome bestInitial = initial.getFittestChromosome();\n-        \n+\n         // run the algorithm\n         Population finalPopulation = ga.evolve(initial, stopCond);\n-        \n+\n         // best chromosome from the final population\n         Chromosome bestFinal = finalPopulation.getFittestChromosome();\n-        \n+\n         // the only thing we can test is whether the final solution is not worse than the initial one\n         // however, for some implementations of GA, this need not be true :)\n-        \n+\n         assertTrue(bestFinal.compareTo(bestInitial) > 0);\n-        \n+\n         //System.out.println(bestInitial);\n         //System.out.println(bestFinal);\n     }\n-    \n-    \n-    \n-    \n+\n+\n+\n+\n     /**\n      * Initializes a random population.\n      */\n     private static ElitisticListPopulation randomPopulation() {\n         List<Chromosome> popList = new LinkedList<Chromosome>();\n-        \n+\n         for (int i=0; i<POPULATION_SIZE; i++) {\n             BinaryChromosome randChrom = new FindOnes(BinaryChromosome.randomBinaryRepresentation(DIMENSION));\n             popList.add(randChrom);\n-        }        \n+        }\n         return new ElitisticListPopulation(popList, popList.size(), ELITISM_RATE);\n     }\n-    \n+\n     /**\n      * Chromosomes represented by a binary chromosome.\n-     * \n+     *\n      * The goal is to set all bits (genes) to 1.\n      */\n     private static class FindOnes extends BinaryChromosome {\n--- a/src/test/java/org/apache/commons/math/genetics/GeneticAlgorithmTestPermutations.java\n+++ b/src/test/java/org/apache/commons/math/genetics/GeneticAlgorithmTestPermutations.java\n \n /**\n  * This is also an example of usage.\n- * \n+ *\n  * This algorithm does \"stochastic sorting\" of a sequence 0,...,N.\n- * \n+ *\n  */\n public class GeneticAlgorithmTestPermutations {\n-    \n+\n     // parameters for the GA\n-    private static final int DIMENSION = 20;    \n-    private static final int POPULATION_SIZE = 80; \n+    private static final int DIMENSION = 20;\n+    private static final int POPULATION_SIZE = 80;\n     private static final int NUM_GENERATIONS = 200;\n     private static final double ELITISM_RATE = 0.2;\n     private static final double CROSSOVER_RATE = 1;\n     private static final double MUTATION_RATE = 0.08;\n     private static final int TOURNAMENT_ARITY = 2;\n-    \n+\n     // numbers from 0 to N-1\n     private static List<Integer> sequence = new ArrayList<Integer>();\n     static {\n     @Test\n     public void test() {\n         // to test a stochastic algorithm is hard, so this will rather be an usage example\n-        \n+\n         // initialize a new genetic algorithm\n         GeneticAlgorithm ga = new GeneticAlgorithm(\n                 new OnePointCrossover<Integer>(),\n                 MUTATION_RATE,\n                 new TournamentSelection(TOURNAMENT_ARITY)\n         );\n-        \n+\n         // initial population\n         Population initial = randomPopulation();\n         // stopping conditions\n         StoppingCondition stopCond = new FixedGenerationCount(NUM_GENERATIONS);\n-        \n+\n         // best initial chromosome\n         Chromosome bestInitial = initial.getFittestChromosome();\n-        \n+\n         // run the algorithm\n         Population finalPopulation = ga.evolve(initial, stopCond);\n-        \n+\n         // best chromosome from the final population\n         Chromosome bestFinal = finalPopulation.getFittestChromosome();\n-        \n+\n         // the only thing we can test is whether the final solution is not worse than the initial one\n         // however, for some implementations of GA, this need not be true :)\n-        \n+\n         assertTrue(bestFinal.compareTo(bestInitial) > 0);\n-        \n+\n         //System.out.println(bestInitial);\n         //System.out.println(bestFinal);\n     }\n-    \n-    \n+\n+\n     /**\n      * Initializes a random population\n      */\n         }\n         return new ElitisticListPopulation(popList, popList.size(), ELITISM_RATE);\n     }\n-    \n+\n     /**\n      * Chromosomes representing a permutation of (0,1,2,...,DIMENSION-1).\n-     * \n+     *\n      * The goal is to sort the sequence.\n      */\n     private static class MinPermutations extends RandomKey<Integer> {\n             }\n             // the most fitted chromosome is the one with minimal error\n             // therefore we must return negative value\n-            return -res; \n+            return -res;\n         }\n \n         @Override\n--- a/src/test/java/org/apache/commons/math/genetics/ListPopulationTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/ListPopulationTest.java\n     @Test\n     public void testGetFittestChromosome() {\n         Chromosome c1 = new Chromosome() {\n-            public double fitness() {                \n+            public double fitness() {\n                 return 0;\n             }\n         };\n         Chromosome c2 = new Chromosome() {\n-            public double fitness() {                \n+            public double fitness() {\n                 return 10;\n             }\n         };\n         Chromosome c3 = new Chromosome() {\n-            public double fitness() {                \n+            public double fitness() {\n                 return 15;\n             }\n         };\n-        \n+\n         ArrayList<Chromosome> chromosomes = new ArrayList<Chromosome> ();\n         chromosomes.add(c1);\n         chromosomes.add(c2);\n         chromosomes.add(c3);\n-        \n+\n         ListPopulation population = new ListPopulation(chromosomes,10) {\n \n             public Population nextGeneration() {\n                 return null;\n             }\n         };\n-        \n+\n         assertEquals(c3, population.getFittestChromosome());\n     }\n \n--- a/src/test/java/org/apache/commons/math/genetics/OnePointCrossoverTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/OnePointCrossoverTest.java\n     public void testCrossover() {\n         Integer[] p1 = new Integer[] {1,0,1,0,0,1,0,1,1};\n         Integer[] p2 = new Integer[] {0,1,1,0,1,0,1,1,1};\n-        \n+\n         BinaryChromosome p1c = new DummyBinaryChromosome(p1);\n         BinaryChromosome p2c = new DummyBinaryChromosome(p2);\n-        \n+\n         OnePointCrossover<Integer> opc = new OnePointCrossover<Integer>();\n-        \n+\n         // how to test a stochastic method?\n         for (int i=0; i<20; i++) {\n             ChromosomePair pair = opc.crossover(p1c,p2c);\n-            \n+\n             Integer[] c1 = new Integer[p1.length];\n             Integer[] c2 = new Integer[p2.length];\n-            \n+\n             c1 = ((BinaryChromosome) pair.getFirst()).getRepresentation().toArray(c1);\n             c2 = ((BinaryChromosome) pair.getSecond()).getRepresentation().toArray(c2);\n-            \n+\n             // first and last values will be the same\n             assertEquals((int) p1[0], (int) c1[0]);\n             assertEquals((int) p2[0], (int) c2[0]);\n--- a/src/test/java/org/apache/commons/math/genetics/RandomKeyMutationTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/RandomKeyMutationTest.java\n             DummyRandomKey origRk = new DummyRandomKey(RandomKey.randomPermutation(l));\n             Chromosome mutated = mutation.mutate(origRk);\n             DummyRandomKey mutatedRk = (DummyRandomKey) mutated;\n-            \n+\n             int changes = 0;\n             for (int j=0; j<origRk.getLength(); j++) {\n                 if (origRk.getRepresentation().get(j) != mutatedRk.getRepresentation().get(j)) {\n--- a/src/test/java/org/apache/commons/math/genetics/RandomKeyTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/RandomKeyTest.java\n     public void testConstructor1() {\n         new DummyRandomKey(new Double[] {0.2, 0.3, 1.2});\n     }\n-    \n+\n     @Test(expected=IllegalArgumentException.class)\n     public void testConstructor2() {\n         new DummyRandomKey(new Double[] {0.2, 0.3, -0.2});\n         DummyRandomKey drk3 = new DummyRandomKey(new Double[] {0.4, 0.15, 0.5, 0.8, 0.2});\n         DummyRandomKey drk4 = new DummyRandomKey(new Double[] {0.4, 0.25, 0.5, 0.8, 0.2});\n         DummyRandomKey drk5 = new DummyRandomKey(new Double[] {0.4, 0.25, 0.5, 0.8, 0.2, 0.5});\n-        \n+\n         assertTrue(drk1.isSame(drk2));\n         assertTrue(drk2.isSame(drk3));\n         assertFalse(drk3.isSame(drk4));\n     public void testDecode() {\n         DummyRandomKey drk = new DummyRandomKey(new Double[] {0.4, 0.1, 0.5, 0.8, 0.2});\n         List<String> decoded = drk.decode(Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"}));\n-        \n+\n         assertEquals(\"b\", decoded.get(0));\n         assertEquals(\"e\", decoded.get(1));\n         assertEquals(\"a\", decoded.get(2));\n     public void testIdentityPermutation() {\n         DummyRandomKey drk = new DummyRandomKey(RandomKey.identityPermutation(5));\n         List<String> decoded = drk.decode(Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"e\"}));\n-        \n+\n         assertEquals(\"a\", decoded.get(0));\n         assertEquals(\"b\", decoded.get(1));\n         assertEquals(\"c\", decoded.get(2));\n     @Test\n     public void testComparatorPermutation() {\n         List<String> data = Arrays.asList(new String[] {\"x\", \"b\", \"c\", \"z\", \"b\"});\n-        \n+\n         List<Double> permutation = RandomKey.comparatorPermutation(data, new Comparator<String>() {\n             public int compare(String o1, String o2) {\n                 return o1.compareTo(o2);\n         assertEquals(\"c\", decodedData.get(2));\n         assertEquals(\"x\", decodedData.get(3));\n         assertEquals(\"z\", decodedData.get(4));\n-        \n+\n         permutation = RandomKey.comparatorPermutation(data, new Comparator<String>() {\n             public int compare(String o1, String o2) {\n                 return o2.compareTo(o1);\n         assertEquals(\"b\", decodedData.get(3));\n         assertEquals(\"b\", decodedData.get(4));\n     }\n-    \n+\n     @Test\n     public void testInducedPermutation() {\n         List<String> origData = Arrays.asList(new String[] {\"a\", \"b\", \"c\", \"d\", \"d\"});\n         List<String> permutedData = Arrays.asList(new String[] {\"d\", \"b\", \"c\", \"a\", \"d\"});\n-        \n+\n         DummyRandomKey drk = new DummyRandomKey(RandomKey.inducedPermutation(origData, permutedData));\n         List<String> decoded = drk.decode(origData);\n-        \n+\n         assertEquals(\"d\", decoded.get(0));\n         assertEquals(\"b\", decoded.get(1));\n         assertEquals(\"c\", decoded.get(2));\n         assertEquals(\"b\", decodedData.get(1));\n         assertEquals(\"c\", decodedData.get(2));\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/math/genetics/TournamentSelectionTest.java\n+++ b/src/test/java/org/apache/commons/math/genetics/TournamentSelectionTest.java\n import org.junit.Test;\n \n public class TournamentSelectionTest {\n-    \n+\n     private static int counter = 0;\n \n     @Test\n     public void testSelect() {\n         TournamentSelection ts = new TournamentSelection(2);\n         ElitisticListPopulation pop = new ElitisticListPopulation(100, 0.203);\n-        \n+\n         for (int i=0; i<pop.getPopulationLimit(); i++) {\n             pop.addChromosome(new DummyChromosome());\n         }\n             assertTrue(pair.getSecond().getFitness() > 0);\n         }\n     }\n-    \n+\n     private static class DummyChromosome extends Chromosome {\n         private final int fitness;\n-        \n+\n         public DummyChromosome() {\n             this.fitness = counter;\n             counter++;\n         }\n-        \n-        public double fitness() {            \n+\n+        public double fitness() {\n             return this.fitness;\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/geometry/FrenchVector3DFormatTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/FrenchVector3DFormatTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/test/java/org/apache/commons/math/geometry/Vector3DFormatAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/Vector3DFormatAbstractTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n import org.apache.commons.math.util.CompositeFormat;\n \n public abstract class Vector3DFormatAbstractTest extends TestCase {\n- \n+\n     Vector3DFormat vector3DFormat = null;\n     Vector3DFormat vector3DFormatSquare = null;\n \n         nf.setMaximumFractionDigits(2);\n         vector3DFormatSquare = new Vector3DFormat(\"[\", \"]\", \" : \", nf);\n     }\n-   \n+\n     public void testSimpleNoDecimals() {\n         Vector3D c = new Vector3D(1, 1, 1);\n         String expected = \"{1; 1; 1}\";\n-        String actual = vector3DFormat.format(c); \n+        String actual = vector3DFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n             \"23; 1\" + getDecimalCharacter() +\n             \"43; 1\" + getDecimalCharacter() +\n             \"63}\";\n-        String actual = vector3DFormat.format(c); \n+        String actual = vector3DFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n             \"23; 1\" + getDecimalCharacter() +\n             \"43; 1\" + getDecimalCharacter() +\n             \"63}\";\n-        String actual = vector3DFormat.format(c); \n+        String actual = vector3DFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n             \"23; 1\" + getDecimalCharacter() +\n             \"43; 1\" + getDecimalCharacter() +\n             \"63}\";\n-        String actual = vector3DFormat.format(c); \n+        String actual = vector3DFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n             \"23; -1\" + getDecimalCharacter() +\n             \"43; 1\" + getDecimalCharacter() +\n             \"63}\";\n-        String actual = vector3DFormat.format(c); \n+        String actual = vector3DFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n             \"23; 1\" + getDecimalCharacter() +\n             \"43; -1\" + getDecimalCharacter() +\n             \"63}\";\n-        String actual = vector3DFormat.format(c); \n+        String actual = vector3DFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n     public void testNonDefaultSetting() {\n         Vector3D c = new Vector3D(1, 1, 1);\n         String expected = \"[1 : 1 : 1]\";\n-        String actual = vector3DFormatSquare.format(c); \n-        assertEquals(expected, actual);\n-    }\n-    \n+        String actual = vector3DFormatSquare.format(c);\n+        assertEquals(expected, actual);\n+    }\n+\n     public void testStaticFormatVector3D() {\n         Locale defaultLocal = Locale.getDefault();\n         Locale.setDefault(getLocale());\n-        \n+\n         Vector3D c = new Vector3D(232.222, -342.33, 432.444);\n         String expected =\n             \"{232\"    + getDecimalCharacter() +\n             \"22; -342\" + getDecimalCharacter() +\n             \"33; 432\" + getDecimalCharacter() +\n             \"44}\";\n-        String actual = Vector3DFormat.formatVector3D(c); \n-        assertEquals(expected, actual);\n-        \n+        String actual = Vector3DFormat.formatVector3D(c);\n+        assertEquals(expected, actual);\n+\n         Locale.setDefault(defaultLocal);\n     }\n \n     public void testNan() {\n         Vector3D c = Vector3D.NaN;\n         String expected = \"{(NaN); (NaN); (NaN)}\";\n-        String actual = vector3DFormat.format(c); \n+        String actual = vector3DFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n     public void testPositiveInfinity() {\n         Vector3D c = Vector3D.POSITIVE_INFINITY;\n         String expected = \"{(Infinity); (Infinity); (Infinity)}\";\n-        String actual = vector3DFormat.format(c); \n+        String actual = vector3DFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n     public void tesNegativeInfinity() {\n         Vector3D c = Vector3D.NEGATIVE_INFINITY;\n         String expected = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n-        String actual = vector3DFormat.format(c); \n+        String actual = vector3DFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n         String source = \"{1; 1; 1}\";\n         Vector3D expected = new Vector3D(1, 1, 1);\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"63}\";\n         Vector3D expected = new Vector3D(1.23, 1.43, 1.63);\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"6333}\";\n         Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"6333}\";\n         Vector3D expected = new Vector3D(-1.2323, 1.4343, 1.6333);\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"6333}\";\n         Vector3D expected = new Vector3D(1.2323, -1.4343, 1.6333);\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"6333}\";\n         Vector3D expected = new Vector3D(1.2323, 1.4343, -1.6333);\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"6333}\";\n         Vector3D expected = new Vector3D(-1.2323, -1.4343, -1.6333);\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"6333}\";\n         Vector3D expected = new Vector3D(0.0, -1.4343, 1.6333);\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"6333]\";\n         Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormatSquare.parseObject(source); \n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-    \n+            Vector3D actual = (Vector3D) vector3DFormatSquare.parseObject(source);\n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n     public void testParseNan() {\n         String source = \"{(NaN); (NaN); (NaN)}\";\n         try {\n-            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source);\n             assertEquals(Vector3D.NaN, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n     public void testParsePositiveInfinity() {\n         String source = \"{(Infinity); (Infinity); (Infinity)}\";\n         try {\n-            Vector3D actual = (Vector3D)vector3DFormat.parseObject(source); \n+            Vector3D actual = (Vector3D)vector3DFormat.parseObject(source);\n             assertEquals(Vector3D.POSITIVE_INFINITY, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n     public void testParseNegativeInfinity() {\n         String source = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n         try {\n-            Vector3D actual = (Vector3D)vector3DFormat.parseObject(source); \n+            Vector3D actual = (Vector3D)vector3DFormat.parseObject(source);\n             assertEquals(Vector3D.NEGATIVE_INFINITY, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n         assertNotNull(cf);\n         assertEquals(nf, cf.getFormat());\n     }\n-    \n+\n     public void testFormatObject() {\n         try {\n             CompositeFormat cf = new Vector3DFormat();\n--- a/src/test/java/org/apache/commons/math/geometry/Vector3DFormatTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/Vector3DFormatTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/test/java/org/apache/commons/math/geometry/Vector3DTest.java\n+++ b/src/test/java/org/apache/commons/math/geometry/Vector3DTest.java\n     assertTrue(Math.abs(v.getY() - 2) < 1.0e-12);\n     assertTrue(Math.abs(v.getZ() - 3) < 1.0e-12);\n   }\n-  \n+\n   public void testNorm1() {\n     assertEquals(0.0, Vector3D.ZERO.getNorm1());\n     assertEquals(6.0, new Vector3D(1, -2, 3).getNorm1(), 0);\n   }\n \n   public void testAngle() {\n-     assertEquals(0.22572612855273393616, \n+     assertEquals(0.22572612855273393616,\n                   Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(4, 5, 6)),\n                   1.0e-12);\n-     assertEquals(7.98595620686106654517199e-8, \n+     assertEquals(7.98595620686106654517199e-8,\n                   Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(2, 4, 6.000001)),\n                   1.0e-12);\n-     assertEquals(3.14159257373023116985197793156, \n+     assertEquals(3.14159257373023116985197793156,\n                   Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(-2, -4, -6.000001)),\n                   1.0e-12);\n      try {\n       assertEquals(y, v.getY(), 1.0e-12);\n       assertEquals(z, v.getZ(), 1.0e-12);\n   }\n-  \n+\n   public static Test suite() {\n     return new TestSuite(Vector3DTest.class);\n   }\n--- a/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  */\n \n public final class Array2DRowRealMatrixTest extends TestCase {\n-    \n+\n     // 3 x 3 identity matrix\n     protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };\n-    \n+\n     // Test data for group operations\n     protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };\n     protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};\n     protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };\n-    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, \n+    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},\n        {-1d,0d,-8d} };\n     protected double[] testDataRow1 = {1d,2d,3d};\n     protected double[] testDataCol3 = {3d,3d,8d};\n-    protected double[][] testDataInv = \n+    protected double[][] testDataInv =\n         { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };\n     protected double[] preMultTest = {8,12,33};\n     protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};\n     protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};\n-    protected double[][] testDataPlusInv = \n+    protected double[][] testDataPlusInv =\n         { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };\n-    \n+\n     // lu decomposition tests\n     protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };\n     protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},\n             {0.33333333333333,0d,0.33333333333333} };\n-    \n+\n     // singular matrices\n     protected double[][] singular = { {2d,3d}, {2d,3d} };\n     protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},\n         {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd\n     protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };\n     protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};\n-    \n+\n     // vectors\n     protected double[] testVector = {1,2,3};\n     protected double[] testVector2 = {1,2,3,4};\n-    \n+\n     // submatrix accessor tests\n     protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},\n-            {2, 4, 6, 8}, {4, 5, 6, 7}}; \n+            {2, 4, 6, 8}, {4, 5, 6, 7}};\n     // array selections\n     protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};\n     protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};\n     // column matrices\n     protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};\n     protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};\n-    \n+\n     // tolerances\n     protected double entryTolerance = 10E-16;\n     protected double normTolerance = 10E-14;\n-    \n+\n     public Array2DRowRealMatrixTest(String name) {\n         super(name);\n     }\n-    \n+\n     public static Test suite() {\n         TestSuite suite = new TestSuite(Array2DRowRealMatrixTest.class);\n         suite.setName(\"Array2DRowRealMatrix Tests\");\n         return suite;\n     }\n-    \n+\n     /** test dimensions */\n     public void testDimensions() {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n         assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n         assertTrue(\"testData2 is not square\",!m2.isSquare());\n-    } \n-    \n+    }\n+\n     /** test copy functions */\n     public void testCopyFunctions() {\n         Array2DRowRealMatrix m1 = new Array2DRowRealMatrix(testData);\n         Array2DRowRealMatrix m3 = new Array2DRowRealMatrix(testData);\n         Array2DRowRealMatrix m4 = new Array2DRowRealMatrix(m3.getData(), false);\n         assertEquals(m4,m3);\n-    }           \n-    \n+    }\n+\n     /** test add */\n     public void testAdd() {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n                     testDataPlusInv[row][col],sumEntries[row][col],\n                         entryTolerance);\n             }\n-        }    \n-    }\n-    \n+        }\n+    }\n+\n     /** test add failure */\n     public void testAddFail() {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n             // ignored\n         }\n     }\n-    \n+\n     /** test norm */\n     public void testNorm() {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         assertEquals(\"testData norm\",14d,m.getNorm(),entryTolerance);\n         assertEquals(\"testData2 norm\",7d,m2.getNorm(),entryTolerance);\n     }\n-    \n+\n     /** test Frobenius norm */\n     public void testFrobeniusNorm() {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         assertEquals(\"testData Frobenius norm\", Math.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n         assertEquals(\"testData2 Frobenius norm\", Math.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n     }\n-    \n+\n      /** test m-n = m + -n */\n     public void testPlusMinus() {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         Array2DRowRealMatrix m2 = new Array2DRowRealMatrix(testDataInv);\n         TestUtils.assertEquals(\"m-n = m + -n\",m.subtract(m2),\n-            m2.scalarMultiply(-1d).add(m),entryTolerance);        \n+            m2.scalarMultiply(-1d).add(m),entryTolerance);\n         try {\n             m.subtract(new Array2DRowRealMatrix(testData2));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n-    }\n-   \n+        }\n+    }\n+\n     /** test multiply */\n      public void testMultiply() {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         TestUtils.assertEquals(\"identity multiply\",identity.multiply(mInv),\n             mInv,entryTolerance);\n         TestUtils.assertEquals(\"identity multiply\",m2.multiply(identity),\n-            m2,entryTolerance); \n+            m2,entryTolerance);\n         try {\n             m.multiply(new Array2DRowRealMatrix(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n-    }   \n-    \n+        }\n+    }\n+\n     //Additional Test for Array2DRowRealMatrixTest.testMultiply\n \n     private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};\n     private double[][] d4 = new double[][] {{1},{2},{3},{4}};\n     private double[][] d5 = new double[][] {{30},{70}};\n-     \n-    public void testMultiply2() { \n-       RealMatrix m3 = new Array2DRowRealMatrix(d3);   \n+\n+    public void testMultiply2() {\n+       RealMatrix m3 = new Array2DRowRealMatrix(d3);\n        RealMatrix m4 = new Array2DRowRealMatrix(d4);\n        RealMatrix m5 = new Array2DRowRealMatrix(d5);\n        TestUtils.assertEquals(\"m3*m4=m5\", m3.multiply(m4), m5, entryTolerance);\n-   }  \n-        \n+   }\n+\n     /** test trace */\n     public void testTrace() {\n         RealMatrix m = new Array2DRowRealMatrix(id);\n             fail(\"Expecting NonSquareMatrixException\");\n         } catch (NonSquareMatrixException ex) {\n             // ignored\n-        }      \n-    }\n-    \n+        }\n+    }\n+\n     /** test sclarAdd */\n     public void testScalarAdd() {\n         RealMatrix m = new Array2DRowRealMatrix(testData);\n         TestUtils.assertEquals(\"scalar add\",new Array2DRowRealMatrix(testDataPlus2),\n             m.scalarAdd(2d),entryTolerance);\n     }\n-                    \n+\n     /** test operate */\n     public void testOperate() {\n         RealMatrix m = new Array2DRowRealMatrix(id);\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n+        }\n     }\n \n     /** test issue MATH-209 */\n         assertEquals( 7.0, b[1], 1.0e-12);\n         assertEquals(11.0, b[2], 1.0e-12);\n     }\n-    \n+\n     /** test transpose */\n     public void testTranspose() {\n-        RealMatrix m = new Array2DRowRealMatrix(testData); \n+        RealMatrix m = new Array2DRowRealMatrix(testData);\n         RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();\n         RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();\n         TestUtils.assertEquals(\"inverse-transpose\", mIT, mTI, normTolerance);\n         RealMatrix mt = new Array2DRowRealMatrix(testData2T);\n         TestUtils.assertEquals(\"transpose\",mt,m.transpose(),normTolerance);\n     }\n-    \n+\n     /** test preMultiply by vector */\n     public void testPremultiplyVector() {\n         RealMatrix m = new Array2DRowRealMatrix(testData);\n             // ignored\n         }\n     }\n-    \n+\n     public void testPremultiply() {\n-        RealMatrix m3 = new Array2DRowRealMatrix(d3);   \n+        RealMatrix m3 = new Array2DRowRealMatrix(d3);\n         RealMatrix m4 = new Array2DRowRealMatrix(d4);\n         RealMatrix m5 = new Array2DRowRealMatrix(d5);\n         TestUtils.assertEquals(\"m3*m4=m5\", m4.preMultiply(m3), m5, entryTolerance);\n-        \n+\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         Array2DRowRealMatrix mInv = new Array2DRowRealMatrix(testDataInv);\n         Array2DRowRealMatrix identity = new Array2DRowRealMatrix(id);\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n-    }\n-    \n+        }\n+    }\n+\n     public void testGetVectors() {\n         RealMatrix m = new Array2DRowRealMatrix(testData);\n         TestUtils.assertEquals(\"get row\",m.getRow(0),testDataRow1,entryTolerance);\n             // ignored\n         }\n     }\n-    \n+\n     public void testGetEntry() {\n         RealMatrix m = new Array2DRowRealMatrix(testData);\n         assertEquals(\"get entry\",m.getEntry(0,1),2d,entryTolerance);\n             // expected\n         }\n     }\n-        \n+\n     /** test examples in user guide */\n     public void testExamples() {\n         // Create a real matrix with two rows and three columns\n         assertEquals(2, p.getRowDimension());\n         assertEquals(2, p.getColumnDimension());\n         // Invert p\n-        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse(); \n+        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();\n         assertEquals(2, pInverse.getRowDimension());\n         assertEquals(2, pInverse.getColumnDimension());\n-        \n+\n         // Solve example\n         double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};\n         RealMatrix coefficients = new Array2DRowRealMatrix(coefficientsData);\n         double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);\n         assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);\n         assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);\n-        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);   \n-        \n-    }\n-    \n+        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);\n+\n+    }\n+\n     // test submatrix accessors\n     public void testGetSubMatrix() {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n         checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n-        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n-        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n-        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n-        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n-        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n-        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n-        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);\n+        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);\n+        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);\n+        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);\n+        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);\n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);\n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);\n         checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n         checkGetSubMatrix(m, null, -1, 1, 2, 2, true);\n         checkGetSubMatrix(m, null,  1, 0, 2, 2, true);\n             }\n         }\n     }\n-    \n+\n     private void checkGetSubMatrix(RealMatrix m, double[][] reference,\n                                    int[] selectedRows, int[] selectedColumns,\n                                    boolean mustFail) {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n         checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n-        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n-        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n-        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n-        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n-        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n-        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n-        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n-        \n+        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);\n+        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);\n+        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);\n+        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);\n+        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);\n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);\n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);\n+\n         checkCopy(m, null,  1, 0, 2, 4, true);\n         checkCopy(m, null, -1, 1, 2, 2, true);\n         checkCopy(m, null,  1, 0, 2, 2, true);\n             }\n         }\n     }\n-    \n+\n     private void checkCopy(RealMatrix m, double[][] reference,\n                            int[] selectedRows, int[] selectedColumns,\n                            boolean mustFail) {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         RealMatrix mRow0 = new Array2DRowRealMatrix(subRow0);\n         RealMatrix mRow3 = new Array2DRowRealMatrix(subRow3);\n-        assertEquals(\"Row0\", mRow0, \n+        assertEquals(\"Row0\", mRow0,\n                 m.getRowMatrix(0));\n-        assertEquals(\"Row3\", mRow3, \n+        assertEquals(\"Row3\", mRow3,\n                 m.getRowMatrix(3));\n         try {\n             m.getRowMatrix(-1);\n             // expected\n         }\n     }\n-    \n+\n     public void testSetRowMatrix() {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         RealMatrix mRow3 = new Array2DRowRealMatrix(subRow3);\n             // expected\n         }\n     }\n-    \n+\n     public void testGetColumnMatrix() {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         RealMatrix mColumn1 = new Array2DRowRealMatrix(subColumn1);\n         RealMatrix mColumn3 = new Array2DRowRealMatrix(subColumn3);\n-        assertEquals(\"Column1\", mColumn1, \n+        assertEquals(\"Column1\", mColumn1,\n                 m.getColumnMatrix(1));\n-        assertEquals(\"Column3\", mColumn3, \n+        assertEquals(\"Column3\", mColumn3,\n                 m.getColumnMatrix(3));\n         try {\n             m.getColumnMatrix(-1);\n             // expected\n         }\n     }\n-    \n+\n     public void testGetColumnVector() {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         RealVector mColumn1 = columnToVector(subColumn1);\n             // expected\n         }\n     }\n-    \n+\n     public void testGetColumn() {\n         RealMatrix m = new Array2DRowRealMatrix(subTestData);\n         double[] mColumn1 = columnToArray(subColumn1);\n     private void checkArrays(double[] expected, double[] actual) {\n         assertEquals(expected.length, actual.length);\n         for (int i = 0; i < expected.length; ++i) {\n-            assertEquals(expected[i], actual[i]);            \n-        }\n-    }\n-    \n+            assertEquals(expected[i], actual[i]);\n+        }\n+    }\n+\n     public void testEqualsAndHashCode() {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         Array2DRowRealMatrix m1 = (Array2DRowRealMatrix) m.copy();\n         assertEquals(m, m1);\n         assertFalse(m.equals(null));\n         assertFalse(m.equals(mt));\n-        assertFalse(m.equals(new Array2DRowRealMatrix(bigSingular))); \n-    }\n-    \n+        assertFalse(m.equals(new Array2DRowRealMatrix(bigSingular)));\n+    }\n+\n     public void testToString() {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         assertEquals(\"Array2DRowRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n         assertEquals(\"Array2DRowRealMatrix{}\",\n                 m.toString());\n     }\n-    \n+\n     public void testSetSubMatrix() throws Exception {\n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         m.setSubMatrix(detData2,1,1);\n         RealMatrix expected = MatrixUtils.createRealMatrix\n             (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});\n-        assertEquals(expected, m);  \n-        \n+        assertEquals(expected, m);\n+\n         m.setSubMatrix(detData2,0,0);\n         expected = MatrixUtils.createRealMatrix\n             (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});\n-        assertEquals(expected, m);  \n-        \n-        m.setSubMatrix(testDataPlus2,0,0);      \n+        assertEquals(expected, m);\n+\n+        m.setSubMatrix(testDataPlus2,0,0);\n         expected = MatrixUtils.createRealMatrix\n             (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});\n-        assertEquals(expected, m);   \n-        \n+        assertEquals(expected, m);\n+\n         // dimension overflow\n-        try {  \n+        try {\n             m.setSubMatrix(testData,1,1);\n             fail(\"expecting MatrixIndexException\");\n         } catch (MatrixIndexException e) {\n             // expected\n         }\n         // dimension underflow\n-        try {  \n+        try {\n             m.setSubMatrix(testData,-1,1);\n             fail(\"expecting MatrixIndexException\");\n         } catch (MatrixIndexException e) {\n             // expected\n         }\n-        try {  \n+        try {\n             m.setSubMatrix(testData,1,-1);\n             fail(\"expecting MatrixIndexException\");\n         } catch (MatrixIndexException e) {\n             // expected\n         }\n-        \n+\n         // null\n         try {\n             m.setSubMatrix(null,1,1);\n         } catch (IllegalStateException e) {\n             // expected\n         }\n-        \n+\n         // ragged\n         try {\n             m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-       \n+\n         // empty\n         try {\n             m.setSubMatrix(new double[][] {{}}, 0, 0);\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n     }\n \n     public void testWalk() {\n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, 0), 0);\n             assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(0, j), 0);\n             assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, 0), 0);\n             assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(0, j), 0);\n             assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n         m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, 0), 0);\n             assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(0, j), 0);\n             assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n         m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, 0), 0);\n             assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(0, j), 0);\n             assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n         Array2DRowRealMatrix m = new Array2DRowRealMatrix(testData);\n         assertEquals(m,TestUtils.serializeAndRecover(m));\n     }\n-    \n-    \n+\n+\n     private static class SetVisitor extends DefaultRealMatrixChangingVisitor {\n         @Override\n         public double visit(int i, int j, double value) {\n     }\n \n     //--------------- -----------------Protected methods\n-    \n+\n     /** extracts the l  and u matrices from compact lu representation */\n-    protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) throws InvalidMatrixException {   \n+    protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) throws InvalidMatrixException {\n         if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||\n                 lowerData.length != upperData.length\n                 || lowerData.length != lu.getRowDimension()) {\n             throw new InvalidMatrixException(\"incorrect dimensions\");\n-        }    \n+        }\n         int n = lu.getRowDimension();\n         for (int i = 0; i < n; i++) {\n             for (int j = 0; j < n; j++) {\n                 } else {\n                     lowerData[i][j] = 0d;\n                     upperData[i][j] = lu.getEntry(i, j);\n-                }   \n+                }\n             }\n         }\n     }\n-    \n+\n     /** Returns the result of applying the given row permutation to the matrix */\n     protected RealMatrix permuteRows(RealMatrix matrix, int[] permutation) {\n         if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {\n         }\n         return new Array2DRowRealMatrix(out);\n     }\n-    \n+\n //    /** Useful for debugging */\n //    private void dumpMatrix(RealMatrix m) {\n //          for (int i = 0; i < m.getRowDimension(); i++) {\n //              System.out.println(os);\n //          }\n //    }\n-        \n+\n }\n \n--- a/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayFieldVectorTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  */\n public class ArrayFieldVectorTest extends TestCase {\n \n-    // \n+    //\n     protected Fraction[][] ma1 = {\n             {new Fraction(1), new Fraction(2), new Fraction(3)},\n             {new Fraction(4), new Fraction(5), new Fraction(6)},\n             {new Fraction(7), new Fraction(8), new Fraction(9)}\n     };\n \n-    // Testclass to test the FieldVector<Fraction> interface \n+    // Testclass to test the FieldVector<Fraction> interface\n     // only with enough content to support the test\n     public static class FieldVectorTestImpl<T extends FieldElement<T>>\n         implements FieldVector<T>, Serializable {\n         ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);\n         ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(vec2);\n         ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4);\n-        FieldVectorTestImpl<Fraction> v2_t = new FieldVectorTestImpl<Fraction>(vec2); \n+        FieldVectorTestImpl<Fraction> v2_t = new FieldVectorTestImpl<Fraction>(vec2);\n \n         FieldVector<Fraction> v_append_1 = v1.append(v2);\n         assertEquals(6, v_append_1.getDimension());\n         }\n \n \n-        ArrayFieldVector<Fraction> vout10 = (ArrayFieldVector<Fraction>) v1.copy();       \n+        ArrayFieldVector<Fraction> vout10 = (ArrayFieldVector<Fraction>) v1.copy();\n         ArrayFieldVector<Fraction> vout10_2 = (ArrayFieldVector<Fraction>) v1.copy();\n         assertEquals(vout10, vout10_2);\n         vout10_2.setEntry(0, new Fraction(11, 10));\n \n     }\n \n-    public void testMapFunctions() { \n+    public void testMapFunctions() {\n         ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);\n \n         //octave =  v1 .+ 2.0\n \n     }\n \n-    public void testBasicFunctions() { \n+    public void testBasicFunctions() {\n         ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);\n         ArrayFieldVector<Fraction> v2 = new ArrayFieldVector<Fraction>(vec2);\n         new ArrayFieldVector<Fraction>(vec_null);\n \n-        FieldVectorTestImpl<Fraction> v2_t = new FieldVectorTestImpl<Fraction>(vec2); \n+        FieldVectorTestImpl<Fraction> v2_t = new FieldVectorTestImpl<Fraction>(vec2);\n \n         //octave =  v1 + v2\n         ArrayFieldVector<Fraction> v_add = v1.add(v2);\n         Fraction[] result_projection_2 = {new Fraction(128, 77), new Fraction(160, 77), new Fraction(192, 77)};\n         checkArray(\"compare vect\", v_projection_2.getData(), result_projection_2);\n \n-    }  \n-\n-    public void testMisc() { \n+    }\n+\n+    public void testMisc() {\n         ArrayFieldVector<Fraction> v1 = new ArrayFieldVector<Fraction>(vec1);\n         ArrayFieldVector<Fraction> v4 = new ArrayFieldVector<Fraction>(vec4);\n         FieldVector<Fraction> v4_2 = new ArrayFieldVector<Fraction>(vec4);\n \n         String out1 = v1.toString();\n         assertTrue(\"some output \",  out1.length()!=0);\n-        /*    \n+        /*\n          Fraction[] dout1 = v1.copyOut();\n         assertEquals(3, dout1.length);\n-        assertNotSame(\"testData not same object \", v1.data, dout1);   \n-         */      \n-        try {\n-            v1.checkVectorDimensions(2); \n+        assertNotSame(\"testData not same object \", v1.data, dout1);\n+         */\n+        try {\n+            v1.checkVectorDimensions(2);\n             fail(\"IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n-        } \n+        }\n \n        try {\n-            v1.checkVectorDimensions(v4); \n+            v1.checkVectorDimensions(v4);\n             fail(\"IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n-        }        \n-\n-        try {\n-            v1.checkVectorDimensions(v4_2); \n+        }\n+\n+        try {\n+            v1.checkVectorDimensions(v4_2);\n             fail(\"IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n-        }        \n+        }\n \n     }\n \n         ArrayFieldVector<Fraction> v = new ArrayFieldVector<Fraction>(vec1);\n         assertEquals(v,TestUtils.serializeAndRecover(v));\n     }\n-  \n+\n     /** verifies that two vectors are equals */\n     protected void checkArray(String msg, Fraction[] m, Fraction[] n) {\n         if (m.length != n.length) {\n--- a/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/ArrayRealVectorTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  */\n public class ArrayRealVectorTest extends TestCase {\n \n-    // \n+    //\n     protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};\n     protected double[] vec1 = {1d, 2d, 3d};\n     protected double[] vec2 = {4d, 5d, 6d};\n     protected double entryTolerance = 10E-16;\n     protected double normTolerance = 10E-14;\n \n-    // Testclass to test the RealVector interface \n+    // Testclass to test the RealVector interface\n     // only with enough content to support the test\n     public static class RealVectorTestImpl implements RealVector, Serializable {\n \n         ArrayRealVector v1 = new ArrayRealVector(vec1);\n         ArrayRealVector v2 = new ArrayRealVector(vec2);\n         ArrayRealVector v4 = new ArrayRealVector(vec4);\n-        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2); \n+        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2);\n \n         RealVector v_append_1 = v1.append(v2);\n         assertEquals(\"testData len\", 6, v_append_1.getDimension());\n         }\n \n \n-        ArrayRealVector vout10 = (ArrayRealVector) v1.copy();       \n+        ArrayRealVector vout10 = (ArrayRealVector) v1.copy();\n         ArrayRealVector vout10_2 = (ArrayRealVector) v1.copy();\n         assertEquals(vout10, vout10_2);\n         vout10_2.setEntry(0, 1.1);\n \n     }\n \n-    public void testMapFunctions() { \n+    public void testMapFunctions() {\n         ArrayRealVector v1 = new ArrayRealVector(vec1);\n \n         //octave =  v1 .+ 2.0\n \n         //octave =  asin(vat)\n         RealVector v_mapAsinToSelf = vat.copy();\n-        v_mapAsinToSelf.mapAsinToSelf();        \n+        v_mapAsinToSelf.mapAsinToSelf();\n         double[] result_mapAsinToSelf = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};\n         assertClose(\"compare vectors\" ,result_mapAsinToSelf,v_mapAsinToSelf.getData(),normTolerance);\n \n \n     }\n \n-    public void testBasicFunctions() { \n+    public void testBasicFunctions() {\n         ArrayRealVector v1 = new ArrayRealVector(vec1);\n         ArrayRealVector v2 = new ArrayRealVector(vec2);\n         ArrayRealVector v_null = new ArrayRealVector(vec_null);\n \n-        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2); \n+        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2);\n \n         //octave =  sqrt(sumsq(v1))\n         double d_getNorm = v1.getNorm();\n         assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n \n         RealVector v_unitVector = v1.unitVector();\n-        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm()); \n+        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());\n         assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n \n         try {\n         double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n         assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n \n-    }  \n-\n-    public void testMisc() { \n+    }\n+\n+    public void testMisc() {\n         ArrayRealVector v1 = new ArrayRealVector(vec1);\n         ArrayRealVector v4 = new ArrayRealVector(vec4);\n         RealVector v4_2 = new ArrayRealVector(vec4);\n \n         String out1 = v1.toString();\n         assertTrue(\"some output \",  out1.length()!=0);\n-        /*    \n+        /*\n          double[] dout1 = v1.copyOut();\n         assertEquals(\"testData len\", 3, dout1.length);\n-        assertNotSame(\"testData not same object \", v1.data, dout1);   \n-         */      \n+        assertNotSame(\"testData not same object \", v1.data, dout1);\n+         */\n         try {\n-            v1.checkVectorDimensions(2); \n+            v1.checkVectorDimensions(2);\n             fail(\"IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n-        } \n+        }\n \n        try {\n-            v1.checkVectorDimensions(v4); \n+            v1.checkVectorDimensions(v4);\n             fail(\"IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n-        }        \n+        }\n \n         try {\n-            v1.checkVectorDimensions(v4_2); \n+            v1.checkVectorDimensions(v4_2);\n             fail(\"IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n-        }        \n+        }\n \n     }\n \n         ArrayRealVector v = new ArrayRealVector(new double[] { 0, 1, 2 });\n         assertEquals(v,TestUtils.serializeAndRecover(v));\n     }\n-    \n-    \n+\n+\n     /** verifies that two vectors are close (sup norm) */\n     protected void assertClose(String msg, double[] m, double[] n,\n             double tolerance) {\n--- a/src/test/java/org/apache/commons/math/linear/BiDiagonalTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BiDiagonalTransformerTest.java\n     private void checkOrthogonal(RealMatrix m) {\n         RealMatrix mTm = m.transpose().multiply(m);\n         RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());\n-        assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-14);        \n+        assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-14);\n     }\n \n     public void testBBiDiagonal() {\n                 if (rows < cols) {\n                     if ((i < j) || (i > j + 1)) {\n                         assertEquals(0, m.getEntry(i, j), 1.0e-16);\n-                    }                    \n+                    }\n                 } else {\n                     if ((i < j - 1) || (i > j)) {\n                         assertEquals(0, m.getEntry(i, j), 1.0e-16);\n         assertTrue(u == transformer.getU());\n         assertTrue(b == transformer.getB());\n         assertTrue(v == transformer.getV());\n-        \n+\n     }\n \n     public void testUpperOrLower() {\n--- a/src/test/java/org/apache/commons/math/linear/BigMatrixImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BigMatrixImplTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  */\n @Deprecated\n public final class BigMatrixImplTest extends TestCase {\n-    \n+\n     // Test data for String constructors\n     protected  String[][] testDataString = { {\"1\",\"2\",\"3\"}, {\"2\",\"5\",\"3\"}, {\"1\",\"0\",\"8\"} };\n-    \n+\n     // 3 x 3 identity matrix\n     protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };\n-    \n+\n     // Test data for group operations\n     protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };\n     protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};\n     protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };\n-    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, \n+    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},\n             {-1d,0d,-8d} };\n     protected double[] testDataRow1 = {1d,2d,3d};\n     protected double[] testDataCol3 = {3d,3d,8d};\n-    protected double[][] testDataInv = \n+    protected double[][] testDataInv =\n         { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };\n     protected double[] preMultTest = {8,12,33};\n     protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};\n     protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};\n-    protected double[][] testDataPlusInv = \n+    protected double[][] testDataPlusInv =\n         { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };\n-    \n+\n     // lu decomposition tests\n     protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };\n     protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},\n             {0.33333333333333,0d,0.33333333333333} };\n-    \n+\n     // singular matrices\n     protected double[][] singular = { {2d,3d}, {2d,3d} };\n     protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},\n             {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd\n     protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };\n     protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};\n-    \n+\n     // vectors\n     protected double[] testVector = {1,2,3};\n     protected double[] testVector2 = {1,2,3,4};\n-    \n+\n     // submatrix accessor tests\n     protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},\n-            {2, 4, 6, 8}, {4, 5, 6, 7}}; \n+            {2, 4, 6, 8}, {4, 5, 6, 7}};\n     // array selections\n     protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};\n     protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};\n     // column matrices\n     protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};\n     protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};\n-    \n+\n     // tolerances\n     protected double entryTolerance = 10E-16;\n     protected double normTolerance = 10E-14;\n-    \n+\n     public BigMatrixImplTest(String name) {\n         super(name);\n     }\n-    \n+\n     public static Test suite() {\n         TestSuite suite = new TestSuite(BigMatrixImplTest.class);\n         suite.setName(\"BigMatrixImpl Tests\");\n         assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n         assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n         assertTrue(\"testData2 is not square\",!m2.isSquare());\n-    }  \n-    \n+    }\n+\n     /** test copy functions */\n     public void testCopyFunctions() {\n         BigMatrixImpl m1 = new BigMatrixImpl(testData);\n         BigMatrixImpl m4 = new BigMatrixImpl(m3.getData(), false);\n         assertEquals(m4,m3);\n     }\n-    \n+\n     /** test constructors */\n     public void testConstructors() {\n         BigMatrix m1 = new BigMatrixImpl(testData);\n             // expected\n         }\n     }\n-    \n+\n     /** test add */\n     public void testAdd() {\n         BigMatrixImpl m = new BigMatrixImpl(testData);\n                     testDataPlusInv[row][col],sumEntries[row][col],\n                         entryTolerance);\n             }\n-        }    \n-    }\n-    \n+        }\n+    }\n+\n     /** test add failure */\n     public void testAddFail() {\n         BigMatrixImpl m = new BigMatrixImpl(testData);\n             // ignored\n         }\n     }\n-    \n+\n     /** test norm */\n     public void testNorm() {\n         BigMatrixImpl m = new BigMatrixImpl(testData);\n         assertEquals(\"testData norm\",14d,m.getNorm().doubleValue(),entryTolerance);\n         assertEquals(\"testData2 norm\",7d,m2.getNorm().doubleValue(),entryTolerance);\n     }\n-    \n+\n      /** test m-n = m + -n */\n     public void testPlusMinus() {\n         BigMatrixImpl m = new BigMatrixImpl(testData);\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n-    }\n-   \n+        }\n+    }\n+\n     /** test multiply */\n      public void testMultiply() {\n         BigMatrixImpl m = new BigMatrixImpl(testData);\n         assertClose(\"identity multiply\",identity.multiply(mInv),\n             mInv,entryTolerance);\n         assertClose(\"identity multiply\",m2.multiply(identity),\n-            m2,entryTolerance); \n+            m2,entryTolerance);\n         try {\n             m.multiply(new BigMatrixImpl(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n-    }   \n-    \n+        }\n+    }\n+\n     //Additional Test for BigMatrixImplTest.testMultiply\n \n     private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};\n     private double[][] d4 = new double[][] {{1},{2},{3},{4}};\n     private double[][] d5 = new double[][] {{30},{70}};\n-     \n-    public void testMultiply2() { \n+\n+    public void testMultiply2() {\n        BigMatrix m3 = new BigMatrixImpl(d3);\n        BigMatrix m4 = new BigMatrixImpl(d4);\n        BigMatrix m5 = new BigMatrixImpl(d5);\n        assertClose(\"m3*m4=m5\", m3.multiply(m4), m5, entryTolerance);\n-   }  \n-        \n+   }\n+\n     /** test isSingular */\n     public void testIsSingular() {\n         BigMatrixImpl m = new BigMatrixImpl(singular);\n         m = new BigMatrixImpl(testData);\n         assertTrue(\"testData nonsingular\",!m.isSingular());\n     }\n-        \n+\n     /** test inverse */\n     public void testInverse() {\n         BigMatrixImpl m = new BigMatrixImpl(testData);\n         BigMatrix mInv = new BigMatrixImpl(testDataInv);\n         assertClose(\"inverse\",mInv,m.inverse(),normTolerance);\n         assertClose(\"inverse^2\",m,m.inverse().inverse(),10E-12);\n-        \n+\n         // Not square\n         m = new BigMatrixImpl(testData2);\n         try {\n         } catch (InvalidMatrixException ex) {\n             // expected\n         }\n-        \n+\n         // Singular\n         m = new BigMatrixImpl(singular);\n         try {\n             // expected\n         }\n     }\n-    \n+\n     /** test solve */\n     public void testSolve() {\n         BigMatrixImpl m = new BigMatrixImpl(testData);\n             fail(\"expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }       \n+        }\n         BigMatrix bs = new BigMatrixImpl(bigSingular);\n         try {\n             bs.solve(bs);\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        } \n+        }\n         try {\n             (new BigMatrixImpl(testData2)).luDecompose();\n             fail(\"Expecting InvalidMatrixException\");\n         } catch (InvalidMatrixException ex) {\n             // ignored\n-        }  \n-    }\n-    \n+        }\n+    }\n+\n     /** test determinant */\n-    public void testDeterminant() {       \n+    public void testDeterminant() {\n         BigMatrix m = new BigMatrixImpl(bigSingular);\n         assertEquals(\"singular determinant\",0,m.getDeterminant().doubleValue(),0);\n         m = new BigMatrixImpl(detData);\n         assertEquals(\"nonsingular test\",-3d,m.getDeterminant().doubleValue(),normTolerance);\n-        \n+\n         // Examples verified against R (version 1.8.1, Red Hat Linux 9)\n         m = new BigMatrixImpl(detData2);\n         assertEquals(\"nonsingular R test 1\",-2d,m.getDeterminant().doubleValue(),normTolerance);\n             fail(\"Expecting InvalidMatrixException, got \" + d);\n         } catch (InvalidMatrixException ex) {\n             // ignored\n-        }      \n-    }\n-    \n+        }\n+    }\n+\n     /** test trace */\n     public void testTrace() {\n         BigMatrix m = new BigMatrixImpl(id);\n             fail(\"Expecting NonSquareMatrixException, got \" + t);\n         } catch (NonSquareMatrixException ex) {\n             // ignored\n-        }      \n-    }\n-    \n+        }\n+    }\n+\n     /** test sclarAdd */\n     public void testScalarAdd() {\n         BigMatrix m = new BigMatrixImpl(testData);\n         assertClose(\"scalar add\",new BigMatrixImpl(testDataPlus2),\n             m.scalarAdd(new BigDecimal(2d)),entryTolerance);\n     }\n-                    \n+\n     /** test operate */\n     public void testOperate() {\n         BigMatrix m = new BigMatrixImpl(id);\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n+        }\n     }\n \n     /** test issue MATH-209 */\n         assertEquals( 7.0, b[1].doubleValue(), 1.0e-12);\n         assertEquals(11.0, b[2].doubleValue(), 1.0e-12);\n     }\n-    \n+\n     /** test transpose */\n     public void testTranspose() {\n         BigMatrix m = new BigMatrixImpl(testData);\n         BigMatrix mt = new BigMatrixImpl(testData2T);\n         assertClose(\"transpose\",mt,m.transpose(),normTolerance);\n     }\n-    \n+\n     /** test preMultiply by vector */\n     public void testPremultiplyVector() {\n         BigMatrix m = new BigMatrixImpl(testData);\n             // ignored\n         }\n     }\n-    \n+\n     public void testPremultiply() {\n         BigMatrix m3 = new BigMatrixImpl(d3);\n         BigMatrix m4 = new BigMatrixImpl(d4);\n         BigMatrix m5 = new BigMatrixImpl(d5);\n         assertClose(\"m3*m4=m5\", m4.preMultiply(m3), m5, entryTolerance);\n-        \n+\n         BigMatrixImpl m = new BigMatrixImpl(testData);\n         BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);\n         BigMatrixImpl identity = new BigMatrixImpl(id);\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n-    }\n-    \n+        }\n+    }\n+\n     public void testGetVectors() {\n         BigMatrix m = new BigMatrixImpl(testData);\n         assertClose(\"get row\",m.getRowAsDoubleArray(0),testDataRow1,entryTolerance);\n             // ignored\n         }\n     }\n-      \n+\n     public void testLUDecomposition() throws Exception {\n         BigMatrixImpl m = new BigMatrixImpl(testData);\n         BigMatrix lu = m.getLUMatrix();\n             // expected\n         }\n     }\n-    \n+\n    /**\n     * test submatrix accessors\n     */\n         BigMatrix mRows03Cols123 = new BigMatrixImpl(subRows03Cols123);\n         BigMatrix mRows20Cols123 = new BigMatrixImpl(subRows20Cols123);\n         BigMatrix mRows31Cols31 = new BigMatrixImpl(subRows31Cols31);\n-        assertEquals(\"Rows23Cols00\", mRows23Cols00, \n+        assertEquals(\"Rows23Cols00\", mRows23Cols00,\n                 m.getSubMatrix(2 , 3 , 0, 0));\n-        assertEquals(\"Rows00Cols33\", mRows00Cols33, \n+        assertEquals(\"Rows00Cols33\", mRows00Cols33,\n                 m.getSubMatrix(0 , 0 , 3, 3));\n         assertEquals(\"Rows01Cols23\", mRows01Cols23,\n-                m.getSubMatrix(0 , 1 , 2, 3));   \n+                m.getSubMatrix(0 , 1 , 2, 3));\n         assertEquals(\"Rows02Cols13\", mRows02Cols13,\n-                m.getSubMatrix(new int[] {0,2}, new int[] {1,3}));  \n+                m.getSubMatrix(new int[] {0,2}, new int[] {1,3}));\n         assertEquals(\"Rows03Cols12\", mRows03Cols12,\n-                m.getSubMatrix(new int[] {0,3}, new int[] {1,2}));  \n+                m.getSubMatrix(new int[] {0,3}, new int[] {1,2}));\n         assertEquals(\"Rows03Cols123\", mRows03Cols123,\n-                m.getSubMatrix(new int[] {0,3}, new int[] {1,2,3})); \n+                m.getSubMatrix(new int[] {0,3}, new int[] {1,2,3}));\n         assertEquals(\"Rows20Cols123\", mRows20Cols123,\n-                m.getSubMatrix(new int[] {2,0}, new int[] {1,2,3})); \n+                m.getSubMatrix(new int[] {2,0}, new int[] {1,2,3}));\n         assertEquals(\"Rows31Cols31\", mRows31Cols31,\n-                m.getSubMatrix(new int[] {3,1}, new int[] {3,1})); \n+                m.getSubMatrix(new int[] {3,1}, new int[] {3,1}));\n         assertEquals(\"Rows31Cols31\", mRows31Cols31,\n-                m.getSubMatrix(new int[] {3,1}, new int[] {3,1})); \n-        \n+                m.getSubMatrix(new int[] {3,1}, new int[] {3,1}));\n+\n         try {\n             m.getSubMatrix(1,0,2,4);\n             fail(\"Expecting MatrixIndexException\");\n             // expected\n         }\n     }\n-    \n+\n     public void testGetColumnMatrix() {\n         BigMatrix m = new BigMatrixImpl(subTestData);\n         BigMatrix mColumn1 = new BigMatrixImpl(subColumn1);\n         BigMatrix mColumn3 = new BigMatrixImpl(subColumn3);\n-        assertEquals(\"Column1\", mColumn1, \n+        assertEquals(\"Column1\", mColumn1,\n                 m.getColumnMatrix(1));\n-        assertEquals(\"Column3\", mColumn3, \n+        assertEquals(\"Column3\", mColumn3,\n                 m.getColumnMatrix(3));\n         try {\n             m.getColumnMatrix(-1);\n             // expected\n         }\n     }\n-    \n+\n     public void testGetRowMatrix() {\n         BigMatrix m = new BigMatrixImpl(subTestData);\n         BigMatrix mRow0 = new BigMatrixImpl(subRow0);\n         BigMatrix mRow3 = new BigMatrixImpl(subRow3);\n-        assertEquals(\"Row0\", mRow0, \n+        assertEquals(\"Row0\", mRow0,\n                 m.getRowMatrix(0));\n-        assertEquals(\"Row3\", mRow3, \n+        assertEquals(\"Row3\", mRow3,\n                 m.getRowMatrix(3));\n         try {\n             m.getRowMatrix(-1);\n             // expected\n         }\n     }\n-    \n+\n     public void testEqualsAndHashCode() {\n         BigMatrixImpl m = new BigMatrixImpl(testData);\n         BigMatrixImpl m1 = (BigMatrixImpl) m.copy();\n         assertTrue(m.hashCode() != m1.hashCode());\n         assertFalse(m.equals(m1));\n     }\n-    \n+\n     public void testToString() {\n         BigMatrixImpl m = new BigMatrixImpl(testData);\n         assertEquals(\"BigMatrixImpl{{1,2,3},{2,5,3},{1,0,8}}\",\n         assertEquals(\"BigMatrixImpl{}\",\n                 m.toString());\n     }\n-    \n+\n     public void testSetSubMatrix() throws Exception {\n-        BigDecimal[][] detData3 = \n+        BigDecimal[][] detData3 =\n             MatrixUtils.createBigMatrix(detData2).getData();\n         BigMatrixImpl m = new BigMatrixImpl(testData);\n         m.setSubMatrix(detData3,1,1);\n         BigMatrix expected = MatrixUtils.createBigMatrix\n             (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});\n-        assertEquals(expected, m);  \n-        \n+        assertEquals(expected, m);\n+\n         m.setSubMatrix(detData3,0,0);\n         expected = MatrixUtils.createBigMatrix\n             (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});\n-        assertEquals(expected, m);  \n-        \n-        BigDecimal[][] testDataPlus3 = \n+        assertEquals(expected, m);\n+\n+        BigDecimal[][] testDataPlus3 =\n             MatrixUtils.createBigMatrix(testDataPlus2).getData();\n-        m.setSubMatrix(testDataPlus3,0,0);      \n+        m.setSubMatrix(testDataPlus3,0,0);\n         expected = MatrixUtils.createBigMatrix\n         (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});\n-        assertEquals(expected, m);   \n-        \n+        assertEquals(expected, m);\n+\n         // javadoc example\n         BigMatrixImpl matrix = (BigMatrixImpl) MatrixUtils.createBigMatrix\n             (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});\n              new BigDecimal(3), new BigDecimal(4), new BigDecimal(8)},\n              {new BigDecimal(9), new BigDecimal(5) , new BigDecimal(6),\n               new BigDecimal(2)}});\n-        assertEquals(expected, matrix);   \n-        \n+        assertEquals(expected, matrix);\n+\n         // dimension overflow\n-        try {  \n+        try {\n             m.setSubMatrix(matrix.getData(),1,1);\n             fail(\"expecting MatrixIndexException\");\n         } catch (MatrixIndexException e) {\n             // expected\n         }\n-        \n+\n         // null\n         try {\n             m.setSubMatrix(null,1,1);\n         } catch (NullPointerException e) {\n             // expected\n         }\n-        \n+\n         // ragged\n         try {\n             m.setSubMatrix(new BigDecimal[][] {{new BigDecimal(1)},\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n         // empty\n         try {\n             m.setSubMatrix(new BigDecimal[][] {{}}, 0, 0);\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        \n-    }\n-    \n+\n+    }\n+\n     //--------------- -----------------Protected methods\n-        \n-    /** verifies that two matrices are close (1-norm) */              \n+\n+    /** verifies that two matrices are close (1-norm) */\n     protected void assertClose(String msg, BigMatrix m, BigMatrix n,\n         double tolerance) {\n         assertTrue(msg,m.subtract(n).getNorm().doubleValue() < tolerance);\n     }\n-    \n+\n     /** verifies that two vectors are close (sup norm) */\n     protected void assertClose(String msg, double[] m, double[] n,\n         double tolerance) {\n             fail(\"vectors not same length\");\n         }\n         for (int i = 0; i < m.length; i++) {\n-            assertEquals(msg + \" \" +  i + \" elements differ\", \n+            assertEquals(msg + \" \" +  i + \" elements differ\",\n                 m[i],n[i],tolerance);\n         }\n     }\n-    \n+\n     /** extracts the l  and u matrices from compact lu representation */\n     protected void splitLU(BigMatrix lu, BigDecimal[][] lowerData, BigDecimal[][] upperData) throws InvalidMatrixException {\n         if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||\n                 lowerData.length != upperData.length\n                 || lowerData.length != lu.getRowDimension()) {\n             throw new InvalidMatrixException(\"incorrect dimensions\");\n-        }    \n+        }\n         int n = lu.getRowDimension();\n         for (int i = 0; i < n; i++) {\n             for (int j = 0; j < n; j++) {\n                 } else {\n                     lowerData[i][j] = new BigDecimal(0);\n                     upperData[i][j] = lu.getEntry(i, j);\n-                }   \n+                }\n             }\n         }\n     }\n-    \n+\n     /** Returns the result of applying the given row permutation to the matrix */\n     protected BigMatrix permuteRows(BigMatrix matrix, int[] permutation) {\n         if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {\n         }\n         return new BigMatrixImpl(out);\n     }\n-    \n+\n     /** Extracts l and u matrices from lu and verifies that matrix = l times u modulo permutation */\n     protected void verifyDecomposition(BigMatrix matrix, BigMatrix lu) throws Exception{\n         int n = matrix.getRowDimension();\n         assertClose(\"lu decomposition does not work\", permuted,\n                 lower.multiply(upper), normTolerance);\n     }\n-         \n+\n //    /** Useful for debugging */\n //    private void dumpMatrix(BigMatrix m) {\n //          for (int i = 0; i < m.getRowDimension(); i++) {\n //              System.out.println(os);\n //          }\n //    }\n-        \n+\n }\n \n--- a/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  */\n \n public final class BlockFieldMatrixTest extends TestCase {\n-    \n+\n     // 3 x 3 identity matrix\n     protected Fraction[][] id = {\n             {new Fraction(1),new Fraction(0),new Fraction(0)},\n             {new Fraction(0),new Fraction(1),new Fraction(0)},\n             {new Fraction(0),new Fraction(0),new Fraction(1)}\n     };\n-    \n+\n     // Test data for group operations\n     protected Fraction[][] testData = {\n             {new Fraction(1),new Fraction(2),new Fraction(3)},\n     };\n     protected Fraction[][] testDataMinus = {\n             {new Fraction(-1),new Fraction(-2),new Fraction(-3)},\n-            {new Fraction(-2),new Fraction(-5),new Fraction(-3)}, \n+            {new Fraction(-2),new Fraction(-5),new Fraction(-3)},\n             {new Fraction(-1),new Fraction(0),new Fraction(-8)}\n     };\n     protected Fraction[] testDataRow1 = {new Fraction(1),new Fraction(2),new Fraction(3)};\n             {new Fraction(15),new Fraction(0),new Fraction(0)},\n             {new Fraction(6),new Fraction(-2),new Fraction(7)}\n     };\n-    \n+\n     // lu decomposition tests\n     protected Fraction[][] luData = {\n             {new Fraction(2),new Fraction(3),new Fraction(3)},\n             {new Fraction(0),new Fraction(5),new Fraction(7)},\n             {new Fraction(1, 3),new Fraction(0),new Fraction(1, 3)}\n     };\n-    \n+\n     // singular matrices\n     protected Fraction[][] singular = { {new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(3)} };\n     protected Fraction[][] bigSingular = {\n             {new Fraction(7),new Fraction(8),new Fraction(10)}\n     };\n     protected Fraction[][] detData2 = { {new Fraction(1), new Fraction(3)}, {new Fraction(2), new Fraction(4)}};\n-    \n+\n     // vectors\n     protected Fraction[] testVector = {new Fraction(1),new Fraction(2),new Fraction(3)};\n     protected Fraction[] testVector2 = {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)};\n-    \n+\n     // submatrix accessor tests\n     protected Fraction[][] subTestData = {\n             {new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)},\n             {new Fraction(3, 2), new Fraction(5, 2), new Fraction(7, 2), new Fraction(9, 2)},\n             {new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8)},\n             {new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7)}\n-    }; \n+    };\n     // array selections\n     protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4)}, {new Fraction(4), new Fraction(8)}};\n     protected Fraction[][] subRows03Cols12 = { {new Fraction(2), new Fraction(3)}, {new Fraction(5), new Fraction(6)}};\n     // column matrices\n     protected Fraction[][] subColumn1 = {{new Fraction(2)}, {new Fraction(5, 2)}, {new Fraction(4)}, {new Fraction(5)}};\n     protected Fraction[][] subColumn3 = {{new Fraction(4)}, {new Fraction(9, 2)}, {new Fraction(8)}, {new Fraction(7)}};\n-    \n+\n     // tolerances\n     protected double entryTolerance = 10E-16;\n     protected double normTolerance = 10E-14;\n-    \n+\n     public BlockFieldMatrixTest(String name) {\n         super(name);\n     }\n-    \n+\n     public static Test suite() {\n         TestSuite suite = new TestSuite(BlockFieldMatrixTest.class);\n         suite.setName(\"BlockFieldMatrix<Fraction> Tests\");\n         return suite;\n     }\n-    \n+\n     /** test dimensions */\n     public void testDimensions() {\n         BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n         assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n         assertTrue(\"testData2 is not square\",!m2.isSquare());\n-    } \n-    \n+    }\n+\n     /** test copy functions */\n     public void testCopyFunctions() {\n         Random r = new Random(66636328996002l);\n         BlockFieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(testData);\n         BlockFieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(m3.getData());\n         assertEquals(m3, m4);\n-    }           \n-    \n+    }\n+\n     /** test add */\n     public void testAdd() {\n         BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n             for (int col = 0; col < m.getColumnDimension(); col++) {\n                 assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);\n             }\n-        }    \n-    }\n-    \n+        }\n+    }\n+\n     /** test add failure */\n     public void testAddFail() {\n         BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n             // ignored\n         }\n     }\n-    \n+\n      /** test m-n = m + -n */\n     public void testPlusMinus() {\n         BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         BlockFieldMatrix<Fraction> m2 = new BlockFieldMatrix<Fraction>(testDataInv);\n-        TestUtils.assertEquals(m.subtract(m2), m2.scalarMultiply(new Fraction(-1)).add(m));        \n+        TestUtils.assertEquals(m.subtract(m2), m2.scalarMultiply(new Fraction(-1)).add(m));\n         try {\n             m.subtract(new BlockFieldMatrix<Fraction>(testData2));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n-    }\n-   \n+        }\n+    }\n+\n     /** test multiply */\n      public void testMultiply() {\n         BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         TestUtils.assertEquals(mInv.multiply(m), identity);\n         TestUtils.assertEquals(m.multiply(identity), m);\n         TestUtils.assertEquals(identity.multiply(mInv), mInv);\n-        TestUtils.assertEquals(m2.multiply(identity), m2); \n+        TestUtils.assertEquals(m2.multiply(identity), m2);\n         try {\n             m.multiply(new BlockFieldMatrix<Fraction>(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }      \n+        }\n     }\n \n     public void testSeveralBlocks() {\n             {new Fraction(4)}\n     };\n     private Fraction[][] d5 = new Fraction[][] {{new Fraction(30)},{new Fraction(70)}};\n-     \n-    public void testMultiply2() { \n-       FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3);   \n+\n+    public void testMultiply2() {\n+       FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3);\n        FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4);\n        FieldMatrix<Fraction> m5 = new BlockFieldMatrix<Fraction>(d5);\n        TestUtils.assertEquals(m3.multiply(m4), m5);\n-   }  \n-        \n+   }\n+\n     /** test trace */\n     public void testTrace() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id);\n             fail(\"Expecting NonSquareMatrixException\");\n         } catch (NonSquareMatrixException ex) {\n             // ignored\n-        }      \n-    }\n-    \n+        }\n+    }\n+\n     /** test scalarAdd */\n     public void testScalarAdd() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         TestUtils.assertEquals(new BlockFieldMatrix<Fraction>(testDataPlus2),\n                                m.scalarAdd(new Fraction(2)));\n     }\n-                    \n+\n     /** test operate */\n     public void testOperate() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(id);\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n+        }\n     }\n \n     public void testOperateLarge() {\n         assertEquals( new Fraction(7), b[1]);\n         assertEquals(new Fraction(11), b[2]);\n     }\n-    \n+\n     /** test transpose */\n     public void testTranspose() {\n-        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData); \n+        FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();\n         FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();\n         TestUtils.assertEquals(mIT, mTI);\n         FieldMatrix<Fraction> mt = new BlockFieldMatrix<Fraction>(testData2T);\n         TestUtils.assertEquals(mt, m.transpose());\n     }\n-    \n+\n     /** test preMultiply by vector */\n     public void testPremultiplyVector() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n             // ignored\n         }\n     }\n-    \n+\n     public void testPremultiply() {\n-        FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3);   \n+        FieldMatrix<Fraction> m3 = new BlockFieldMatrix<Fraction>(d3);\n         FieldMatrix<Fraction> m4 = new BlockFieldMatrix<Fraction>(d4);\n         FieldMatrix<Fraction> m5 = new BlockFieldMatrix<Fraction>(d5);\n         TestUtils.assertEquals(m4.preMultiply(m3), m5);\n-        \n+\n         BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         BlockFieldMatrix<Fraction> mInv = new BlockFieldMatrix<Fraction>(testDataInv);\n         BlockFieldMatrix<Fraction> identity = new BlockFieldMatrix<Fraction>(id);\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n-    }\n-    \n+        }\n+    }\n+\n     public void testGetVectors() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         TestUtils.assertEquals(m.getRow(0), testDataRow1);\n             // ignored\n         }\n     }\n-    \n+\n     public void testGetEntry() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         assertEquals(m.getEntry(0,1),new Fraction(2));\n             // expected\n         }\n     }\n-        \n+\n     /** test examples in user guide */\n     public void testExamples() {\n         // Create a real matrix with two rows and three columns\n         assertEquals(2, p.getRowDimension());\n         assertEquals(2, p.getColumnDimension());\n         // Invert p\n-        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse(); \n+        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse();\n         assertEquals(2, pInverse.getRowDimension());\n         assertEquals(2, pInverse.getColumnDimension());\n-        \n+\n         // Solve example\n         Fraction[][] coefficientsData = {\n                 {new Fraction(2), new Fraction(3), new Fraction(-2)},\n         assertEquals(new Fraction(4).multiply(solution[0]).\n                      subtract(new Fraction(3).multiply(solution[1])).\n                      subtract(new Fraction(5).multiply(solution[2])),\n-                     constants[2]);   \n-        \n-    }\n-    \n+                     constants[2]);\n+\n+    }\n+\n     // test submatrix accessors\n     public void testGetSubMatrix() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);\n         checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3);\n-        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);   \n-        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });  \n-        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });  \n-        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); \n-        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); \n-        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n-        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);\n+        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });\n+        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });\n+        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });\n+        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });\n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });\n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });\n         checkGetSubMatrix(m, null,  1, 0, 2, 4);\n         checkGetSubMatrix(m, null, -1, 1, 2, 2);\n         checkGetSubMatrix(m, null,  1, 0, 2, 2);\n             }\n         }\n     }\n-    \n+\n     private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,\n                                    int[] selectedRows, int[] selectedColumns) {\n         try {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);\n         checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3);\n-        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);   \n-        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });  \n-        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });  \n-        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); \n-        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); \n-        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n-        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n-        \n+        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);\n+        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });\n+        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });\n+        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });\n+        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });\n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });\n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });\n+\n         checkCopy(m, null,  1, 0, 2, 4);\n         checkCopy(m, null, -1, 1, 2, 2);\n         checkCopy(m, null,  1, 0, 2, 2);\n             }\n         }\n     }\n-    \n+\n     private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,\n                            int[] selectedRows, int[] selectedColumns) {\n         try {\n             // expected\n         }\n     }\n-    \n+\n     public void testGetSetRowMatrixLarge() {\n         int n = 3 * BlockFieldMatrix.BLOCK_SIZE;\n         FieldMatrix<Fraction> m =\n         assertEquals(sub, m.getRowMatrix(2));\n \n     }\n-    \n+\n     public void testGetColumnMatrix() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         FieldMatrix<Fraction> mColumn1 = new BlockFieldMatrix<Fraction>(subColumn1);\n         assertEquals(sub, m.getColumnMatrix(2));\n \n     }\n-    \n+\n     public void testGetRowVector() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         FieldVector<Fraction> mRow0 = new ArrayFieldVector<Fraction>(subRow0[0]);\n         assertEquals(sub, m.getRowVector(2));\n \n     }\n-    \n+\n     public void testGetColumnVector() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);\n         assertEquals(sub, m.getColumnVector(2));\n \n     }\n-    \n+\n     private FieldVector<Fraction> columnToVector(Fraction[][] column) {\n         Fraction[] data = new Fraction[column.length];\n         for (int i = 0; i < data.length; ++i) {\n         checkArrays(sub, m.getRow(2));\n \n     }\n-    \n+\n     public void testGetColumn() {\n         FieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(subTestData);\n         Fraction[] mColumn1 = columnToArray(subColumn1);\n         checkArrays(sub, m.getColumn(2));\n \n     }\n-    \n+\n     private Fraction[] columnToArray(Fraction[][] column) {\n         Fraction[] data = new Fraction[column.length];\n         for (int i = 0; i < data.length; ++i) {\n     private void checkArrays(Fraction[] expected, Fraction[] actual) {\n         assertEquals(expected.length, actual.length);\n         for (int i = 0; i < expected.length; ++i) {\n-            assertEquals(expected[i], actual[i]);            \n-        }\n-    }\n-    \n+            assertEquals(expected[i], actual[i]);\n+        }\n+    }\n+\n     public void testEqualsAndHashCode() {\n         BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         BlockFieldMatrix<Fraction> m1 = (BlockFieldMatrix<Fraction>) m.copy();\n         assertEquals(m, m1);\n         assertFalse(m.equals(null));\n         assertFalse(m.equals(mt));\n-        assertFalse(m.equals(new BlockFieldMatrix<Fraction>(bigSingular))); \n-    }\n-    \n+        assertFalse(m.equals(new BlockFieldMatrix<Fraction>(bigSingular)));\n+    }\n+\n     public void testToString() {\n         BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         assertEquals(\"BlockFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}\", m.toString());\n     }\n-    \n+\n     public void testSetSubMatrix() throws Exception {\n         BlockFieldMatrix<Fraction> m = new BlockFieldMatrix<Fraction>(testData);\n         m.setSubMatrix(detData2,1,1);\n         FieldMatrix<Fraction> expected = new BlockFieldMatrix<Fraction>\n             (new Fraction[][] {{new Fraction(1),new Fraction(2),new Fraction(3)},{new Fraction(2),new Fraction(1),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});\n-        assertEquals(expected, m);  \n-        \n+        assertEquals(expected, m);\n+\n         m.setSubMatrix(detData2,0,0);\n         expected = new BlockFieldMatrix<Fraction>\n             (new Fraction[][] {{new Fraction(1),new Fraction(3),new Fraction(3)},{new Fraction(2),new Fraction(4),new Fraction(3)},{new Fraction(1),new Fraction(2),new Fraction(4)}});\n-        assertEquals(expected, m);  \n-        \n-        m.setSubMatrix(testDataPlus2,0,0);      \n+        assertEquals(expected, m);\n+\n+        m.setSubMatrix(testDataPlus2,0,0);\n         expected = new BlockFieldMatrix<Fraction>\n             (new Fraction[][] {{new Fraction(3),new Fraction(4),new Fraction(5)},{new Fraction(4),new Fraction(7),new Fraction(5)},{new Fraction(3),new Fraction(2),new Fraction(10)}});\n-        assertEquals(expected, m);   \n-        \n+        assertEquals(expected, m);\n+\n         // javadoc example\n         BlockFieldMatrix<Fraction> matrix =\n             new BlockFieldMatrix<Fraction>(new Fraction[][] {\n                     {new Fraction(5), new Fraction(3), new Fraction(4), new Fraction(8)},\n                     {new Fraction(9), new Fraction(5) ,new Fraction(6), new Fraction(2)}\n             });\n-        assertEquals(expected, matrix);   \n+        assertEquals(expected, matrix);\n \n         // dimension overflow\n-        try {  \n+        try {\n             m.setSubMatrix(testData,1,1);\n             fail(\"expecting MatrixIndexException\");\n         } catch (MatrixIndexException e) {\n             // expected\n         }\n         // dimension underflow\n-        try {  \n+        try {\n             m.setSubMatrix(testData,-1,1);\n             fail(\"expecting MatrixIndexException\");\n         } catch (MatrixIndexException e) {\n             // expected\n         }\n-        try {  \n+        try {\n             m.setSubMatrix(testData,1,-1);\n             fail(\"expecting MatrixIndexException\");\n         } catch (MatrixIndexException e) {\n             // expected\n         }\n-        \n+\n         // null\n         try {\n             m.setSubMatrix(null,1,1);\n         } catch (NullPointerException e) {\n             // expected\n         }\n-        \n+\n         // ragged\n         try {\n             m.setSubMatrix(new Fraction[][] {{new Fraction(1)}, {new Fraction(2), new Fraction(3)}}, 0, 0);\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-       \n+\n         // empty\n         try {\n             m.setSubMatrix(new Fraction[][] {{}}, 0, 0);\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n     }\n \n     public void testWalk() {\n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, 0));\n             assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(0, j));\n             assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, 0));\n             assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(0, j));\n             assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n         m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, 0));\n             assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(0, j));\n             assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n         m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, 0));\n             assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(0, j));\n             assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n         }\n         return m;\n     }\n-    \n+\n }\n \n--- a/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  */\n \n public final class BlockRealMatrixTest extends TestCase {\n-    \n+\n     // 3 x 3 identity matrix\n     protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };\n-    \n+\n     // Test data for group operations\n     protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };\n     protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};\n     protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };\n-    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, \n+    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},\n        {-1d,0d,-8d} };\n     protected double[] testDataRow1 = {1d,2d,3d};\n     protected double[] testDataCol3 = {3d,3d,8d};\n-    protected double[][] testDataInv = \n+    protected double[][] testDataInv =\n         { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };\n     protected double[] preMultTest = {8,12,33};\n     protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};\n     protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};\n-    protected double[][] testDataPlusInv = \n+    protected double[][] testDataPlusInv =\n         { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };\n-    \n+\n     // lu decomposition tests\n     protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };\n     protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},\n             {0.33333333333333,0d,0.33333333333333} };\n-    \n+\n     // singular matrices\n     protected double[][] singular = { {2d,3d}, {2d,3d} };\n     protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},\n         {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd\n     protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };\n     protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};\n-    \n+\n     // vectors\n     protected double[] testVector = {1,2,3};\n     protected double[] testVector2 = {1,2,3,4};\n-    \n+\n     // submatrix accessor tests\n     protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},\n-            {2, 4, 6, 8}, {4, 5, 6, 7}}; \n+            {2, 4, 6, 8}, {4, 5, 6, 7}};\n     // array selections\n     protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};\n     protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};\n     // column matrices\n     protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};\n     protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};\n-    \n+\n     // tolerances\n     protected double entryTolerance = 10E-16;\n     protected double normTolerance = 10E-14;\n-    \n+\n     public BlockRealMatrixTest(String name) {\n         super(name);\n     }\n-    \n+\n     public static Test suite() {\n         TestSuite suite = new TestSuite(BlockRealMatrixTest.class);\n         suite.setName(\"BlockRealMatrix Tests\");\n         return suite;\n     }\n-    \n+\n     /** test dimensions */\n     public void testDimensions() {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n         assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n         assertTrue(\"testData2 is not square\",!m2.isSquare());\n-    } \n-    \n+    }\n+\n     /** test copy functions */\n     public void testCopyFunctions() {\n         Random r = new Random(66636328996002l);\n         BlockRealMatrix m3 = new BlockRealMatrix(testData);\n         BlockRealMatrix m4 = new BlockRealMatrix(m3.getData());\n         assertEquals(m3, m4);\n-    }           \n-    \n+    }\n+\n     /** test add */\n     public void testAdd() {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n                     testDataPlusInv[row][col],sumEntries[row][col],\n                         entryTolerance);\n             }\n-        }    \n-    }\n-    \n+        }\n+    }\n+\n     /** test add failure */\n     public void testAddFail() {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n             // ignored\n         }\n     }\n-    \n+\n     /** test norm */\n     public void testNorm() {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         assertEquals(\"testData norm\",14d,m.getNorm(),entryTolerance);\n         assertEquals(\"testData2 norm\",7d,m2.getNorm(),entryTolerance);\n     }\n-    \n+\n     /** test Frobenius norm */\n     public void testFrobeniusNorm() {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         assertEquals(\"testData Frobenius norm\", Math.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n         assertEquals(\"testData2 Frobenius norm\", Math.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n     }\n-    \n+\n      /** test m-n = m + -n */\n     public void testPlusMinus() {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         BlockRealMatrix m2 = new BlockRealMatrix(testDataInv);\n-        assertClose(m.subtract(m2), m2.scalarMultiply(-1d).add(m), entryTolerance);        \n+        assertClose(m.subtract(m2), m2.scalarMultiply(-1d).add(m), entryTolerance);\n         try {\n             m.subtract(new BlockRealMatrix(testData2));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n-    }\n-   \n+        }\n+    }\n+\n     /** test multiply */\n      public void testMultiply() {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         assertClose(mInv.multiply(m), identity, entryTolerance);\n         assertClose(m.multiply(identity), m, entryTolerance);\n         assertClose(identity.multiply(mInv), mInv, entryTolerance);\n-        assertClose(m2.multiply(identity), m2, entryTolerance); \n+        assertClose(m2.multiply(identity), m2, entryTolerance);\n         try {\n             m.multiply(new BlockRealMatrix(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }      \n+        }\n     }\n \n     public void testSeveralBlocks() {\n     private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};\n     private double[][] d4 = new double[][] {{1},{2},{3},{4}};\n     private double[][] d5 = new double[][] {{30},{70}};\n-     \n-    public void testMultiply2() { \n-       RealMatrix m3 = new BlockRealMatrix(d3);   \n+\n+    public void testMultiply2() {\n+       RealMatrix m3 = new BlockRealMatrix(d3);\n        RealMatrix m4 = new BlockRealMatrix(d4);\n        RealMatrix m5 = new BlockRealMatrix(d5);\n        assertClose(m3.multiply(m4), m5, entryTolerance);\n-   }  \n-        \n+   }\n+\n     /** test trace */\n     public void testTrace() {\n         RealMatrix m = new BlockRealMatrix(id);\n             fail(\"Expecting NonSquareMatrixException\");\n         } catch (NonSquareMatrixException ex) {\n             // ignored\n-        }      \n-    }\n-    \n+        }\n+    }\n+\n     /** test scalarAdd */\n     public void testScalarAdd() {\n         RealMatrix m = new BlockRealMatrix(testData);\n         assertClose(new BlockRealMatrix(testDataPlus2), m.scalarAdd(2d), entryTolerance);\n     }\n-                    \n+\n     /** test operate */\n     public void testOperate() {\n         RealMatrix m = new BlockRealMatrix(id);\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n+        }\n     }\n \n     public void testOperateLarge() {\n         assertEquals( 7.0, b[1], 1.0e-12);\n         assertEquals(11.0, b[2], 1.0e-12);\n     }\n-    \n+\n     /** test transpose */\n     public void testTranspose() {\n-        RealMatrix m = new BlockRealMatrix(testData); \n+        RealMatrix m = new BlockRealMatrix(testData);\n         RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();\n         RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();\n         assertClose(mIT, mTI, normTolerance);\n         RealMatrix mt = new BlockRealMatrix(testData2T);\n         assertClose(mt, m.transpose(), normTolerance);\n     }\n-    \n+\n     /** test preMultiply by vector */\n     public void testPremultiplyVector() {\n         RealMatrix m = new BlockRealMatrix(testData);\n             // ignored\n         }\n     }\n-    \n+\n     public void testPremultiply() {\n-        RealMatrix m3 = new BlockRealMatrix(d3);   \n+        RealMatrix m3 = new BlockRealMatrix(d3);\n         RealMatrix m4 = new BlockRealMatrix(d4);\n         RealMatrix m5 = new BlockRealMatrix(d5);\n         assertClose(m4.preMultiply(m3), m5, entryTolerance);\n-        \n+\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         BlockRealMatrix mInv = new BlockRealMatrix(testDataInv);\n         BlockRealMatrix identity = new BlockRealMatrix(id);\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n-    }\n-    \n+        }\n+    }\n+\n     public void testGetVectors() {\n         RealMatrix m = new BlockRealMatrix(testData);\n         assertClose(m.getRow(0), testDataRow1, entryTolerance);\n             // ignored\n         }\n     }\n-    \n+\n     public void testGetEntry() {\n         RealMatrix m = new BlockRealMatrix(testData);\n         assertEquals(\"get entry\",m.getEntry(0,1),2d,entryTolerance);\n             // expected\n         }\n     }\n-        \n+\n     /** test examples in user guide */\n     public void testExamples() {\n         // Create a real matrix with two rows and three columns\n         assertEquals(2, p.getRowDimension());\n         assertEquals(2, p.getColumnDimension());\n         // Invert p\n-        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse(); \n+        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();\n         assertEquals(2, pInverse.getRowDimension());\n         assertEquals(2, pInverse.getColumnDimension());\n-        \n+\n         // Solve example\n         double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};\n         RealMatrix coefficients = new BlockRealMatrix(coefficientsData);\n         double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);\n         assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);\n         assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);\n-        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);   \n-        \n-    }\n-    \n+        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);\n+\n+    }\n+\n     // test submatrix accessors\n     public void testGetSubMatrix() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n         checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);\n         checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3);\n-        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);   \n-        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });  \n-        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });  \n-        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); \n-        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); \n-        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n-        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);\n+        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });\n+        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });\n+        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });\n+        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });\n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });\n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });\n         checkGetSubMatrix(m, null,  1, 0, 2, 4);\n         checkGetSubMatrix(m, null, -1, 1, 2, 2);\n         checkGetSubMatrix(m, null,  1, 0, 2, 2);\n             }\n         }\n     }\n-    \n+\n     private void checkGetSubMatrix(RealMatrix m, double[][] reference,\n                                    int[] selectedRows, int[] selectedColumns) {\n         try {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n         checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);\n         checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3);\n-        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);   \n-        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });  \n-        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });  \n-        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); \n-        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); \n-        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n-        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n-        \n+        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);\n+        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });\n+        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });\n+        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });\n+        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });\n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });\n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });\n+\n         checkCopy(m, null,  1, 0, 2, 4);\n         checkCopy(m, null, -1, 1, 2, 2);\n         checkCopy(m, null,  1, 0, 2, 2);\n             }\n         }\n     }\n-    \n+\n     private void checkCopy(RealMatrix m, double[][] reference,\n                            int[] selectedRows, int[] selectedColumns) {\n         try {\n             // expected\n         }\n     }\n-    \n+\n     public void testGetSetRowMatrixLarge() {\n         int n = 3 * BlockRealMatrix.BLOCK_SIZE;\n         RealMatrix m = new BlockRealMatrix(n, n);\n         assertEquals(sub, m.getRowMatrix(2));\n \n     }\n-    \n+\n     public void testGetColumnMatrix() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n         RealMatrix mColumn1 = new BlockRealMatrix(subColumn1);\n         assertEquals(sub, m.getColumnMatrix(2));\n \n     }\n-    \n+\n     public void testGetRowVector() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n         RealVector mRow0 = new ArrayRealVector(subRow0[0]);\n         assertEquals(sub, m.getRowVector(2));\n \n     }\n-    \n+\n     public void testGetColumnVector() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n         RealVector mColumn1 = columnToVector(subColumn1);\n         assertEquals(sub, m.getColumnVector(2));\n \n     }\n-    \n+\n     private RealVector columnToVector(double[][] column) {\n         double[] data = new double[column.length];\n         for (int i = 0; i < data.length; ++i) {\n         checkArrays(sub, m.getRow(2));\n \n     }\n-    \n+\n     public void testGetColumn() {\n         RealMatrix m = new BlockRealMatrix(subTestData);\n         double[] mColumn1 = columnToArray(subColumn1);\n         checkArrays(sub, m.getColumn(2));\n \n     }\n-    \n+\n     private double[] columnToArray(double[][] column) {\n         double[] data = new double[column.length];\n         for (int i = 0; i < data.length; ++i) {\n     private void checkArrays(double[] expected, double[] actual) {\n         assertEquals(expected.length, actual.length);\n         for (int i = 0; i < expected.length; ++i) {\n-            assertEquals(expected[i], actual[i]);            \n-        }\n-    }\n-    \n+            assertEquals(expected[i], actual[i]);\n+        }\n+    }\n+\n     public void testEqualsAndHashCode() {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         BlockRealMatrix m1 = (BlockRealMatrix) m.copy();\n         assertEquals(m, m1);\n         assertFalse(m.equals(null));\n         assertFalse(m.equals(mt));\n-        assertFalse(m.equals(new BlockRealMatrix(bigSingular))); \n-    }\n-    \n+        assertFalse(m.equals(new BlockRealMatrix(bigSingular)));\n+    }\n+\n     public void testToString() {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         assertEquals(\"BlockRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n                 m.toString());\n     }\n-    \n+\n     public void testSetSubMatrix() throws Exception {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         m.setSubMatrix(detData2,1,1);\n         RealMatrix expected = new BlockRealMatrix\n             (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});\n-        assertEquals(expected, m);  \n-        \n+        assertEquals(expected, m);\n+\n         m.setSubMatrix(detData2,0,0);\n         expected = new BlockRealMatrix\n             (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});\n-        assertEquals(expected, m);  \n-        \n-        m.setSubMatrix(testDataPlus2,0,0);      \n+        assertEquals(expected, m);\n+\n+        m.setSubMatrix(testDataPlus2,0,0);\n         expected = new BlockRealMatrix\n             (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});\n-        assertEquals(expected, m);   \n-        \n+        assertEquals(expected, m);\n+\n         // javadoc example\n         BlockRealMatrix matrix = new BlockRealMatrix\n             (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});\n         matrix.setSubMatrix(new double[][] {{3, 4}, {5, 6}}, 1, 1);\n         expected = new BlockRealMatrix\n             (new double[][] {{1, 2, 3, 4}, {5, 3, 4, 8}, {9, 5 ,6, 2}});\n-        assertEquals(expected, matrix);   \n+        assertEquals(expected, matrix);\n \n         // dimension overflow\n-        try {  \n+        try {\n             m.setSubMatrix(testData,1,1);\n             fail(\"expecting MatrixIndexException\");\n         } catch (MatrixIndexException e) {\n             // expected\n         }\n         // dimension underflow\n-        try {  \n+        try {\n             m.setSubMatrix(testData,-1,1);\n             fail(\"expecting MatrixIndexException\");\n         } catch (MatrixIndexException e) {\n             // expected\n         }\n-        try {  \n+        try {\n             m.setSubMatrix(testData,1,-1);\n             fail(\"expecting MatrixIndexException\");\n         } catch (MatrixIndexException e) {\n             // expected\n         }\n-        \n+\n         // null\n         try {\n             m.setSubMatrix(null,1,1);\n         } catch (NullPointerException e) {\n             // expected\n         }\n-        \n+\n         // ragged\n         try {\n             m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-       \n+\n         // empty\n         try {\n             m.setSubMatrix(new double[][] {{}}, 0, 0);\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n     }\n \n     public void testWalk() {\n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, 0), 0);\n             assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(0, j), 0);\n             assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, 0), 0);\n             assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(0, j), 0);\n             assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n         m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, 0), 0);\n             assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(0, j), 0);\n             assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n         m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, 0), 0);\n             assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(0, j), 0);\n             assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n     }\n-    \n+\n     public void testSerial()  {\n         BlockRealMatrix m = new BlockRealMatrix(testData);\n         assertEquals(m,TestUtils.serializeAndRecover(m));\n     }\n \n     //--------------- -----------------Protected methods\n-        \n-    /** verifies that two matrices are close (1-norm) */              \n+\n+    /** verifies that two matrices are close (1-norm) */\n     protected void assertClose(RealMatrix m, RealMatrix n, double tolerance) {\n         assertTrue(m.subtract(n).getNorm() < tolerance);\n     }\n-    \n+\n     /** verifies that two vectors are close (sup norm) */\n     protected void assertClose(double[] m, double[] n, double tolerance) {\n         if (m.length != n.length) {\n         }\n         return m;\n     }\n-    \n+\n }\n \n--- a/src/test/java/org/apache/commons/math/linear/CholeskyDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/CholeskyDecompositionImplTest.java\n                 {-0.09376327,  0.10400408, 0.07137959, 0.04762857 },\n                 { 0.30328980,  0.07137959, 0.30458776, 0.04882449 },\n                 { 0.04909388,  0.04762857, 0.04882449, 0.07543265 }\n-            \n+\n         }));\n     }\n \n         // check the same cached instance is returned the second time\n         assertTrue(l  == llt.getL());\n         assertTrue(lt == llt.getLT());\n-        \n+\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n             if (i < 5) {\n                 ref[i] = 2 * r.nextDouble() - 1;\n             } else {\n-                ref[i] = 0.0001 * r.nextDouble() + 6;                \n+                ref[i] = 0.0001 * r.nextDouble() + 6;\n             }\n         }\n         Arrays.sort(ref);\n         for (int i = 0; i < ref.length; ++i) {\n             assertEquals(ref[ref.length - i - 1], eigenValues[i], 2.0e-14);\n         }\n-        \n+\n     }\n \n     /** test dimensions */\n                 {3,  2,  4},\n                 {2,  0,  2},\n                 {4,  2,  3}\n-        }); \n+        });\n         EigenDecomposition ed = new EigenDecompositionImpl(repeated, MathUtils.SAFE_MIN);\n         checkEigenValues((new double[] {8, -1, -1}), ed, 1E-12);\n         checkEigenVector((new double[] {2, 1, 2}), ed, 1E-12);\n     }\n-    \n+\n     /**\n      * Matrix with eigenvalues {2, 0, 12}\n      */\n     public void testDistinctEigenvalues() {\n         RealMatrix distinct = MatrixUtils.createRealMatrix(new double[][] {\n-                {3, 1, -4},  \n-                {1, 3, -4}, \n+                {3, 1, -4},\n+                {1, 3, -4},\n                 {-4, -4, 8}\n         });\n         EigenDecomposition ed = new EigenDecompositionImpl(distinct, MathUtils.SAFE_MIN);\n         checkEigenVector((new double[] {1, 1, 1}), ed, 1E-12);\n         checkEigenVector((new double[] {-1, -1, 2}), ed, 1E-12);\n     }\n-    \n+\n     /**\n      * Verifies that the given EigenDecomposition has eigenvalues equivalent to\n      * the targetValues, ignoring the order of the values and allowing\n             assertTrue(isIncludedValue(targetValues[i], observed, tolerance));\n         }\n     }\n-    \n+\n     /**\n      * Returns true iff there is an entry within tolerance of value in\n      * searchArray.\n        }\n        return found;\n     }\n-    \n+\n     /**\n      * Returns true iff eigenVector is a scalar multiple of one of the columns\n      * of ed.getV().  Does not try linear combinations - i.e., should only be\n             EigenDecomposition ed, double tolerance) {\n         assertTrue(isIncludedColumn(eigenVector, ed.getV(), tolerance));\n     }\n-    \n+\n     /**\n      * Returns true iff there is a column that is a scalar multiple of column\n      * in searchMatrix (modulo tolerance)\n                 if (Math.abs(multiplier - 1.0) <= Math.ulp(1.0) && Math.abs(colEntry) > 1E-14\n                         && Math.abs(column[j]) > 1e-14) {\n                     multiplier = colEntry / column[j];\n-                } \n+                }\n                 if (Math.abs(column[j] * multiplier - colEntry) > tolerance) {\n                     matching = false;\n                 }\n--- a/src/test/java/org/apache/commons/math/linear/FieldLUDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/FieldLUDecompositionImplTest.java\n             { new Fraction(2), new Fraction(3), new Fraction(7) },\n             { new Fraction(6), new Fraction(6), new Fraction(8) }\n     };\n-    \n+\n     // singular matrices\n     private Fraction[][] singular = {\n             { new Fraction(2), new Fraction(3) },\n         assertTrue(l == lu.getL());\n         assertTrue(u == lu.getU());\n         assertTrue(p == lu.getP());\n-        \n+\n     }\n \n     /** test matrices values */\n         assertTrue(l == lu.getL());\n         assertTrue(u == lu.getU());\n         assertTrue(p == lu.getP());\n-        \n+\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  */\n \n public final class FieldMatrixImplTest extends TestCase {\n-    \n+\n     // 3 x 3 identity matrix\n     protected Fraction[][] id = { {new Fraction(1),new Fraction(0),new Fraction(0)}, {new Fraction(0),new Fraction(1),new Fraction(0)}, {new Fraction(0),new Fraction(0),new Fraction(1)} };\n-    \n+\n     // Test data for group operations\n     protected Fraction[][] testData = { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(5),new Fraction(3)}, {new Fraction(1),new Fraction(0),new Fraction(8)} };\n     protected Fraction[][] testDataLU = {{new Fraction(2), new Fraction(5), new Fraction(3)}, {new Fraction(1, 2), new Fraction(-5, 2), new Fraction(13, 2)}, {new Fraction(1, 2), new Fraction(1, 5), new Fraction(1, 5)}};\n     protected Fraction[][] testDataPlus2 = { {new Fraction(3),new Fraction(4),new Fraction(5)}, {new Fraction(4),new Fraction(7),new Fraction(5)}, {new Fraction(3),new Fraction(2),new Fraction(10)} };\n-    protected Fraction[][] testDataMinus = { {new Fraction(-1),new Fraction(-2),new Fraction(-3)}, {new Fraction(-2),new Fraction(-5),new Fraction(-3)}, \n+    protected Fraction[][] testDataMinus = { {new Fraction(-1),new Fraction(-2),new Fraction(-3)}, {new Fraction(-2),new Fraction(-5),new Fraction(-3)},\n        {new Fraction(-1),new Fraction(0),new Fraction(-8)} };\n     protected Fraction[] testDataRow1 = {new Fraction(1),new Fraction(2),new Fraction(3)};\n     protected Fraction[] testDataCol3 = {new Fraction(3),new Fraction(3),new Fraction(8)};\n-    protected Fraction[][] testDataInv = \n+    protected Fraction[][] testDataInv =\n         { {new Fraction(-40),new Fraction(16),new Fraction(9)}, {new Fraction(13),new Fraction(-5),new Fraction(-3)}, {new Fraction(5),new Fraction(-2),new Fraction(-1)} };\n     protected Fraction[] preMultTest = {new Fraction(8),new Fraction(12),new Fraction(33)};\n     protected Fraction[][] testData2 ={ {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(5),new Fraction(3)}};\n     protected Fraction[][] testData2T = { {new Fraction(1),new Fraction(2)}, {new Fraction(2),new Fraction(5)}, {new Fraction(3),new Fraction(3)}};\n-    protected Fraction[][] testDataPlusInv = \n+    protected Fraction[][] testDataPlusInv =\n         { {new Fraction(-39),new Fraction(18),new Fraction(12)}, {new Fraction(15),new Fraction(0),new Fraction(0)}, {new Fraction(6),new Fraction(-2),new Fraction(7)} };\n-    \n+\n     // lu decomposition tests\n     protected Fraction[][] luData = { {new Fraction(2),new Fraction(3),new Fraction(3)}, {new Fraction(0),new Fraction(5),new Fraction(7)}, {new Fraction(6),new Fraction(9),new Fraction(8)} };\n     protected Fraction[][] luDataLUDecomposition = { {new Fraction(6),new Fraction(9),new Fraction(8)}, {new Fraction(0),new Fraction(5),new Fraction(7)},\n             {new Fraction(1, 3),new Fraction(0),new Fraction(1, 3)} };\n-    \n+\n     // singular matrices\n     protected Fraction[][] singular = { {new Fraction(2),new Fraction(3)}, {new Fraction(2),new Fraction(3)} };\n     protected Fraction[][] bigSingular = {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)}, {new Fraction(2),new Fraction(5),new Fraction(3),new Fraction(4)},\n         {new Fraction(7),new Fraction(3),new Fraction(256),new Fraction(1930)}, {new Fraction(3),new Fraction(7),new Fraction(6),new Fraction(8)}}; // 4th row = 1st + 2nd\n     protected Fraction[][] detData = { {new Fraction(1),new Fraction(2),new Fraction(3)}, {new Fraction(4),new Fraction(5),new Fraction(6)}, {new Fraction(7),new Fraction(8),new Fraction(10)} };\n     protected Fraction[][] detData2 = { {new Fraction(1), new Fraction(3)}, {new Fraction(2), new Fraction(4)}};\n-    \n+\n     // vectors\n     protected Fraction[] testVector = {new Fraction(1),new Fraction(2),new Fraction(3)};\n     protected Fraction[] testVector2 = {new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)};\n-    \n+\n     // submatrix accessor tests\n     protected Fraction[][] subTestData = {{new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4)}, {new Fraction(3, 2), new Fraction(5, 2), new Fraction(7, 2), new Fraction(9, 2)},\n-            {new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8)}, {new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7)}}; \n+            {new Fraction(2), new Fraction(4), new Fraction(6), new Fraction(8)}, {new Fraction(4), new Fraction(5), new Fraction(6), new Fraction(7)}};\n     // array selections\n     protected Fraction[][] subRows02Cols13 = { {new Fraction(2), new Fraction(4)}, {new Fraction(4), new Fraction(8)}};\n     protected Fraction[][] subRows03Cols12 = { {new Fraction(2), new Fraction(3)}, {new Fraction(5), new Fraction(6)}};\n     // column matrices\n     protected Fraction[][] subColumn1 = {{new Fraction(2)}, {new Fraction(5, 2)}, {new Fraction(4)}, {new Fraction(5)}};\n     protected Fraction[][] subColumn3 = {{new Fraction(4)}, {new Fraction(9, 2)}, {new Fraction(8)}, {new Fraction(7)}};\n-    \n+\n     // tolerances\n     protected double entryTolerance = 10E-16;\n     protected double normTolerance = 10E-14;\n-    \n+\n     public FieldMatrixImplTest(String name) {\n         super(name);\n     }\n-    \n+\n     public static Test suite() {\n         TestSuite suite = new TestSuite(FieldMatrixImplTest.class);\n         suite.setName(\"Array2DRowFieldMatrix<Fraction> Tests\");\n         return suite;\n     }\n-    \n+\n     /** test dimensions */\n     public void testDimensions() {\n         Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n         assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n         assertTrue(\"testData2 is not square\",!m2.isSquare());\n-    } \n-    \n+    }\n+\n     /** test copy functions */\n     public void testCopyFunctions() {\n         Array2DRowFieldMatrix<Fraction> m1 = new Array2DRowFieldMatrix<Fraction>(testData);\n         Array2DRowFieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(testData);\n         Array2DRowFieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(m3.getData(), false);\n         assertEquals(m4,m3);\n-    }           \n-    \n+    }\n+\n     /** test add */\n     public void testAdd() {\n         Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n             for (int col = 0; col < m.getColumnDimension(); col++) {\n                 assertEquals(testDataPlusInv[row][col],sumEntries[row][col]);\n             }\n-        }    \n-    }\n-    \n+        }\n+    }\n+\n     /** test add failure */\n     public void testAddFail() {\n         Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n             // ignored\n         }\n     }\n-    \n+\n      /** test m-n = m + -n */\n     public void testPlusMinus() {\n         Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(testDataInv);\n-        TestUtils.assertEquals(m.subtract(m2),m2.scalarMultiply(new Fraction(-1)).add(m));        \n+        TestUtils.assertEquals(m.subtract(m2),m2.scalarMultiply(new Fraction(-1)).add(m));\n         try {\n             m.subtract(new Array2DRowFieldMatrix<Fraction>(testData2));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n-    }\n-   \n+        }\n+    }\n+\n     /** test multiply */\n      public void testMultiply() {\n         Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         TestUtils.assertEquals(mInv.multiply(m), identity);\n         TestUtils.assertEquals(m.multiply(identity), m);\n         TestUtils.assertEquals(identity.multiply(mInv), mInv);\n-        TestUtils.assertEquals(m2.multiply(identity), m2); \n+        TestUtils.assertEquals(m2.multiply(identity), m2);\n         try {\n             m.multiply(new Array2DRowFieldMatrix<Fraction>(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n-    }   \n-    \n+        }\n+    }\n+\n     //Additional Test for Array2DRowFieldMatrix<Fraction>Test.testMultiply\n \n     private Fraction[][] d3 = new Fraction[][] {{new Fraction(1),new Fraction(2),new Fraction(3),new Fraction(4)},{new Fraction(5),new Fraction(6),new Fraction(7),new Fraction(8)}};\n     private Fraction[][] d4 = new Fraction[][] {{new Fraction(1)},{new Fraction(2)},{new Fraction(3)},{new Fraction(4)}};\n     private Fraction[][] d5 = new Fraction[][] {{new Fraction(30)},{new Fraction(70)}};\n-     \n-    public void testMultiply2() { \n-       FieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(d3);   \n+\n+    public void testMultiply2() {\n+       FieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(d3);\n        FieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(d4);\n        FieldMatrix<Fraction> m5 = new Array2DRowFieldMatrix<Fraction>(d5);\n        TestUtils.assertEquals(m3.multiply(m4), m5);\n-   }  \n-        \n+   }\n+\n     /** test trace */\n     public void testTrace() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(id);\n             fail(\"Expecting NonSquareMatrixException\");\n         } catch (NonSquareMatrixException ex) {\n             // ignored\n-        }      \n-    }\n-    \n+        }\n+    }\n+\n     /** test sclarAdd */\n     public void testScalarAdd() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         TestUtils.assertEquals(new Array2DRowFieldMatrix<Fraction>(testDataPlus2), m.scalarAdd(new Fraction(2)));\n     }\n-                    \n+\n     /** test operate */\n     public void testOperate() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(id);\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n+        }\n     }\n \n     /** test issue MATH-209 */\n         assertEquals( new Fraction(7), b[1]);\n         assertEquals(new Fraction(11), b[2]);\n     }\n-    \n+\n     /** test transpose */\n     public void testTranspose() {\n-        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData); \n+        FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();\n         FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();\n         TestUtils.assertEquals(mIT, mTI);\n         FieldMatrix<Fraction> mt = new Array2DRowFieldMatrix<Fraction>(testData2T);\n         TestUtils.assertEquals(mt, m.transpose());\n     }\n-    \n+\n     /** test preMultiply by vector */\n     public void testPremultiplyVector() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n             // ignored\n         }\n     }\n-    \n+\n     public void testPremultiply() {\n-        FieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(d3);   \n+        FieldMatrix<Fraction> m3 = new Array2DRowFieldMatrix<Fraction>(d3);\n         FieldMatrix<Fraction> m4 = new Array2DRowFieldMatrix<Fraction>(d4);\n         FieldMatrix<Fraction> m5 = new Array2DRowFieldMatrix<Fraction>(d5);\n         TestUtils.assertEquals(m4.preMultiply(m3), m5);\n-        \n+\n         Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         Array2DRowFieldMatrix<Fraction> mInv = new Array2DRowFieldMatrix<Fraction>(testDataInv);\n         Array2DRowFieldMatrix<Fraction> identity = new Array2DRowFieldMatrix<Fraction>(id);\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n-    }\n-    \n+        }\n+    }\n+\n     public void testGetVectors() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         TestUtils.assertEquals(m.getRow(0), testDataRow1);\n             // ignored\n         }\n     }\n-    \n+\n     public void testGetEntry() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         assertEquals(\"get entry\",m.getEntry(0,1),new Fraction(2));\n             // expected\n         }\n     }\n-        \n+\n     /** test examples in user guide */\n     public void testExamples() {\n         // Create a real matrix with two rows and three columns\n         assertEquals(2, p.getRowDimension());\n         assertEquals(2, p.getColumnDimension());\n         // Invert p\n-        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse(); \n+        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse();\n         assertEquals(2, pInverse.getRowDimension());\n         assertEquals(2, pInverse.getColumnDimension());\n-        \n+\n         // Solve example\n         Fraction[][] coefficientsData = {\n                 {new Fraction(2), new Fraction(3), new Fraction(-2)},\n                      add(new Fraction(6).multiply(solution[2])), constants[1]);\n         assertEquals(new Fraction(4).multiply(solution[0]).\n                      subtract(new Fraction(3).multiply(solution[1])).\n-                     subtract(new Fraction(5).multiply(solution[2])), constants[2]);   \n-        \n-    }\n-    \n+                     subtract(new Fraction(5).multiply(solution[2])), constants[2]);\n+\n+    }\n+\n     // test submatrix accessors\n     public void testGetSubMatrix() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0);\n         checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3);\n-        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);   \n-        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });  \n-        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });  \n-        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); \n-        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); \n-        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n-        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n+        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3);\n+        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });\n+        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });\n+        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });\n+        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });\n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });\n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });\n         checkGetSubMatrix(m, null,  1, 0, 2, 4);\n         checkGetSubMatrix(m, null, -1, 1, 2, 2);\n         checkGetSubMatrix(m, null,  1, 0, 2, 2);\n             }\n         }\n     }\n-    \n+\n     private void checkGetSubMatrix(FieldMatrix<Fraction> m, Fraction[][] reference,\n                                    int[] selectedRows, int[] selectedColumns) {\n         try {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0);\n         checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3);\n-        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);   \n-        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });  \n-        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });  \n-        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }); \n-        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }); \n-        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n-        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 }); \n-        \n+        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3);\n+        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 });\n+        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 });\n+        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 });\n+        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 });\n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });\n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 });\n+\n         checkCopy(m, null,  1, 0, 2, 4);\n         checkCopy(m, null, -1, 1, 2, 2);\n         checkCopy(m, null,  1, 0, 2, 2);\n             }\n         }\n     }\n-    \n+\n     private void checkCopy(FieldMatrix<Fraction> m, Fraction[][] reference,\n                            int[] selectedRows, int[] selectedColumns) {\n         try {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         FieldMatrix<Fraction> mRow0 = new Array2DRowFieldMatrix<Fraction>(subRow0);\n         FieldMatrix<Fraction> mRow3 = new Array2DRowFieldMatrix<Fraction>(subRow3);\n-        assertEquals(\"Row0\", mRow0, \n+        assertEquals(\"Row0\", mRow0,\n                 m.getRowMatrix(0));\n-        assertEquals(\"Row3\", mRow3, \n+        assertEquals(\"Row3\", mRow3,\n                 m.getRowMatrix(3));\n         try {\n             m.getRowMatrix(-1);\n             // expected\n         }\n     }\n-    \n+\n     public void testSetRowMatrix() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         FieldMatrix<Fraction> mRow3 = new Array2DRowFieldMatrix<Fraction>(subRow3);\n             // expected\n         }\n     }\n-    \n+\n     public void testGetColumnMatrix() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         FieldMatrix<Fraction> mColumn1 = new Array2DRowFieldMatrix<Fraction>(subColumn1);\n         FieldMatrix<Fraction> mColumn3 = new Array2DRowFieldMatrix<Fraction>(subColumn3);\n-        assertEquals(\"Column1\", mColumn1, \n+        assertEquals(\"Column1\", mColumn1,\n                 m.getColumnMatrix(1));\n-        assertEquals(\"Column3\", mColumn3, \n+        assertEquals(\"Column3\", mColumn3,\n                 m.getColumnMatrix(3));\n         try {\n             m.getColumnMatrix(-1);\n             // expected\n         }\n     }\n-    \n+\n     public void testGetColumnVector() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         FieldVector<Fraction> mColumn1 = columnToVector(subColumn1);\n             // expected\n         }\n     }\n-    \n+\n     public void testGetColumn() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(subTestData);\n         Fraction[] mColumn1 = columnToArray(subColumn1);\n     private void checkArrays(Fraction[] expected, Fraction[] actual) {\n         assertEquals(expected.length, actual.length);\n         for (int i = 0; i < expected.length; ++i) {\n-            assertEquals(expected[i], actual[i]);            \n-        }\n-    }\n-    \n+            assertEquals(expected[i], actual[i]);\n+        }\n+    }\n+\n     public void testEqualsAndHashCode() {\n         Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         Array2DRowFieldMatrix<Fraction> m1 = (Array2DRowFieldMatrix<Fraction>) m.copy();\n         assertEquals(m, m1);\n         assertFalse(m.equals(null));\n         assertFalse(m.equals(mt));\n-        assertFalse(m.equals(new Array2DRowFieldMatrix<Fraction>(bigSingular))); \n-    }\n-    \n+        assertFalse(m.equals(new Array2DRowFieldMatrix<Fraction>(bigSingular)));\n+    }\n+\n     public void testToString() {\n         Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         assertEquals(\"Array2DRowFieldMatrix{{1,2,3},{2,5,3},{1,0,8}}\", m.toString());\n         m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance());\n         assertEquals(\"Array2DRowFieldMatrix{}\", m.toString());\n     }\n-    \n+\n     public void testSetSubMatrix() throws Exception {\n         Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         m.setSubMatrix(detData2,1,1);\n                     {new Fraction(2),new Fraction(1),new Fraction(3)},\n                     {new Fraction(1),new Fraction(2),new Fraction(4)}\n              });\n-        assertEquals(expected, m);  \n-        \n+        assertEquals(expected, m);\n+\n         m.setSubMatrix(detData2,0,0);\n         expected = new Array2DRowFieldMatrix<Fraction>\n             (new Fraction[][] {\n                     {new Fraction(2),new Fraction(4),new Fraction(3)},\n                     {new Fraction(1),new Fraction(2),new Fraction(4)}\n              });\n-        assertEquals(expected, m);  \n-        \n-        m.setSubMatrix(testDataPlus2,0,0);      \n+        assertEquals(expected, m);\n+\n+        m.setSubMatrix(testDataPlus2,0,0);\n         expected = new Array2DRowFieldMatrix<Fraction>\n             (new Fraction[][] {\n                     {new Fraction(3),new Fraction(4),new Fraction(5)},\n                     {new Fraction(4),new Fraction(7),new Fraction(5)},\n                     {new Fraction(3),new Fraction(2),new Fraction(10)}\n              });\n-        assertEquals(expected, m);   \n-        \n+        assertEquals(expected, m);\n+\n         // dimension overflow\n-        try {  \n+        try {\n             m.setSubMatrix(testData,1,1);\n             fail(\"expecting MatrixIndexException\");\n         } catch (MatrixIndexException e) {\n             // expected\n         }\n         // dimension underflow\n-        try {  \n+        try {\n             m.setSubMatrix(testData,-1,1);\n             fail(\"expecting MatrixIndexException\");\n         } catch (MatrixIndexException e) {\n             // expected\n         }\n-        try {  \n+        try {\n             m.setSubMatrix(testData,1,-1);\n             fail(\"expecting MatrixIndexException\");\n         } catch (MatrixIndexException e) {\n             // expected\n         }\n-        \n+\n         // null\n         try {\n             m.setSubMatrix(null,1,1);\n         } catch (IllegalStateException e) {\n             // expected\n         }\n-        \n+\n         // ragged\n         try {\n             m.setSubMatrix(new Fraction[][] {{new Fraction(1)}, {new Fraction(2), new Fraction(3)}}, 0, 0);\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-       \n+\n         // empty\n         try {\n             m.setSubMatrix(new Fraction[][] {{}}, 0, 0);\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n     }\n \n     public void testWalk() {\n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, 0));\n             assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(0, j));\n             assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, 0));\n             assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(0, j));\n             assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n         m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, 0));\n             assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(0, j));\n             assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n         m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(new Fraction(0), m.getEntry(i, 0));                    \n+            assertEquals(new Fraction(0), m.getEntry(i, 0));\n             assertEquals(new Fraction(0), m.getEntry(i, columns - 1));\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(new Fraction(0), m.getEntry(0, j));                    \n+            assertEquals(new Fraction(0), m.getEntry(0, j));\n             assertEquals(new Fraction(0), m.getEntry(rows - 1, j));\n         }\n \n         Array2DRowFieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n         assertEquals(m,TestUtils.serializeAndRecover(m));\n     }\n-  \n+\n     private static class SetVisitor extends DefaultFieldMatrixChangingVisitor<Fraction> {\n         public SetVisitor() {\n             super(Fraction.ZERO);\n     }\n \n     //--------------- -----------------Protected methods\n-    \n+\n     /** extracts the l  and u matrices from compact lu representation */\n     protected void splitLU(FieldMatrix<Fraction> lu,\n                            Fraction[][] lowerData,\n                            Fraction[][] upperData)\n-        throws InvalidMatrixException {   \n+        throws InvalidMatrixException {\n         if (!lu.isSquare() ||\n             lowerData.length != lowerData[0].length ||\n             upperData.length != upperData[0].length ||\n             lowerData.length != upperData.length ||\n             lowerData.length != lu.getRowDimension()) {\n             throw new InvalidMatrixException(\"incorrect dimensions\");\n-        }    \n+        }\n         int n = lu.getRowDimension();\n         for (int i = 0; i < n; i++) {\n             for (int j = 0; j < n; j++) {\n                 } else {\n                     lowerData[i][j] = Fraction.ZERO;\n                     upperData[i][j] = lu.getEntry(i, j);\n-                }   \n+                }\n             }\n         }\n     }\n-    \n+\n     /** Returns the result of applying the given row permutation to the matrix */\n     protected FieldMatrix<Fraction> permuteRows(FieldMatrix<Fraction> matrix, int[] permutation) {\n         if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {\n         }\n         return new Array2DRowFieldMatrix<Fraction>(out);\n     }\n-    \n+\n }\n \n--- a/src/test/java/org/apache/commons/math/linear/FrenchRealVectorFormatTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/FrenchRealVectorFormatTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/test/java/org/apache/commons/math/linear/InvalidMatrixExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/InvalidMatrixExceptionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * @version $Revision$ $Date$\n  */\n public class InvalidMatrixExceptionTest extends TestCase {\n-    \n+\n     public void testConstructorMessage(){\n         String msg = \"message\";\n         InvalidMatrixException ex = new InvalidMatrixException(msg);\n--- a/src/test/java/org/apache/commons/math/linear/LUDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/LUDecompositionImplTest.java\n             { 0.0, 5.0, 7.0 },\n             { 6.0, 9.0, 8.0 }\n     };\n-    \n+\n     // singular matrices\n     private double[][] singular = {\n             { 2.0, 3.0 },\n         assertTrue(l == lu.getL());\n         assertTrue(u == lu.getU());\n         assertTrue(p == lu.getP());\n-        \n+\n     }\n \n     /** test matrices values */\n         assertTrue(l == lu.getL());\n         assertTrue(u == lu.getU());\n         assertTrue(p == lu.getP());\n-        \n+\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/linear/LUSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/LUSolverTest.java\n             { 0.0, 5.0, 7.0 },\n             { 6.0, 9.0, 8.0 }\n     };\n-    \n+\n     // singular matrices\n     private double[][] singular = {\n             { 2.0, 3.0 },\n--- a/src/test/java/org/apache/commons/math/linear/MatrixIndexExceptionTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/MatrixIndexExceptionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * @version $Revision$ $Date$\n  */\n public class MatrixIndexExceptionTest extends TestCase {\n-    \n+\n     /**\n-     * \n+     *\n      */\n     public void testConstructorMessage(){\n         String msg = \"message\";\n--- a/src/test/java/org/apache/commons/math/linear/MatrixUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/MatrixUtilsTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  */\n \n public final class MatrixUtilsTest extends TestCase {\n-    \n+\n     protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };\n     protected double[][] nullMatrix = null;\n     protected double[] row = {1,2,3};\n-    protected BigDecimal[] bigRow = \n+    protected BigDecimal[] bigRow =\n         {new BigDecimal(1),new BigDecimal(2),new BigDecimal(3)};\n     protected String[] stringRow = {\"1\", \"2\", \"3\"};\n-    protected Fraction[] fractionRow = \n+    protected Fraction[] fractionRow =\n         {new Fraction(1),new Fraction(2),new Fraction(3)};\n     protected double[][] rowMatrix = {{1,2,3}};\n-    protected BigDecimal[][] bigRowMatrix = \n+    protected BigDecimal[][] bigRowMatrix =\n         {{new BigDecimal(1), new BigDecimal(2), new BigDecimal(3)}};\n     protected String[][] stringRowMatrix = {{\"1\", \"2\", \"3\"}};\n-    protected Fraction[][] fractionRowMatrix = \n+    protected Fraction[][] fractionRowMatrix =\n         {{new Fraction(1), new Fraction(2), new Fraction(3)}};\n     protected double[] col = {0,4,6};\n-    protected BigDecimal[] bigCol = \n+    protected BigDecimal[] bigCol =\n         {new BigDecimal(0),new BigDecimal(4),new BigDecimal(6)};\n     protected String[] stringCol = {\"0\",\"4\",\"6\"};\n-    protected Fraction[] fractionCol = \n+    protected Fraction[] fractionCol =\n         {new Fraction(0),new Fraction(4),new Fraction(6)};\n     protected double[] nullDoubleArray = null;\n     protected double[][] colMatrix = {{0},{4},{6}};\n-    protected BigDecimal[][] bigColMatrix = \n+    protected BigDecimal[][] bigColMatrix =\n         {{new BigDecimal(0)},{new BigDecimal(4)},{new BigDecimal(6)}};\n     protected String[][] stringColMatrix = {{\"0\"}, {\"4\"}, {\"6\"}};\n-    protected Fraction[][] fractionColMatrix = \n+    protected Fraction[][] fractionColMatrix =\n         {{new Fraction(0)},{new Fraction(4)},{new Fraction(6)}};\n-    \n+\n     public MatrixUtilsTest(String name) {\n         super(name);\n     }\n-    \n+\n \n     public static Test suite() {\n         TestSuite suite = new TestSuite(MatrixUtilsTest.class);\n         suite.setName(\"MatrixUtils Tests\");\n         return suite;\n     }\n-    \n+\n     public void testCreateRealMatrix() {\n-        assertEquals(new BlockRealMatrix(testData), \n+        assertEquals(new BlockRealMatrix(testData),\n                 MatrixUtils.createRealMatrix(testData));\n         try {\n             MatrixUtils.createRealMatrix(new double[][] {{1}, {1,2}});  // ragged\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        } \n+        }\n         try {\n             MatrixUtils.createRealMatrix(new double[][] {{}, {}});  // no columns\n             fail(\"Expecting IllegalArgumentException\");\n             fail(\"Expecting NullPointerException\");\n         } catch (NullPointerException ex) {\n             // expected\n-        } \n+        }\n     }\n \n     public void testcreateFieldMatrix() {\n-        assertEquals(new Array2DRowFieldMatrix<Fraction>(asFraction(testData)), \n+        assertEquals(new Array2DRowFieldMatrix<Fraction>(asFraction(testData)),\n                      MatrixUtils.createFieldMatrix(asFraction(testData)));\n-        assertEquals(new Array2DRowFieldMatrix<Fraction>(fractionColMatrix), \n+        assertEquals(new Array2DRowFieldMatrix<Fraction>(fractionColMatrix),\n                      MatrixUtils.createFieldMatrix(fractionColMatrix));\n         try {\n             MatrixUtils.createFieldMatrix(asFraction(new double[][] {{1}, {1,2}}));  // ragged\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        } \n+        }\n         try {\n             MatrixUtils.createFieldMatrix(asFraction(new double[][] {{}, {}}));  // no columns\n             fail(\"Expecting IllegalArgumentException\");\n             fail(\"Expecting NullPointerException\");\n         } catch (NullPointerException ex) {\n             // expected\n-        } \n+        }\n     }\n \n     @Deprecated\n     public void testCreateBigMatrix() {\n-        assertEquals(new BigMatrixImpl(testData), \n+        assertEquals(new BigMatrixImpl(testData),\n                 MatrixUtils.createBigMatrix(testData));\n-        assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), true), \n+        assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), true),\n                 MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), false));\n-        assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), false), \n+        assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), false),\n                 MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), true));\n-        assertEquals(new BigMatrixImpl(bigColMatrix), \n+        assertEquals(new BigMatrixImpl(bigColMatrix),\n                 MatrixUtils.createBigMatrix(bigColMatrix));\n-        assertEquals(new BigMatrixImpl(stringColMatrix), \n+        assertEquals(new BigMatrixImpl(stringColMatrix),\n                 MatrixUtils.createBigMatrix(stringColMatrix));\n         try {\n             MatrixUtils.createBigMatrix(new double[][] {{1}, {1,2}});  // ragged\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        } \n+        }\n         try {\n             MatrixUtils.createBigMatrix(new double[][] {{}, {}});  // no columns\n             fail(\"Expecting IllegalArgumentException\");\n             fail(\"Expecting NullPointerException\");\n         } catch (NullPointerException ex) {\n             // expected\n-        } \n-    }\n-        \n+        }\n+    }\n+\n     public void testCreateRowRealMatrix() {\n         assertEquals(MatrixUtils.createRowRealMatrix(row),\n                      new BlockRealMatrix(rowMatrix));\n             fail(\"Expecting NullPointerException\");\n         } catch (NullPointerException ex) {\n             // expected\n-        } \n-    }\n-    \n+        }\n+    }\n+\n     public void testCreateRowFieldMatrix() {\n         assertEquals(MatrixUtils.createRowFieldMatrix(asFraction(row)),\n                      new Array2DRowFieldMatrix<Fraction>(asFraction(rowMatrix)));\n             fail(\"Expecting NullPointerException\");\n         } catch (NullPointerException ex) {\n             // expected\n-        } \n+        }\n     }\n \n     @Deprecated\n             fail(\"Expecting NullPointerException\");\n         } catch (NullPointerException ex) {\n             // expected\n-        } \n+        }\n     }\n \n     public void testCreateColumnRealMatrix() {\n             fail(\"Expecting NullPointerException\");\n         } catch (NullPointerException ex) {\n             // expected\n-        } \n-    }\n-    \n+        }\n+    }\n+\n     public void testCreateColumnFieldMatrix() {\n         assertEquals(MatrixUtils.createColumnFieldMatrix(asFraction(col)),\n                      new Array2DRowFieldMatrix<Fraction>(asFraction(colMatrix)));\n             fail(\"Expecting NullPointerException\");\n         } catch (NullPointerException ex) {\n             // expected\n-        } \n+        }\n     }\n \n     @Deprecated\n         assertEquals(MatrixUtils.createColumnBigMatrix(bigCol),\n                 new BigMatrixImpl(bigColMatrix));\n         assertEquals(MatrixUtils.createColumnBigMatrix(stringCol),\n-                new BigMatrixImpl(stringColMatrix));   \n-       \n+                new BigMatrixImpl(stringColMatrix));\n+\n         try {\n             MatrixUtils.createColumnBigMatrix(new double[] {});  // empty\n             fail(\"Expecting IllegalArgumentException\");\n             fail(\"Expecting NullPointerException\");\n         } catch (NullPointerException ex) {\n             // expected\n-        } \n+        }\n     }\n \n     /**\n                     assertEquals(m.getEntry(i, j), 0d, 0);\n                 }\n             }\n-        }   \n-    }\n-    \n+        }\n+    }\n+\n     public void testCreateIdentityMatrix() {\n         checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(3));\n         checkIdentityMatrix(MatrixUtils.createRealIdentityMatrix(2));\n             // expected\n         }\n     }\n-    \n+\n     /**\n      * Verifies that the matrix is an identity matrix\n      */\n                     assertEquals(m.getEntry(i, j), Fraction.ZERO);\n                 }\n             }\n-        }   \n-    }\n-    \n+        }\n+    }\n+\n     public void testcreateFieldIdentityMatrix() {\n         checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 3));\n         checkIdentityFieldMatrix(MatrixUtils.createFieldIdentityMatrix(FractionField.getInstance(), 2));\n                     assertEquals(m.getEntry(i, j), BigMatrixImpl.ZERO);\n                 }\n             }\n-        }   \n+        }\n     }\n \n     @Deprecated\n--- a/src/test/java/org/apache/commons/math/linear/QRDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/QRDecompositionImplTest.java\n import junit.framework.TestSuite;\n \n public class QRDecompositionImplTest extends TestCase {\n-    double[][] testData3x3NonSingular = { \n-            { 12, -51, 4 }, \n+    double[][] testData3x3NonSingular = {\n+            { 12, -51, 4 },\n             { 6, 167, -68 },\n             { -4, 24, -41 }, };\n \n-    double[][] testData3x3Singular = { \n-            { 1, 4, 7, }, \n+    double[][] testData3x3Singular = {\n+            { 1, 4, 7, },\n             { 2, 5, 8, },\n             { 3, 6, 9, }, };\n \n-    double[][] testData3x4 = { \n-            { 12, -51, 4, 1 }, \n+    double[][] testData3x4 = {\n+            { 12, -51, 4, 1 },\n             { 6, 167, -68, 2 },\n             { -4, 24, -41, 3 }, };\n \n-    double[][] testData4x3 = { \n-            { 12, -51, 4, }, \n+    double[][] testData4x3 = {\n+            { 12, -51, 4, },\n             { 6, 167, -68, },\n-            { -4, 24, -41, }, \n+            { -4, 24, -41, },\n             { -5, 34, 7, }, };\n \n     private static final double entryTolerance = 10e-16;\n         assertEquals(rows,    qr.getQ().getRowDimension());\n         assertEquals(rows,    qr.getQ().getColumnDimension());\n         assertEquals(rows,    qr.getR().getRowDimension());\n-        assertEquals(columns, qr.getR().getColumnDimension());        \n+        assertEquals(columns, qr.getR().getColumnDimension());\n     }\n \n     /** test A = QR */\n         assertTrue(q == qr.getQ());\n         assertTrue(r == qr.getR());\n         assertTrue(h == qr.getH());\n-        \n+\n     }\n \n     private RealMatrix createTestMatrix(final Random r, final int rows, final int columns) {\n--- a/src/test/java/org/apache/commons/math/linear/QRSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/QRSolverTest.java\n import org.apache.commons.math.linear.ArrayRealVector;\n \n public class QRSolverTest extends TestCase {\n-    double[][] testData3x3NonSingular = { \n-            { 12, -51,   4 }, \n+    double[][] testData3x3NonSingular = {\n+            { 12, -51,   4 },\n             {  6, 167, -68 },\n             { -4,  24, -41 }\n     };\n \n-    double[][] testData3x3Singular = { \n-            { 1, 2,  2 }, \n+    double[][] testData3x3Singular = {\n+            { 1, 2,  2 },\n             { 2, 4,  6 },\n             { 4, 8, 12 }\n     };\n \n-    double[][] testData3x4 = { \n-            { 12, -51,   4, 1 }, \n+    double[][] testData3x4 = {\n+            { 12, -51,   4, 1 },\n             {  6, 167, -68, 2 },\n             { -4,  24, -41, 3 }\n     };\n \n-    double[][] testData4x3 = { \n-            { 12, -51,   4 }, \n+    double[][] testData4x3 = {\n+            { 12, -51,   4 },\n             {  6, 167, -68 },\n-            { -4,  24, -41 }, \n+            { -4,  24, -41 },\n             { -5,  34,   7 }\n     };\n \n--- a/src/test/java/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/RealMatrixImplTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  */\n @Deprecated\n public final class RealMatrixImplTest extends TestCase {\n-    \n+\n     // 3 x 3 identity matrix\n     protected double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };\n-    \n+\n     // Test data for group operations\n     protected double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };\n     protected double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};\n     protected double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };\n-    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, \n+    protected double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d},\n        {-1d,0d,-8d} };\n     protected double[] testDataRow1 = {1d,2d,3d};\n     protected double[] testDataCol3 = {3d,3d,8d};\n-    protected double[][] testDataInv = \n+    protected double[][] testDataInv =\n         { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };\n     protected double[] preMultTest = {8,12,33};\n     protected double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};\n     protected double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};\n-    protected double[][] testDataPlusInv = \n+    protected double[][] testDataPlusInv =\n         { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };\n-    \n+\n     // lu decomposition tests\n     protected double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };\n     protected double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d},\n             {0.33333333333333,0d,0.33333333333333} };\n-    \n+\n     // singular matrices\n     protected double[][] singular = { {2d,3d}, {2d,3d} };\n     protected double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},\n         {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd\n     protected double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };\n     protected double[][] detData2 = { {1d, 3d}, {2d, 4d}};\n-    \n+\n     // vectors\n     protected double[] testVector = {1,2,3};\n     protected double[] testVector2 = {1,2,3,4};\n-    \n+\n     // submatrix accessor tests\n     protected double[][] subTestData = {{1, 2, 3, 4}, {1.5, 2.5, 3.5, 4.5},\n-            {2, 4, 6, 8}, {4, 5, 6, 7}}; \n+            {2, 4, 6, 8}, {4, 5, 6, 7}};\n     // array selections\n     protected double[][] subRows02Cols13 = { {2, 4}, {4, 8}};\n     protected double[][] subRows03Cols12 = { {2, 3}, {5, 6}};\n     // column matrices\n     protected double[][] subColumn1 = {{2}, {2.5}, {4}, {5}};\n     protected double[][] subColumn3 = {{4}, {4.5}, {8}, {7}};\n-    \n+\n     // tolerances\n     protected double entryTolerance = 10E-16;\n     protected double normTolerance = 10E-14;\n-    \n+\n     public RealMatrixImplTest(String name) {\n         super(name);\n     }\n-    \n+\n     public static Test suite() {\n         TestSuite suite = new TestSuite(RealMatrixImplTest.class);\n         suite.setName(\"RealMatrixImpl Tests\");\n         return suite;\n     }\n-    \n+\n     /** test dimensions */\n     public void testDimensions() {\n         RealMatrixImpl m = new RealMatrixImpl(testData);\n         assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n         assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n         assertTrue(\"testData2 is not square\",!m2.isSquare());\n-    } \n-    \n+    }\n+\n     /** test copy functions */\n     public void testCopyFunctions() {\n         RealMatrixImpl m1 = new RealMatrixImpl(testData);\n         RealMatrixImpl m3 = new RealMatrixImpl(testData);\n         RealMatrixImpl m4 = new RealMatrixImpl(m3.getData(), false);\n         assertEquals(m4,m3);\n-    }           \n-    \n+    }\n+\n     /** test add */\n     public void testAdd() {\n         RealMatrixImpl m = new RealMatrixImpl(testData);\n                     testDataPlusInv[row][col],sumEntries[row][col],\n                         entryTolerance);\n             }\n-        }    \n-    }\n-    \n+        }\n+    }\n+\n     /** test add failure */\n     public void testAddFail() {\n         RealMatrixImpl m = new RealMatrixImpl(testData);\n             // ignored\n         }\n     }\n-    \n+\n     /** test norm */\n     public void testNorm() {\n         RealMatrixImpl m = new RealMatrixImpl(testData);\n         assertEquals(\"testData norm\",14d,m.getNorm(),entryTolerance);\n         assertEquals(\"testData2 norm\",7d,m2.getNorm(),entryTolerance);\n     }\n-    \n+\n     /** test Frobenius norm */\n     public void testFrobeniusNorm() {\n         RealMatrixImpl m = new RealMatrixImpl(testData);\n         assertEquals(\"testData Frobenius norm\", Math.sqrt(117.0), m.getFrobeniusNorm(), entryTolerance);\n         assertEquals(\"testData2 Frobenius norm\", Math.sqrt(52.0), m2.getFrobeniusNorm(), entryTolerance);\n     }\n-    \n+\n      /** test m-n = m + -n */\n     public void testPlusMinus() {\n         RealMatrixImpl m = new RealMatrixImpl(testData);\n         RealMatrixImpl m2 = new RealMatrixImpl(testDataInv);\n         TestUtils.assertEquals(\"m-n = m + -n\",m.subtract(m2),\n-            m2.scalarMultiply(-1d).add(m),entryTolerance);        \n+            m2.scalarMultiply(-1d).add(m),entryTolerance);\n         try {\n             m.subtract(new RealMatrixImpl(testData2));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n-    }\n-   \n+        }\n+    }\n+\n     /** test multiply */\n      public void testMultiply() {\n         RealMatrixImpl m = new RealMatrixImpl(testData);\n         TestUtils.assertEquals(\"identity multiply\",identity.multiply(mInv),\n             mInv,entryTolerance);\n         TestUtils.assertEquals(\"identity multiply\",m2.multiply(identity),\n-            m2,entryTolerance); \n+            m2,entryTolerance);\n         try {\n             m.multiply(new RealMatrixImpl(bigSingular));\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n-    }   \n-    \n+        }\n+    }\n+\n     //Additional Test for RealMatrixImplTest.testMultiply\n \n     private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};\n     private double[][] d4 = new double[][] {{1},{2},{3},{4}};\n     private double[][] d5 = new double[][] {{30},{70}};\n-     \n-    public void testMultiply2() { \n-       RealMatrix m3 = new RealMatrixImpl(d3);   \n+\n+    public void testMultiply2() {\n+       RealMatrix m3 = new RealMatrixImpl(d3);\n        RealMatrix m4 = new RealMatrixImpl(d4);\n        RealMatrix m5 = new RealMatrixImpl(d5);\n        TestUtils.assertEquals(\"m3*m4=m5\", m3.multiply(m4), m5, entryTolerance);\n-   }  \n-        \n+   }\n+\n     /** test trace */\n     public void testTrace() {\n         RealMatrix m = new RealMatrixImpl(id);\n             fail(\"Expecting NonSquareMatrixException\");\n         } catch (NonSquareMatrixException ex) {\n             // ignored\n-        }      \n-    }\n-    \n+        }\n+    }\n+\n     /** test sclarAdd */\n     public void testScalarAdd() {\n         RealMatrix m = new RealMatrixImpl(testData);\n         TestUtils.assertEquals(\"scalar add\",new RealMatrixImpl(testDataPlus2),\n             m.scalarAdd(2d),entryTolerance);\n     }\n-                    \n+\n     /** test operate */\n     public void testOperate() {\n         RealMatrix m = new RealMatrixImpl(id);\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n+        }\n     }\n \n     /** test issue MATH-209 */\n         assertEquals( 7.0, b[1], 1.0e-12);\n         assertEquals(11.0, b[2], 1.0e-12);\n     }\n-    \n+\n     /** test transpose */\n     public void testTranspose() {\n-        RealMatrix m = new RealMatrixImpl(testData); \n+        RealMatrix m = new RealMatrixImpl(testData);\n         RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();\n         RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();\n         TestUtils.assertEquals(\"inverse-transpose\", mIT, mTI, normTolerance);\n         RealMatrix mt = new RealMatrixImpl(testData2T);\n         TestUtils.assertEquals(\"transpose\",mt,m.transpose(),normTolerance);\n     }\n-    \n+\n     /** test preMultiply by vector */\n     public void testPremultiplyVector() {\n         RealMatrix m = new RealMatrixImpl(testData);\n             // ignored\n         }\n     }\n-    \n+\n     public void testPremultiply() {\n-        RealMatrix m3 = new RealMatrixImpl(d3);   \n+        RealMatrix m3 = new RealMatrixImpl(d3);\n         RealMatrix m4 = new RealMatrixImpl(d4);\n         RealMatrix m5 = new RealMatrixImpl(d5);\n         TestUtils.assertEquals(\"m3*m4=m5\", m4.preMultiply(m3), m5, entryTolerance);\n-        \n+\n         RealMatrixImpl m = new RealMatrixImpl(testData);\n         RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);\n         RealMatrixImpl identity = new RealMatrixImpl(id);\n             fail(\"Expecting illegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }      \n-    }\n-    \n+        }\n+    }\n+\n     public void testGetVectors() {\n         RealMatrix m = new RealMatrixImpl(testData);\n         TestUtils.assertEquals(\"get row\",m.getRow(0),testDataRow1,entryTolerance);\n             // ignored\n         }\n     }\n-    \n+\n     public void testGetEntry() {\n         RealMatrix m = new RealMatrixImpl(testData);\n         assertEquals(\"get entry\",m.getEntry(0,1),2d,entryTolerance);\n             // expected\n         }\n     }\n-        \n+\n     /** test examples in user guide */\n     public void testExamples() {\n         // Create a real matrix with two rows and three columns\n         assertEquals(2, p.getRowDimension());\n         assertEquals(2, p.getColumnDimension());\n         // Invert p\n-        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse(); \n+        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();\n         assertEquals(2, pInverse.getRowDimension());\n         assertEquals(2, pInverse.getColumnDimension());\n-        \n+\n         // Solve example\n         double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};\n         RealMatrix coefficients = new RealMatrixImpl(coefficientsData);\n         double[] solution = new LUDecompositionImpl(coefficients).getSolver().solve(constants);\n         assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);\n         assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);\n-        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);   \n-        \n-    }\n-    \n+        assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);\n+\n+    }\n+\n     // test submatrix accessors\n     public void testGetSubMatrix() {\n         RealMatrix m = new RealMatrixImpl(subTestData);\n         checkGetSubMatrix(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n         checkGetSubMatrix(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n-        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n-        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n-        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n-        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n-        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n-        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n-        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n+        checkGetSubMatrix(m, subRows01Cols23,  0 , 1 , 2, 3, false);\n+        checkGetSubMatrix(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);\n+        checkGetSubMatrix(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);\n+        checkGetSubMatrix(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);\n+        checkGetSubMatrix(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);\n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);\n+        checkGetSubMatrix(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);\n         checkGetSubMatrix(m, null,  1, 0, 2, 4, true);\n         checkGetSubMatrix(m, null, -1, 1, 2, 2, true);\n         checkGetSubMatrix(m, null,  1, 0, 2, 2, true);\n             }\n         }\n     }\n-    \n+\n     private void checkGetSubMatrix(RealMatrix m, double[][] reference,\n                                    int[] selectedRows, int[] selectedColumns,\n                                    boolean mustFail) {\n         RealMatrix m = new RealMatrixImpl(subTestData);\n         checkCopy(m, subRows23Cols00,  2 , 3 , 0, 0, false);\n         checkCopy(m, subRows00Cols33,  0 , 0 , 3, 3, false);\n-        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);   \n-        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);  \n-        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);  \n-        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false); \n-        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false); \n-        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n-        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false); \n-        \n+        checkCopy(m, subRows01Cols23,  0 , 1 , 2, 3, false);\n+        checkCopy(m, subRows02Cols13,  new int[] { 0, 2 }, new int[] { 1, 3 },    false);\n+        checkCopy(m, subRows03Cols12,  new int[] { 0, 3 }, new int[] { 1, 2 },    false);\n+        checkCopy(m, subRows03Cols123, new int[] { 0, 3 }, new int[] { 1, 2, 3 }, false);\n+        checkCopy(m, subRows20Cols123, new int[] { 2, 0 }, new int[] { 1, 2, 3 }, false);\n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);\n+        checkCopy(m, subRows31Cols31,  new int[] { 3, 1 }, new int[] { 3, 1 },    false);\n+\n         checkCopy(m, null,  1, 0, 2, 4, true);\n         checkCopy(m, null, -1, 1, 2, 2, true);\n         checkCopy(m, null,  1, 0, 2, 2, true);\n             }\n         }\n     }\n-    \n+\n     private void checkCopy(RealMatrix m, double[][] reference,\n                            int[] selectedRows, int[] selectedColumns,\n                            boolean mustFail) {\n         RealMatrix m = new RealMatrixImpl(subTestData);\n         RealMatrix mRow0 = new RealMatrixImpl(subRow0);\n         RealMatrix mRow3 = new RealMatrixImpl(subRow3);\n-        assertEquals(\"Row0\", mRow0, \n+        assertEquals(\"Row0\", mRow0,\n                 m.getRowMatrix(0));\n-        assertEquals(\"Row3\", mRow3, \n+        assertEquals(\"Row3\", mRow3,\n                 m.getRowMatrix(3));\n         try {\n             m.getRowMatrix(-1);\n             // expected\n         }\n     }\n-    \n+\n     public void testSetRowMatrix() {\n         RealMatrix m = new RealMatrixImpl(subTestData);\n         RealMatrix mRow3 = new RealMatrixImpl(subRow3);\n             // expected\n         }\n     }\n-    \n+\n     public void testGetColumnMatrix() {\n         RealMatrix m = new RealMatrixImpl(subTestData);\n         RealMatrix mColumn1 = new RealMatrixImpl(subColumn1);\n         RealMatrix mColumn3 = new RealMatrixImpl(subColumn3);\n-        assertEquals(\"Column1\", mColumn1, \n+        assertEquals(\"Column1\", mColumn1,\n                 m.getColumnMatrix(1));\n-        assertEquals(\"Column3\", mColumn3, \n+        assertEquals(\"Column3\", mColumn3,\n                 m.getColumnMatrix(3));\n         try {\n             m.getColumnMatrix(-1);\n             // expected\n         }\n     }\n-    \n+\n     public void testGetColumnVector() {\n         RealMatrix m = new RealMatrixImpl(subTestData);\n         RealVector mColumn1 = columnToVector(subColumn1);\n             // expected\n         }\n     }\n-    \n+\n     public void testGetColumn() {\n         RealMatrix m = new RealMatrixImpl(subTestData);\n         double[] mColumn1 = columnToArray(subColumn1);\n     private void checkArrays(double[] expected, double[] actual) {\n         assertEquals(expected.length, actual.length);\n         for (int i = 0; i < expected.length; ++i) {\n-            assertEquals(expected[i], actual[i]);            \n-        }\n-    }\n-    \n+            assertEquals(expected[i], actual[i]);\n+        }\n+    }\n+\n     public void testEqualsAndHashCode() {\n         RealMatrixImpl m = new RealMatrixImpl(testData);\n         RealMatrixImpl m1 = (RealMatrixImpl) m.copy();\n         assertEquals(m, m1);\n         assertFalse(m.equals(null));\n         assertFalse(m.equals(mt));\n-        assertFalse(m.equals(new RealMatrixImpl(bigSingular))); \n-    }\n-    \n+        assertFalse(m.equals(new RealMatrixImpl(bigSingular)));\n+    }\n+\n     public void testToString() {\n         RealMatrixImpl m = new RealMatrixImpl(testData);\n         assertEquals(\"RealMatrixImpl{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n         assertEquals(\"RealMatrixImpl{}\",\n                 m.toString());\n     }\n-    \n+\n     public void testSetSubMatrix() throws Exception {\n         RealMatrixImpl m = new RealMatrixImpl(testData);\n         m.setSubMatrix(detData2,1,1);\n         RealMatrix expected = MatrixUtils.createRealMatrix\n             (new double[][] {{1.0,2.0,3.0},{2.0,1.0,3.0},{1.0,2.0,4.0}});\n-        assertEquals(expected, m);  \n-        \n+        assertEquals(expected, m);\n+\n         m.setSubMatrix(detData2,0,0);\n         expected = MatrixUtils.createRealMatrix\n             (new double[][] {{1.0,3.0,3.0},{2.0,4.0,3.0},{1.0,2.0,4.0}});\n-        assertEquals(expected, m);  \n-        \n-        m.setSubMatrix(testDataPlus2,0,0);      \n+        assertEquals(expected, m);\n+\n+        m.setSubMatrix(testDataPlus2,0,0);\n         expected = MatrixUtils.createRealMatrix\n             (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});\n-        assertEquals(expected, m);   \n-        \n+        assertEquals(expected, m);\n+\n         // dimension overflow\n-        try {  \n+        try {\n             m.setSubMatrix(testData,1,1);\n             fail(\"expecting MatrixIndexException\");\n         } catch (MatrixIndexException e) {\n             // expected\n         }\n         // dimension underflow\n-        try {  \n+        try {\n             m.setSubMatrix(testData,-1,1);\n             fail(\"expecting MatrixIndexException\");\n         } catch (MatrixIndexException e) {\n             // expected\n         }\n-        try {  \n+        try {\n             m.setSubMatrix(testData,1,-1);\n             fail(\"expecting MatrixIndexException\");\n         } catch (MatrixIndexException e) {\n             // expected\n         }\n-        \n+\n         // null\n         try {\n             m.setSubMatrix(null,1,1);\n         } catch (IllegalStateException e) {\n             // expected\n         }\n-        \n+\n         // ragged\n         try {\n             m.setSubMatrix(new double[][] {{1}, {2, 3}}, 0, 0);\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-       \n+\n         // empty\n         try {\n             m.setSubMatrix(new double[][] {{}}, 0, 0);\n         } catch (IllegalArgumentException e) {\n             // expected\n         }\n-        \n+\n     }\n \n     public void testWalk() {\n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, 0), 0);\n             assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(0, j), 0);\n             assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n         m.walkInOptimizedOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, 0), 0);\n             assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(0, j), 0);\n             assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n         m.walkInRowOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, 0), 0);\n             assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(0, j), 0);\n             assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n         m.walkInColumnOrder(getVisitor, 1, rows - 2, 1, columns - 2);\n         assertEquals((rows - 2) * (columns - 2), getVisitor.getCount());\n         for (int i = 0; i < rows; ++i) {\n-            assertEquals(0.0, m.getEntry(i, 0), 0);                    \n+            assertEquals(0.0, m.getEntry(i, 0), 0);\n             assertEquals(0.0, m.getEntry(i, columns - 1), 0);\n         }\n         for (int j = 0; j < columns; ++j) {\n-            assertEquals(0.0, m.getEntry(0, j), 0);                    \n+            assertEquals(0.0, m.getEntry(0, j), 0);\n             assertEquals(0.0, m.getEntry(rows - 1, j), 0);\n         }\n \n         RealMatrixImpl m = new RealMatrixImpl(testData);\n         assertEquals(m,TestUtils.serializeAndRecover(m));\n     }\n-    \n-    \n+\n+\n     private static class SetVisitor extends DefaultRealMatrixChangingVisitor {\n         @Override\n         public double visit(int i, int j, double value) {\n     }\n \n     //--------------- -----------------Protected methods\n-    \n+\n     /** extracts the l  and u matrices from compact lu representation */\n-    protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) throws InvalidMatrixException {   \n+    protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) throws InvalidMatrixException {\n         if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||\n                 lowerData.length != upperData.length\n                 || lowerData.length != lu.getRowDimension()) {\n             throw new InvalidMatrixException(\"incorrect dimensions\");\n-        }    \n+        }\n         int n = lu.getRowDimension();\n         for (int i = 0; i < n; i++) {\n             for (int j = 0; j < n; j++) {\n                 } else {\n                     lowerData[i][j] = 0d;\n                     upperData[i][j] = lu.getEntry(i, j);\n-                }   \n+                }\n             }\n         }\n     }\n-    \n+\n     /** Returns the result of applying the given row permutation to the matrix */\n     protected RealMatrix permuteRows(RealMatrix matrix, int[] permutation) {\n         if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {\n         }\n         return new RealMatrixImpl(out);\n     }\n-    \n+\n //    /** Useful for debugging */\n //    private void dumpMatrix(RealMatrix m) {\n //          for (int i = 0; i < m.getRowDimension(); i++) {\n //              System.out.println(os);\n //          }\n //    }\n-        \n+\n }\n \n--- a/src/test/java/org/apache/commons/math/linear/RealVectorFormatAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/RealVectorFormatAbstractTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n import org.apache.commons.math.util.CompositeFormat;\n \n public abstract class RealVectorFormatAbstractTest extends TestCase {\n- \n+\n     RealVectorFormat realVectorFormat = null;\n     RealVectorFormat realVectorFormatSquare = null;\n \n         nf.setMaximumFractionDigits(2);\n         realVectorFormatSquare = new RealVectorFormat(\"[\", \"]\", \" : \", nf);\n     }\n-   \n+\n     public void testSimpleNoDecimals() {\n         ArrayRealVector c = new ArrayRealVector(new double[] {1, 1, 1});\n         String expected = \"{1; 1; 1}\";\n-        String actual = realVectorFormat.format(c); \n+        String actual = realVectorFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n             \"23; 1\" + getDecimalCharacter() +\n             \"43; 1\" + getDecimalCharacter() +\n             \"63}\";\n-        String actual = realVectorFormat.format(c); \n+        String actual = realVectorFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n             \"23; 1\" + getDecimalCharacter() +\n             \"43; 1\" + getDecimalCharacter() +\n             \"63}\";\n-        String actual = realVectorFormat.format(c); \n+        String actual = realVectorFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n             \"23; 1\" + getDecimalCharacter() +\n             \"43; 1\" + getDecimalCharacter() +\n             \"63}\";\n-        String actual = realVectorFormat.format(c); \n+        String actual = realVectorFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n             \"23; -1\" + getDecimalCharacter() +\n             \"43; 1\" + getDecimalCharacter() +\n             \"63}\";\n-        String actual = realVectorFormat.format(c); \n+        String actual = realVectorFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n             \"23; 1\" + getDecimalCharacter() +\n             \"43; -1\" + getDecimalCharacter() +\n             \"63}\";\n-        String actual = realVectorFormat.format(c); \n+        String actual = realVectorFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n     public void testNonDefaultSetting() {\n         ArrayRealVector c = new ArrayRealVector(new double[] {1, 1, 1});\n         String expected = \"[1 : 1 : 1]\";\n-        String actual = realVectorFormatSquare.format(c); \n-        assertEquals(expected, actual);\n-    }\n-    \n+        String actual = realVectorFormatSquare.format(c);\n+        assertEquals(expected, actual);\n+    }\n+\n     public void testStaticFormatRealVectorImpl() {\n         Locale defaultLocal = Locale.getDefault();\n         Locale.setDefault(getLocale());\n-        \n+\n         ArrayRealVector c = new ArrayRealVector(new double[] {232.222, -342.33, 432.444});\n         String expected =\n             \"{232\"    + getDecimalCharacter() +\n             \"22; -342\" + getDecimalCharacter() +\n             \"33; 432\" + getDecimalCharacter() +\n             \"44}\";\n-        String actual = RealVectorFormat.formatRealVector(c); \n-        assertEquals(expected, actual);\n-        \n+        String actual = RealVectorFormat.formatRealVector(c);\n+        assertEquals(expected, actual);\n+\n         Locale.setDefault(defaultLocal);\n     }\n \n     public void testNan() {\n         ArrayRealVector c = new ArrayRealVector(new double[] {Double.NaN, Double.NaN, Double.NaN});\n         String expected = \"{(NaN); (NaN); (NaN)}\";\n-        String actual = realVectorFormat.format(c); \n+        String actual = realVectorFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n                 Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY\n         });\n         String expected = \"{(Infinity); (Infinity); (Infinity)}\";\n-        String actual = realVectorFormat.format(c); \n+        String actual = realVectorFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n                 Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY\n         });\n         String expected = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n-        String actual = realVectorFormat.format(c); \n+        String actual = realVectorFormat.format(c);\n         assertEquals(expected, actual);\n     }\n \n         String source = \"{1; 1; 1}\";\n         ArrayRealVector expected = new ArrayRealVector(new double[] {1, 1, 1});\n         try {\n-            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"63}\";\n         ArrayRealVector expected = new ArrayRealVector(new double[] {1.23, 1.43, 1.63});\n         try {\n-            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"6333}\";\n         ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, 1.6333});\n         try {\n-            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"6333}\";\n         ArrayRealVector expected = new ArrayRealVector(new double[] {-1.2323, 1.4343, 1.6333});\n         try {\n-            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"6333}\";\n         ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, -1.4343, 1.6333});\n         try {\n-            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"6333}\";\n         ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, -1.6333});\n         try {\n-            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"6333}\";\n         ArrayRealVector expected = new ArrayRealVector(new double[] {-1.2323, -1.4343, -1.6333});\n         try {\n-            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"6333}\";\n         ArrayRealVector expected = new ArrayRealVector(new double[] {0.0, -1.4343, 1.6333});\n         try {\n-            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);\n             assertEquals(expected, actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n             \"6333]\";\n         ArrayRealVector expected = new ArrayRealVector(new double[] {1.2323, 1.4343, 1.6333});\n         try {\n-            ArrayRealVector actual = (ArrayRealVector) realVectorFormatSquare.parseObject(source); \n-            assertEquals(expected, actual);\n-        } catch (ParseException ex) {\n-            fail(ex.getMessage());\n-        }\n-    }\n-    \n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormatSquare.parseObject(source);\n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n     public void testParseNan() {\n         String source = \"{(NaN); (NaN); (NaN)}\";\n         try {\n-            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source); \n+            ArrayRealVector actual = (ArrayRealVector) realVectorFormat.parseObject(source);\n             assertEquals(new ArrayRealVector(new double[] {Double.NaN, Double.NaN, Double.NaN}), actual);\n         } catch (ParseException ex) {\n             fail(ex.getMessage());\n     public void testParsePositiveInfinity() {\n         String source = \"{(Infinity); (Infinity); (Infinity)}\";\n         try {\n-            ArrayRealVector actual = (ArrayRealVector)realVectorFormat.parseObject(source); \n+            ArrayRealVector actual = (ArrayRealVector)realVectorFormat.parseObject(source);\n             assertEquals(new ArrayRealVector(new double[] {\n                     Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY\n             }), actual);\n     public void testParseNegativeInfinity() {\n         String source = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n         try {\n-            ArrayRealVector actual = (ArrayRealVector)realVectorFormat.parseObject(source); \n+            ArrayRealVector actual = (ArrayRealVector)realVectorFormat.parseObject(source);\n             assertEquals(new ArrayRealVector(new double[] {\n                     Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY\n             }), actual);\n         assertNotNull(cf);\n         assertEquals(nf, cf.getFormat());\n     }\n-    \n+\n     public void testFormatObject() {\n         try {\n             CompositeFormat cf = new RealVectorFormat();\n--- a/src/test/java/org/apache/commons/math/linear/RealVectorFormatTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/RealVectorFormatTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/test/java/org/apache/commons/math/linear/SingularValueDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SingularValueDecompositionImplTest.java\n         assertTrue(u == svd.getU());\n         assertTrue(s == svd.getS());\n         assertTrue(v == svd.getV());\n-        \n+\n     }\n \n     /** test matrices values */\n--- a/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n         } catch (FractionConversionException e) {\n             // ignore, can't happen\n         }\n-        \n-                \n+\n+\n     }\n \n     public static Test suite() {\n         FieldMatrix<Fraction> mPlusMInv = m.add(mInv);\n         for (int row = 0; row < m.getRowDimension(); row++) {\n             for (int col = 0; col < m.getColumnDimension(); col++) {\n-                assertEquals(\"sum entry entry\", \n-                    mDataPlusInv.getEntry(row, col).doubleValue(), mPlusMInv.getEntry(row, col).doubleValue(), \n+                assertEquals(\"sum entry entry\",\n+                    mDataPlusInv.getEntry(row, col).doubleValue(), mPlusMInv.getEntry(row, col).doubleValue(),\n                     entryTolerance);\n             }\n         }\n         }\n     }\n \n-    \n+\n     /** test m-n = m + -n */\n     public void testPlusMinus() {\n         SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n     /** test sclarAdd */\n     public void testScalarAdd() {\n         FieldMatrix<Fraction> m = createSparseMatrix(testData);\n-        assertClose(\"scalar add\", createSparseMatrix(testDataPlus2), \n+        assertClose(\"scalar add\", createSparseMatrix(testDataPlus2),\n             m.scalarAdd(new Fraction(2)), entryTolerance);\n     }\n \n \n     /** test transpose */\n     public void testTranspose() {\n-        \n-        FieldMatrix<Fraction> m = createSparseMatrix(testData); \n+\n+        FieldMatrix<Fraction> m = createSparseMatrix(testData);\n         FieldMatrix<Fraction> mIT = new FieldLUDecompositionImpl<Fraction>(m).getSolver().getInverse().transpose();\n         FieldMatrix<Fraction> mTI = new FieldLUDecompositionImpl<Fraction>(m.transpose()).getSolver().getInverse();\n         assertClose(\"inverse-transpose\", mIT, mTI, normTolerance);\n         assertEquals(2, p.getRowDimension());\n         assertEquals(2, p.getColumnDimension());\n         // Invert p\n-        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse(); \n+        FieldMatrix<Fraction> pInverse = new FieldLUDecompositionImpl<Fraction>(p).getSolver().getInverse();\n         assertEquals(2, pInverse.getRowDimension());\n         assertEquals(2, pInverse.getColumnDimension());\n \n         assertEquals(\"Rows23Cols00\", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));\n         assertEquals(\"Rows00Cols33\", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));\n         assertEquals(\"Rows01Cols23\", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));\n-        assertEquals(\"Rows02Cols13\", mRows02Cols13, \n+        assertEquals(\"Rows02Cols13\", mRows02Cols13,\n             m.getSubMatrix(new int[] { 0, 2 }, new int[] { 1, 3 }));\n-        assertEquals(\"Rows03Cols12\", mRows03Cols12, \n+        assertEquals(\"Rows03Cols12\", mRows03Cols12,\n             m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2 }));\n-        assertEquals(\"Rows03Cols123\", mRows03Cols123, \n+        assertEquals(\"Rows03Cols123\", mRows03Cols123,\n             m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2, 3 }));\n-        assertEquals(\"Rows20Cols123\", mRows20Cols123, \n+        assertEquals(\"Rows20Cols123\", mRows20Cols123,\n             m.getSubMatrix(new int[] { 2, 0 }, new int[] { 1, 2, 3 }));\n-        assertEquals(\"Rows31Cols31\", mRows31Cols31, \n+        assertEquals(\"Rows31Cols31\", mRows31Cols31,\n             m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));\n-        assertEquals(\"Rows31Cols31\", mRows31Cols31, \n+        assertEquals(\"Rows31Cols31\", mRows31Cols31,\n             m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));\n \n         try {\n     /* Disable for now\n     public void testToString() {\n         SparseFieldMatrix<Fraction> m = createSparseMatrix(testData);\n-        assertEquals(\"SparseFieldMatrix<Fraction>{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\", \n+        assertEquals(\"SparseFieldMatrix<Fraction>{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n             m.toString());\n         m = new SparseFieldMatrix<Fraction>(field, 1, 1);\n         assertEquals(\"SparseFieldMatrix<Fraction>{{0.0}}\", m.toString());\n         assertEquals(expected, m);\n \n         // javadoc example\n-        SparseFieldMatrix<Fraction> matrix = \n-            createSparseMatrix(new Fraction[][] { \n+        SparseFieldMatrix<Fraction> matrix =\n+            createSparseMatrix(new Fraction[][] {\n         { new Fraction(1), new Fraction(2), new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6), new Fraction(7), new Fraction(8) }, { new Fraction(9), new Fraction(0), new Fraction(1), new Fraction(2) } });\n         matrix.setSubMatrix(new Fraction[][] { { new Fraction(3), new Fraction(4) }, { new Fraction(5), new Fraction(6) } }, 1, 1);\n         expected = createSparseMatrix(new Fraction[][] {\n             for(int j=0; j < m.getColumnDimension(); j++){\n                 assertEquals(msg, m.getEntry(i,j).doubleValue(), n.getEntry(i,j).doubleValue(), tolerance);\n             }\n-            \n+\n         }\n     }\n \n                     tolerance);\n         }\n     }\n-    \n+\n     private SparseFieldMatrix<Fraction> createSparseMatrix(Fraction[][] data) {\n         SparseFieldMatrix<Fraction> matrix = new SparseFieldMatrix<Fraction>(field, data.length, data[0].length);\n         for (int row = 0; row < data.length; row++) {\n--- a/src/test/java/org/apache/commons/math/linear/SparseFieldVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseFieldVectorTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  */\n public class SparseFieldVectorTest extends TestCase {\n \n-    // \n+    //\n     protected Fraction[][] ma1 = {{new Fraction(1), new Fraction(2), new Fraction(3)}, {new Fraction(4), new Fraction(5), new Fraction(6)}, {new Fraction(7), new Fraction(8), new Fraction(9)}};\n     protected Fraction[] vec1 = {new Fraction(1), new Fraction(2), new Fraction(3)};\n     protected Fraction[] vec2 = {new Fraction(4), new Fraction(5), new Fraction(6)};\n \n     protected FractionField field = FractionField.getInstance();\n \n-    public void testMapFunctions() throws FractionConversionException { \n+    public void testMapFunctions() throws FractionConversionException {\n         SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);\n \n         //octave =  v1 .+ 2.0\n \n     }\n \n-    public void testBasicFunctions() throws FractionConversionException { \n+    public void testBasicFunctions() throws FractionConversionException {\n         SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);\n         SparseFieldVector<Fraction> v2 = new SparseFieldVector<Fraction>(field,vec2);\n \n-        SparseFieldVector<Fraction> v2_t = new SparseFieldVector<Fraction>(field,vec2); \n+        SparseFieldVector<Fraction> v2_t = new SparseFieldVector<Fraction>(field,vec2);\n \n         //octave =  v1 + v2\n         FieldVector<Fraction> v_add = v1.add(v2);\n     }\n \n \n-    public void testMisc() { \n+    public void testMisc() {\n         SparseFieldVector<Fraction> v1 = new SparseFieldVector<Fraction>(field,vec1);\n \n         String out1 = v1.toString();\n         assertTrue(\"some output \",  out1.length()!=0);\n         try {\n-            v1.checkVectorDimensions(2); \n+            v1.checkVectorDimensions(2);\n             fail(\"IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n-        }     \n+        }\n \n \n     }\n--- a/src/test/java/org/apache/commons/math/linear/SparseRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealMatrixTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n /**\n  * Test cases for the {@link OpenMapRealMatrix} class.\n- * \n+ *\n  * @version $Revision$ $Date: 2008-11-07 06:48:13 -0800 (Fri, 07 Nov\n  *          2008) $\n  */\n         RealMatrix mPlusMInv = m.add(mInv);\n         for (int row = 0; row < m.getRowDimension(); row++) {\n             for (int col = 0; col < m.getColumnDimension(); col++) {\n-                assertEquals(\"sum entry entry\", \n-                    mDataPlusInv.getEntry(row, col), mPlusMInv.getEntry(row, col), \n+                assertEquals(\"sum entry entry\",\n+                    mDataPlusInv.getEntry(row, col), mPlusMInv.getEntry(row, col),\n                     entryTolerance);\n             }\n         }\n     /** test sclarAdd */\n     public void testScalarAdd() {\n         RealMatrix m = createSparseMatrix(testData);\n-        assertClose(\"scalar add\", createSparseMatrix(testDataPlus2), \n+        assertClose(\"scalar add\", createSparseMatrix(testDataPlus2),\n             m.scalarAdd(2d), entryTolerance);\n     }\n \n \n     /** test transpose */\n     public void testTranspose() {\n-        \n-        RealMatrix m = createSparseMatrix(testData); \n+\n+        RealMatrix m = createSparseMatrix(testData);\n         RealMatrix mIT = new LUDecompositionImpl(m).getSolver().getInverse().transpose();\n         RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getSolver().getInverse();\n         assertClose(\"inverse-transpose\", mIT, mTI, normTolerance);\n         assertEquals(2, p.getRowDimension());\n         assertEquals(2, p.getColumnDimension());\n         // Invert p\n-        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse(); \n+        RealMatrix pInverse = new LUDecompositionImpl(p).getSolver().getInverse();\n         assertEquals(2, pInverse.getRowDimension());\n         assertEquals(2, pInverse.getColumnDimension());\n \n         assertEquals(\"Rows23Cols00\", mRows23Cols00, m.getSubMatrix(2, 3, 0, 0));\n         assertEquals(\"Rows00Cols33\", mRows00Cols33, m.getSubMatrix(0, 0, 3, 3));\n         assertEquals(\"Rows01Cols23\", mRows01Cols23, m.getSubMatrix(0, 1, 2, 3));\n-        assertEquals(\"Rows02Cols13\", mRows02Cols13, \n+        assertEquals(\"Rows02Cols13\", mRows02Cols13,\n             m.getSubMatrix(new int[] { 0, 2 }, new int[] { 1, 3 }));\n-        assertEquals(\"Rows03Cols12\", mRows03Cols12, \n+        assertEquals(\"Rows03Cols12\", mRows03Cols12,\n             m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2 }));\n-        assertEquals(\"Rows03Cols123\", mRows03Cols123, \n+        assertEquals(\"Rows03Cols123\", mRows03Cols123,\n             m.getSubMatrix(new int[] { 0, 3 }, new int[] { 1, 2, 3 }));\n-        assertEquals(\"Rows20Cols123\", mRows20Cols123, \n+        assertEquals(\"Rows20Cols123\", mRows20Cols123,\n             m.getSubMatrix(new int[] { 2, 0 }, new int[] { 1, 2, 3 }));\n-        assertEquals(\"Rows31Cols31\", mRows31Cols31, \n+        assertEquals(\"Rows31Cols31\", mRows31Cols31,\n             m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));\n-        assertEquals(\"Rows31Cols31\", mRows31Cols31, \n+        assertEquals(\"Rows31Cols31\", mRows31Cols31,\n             m.getSubMatrix(new int[] { 3, 1 }, new int[] { 3, 1 }));\n \n         try {\n \n     public void testToString() {\n         OpenMapRealMatrix m = createSparseMatrix(testData);\n-        assertEquals(\"OpenMapRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\", \n+        assertEquals(\"OpenMapRealMatrix{{1.0,2.0,3.0},{2.0,5.0,3.0},{1.0,0.0,8.0}}\",\n             m.toString());\n         m = new OpenMapRealMatrix(1, 1);\n         assertEquals(\"OpenMapRealMatrix{{0.0}}\", m.toString());\n         assertEquals(expected, m);\n \n         // javadoc example\n-        OpenMapRealMatrix matrix = \n-            createSparseMatrix(new double[][] { \n+        OpenMapRealMatrix matrix =\n+            createSparseMatrix(new double[][] {\n         { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 0, 1, 2 } });\n         matrix.setSubMatrix(new double[][] { { 3, 4 }, { 5, 6 } }, 1, 1);\n         expected = createSparseMatrix(new double[][] {\n                     tolerance);\n         }\n     }\n-    \n+\n     private OpenMapRealMatrix createSparseMatrix(double[][] data) {\n         OpenMapRealMatrix matrix = new OpenMapRealMatrix(data.length, data[0].length);\n         for (int row = 0; row < data.length; row++) {\n--- a/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseRealVectorTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  */\n public class SparseRealVectorTest extends TestCase {\n \n-    // \n+    //\n     protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};\n     protected double[] vec1 = {1d, 2d, 3d};\n     protected double[] vec2 = {4d, 5d, 6d};\n     protected double entryTolerance = 10E-16;\n     protected double normTolerance = 10E-14;\n \n-    // Testclass to test the RealVector interface \n+    // Testclass to test the RealVector interface\n     // only with enough content to support the test\n     public static class SparseRealVectorTestImpl implements RealVector, Serializable {\n \n         OpenMapRealVector v1 = new OpenMapRealVector(vec1);\n         OpenMapRealVector v2 = new OpenMapRealVector(vec2);\n         OpenMapRealVector v4 = new OpenMapRealVector(vec4);\n-        SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2); \n+        SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2);\n \n         RealVector v_append_1 = v1.append(v2);\n         assertEquals(\"testData len\", 6, v_append_1.getDimension());\n \t    RealVector v_append_4 = v1.append(v2_t);\n         assertEquals(\"testData len\", 6, v_append_4.getDimension());\n         assertEquals(\"testData is 4.0 \", 4.0, v_append_4.getEntry(3));\n-        \n+\n         RealVector vout5 = v4.getSubVector(3, 3);\n         assertEquals(\"testData len\", 3, vout5.getDimension());\n         assertEquals(\"testData is 4.0 \", 5.0, vout5.getEntry(1));\n \n     }\n \n-    public void testMapFunctions() { \n+    public void testMapFunctions() {\n         OpenMapRealVector v1 = new OpenMapRealVector(vec1);\n \n         //octave =  v1 .+ 2.0\n \n         //octave =  asin(vat)\n         RealVector v_mapAsinToSelf = vat.copy();\n-        v_mapAsinToSelf.mapAsinToSelf();        \n+        v_mapAsinToSelf.mapAsinToSelf();\n         double[] result_mapAsinToSelf = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};\n         assertClose(\"compare vectors\" ,result_mapAsinToSelf,v_mapAsinToSelf.getData(),normTolerance);\n \n \n     }\n \n-    public void testBasicFunctions() { \n+    public void testBasicFunctions() {\n         OpenMapRealVector v1 = new OpenMapRealVector(vec1);\n         OpenMapRealVector v2 = new OpenMapRealVector(vec2);\n         OpenMapRealVector v_null = new OpenMapRealVector(vec_null);\n \n-        SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2); \n+        SparseRealVectorTestImpl v2_t = new SparseRealVectorTestImpl(vec2);\n \n         //octave =  sqrt(sumsq(v1))\n         double d_getNorm = v1.getNorm();\n         assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n \n         RealVector v_unitVector = v1.unitVector();\n-        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm()); \n+        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm());\n         assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n \n         try {\n         double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n         assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n \n-    }  \n-\n-    public void testMisc() { \n+    }\n+\n+    public void testMisc() {\n         OpenMapRealVector v1 = new OpenMapRealVector(vec1);\n \n         String out1 = v1.toString();\n         assertTrue(\"some output \",  out1.length()!=0);\n         try {\n-            v1.checkVectorDimensions(2); \n+            v1.checkVectorDimensions(2);\n             fail(\"IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n-        }     \n+        }\n \n \n     }\n         OpenMapRealVector v = new OpenMapRealVector(new double[] { 0, 1, 2 });\n         assertEquals(v,TestUtils.serializeAndRecover(v));\n     }\n-    \n+\n     /** verifies that two vectors are close (sup norm) */\n     protected void assertClose(String msg, double[] m, double[] n,\n             double tolerance) {\n--- a/src/test/java/org/apache/commons/math/linear/TriDiagonalTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/TriDiagonalTransformerTest.java\n     private void checkOrthogonal(RealMatrix m) {\n         RealMatrix mTm = m.transpose().multiply(m);\n         RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());\n-        assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-15);        \n+        assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-15);\n     }\n \n     public void testTTriDiagonal() {\n             for (int j = 0; j < cols; ++j) {\n                 if ((i < j - 1) || (i > j + 1)) {\n                     assertEquals(0, m.getEntry(i, j), 1.0e-16);\n-                }                    \n+                }\n             }\n         }\n     }\n         // check the same cached instance is returned the second time\n         assertTrue(q == transformer.getQ());\n         assertTrue(t == transformer.getT());\n-        \n+\n     }\n \n     public static Test suite() {\n--- a/src/test/java/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n           assertEquals(Math.cos(t), y[0], 1.0e-7);\n           assertEquals(Math.sin(t), y[1], 1.0e-7);\n       }\n-      \n+\n   }\n \n   public void testErrorConditions()\n \n       ContinuousOutputModel cm = new ContinuousOutputModel();\n       cm.handleStep(buildInterpolator(0, new double[] { 0.0, 1.0, -2.0 }, 1), true);\n-      \n+\n       // dimension mismatch\n       assertTrue(checkAppendError(cm, 1.0, new double[] { 0.0, 1.0 }, 2.0));\n \n--- a/src/test/java/org/apache/commons/math/ode/FirstOrderConverterTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/FirstOrderConverterTest.java\n       assertTrue(eqn1.getDimension() == (2 * eqn2.getDimension()));\n     }\n   }\n-  \n+\n   public void testDecreasingSteps()\n     throws DerivativeException, IntegratorException {\n-      \n+\n     double previousError = Double.NaN;\n     for (int i = 0; i < 10; ++i) {\n \n         assertTrue(Math.abs(error) < Math.abs(previousError));\n       }\n       previousError = error;\n-      \n+\n     }\n   }\n \n                    - Math.sin(4.0);\n     assertTrue(Math.abs(error) > 0.1);\n   }\n-  \n+\n   public static Test suite() {\n     return new TestSuite(FirstOrderConverterTest.class);\n   }\n \n   private static class Equations\n     implements SecondOrderDifferentialEquations {\n-      \n+\n      private int n;\n \n       private double omega2;\n-      \n+\n       public Equations(int n, double omega) {\n         this.n = n;\n         omega2 = omega * omega;\n       }\n-      \n+\n       public int getDimension() {\n         return n;\n       }\n-      \n+\n       public void computeSecondDerivatives(double t, double[] y, double[] yDot,\n                                            double[] yDDot) {\n         for (int i = 0; i < n; ++i) {\n           yDDot[i] = -omega2 * y[i];\n         }\n     }\n-      \n+\n   }\n \n   private double integrateWithSpecifiedStep(double omega,\n--- a/src/test/java/org/apache/commons/math/ode/TestProblem1.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem1.java\n     setErrorScale(errorScale);\n     y = new double[y0.length];\n   }\n- \n+\n   /**\n    * Copy constructor.\n    * @param problem problem to copy\n--- a/src/test/java/org/apache/commons/math/ode/TestProblem2.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem2.java\n     setErrorScale(errorScale);\n     y = new double[y0.length];\n   }\n- \n+\n   /**\n    * Copy constructor.\n    * @param problem problem to copy\n--- a/src/test/java/org/apache/commons/math/ode/TestProblem3.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem3.java\n     setErrorScale(errorScale);\n     y = new double[y0.length];\n   }\n- \n+\n   /**\n    * Simple constructor.\n    */\n   public TestProblem3() {\n     this(0.1);\n   }\n- \n+\n   /**\n    * Copy constructor.\n    * @param problem problem to copy\n--- a/src/test/java/org/apache/commons/math/ode/TestProblem4.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblem4.java\n     setErrorScale(errorScale);\n     y = new double[y0.length];\n   }\n- \n+\n   /**\n    * Copy constructor.\n    * @param problem problem to copy\n       sign = -sign;\n       return EventHandler.RESET_STATE;\n     }\n-  \n+\n     public void resetState(double t, double[] y) {\n       y[0] = -y[0];\n       y[1] = -y[1];\n     public int eventOccurred(double t, double[] y, boolean increasing) {\n       return EventHandler.STOP;\n     }\n-  \n+\n     public void resetState(double t, double[] y) {\n     }\n \n--- a/src/test/java/org/apache/commons/math/ode/TestProblemAbstract.java\n+++ b/src/test/java/org/apache/commons/math/ode/TestProblemAbstract.java\n     calls     = 0;\n     n         = y0.length;\n     this.t0   = t0;\n-    this.y0   = y0.clone(); \n+    this.y0   = y0.clone();\n    }\n \n   /**\n    * @param errorScale error scale\n    */\n   protected void setErrorScale(double[] errorScale) {\n-    this.errorScale = errorScale.clone(); \n+    this.errorScale = errorScale.clone();\n   }\n \n   public int getDimension() {\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n     } catch(IntegratorException ie) {\n     }\n   }\n-  \n+\n   public void testDecreasingSteps()\n     throws DerivativeException, IntegratorException  {\n-      \n+\n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n \n               return false;\n           }\n           public void reset() {\n-          }          \n+          }\n       });\n       integ.integrate(new FirstOrderDifferentialEquations() {\n           private static final long serialVersionUID = 0L;\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/DormandPrince54IntegratorTest.java\n         assertTrue(minStep < (1.0 / 450.0));\n         assertTrue(maxStep > (1.0 / 4.2));\n       }\n-    }  \n+    }\n     private boolean firstTime;\n     private double  minStep;\n     private double  maxStep;\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/EulerIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/EulerIntegratorTest.java\n     } catch(IntegratorException ie) {\n     }\n   }\n-  \n+\n   public void testDecreasingSteps()\n     throws DerivativeException, IntegratorException {\n \n             return false;\n         }\n         public void reset() {\n-        }          \n+        }\n       });\n       integ.integrate(new FirstOrderDifferentialEquations() {\n                           private static final long serialVersionUID = 0L;\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n     for (StepHandler handler : integ.getStepHandlers()) {\n         oos.writeObject(handler);\n     }\n-    \n+\n     ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n     ObjectInputStream     ois = new ObjectInputStream(bis);\n     ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n \n   private static class DummyIntegrator extends RungeKuttaIntegrator {\n \n-      \n+\n       protected DummyIntegrator(RungeKuttaStepInterpolator prototype) {\n           super(\"dummy\", new double[0], new double[0][0], new double[0], prototype, Double.NaN);\n       }\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/GillIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/GillIntegratorTest.java\n     } catch(IntegratorException ie) {\n     }\n   }\n-  \n+\n   public void testDecreasingSteps()\n     throws DerivativeException, IntegratorException  {\n-      \n+\n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n \n               return false;\n           }\n           public void reset() {\n-          }          \n+          }\n       });\n       integ.integrate(new FirstOrderDifferentialEquations() {\n           private static final long serialVersionUID = 0L;\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n       }\n \n     } catch (Exception e) {\n-      fail(\"wrong exception caught: \" + e.getMessage());        \n+      fail(\"wrong exception caught: \" + e.getMessage());\n     }\n   }\n \n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/MidpointIntegratorTest.java\n     } catch(IntegratorException ie) {\n     }\n   }\n-  \n+\n   public void testDecreasingSteps()\n     throws DerivativeException, IntegratorException  {\n-      \n+\n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n \n               return false;\n           }\n           public void reset() {\n-          }          \n+          }\n       });\n       integ.integrate(new FirstOrderDifferentialEquations() {\n           private static final long serialVersionUID = 0L;\n--- a/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegratorTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegratorTest.java\n     } catch(IntegratorException ie) {\n     }\n   }\n-  \n+\n   public void testDecreasingSteps()\n     throws DerivativeException, IntegratorException  {\n-      \n+\n     TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n     for (int k = 0; k < problems.length; ++k) {\n-    \n+\n       double previousError = Double.NaN;\n       for (int i = 4; i < 10; ++i) {\n \n               return false;\n           }\n           public void reset() {\n-          }          \n+          }\n       });\n       integ.integrate(new FirstOrderDifferentialEquations() {\n           public void computeDerivatives(double t, double[] y, double[] dot) {\n--- a/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizerTest.java\n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n  * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n- * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files. \n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files.\n  * The redistribution policy for MINPACK is available <a\n  * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n  * convenience, it is reproduced below.</p>\n--- a/src/test/java/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/MultiDirectionalTest.java\n           Assert.assertNull(ce.getCause());\n       } catch (Exception e) {\n           Assert.fail(\"wrong exception caught: \" + e.getMessage());\n-      } \n+      }\n       try {\n           MultiDirectional optimizer = new MultiDirectional(0.9, 1.9);\n           optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { +2.0 });\n           Assert.assertNotNull(ce.getCause());\n       } catch (Exception e) {\n           Assert.fail(\"wrong exception caught: \" + e.getMessage());\n-      } \n+      }\n   }\n \n   @Test\n       optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n       Assert.assertEquals(xP,        optimum.getPoint()[0], 2.0e-8);\n       Assert.assertEquals(yM,        optimum.getPoint()[1], 3.0e-6);\n-      Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);              \n+      Assert.assertEquals(valueXpYm, optimum.getValue(),    2.0e-12);\n       Assert.assertTrue(optimizer.getEvaluations() > 120);\n       Assert.assertTrue(optimizer.getEvaluations() < 150);\n \n       final double[] actualPosition = estimate.getPoint();\n       Assert.assertEquals(expectedPosition[0], actualPosition[0], EPSILON );\n       Assert.assertEquals(expectedPosition[1], actualPosition[1], EPSILON );\n-      \n+\n   }\n \n   private static class Gaussian2D implements MultivariateRealFunction {\n       private final double[] maximumPosition;\n \n       private final double std;\n-      \n+\n       public Gaussian2D(double xOpt, double yOpt, double std) {\n           maximumPosition = new double[] { xOpt, yOpt };\n           this.std = std;\n--- a/src/test/java/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/NelderMeadTest.java\n           assertNull(ce.getCause());\n       } catch (Exception e) {\n           fail(\"wrong exception caught: \" + e.getMessage());\n-      } \n+      }\n       try {\n           NelderMead optimizer = new NelderMead(0.9, 1.9, 0.4, 0.6);\n           optimizer.optimize(wrong, GoalType.MINIMIZE, new double[] { +2.0 });\n           assertNotNull(ce.getCause());\n       } catch (Exception e) {\n           fail(\"wrong exception caught: \" + e.getMessage());\n-      } \n+      }\n   }\n \n   @Test\n       optimum = optimizer.optimize(fourExtrema, GoalType.MINIMIZE, new double[] { +1, 0 });\n       assertEquals(xP,        optimum.getPoint()[0], 5.0e-6);\n       assertEquals(yM,        optimum.getPoint()[1], 6.0e-6);\n-      assertEquals(valueXpYm, optimum.getValue(),    1.0e-11);              \n+      assertEquals(valueXpYm, optimum.getValue(),    1.0e-11);\n       assertTrue(optimizer.getEvaluations() > 60);\n       assertTrue(optimizer.getEvaluations() < 90);\n \n--- a/src/test/java/org/apache/commons/math/optimization/fitting/HarmonicFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/HarmonicFitterTest.java\n // to you under the Apache License, Version 2.0 (the\n // \"License\"); you may not use this file except in compliance\n // with the License.  You may obtain a copy of the License at\n-// \n+//\n //   http://www.apache.org/licenses/LICENSE-2.0\n-// \n+//\n // Unless required by applicable law or agreed to in writing,\n // software distributed under the License is distributed on an\n // \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n--- a/src/test/java/org/apache/commons/math/optimization/fitting/PolynomialFitterTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/fitting/PolynomialFitterTest.java\n // to you under the Apache License, Version 2.0 (the\n // \"License\"); you may not use this file except in compliance\n // with the License.  You may obtain a copy of the License at\n-// \n+//\n //   http://www.apache.org/licenses/LICENSE-2.0\n-// \n+//\n // Unless required by applicable law or agreed to in writing,\n // software distributed under the License is distributed on an\n // \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n--- a/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n  * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n- * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files. \n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files.\n  * The redistribution policy for MINPACK is available <a\n  * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n  * convenience, it is reproduced below.</p>\n             for (int i = 0; i < n; ++i) {\n                 Point2D.Double pi = points.get(i);\n                 double di   = pi.distance(center);\n-                jacobian[i][0] = (center.x - pi.x) / di - dRdX;    \n-                jacobian[i][1] = (center.y - pi.y) / di - dRdY;    \n+                jacobian[i][0] = (center.x - pi.x) / di - dRdX;\n+                jacobian[i][1] = (center.y - pi.y) / di - dRdY;\n            }\n \n             return jacobian;\n--- a/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n  * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n- * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files. \n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files.\n  * The redistribution policy for MINPACK is available <a\n  * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n  * convenience, it is reproduced below.</p>\n                 {  2, 1,  3 },\n                 { -3, 0, -9 }\n         }, new double[] { 1, 1, 1 });\n- \n+\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         optimizer.optimize(problem, problem.target, new double[] { 1, 1, 1 }, new double[] { 0, 0, 0 });\n         assertTrue(Math.sqrt(problem.target.length) * optimizer.getRMS() > 0.6);\n             for (int i = 0; i < n; ++i) {\n                 Point2D.Double pi = points.get(i);\n                 double di   = pi.distance(center);\n-                jacobian[i][0] = (center.x - pi.x) / di - dRdX;    \n-                jacobian[i][1] = (center.y - pi.y) / di - dRdY;    \n+                jacobian[i][0] = (center.x - pi.x) / di - dRdX;\n+                jacobian[i][1] = (center.y - pi.y) / di - dRdY;\n             }\n \n             return jacobian;\n--- a/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/MinpackTest.java\n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n  * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n- * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files. \n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files.\n  * The redistribution policy for MINPACK is available <a\n  * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n  * convenience, it is reproduced below.</p>\n     minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0},\n                                           991.261822123701), false);\n   }\n-    \n+\n   public void testMinpackPowellSingular() {\n     minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 },\n                                            14.6628782986152), false);\n     minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 },\n                                            126887.903284750), false);\n   }\n-    \n+\n   public void testMinpackFreudensteinRoth() {\n     minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },\n                                              20.0124960961895, 6.99887517584575,\n                                                -0.89680510749204\n                                              }), false);\n   }\n-    \n+\n   public void testMinpackBard() {\n     minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466,\n                                  new double[] {\n                                    -164464906.857771\n                                  }), false);\n   }\n-    \n+\n   public void testMinpackKowalikOsborne() {\n     minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 },\n                                            0.0728915102882945,\n                                              0.134575665392506\n                                            }), false);\n   }\n-    \n+\n   public void testMinpackMeyer() {\n     minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 },\n                                   41153.4665543031, 9.37794514651874,\n                                     901.268527953801\n                                   }), true);\n   }\n-    \n+\n   public void testMinpackWatson() {\n-  \n+\n     minpackTest(new WatsonFunction(6, 0.0,\n                                    5.47722557505166, 0.0478295939097601,\n                                    new double[] {\n                                    }), false);\n \n   }\n-    \n+\n   public void testMinpackBox3Dimensional() {\n     minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 },\n                                             32.1115837449572), false);\n   }\n-    \n+\n   public void testMinpackJennrichSampson() {\n     minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },\n                                             64.5856498144943, 11.1517793413499,\n                                          -0.403688070279258, 0.236665033746463\n                                         }), false);\n   }\n-    \n+\n   public void testMinpackChebyquad() {\n     minpackTest(new ChebyquadFunction(1, 8, 1.0,\n                                       1.88623796907732, 1.88623796907732,\n                                         0.833291216194063,  0.940379732824644\n                                       }), false);\n   }\n-    \n+\n   public void testMinpackBrownAlmostLinear() {\n     minpackTest(new BrownAlmostLinearFunction(10, 0.5,\n                                               16.5302162063499, 0.0,\n                                                0.979430303349865, 0.979430303349865,\n                                                0.979430303349865, 0.979430303349865,\n                                                0.979430303349865, 1.20569696650135\n-                                              }), false);  \n+                                              }), false);\n     minpackTest(new BrownAlmostLinearFunction(10, 50.0,\n                                               0.9765625e17, 0.0,\n                                               new double[] {\n                                                 0.999999999999121\n                                               }), false);\n     }\n-    \n+\n   public void testMinpackOsborne1() {\n       minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, },\n                                        0.937564021037838, 0.00739249260904843,\n                                          0.0221227011813076\n                                        }), false);\n     }\n-    \n+\n   public void testMinpackOsborne2() {\n-      \n+\n     minpackTest(new Osborne2Function(new double[] {\n                                        1.3, 0.65, 0.65, 0.7, 0.6,\n                                        3.0, 5.0, 7.0, 2.0, 4.5, 5.5\n \n   private static abstract class MinpackFunction\n       implements DifferentiableMultivariateVectorialFunction, Serializable {\n- \n+\n       private static final long serialVersionUID = -6209760235478794233L;\n       protected int      n;\n       protected int      m;\n       34780.0, 28610.0, 23650.0, 19630.0,\n       16370.0, 13720.0, 11540.0,  9744.0,\n        8261.0,  7030.0,  6005.0,  5147.0,\n-       4427.0,  3820.0,  3307.0,  2872.0                  \n+       4427.0,  3820.0,  3307.0,  2872.0\n     };\n \n   }\n--- a/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n  * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n- * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files. \n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files.\n  * The redistribution policy for MINPACK is available <a\n  * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n  * convenience, it is reproduced below.</p>\n--- a/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/linear/SimplexSolverTest.java\n \n         SimplexSolver solver = new SimplexSolver();\n         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n-        \n+\n         assertEquals(0.0, solution.getPoint()[0], .0000001);\n         assertEquals(1.0, solution.getPoint()[1], .0000001);\n         assertEquals(1.0, solution.getPoint()[2], .0000001);\n         assertEquals(10.0, solution.getPoint()[0], 0.0);\n         assertEquals(30.0, solution.getValue(), 0.0);\n     }\n-    \n+\n     /**\n      * With no artificial variables needed (no equals and no greater than\n      * constraints) we can go straight to Phase 2.\n       assertEquals(0.0, solution.getPoint()[2], 0.0);\n       assertEquals(15.0, solution.getValue(), 0.0);\n   }\n-    \n+\n     @Test\n     public void testTrivialModel() throws OptimizationException {\n         LinearObjectiveFunction f = new LinearObjectiveFunction(new double[] { 1, 1 }, 0);\n         RealPointValuePair solution = solver.optimize(f, constraints, GoalType.MINIMIZE, true);\n         assertEquals(7518.0, solution.getValue(), .0000001);\n     }\n-    \n+\n     /**\n      * Converts a test string to a {@link LinearConstraint}.\n      * Ex: x0 + x1 + x2 + x3 - x12 = 0\n--- a/src/test/java/org/apache/commons/math/optimization/linear/SimplexTableauTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/linear/SimplexTableauTest.java\n \n public class SimplexTableauTest extends TestCase {\n \n-    public void testInitialization() {    \n+    public void testInitialization() {\n         LinearObjectiveFunction f = createFunction();\n         Collection<LinearConstraint> constraints = createConstraints();\n         SimplexTableau tableau =\n         assertMatrixEquals(expectedInitialTableau, tableau.getData());\n     }\n \n-    public void testdiscardArtificialVariables() {    \n+    public void testdiscardArtificialVariables() {\n         LinearObjectiveFunction f = createFunction();\n         Collection<LinearConstraint> constraints = createConstraints();\n         SimplexTableau tableau =\n         Collection<LinearConstraint> constraints = new ArrayList<LinearConstraint>();\n         constraints.add(new LinearConstraint(new double[] {1, 0}, Relationship.LEQ, 2));\n         constraints.add(new LinearConstraint(new double[] {0, 1}, Relationship.LEQ, 3));\n-        constraints.add(new LinearConstraint(new double[] {1, 1}, Relationship.LEQ, 4));    \n+        constraints.add(new LinearConstraint(new double[] {1, 1}, Relationship.LEQ, 4));\n         SimplexTableau tableau =\n             new SimplexTableau(f, constraints, GoalType.MAXIMIZE, false, 1.0e-6);\n         double[][] initialTableau = {\n--- a/src/test/java/org/apache/commons/math/optimization/univariate/BrentMinimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/univariate/BrentMinimizerTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n import org.junit.Test;\n \n /**\n- * @version $Revision$ $Date$ \n+ * @version $Revision$ $Date$\n  */\n public final class BrentMinimizerTest {\n \n--- a/src/test/java/org/apache/commons/math/random/AbstractRandomGeneratorTest.java\n+++ b/src/test/java/org/apache/commons/math/random/AbstractRandomGeneratorTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n import junit.framework.TestSuite;\n \n import org.apache.commons.math.stat.Frequency;\n- \n+\n \n /**\n  * Test cases for the AbstractRandomGenerator class\n  */\n \n public class AbstractRandomGeneratorTest extends RandomDataTest {\n-    \n+\n     protected TestRandomGenerator testGenerator = new TestRandomGenerator();\n-    \n+\n     public AbstractRandomGeneratorTest(String name) {\n         super(name);\n         randomData = new RandomDataImpl(testGenerator);\n-    } \n-    \n+    }\n+\n     public static Test suite() {\n         TestSuite suite = new TestSuite(AbstractRandomGeneratorTest.class);\n         suite.setName(\"AbstractRandomGenerator Tests\");\n         return suite;\n     }\n-    \n+\n     @Override\n     public void testNextInt() {\n         try {\n         for (int i=0; i<smallSampleSize; i++) {\n             value = testGenerator.nextInt(4);\n             assertTrue(\"nextInt range\",(value >= 0) && (value <= 3));\n-            freq.addValue(value);  \n+            freq.addValue(value);\n         }\n         long[] observed = new long[4];\n         for (int i=0; i<4; i++) {\n             observed[i] = freq.getCount(i);\n-        } \n-        \n+        }\n+\n         /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n          * Change to 11.34 for alpha = .01\n          */\n         assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-                testStatistic.chiSquare(expected,observed) < 16.27);    \n+                testStatistic.chiSquare(expected,observed) < 16.27);\n     }\n-    \n+\n     @Override\n     public void testNextLong() {\n         long q1 = Long.MAX_VALUE/4;\n         long q2 = 2 *  q1;\n         long q3 = 3 * q1;\n-        \n+\n         Frequency freq = new Frequency();\n         long val = 0;\n         int value = 0;\n             } else {\n                 value = 3;\n             }\n-            freq.addValue(value);  \n+            freq.addValue(value);\n         }\n         long[] observed = new long[4];\n         for (int i=0; i<4; i++) {\n             observed[i] = freq.getCount(i);\n-        } \n-        \n+        }\n+\n         /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n          * Change to 11.34 for alpha = .01\n          */\n         assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-                testStatistic.chiSquare(expected,observed) < 16.27);    \n+                testStatistic.chiSquare(expected,observed) < 16.27);\n     }\n-    \n+\n     public void testNextBoolean() {\n-        long halfSampleSize = smallSampleSize / 2; \n+        long halfSampleSize = smallSampleSize / 2;\n         double[] expected = {halfSampleSize, halfSampleSize};\n         long[] observed = new long[2];\n         for (int i=0; i<smallSampleSize; i++) {\n          * Change to 6.635 for alpha = .01\n          */\n         assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-                testStatistic.chiSquare(expected,observed) < 10.828);    \n+                testStatistic.chiSquare(expected,observed) < 10.828);\n     }\n-    \n+\n     public void testNextFloat() {\n         Frequency freq = new Frequency();\n         float val = 0;\n             } else {\n                 value = 3;\n             }\n-            freq.addValue(value);  \n+            freq.addValue(value);\n         }\n         long[] observed = new long[4];\n         for (int i=0; i<4; i++) {\n             observed[i] = freq.getCount(i);\n-        } \n-        \n+        }\n+\n         /* Use ChiSquare dist with df = 4-1 = 3, alpha = .001\n          * Change to 11.34 for alpha = .01\n          */\n         assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-                testStatistic.chiSquare(expected,observed) < 16.27);    \n+                testStatistic.chiSquare(expected,observed) < 16.27);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/random/EmpiricalDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/random/EmpiricalDistributionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     protected EmpiricalDistribution empiricalDistribution = null;\n     protected EmpiricalDistribution empiricalDistribution2 = null;\n     protected File file = null;\n-    protected URL url = null; \n+    protected URL url = null;\n     protected double[] dataArray = null;\n-    \n+\n     public EmpiricalDistributionTest(String name) {\n         super(name);\n     }\n     public void setUp() throws IOException {\n         empiricalDistribution = new EmpiricalDistributionImpl(100);\n         url = getClass().getResource(\"testData.txt\");\n-        \n+\n         empiricalDistribution2 = new EmpiricalDistributionImpl(100);\n-        BufferedReader in = \n+        BufferedReader in =\n                 new BufferedReader(new InputStreamReader(\n                         url.openStream()));\n         String str = null;\n         }\n         in.close();\n         in = null;\n-        \n+\n         dataArray = new double[list.size()];\n         int i = 0;\n         for (Double data : list) {\n             dataArray[i] = data.doubleValue();\n             i++;\n-        }                 \n+        }\n     }\n \n     public static Test suite() {\n     }\n \n     /**\n-     * Test EmpiricalDistrbution.load() using sample data file.<br> \n-     * Check that the sampleCount, mu and sigma match data in \n+     * Test EmpiricalDistrbution.load() using sample data file.<br>\n+     * Check that the sampleCount, mu and sigma match data in\n      * the sample data file.\n      */\n     public void testLoad() throws Exception {\n-        empiricalDistribution.load(url);   \n+        empiricalDistribution.load(url);\n         // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1\n         // Make sure that loaded distribution matches this\n         assertEquals(empiricalDistribution.getSampleStats().getN(),1000,10E-7);\n \n     /**\n      * Test EmpiricalDistrbution.load(double[]) using data taken from\n-     * sample data file.<br> \n-     * Check that the sampleCount, mu and sigma match data in \n+     * sample data file.<br>\n+     * Check that the sampleCount, mu and sigma match data in\n      * the sample data file.\n      */\n     public void testDoubleLoad() throws Exception {\n-        empiricalDistribution2.load(dataArray);   \n+        empiricalDistribution2.load(dataArray);\n         // testData File has 10000 values, with mean ~ 5.0, std dev ~ 1\n         // Make sure that loaded distribution matches this\n         assertEquals(empiricalDistribution2.getSampleStats().getN(),1000,10E-7);\n         assertEquals\n           (empiricalDistribution2.getSampleStats().getStandardDeviation(),\n                 1.0173699343977738,10E-7);\n-        \n+\n         double[] bounds = empiricalDistribution2.getUpperBounds();\n         assertEquals(bounds.length, 100);\n         assertEquals(bounds[99], 1.0, 10e-12);\n-          \n-    }\n-   \n-    /** \n+\n+    }\n+\n+    /**\n       * Generate 1000 random values and make sure they look OK.<br>\n       * Note that there is a non-zero (but very small) probability that\n       * these tests will fail even if the code is working as designed.\n         tstGen(0.1);\n         tstDoubleGen(0.1);\n     }\n-    \n+\n     /**\n       * Make sure exception thrown if digest getNext is attempted\n       * before loading empiricalDistribution.\n             fail(\"wrong exception caught\");\n         }\n     }\n-    \n+\n     /**\n      * Make sure we can handle a grid size that is too fine\n      */\n     public void testGridTooFine() throws Exception {\n         empiricalDistribution = new EmpiricalDistributionImpl(1001);\n-        tstGen(0.1);    \n-        empiricalDistribution2 = new EmpiricalDistributionImpl(1001);           \n+        tstGen(0.1);\n+        empiricalDistribution2 = new EmpiricalDistributionImpl(1001);\n         tstDoubleGen(0.1);\n     }\n-    \n+\n     /**\n      * How about too fat?\n      */\n         empiricalDistribution = new EmpiricalDistributionImpl(1);\n         tstGen(5); // ridiculous tolerance; but ridiculous grid size\n                    // really just checking to make sure we do not bomb\n-        empiricalDistribution2 = new EmpiricalDistributionImpl(1);           \n-        tstDoubleGen(5);           \n-    }\n-    \n+        empiricalDistribution2 = new EmpiricalDistributionImpl(1);\n+        tstDoubleGen(5);\n+    }\n+\n     /**\n      * Test bin index overflow problem (BZ 36450)\n      */\n         double[] x = new double[] {9474.94326071674, 2080107.8865462579};\n         new EmpiricalDistributionImpl().load(x);\n     }\n-    \n+\n     public void testSerialization() {\n         // Empty\n         EmpiricalDistribution dist = new EmpiricalDistributionImpl();\n         EmpiricalDistribution dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(dist);\n         verifySame(dist, dist2);\n-        \n+\n         // Loaded\n-        empiricalDistribution2.load(dataArray);   \n+        empiricalDistribution2.load(dataArray);\n         dist2 = (EmpiricalDistribution) TestUtils.serializeAndRecover(empiricalDistribution2);\n         verifySame(empiricalDistribution2, dist2);\n     }\n             assertEquals(d1.getBinStats(), d2.getBinStats());\n         }\n     }\n-    \n+\n     private void tstGen(double tolerance)throws Exception {\n-        empiricalDistribution.load(url);   \n+        empiricalDistribution.load(url);\n         SummaryStatistics stats = new SummaryStatistics();\n         for (int i = 1; i < 1000; i++) {\n             stats.addValue(empiricalDistribution.getNextValue());\n     }\n \n     private void tstDoubleGen(double tolerance)throws Exception {\n-        empiricalDistribution2.load(dataArray);   \n+        empiricalDistribution2.load(dataArray);\n         SummaryStatistics stats = new SummaryStatistics();\n         for (int i = 1; i < 1000; i++) {\n             stats.addValue(empiricalDistribution2.getNextValue());\n--- a/src/test/java/org/apache/commons/math/random/MersenneTwisterTest.java\n+++ b/src/test/java/org/apache/commons/math/random/MersenneTwisterTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n             950049240l, 4173257693l, 1760124957l,  512151405l,  681175196l,  580563018l, 1169662867l, 4015033554l,\n             2687781101l,  699691603l, 2673494188l, 1137221356l,  123599888l,  472658308l, 1053598179l, 1012713758l,\n             3481064843l, 3759461013l, 3981457956l, 3830587662l, 1877191791l, 3650996736l,  988064871l, 3515461600l,\n-            4089077232l, 2225147448l, 1249609188l, 2643151863l, 3896204135l, 2416995901l, 1397735321l, 3460025646l \n+            4089077232l, 2225147448l, 1249609188l, 2643151863l, 3896204135l, 2416995901l, 1397735321l, 3460025646l\n         };\n         double[] refDouble = {\n             0.76275443, 0.99000644, 0.98670464, 0.10143112, 0.27933125, 0.69867227, 0.94218740, 0.03427201,\n--- a/src/test/java/org/apache/commons/math/random/RandomAdaptorTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomAdaptorTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  */\n \n public class RandomAdaptorTest extends RandomDataTest {\n-    \n+\n     public RandomAdaptorTest(String name) {\n         super(name);\n-    } \n-    \n+    }\n+\n     public static Test suite() {\n         TestSuite suite = new TestSuite(RandomAdaptorTest.class);\n         suite.setName(\"RandomAdaptor Tests\");\n         return suite;\n     }\n-    \n+\n     public void testAdaptor() {\n         ConstantGenerator generator = new ConstantGenerator();\n         Random random = RandomAdaptor.createAdaptor(generator);\n         checkConstant(random);\n         RandomAdaptor randomAdaptor = new RandomAdaptor(generator);\n-        checkConstant(randomAdaptor); \n+        checkConstant(randomAdaptor);\n     }\n-    \n+\n     private void checkConstant(Random random) {\n         byte[] bytes = new byte[] {0};\n         random.nextBytes(bytes);\n-        assertEquals(0, bytes[0]);  \n+        assertEquals(0, bytes[0]);\n         assertEquals(false, random.nextBoolean());\n         assertEquals(0, random.nextDouble(), 0);\n         assertEquals(0, random.nextFloat(), 0);\n         random.setSeed(100);\n         assertEquals(0, random.nextDouble(), 0);\n     }\n-    \n+\n     /*\n      * \"Constant\" generator to test Adaptor delegation.\n      * \"Powered by Eclipse ;-)\"\n-     * \n+     *\n      */\n     private static class ConstantGenerator implements RandomGenerator {\n-        \n+\n         public boolean nextBoolean() {\n             return false;\n         }\n-        \n+\n         public void nextBytes(byte[] bytes) {\n         }\n \n \n         public void setSeed(int seed) {\n         }\n-        \n+\n         public void setSeed(int[] seed) {\n         }\n \n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n /**\n  * Test cases for the RandomData class.\n- * \n+ *\n  * @version $Revision$ $Date: 2009-04-05 11:55:59 -0500 (Sun, 05 Apr\n  *          2009) $\n  */\n \n \t\t/*\n \t\t * remove this test back soon, since it takes about 4 seconds\n-\t\t * \n+\t\t *\n \t\t * try { randomData.setSecureAlgorithm(\"SHA1PRNG\",\"SUN\"); } catch\n \t\t * (NoSuchProviderException ex) { ; } assertTrue(\"different seeds\",\n \t\t * !hex.equals(randomData.nextSecureHexString(40))); try {\n \t\t * fail(\"expecting NoSuchAlgorithmException\"); } catch\n \t\t * (NoSuchProviderException ex) { ; } catch (NoSuchAlgorithmException\n \t\t * ex) { ; }\n-\t\t * \n+\t\t *\n \t\t * try { randomData.setSecureAlgorithm(\"SHA1PRNG\",\"NOSUCHPROVIDER\");\n \t\t * fail(\"expecting NoSuchProviderException\"); } catch\n \t\t * (NoSuchProviderException ex) { ; }\n--- a/src/test/java/org/apache/commons/math/random/TestRandomGenerator.java\n+++ b/src/test/java/org/apache/commons/math/random/TestRandomGenerator.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n import java.util.Random;\n \n /**\n- * Dummy AbstractRandomGenerator concrete subclass that just wraps a \n+ * Dummy AbstractRandomGenerator concrete subclass that just wraps a\n  * java.util.Random instance.  Used by AbstractRandomGeneratorTest to test\n  * default implementations in AbstractRandomGenerator.\n  *\n--- a/src/test/java/org/apache/commons/math/random/UniformRandomGeneratorTest.java\n+++ b/src/test/java/org/apache/commons/math/random/UniformRandomGeneratorTest.java\n         assertEquals(0.0, StatUtils.mean(sample), 0.07);\n         assertEquals(1.0, StatUtils.variance(sample), 0.02);\n     }\n-    \n-    \n+\n+\n     public static Test suite() {\n         return new TestSuite(UniformRandomGeneratorTest.class);\n     }\n--- a/src/test/java/org/apache/commons/math/random/ValueServerTest.java\n+++ b/src/test/java/org/apache/commons/math/random/ValueServerTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n import org.apache.commons.math.RetryTestCase;\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n- \n+\n /**\n  * Test cases for the ValueServer class.\n  *\n public final class ValueServerTest extends RetryTestCase {\n \n     private ValueServer vs = new ValueServer();\n-    \n+\n     public ValueServerTest(String name) {\n         super(name);\n     }\n         vs.setMode(ValueServer.DIGEST_MODE);\n         try {\n             URL url = getClass().getResource(\"testData.txt\");\n-            vs.setValuesFileURL(url); \n+            vs.setValuesFileURL(url);\n         } catch (Exception ex) {\n             fail(\"malformed test URL\");\n         }\n         return suite;\n     }\n \n-   \n-    /** \n+\n+    /**\n       * Generate 1000 random values and make sure they look OK.<br>\n       * Note that there is a non-zero (but very small) probability that\n       * these tests will fail even if the code is working as designed.\n         double next = 0.0;\n         double tolerance = 0.1;\n         vs.computeDistribution();\n-        assertTrue(\"empirical distribution property\", \n+        assertTrue(\"empirical distribution property\",\n             vs.getEmpiricalDistribution() != null);\n         SummaryStatistics stats = new SummaryStatistics();\n         for (int i = 1; i < 1000; i++) {\n             next = vs.getNext();\n             stats.addValue(next);\n-        }    \n+        }\n         assertEquals(\"mean\", 5.069831575018909, stats.getMean(), tolerance);\n         assertEquals\n-         (\"std dev\", 1.0173699343977738, stats.getStandardDeviation(), \n+         (\"std dev\", 1.0173699343977738, stats.getStandardDeviation(),\n             tolerance);\n-        \n+\n         vs.computeDistribution(500);\n         stats = new SummaryStatistics();\n         for (int i = 1; i < 1000; i++) {\n             next = vs.getNext();\n             stats.addValue(next);\n-        }    \n+        }\n         assertEquals(\"mean\", 5.069831575018909, stats.getMean(), tolerance);\n         assertEquals\n-         (\"std dev\", 1.0173699343977738, stats.getStandardDeviation(), \n+         (\"std dev\", 1.0173699343977738, stats.getStandardDeviation(),\n             tolerance);\n-        \n-    }\n-    \n+\n+    }\n+\n     /**\n       * Make sure exception thrown if digest getNext is attempted\n       * before loading empiricalDistribution.\n     }\n \n     /**\n-     * Test ValueServer REPLAY_MODE using values in testData file.<br> \n+     * Test ValueServer REPLAY_MODE using values in testData file.<br>\n      * Check that the values 1,2,1001,1002 match data file values 1 and 2.\n      * the sample data file.\n      */\n         // make sure no NPE\n         vs.closeReplayFile();\n     }\n-    \n-    /** \n+\n+    /**\n      * Test other ValueServer modes\n      */\n     public void testModes() throws Exception {\n             // ignored\n         }\n     }\n-    \n+\n     /**\n      * Test fill\n      */\n             assertEquals(\"fill test in place\",2,v2[i],Double.MIN_VALUE);\n         }\n     }\n-    \n+\n     /**\n      * Test getters to make Clover happy\n      */\n         URL url = vs.getValuesFileURL();\n         assertEquals(\"valuesFileURL test\",\"http://www.apache.org\",url.toString());\n     }\n-                          \n+\n }\n--- a/src/test/java/org/apache/commons/math/special/BetaTest.java\n+++ b/src/test/java/org/apache/commons/math/special/BetaTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     public void testRegularizedBetaPositivePositiveNan() {\n         testRegularizedBeta(Double.NaN, 0.5, 1.0, Double.NaN);\n     }\n-    \n+\n     public void testRegularizedBetaNegativePositivePositive() {\n         testRegularizedBeta(Double.NaN, -0.5, 1.0, 2.0);\n     }\n-    \n+\n     public void testRegularizedBetaPositiveNegativePositive() {\n         testRegularizedBeta(Double.NaN, 0.5, -1.0, 2.0);\n     }\n-    \n+\n     public void testRegularizedBetaPositivePositiveNegative() {\n         testRegularizedBeta(Double.NaN, 0.5, 1.0, -2.0);\n     }\n-    \n+\n     public void testRegularizedBetaZeroPositivePositive() {\n         testRegularizedBeta(0.0, 0.0, 1.0, 2.0);\n     }\n-    \n+\n     public void testRegularizedBetaPositiveZeroPositive() {\n         testRegularizedBeta(Double.NaN, 0.5, 0.0, 2.0);\n     }\n-    \n+\n     public void testRegularizedBetaPositivePositiveZero() {\n         testRegularizedBeta(Double.NaN, 0.5, 1.0, 0.0);\n     }\n-    \n+\n     public void testRegularizedBetaPositivePositivePositive() {\n         testRegularizedBeta(0.75, 0.5, 1.0, 2.0);\n     }\n-    \n+\n     public void testLogBetaNanPositive() {\n         testLogBeta(Double.NaN, Double.NaN, 2.0);\n     }\n-    \n+\n     public void testLogBetaPositiveNan() {\n         testLogBeta(Double.NaN, 1.0, Double.NaN);\n     }\n-    \n+\n     public void testLogBetaNegativePositive() {\n         testLogBeta(Double.NaN, -1.0, 2.0);\n     }\n-    \n+\n     public void testLogBetaPositiveNegative() {\n         testLogBeta(Double.NaN, 1.0, -2.0);\n     }\n-    \n+\n     public void testLogBetaZeroPositive() {\n         testLogBeta(Double.NaN, 0.0, 2.0);\n     }\n-    \n+\n     public void testLogBetaPositiveZero() {\n         testLogBeta(Double.NaN, 1.0, 0.0);\n     }\n-    \n+\n     public void testLogBetaPositivePositive() {\n         testLogBeta(-0.693147180559945, 1.0, 2.0);\n     }\n-}\n+}\n--- a/src/test/java/org/apache/commons/math/special/ErfTest.java\n+++ b/src/test/java/org/apache/commons/math/special/ErfTest.java\n         double actual = Erf.erf(x);\n         double expected = 0.99;\n         assertEquals(expected, actual, 1.0e-5);\n-    \n+\n         actual = Erf.erf(-x);\n         expected = -expected;\n         assertEquals(expected, actual, 1.0e-5);\n         double actual = Erf.erf(x);\n         double expected = 0.995;\n         assertEquals(expected, actual, 1.0e-5);\n-        \n+\n         actual = Erf.erf(-x);\n         expected = -expected;\n         assertEquals(expected, actual, 1.0e-5);\n         double actual = Erf.erf(x);\n         double expected = 0.999;\n         assertEquals(expected, actual, 1.0e-5);\n-        \n+\n         actual = Erf.erf(-x);\n         expected = -expected;\n         assertEquals(expected, actual, 1.0e-5);\n--- a/src/test/java/org/apache/commons/math/special/GammaTest.java\n+++ b/src/test/java/org/apache/commons/math/special/GammaTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * @version $Revision$ $Date$\n  */\n public class GammaTest extends TestCase {\n-     \n+\n     public GammaTest(String name) {\n         super(name);\n     }\n     public void testRegularizedGammaPositiveNan() {\n         testRegularizedGamma(Double.NaN, 1.0, Double.NaN);\n     }\n-    \n+\n     public void testRegularizedGammaNegativePositive() {\n         testRegularizedGamma(Double.NaN, -1.5, 1.0);\n     }\n-    \n+\n     public void testRegularizedGammaPositiveNegative() {\n         testRegularizedGamma(Double.NaN, 1.0, -1.0);\n     }\n-    \n+\n     public void testRegularizedGammaZeroPositive() {\n         testRegularizedGamma(Double.NaN, 0.0, 1.0);\n     }\n-    \n+\n     public void testRegularizedGammaPositiveZero() {\n         testRegularizedGamma(0.0, 1.0, 0.0);\n     }\n-    \n+\n     public void testRegularizedGammaPositivePositive() {\n         testRegularizedGamma(0.632120558828558, 1.0, 1.0);\n     }\n-    \n+\n     public void testLogGammaNan() {\n         testLogGamma(Double.NaN, Double.NaN);\n     }\n-    \n+\n     public void testLogGammaNegative() {\n         testLogGamma(Double.NaN, -1.0);\n     }\n-    \n+\n     public void testLogGammaZero() {\n         testLogGamma(Double.NaN, 0.0);\n     }\n-    \n+\n     public void testLogGammaPositive() {\n         testLogGamma(0.6931471805599457, 3.0);\n     }\n--- a/src/test/java/org/apache/commons/math/stat/CertifiedDataTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/CertifiedDataTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n         SummaryStatistics u = new SummaryStatistics();\n         loadStats(\"data/PiDigits.txt\", u);\n         assertEquals(\"PiDigits: std\", std, u.getStandardDeviation(), 1E-13);\n-        assertEquals(\"PiDigits: mean\", mean, u.getMean(), 1E-13);  \n+        assertEquals(\"PiDigits: mean\", mean, u.getMean(), 1E-13);\n \n         loadStats(\"data/Mavro.txt\", u);\n         assertEquals(\"Mavro: std\", std, u.getStandardDeviation(), 1E-14);\n         assertEquals(\"Mavro: mean\", mean, u.getMean(), 1E-14);\n-        \n+\n         loadStats(\"data/Michelso.txt\", u);\n         assertEquals(\"Michelso: std\", std, u.getStandardDeviation(), 1E-13);\n-        assertEquals(\"Michelso: mean\", mean, u.getMean(), 1E-13);   \n-                                        \n+        assertEquals(\"Michelso: mean\", mean, u.getMean(), 1E-13);\n+\n         loadStats(\"data/NumAcc1.txt\", u);\n         assertEquals(\"NumAcc1: std\", std, u.getStandardDeviation(), 1E-14);\n         assertEquals(\"NumAcc1: mean\", mean, u.getMean(), 1E-14);\n-        \n+\n         loadStats(\"data/NumAcc2.txt\", u);\n         assertEquals(\"NumAcc2: std\", std, u.getStandardDeviation(), 1E-14);\n         assertEquals(\"NumAcc2: mean\", mean, u.getMean(), 1E-14);\n     public void testDescriptiveStatistics() throws Exception {\n \n         DescriptiveStatistics u = new DescriptiveStatistics();\n-        \n+\n         loadStats(\"data/PiDigits.txt\", u);\n         assertEquals(\"PiDigits: std\", std, u.getStandardDeviation(), 1E-14);\n         assertEquals(\"PiDigits: mean\", mean, u.getMean(), 1E-14);\n-        \n+\n         loadStats(\"data/Mavro.txt\", u);\n         assertEquals(\"Mavro: std\", std, u.getStandardDeviation(), 1E-14);\n-        assertEquals(\"Mavro: mean\", mean, u.getMean(), 1E-14);        \n-        \n+        assertEquals(\"Mavro: mean\", mean, u.getMean(), 1E-14);\n+\n         loadStats(\"data/Michelso.txt\", u);\n         assertEquals(\"Michelso: std\", std, u.getStandardDeviation(), 1E-14);\n-        assertEquals(\"Michelso: mean\", mean, u.getMean(), 1E-14);   \n+        assertEquals(\"Michelso: mean\", mean, u.getMean(), 1E-14);\n \n         loadStats(\"data/NumAcc1.txt\", u);\n         assertEquals(\"NumAcc1: std\", std, u.getStandardDeviation(), 1E-14);\n         assertEquals(\"NumAcc1: mean\", mean, u.getMean(), 1E-14);\n-        \n+\n         loadStats(\"data/NumAcc2.txt\", u);\n         assertEquals(\"NumAcc2: std\", std, u.getStandardDeviation(), 1E-14);\n         assertEquals(\"NumAcc2: mean\", mean, u.getMean(), 1E-14);\n      * @param statistical summary\n      */\n     private void loadStats(String resource, Object u) throws Exception {\n-        \n+\n         DescriptiveStatistics d = null;\n         SummaryStatistics s = null;\n         if (u instanceof DescriptiveStatistics) {\n                 \"clear\", new Class[]{}).invoke(u, new Object[]{});\n         mean = Double.NaN;\n         std = Double.NaN;\n-        \n+\n         BufferedReader in =\n             new BufferedReader(\n                     new InputStreamReader(\n                             CertifiedDataTest.class.getResourceAsStream(resource)));\n-        \n+\n         String line = null;\n-        \n+\n         for (int j = 0; j < 60; j++) {\n             line = in.readLine();\n             if (j == 40) {\n                             line.substring(line.lastIndexOf(\":\") + 1).trim());\n             }\n         }\n-        \n+\n         line = in.readLine();\n-        \n+\n         while (line != null) {\n             if (d != null) {\n                 d.addValue(Double.parseDouble(line.trim()));\n             }\n             line = in.readLine();\n         }\n-        \n+\n         in.close();\n     }\n }\n--- a/src/test/java/org/apache/commons/math/stat/FrequencyTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/FrequencyTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     private int threeI=3;\n     private double tolerance = 10E-15;\n     private Frequency f = null;\n-    \n+\n     public FrequencyTest(String name) {\n         super(name);\n     }\n \n     @Override\n-    public void setUp() {  \n+    public void setUp() {\n         f = new Frequency();\n     }\n-    \n+\n     public static Test suite() {\n         TestSuite suite = new TestSuite(FrequencyTest.class);\n         suite.setName(\"Frequency Tests\");\n         return suite;\n     }\n-    \n+\n     /** test freq counts */\n     public void testCounts() {\n         assertEquals(\"total count\",0,f.getSumFreq());\n         assertEquals(\"Integer argument cum freq\",4, f.getCumFreq(Integer.valueOf(2)));\n         assertEquals(\"five cumulative frequency\", 4,  f.getCumFreq(5));\n         assertEquals(\"foo cumulative frequency\", 0,  f.getCumFreq(\"foo\"));\n-        \n+\n         f.clear();\n         assertEquals(\"total count\",0,f.getSumFreq());\n-        \n+\n         // userguide examples -------------------------------------------------------------------\n         f.addValue(\"one\");\n         f.addValue(\"One\");\n         assertEquals(\"z cumulative pct\", 1.0,  f.getCumPct(\"z\"), tolerance);\n         assertEquals(\"Ot cumulative pct\", 0.25,  f.getCumPct(\"Ot\"), tolerance);\n         f.clear();\n-        \n+\n         f = null;\n         Frequency f = new Frequency();\n         f.addValue(1);\n         assertEquals(\"0 cum pct\", 0.2, f.getCumPct(0), tolerance);\n         assertEquals(\"1 pct\", 0.6, f.getPct(Integer.valueOf(1)), tolerance);\n         assertEquals(\"-2 cum pct\", 0, f.getCumPct(-2), tolerance);\n-        assertEquals(\"10 cum pct\", 1, f.getCumPct(10), tolerance);   \n-        \n+        assertEquals(\"10 cum pct\", 1, f.getCumPct(10), tolerance);\n+\n         f = null;\n         f = new Frequency(String.CASE_INSENSITIVE_ORDER);\n         f.addValue(\"one\");\n         assertEquals(0.25, f.getPct('a'), 0.0);\n         assertEquals(0.5, f.getCumPct('b'), 0.0);\n         assertEquals(1.0, f.getCumPct('e'), 0.0);\n-    }     \n-    \n+    }\n+\n     /** test pcts */\n     public void testPcts() {\n         f.addValue(oneL);\n         assertEquals(\"zero cum pct\",0.0,f.getCumPct(0),tolerance);\n         assertEquals(\"foo cum pct\",0,f.getCumPct(\"foo\"),tolerance);\n     }\n-    \n+\n     /** test adding incomparable values */\n     public void testAdd() {\n         char aChar = 'a';\n         f.addValue(aChar);\n         f.addValue(bChar);\n         try {\n-            f.addValue(aString);    \n+            f.addValue(aString);\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         assertEquals(\"b cum pct\",1.0,f.getCumPct(bChar),tolerance);\n         assertEquals(\"a string pct\",0.0,f.getPct(aString),tolerance);\n         assertEquals(\"a string cum pct\",0.0,f.getCumPct(aString),tolerance);\n-        \n+\n         f = new Frequency();\n         f.addValue(\"One\");\n         try {\n-            f.addValue(new Integer(\"One\")); \n+            f.addValue(new Integer(\"One\"));\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n     }\n-    \n+\n     // Check what happens when non-Comparable objects are added\n     @SuppressWarnings(\"deprecation\")\n     public void testAddNonComparable(){\n         assertTrue(\"pct, empty table\", Double.isNaN(f.getPct(0)));\n         assertTrue(\"pct, empty table\", Double.isNaN(f.getPct(Integer.valueOf(0))));\n         assertTrue(\"cum pct, empty table\", Double.isNaN(f.getCumPct(0)));\n-        assertTrue(\"cum pct, empty table\", Double.isNaN(f.getCumPct(Integer.valueOf(0))));   \n-    }\n-    \n+        assertTrue(\"cum pct, empty table\", Double.isNaN(f.getCumPct(Integer.valueOf(0))));\n+    }\n+\n     /**\n-     * Tests toString() \n+     * Tests toString()\n      */\n     public void testToString(){\n         f.addValue(oneL);\n         f.addValue(twoL);\n         f.addValue(oneI);\n         f.addValue(twoI);\n-        \n+\n         String s = f.toString();\n         //System.out.println(s);\n         assertNotNull(s);\n         try {\n             String line = reader.readLine(); // header line\n             assertNotNull(line);\n-            \n+\n             line = reader.readLine(); // one's or two's line\n             assertNotNull(line);\n-                        \n+\n             line = reader.readLine(); // one's or two's line\n             assertNotNull(line);\n \n             assertNull(line);\n         } catch(IOException ex){\n             fail(ex.getMessage());\n-        }        \n+        }\n     }\n     public void testIntegerValues() {\n         Comparable<?> obj1 = null;\n         Iterator<?> it = f.valuesIterator();\n         while (it.hasNext()) {\n             assertTrue(it.next() instanceof Long);\n-        }     \n-    }\n-    \n+        }\n+    }\n+\n     public void testSerial() {\n         f.addValue(oneL);\n         f.addValue(twoL);\n--- a/src/test/java/org/apache/commons/math/stat/StatUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/StatUtilsTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n         }\n \n     }\n-    \n+\n     public void testSumSq() {\n         double[] x = null;\n-        \n+\n         // test null\n         try {\n             StatUtils.sumSq(x);\n         } catch (IllegalArgumentException ex) {\n             // success\n         }\n-        \n+\n         try {\n             StatUtils.sumSq(x, 0, 4);\n             fail(\"null is not a valid data array.\");\n         } catch (IllegalArgumentException ex) {\n             // success\n         }\n-        \n+\n         // test empty\n         x = new double[] {};\n         TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x), tolerance);\n         TestUtils.assertEquals(Double.NaN, StatUtils.sumSq(x, 0, 0), tolerance);\n-        \n+\n         // test one\n         x = new double[] {two};\n         TestUtils.assertEquals(4, StatUtils.sumSq(x), tolerance);\n         TestUtils.assertEquals(4, StatUtils.sumSq(x, 0, 1), tolerance);\n-        \n+\n         // test many\n         x = new double[] {one, two, two, three};\n         TestUtils.assertEquals(18, StatUtils.sumSq(x), tolerance);\n         TestUtils.assertEquals(8, StatUtils.sumSq(x, 1, 2), tolerance);\n     }\n-    \n+\n     public void testProduct() {\n         double[] x = null;\n-        \n+\n         // test null\n         try {\n             StatUtils.product(x);\n         } catch (IllegalArgumentException ex) {\n             // success\n         }\n-        \n+\n         try {\n             StatUtils.product(x, 0, 4);\n             fail(\"null is not a valid data array.\");\n         } catch (IllegalArgumentException ex) {\n             // success\n         }\n-        \n+\n         // test empty\n         x = new double[] {};\n         TestUtils.assertEquals(Double.NaN, StatUtils.product(x), tolerance);\n         TestUtils.assertEquals(Double.NaN, StatUtils.product(x, 0, 0), tolerance);\n-        \n+\n         // test one\n         x = new double[] {two};\n         TestUtils.assertEquals(two, StatUtils.product(x), tolerance);\n         TestUtils.assertEquals(two, StatUtils.product(x, 0, 1), tolerance);\n-        \n+\n         // test many\n         x = new double[] {one, two, two, three};\n         TestUtils.assertEquals(12, StatUtils.product(x), tolerance);\n         TestUtils.assertEquals(4, StatUtils.product(x, 1, 2), tolerance);\n     }\n-    \n+\n     public void testSumLog() {\n         double[] x = null;\n-        \n+\n         // test null\n         try {\n             StatUtils.sumLog(x);\n         } catch (IllegalArgumentException ex) {\n             // success\n         }\n-        \n+\n         try {\n             StatUtils.sumLog(x, 0, 4);\n             fail(\"null is not a valid data array.\");\n         } catch (IllegalArgumentException ex) {\n             // success\n         }\n-        \n+\n         // test empty\n         x = new double[] {};\n         TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x), tolerance);\n         TestUtils.assertEquals(Double.NaN, StatUtils.sumLog(x, 0, 0), tolerance);\n-        \n+\n         // test one\n         x = new double[] {two};\n         TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x), tolerance);\n         TestUtils.assertEquals(Math.log(two), StatUtils.sumLog(x, 0, 1), tolerance);\n-        \n+\n         // test many\n         x = new double[] {one, two, two, three};\n         TestUtils.assertEquals(Math.log(one) + 2.0 * Math.log(two) + Math.log(three), StatUtils.sumLog(x), tolerance);\n         TestUtils.assertEquals(2.0 * Math.log(two), StatUtils.sumLog(x, 1, 2), tolerance);\n     }\n-    \n+\n     public void testMean() {\n         double[] x = null;\n-        \n+\n         try {\n             StatUtils.mean(x, 0, 4);\n             fail(\"null is not a valid data array.\");\n         } catch (IllegalArgumentException ex) {\n             // success\n         }\n-        \n+\n         // test empty\n         x = new double[] {};\n         TestUtils.assertEquals(Double.NaN, StatUtils.mean(x, 0, 0), tolerance);\n-        \n+\n         // test one\n         x = new double[] {two};\n         TestUtils.assertEquals(two, StatUtils.mean(x, 0, 1), tolerance);\n-        \n+\n         // test many\n         x = new double[] {one, two, two, three};\n         TestUtils.assertEquals(2.5, StatUtils.mean(x, 2, 2), tolerance);\n     }\n-    \n+\n     public void testVariance() {\n         double[] x = null;\n-        \n+\n         try {\n             StatUtils.variance(x, 0, 4);\n             fail(\"null is not a valid data array.\");\n         } catch (IllegalArgumentException ex) {\n             // success\n         }\n-        \n+\n         // test empty\n         x = new double[] {};\n         TestUtils.assertEquals(Double.NaN, StatUtils.variance(x, 0, 0), tolerance);\n-        \n+\n         // test one\n         x = new double[] {two};\n         TestUtils.assertEquals(0.0, StatUtils.variance(x, 0, 1), tolerance);\n-        \n+\n         // test many\n         x = new double[] {one, two, two, three};\n         TestUtils.assertEquals(0.5, StatUtils.variance(x, 2, 2), tolerance);\n-        \n+\n         // test precomputed mean\n         x = new double[] {one, two, two, three};\n         TestUtils.assertEquals(0.5, StatUtils.variance(x,2.5, 2, 2), tolerance);\n     }\n-    \n+\n     public void testMax() {\n         double[] x = null;\n-        \n+\n         try {\n             StatUtils.max(x, 0, 4);\n             fail(\"null is not a valid data array.\");\n         } catch (IllegalArgumentException ex) {\n             // success\n         }\n-        \n+\n         // test empty\n         x = new double[] {};\n         TestUtils.assertEquals(Double.NaN, StatUtils.max(x, 0, 0), tolerance);\n-        \n+\n         // test one\n         x = new double[] {two};\n         TestUtils.assertEquals(two, StatUtils.max(x, 0, 1), tolerance);\n-        \n+\n         // test many\n         x = new double[] {one, two, two, three};\n         TestUtils.assertEquals(three, StatUtils.max(x, 1, 3), tolerance);\n         // test middle nan is ignored\n         x = new double[] {one, nan, three};\n         TestUtils.assertEquals(three, StatUtils.max(x), tolerance);\n-        \n+\n         // test last nan is ignored\n         x = new double[] {one, two, nan};\n         TestUtils.assertEquals(two, StatUtils.max(x), tolerance);\n         x = new double[] {nan, nan, nan};\n         TestUtils.assertEquals(nan, StatUtils.max(x), tolerance);\n     }\n-    \n+\n     public void testMin() {\n         double[] x = null;\n-        \n+\n         try {\n             StatUtils.min(x, 0, 4);\n             fail(\"null is not a valid data array.\");\n         } catch (IllegalArgumentException ex) {\n             // success\n         }\n-        \n+\n         // test empty\n         x = new double[] {};\n         TestUtils.assertEquals(Double.NaN, StatUtils.min(x, 0, 0), tolerance);\n-        \n+\n         // test one\n         x = new double[] {two};\n         TestUtils.assertEquals(two, StatUtils.min(x, 0, 1), tolerance);\n-        \n+\n         // test many\n         x = new double[] {one, two, two, three};\n         TestUtils.assertEquals(two, StatUtils.min(x, 1, 3), tolerance);\n         // test middle nan is ignored\n         x = new double[] {one, nan, three};\n         TestUtils.assertEquals(one, StatUtils.min(x), tolerance);\n-        \n+\n         // test last nan is ignored\n         x = new double[] {one, two, nan};\n         TestUtils.assertEquals(one, StatUtils.min(x), tolerance);\n         x = new double[] {nan, nan, nan};\n         TestUtils.assertEquals(nan, StatUtils.min(x), tolerance);\n     }\n-    \n+\n     public void testPercentile() {\n         double[] x = null;\n-        \n+\n         // test null\n         try {\n             StatUtils.percentile(x, .25);\n         } catch (IllegalArgumentException ex) {\n             // success\n         }\n-        \n+\n         try {\n             StatUtils.percentile(x, 0, 4, 0.25);\n             fail(\"null is not a valid data array.\");\n         } catch (IllegalArgumentException ex) {\n             // success\n         }\n-        \n+\n         // test empty\n         x = new double[] {};\n         TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 25), tolerance);\n         TestUtils.assertEquals(Double.NaN, StatUtils.percentile(x, 0, 0, 25), tolerance);\n-        \n+\n         // test one\n         x = new double[] {two};\n         TestUtils.assertEquals(two, StatUtils.percentile(x, 25), tolerance);\n         TestUtils.assertEquals(two, StatUtils.percentile(x, 0, 1, 25), tolerance);\n-        \n+\n         // test many\n         x = new double[] {one, two, two, three};\n         TestUtils.assertEquals(2.5, StatUtils.percentile(x, 70), tolerance);\n         TestUtils.assertEquals(2.5, StatUtils.percentile(x, 1, 3, 62.5), tolerance);\n     }\n-    \n+\n     public void testDifferenceStats() throws Exception {\n         double sample1[] = {1d, 2d, 3d, 4d};\n         double sample2[] = {1d, 3d, 4d, 2d};\n         double meanDifference = StatUtils.meanDifference(sample1, sample2);\n         assertEquals(StatUtils.sumDifference(sample1, sample2), StatUtils.sum(diff), tolerance);\n         assertEquals(meanDifference, StatUtils.mean(diff), tolerance);\n-        assertEquals(StatUtils.varianceDifference(sample1, sample2, meanDifference), \n+        assertEquals(StatUtils.varianceDifference(sample1, sample2, meanDifference),\n                 StatUtils.variance(diff), tolerance);\n         try {\n             StatUtils.meanDifference(sample1, small);\n             // expected\n         }\n     }\n-    \n+\n     public void testGeometricMean() throws Exception {\n         double[] test = null;\n         try {\n             // expected\n         }\n         test = new double[] {2, 4, 6, 8};\n-        assertEquals(Math.exp(0.25d * StatUtils.sumLog(test)), \n+        assertEquals(Math.exp(0.25d * StatUtils.sumLog(test)),\n                 StatUtils.geometricMean(test), Double.MIN_VALUE);\n-        assertEquals(Math.exp(0.5 * StatUtils.sumLog(test, 0, 2)), \n+        assertEquals(Math.exp(0.5 * StatUtils.sumLog(test, 0, 2)),\n                 StatUtils.geometricMean(test, 0, 2), Double.MIN_VALUE);\n     }\n-}\n+}\n--- a/src/test/java/org/apache/commons/math/stat/clustering/EuclideanIntegerPointTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/clustering/EuclideanIntegerPointTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n         int[] array = { -3, -2, -1, 0, 1 };\n         assertTrue(array == new EuclideanIntegerPoint(array).getPoint());\n     }\n-    \n+\n     @Test\n     public void testDistance() {\n         EuclideanIntegerPoint e1 = new EuclideanIntegerPoint(new int[] { -3, -2, -1, 0, 1 });\n         assertEquals(0.0, e1.distanceFrom(e1), 1.0e-15);\n         assertEquals(0.0, e2.distanceFrom(e2), 1.0e-15);\n     }\n-    \n+\n     @Test\n     public void testCentroid() {\n         List<EuclideanIntegerPoint> list = new ArrayList<EuclideanIntegerPoint>();\n         assertEquals(2, c.getPoint()[0]);\n         assertEquals(3, c.getPoint()[1]);\n     }\n-    \n+\n     @Test\n     public void testSerial() {\n         EuclideanIntegerPoint p = new EuclideanIntegerPoint(new int[] { -3, -2, -1, 0, 1 });\n         assertEquals(p, TestUtils.serializeAndRecover(p));\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/math/stat/correlation/CovarianceTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/correlation/CovarianceTest.java\n import junit.framework.TestCase;\n \n public class CovarianceTest extends TestCase {\n-    \n+\n     protected final double[] longleyData = new double[] {\n             60323,83.0,234289,2356,1590,107608,1947,\n             61122,88.5,259426,2325,1456,108632,1948,\n             69331,115.7,518173,4806,2572,127852,1961,\n             70551,116.9,554894,4007,2827,130081,1962\n         };\n-    \n+\n     protected final double[] swissData = new double[] {\n             80.2,17.0,15,12,9.96,\n             83.1,45.1,6,9,84.84,\n             44.7,46.6,16,29,50.43,\n             42.8,27.7,22,29,58.33\n         };\n- \n-    \n+\n+\n     /**\n      * Test Longley dataset against R.\n      * Data Source: J. Longley (1967) \"An Appraisal of Least Squares\n      * Programs for the Electronic Computer from the Point of View of the User\"\n      * Journal of the American Statistical Association, vol. 62. September,\n      * pp. 819-841.\n-     * \n+     *\n      * Data are from NIST:\n      * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat\n      */\n-    public void testLongly() {  \n+    public void testLongly() {\n         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);\n         RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();\n         double[] rData = new double[] {\n          16240.93333333333, 5.092333333333334e+01, 470977.900000000,\n          2973.033333333333, 1382.433333333333, 32917.40000000, 22.66666666666667\n         };\n-        \n+\n         TestUtils.assertEquals(\"covariance matrix\", createRealMatrix(rData, 7, 7), covarianceMatrix, 10E-9);\n \n     }\n-    \n+\n     /**\n      * Test R Swiss fertility dataset against R.\n      * Data Source: R datasets package\n            -79.7295097132285, -139.6574005550416, 53.57585568917669, 92.4560592044403, -61.6988297872340,\n             241.5632030527289, 379.9043755781684, -190.56061054579092, -61.6988297872340, 1739.2945371877890\n          };\n-         \n+\n          TestUtils.assertEquals(\"covariance matrix\", createRealMatrix(rData, 5, 5), covarianceMatrix, 10E-13);\n     }\n-    \n+\n     /**\n      * Constant column\n      */\n         assertEquals(0d, new Covariance().covariance(noVariance, values, true), Double.MIN_VALUE);\n         assertEquals(0d, new Covariance().covariance(noVariance, noVariance, true), Double.MIN_VALUE);\n     }\n-    \n-    \n+\n+\n     /**\n      * Insufficient data\n      */\n             // Expected\n         }\n     }\n-    \n+\n     /**\n      * Verify that diagonal entries are consistent with Variance computation and matrix matches\n      * column-by-column covariances\n     public void testConsistency() {\n         final RealMatrix matrix = createRealMatrix(swissData, 47, 5);\n         final RealMatrix covarianceMatrix = new Covariance(matrix).getCovarianceMatrix();\n-        \n+\n         // Variances on the diagonal\n         Variance variance = new Variance();\n         for (int i = 0; i < 5; i++) {\n             assertEquals(variance.evaluate(matrix.getColumn(i)), covarianceMatrix.getEntry(i,i), 10E-14);\n         }\n-        \n+\n         // Symmetry, column-consistency\n-        assertEquals(covarianceMatrix.getEntry(2, 3), \n+        assertEquals(covarianceMatrix.getEntry(2, 3),\n                 new Covariance().covariance(matrix.getColumn(2), matrix.getColumn(3), true), 10E-14);\n         assertEquals(covarianceMatrix.getEntry(2, 3), covarianceMatrix.getEntry(3, 2), Double.MIN_VALUE);\n-        \n+\n         // All columns same -> all entries = column variance\n         RealMatrix repeatedColumns = new Array2DRowRealMatrix(47, 3);\n         for (int i = 0; i < 3; i++) {\n                 assertEquals(columnVariance, repeatedCovarianceMatrix.getEntry(i, j), 10E-14);\n             }\n         }\n-        \n+\n         // Check bias-correction defaults\n         double[][] data = matrix.getData();\n-        TestUtils.assertEquals(\"Covariances\", \n+        TestUtils.assertEquals(\"Covariances\",\n                 covarianceMatrix, new Covariance().computeCovarianceMatrix(data),Double.MIN_VALUE);\n-        TestUtils.assertEquals(\"Covariances\", \n+        TestUtils.assertEquals(\"Covariances\",\n                 covarianceMatrix, new Covariance().computeCovarianceMatrix(data, true),Double.MIN_VALUE);\n-        \n+\n         double[] x = data[0];\n         double[] y = data[1];\n-        assertEquals(new Covariance().covariance(x, y), \n-                new Covariance().covariance(x, y, true), Double.MIN_VALUE); \n-    }\n-    \n+        assertEquals(new Covariance().covariance(x, y),\n+                new Covariance().covariance(x, y, true), Double.MIN_VALUE);\n+    }\n+\n     protected RealMatrix createRealMatrix(double[] data, int nRows, int nCols) {\n         double[][] matrixData = new double[nRows][nCols];\n         int ptr = 0;\n             System.arraycopy(data, ptr, matrixData[i], 0, nCols);\n             ptr += nCols;\n         }\n-        return new Array2DRowRealMatrix(matrixData); \n+        return new Array2DRowRealMatrix(matrixData);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/stat/correlation/PearsonsCorrelationTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/correlation/PearsonsCorrelationTest.java\n import junit.framework.TestCase;\n \n public class PearsonsCorrelationTest extends TestCase {\n-    \n+\n     protected final double[] longleyData = new double[] {\n             60323,83.0,234289,2356,1590,107608,1947,\n             61122,88.5,259426,2325,1456,108632,1948,\n             69331,115.7,518173,4806,2572,127852,1961,\n             70551,116.9,554894,4007,2827,130081,1962\n         };\n-    \n+\n     protected final double[] swissData = new double[] {\n             80.2,17.0,15,12,9.96,\n             83.1,45.1,6,9,84.84,\n             44.7,46.6,16,29,50.43,\n             42.8,27.7,22,29,58.33\n         };\n- \n-    \n+\n+\n     /**\n      * Test Longley dataset against R.\n      */\n-    public void testLongly() throws Exception {  \n+    public void testLongly() throws Exception {\n         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);\n-        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix); \n+        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);\n         RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();\n         double[] rData = new double[] {\n                 1.000000000000000, 0.9708985250610560, 0.9835516111796693, 0.5024980838759942,\n                 0.3644162671890320, 1.000000000000000, 0.9939528462329257,\n                 0.971329459192119, 0.9911491900672053, 0.9952734837647849, 0.6682566045621746,\n                 0.4172451498349454, 0.993952846232926, 1.0000000000000000\n-        }; \n+        };\n         TestUtils.assertEquals(\"correlation matrix\", createRealMatrix(rData, 7, 7), correlationMatrix, 10E-15);\n-        \n+\n         double[] rPvalues = new double[] {\n                 4.38904690369668e-10,\n                 8.36353208910623e-12, 7.8159700933611e-14,\n-                0.0472894097790304, 0.01030636128354301, 0.01316878049026582, \n+                0.0472894097790304, 0.01030636128354301, 0.01316878049026582,\n                 0.0749178049642416, 0.06971758330341182, 0.0830166169296545, 0.510948586323452,\n-                3.693245043123738e-09, 4.327782576751815e-11, 1.167954621905665e-13, 0.00331028281967516, 0.1652293725106684, \n+                3.693245043123738e-09, 4.327782576751815e-11, 1.167954621905665e-13, 0.00331028281967516, 0.1652293725106684,\n                 3.95834476307755e-10, 1.114663916723657e-13, 1.332267629550188e-15, 0.00466039138541463, 0.1078477071581498, 7.771561172376096e-15\n         };\n         RealMatrix rPMatrix = createLowerTriangularRealMatrix(rPvalues, 7);\n         fillUpper(rPMatrix, 0d);\n         TestUtils.assertEquals(\"correlation p values\", rPMatrix, corrInstance.getCorrelationPValues(), 10E-15);\n     }\n-    \n+\n     /**\n      * Test R Swiss fertility dataset against R.\n      */\n     public void testSwissFertility() throws Exception {\n          RealMatrix matrix = createRealMatrix(swissData, 47, 5);\n-         PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix); \n+         PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);\n          RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();\n          double[] rData = new double[] {\n                1.0000000000000000, 0.3530791836199747, -0.6458827064572875, -0.6637888570350691,  0.4636847006517939,\n                  0.4636847006517939, 0.4010950530487398, -0.5727418060641666, -0.1538589170909148, 1.0000000000000000\n          };\n          TestUtils.assertEquals(\"correlation matrix\", createRealMatrix(rData, 5, 5), correlationMatrix, 10E-15);\n-         \n+\n          double[] rPvalues = new double[] {\n                  0.01491720061472623,\n                  9.45043734069043e-07, 9.95151527133974e-08,\n          fillUpper(rPMatrix, 0d);\n          TestUtils.assertEquals(\"correlation p values\", rPMatrix, corrInstance.getCorrelationPValues(), 10E-15);\n     }\n-    \n+\n     /**\n      * Constant column\n      */\n         double[] values = new double[] {1, 2, 3, 4};\n         assertTrue(Double.isNaN(new PearsonsCorrelation().correlation(noVariance, values)));\n     }\n-    \n-    \n+\n+\n     /**\n      * Insufficient data\n      */\n-     \n+\n     public void testInsufficientData() {\n         double[] one = new double[] {1};\n         double[] two = new double[] {2};\n             // Expected\n         }\n     }\n-    \n+\n     /**\n      * Verify that direct t-tests using standard error estimates are consistent\n      * with reported p-values\n     public void testStdErrorConsistency() throws Exception {\n         TDistribution tDistribution = new TDistributionImpl(45);\n         RealMatrix matrix = createRealMatrix(swissData, 47, 5);\n-        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix); \n+        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);\n         RealMatrix rValues = corrInstance.getCorrelationMatrix();\n         RealMatrix pValues = corrInstance.getCorrelationPValues();\n         RealMatrix stdErrors = corrInstance.getCorrelationStandardErrors();\n             }\n         }\n     }\n-    \n+\n     /**\n      * Verify that creating correlation from covariance gives same results as\n      * direct computation from the original matrix\n      */\n     public void testCovarianceConsistency() throws Exception {\n         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);\n-        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix); \n+        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);\n         Covariance covInstance = new Covariance(matrix);\n         PearsonsCorrelation corrFromCovInstance = new PearsonsCorrelation(covInstance);\n         TestUtils.assertEquals(\"correlation values\", corrInstance.getCorrelationMatrix(),\n                 corrFromCovInstance.getCorrelationPValues(), 10E-15);\n         TestUtils.assertEquals(\"standard errors\", corrInstance.getCorrelationStandardErrors(),\n                 corrFromCovInstance.getCorrelationStandardErrors(), 10E-15);\n-        \n-        PearsonsCorrelation corrFromCovInstance2 = \n+\n+        PearsonsCorrelation corrFromCovInstance2 =\n             new PearsonsCorrelation(covInstance.getCovarianceMatrix(), 16);\n         TestUtils.assertEquals(\"correlation values\", corrInstance.getCorrelationMatrix(),\n                 corrFromCovInstance2.getCorrelationMatrix(), 10E-15);\n         TestUtils.assertEquals(\"standard errors\", corrInstance.getCorrelationStandardErrors(),\n                 corrFromCovInstance2.getCorrelationStandardErrors(), 10E-15);\n     }\n-    \n-     \n+\n+\n     public void testConsistency() {\n         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);\n-        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix); \n+        PearsonsCorrelation corrInstance = new PearsonsCorrelation(matrix);\n         double[][] data = matrix.getData();\n         double[] x = matrix.getColumn(0);\n         double[] y = matrix.getColumn(1);\n-        assertEquals(new PearsonsCorrelation().correlation(x, y), \n+        assertEquals(new PearsonsCorrelation().correlation(x, y),\n                 corrInstance.getCorrelationMatrix().getEntry(0, 1), Double.MIN_VALUE);\n         TestUtils.assertEquals(\"Correlation matrix\", corrInstance.getCorrelationMatrix(),\n                 new PearsonsCorrelation().computeCorrelationMatrix(data), Double.MIN_VALUE);\n     }\n-    \n+\n     protected RealMatrix createRealMatrix(double[] data, int nRows, int nCols) {\n         double[][] matrixData = new double[nRows][nCols];\n         int ptr = 0;\n             System.arraycopy(data, ptr, matrixData[i], 0, nCols);\n             ptr += nCols;\n         }\n-        return new BlockRealMatrix(matrixData); \n-    }\n-    \n+        return new BlockRealMatrix(matrixData);\n+    }\n+\n     protected RealMatrix createLowerTriangularRealMatrix(double[] data, int dimension) {\n         int ptr = 0;\n         RealMatrix result = new BlockRealMatrix(dimension, dimension);\n         }\n         return result;\n     }\n-    \n+\n     protected void fillUpper(RealMatrix matrix, double diagonalValue) {\n         int dimension = matrix.getColumnDimension();\n         for (int i = 0; i < dimension; i++) {\n             for (int j = i+1; j < dimension; j++) {\n                 matrix.setEntry(i, j, matrix.getEntry(j, i));\n             }\n-        }  \n+        }\n     }\n }\n--- a/src/test/java/org/apache/commons/math/stat/correlation/SpearmansRankCorrelationTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/correlation/SpearmansRankCorrelationTest.java\n \n /**\n  * Test cases for Spearman's rank correlation\n- * \n+ *\n  * @since 2.0\n  * @version $Revision$ $Date$\n  */\n     protected void tearDown() throws Exception {\n         super.tearDown();\n     }\n-    \n+\n     /**\n      * Test Longley dataset against R.\n      */\n     @Override\n-    public void testLongly() throws Exception {  \n+    public void testLongly() throws Exception {\n         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);\n-        SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix); \n+        SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix);\n         RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();\n         double[] rData = new double[] {\n                 1, 0.982352941176471, 0.985294117647059, 0.564705882352941, 0.2264705882352941, 0.976470588235294,\n                 0.2205882352941176, 0.2235294117647059, -0.3411764705882353, 1, 0.2264705882352941, 0.2264705882352941,\n                 0.976470588235294, 0.997058823529412, 0.9941176470588236, 0.685294117647059, 0.2264705882352941, 1, 1,\n                 0.976470588235294, 0.997058823529412, 0.9941176470588236, 0.685294117647059, 0.2264705882352941, 1, 1\n-        }; \n+        };\n         TestUtils.assertEquals(\"Spearman's correlation matrix\", createRealMatrix(rData, 7, 7), correlationMatrix, 10E-15);\n     }\n-    \n+\n     /**\n      * Test R swiss fertility dataset.\n      */\n-    public void testSwiss() throws Exception {  \n+    public void testSwiss() throws Exception {\n         RealMatrix matrix = createRealMatrix(swissData, 47, 5);\n-        SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix); \n+        SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix);\n         RealMatrix correlationMatrix = corrInstance.getCorrelationMatrix();\n         double[] rData = new double[] {\n                 1, 0.2426642769364176, -0.660902996352354, -0.443257690360988, 0.4136455623012432,\n                -0.660902996352354, -0.598859938748963, 1, 0.674603831406147, -0.4750575257171745,\n                -0.443257690360988, -0.650463814145816, 0.674603831406147, 1, -0.1444163088302244,\n                 0.4136455623012432, 0.2886878090882852, -0.4750575257171745, -0.1444163088302244, 1\n-        }; \n+        };\n         TestUtils.assertEquals(\"Spearman's correlation matrix\", createRealMatrix(rData, 5, 5), correlationMatrix, 10E-15);\n     }\n-    \n+\n     /**\n      * Constant column\n      */\n         double[] values = new double[] {1, 2, 3, 4};\n         assertTrue(Double.isNaN(new SpearmansCorrelation().correlation(noVariance, values)));\n     }\n-    \n+\n     /**\n      * Insufficient data\n-     */ \n+     */\n     @Override\n     public void testInsufficientData() {\n         double[] one = new double[] {1};\n             // Expected\n         }\n     }\n-    \n+\n     @Override\n     public void testConsistency() {\n         RealMatrix matrix = createRealMatrix(longleyData, 16, 7);\n-        SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix); \n+        SpearmansCorrelation corrInstance = new SpearmansCorrelation(matrix);\n         double[][] data = matrix.getData();\n         double[] x = matrix.getColumn(0);\n         double[] y = matrix.getColumn(1);\n-        assertEquals(new SpearmansCorrelation().correlation(x, y), \n+        assertEquals(new SpearmansCorrelation().correlation(x, y),\n                 corrInstance.getCorrelationMatrix().getEntry(0, 1), Double.MIN_VALUE);\n         TestUtils.assertEquals(\"Correlation matrix\", corrInstance.getCorrelationMatrix(),\n                 new SpearmansCorrelation().computeCorrelationMatrix(data), Double.MIN_VALUE);\n     }\n-    \n+\n     // Not relevant here\n     @Override\n     public void testStdErrorConsistency() throws Exception {}\n     @Override\n     public void testCovarianceConsistency() throws Exception {}\n-     \n+\n }\n--- a/src/test/java/org/apache/commons/math/stat/data/CertifiedDataAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/data/CertifiedDataAbstractTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * @version $Revision$ $Date$\n  */\n public abstract class CertifiedDataAbstractTest extends TestCase {\n-    \n+\n     private DescriptiveStatistics descriptives;\n-    \n+\n     private SummaryStatistics summaries;\n-    \n+\n     private Map<String, Double> certifiedValues;\n \n     @Override\n         descriptives = new DescriptiveStatistics();\n         summaries = new SummaryStatistics();\n         certifiedValues = new HashMap<String, Double>();\n-        \n+\n         loadData();\n     }\n \n         try {\n             URL resourceURL = getClass().getClassLoader().getResource(getResourceName());\n             in = new BufferedReader(new InputStreamReader(resourceURL.openStream()));\n-            \n+\n             String line = in.readLine();\n             while (line != null) {\n-                \n-                /* this call to StringUtils did little for the \n-                 * following conditional structure \n+\n+                /* this call to StringUtils did little for the\n+                 * following conditional structure\n                  */\n                 line = line.trim();\n \n     protected void tearDown() throws Exception {\n         descriptives.clear();\n         descriptives = null;\n-        \n+\n         summaries.clear();\n         summaries = null;\n-        \n+\n         certifiedValues.clear();\n         certifiedValues = null;\n     }\n-    \n+\n     public void testCertifiedValues() {\n         for (String name : certifiedValues.keySet()) {\n             Double expectedValue = certifiedValues.get(name);\n             }\n         }\n     }\n-    \n-    \n+\n+\n     protected Double getProperty(Object bean, String name) {\n         try {\n             // Get the value of prop\n-            String prop = \"get\" + name.substring(0,1).toUpperCase() + name.substring(1); \n+            String prop = \"get\" + name.substring(0,1).toUpperCase() + name.substring(1);\n             Method meth = bean.getClass().getMethod(prop, new Class[0]);\n             Object property = meth.invoke(bean, new Object[0]);\n             if (meth.getReturnType().equals(Double.TYPE)) {\n--- a/src/test/java/org/apache/commons/math/stat/data/LewTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/data/LewTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/test/java/org/apache/commons/math/stat/data/LotteryTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/data/LotteryTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatisticTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatisticTest.java\n import org.apache.commons.math.stat.descriptive.moment.Mean;\n \n /**\n- * Tests for AbstractUnivariateStatistic \n+ * Tests for AbstractUnivariateStatistic\n  *\n  * @version $Revision$ $Date$\n  */\n public class AbstractUnivariateStatisticTest extends TestCase {\n-    \n+\n     public AbstractUnivariateStatisticTest(String name) {\n         super(name);\n     }\n-    \n+\n     public static Test suite() {\n         TestSuite suite = new TestSuite(AbstractUnivariateStatisticTest.class);\n         suite.setName(\"AbstractUnivariateStatistic Tests\");\n         return suite;\n     }\n-    \n+\n     protected double[] testArray = {0, 1, 2, 3, 4, 5};\n     protected double[] testWeightsArray = {0.3, 0.2, 1.3, 1.1, 1.0, 1.8};\n     protected double[] testNegativeWeightsArray = {-0.3, 0.2, -1.3, 1.1, 1.0, 1.8};\n     protected double[] nullArray = null;\n     protected double[] singletonArray = {0};\n     protected Mean testStatistic = new Mean();\n-    \n+\n     public void testTestPositive() {\n         for (int j = 0; j < 6; j++) {\n             for (int i = 1; i < (7 - j); i++) {\n                 assertTrue(testStatistic.test(testArray, 0, i));\n-            }  \n+            }\n         }\n         assertTrue(testStatistic.test(singletonArray, 0, 1));\n     }\n-    \n+\n     public void testTestNegative() {\n         assertFalse(testStatistic.test(singletonArray, 0, 0));\n         assertFalse(testStatistic.test(testArray, 0, 0));\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/AggregateSummaryStatisticsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/AggregateSummaryStatisticsTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  *\n  */\n public class AggregateSummaryStatisticsTest extends TestCase {\n-    \n+\n     /**\n      * Creates and returns a {@code Test} representing all the test cases in this\n      * class\n         suite.setName(\"AggregateSummaryStatistics tests\");\n         return suite;\n     }\n-    \n+\n     /**\n      * Tests the standard aggregation behavior\n      */\n         AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();\n         SummaryStatistics setOneStats = aggregate.createContributingStatistics();\n         SummaryStatistics setTwoStats = aggregate.createContributingStatistics();\n-        \n+\n         assertNotNull(\"The set one contributing stats are null\", setOneStats);\n         assertNotNull(\"The set two contributing stats are null\", setTwoStats);\n         assertNotSame(\"Contributing stats objects are the same\", setOneStats, setTwoStats);\n-        \n+\n         setOneStats.addValue(2);\n         setOneStats.addValue(3);\n         setOneStats.addValue(5);\n         setOneStats.addValue(11);\n         assertEquals(\"Wrong number of set one values\", 5, setOneStats.getN());\n         assertEquals(\"Wrong sum of set one values\", 28.0, setOneStats.getSum());\n-        \n+\n         setTwoStats.addValue(2);\n         setTwoStats.addValue(4);\n         setTwoStats.addValue(8);\n         assertEquals(\"Wrong number of set two values\", 3, setTwoStats.getN());\n         assertEquals(\"Wrong sum of set two values\", 14.0, setTwoStats.getSum());\n-        \n+\n         assertEquals(\"Wrong number of aggregate values\", 8, aggregate.getN());\n         assertEquals(\"Wrong aggregate sum\", 42.0, aggregate.getSum());\n     }\n-    \n+\n     /**\n      * Verify that aggregating over a partition gives the same results\n      * as direct computation.\n-     * \n+     *\n      *  1) Randomly generate a dataset of 10-100 values\n      *     from [-100, 100]\n      *  2) Divide the dataset it into 2-5 partitions\n      *  3) Create an AggregateSummaryStatistic and ContributingStatistics\n-     *     for each partition \n+     *     for each partition\n      *  4) Compare results from the AggregateSummaryStatistic with values\n-     *     returned by a single SummaryStatistics instance that is provided \n+     *     returned by a single SummaryStatistics instance that is provided\n      *     the full dataset\n      */\n     public void testAggregationConsistency() throws Exception {\n-        \n+\n         // Generate a random sample and random partition\n         double[] totalSample = generateSample();\n         double[][] subSamples = generatePartition(totalSample);\n         int nSamples = subSamples.length;\n-        \n+\n         // Create aggregator and total stats for comparison\n         AggregateSummaryStatistics aggregate = new AggregateSummaryStatistics();\n         SummaryStatistics totalStats = new SummaryStatistics();\n-        \n+\n         // Create array of component stats\n         SummaryStatistics componentStats[] = new SummaryStatistics[nSamples];\n-        \n+\n         for (int i = 0; i < nSamples; i++) {\n-            \n+\n             // Make componentStats[i] a contributing statistic to aggregate\n             componentStats[i] = aggregate.createContributingStatistics();\n-            \n+\n             // Add values from subsample\n             for (int j = 0; j < subSamples[i].length; j++) {\n                 componentStats[i].addValue(subSamples[i][j]);\n             }\n         }\n-        \n+\n         // Compute totalStats directly\n         for (int i = 0; i < totalSample.length; i++) {\n             totalStats.addValue(totalSample[i]);\n         }\n-        \n+\n         /*\n          * Compare statistics in totalStats with aggregate.\n          * Note that guaranteed success of this comparison depends on the\n          * fact that <aggregate> gets values in exactly the same order\n-         * as <totalStats>. \n-         *  \n+         * as <totalStats>.\n+         *\n          */\n-        assertEquals(totalStats.getSummary(), aggregate.getSummary());  \n-        \n-    }\n-    \n+        assertEquals(totalStats.getSummary(), aggregate.getSummary());\n+\n+    }\n+\n     /**\n      * Test aggregate function by randomly generating a dataset of 10-100 values\n      * from [-100, 100], dividing it into 2-5 partitions, computing stats for each\n      * partition and comparing the result of aggregate(...) applied to the collection\n      * of per-partition SummaryStatistics with a single SummaryStatistics computed\n      * over the full sample.\n-     * \n+     *\n      * @throws Exception\n      */\n     public void testAggregate() throws Exception {\n-        \n+\n         // Generate a random sample and random partition\n         double[] totalSample = generateSample();\n         double[][] subSamples = generatePartition(totalSample);\n         int nSamples = subSamples.length;\n-       \n+\n         // Compute combined stats directly\n         SummaryStatistics totalStats = new SummaryStatistics();\n         for (int i = 0; i < totalSample.length; i++) {\n             totalStats.addValue(totalSample[i]);\n         }\n-        \n+\n         // Now compute subsample stats individually and aggregate\n         SummaryStatistics[] subSampleStats = new SummaryStatistics[nSamples];\n         for (int i = 0; i < nSamples; i++) {\n         }\n         Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();\n         for (int i = 0; i < nSamples; i++) {\n-            for (int j = 0; j < subSamples[i].length; j++) { \n+            for (int j = 0; j < subSamples[i].length; j++) {\n                 subSampleStats[i].addValue(subSamples[i][j]);\n             }\n             aggregate.add(subSampleStats[i]);\n         }\n-        \n+\n         // Compare values\n         StatisticalSummary aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);\n         assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12);\n     }\n-    \n-    \n+\n+\n     public void testAggregateDegenerate() throws Exception {\n         double[] totalSample = {1, 2, 3, 4, 5};\n         double[][] subSamples = {{1}, {2}, {3}, {4}, {5}};\n-        \n+\n         // Compute combined stats directly\n         SummaryStatistics totalStats = new SummaryStatistics();\n         for (int i = 0; i < totalSample.length; i++) {\n             totalStats.addValue(totalSample[i]);\n         }\n-        \n+\n         // Now compute subsample stats individually and aggregate\n         SummaryStatistics[] subSampleStats = new SummaryStatistics[5];\n         for (int i = 0; i < 5; i++) {\n         }\n         Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();\n         for (int i = 0; i < 5; i++) {\n-            for (int j = 0; j < subSamples[i].length; j++) { \n+            for (int j = 0; j < subSamples[i].length; j++) {\n                 subSampleStats[i].addValue(subSamples[i][j]);\n             }\n             aggregate.add(subSampleStats[i]);\n         }\n-        \n+\n         // Compare values\n         StatisticalSummaryValues aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);\n         assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12);\n     }\n-    \n+\n     public void testAggregateSpecialValues() throws Exception {\n         double[] totalSample = {Double.POSITIVE_INFINITY, 2, 3, Double.NaN, 5};\n         double[][] subSamples = {{Double.POSITIVE_INFINITY, 2}, {3}, {Double.NaN}, {5}};\n-        \n+\n         // Compute combined stats directly\n         SummaryStatistics totalStats = new SummaryStatistics();\n         for (int i = 0; i < totalSample.length; i++) {\n             totalStats.addValue(totalSample[i]);\n         }\n-        \n+\n         // Now compute subsample stats individually and aggregate\n         SummaryStatistics[] subSampleStats = new SummaryStatistics[5];\n         for (int i = 0; i < 4; i++) {\n         }\n         Collection<SummaryStatistics> aggregate = new ArrayList<SummaryStatistics>();\n         for (int i = 0; i < 4; i++) {\n-            for (int j = 0; j < subSamples[i].length; j++) { \n+            for (int j = 0; j < subSamples[i].length; j++) {\n                 subSampleStats[i].addValue(subSamples[i][j]);\n             }\n             aggregate.add(subSampleStats[i]);\n         }\n-        \n+\n         // Compare values\n         StatisticalSummaryValues aggregatedStats = AggregateSummaryStatistics.aggregate(aggregate);\n         assertEquals(totalStats.getSummary(), aggregatedStats, 10E-12);\n-        \n-    }\n-    \n+\n+    }\n+\n     /**\n      * Verifies that a StatisticalSummary and a StatisticalSummaryValues are equal up\n      * to delta, with NaNs, infinities returned in the same spots. For max, min, n, values\n         TestUtils.assertEquals(expected.getVariance(), observed.getVariance(), delta);\n     }\n \n-    \n+\n     /**\n      * Generates a random sample of double values.\n-     * Sample size is random, between 10 and 100 and values are \n+     * Sample size is random, between 10 and 100 and values are\n      * uniformly distributed over [-100, 100].\n-     * \n+     *\n      * @return array of random double values\n      */\n     private double[] generateSample() {\n         for (int i = 0; i < out.length; i++) {\n             out[i] = randomData.nextUniform(-100, 100);\n         }\n-        return out;     \n-    }\n-    \n+        return out;\n+    }\n+\n     /**\n      * Generates a partition of <sample> into up to 5 sequentially selected\n      * subsamples with randomly selected partition points.\n-     * \n+     *\n      * @param sample array to partition\n      * @return rectangular array with rows = subsamples\n      */\n             return out;\n         }\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsTest.java\n \n /**\n  * Test cases for the DescriptiveStatistics class.\n- * \n+ *\n  * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n  *          2007) $\n  */\n         stats.setMeanImpl(new deepMean());\n         assertEquals(42, stats.getMean(), 1E-10);\n     }\n-    \n+\n     public void testCopy() {\n         DescriptiveStatistics stats = createDescriptiveStatistics();\n         stats.addValue(1);\n         copy = stats.copy();\n         assertEquals(42, copy.getMean(), 1E-10);\n     }\n-    \n+\n     public void testWindowSize() {\n         DescriptiveStatistics stats = createDescriptiveStatistics();\n         stats.setWindowSize(300);\n         int refSum2 = refSum - (50 * 51) / 2;\n         assertEquals(refSum2 / 50.0, stats.getMean(), 1E-10);\n     }\n-    \n+\n     public void testGetValues() {\n         DescriptiveStatistics stats = createDescriptiveStatistics();\n         for (int i = 100; i > 0; --i) {\n         }\n         assertEquals(12.0, stats.getElement(88), 1.0e-10);\n     }\n-    \n+\n     public void testToString() {\n         DescriptiveStatistics stats = createDescriptiveStatistics();\n         stats.addValue(1);\n         assertEquals(reference.getGeometricMean(), shuffled.getSumsq(), 1.0e-10);\n \n     }\n-    \n+\n     public void testPercentileSetter() throws Exception {\n         DescriptiveStatistics stats = createDescriptiveStatistics();\n         stats.addValue(1);\n         stats.addValue(2);\n         stats.addValue(3);\n         assertEquals(2, stats.getPercentile(50.0), 1E-10);\n-        \n+\n         // Inject wrapped Percentile impl\n         stats.setPercentileImpl(new goodPercentile());\n         assertEquals(2, stats.getPercentile(50.0), 1E-10);\n-        \n+\n         // Try \"new math\" impl\n         stats.setPercentileImpl(new subPercentile());\n         assertEquals(10.0, stats.getPercentile(10.0), 1E-10);\n-        \n+\n         // Try to set bad impl\n         try {\n-            stats.setPercentileImpl(new badPercentile()); \n+            stats.setPercentileImpl(new badPercentile());\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         assertTrue(MathUtils.equals(mean3, dstat.getMean()));\n \n     }\n-    \n+\n     // Test UnivariateStatistics impls for setter injection tests\n-    \n+\n     /**\n-     * A new way to compute the mean \n+     * A new way to compute the mean\n      */\n     static class deepMean implements UnivariateStatistic {\n \n \n         public double evaluate(double[] values) {\n             return 42;\n-        }  \n+        }\n         public UnivariateStatistic copy() {\n             return new deepMean();\n         }\n     }\n-    \n+\n     /**\n      * Test percentile implementation - wraps a Percentile\n      */\n         }\n         public double evaluate(double[] values) {\n             return percentile.evaluate(values);\n-        }  \n+        }\n         public UnivariateStatistic copy() {\n             goodPercentile result = new goodPercentile();\n             result.setQuantile(percentile.getQuantile());\n             return result;\n         }\n     }\n-    \n+\n     /**\n      * Test percentile subclass - another \"new math\" impl\n      * Always returns currently set quantile\n         @Override\n         public double evaluate(double[] values) {\n             return getQuantile();\n-        }  \n+        }\n         private static final long serialVersionUID = 8040701391045914979L;\n         @Override\n         public Percentile copy() {\n             return result;\n         }\n     }\n-    \n+\n     /**\n      * \"Bad\" test percentile implementation - no setQuantile\n      */\n             return new badPercentile();\n         }\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/InteractionTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/InteractionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n \n     public void testInteraction() {\n-        \n+\n         FourthMoment m4 = new FourthMoment();\n         Mean m = new Mean(m4);\n         Variance v = new Variance(m4);\n         for (int i = 0; i < testArray.length; i++){\n             m4.increment(testArray[i]);\n         }\n-        \n+\n         assertEquals(mean,m.getResult(),tolerance);\n         assertEquals(var,v.getResult(),tolerance);\n         assertEquals(skew ,s.getResult(),tolerance);\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -8837442489133392138L;\n-    \n+\n     /**\n      * Holds a reference to a list - GENERICs are going to make\n      * our lives easier here as we could only accept List<Number>\n     public ListUnivariateImpl(){\n         this(new ArrayList<Object>());\n     }\n-    \n+\n     /**\n      * Construct a ListUnivariate with a specific List.\n      * @param list The list that will back this DescriptiveStatistics\n     public ListUnivariateImpl(List<Object> list) {\n         this(list, new DefaultTransformer());\n     }\n-    \n+\n     /**\n      * Construct a ListUnivariate with a specific List.\n      * @param list The list that will back this DescriptiveStatistics\n             calcIndex = (list.size() - windowSize) + index;\n         }\n \n-        \n+\n         try {\n             value = transformer.transform(list.get(calcIndex));\n         } catch (MathException e) {\n             e.printStackTrace();\n         }\n-        \n+\n         return value;\n     }\n \n     public void addValue(double v) {\n         list.add(Double.valueOf(v));\n     }\n-    \n-    /**\n-     * Adds an object to this list. \n+\n+    /**\n+     * Adds an object to this list.\n      * @param o Object to add to the list\n      */\n     public void addObject(Object o) {\n     public void clear() {\n         list.clear();\n     }\n-    \n+\n     /**\n      * Apply the given statistic to this univariate collection.\n      * @param stat the statistic to apply\n         }\n         return Double.NaN;\n     }\n-    \n+\n     /**\n      * Access the number transformer.\n      * @return the number transformer.\n     public void setTransformer(NumberTransformer transformer) {\n         this.transformer = transformer;\n     }\n-    \n+\n     /** {@inheritDoc} */\n     @Override\n     public synchronized void setWindowSize(int windowSize) {\n         this.windowSize = windowSize;\n-        //Discard elements from the front of the list if the windowSize is less than \n+        //Discard elements from the front of the list if the windowSize is less than\n         // the size of the list.\n         int extra = list.size() - windowSize;\n         for (int i = 0; i < extra; i++) {\n         return windowSize;\n     }\n \n-}\n+}\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/ListUnivariateImplTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/ListUnivariateImplTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  */\n \n public final class ListUnivariateImplTest extends TestCase {\n-    \n+\n     private double one = 1;\n     private float two = 2;\n     private int three = 3;\n     private double min = 1;\n     private double max = 3;\n     private double tolerance = 10E-15;\n-    \n+\n     public ListUnivariateImplTest(String name) {\n         super(name);\n     }\n-    \n+\n     public static Test suite() {\n         TestSuite suite = new TestSuite(ListUnivariateImplTest.class);\n         suite.setName(\"Frequency Tests\");\n         return suite;\n     }\n-    \n+\n     /** test stats */\n     public void testStats() {\n         List<Object> externalList = new ArrayList<Object>();\n-        \n-        DescriptiveStatistics u = new ListUnivariateImpl( externalList ); \n+\n+        DescriptiveStatistics u = new ListUnivariateImpl( externalList );\n \n         assertEquals(\"total count\",0,u.getN(),tolerance);\n         u.addValue(one);\n         assertEquals(\"min\",min,u.getMin(),tolerance);\n         assertEquals(\"max\",max,u.getMax(),tolerance);\n         u.clear();\n-        assertEquals(\"total count\",0,u.getN(),tolerance);    \n-    }     \n-    \n+        assertEquals(\"total count\",0,u.getN(),tolerance);\n+    }\n+\n     public void testN0andN1Conditions() throws Exception {\n         List<Object> list = new ArrayList<Object>();\n-        \n+\n         DescriptiveStatistics u = new ListUnivariateImpl( list );\n-                \n+\n         assertTrue(\"Mean of n = 0 set should be NaN\", Double.isNaN( u.getMean() ) );\n         assertTrue(\"Standard Deviation of n = 0 set should be NaN\", Double.isNaN( u.getStandardDeviation() ) );\n         assertTrue(\"Variance of n = 0 set should be NaN\", Double.isNaN(u.getVariance() ) );\n \n         assertTrue( \"Mean of n = 1 set should be value of single item n1\", u.getMean() == one);\n         assertTrue( \"StdDev of n = 1 set should be zero, instead it is: \" + u.getStandardDeviation(), u.getStandardDeviation() == 0);\n-        assertTrue( \"Variance of n = 1 set should be zero\", u.getVariance() == 0);  \n+        assertTrue( \"Variance of n = 1 set should be zero\", u.getVariance() == 0);\n     }\n-    \n+\n     public void testSkewAndKurtosis() {\n         DescriptiveStatistics u = new DescriptiveStatistics();\n-        \n+\n         double[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,\n                                              9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };\n         for( int i = 0; i < testArray.length; i++) {\n             u.addValue( testArray[i]);\n         }\n-        \n+\n         assertEquals(\"mean\", 12.40455, u.getMean(), 0.0001);\n         assertEquals(\"variance\", 10.00236, u.getVariance(), 0.0001);\n         assertEquals(\"skewness\", 1.437424, u.getSkewness(), 0.0001);\n     public void testProductAndGeometricMean() throws Exception {\n         ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>());\n         u.setWindowSize(10);\n-                \n+\n         u.addValue( 1.0 );\n         u.addValue( 2.0 );\n         u.addValue( 3.0 );\n             u.addValue( i + 2 );\n         }\n         // Values should be (2,3,4,5,6,7,8,9,10,11)\n-        \n+\n         assertEquals( \"Geometric mean not expected\", 5.755931, u.getGeometricMean(), 0.00001 );\n \n \n     }\n-    \n+\n     /** test stats */\n     public void testSerialization() {\n-        \n+\n         DescriptiveStatistics u = new ListUnivariateImpl();\n-        \n+\n         assertEquals(\"total count\",0,u.getN(),tolerance);\n         u.addValue(one);\n         u.addValue(two);\n-        \n-        DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u); \n- \n+\n+        DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u);\n+\n         u2.addValue(two);\n         u2.addValue(three);\n-        \n+\n         assertEquals(\"N\",n,u2.getN(),tolerance);\n         assertEquals(\"sum\",sum,u2.getSum(),tolerance);\n         assertEquals(\"sumsq\",sumSq,u2.getSumsq(),tolerance);\n         assertEquals(\"max\",max,u2.getMax(),tolerance);\n \n         u2.clear();\n-        assertEquals(\"total count\",0,u2.getN(),tolerance);    \n-    }       \n+        assertEquals(\"total count\",0,u2.getN(),tolerance);\n+    }\n }\n \n--- a/src/test/java/org/apache/commons/math/stat/descriptive/MixedListUnivariateImplTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/MixedListUnivariateImplTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     private double tolerance = 10E-15;\n \n     private TransformerMap transformers = new TransformerMap();\n-    \n+\n     public MixedListUnivariateImplTest(String name) {\n         super(name);\n         transformers = new TransformerMap();\n         assertTrue(\n             \"Mean of n = 1 set should be value of single item n1, instead it is \" + u.getMean() ,\n             u.getMean() == one);\n-            \n+\n         assertTrue(\n             \"StdDev of n = 1 set should be zero, instead it is: \"\n                 + u.getStandardDeviation(),\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatisticsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatisticsTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     public MultivariateSummaryStatisticsTest(String name) {\n         super(name);\n     }\n-    \n+\n     public static Test suite() {\n         TestSuite suite = new TestSuite(MultivariateSummaryStatisticsTest.class);\n         suite.setName(\"MultivariateSummaryStatistics tests\");\n         assertEquals(3, u.getMean()[1], 1E-14);\n         assertEquals(2, u.getDimension());\n     }\n-    \n+\n     public void testSetterIllegalState() throws Exception {\n         MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(2, true);\n         u.addValue(new double[] { 1, 2 });\n         TestUtils.assertEquals(reference.getGeometricMean(), shuffled.getSumLog(),        1.0e-10);\n \n     }\n-    \n+\n     /**\n      * Bogus mean implementation to test setter injection.\n      * Returns the sum instead of the mean.\n      */\n-    static class sumMean implements StorelessUnivariateStatistic {   \n+    static class sumMean implements StorelessUnivariateStatistic {\n         private double sum = 0;\n         private long n = 0;\n         public double evaluate(double[] values, int begin, int length) {\n             return 0;\n         }\n         public void clear() {\n-          sum = 0; \n+          sum = 0;\n           n = 0;\n         }\n         public long getN() {\n         public void incrementAll(double[] values, int start, int length) {\n         }\n         public void incrementAll(double[] values) {\n-        }   \n+        }\n         public StorelessUnivariateStatistic copy() {\n             return new sumMean();\n         }\n         assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 0), 1.0e-10);\n         assertEquals(2.0 / 3.0, u.getCovariance().getEntry(1, 1), 1.0e-10);\n         u.clear();\n-        assertEquals(0, u.getN());    \n-    }     \n+        assertEquals(0, u.getN());\n+    }\n \n     public void testN0andN1Conditions() throws Exception {\n         MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(1, true);\n         assertEquals(1.0, u.getGeometricMean()[0], 1.0e-10);\n         assertEquals(0.0, u.getStandardDeviation()[0], 1.0e-10);\n \n-        /* n=2 */               \n+        /* n=2 */\n         u.addValue(new double[] { 2 });\n         assertTrue(u.getStandardDeviation()[0] > 0);\n \n \n     public void testNaNContracts() throws DimensionMismatchException {\n         MultivariateSummaryStatistics u = createMultivariateSummaryStatistics(1, true);\n-        assertTrue(Double.isNaN(u.getMean()[0])); \n-        assertTrue(Double.isNaN(u.getMin()[0])); \n-        assertTrue(Double.isNaN(u.getStandardDeviation()[0])); \n+        assertTrue(Double.isNaN(u.getMean()[0]));\n+        assertTrue(Double.isNaN(u.getMin()[0]));\n+        assertTrue(Double.isNaN(u.getStandardDeviation()[0]));\n         assertTrue(Double.isNaN(u.getGeometricMean()[0]));\n \n         u.addValue(new double[] { 1.0 });\n-        assertFalse(Double.isNaN(u.getMean()[0])); \n-        assertFalse(Double.isNaN(u.getMin()[0])); \n-        assertFalse(Double.isNaN(u.getStandardDeviation()[0])); \n+        assertFalse(Double.isNaN(u.getMean()[0]));\n+        assertFalse(Double.isNaN(u.getMin()[0]));\n+        assertFalse(Double.isNaN(u.getStandardDeviation()[0]));\n         assertFalse(Double.isNaN(u.getGeometricMean()[0]));\n \n     }\n         t.addValue(new double[] { 5d, 1d });\n         assertTrue(t.equals(u));\n         assertTrue(u.equals(t));\n-        assertEquals(u.hashCode(), t.hashCode());   \n+        assertEquals(u.hashCode(), t.hashCode());\n \n         // Clear and make sure summaries are indistinguishable from empty summary\n         u.clear();\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValuesTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValuesTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  */\n \n public final class StatisticalSummaryValuesTest extends TestCase {\n-    \n-    \n+\n+\n     public StatisticalSummaryValuesTest(String name) {\n         super(name);\n     }\n-    \n+\n     public static Test suite() {\n         TestSuite suite = new TestSuite(StatisticalSummaryValuesTest.class);\n         suite.setName(\"StatisticalSummaryValues Tests\");\n         return suite;\n     }\n-      \n+\n     public void testSerialization() {\n         StatisticalSummaryValues u = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);\n-        TestUtils.checkSerializedEquality(u); \n+        TestUtils.checkSerializedEquality(u);\n         StatisticalSummaryValues t = (StatisticalSummaryValues) TestUtils.serializeAndRecover(u);\n         verifyEquality(u, t);\n     }\n-    \n+\n     public void testEqualsAndHashCode() {\n         StatisticalSummaryValues u  = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);\n         StatisticalSummaryValues t = null;\n         t = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);\n         assertTrue(\"instances with same data should be equal\", t.equals(u));\n         assertEquals(\"hash code\", u.hashCode(), t.hashCode());\n-        \n+\n         u = new StatisticalSummaryValues(Double.NaN, 2, 3, 4, 5, 6);\n         t = new StatisticalSummaryValues(1, Double.NaN, 3, 4, 5, 6);\n-        assertFalse(\"instances based on different data should be different\", \n+        assertFalse(\"instances based on different data should be different\",\n                 (u.equals(t) ||t.equals(u)));\n     }\n-    \n+\n     private void verifyEquality(StatisticalSummaryValues s, StatisticalSummaryValues u) {\n         assertEquals(\"N\",s.getN(),u.getN());\n         TestUtils.assertEquals(\"sum\",s.getSum(),u.getSum(), 0);\n         TestUtils.assertEquals(\"std\",s.getStandardDeviation(),u.getStandardDeviation(), 0);\n         TestUtils.assertEquals(\"mean\",s.getMean(),u.getMean(), 0);\n         TestUtils.assertEquals(\"min\",s.getMin(),u.getMin(), 0);\n-        TestUtils.assertEquals(\"max\",s.getMax(),u.getMax(), 0);   \n+        TestUtils.assertEquals(\"max\",s.getMax(),u.getMax(), 0);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatisticAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatisticAbstractTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     public StorelessUnivariateStatisticAbstractTest(String name) {\n         super(name);\n     }\n-    \n+\n     /** Small sample arrays */\n     protected double[][] smallSamples = {{}, {1}, {1,2}, {1,2,3}, {1,2,3,4}};\n \n     /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */\n     @Override\n     public abstract double expectedValue();\n-    \n-    /** \n-     *  Verifies that increment() and incrementAll work properly. \n+\n+    /**\n+     *  Verifies that increment() and incrementAll work properly.\n      */\n     public void testIncrementation() throws Exception {\n \n         StorelessUnivariateStatistic statistic =\n             (StorelessUnivariateStatistic) getUnivariateStatistic();\n-        \n+\n         // Add testArray one value at a time and check result\n         for (int i = 0; i < testArray.length; i++) {\n             statistic.increment(testArray[i]);\n         }\n-        \n+\n         assertEquals(expectedValue(), statistic.getResult(), getTolerance());\n         assertEquals(testArray.length, statistic.getN());\n \n         statistic.clear();\n-        \n+\n         // Add testArray all at once and check again\n         statistic.incrementAll(testArray);\n         assertEquals(expectedValue(), statistic.getResult(), getTolerance());\n         assertEquals(testArray.length, statistic.getN());\n-        \n-        statistic.clear();\n-        \n+\n+        statistic.clear();\n+\n         // Cleared\n         assertTrue(Double.isNaN(statistic.getResult()));\n         assertEquals(0, statistic.getN());\n \n         StorelessUnivariateStatistic statistic =\n             (StorelessUnivariateStatistic) getUnivariateStatistic();\n-        \n+\n         TestUtils.checkSerializedEquality(statistic);\n \n         statistic.clear();\n         for (int i = 0; i < testArray.length; i++) {\n             statistic.increment(testArray[i]);\n             if(i % 5 == 0)\n-                statistic = (StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic); \n-        }\n-        \n+                statistic = (StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic);\n+        }\n+\n         TestUtils.checkSerializedEquality(statistic);\n-        \n+\n         assertEquals(expectedValue(), statistic.getResult(), getTolerance());\n \n         statistic.clear();\n         assertTrue(Double.isNaN(statistic.getResult()));\n \n     }\n-    \n+\n     public void testEqualsAndHashCode() {\n         StorelessUnivariateStatistic statistic =\n             (StorelessUnivariateStatistic) getUnivariateStatistic();\n         StorelessUnivariateStatistic statistic2 = null;\n-        \n+\n         assertTrue(\"non-null, compared to null\", !statistic.equals(statistic2));\n         assertTrue(\"reflexive, non-null\", statistic.equals(statistic));\n-        \n+\n         int emptyHash = statistic.hashCode();\n         statistic2 = (StorelessUnivariateStatistic) getUnivariateStatistic();\n         assertTrue(\"empty stats should be equal\", statistic.equals(statistic2));\n-        assertEquals(\"empty stats should have the same hashcode\", \n+        assertEquals(\"empty stats should have the same hashcode\",\n                 emptyHash, statistic2.hashCode());\n-        \n+\n         statistic.increment(1d);\n         assertTrue(\"reflexive, non-empty\", statistic.equals(statistic));\n         assertTrue(\"non-empty, compared to empty\", !statistic.equals(statistic2));\n         assertTrue(\"non-empty, compared to empty\", !statistic2.equals(statistic));\n         assertTrue(\"non-empty stat should have different hashcode from empty stat\",\n                 statistic.hashCode() != emptyHash);\n-        \n+\n         statistic2.increment(1d);\n         assertTrue(\"stats with same data should be equal\", statistic.equals(statistic2));\n-        assertEquals(\"stats with same data should have the same hashcode\", \n+        assertEquals(\"stats with same data should have the same hashcode\",\n                 statistic.hashCode(), statistic2.hashCode());\n-        \n+\n         statistic.increment(Double.POSITIVE_INFINITY);\n         assertTrue(\"stats with different n's should not be equal\", !statistic2.equals(statistic));\n         assertTrue(\"stats with different n's should have different hashcodes\",\n                 statistic.hashCode() != statistic2.hashCode());\n-        \n+\n         statistic2.increment(Double.POSITIVE_INFINITY);\n         assertTrue(\"stats with same data should be equal\", statistic.equals(statistic2));\n-        assertEquals(\"stats with same data should have the same hashcode\", \n-                statistic.hashCode(), statistic2.hashCode()); \n-        \n+        assertEquals(\"stats with same data should have the same hashcode\",\n+                statistic.hashCode(), statistic2.hashCode());\n+\n         statistic.clear();\n         statistic2.clear();\n         assertTrue(\"cleared stats should be equal\", statistic.equals(statistic2));\n-        assertEquals(\"cleared stats should have thashcode of empty stat\", \n+        assertEquals(\"cleared stats should have thashcode of empty stat\",\n                 emptyHash, statistic2.hashCode());\n-        assertEquals(\"cleared stats should have thashcode of empty stat\", \n+        assertEquals(\"cleared stats should have thashcode of empty stat\",\n                 emptyHash, statistic.hashCode());\n-        \n-    }\n-    \n+\n+    }\n+\n     public void testMomentSmallSamples() {\n         UnivariateStatistic stat = getUnivariateStatistic();\n         if (stat instanceof SecondMoment) {\n             assertEquals(0d, moment.getResult(), 0);\n         }\n     }\n-    \n-    /** \n-     * Make sure that evaluate(double[]) and inrementAll(double[]), \n+\n+    /**\n+     * Make sure that evaluate(double[]) and inrementAll(double[]),\n      * getResult() give same results.\n      */\n     public void testConsistency() {\n             TestUtils.assertEquals(stat.getResult(), stat.evaluate(smallSamples[i]), getTolerance());\n         }\n     }\n-    \n+\n     /**\n      * Verifies that copied statistics remain equal to originals when\n      * incremented the same way.\n      *\n      */\n     public void testCopyConsistency() {\n-        \n+\n         StorelessUnivariateStatistic master =\n             (StorelessUnivariateStatistic) getUnivariateStatistic();\n-        \n+\n         StorelessUnivariateStatistic replica = null;\n-        \n+\n         // Randomly select a portion of testArray to load first\n         long index = Math.round((Math.random()) * testArray.length);\n-        \n+\n         // Put first half in master and copy master to replica\n         master.incrementAll(testArray, 0, (int) index);\n         replica = master.copy();\n-        \n+\n         // Check same\n         assertTrue(replica.equals(master));\n         assertTrue(master.equals(replica));\n-        \n+\n         // Now add second part to both and check again\n-        master.incrementAll(testArray, \n+        master.incrementAll(testArray,\n                 (int) index, (int) (testArray.length - index));\n-        replica.incrementAll(testArray, \n+        replica.incrementAll(testArray,\n                 (int) index, (int) (testArray.length - index));\n         assertTrue(replica.equals(master));\n         assertTrue(master.equals(replica));\n     }\n-    \n+\n     public void testSerial() {\n         StorelessUnivariateStatistic s =\n             (StorelessUnivariateStatistic) getUnivariateStatistic();\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/SummaryStatisticsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/SummaryStatisticsTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     public SummaryStatisticsTest(String name) {\n         super(name);\n     }\n-    \n+\n     protected SummaryStatistics createSummaryStatistics() {\n         return new SummaryStatistics();\n     }\n         assertEquals(\"min\",min,u.getMin(),tolerance);\n         assertEquals(\"max\",max,u.getMax(),tolerance);\n         u.clear();\n-        assertEquals(\"total count\",0,u.getN(),tolerance);    \n-    }     \n+        assertEquals(\"total count\",0,u.getN(),tolerance);\n+    }\n \n     public void testN0andN1Conditions() throws Exception {\n         SummaryStatistics u = createSummaryStatistics();\n-        assertTrue(\"Mean of n = 0 set should be NaN\", \n+        assertTrue(\"Mean of n = 0 set should be NaN\",\n                 Double.isNaN( u.getMean() ) );\n-        assertTrue(\"Standard Deviation of n = 0 set should be NaN\", \n+        assertTrue(\"Standard Deviation of n = 0 set should be NaN\",\n                 Double.isNaN( u.getStandardDeviation() ) );\n-        assertTrue(\"Variance of n = 0 set should be NaN\", \n+        assertTrue(\"Variance of n = 0 set should be NaN\",\n                 Double.isNaN(u.getVariance() ) );\n \n         /* n=1 */\n         u.addValue(one);\n-        assertTrue(\"mean should be one (n = 1)\", \n+        assertTrue(\"mean should be one (n = 1)\",\n                 u.getMean() == one);\n-        assertTrue(\"geometric should be one (n = 1) instead it is \" + u.getGeometricMean(), \n+        assertTrue(\"geometric should be one (n = 1) instead it is \" + u.getGeometricMean(),\n                 u.getGeometricMean() == one);\n-        assertTrue(\"Std should be zero (n = 1)\", \n+        assertTrue(\"Std should be zero (n = 1)\",\n                 u.getStandardDeviation() == 0.0);\n-        assertTrue(\"variance should be zero (n = 1)\", \n+        assertTrue(\"variance should be zero (n = 1)\",\n                 u.getVariance() == 0.0);\n \n-        /* n=2 */               \n+        /* n=2 */\n         u.addValue(twoF);\n-        assertTrue(\"Std should not be zero (n = 2)\", \n+        assertTrue(\"Std should not be zero (n = 2)\",\n                 u.getStandardDeviation() != 0.0);\n-        assertTrue(\"variance should not be zero (n = 2)\", \n+        assertTrue(\"variance should not be zero (n = 2)\",\n                 u.getVariance() != 0.0);\n \n     }\n         u.addValue( 3.0 );\n         u.addValue( 4.0 );\n \n-        assertEquals( \"Geometric mean not expected\", 2.213364, \n+        assertEquals( \"Geometric mean not expected\", 2.213364,\n                 u.getGeometricMean(), 0.00001 );\n     }\n \n     public void testNaNContracts() {\n         SummaryStatistics u = createSummaryStatistics();\n-        assertTrue(\"mean not NaN\",Double.isNaN(u.getMean())); \n-        assertTrue(\"min not NaN\",Double.isNaN(u.getMin())); \n-        assertTrue(\"std dev not NaN\",Double.isNaN(u.getStandardDeviation())); \n-        assertTrue(\"var not NaN\",Double.isNaN(u.getVariance())); \n+        assertTrue(\"mean not NaN\",Double.isNaN(u.getMean()));\n+        assertTrue(\"min not NaN\",Double.isNaN(u.getMin()));\n+        assertTrue(\"std dev not NaN\",Double.isNaN(u.getStandardDeviation()));\n+        assertTrue(\"var not NaN\",Double.isNaN(u.getVariance()));\n         assertTrue(\"geom mean not NaN\",Double.isNaN(u.getGeometricMean()));\n \n         u.addValue(1.0);\n \n-        assertEquals( \"mean not expected\", 1.0, \n+        assertEquals( \"mean not expected\", 1.0,\n                 u.getMean(), Double.MIN_VALUE);\n-        assertEquals( \"variance not expected\", 0.0, \n+        assertEquals( \"variance not expected\", 0.0,\n                 u.getVariance(), Double.MIN_VALUE);\n-        assertEquals( \"geometric mean not expected\", 1.0, \n+        assertEquals( \"geometric mean not expected\", 1.0,\n                 u.getGeometricMean(), Double.MIN_VALUE);\n \n         u.addValue(-1.0);\n         verifySummary(u, summary);\n         u.addValue(2d);\n         summary = u.getSummary();\n-        verifySummary(u, summary);     \n+        verifySummary(u, summary);\n     }\n \n     public void testSerialization() {\n         u.addValue(4d);\n         assertFalse(\"different n's should make instances not equal\", t.equals(u));\n         assertFalse(\"different n's should make instances not equal\", u.equals(t));\n-        assertTrue(\"different n's should make hashcodes different\", \n+        assertTrue(\"different n's should make hashcodes different\",\n                 u.hashCode() != t.hashCode());\n \n         //Add data in same order to t\n         t.addValue(4d);\n         assertTrue(\"summaries based on same data should be equal\", t.equals(u));\n         assertTrue(\"summaries based on same data should be equal\", u.equals(t));\n-        assertEquals(\"summaries based on same data should have same hashcodes\", \n-                u.hashCode(), t.hashCode());   \n+        assertEquals(\"summaries based on same data should have same hashcodes\",\n+                u.hashCode(), t.hashCode());\n \n         // Clear and make sure summaries are indistinguishable from empty summary\n         u.clear();\n         assertEquals(\"empty hash code\", emptyHash, t.hashCode());\n         assertEquals(\"empty hash code\", emptyHash, u.hashCode());\n     }\n-    \n+\n     public void testCopy() throws Exception {\n         SummaryStatistics u = createSummaryStatistics();\n         u.addValue(2d);\n         assertTrue(v.sumsq == v.getSumsqImpl());\n         assertTrue(v.sumLog == v.getSumLogImpl());\n         assertTrue(v.variance == v.getVarianceImpl());\n-        \n+\n         // Make sure both behave the same with additional values added\n         u.addValue(7d);\n         u.addValue(9d);\n         v.addValue(23d);\n         assertEquals(u, v);\n         assertEquals(v, u);\n-        \n+\n         // Check implementation pointers are preserved\n         u.clear();\n         u.setSumImpl(new Sum());\n         SummaryStatistics.copy(u,v);\n         assertEquals(u.sum, v.sum);\n         assertEquals(u.getSumImpl(), v.getSumImpl());\n-        \n+\n     }\n \n     private void verifySummary(SummaryStatistics u, StatisticalSummary s) {\n         TestUtils.assertEquals(\"std\",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);\n         TestUtils.assertEquals(\"mean\",s.getMean(),u.getMean(),tolerance);\n         TestUtils.assertEquals(\"min\",s.getMin(),u.getMin(),tolerance);\n-        TestUtils.assertEquals(\"max\",s.getMax(),u.getMax(),tolerance);   \n+        TestUtils.assertEquals(\"max\",s.getMax(),u.getMax(),tolerance);\n     }\n \n     public void testSetterInjection() throws Exception {\n         u.clear();\n         u.setMeanImpl(new Mean()); // OK after clear\n     }\n-    \n+\n     public void testSetterIllegalState() throws Exception {\n         SummaryStatistics u = createSummaryStatistics();\n         u.addValue(1);\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/UnivariateStatisticAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/UnivariateStatisticAbstractTest.java\n \n \n     protected double weightedMean = 12.366995073891626d;\n-    protected double weightedVar =   9.974760968886391d; \n+    protected double weightedVar =   9.974760968886391d;\n     protected double weightedStd = Math.sqrt(weightedVar);\n     protected double weightedProduct = 8517647448765288000000d;\n     protected double weightedSum = 251.05d;\n                 copy.evaluate(testArray),\n                 getTolerance());\n     }\n-    \n+\n     /**\n      * Tests consistency of weighted statistic computation.\n      * For statistics that support weighted evaluation, this test case compares\n      * value appearing only once but with a weight value equal to its multiplicity\n      * in the repeating array.\n      */\n-    \n+\n     public void testWeightedConsistency() throws Exception {\n-        \n+\n         // See if this statistic computes weighted statistics\n         // If not, skip this test\n         UnivariateStatistic statistic = getUnivariateStatistic();\n         } catch (NoSuchMethodException ex) {\n             return;  // skip test\n         }\n-        \n+\n         // Create arrays of values and corresponding integral weights\n         // and longer array with values repeated according to the weights\n         final int len = 10;        // length of values array\n         final double mu = 0;       // mean of test data\n-        final double sigma = 5;    // std dev of test data \n+        final double sigma = 5;    // std dev of test data\n         double[] values = new double[len];\n         double[] weights = new double[len];\n-        RandomData randomData = new RandomDataImpl();  \n-        \n+        RandomData randomData = new RandomDataImpl();\n+\n         // Fill weights array with random int values between 1 and 5\n         int[] intWeights = new int[len];\n         for (int i = 0; i < len; i++) {\n             intWeights[i] = randomData.nextInt(1, 5);\n             weights[i] = intWeights[i];\n         }\n-        \n+\n         // Fill values array with random data from N(mu, sigma)\n         // and fill valuesList with values from values array with\n         // values[i] repeated weights[i] times, each i\n                 valuesList.add(new Double(value));\n             }\n         }\n-        \n+\n         // Dump valuesList into repeatedValues array\n         int sumWeights = valuesList.size();\n         double[] repeatedValues = new double[sumWeights];\n         for (int i = 0; i < sumWeights; i++) {\n             repeatedValues[i] = valuesList.get(i);\n         }\n-        \n+\n         // Compare result of weighted statistic computation with direct computation\n         // on array of repeated values\n         double weightedResult = (Double) evaluateMethod.invoke(\n                 statistic, values, weights, 0, values.length);\n         TestUtils.assertRelativelyEquals(\n-                statistic.evaluate(repeatedValues), weightedResult, 10E-14); \n-        \n+                statistic.evaluate(repeatedValues), weightedResult, 10E-14);\n+\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/FirstMomentTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/FirstMomentTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n     /** descriptive statistic. */\n     protected FirstMoment stat;\n-    \n+\n     /**\n      * @param name\n      */\n     public FirstMomentTest(String name) {\n         super(name);\n     }\n-    \n+\n     /**\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n      */\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/FourthMomentTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/FourthMomentTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n     /** descriptive statistic. */\n     protected FourthMoment stat;\n-    \n+\n     /**\n      * @param name\n      */\n     public FourthMomentTest(String name) {\n         super(name);\n     }\n-    \n+\n     /**\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n      */\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/GeometricMeanTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/GeometricMeanTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n public class GeometricMeanTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected GeometricMean stat;\n-    \n+\n     /**\n      * @param name\n      */\n         suite.setName(\"Mean  Tests\");\n         return suite;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public double expectedValue() {\n         return this.geoMean;\n     }\n-    \n+\n     public void testSpecialValues() {\n         GeometricMean mean = new GeometricMean();\n         // empty\n         assertTrue(Double.isNaN(mean.getResult()));\n-        \n+\n         // finite data\n         mean.increment(1d);\n         assertFalse(Double.isNaN(mean.getResult()));\n-        \n+\n         // add 0 -- makes log sum blow to minus infinity, should make 0\n         mean.increment(0d);\n         assertEquals(0d, mean.getResult(), 0);\n-        \n+\n         // add positive infinity - note the minus infinity above\n         mean.increment(Double.POSITIVE_INFINITY);\n         assertTrue(Double.isNaN(mean.getResult()));\n-        \n+\n         // clear\n         mean.clear();\n         assertTrue(Double.isNaN(mean.getResult()));\n-        \n+\n         // positive infinity by itself\n         mean.increment(Double.POSITIVE_INFINITY);\n         assertEquals(Double.POSITIVE_INFINITY, mean.getResult(), 0);\n-        \n+\n         // negative value -- should make NaN\n         mean.increment(-2d);\n         assertTrue(Double.isNaN(mean.getResult()));\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/KurtosisTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/KurtosisTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n public class KurtosisTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected Kurtosis stat;\n-    \n+\n     /**\n      * @param name\n      */\n     public KurtosisTest(String name) {\n         super(name);\n     }\n-    \n+\n     public static Test suite() {\n         TestSuite suite = new TestSuite(KurtosisTest.class);\n         suite.setName(\"Kurtosis  Tests\");\n     public double expectedValue() {\n         return this.kurt;\n     }\n-    \n+\n     /**\n      * Make sure Double.NaN is returned iff n < 4\n      *\n         kurt.increment(1d);\n         assertTrue(Double.isNaN(kurt.getResult()));\n         kurt.increment(1d);\n-        assertFalse(Double.isNaN(kurt.getResult()));      \n+        assertFalse(Double.isNaN(kurt.getResult()));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/SecondMomentTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/SecondMomentTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n     /** descriptive statistic. */\n     protected SecondMoment stat;\n-    \n+\n     /**\n      * @param name\n      */\n     public SecondMomentTest(String name) {\n         super(name);\n     }\n-    \n+\n     /**\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n      */\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/SkewnessTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/SkewnessTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class SkewnessTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected Skewness stat;\n-    \n+\n     /**\n      * @param name\n      */\n         suite.setName(\"Skewness Tests\");\n         return suite;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public double expectedValue() {\n         return this.skew;\n     }\n-    \n+\n     /**\n      * Make sure Double.NaN is returned iff n < 3\n      *\n         skew.increment(1d);\n         assertTrue(Double.isNaN(skew.getResult()));\n         skew.increment(1d);\n-        assertFalse(Double.isNaN(skew.getResult()));      \n+        assertFalse(Double.isNaN(skew.getResult()));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviationTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviationTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class StandardDeviationTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected StandardDeviation stat;\n-    \n+\n     /**\n      * @param name\n      */\n         suite.setName(\"StandardDeviation Tests\");\n         return suite;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public double expectedValue() {\n         return this.std;\n     }\n-    \n+\n     /**\n      * Make sure Double.NaN is returned iff n = 0\n      *\n         std.increment(1d);\n         assertEquals(0d, std.getResult(), 0);\n     }\n-    \n+\n     /**\n      * Test population version of variance\n-     */ \n+     */\n     public void testPopulation() {\n         double[] values = {-1.0d, 3.1d, 4.0d, -2.1d, 22d, 11.7d, 3d, 14d};\n         double sigma = populationStandardDeviation(values);\n         s1.incrementAll(values);\n         assertEquals(sigma, s1.getResult(), 1E-14);\n         s1 = new StandardDeviation(false, m);\n-        assertEquals(sigma, s1.getResult(), 1E-14);     \n+        assertEquals(sigma, s1.getResult(), 1E-14);\n         s1 = new StandardDeviation(false);\n         assertEquals(sigma, s1.evaluate(values), 1E-14);\n         s1.incrementAll(values);\n-        assertEquals(sigma, s1.getResult(), 1E-14);     \n+        assertEquals(sigma, s1.getResult(), 1E-14);\n     }\n-    \n+\n     /**\n      * Definitional formula for population standard deviation\n      */\n         double mean = new Mean().evaluate(v);\n         double sum = 0;\n         for (int i = 0; i < v.length; i++) {\n-            sum += (v[i] - mean) * (v[i] - mean); \n+            sum += (v[i] - mean) * (v[i] - mean);\n         }\n         return Math.sqrt(sum / v.length);\n     }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/ThirdMomentTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/ThirdMomentTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n     /** descriptive statistic. */\n     protected ThirdMoment stat;\n-    \n+\n     /**\n      * @param name\n      */\n     public ThirdMomentTest(String name) {\n         super(name);\n     }\n-    \n+\n     /**\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n      */\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/VarianceTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/VarianceTest.java\n \n /**\n  * Test cases for the {@link UnivariateStatistic} class.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class VarianceTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected Variance stat;\n-    \n+\n     /**\n      * @param name\n      */\n \n     public void testWeightedVariance() {\n         Variance variance = new Variance();\n-        assertEquals(expectedWeightedValue(), \n+        assertEquals(expectedWeightedValue(),\n                 variance.evaluate(testArray, testWeightsArray, 0, testArray.length), getTolerance());\n-        \n+\n         // All weights = 1 -> weighted variance = unweighted variance\n         assertEquals(expectedValue(),\n                 variance.evaluate(testArray, unitWeightsArray, 0, testArray.length), getTolerance());\n-        \n+\n         // All weights the same -> when weights are normalized to sum to the length of the values array,\n         // weighted variance = unweighted value\n         assertEquals(expectedValue(),\n                 variance.evaluate(testArray, MathUtils.normalizeArray(identicalWeightsArray, testArray.length),\n                         0, testArray.length), getTolerance());\n-        \n+\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/moment/VectorialCovarianceTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/VectorialCovarianceTest.java\n         VectorialCovariance stat = new VectorialCovariance(points[0].length, true);\n         assertEquals(stat, TestUtils.serializeAndRecover(stat));\n     }\n-    \n+\n     @Override\n     public void setUp() {\n         points = new double[][] {\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/rank/MaxTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/rank/MaxTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n public class MaxTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected Max stat;\n-    \n+\n     /**\n      * @param name\n      */\n         suite.setName(\"Max  Tests\");\n         return suite;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public double expectedValue() {\n         return this.max;\n     }\n-    \n+\n     public void testSpecialValues() {\n-        double[] testArray = {0d, Double.NaN, Double.NEGATIVE_INFINITY, \n+        double[] testArray = {0d, Double.NaN, Double.NEGATIVE_INFINITY,\n                 Double.POSITIVE_INFINITY};\n         Max max = new Max();\n         assertTrue(Double.isNaN(max.getResult()));\n         assertEquals(0d, max.getResult(), 0);\n         max.increment(testArray[3]);\n         assertEquals(Double.POSITIVE_INFINITY, max.getResult(), 0);\n-        assertEquals(Double.POSITIVE_INFINITY, max.evaluate(testArray), 0);     \n+        assertEquals(Double.POSITIVE_INFINITY, max.evaluate(testArray), 0);\n     }\n \n     public void testNaNs() {\n         Max max = new Max();\n         double nan = Double.NaN;\n-        assertEquals(3d, max.evaluate(new double[]{nan, 2d, 3d}), 0);     \n-        assertEquals(3d, max.evaluate(new double[]{1d, nan, 3d}), 0);     \n-        assertEquals(2d, max.evaluate(new double[]{1d, 2d, nan}), 0);     \n-        assertTrue(Double.isNaN(max.evaluate(new double[]{nan, nan, nan})));     \n+        assertEquals(3d, max.evaluate(new double[]{nan, 2d, 3d}), 0);\n+        assertEquals(3d, max.evaluate(new double[]{1d, nan, 3d}), 0);\n+        assertEquals(2d, max.evaluate(new double[]{1d, 2d, nan}), 0);\n+        assertTrue(Double.isNaN(max.evaluate(new double[]{nan, nan, nan})));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/rank/MedianTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/rank/MedianTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n public class MedianTest extends UnivariateStatisticAbstractTest{\n \n     protected Median stat;\n-    \n+\n     /**\n      * @param name\n      */\n         suite.setName(\"Median  Tests\");\n         return suite;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public UnivariateStatistic getUnivariateStatistic() {  \n+    public UnivariateStatistic getUnivariateStatistic() {\n         return new Median();\n     }\n \n--- a/src/test/java/org/apache/commons/math/stat/descriptive/rank/MinTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/rank/MinTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n public class MinTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected Min stat;\n-    \n+\n     /**\n      * @param name\n      */\n         suite.setName(\"Min  Tests\");\n         return suite;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public double expectedValue() {\n         return this.min;\n     }\n-    \n+\n     public void testSpecialValues() {\n-        double[] testArray = {0d, Double.NaN, Double.POSITIVE_INFINITY, \n+        double[] testArray = {0d, Double.NaN, Double.POSITIVE_INFINITY,\n                 Double.NEGATIVE_INFINITY};\n         Min min = new Min();\n         assertTrue(Double.isNaN(min.getResult()));\n         assertEquals(0d, min.getResult(), 0);\n         min.increment(testArray[3]);\n         assertEquals(Double.NEGATIVE_INFINITY, min.getResult(), 0);\n-        assertEquals(Double.NEGATIVE_INFINITY, min.evaluate(testArray), 0);     \n+        assertEquals(Double.NEGATIVE_INFINITY, min.evaluate(testArray), 0);\n     }\n \n     public void testNaNs() {\n         Min min = new Min();\n         double nan = Double.NaN;\n-        assertEquals(2d, min.evaluate(new double[]{nan, 2d, 3d}), 0);     \n-        assertEquals(1d, min.evaluate(new double[]{1d, nan, 3d}), 0);     \n-        assertEquals(1d, min.evaluate(new double[]{1d, 2d, nan}), 0);     \n-        assertTrue(Double.isNaN(min.evaluate(new double[]{nan, nan, nan})));     \n+        assertEquals(2d, min.evaluate(new double[]{nan, 2d, 3d}), 0);\n+        assertEquals(1d, min.evaluate(new double[]{1d, nan, 3d}), 0);\n+        assertEquals(1d, min.evaluate(new double[]{1d, 2d, nan}), 0);\n+        assertTrue(Double.isNaN(min.evaluate(new double[]{nan, nan, nan})));\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n public class PercentileTest extends UnivariateStatisticAbstractTest{\n \n     protected Percentile stat;\n-    \n+\n     /**\n      * @param name\n      */\n         suite.setName(\"Percentile Tests\");\n         return suite;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public UnivariateStatistic getUnivariateStatistic() {   \n+    public UnivariateStatistic getUnivariateStatistic() {\n         return new Percentile(95.0);\n     }\n \n         Percentile p = new Percentile(75);\n         assertEquals(3.0, p.evaluate(d), 1.0e-5);\n     }\n-    \n+\n     public void testPercentile() {\n         double[] d = new double[] {1, 3, 2, 4};\n         Percentile p = new Percentile(30);\n         assertEquals(3.75, p.evaluate(d), 1.0e-5);\n         p.setQuantile(50);\n         assertEquals(2.5, p.evaluate(d), 1.0e-5);\n-        \n+\n         // invalid percentiles\n         try {\n             p.evaluate(d, 0, d.length, -1.0);\n             // success\n         }\n     }\n-    \n+\n     public void testNISTExample() {\n-        double[] d = new double[] {95.1772, 95.1567, 95.1937, 95.1959, \n+        double[] d = new double[] {95.1772, 95.1567, 95.1937, 95.1959,\n                 95.1442, 95.0610,  95.1591, 95.1195, 95.1772, 95.0925, 95.1990, 95.1682\n         };\n-        Percentile p = new Percentile(90); \n+        Percentile p = new Percentile(90);\n         assertEquals(95.1981, p.evaluate(d), 1.0e-4);\n         assertEquals(95.1990, p.evaluate(d,0,d.length, 100d), 0);\n     }\n-    \n+\n     public void test5() {\n         Percentile percentile = new Percentile(5);\n         assertEquals(this.percentile5, percentile.evaluate(testArray), getTolerance());\n     }\n-    \n+\n     public void testNullEmpty() {\n         Percentile percentile = new Percentile(50);\n         double[] nullArray = null;\n             fail(\"Expecting IllegalArgumentException for null array\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n-        assertTrue(Double.isNaN(percentile.evaluate(emptyArray)));        \n+        }\n+        assertTrue(Double.isNaN(percentile.evaluate(emptyArray)));\n     }\n-    \n+\n     public void testSingleton() {\n         Percentile percentile = new Percentile(50);\n         double[] singletonArray = new double[] {1d};\n         assertEquals(1d, percentile.evaluate(singletonArray), 0);\n         assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0);\n         assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 5), 0);\n-        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 100), 0); \n-        assertTrue(Double.isNaN(percentile.evaluate(singletonArray, 0, 0)));     \n+        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 100), 0);\n+        assertTrue(Double.isNaN(percentile.evaluate(singletonArray, 0, 0)));\n     }\n-    \n+\n     public void testSpecialValues() {\n         Percentile percentile = new Percentile(50);\n         double[] specialValues = new double[] {0d, 1d, 2d, 3d, 4d,  Double.NaN};\n         specialValues =  new double[] {Double.NEGATIVE_INFINITY, 1d, 2d, 3d,\n                 Double.NaN, Double.POSITIVE_INFINITY};\n         assertEquals(2.5d, percentile.evaluate(specialValues), 0);\n-        specialValues = new double[] {1d, 1d, Double.POSITIVE_INFINITY, \n+        specialValues = new double[] {1d, 1d, Double.POSITIVE_INFINITY,\n                 Double.POSITIVE_INFINITY};\n         assertTrue(Double.isInfinite(percentile.evaluate(specialValues)));\n-        specialValues = new double[] {1d, 1d, Double.NaN, \n+        specialValues = new double[] {1d, 1d, Double.NaN,\n                 Double.NaN};\n         assertTrue(Double.isNaN(percentile.evaluate(specialValues)));\n-        specialValues = new double[] {1d, 1d, Double.NEGATIVE_INFINITY, \n+        specialValues = new double[] {1d, 1d, Double.NEGATIVE_INFINITY,\n                 Double.NEGATIVE_INFINITY};\n         // Interpolation results in NEGATIVE_INFINITY + POSITIVE_INFINITY\n-        assertTrue(Double.isNaN(percentile.evaluate(specialValues)));   \n+        assertTrue(Double.isNaN(percentile.evaluate(specialValues)));\n     }\n-    \n+\n     public void testSetQuantile() {\n         Percentile percentile = new Percentile(10);\n         percentile.setQuantile(100); // OK\n-        assertEquals(100, percentile.getQuantile(), 0);      \n+        assertEquals(100, percentile.getQuantile(), 0);\n         try {\n             percentile.setQuantile(0);\n             fail(\"Expecting IllegalArgumentException\");\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }        \n+        }\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumLogTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumLogTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n public class SumLogTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected SumOfLogs stat;\n-    \n+\n     /**\n      * @param name\n      */\n         suite.setName(\"SumLog Tests\");\n         return suite;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public UnivariateStatistic getUnivariateStatistic() {        \n+    public UnivariateStatistic getUnivariateStatistic() {\n         return new SumOfLogs();\n     }\n \n     public double expectedValue() {\n         return this.sumLog;\n     }\n-    \n+\n     public void testSpecialValues() {\n         SumOfLogs sum = new SumOfLogs();\n         // empty\n         assertTrue(Double.isNaN(sum.getResult()));\n-        \n+\n         // finite data\n         sum.increment(1d);\n         assertFalse(Double.isNaN(sum.getResult()));\n-        \n+\n         // add negative infinity\n         sum.increment(0d);\n         assertEquals(Double.NEGATIVE_INFINITY, sum.getResult(), 0);\n-        \n+\n         // add positive infinity -- should make NaN\n         sum.increment(Double.POSITIVE_INFINITY);\n         assertTrue(Double.isNaN(sum.getResult()));\n-        \n+\n         // clear\n         sum.clear();\n         assertTrue(Double.isNaN(sum.getResult()));\n-        \n+\n         // positive infinity by itself\n         sum.increment(Double.POSITIVE_INFINITY);\n         assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);\n-        \n+\n         // negative value -- should make NaN\n         sum.increment(-2d);\n         assertTrue(Double.isNaN(sum.getResult()));\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumSqTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/summary/SumSqTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n /**\n  * Test cases for the {@link SumOfSquares} class.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class SumSqTest extends StorelessUnivariateStatisticAbstractTest{\n \n     protected SumOfSquares stat;\n-    \n+\n     /**\n      * @param name\n      */\n         suite.setName(\"SumSq Tests\");\n         return suite;\n     }\n-    \n+\n     /**\n      * {@inheritDoc}\n      */\n     public double expectedValue() {\n         return this.sumSq;\n     }\n-    \n+\n     public void testSpecialValues() {\n         SumOfSquares sumSq = new SumOfSquares();\n         assertTrue(Double.isNaN(sumSq.getResult()));\n         sumSq.increment(Double.NEGATIVE_INFINITY);\n         assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);\n         sumSq.increment(Double.NaN);\n-        assertTrue(Double.isNaN(sumSq.getResult())); \n+        assertTrue(Double.isNaN(sumSq.getResult()));\n         sumSq.increment(1);\n-        assertTrue(Double.isNaN(sumSq.getResult())); \n+        assertTrue(Double.isNaN(sumSq.getResult()));\n     }\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/inference/ChiSquareFactoryTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/inference/ChiSquareFactoryTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/test/java/org/apache/commons/math/stat/inference/ChiSquareTestTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/inference/ChiSquareTestTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     }\n \n     public void testChiSquare() throws Exception {\n- \n-        // Target values computed using R version 1.8.1 \n-        // Some assembly required ;-)  \n+\n+        // Target values computed using R version 1.8.1\n+        // Some assembly required ;-)\n         //      Use sum((obs - exp)^2/exp) for the chi-square statistic and\n         //      1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value\n-        \n+\n         long[] observed = {10, 9, 11};\n         double[] expected = {10, 10, 10};\n         assertEquals(\"chi-square statistic\", 0.2,  testStatistic.chiSquare(expected, observed), 10E-12);\n         assertEquals(\"chi-square p-value\", 0.904837418036, testStatistic.chiSquareTest(expected, observed), 1E-10);\n-        \n+\n         long[] observed1 = { 500, 623, 72, 70, 31 };\n         double[] expected1 = { 485, 541, 82, 61, 37 };\n         assertEquals( \"chi-square test statistic\", 9.023307936427388, testStatistic.chiSquare(expected1, observed1), 1E-10);\n             fail(\"alpha out of range, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n-        \n+        }\n+\n         long[] tooShortObs = { 0 };\n         double[] tooShortEx = { 1 };\n         try {\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-        \n+\n         // 0 expected count\n         expected[0] = 0;\n         try {\n             fail(\"bad expected count, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        } \n-        \n+        }\n+\n         // negative observed count\n         expected[0] = 1;\n         observed[0] = -1;\n             fail(\"bad expected count, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        } \n-        \n+        }\n+\n     }\n \n     public void testChiSquareIndependence() throws Exception {\n-        \n-        // Target values computed using R version 1.8.1 \n-        \n+\n+        // Target values computed using R version 1.8.1\n+\n         long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};\n         assertEquals( \"chi-square test statistic\", 22.709027688, testStatistic.chiSquare(counts), 1E-9);\n         assertEquals(\"chi-square p-value\", 0.000144751460134, testStatistic.chiSquareTest(counts), 1E-9);\n         assertTrue(\"chi-square test reject\", testStatistic.chiSquareTest(counts, 0.0002));\n-        assertTrue(\"chi-square test accept\", !testStatistic.chiSquareTest(counts, 0.0001));    \n-        \n+        assertTrue(\"chi-square test accept\", !testStatistic.chiSquareTest(counts, 0.0001));\n+\n         long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };\n         assertEquals( \"chi-square test statistic\", 0.168965517241, testStatistic.chiSquare(counts2), 1E-9);\n         assertEquals(\"chi-square p-value\",0.918987499852, testStatistic.chiSquareTest(counts2), 1E-9);\n-        assertTrue(\"chi-square test accept\", !testStatistic.chiSquareTest(counts2, 0.1)); \n-        \n+        assertTrue(\"chi-square test accept\", !testStatistic.chiSquareTest(counts2, 0.1));\n+\n         // ragged input array\n         long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};\n         try {\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-        \n+\n         // insufficient data\n         long[][] counts4 = {{40, 22, 43}};\n         try {\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        } \n+        }\n         long[][] counts5 = {{40}, {40}, {30}, {10}};\n         try {\n             testStatistic.chiSquare(counts5);\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        } \n-        \n+        }\n+\n         // negative counts\n         long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };\n         try {\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        } \n-        \n+        }\n+\n         // bad alpha\n         try {\n             testStatistic.chiSquareTest(counts, 0);\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        } \n-    }\n-    \n+        }\n+    }\n+\n     public void testChiSquareLargeTestStatistic() throws Exception {\n         double[] exp = new double[] {\n-            3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, \n+            3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0,\n             232921.0, 437665.75\n         };\n \n             2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899\n         };\n         org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =\n-            new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); \n-        double cst = csti.chiSquareTest(exp, obs); \n+            new org.apache.commons.math.stat.inference.ChiSquareTestImpl();\n+        double cst = csti.chiSquareTest(exp, obs);\n         assertEquals(\"chi-square p-value\", 0.0, cst, 1E-3);\n-        assertEquals( \"chi-square test statistic\", \n+        assertEquals( \"chi-square test statistic\",\n                 114875.90421929007, testStatistic.chiSquare(exp, obs), 1E-9);\n     }\n-    \n+\n     /** Contingency table containing zeros - PR # 32531 */\n     public void testChiSquareZeroCount() throws Exception {\n-        // Target values computed using R version 1.8.1 \n+        // Target values computed using R version 1.8.1\n         long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};\n         assertEquals( \"chi-square test statistic\", 9.67444662263,\n                 testStatistic.chiSquare(counts), 1E-9);\n         assertEquals(\"chi-square p-value\", 0.0462835770603,\n-                testStatistic.chiSquareTest(counts), 1E-9);       \n-    }\n-    \n+                testStatistic.chiSquareTest(counts), 1E-9);\n+    }\n+\n     /** Target values verified using DATAPLOT version 2006.3 */\n     public void testChiSquareDataSetsComparisonEqualCounts()\n     throws Exception {\n         long[] observed1 = {10, 12, 12, 10};\n-        long[] observed2 = {5, 15, 14, 10};    \n-        assertEquals(\"chi-square p value\", 0.541096, \n+        long[] observed2 = {5, 15, 14, 10};\n+        assertEquals(\"chi-square p value\", 0.541096,\n                 testStatistic.chiSquareTestDataSetsComparison(\n                 observed1, observed2), 1E-6);\n         assertEquals(\"chi-square test statistic\", 2.153846,\n                 testStatistic.chiSquareDataSetsComparison(\n                 observed1, observed2), 1E-6);\n-        assertFalse(\"chi-square test result\", \n+        assertFalse(\"chi-square test result\",\n                 testStatistic.chiSquareTestDataSetsComparison(\n                 observed1, observed2, 0.4));\n     }\n-    \n+\n     /** Target values verified using DATAPLOT version 2006.3 */\n     public void testChiSquareDataSetsComparisonUnEqualCounts()\n     throws Exception {\n         long[] observed1 = {10, 12, 12, 10, 15};\n-        long[] observed2 = {15, 10, 10, 15, 5};    \n-        assertEquals(\"chi-square p value\", 0.124115, \n+        long[] observed2 = {15, 10, 10, 15, 5};\n+        assertEquals(\"chi-square p value\", 0.124115,\n                 testStatistic.chiSquareTestDataSetsComparison(\n                 observed1, observed2), 1E-6);\n         assertEquals(\"chi-square test statistic\", 7.232189,\n                 testStatistic.chiSquareDataSetsComparison(\n                 observed1, observed2), 1E-6);\n-        assertTrue(\"chi-square test result\", \n+        assertTrue(\"chi-square test result\",\n                 testStatistic.chiSquareTestDataSetsComparison(\n                 observed1, observed2, 0.13));\n-        assertFalse(\"chi-square test result\", \n+        assertFalse(\"chi-square test result\",\n                 testStatistic.chiSquareTestDataSetsComparison(\n                 observed1, observed2, 0.12));\n     }\n-    \n+\n     public void testChiSquareDataSetsComparisonBadCounts()\n     throws Exception {\n         long[] observed1 = {10, -1, 12, 10, 15};\n--- a/src/test/java/org/apache/commons/math/stat/inference/OneWayAnovaTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/inference/OneWayAnovaTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n public class OneWayAnovaTest extends TestCase {\n \n     protected OneWayAnova testStatistic = new OneWayAnovaImpl();\n-    \n+\n     private double[] emptyArray = {};\n \n     private double[] classA =\n         List<double[]> twoClasses = new ArrayList<double[]>();\n         twoClasses.add(classA);\n         twoClasses.add(classB);\n-        \n+\n         assertEquals(\"ANOVA F-value\",  0.0150579150579,\n                  testStatistic.anovaFValue(twoClasses), 1E-12);\n \n             fail(\"empty array for key classX, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n+        }\n \n         List<double[]> tooFew = new ArrayList<double[]>();\n         tooFew.add(classA);\n             fail(\"less than two classes, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n+        }\n     }\n-    \n+\n \n     public void testAnovaPValue() throws Exception {\n         // Target comparison values computed using R version 2.6.0 (Linux version)\n         List<double[]> twoClasses = new ArrayList<double[]>();\n         twoClasses.add(classA);\n         twoClasses.add(classB);\n-        \n+\n         assertEquals(\"ANOVA P-value\",  0.904212960464,\n                  testStatistic.anovaPValue(twoClasses), 1E-12);\n \n         List<double[]> twoClasses = new ArrayList<double[]>();\n         twoClasses.add(classA);\n         twoClasses.add(classB);\n-        \n+\n         assertFalse(\"ANOVA Test P>0.01\", testStatistic.anovaTest(twoClasses, 0.01));\n     }\n \n-}\n+}\n--- a/src/test/java/org/apache/commons/math/stat/inference/TTestFactoryTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/inference/TTestFactoryTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n--- a/src/test/java/org/apache/commons/math/stat/inference/TTestTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/inference/TTestTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n public class TTestTest extends TestCase {\n \n     protected TTest testStatistic = new TTestImpl();\n-    \n+\n     private double[] tooShortObs = { 1.0 };\n     private double[] emptyObs = {};\n-    private SummaryStatistics emptyStats = new SummaryStatistics();  \n-   SummaryStatistics tooShortStats = null;  \n+    private SummaryStatistics emptyStats = new SummaryStatistics();\n+   SummaryStatistics tooShortStats = null;\n \n     public TTestTest(String name) {\n         super(name);\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n- \n+\n         try {\n             testStatistic.t(mu, emptyStats);\n             fail(\"arguments too short, IllegalArgumentException expected\");\n             fail(\"insufficient data to perform t test, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n            // expected\n-        }  \n+        }\n \n         try {\n             testStatistic.t(mu, tooShortStats);\n             fail(\"insufficient data to perform t test, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n-    }\n-    \n+        }\n+    }\n+\n     public void testOneSampleTTest() throws Exception {\n         double[] oneSidedP =\n             {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d };\n-        SummaryStatistics oneSidedPStats = new SummaryStatistics();    \n+        SummaryStatistics oneSidedPStats = new SummaryStatistics();\n         for (int i = 0; i < oneSidedP.length; i++) {\n             oneSidedPStats.addValue(oneSidedP[i]);\n         }\n         // Target comparison values computed using R version 1.8.1 (Linux version)\n-        assertEquals(\"one sample t stat\", 3.86485535541, \n+        assertEquals(\"one sample t stat\", 3.86485535541,\n                 testStatistic.t(0d, oneSidedP), 10E-10);\n-        assertEquals(\"one sample t stat\", 3.86485535541, \n+        assertEquals(\"one sample t stat\", 3.86485535541,\n                 testStatistic.t(0d, oneSidedPStats),1E-10);\n         assertEquals(\"one sample p value\", 0.000521637019637,\n                 testStatistic.tTest(0d, oneSidedP) / 2d, 10E-10);\n         assertTrue(\"one sample t-test reject\", testStatistic.tTest(0d, oneSidedPStats, 0.01));\n         assertTrue(\"one sample t-test accept\", !testStatistic.tTest(0d, oneSidedP, 0.0001));\n         assertTrue(\"one sample t-test accept\", !testStatistic.tTest(0d, oneSidedPStats, 0.0001));\n-         \n+\n         try {\n             testStatistic.tTest(0d, oneSidedP, 95);\n             fail(\"alpha out of range, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n-        \n+        }\n+\n         try {\n             testStatistic.tTest(0d, oneSidedPStats, 95);\n             fail(\"alpha out of range, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n-        \n-    }\n-    \n+        }\n+\n+    }\n+\n     public void testTwoSampleTHeterscedastic() throws Exception {\n         double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };\n         double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };\n-        SummaryStatistics sampleStats1 = new SummaryStatistics();  \n+        SummaryStatistics sampleStats1 = new SummaryStatistics();\n         for (int i = 0; i < sample1.length; i++) {\n             sampleStats1.addValue(sample1[i]);\n         }\n-        SummaryStatistics sampleStats2 = new SummaryStatistics();    \n+        SummaryStatistics sampleStats2 = new SummaryStatistics();\n         for (int i = 0; i < sample2.length; i++) {\n             sampleStats2.addValue(sample2[i]);\n         }\n-         \n-        // Target comparison values computed using R version 1.8.1 (Linux version)\n-        assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768, \n+\n+        // Target comparison values computed using R version 1.8.1 (Linux version)\n+        assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768,\n                 testStatistic.t(sample1, sample2), 1E-10);\n-        assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768, \n+        assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768,\n                 testStatistic.t(sampleStats1, sampleStats2), 1E-10);\n-        assertEquals(\"two sample heteroscedastic p value\", 0.128839369622, \n+        assertEquals(\"two sample heteroscedastic p value\", 0.128839369622,\n                 testStatistic.tTest(sample1, sample2), 1E-10);\n-        assertEquals(\"two sample heteroscedastic p value\", 0.128839369622, \n-                testStatistic.tTest(sampleStats1, sampleStats2), 1E-10);     \n-        assertTrue(\"two sample heteroscedastic t-test reject\", \n+        assertEquals(\"two sample heteroscedastic p value\", 0.128839369622,\n+                testStatistic.tTest(sampleStats1, sampleStats2), 1E-10);\n+        assertTrue(\"two sample heteroscedastic t-test reject\",\n                 testStatistic.tTest(sample1, sample2, 0.2));\n-        assertTrue(\"two sample heteroscedastic t-test reject\", \n+        assertTrue(\"two sample heteroscedastic t-test reject\",\n                 testStatistic.tTest(sampleStats1, sampleStats2, 0.2));\n-        assertTrue(\"two sample heteroscedastic t-test accept\", \n+        assertTrue(\"two sample heteroscedastic t-test accept\",\n                 !testStatistic.tTest(sample1, sample2, 0.1));\n-        assertTrue(\"two sample heteroscedastic t-test accept\", \n+        assertTrue(\"two sample heteroscedastic t-test accept\",\n                 !testStatistic.tTest(sampleStats1, sampleStats2, 0.1));\n-     \n+\n         try {\n             testStatistic.tTest(sample1, sample2, .95);\n             fail(\"alpha out of range, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        } \n-        \n+        }\n+\n         try {\n             testStatistic.tTest(sampleStats1, sampleStats2, .95);\n             fail(\"alpha out of range, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n-            // expected \n-        }  \n-        \n+            // expected\n+        }\n+\n         try {\n             testStatistic.tTest(sample1, tooShortObs, .01);\n             fail(\"insufficient data, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n-        \n+        }\n+\n         try {\n             testStatistic.tTest(sampleStats1, tooShortStats, .01);\n             fail(\"insufficient data, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n-        \n+        }\n+\n         try {\n             testStatistic.tTest(sample1, tooShortObs);\n             fail(\"insufficient data, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n            // expected\n-        }  \n-        \n+        }\n+\n         try {\n             testStatistic.tTest(sampleStats1, tooShortStats);\n             fail(\"insufficient data, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n-        \n+        }\n+\n         try {\n             testStatistic.t(sample1, tooShortObs);\n             fail(\"insufficient data, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-        \n+\n         try {\n             testStatistic.t(sampleStats1, tooShortStats);\n             fail(\"insufficient data, IllegalArgumentException expected\");\n     public void testTwoSampleTHomoscedastic() throws Exception {\n         double[] sample1 ={2, 4, 6, 8, 10, 97};\n         double[] sample2 = {4, 6, 8, 10, 16};\n-        SummaryStatistics sampleStats1 = new SummaryStatistics();  \n+        SummaryStatistics sampleStats1 = new SummaryStatistics();\n         for (int i = 0; i < sample1.length; i++) {\n             sampleStats1.addValue(sample1[i]);\n         }\n-        SummaryStatistics sampleStats2 = new SummaryStatistics();    \n+        SummaryStatistics sampleStats2 = new SummaryStatistics();\n         for (int i = 0; i < sample2.length; i++) {\n             sampleStats2.addValue(sample2[i]);\n         }\n-        \n-        // Target comparison values computed using R version 1.8.1 (Linux version)\n-        assertEquals(\"two sample homoscedastic t stat\", 0.73096310086, \n+\n+        // Target comparison values computed using R version 1.8.1 (Linux version)\n+        assertEquals(\"two sample homoscedastic t stat\", 0.73096310086,\n               testStatistic.homoscedasticT(sample1, sample2), 10E-11);\n-        assertEquals(\"two sample homoscedastic p value\", 0.4833963785, \n-                testStatistic.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);     \n-        assertTrue(\"two sample homoscedastic t-test reject\", \n+        assertEquals(\"two sample homoscedastic p value\", 0.4833963785,\n+                testStatistic.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);\n+        assertTrue(\"two sample homoscedastic t-test reject\",\n                 testStatistic.homoscedasticTTest(sample1, sample2, 0.49));\n-        assertTrue(\"two sample homoscedastic t-test accept\", \n+        assertTrue(\"two sample homoscedastic t-test accept\",\n                 !testStatistic.homoscedasticTTest(sample1, sample2, 0.48));\n     }\n-    \n+\n     public void testSmallSamples() throws Exception {\n         double[] sample1 = {1d, 3d};\n-        double[] sample2 = {4d, 5d};        \n-        \n+        double[] sample2 = {4d, 5d};\n+\n         // Target values computed using R, version 1.8.1 (linux version)\n         assertEquals(-2.2360679775, testStatistic.t(sample1, sample2),\n                 1E-10);\n         assertEquals(0.198727388935, testStatistic.tTest(sample1, sample2),\n                 1E-10);\n     }\n-    \n+\n     public void testPaired() throws Exception {\n         double[] sample1 = {1d, 3d, 5d, 7d};\n         double[] sample2 = {0d, 6d, 11d, 2d};\n         assertEquals(0.774544295819, testStatistic.pairedTTest(sample1, sample2), 1E-10);\n         assertEquals(0.001208, testStatistic.pairedTTest(sample1, sample3), 1E-6);\n         assertFalse(testStatistic.pairedTTest(sample1, sample3, .001));\n-        assertTrue(testStatistic.pairedTTest(sample1, sample3, .002));    \n+        assertTrue(testStatistic.pairedTTest(sample1, sample3, .002));\n     }\n }\n--- a/src/test/java/org/apache/commons/math/stat/inference/TestUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/inference/TestUtilsTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     }\n \n     public void testChiSquare() throws Exception {\n-        \n-        // Target values computed using R version 1.8.1 \n-        // Some assembly required ;-)  \n+\n+        // Target values computed using R version 1.8.1\n+        // Some assembly required ;-)\n         //      Use sum((obs - exp)^2/exp) for the chi-square statistic and\n         //      1 - pchisq(sum((obs - exp)^2/exp), length(obs) - 1) for the p-value\n-        \n+\n         long[] observed = {10, 9, 11};\n         double[] expected = {10, 10, 10};\n         assertEquals(\"chi-square statistic\", 0.2,  TestUtils.chiSquare(expected, observed), 10E-12);\n         assertEquals(\"chi-square p-value\", 0.904837418036, TestUtils.chiSquareTest(expected, observed), 1E-10);\n-        \n+\n         long[] observed1 = { 500, 623, 72, 70, 31 };\n         double[] expected1 = { 485, 541, 82, 61, 37 };\n         assertEquals( \"chi-square test statistic\", 9.023307936427388, TestUtils.chiSquare(expected1, observed1), 1E-10);\n             fail(\"alpha out of range, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n-        \n+        }\n+\n         long[] tooShortObs = { 0 };\n         double[] tooShortEx = { 1 };\n         try {\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-        \n+\n         // 0 expected count\n         expected[0] = 0;\n         try {\n             fail(\"bad expected count, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        } \n-        \n+        }\n+\n         // negative observed count\n         expected[0] = 1;\n         observed[0] = -1;\n             fail(\"bad expected count, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        } \n-        \n+        }\n+\n     }\n \n     public void testChiSquareIndependence() throws Exception {\n-        \n-        // Target values computed using R version 1.8.1 \n-        \n+\n+        // Target values computed using R version 1.8.1\n+\n         long[][] counts = { {40, 22, 43}, {91, 21, 28}, {60, 10, 22}};\n         assertEquals( \"chi-square test statistic\", 22.709027688, TestUtils.chiSquare(counts), 1E-9);\n         assertEquals(\"chi-square p-value\", 0.000144751460134, TestUtils.chiSquareTest(counts), 1E-9);\n         assertTrue(\"chi-square test reject\", TestUtils.chiSquareTest(counts, 0.0002));\n-        assertTrue(\"chi-square test accept\", !TestUtils.chiSquareTest(counts, 0.0001));    \n-        \n+        assertTrue(\"chi-square test accept\", !TestUtils.chiSquareTest(counts, 0.0001));\n+\n         long[][] counts2 = {{10, 15}, {30, 40}, {60, 90} };\n         assertEquals( \"chi-square test statistic\", 0.168965517241, TestUtils.chiSquare(counts2), 1E-9);\n         assertEquals(\"chi-square p-value\",0.918987499852, TestUtils.chiSquareTest(counts2), 1E-9);\n-        assertTrue(\"chi-square test accept\", !TestUtils.chiSquareTest(counts2, 0.1)); \n-        \n+        assertTrue(\"chi-square test accept\", !TestUtils.chiSquareTest(counts2, 0.1));\n+\n         // ragged input array\n         long[][] counts3 = { {40, 22, 43}, {91, 21, 28}, {60, 10}};\n         try {\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-        \n+\n         // insufficient data\n         long[][] counts4 = {{40, 22, 43}};\n         try {\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        } \n+        }\n         long[][] counts5 = {{40}, {40}, {30}, {10}};\n         try {\n             TestUtils.chiSquare(counts5);\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        } \n-        \n+        }\n+\n         // negative counts\n         long[][] counts6 = {{10, -2}, {30, 40}, {60, 90} };\n         try {\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        } \n-        \n+        }\n+\n         // bad alpha\n         try {\n             TestUtils.chiSquareTest(counts, 0);\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        } \n-    }\n-    \n+        }\n+    }\n+\n     public void testChiSquareLargeTestStatistic() throws Exception {\n         double[] exp = new double[] {\n-                3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0, \n+                3389119.5, 649136.6, 285745.4, 25357364.76, 11291189.78, 543628.0,\n                 232921.0, 437665.75\n         };\n \n                 2372383, 584222, 257170, 17750155, 7903832, 489265, 209628, 393899\n         };\n         org.apache.commons.math.stat.inference.ChiSquareTestImpl csti =\n-            new org.apache.commons.math.stat.inference.ChiSquareTestImpl(); \n-        double cst = csti.chiSquareTest(exp, obs); \n+            new org.apache.commons.math.stat.inference.ChiSquareTestImpl();\n+        double cst = csti.chiSquareTest(exp, obs);\n         assertEquals(\"chi-square p-value\", 0.0, cst, 1E-3);\n-        assertEquals( \"chi-square test statistic\", \n+        assertEquals( \"chi-square test statistic\",\n                 114875.90421929007, TestUtils.chiSquare(exp, obs), 1E-9);\n     }\n-    \n+\n     /** Contingency table containing zeros - PR # 32531 */\n     public void testChiSquareZeroCount() throws Exception {\n-        // Target values computed using R version 1.8.1 \n+        // Target values computed using R version 1.8.1\n         long[][] counts = { {40, 0, 4}, {91, 1, 2}, {60, 2, 0}};\n         assertEquals( \"chi-square test statistic\", 9.67444662263,\n                 TestUtils.chiSquare(counts), 1E-9);\n         assertEquals(\"chi-square p-value\", 0.0462835770603,\n-                TestUtils.chiSquareTest(counts), 1E-9);       \n-    }\n-    \n+                TestUtils.chiSquareTest(counts), 1E-9);\n+    }\n+\n     private double[] tooShortObs = { 1.0 };\n     private double[] emptyObs = {};\n-    private SummaryStatistics emptyStats = new SummaryStatistics();  \n+    private SummaryStatistics emptyStats = new SummaryStatistics();\n \n     public void testOneSampleT() throws Exception {\n         double[] observed =\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-        \n+\n         try {\n             TestUtils.t(mu, emptyStats);\n             fail(\"arguments too short, IllegalArgumentException expected\");\n             fail(\"insufficient data to perform t test, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n+        }\n \n         try {\n             TestUtils.t(mu, (SummaryStatistics) null);\n             fail(\"insufficient data to perform t test, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n-    }\n-    \n+        }\n+    }\n+\n     public void testOneSampleTTest() throws Exception {\n         double[] oneSidedP =\n             {2d, 0d, 6d, 6d, 3d, 3d, 2d, 3d, -6d, 6d, 6d, 6d, 3d, 0d, 1d, 1d, 0d, 2d, 3d, 3d };\n-        SummaryStatistics oneSidedPStats = new SummaryStatistics();    \n+        SummaryStatistics oneSidedPStats = new SummaryStatistics();\n         for (int i = 0; i < oneSidedP.length; i++) {\n             oneSidedPStats.addValue(oneSidedP[i]);\n         }\n         // Target comparison values computed using R version 1.8.1 (Linux version)\n-        assertEquals(\"one sample t stat\", 3.86485535541, \n+        assertEquals(\"one sample t stat\", 3.86485535541,\n                 TestUtils.t(0d, oneSidedP), 10E-10);\n-        assertEquals(\"one sample t stat\", 3.86485535541, \n+        assertEquals(\"one sample t stat\", 3.86485535541,\n                 TestUtils.t(0d, oneSidedPStats),1E-10);\n         assertEquals(\"one sample p value\", 0.000521637019637,\n                 TestUtils.tTest(0d, oneSidedP) / 2d, 10E-10);\n         assertTrue(\"one sample t-test reject\", TestUtils.tTest(0d, oneSidedPStats, 0.01));\n         assertTrue(\"one sample t-test accept\", !TestUtils.tTest(0d, oneSidedP, 0.0001));\n         assertTrue(\"one sample t-test accept\", !TestUtils.tTest(0d, oneSidedPStats, 0.0001));\n-        \n+\n         try {\n             TestUtils.tTest(0d, oneSidedP, 95);\n             fail(\"alpha out of range, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n-        \n+        }\n+\n         try {\n             TestUtils.tTest(0d, oneSidedPStats, 95);\n             fail(\"alpha out of range, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n-        \n-    }\n-    \n+        }\n+\n+    }\n+\n     public void testTwoSampleTHeterscedastic() throws Exception {\n         double[] sample1 = { 7d, -4d, 18d, 17d, -3d, -5d, 1d, 10d, 11d, -2d };\n         double[] sample2 = { -1d, 12d, -1d, -3d, 3d, -5d, 5d, 2d, -11d, -1d, -3d };\n-        SummaryStatistics sampleStats1 = new SummaryStatistics();  \n+        SummaryStatistics sampleStats1 = new SummaryStatistics();\n         for (int i = 0; i < sample1.length; i++) {\n             sampleStats1.addValue(sample1[i]);\n         }\n-        SummaryStatistics sampleStats2 = new SummaryStatistics();    \n+        SummaryStatistics sampleStats2 = new SummaryStatistics();\n         for (int i = 0; i < sample2.length; i++) {\n             sampleStats2.addValue(sample2[i]);\n         }\n-        \n+\n         // Target comparison values computed using R version 1.8.1 (Linux version)\n-        assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768, \n+        assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768,\n                 TestUtils.t(sample1, sample2), 1E-10);\n-        assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768, \n+        assertEquals(\"two sample heteroscedastic t stat\", 1.60371728768,\n                 TestUtils.t(sampleStats1, sampleStats2), 1E-10);\n-        assertEquals(\"two sample heteroscedastic p value\", 0.128839369622, \n+        assertEquals(\"two sample heteroscedastic p value\", 0.128839369622,\n                 TestUtils.tTest(sample1, sample2), 1E-10);\n-        assertEquals(\"two sample heteroscedastic p value\", 0.128839369622, \n-                TestUtils.tTest(sampleStats1, sampleStats2), 1E-10);     \n-        assertTrue(\"two sample heteroscedastic t-test reject\", \n+        assertEquals(\"two sample heteroscedastic p value\", 0.128839369622,\n+                TestUtils.tTest(sampleStats1, sampleStats2), 1E-10);\n+        assertTrue(\"two sample heteroscedastic t-test reject\",\n                 TestUtils.tTest(sample1, sample2, 0.2));\n-        assertTrue(\"two sample heteroscedastic t-test reject\", \n+        assertTrue(\"two sample heteroscedastic t-test reject\",\n                 TestUtils.tTest(sampleStats1, sampleStats2, 0.2));\n-        assertTrue(\"two sample heteroscedastic t-test accept\", \n+        assertTrue(\"two sample heteroscedastic t-test accept\",\n                 !TestUtils.tTest(sample1, sample2, 0.1));\n-        assertTrue(\"two sample heteroscedastic t-test accept\", \n+        assertTrue(\"two sample heteroscedastic t-test accept\",\n                 !TestUtils.tTest(sampleStats1, sampleStats2, 0.1));\n-        \n+\n         try {\n             TestUtils.tTest(sample1, sample2, .95);\n             fail(\"alpha out of range, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        } \n-        \n+        }\n+\n         try {\n             TestUtils.tTest(sampleStats1, sampleStats2, .95);\n             fail(\"alpha out of range, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n-            // expected \n-        }  \n-        \n+            // expected\n+        }\n+\n         try {\n             TestUtils.tTest(sample1, tooShortObs, .01);\n             fail(\"insufficient data, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n-        \n+        }\n+\n         try {\n             TestUtils.tTest(sampleStats1, (SummaryStatistics) null, .01);\n             fail(\"insufficient data, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n-        \n+        }\n+\n         try {\n             TestUtils.tTest(sample1, tooShortObs);\n             fail(\"insufficient data, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n-        \n+        }\n+\n         try {\n             TestUtils.tTest(sampleStats1, (SummaryStatistics) null);\n             fail(\"insufficient data, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n-        }  \n-        \n+        }\n+\n         try {\n             TestUtils.t(sample1, tooShortObs);\n             fail(\"insufficient data, IllegalArgumentException expected\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-        \n+\n         try {\n             TestUtils.t(sampleStats1, (SummaryStatistics) null);\n             fail(\"insufficient data, IllegalArgumentException expected\");\n     public void testTwoSampleTHomoscedastic() throws Exception {\n         double[] sample1 ={2, 4, 6, 8, 10, 97};\n         double[] sample2 = {4, 6, 8, 10, 16};\n-        SummaryStatistics sampleStats1 = new SummaryStatistics();  \n+        SummaryStatistics sampleStats1 = new SummaryStatistics();\n         for (int i = 0; i < sample1.length; i++) {\n             sampleStats1.addValue(sample1[i]);\n         }\n-        SummaryStatistics sampleStats2 = new SummaryStatistics();    \n+        SummaryStatistics sampleStats2 = new SummaryStatistics();\n         for (int i = 0; i < sample2.length; i++) {\n             sampleStats2.addValue(sample2[i]);\n         }\n-        \n+\n         // Target comparison values computed using R version 1.8.1 (Linux version)\n-        assertEquals(\"two sample homoscedastic t stat\", 0.73096310086, \n+        assertEquals(\"two sample homoscedastic t stat\", 0.73096310086,\n                 TestUtils.homoscedasticT(sample1, sample2), 10E-11);\n-        assertEquals(\"two sample homoscedastic p value\", 0.4833963785, \n-                TestUtils.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);     \n-        assertTrue(\"two sample homoscedastic t-test reject\", \n+        assertEquals(\"two sample homoscedastic p value\", 0.4833963785,\n+                TestUtils.homoscedasticTTest(sampleStats1, sampleStats2), 1E-10);\n+        assertTrue(\"two sample homoscedastic t-test reject\",\n                 TestUtils.homoscedasticTTest(sample1, sample2, 0.49));\n-        assertTrue(\"two sample homoscedastic t-test accept\", \n+        assertTrue(\"two sample homoscedastic t-test accept\",\n                 !TestUtils.homoscedasticTTest(sample1, sample2, 0.48));\n     }\n-    \n+\n     public void testSmallSamples() throws Exception {\n         double[] sample1 = {1d, 3d};\n-        double[] sample2 = {4d, 5d};        \n-        \n+        double[] sample2 = {4d, 5d};\n+\n         // Target values computed using R, version 1.8.1 (linux version)\n         assertEquals(-2.2360679775, TestUtils.t(sample1, sample2),\n                 1E-10);\n         assertEquals(0.198727388935, TestUtils.tTest(sample1, sample2),\n                 1E-10);\n     }\n-    \n+\n     public void testPaired() throws Exception {\n         double[] sample1 = {1d, 3d, 5d, 7d};\n         double[] sample2 = {0d, 6d, 11d, 2d};\n         assertEquals(0.774544295819, TestUtils.pairedTTest(sample1, sample2), 1E-10);\n         assertEquals(0.001208, TestUtils.pairedTTest(sample1, sample3), 1E-6);\n         assertFalse(TestUtils.pairedTTest(sample1, sample3, .001));\n-        assertTrue(TestUtils.pairedTTest(sample1, sample3, .002));    \n-    }\n-    \n+        assertTrue(TestUtils.pairedTTest(sample1, sample3, .002));\n+    }\n+\n     private double[] classA =\n       {93.0, 103.0, 95.0, 101.0};\n     private double[] classB =\n       {99.0, 92.0, 102.0, 100.0, 102.0};\n     private double[] classC =\n       {110.0, 115.0, 111.0, 117.0, 128.0};\n-    \n+\n     private List<double[]> classes = new ArrayList<double[]>();\n     private OneWayAnova oneWayAnova = new OneWayAnovaImpl();\n-    \n+\n     public void testOneWayAnovaUtils() throws Exception {\n         classes.add(classA);\n         classes.add(classB);\n         classes.add(classC);\n-        assertEquals(oneWayAnova.anovaFValue(classes), \n+        assertEquals(oneWayAnova.anovaFValue(classes),\n                 TestUtils.oneWayAnovaFValue(classes), 10E-12);\n-        assertEquals(oneWayAnova.anovaPValue(classes), \n+        assertEquals(oneWayAnova.anovaPValue(classes),\n                 TestUtils.oneWayAnovaPValue(classes), 10E-12);\n-        assertEquals(oneWayAnova.anovaTest(classes, 0.01), \n-                TestUtils.oneWayAnovaTest(classes, 0.01));   \n-    } \n+        assertEquals(oneWayAnova.anovaTest(classes, 0.01),\n+                TestUtils.oneWayAnovaTest(classes, 0.01));\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/stat/ranking/NaturalRankingTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/ranking/NaturalRankingTest.java\n \n /**\n  * Test cases for NaturalRanking class\n- * \n+ *\n  * @since 2.0\n  * @version $Revision$ $Date$\n  */\n--- a/src/test/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegressionTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegressionTest.java\n         omega[5] = new double[]{0, 0, 0, 0, 0, 6.0};\n         super.setUp();\n     }\n-   \n+\n     @Test(expected=IllegalArgumentException.class)\n     public void cannotAddXSampleData() {\n         createRegression().newSampleData(new double[]{}, null, null);\n     public void cannotAddNullYSampleData() {\n         createRegression().newSampleData(null, new double[][]{}, null);\n     }\n-    \n+\n     @Test(expected=IllegalArgumentException.class)\n     public void cannotAddSampleDataWithSizeMismatch() {\n         double[] y = new double[]{1.0, 2.0};\n         x[0] = new double[]{1.0, 0};\n         createRegression().newSampleData(y, x, null);\n     }\n-    \n+\n     @Test(expected=IllegalArgumentException.class)\n     public void cannotAddNullCovarianceData() {\n         createRegression().newSampleData(new double[]{}, new double[][]{}, null);\n     }\n-    \n+\n     @Test(expected=IllegalArgumentException.class)\n     public void notEnoughData() {\n         double[]   reducedY = new double[y.length - 1];\n         System.arraycopy(omega, 0, reducedO, 0, reducedO.length);\n         createRegression().newSampleData(reducedY, reducedX, reducedO);\n     }\n-    \n+\n     @Test(expected=IllegalArgumentException.class)\n     public void cannotAddCovarianceDataWithSampleSizeMismatch() {\n         double[] y = new double[]{1.0, 2.0};\n     protected int getSampleSize() {\n         return y.length;\n     }\n-        \n+\n }\n--- a/src/test/java/org/apache/commons/math/stat/regression/MultipleLinearRegressionAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/regression/MultipleLinearRegressionAbstractTest.java\n     }\n \n     protected abstract MultipleLinearRegression createRegression();\n-    \n+\n     protected abstract int getNumberOfRegressors();\n-    \n+\n     protected abstract int getSampleSize();\n \n     @Test\n     public void canEstimateRegressionParameters(){\n-        double[] beta = regression.estimateRegressionParameters();        \n+        double[] beta = regression.estimateRegressionParameters();\n         assertEquals(getNumberOfRegressors(), beta.length);\n     }\n \n         double[] e = regression.estimateResiduals();\n         assertEquals(getSampleSize(), e.length);\n     }\n-    \n+\n     @Test\n     public void canEstimateRegressionParametersVariance(){\n         double[][] variance = regression.estimateRegressionParametersVariance();\n             double variance = regression.estimateRegressandVariance();\n             assertTrue(variance > 0.0);\n         }\n-    }   \n+    }\n \n }\n--- a/src/test/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegressionTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegressionTest.java\n \n     private double[] y;\n     private double[][] x;\n-    \n+\n     @Before\n     @Override\n     public void setUp(){\n     protected int getSampleSize() {\n         return y.length;\n     }\n-    \n+\n     @Test(expected=IllegalArgumentException.class)\n     public void cannotAddXSampleData() {\n         createRegression().newSampleData(new double[]{}, null);\n     public void cannotAddNullYSampleData() {\n         createRegression().newSampleData(null, new double[][]{});\n     }\n-    \n+\n     @Test(expected=IllegalArgumentException.class)\n     public void cannotAddSampleDataWithSizeMismatch() {\n         double[] y = new double[]{1.0, 2.0};\n         x[0] = new double[]{1.0, 0};\n         createRegression().newSampleData(y, x);\n     }\n-    \n+\n     @Test\n     public void testPerfectFit() {\n         double[] betaHat = regression.estimateRegressionParameters();\n-        TestUtils.assertEquals(betaHat, \n+        TestUtils.assertEquals(betaHat,\n                                new double[]{ 11.0, 1.0 / 2.0, 2.0 / 3.0, 3.0 / 4.0, 4.0 / 5.0, 5.0 / 6.0 },\n                                1e-14);\n         double[] residuals = regression.estimateResiduals();\n                      errors.subtract(referenceVariance).getNorm(),\n                      5.0e-16 * referenceVariance.getNorm());\n     }\n-    \n-    \n+\n+\n     /**\n      * Test Longley dataset against certified values provided by NIST.\n      * Data Source: J. Longley (1967) \"An Appraisal of Least Squares\n      * Programs for the Electronic Computer from the Point of View of the User\"\n      * Journal of the American Statistical Association, vol. 62. September,\n      * pp. 819-841.\n-     * \n+     *\n      * Certified values (and data) are from NIST:\n      * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat\n      */\n             69331,115.7,518173,4806,2572,127852,1961,\n             70551,116.9,554894,4007,2827,130081,1962\n         };\n-        \n+\n         // Transform to Y and X required by interface\n         int nobs = 16;\n         int nvars = 6;\n-        \n+\n         // Estimate the model\n         OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();\n         model.newSampleData(design, nobs, nvars);\n-        \n+\n         // Check expected beta values from NIST\n         double[] betaHat = model.estimateRegressionParameters();\n-        TestUtils.assertEquals(betaHat, \n+        TestUtils.assertEquals(betaHat,\n           new double[]{-3482258.63459582, 15.0618722713733,\n                 -0.358191792925910E-01,-2.02022980381683,\n                 -1.03322686717359,-0.511041056535807E-01,\n-                 1829.15146461355}, 2E-8); // \n-        \n+                 1829.15146461355}, 2E-8); //\n+\n         // Check expected residuals from R\n         double[] residuals = model.estimateResiduals();\n         TestUtils.assertEquals(residuals, new double[]{\n                 -155.5499735953195,-85.6713080421283,341.9315139607727,\n                 -206.7578251937366},\n                       1E-8);\n-        \n+\n         // Check standard errors from NIST\n         double[] errors = model.estimateRegressionParametersStandardErrors();\n         TestUtils.assertEquals(new double[] {890420.383607373,\n                        0.488399681651699,\n                        0.214274163161675,\n                        0.226073200069370,\n-                       455.478499142212}, errors, 1E-6); \n-    }\n-    \n+                       455.478499142212}, errors, 1E-6);\n+    }\n+\n     /**\n      * Test R Swiss fertility dataset against R.\n      * Data Source: R datasets package\n \n         // Check expected beta values from R\n         double[] betaHat = model.estimateRegressionParameters();\n-        TestUtils.assertEquals(betaHat, \n+        TestUtils.assertEquals(betaHat,\n                 new double[]{91.05542390271397,\n                 -0.22064551045715,\n                 -0.26058239824328,\n                 5.4326230830188482,-7.2375578629692230,2.1671550814448222,\n                 15.0147574652763112,4.8625103516321015,-7.1597256413907706,\n                 -0.4515205619767598,-10.2916870903837587,-15.7812984571900063},\n-                1E-12); \n-        \n+                1E-12);\n+\n         // Check standard errors from R\n         double[] errors = model.estimateRegressionParametersStandardErrors();\n         TestUtils.assertEquals(new double[] {6.94881329475087,\n                 0.07360008972340,\n                 0.27410957467466,\n                 0.19454551679325,\n-                0.03726654773803}, errors, 1E-10); \n-    }\n-    \n+                0.03726654773803}, errors, 1E-10);\n+    }\n+\n     /**\n      * Test hat matrix computation\n-     * \n+     *\n      * @throws Exception\n      */\n     @Test\n     public void testHat() throws Exception {\n-        \n+\n         /*\n-         * This example is from \"The Hat Matrix in Regression and ANOVA\", \n-         * David C. Hoaglin and Roy E. Welsch, \n+         * This example is from \"The Hat Matrix in Regression and ANOVA\",\n+         * David C. Hoaglin and Roy E. Welsch,\n          * The American Statistician, Vol. 32, No. 1 (Feb., 1978), pp. 17-22.\n-         * \n+         *\n          */\n         double[] design = new double[] {\n                 11.14, .499, 11.1,\n                 11.02, .406, 10.5,\n                 11.41, .467, 10.7\n         };\n-        \n+\n         int nobs = 10;\n         int nvars = 2;\n-        \n+\n         // Estimate the model\n         OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();\n         model.newSampleData(design, nobs, nvars);\n-        \n+\n         RealMatrix hat = model.calculateHat();\n-        \n+\n         // Reference data is upper half of symmetric hat matrix\n         double[] referenceData = new double[] {\n                 .418, -.002,  .079, -.274, -.046,  .181,  .128,  .222,  .050,  .242,\n                                                                         .315,  .148,\n                                                                                .187\n         };\n-        \n+\n         // Check against reference data and verify symmetry\n         int k = 0;\n         for (int i = 0; i < 10; i++) {\n             for (int j = i; j < 10; j++) {\n                 assertEquals(referenceData[k], hat.getEntry(i, j), 10e-3);\n                 assertEquals(hat.getEntry(i, j), hat.getEntry(j, i), 10e-12);\n-                k++;  \n+                k++;\n             }\n         }\n-        \n-        /* \n-         * Verify that residuals computed using the hat matrix are close to \n+\n+        /*\n+         * Verify that residuals computed using the hat matrix are close to\n          * what we get from direct computation, i.e. r = (I - H) y\n          */\n         double[] residuals = model.estimateResiduals();\n         RealMatrix I = MatrixUtils.createRealIdentityMatrix(10);\n         double[] hatResiduals = I.subtract(hat).operate(model.Y).getData();\n-        TestUtils.assertEquals(residuals, hatResiduals, 10e-12);    \n+        TestUtils.assertEquals(residuals, hatResiduals, 10e-12);\n     }\n }\n--- a/src/test/java/org/apache/commons/math/stat/regression/SimpleRegressionTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/regression/SimpleRegressionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n public final class SimpleRegressionTest extends TestCase {\n \n-    /* \n-     * NIST \"Norris\" refernce data set from \n+    /*\n+     * NIST \"Norris\" refernce data set from\n      * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat\n      * Strangely, order is {y,x}\n      */\n-    private double[][] data = { { 0.1, 0.2 }, {338.8, 337.4 }, {118.1, 118.2 }, \n-            {888.0, 884.6 }, {9.2, 10.1 }, {228.1, 226.5 }, {668.5, 666.3 }, {998.5, 996.3 }, \n-            {449.1, 448.6 }, {778.9, 777.0 }, {559.2, 558.2 }, {0.3, 0.4 }, {0.1, 0.6 }, {778.1, 775.5 }, \n-            {668.8, 666.9 }, {339.3, 338.0 }, {448.9, 447.5 }, {10.8, 11.6 }, {557.7, 556.0 }, \n-            {228.3, 228.1 }, {998.0, 995.8 }, {888.8, 887.6 }, {119.6, 120.2 }, {0.3, 0.3 }, \n-            {0.6, 0.3 }, {557.6, 556.8 }, {339.3, 339.1 }, {888.0, 887.2 }, {998.5, 999.0 }, \n-            {778.9, 779.0 }, {10.2, 11.1 }, {117.6, 118.3 }, {228.9, 229.2 }, {668.4, 669.1 }, \n+    private double[][] data = { { 0.1, 0.2 }, {338.8, 337.4 }, {118.1, 118.2 },\n+            {888.0, 884.6 }, {9.2, 10.1 }, {228.1, 226.5 }, {668.5, 666.3 }, {998.5, 996.3 },\n+            {449.1, 448.6 }, {778.9, 777.0 }, {559.2, 558.2 }, {0.3, 0.4 }, {0.1, 0.6 }, {778.1, 775.5 },\n+            {668.8, 666.9 }, {339.3, 338.0 }, {448.9, 447.5 }, {10.8, 11.6 }, {557.7, 556.0 },\n+            {228.3, 228.1 }, {998.0, 995.8 }, {888.8, 887.6 }, {119.6, 120.2 }, {0.3, 0.3 },\n+            {0.6, 0.3 }, {557.6, 556.8 }, {339.3, 339.1 }, {888.0, 887.2 }, {998.5, 999.0 },\n+            {778.9, 779.0 }, {10.2, 11.1 }, {117.6, 118.3 }, {228.9, 229.2 }, {668.4, 669.1 },\n             {449.2, 448.9 }, {0.2, 0.5 }\n     };\n \n-    /* \n-     * Correlation example from \n+    /*\n+     * Correlation example from\n      * http://www.xycoon.com/correlation.htm\n      */\n-    private double[][] corrData = { { 101.0, 99.2 }, {100.1, 99.0 }, {100.0, 100.0 }, \n-            {90.6, 111.6 }, {86.5, 122.2 }, {89.7, 117.6 }, {90.6, 121.1 }, {82.8, 136.0 }, \n-            {70.1, 154.2 }, {65.4, 153.6 }, {61.3, 158.5 }, {62.5, 140.6 }, {63.6, 136.2 }, \n+    private double[][] corrData = { { 101.0, 99.2 }, {100.1, 99.0 }, {100.0, 100.0 },\n+            {90.6, 111.6 }, {86.5, 122.2 }, {89.7, 117.6 }, {90.6, 121.1 }, {82.8, 136.0 },\n+            {70.1, 154.2 }, {65.4, 153.6 }, {61.3, 158.5 }, {62.5, 140.6 }, {63.6, 136.2 },\n             {52.6, 168.0 }, {59.7, 154.3 }, {59.5, 149.0 }, {61.3, 165.5 }\n     };\n \n     /*\n      * From Moore and Mcabe, \"Introduction to the Practice of Statistics\"\n-     * Example 10.3 \n+     * Example 10.3\n      */\n     private double[][] infData = { { 15.6, 5.2 }, {26.8, 6.1 }, {37.8, 8.7 }, {36.4, 8.5 },\n             {35.5, 8.8 }, {18.6, 4.9 }, {15.3, 4.5 }, {7.9, 2.5 }, {0.0, 1.1 }\n     };\n-    \n+\n     /*\n      * Points to remove in the remove tests\n      */\n     private double[][] removeMultiple = { infData[1], infData[2] };\n     private double removeX = infData[0][0];\n     private double removeY = infData[0][1];\n-    \n-            \n+\n+\n     /*\n      * Data with bad linear fit\n      */\n         for (int i = 0; i < data.length; i++) {\n             regression.addData(data[i][1], data[i][0]);\n         }\n-        // Tests against certified values from  \n+        // Tests against certified values from\n         // http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat\n         assertEquals(\"slope\", 1.00211681802045, regression.getSlope(), 10E-12);\n         assertEquals(\"slope std err\", 0.429796848199937E-03,\n         assertEquals(\"SSE\", 26.6173985294224,\n             regression.getSumSquaredErrors(),10E-9);\n         // ------------  End certified data tests\n-          \n+\n         assertEquals( \"predict(0)\",  -0.262323073774029,\n             regression.predict(0), 10E-12);\n         assertEquals(\"predict(1)\", 1.00211681802045 - 0.262323073774029,\n         regression.addData(1, 2);\n         regression.addData(3, 3);\n \n-        // All should be OK except MSE, s(b0), s(b1) which need one more df \n+        // All should be OK except MSE, s(b0), s(b1) which need one more df\n         assertTrue(\"interceptNaN\", !Double.isNaN(regression.getIntercept()));\n         assertTrue(\"slope NaN\", !Double.isNaN(regression.getSlope()));\n         assertTrue (\"slope std err not NaN\", Double.isNaN(regression.getSlopeStdErr()));\n         assertEquals(\"std err intercept\", 0.286036932,\n                 regression.getInterceptStdErr(),1E-8);\n         assertEquals(\"significance\", 4.596e-07,\n-                regression.getSignificance(),1E-8);    \n-        assertEquals(\"slope conf interval half-width\", 0.0270713794287, \n+                regression.getSignificance(),1E-8);\n+        assertEquals(\"slope conf interval half-width\", 0.0270713794287,\n                 regression.getSlopeConfidenceInterval(),1E-8);\n         // infData2\n         regression = new SimpleRegression();\n         assertEquals(\"std err intercept\",4.17718672,\n                 regression.getInterceptStdErr(),1E-8);\n         assertEquals(\"significance\", 0.261829133982,\n-                regression.getSignificance(),1E-11);    \n-        assertEquals(\"slope conf interval half-width\", 2.97802204827, \n+                regression.getSignificance(),1E-11);\n+        assertEquals(\"slope conf interval half-width\", 2.97802204827,\n                 regression.getSlopeConfidenceInterval(),1E-8);\n         //------------- End R-verified tests -------------------------------\n-        \n+\n         //FIXME: get a real example to test against with alpha = .01\n         assertTrue(\"tighter means wider\",\n                 regression.getSlopeConfidenceInterval() < regression.getSlopeConfidenceInterval(0.01));\n-     \n+\n         try {\n             regression.getSlopeConfidenceInterval(1);\n             fail(\"expecting IllegalArgumentException for alpha = 1\");\n         } catch (IllegalArgumentException ex) {\n             // ignored\n-        }  \n+        }\n \n     }\n \n         for (int i = 0; i < n; i++) {\n             regression.addData(- ((double) i) / (n - 1), i);\n         }\n-   \n+\n         assertEquals(0.0, regression.getSignificance(), 1.0e-5);\n-        assertTrue(regression.getSlope() < 0.0);   \n+        assertTrue(regression.getSlope() < 0.0);\n     }\n \n     public void testRandom() throws Exception {\n         }\n \n         assertTrue( 0.0 < regression.getSignificance()\n-                    && regression.getSignificance() < 1.0);       \n-    }\n-    \n-    \n+                    && regression.getSignificance() < 1.0);\n+    }\n+\n+\n     // Jira MATH-85 = Bugzilla 39432\n     public void testSSENonNegative() {\n         double[] y = { 8915.102, 8919.302, 8923.502 };\n             reg.addData(x[i], y[i]);\n         }\n         assertTrue(reg.getSumSquaredErrors() >= 0.0);\n-    } \n-    \n+    }\n+\n     // Test remove X,Y (single observation)\n     public void testRemoveXY() throws Exception {\n         // Create regression with inference data then remove to test\n         assertEquals(\"std err intercept\", 0.286036932,\n                 regression.getInterceptStdErr(),1E-8);\n         assertEquals(\"significance\", 4.596e-07,\n-                regression.getSignificance(),1E-8);    \n-        assertEquals(\"slope conf interval half-width\", 0.0270713794287, \n+                regression.getSignificance(),1E-8);\n+        assertEquals(\"slope conf interval half-width\", 0.0270713794287,\n                 regression.getSlopeConfidenceInterval(),1E-8);\n      }\n-    \n-    \n+\n+\n     // Test remove single observation in array\n     public void testRemoveSingle() throws Exception {\n         // Create regression with inference data then remove to test\n         assertEquals(\"std err intercept\", 0.286036932,\n                 regression.getInterceptStdErr(),1E-8);\n         assertEquals(\"significance\", 4.596e-07,\n-                regression.getSignificance(),1E-8);    \n-        assertEquals(\"slope conf interval half-width\", 0.0270713794287, \n+                regression.getSignificance(),1E-8);\n+        assertEquals(\"slope conf interval half-width\", 0.0270713794287,\n                 regression.getSlopeConfidenceInterval(),1E-8);\n      }\n-    \n+\n     // Test remove multiple observations\n     public void testRemoveMultiple() throws Exception {\n         // Create regression with inference data then remove to test\n         assertEquals(\"std err intercept\", 0.286036932,\n                 regression.getInterceptStdErr(),1E-8);\n         assertEquals(\"significance\", 4.596e-07,\n-                regression.getSignificance(),1E-8);    \n-        assertEquals(\"slope conf interval half-width\", 0.0270713794287, \n+                regression.getSignificance(),1E-8);\n+        assertEquals(\"slope conf interval half-width\", 0.0270713794287,\n                 regression.getSlopeConfidenceInterval(),1E-8);\n      }\n-    \n+\n     // Remove observation when empty\n     public void testRemoveObsFromEmpty() {\n         SimpleRegression regression = new SimpleRegression();\n         regression.removeData(removeX, removeY);\n         assertEquals(regression.getN(), 0);\n     }\n-    \n+\n     // Remove single observation to empty\n     public void testRemoveObsFromSingle() {\n         SimpleRegression regression = new SimpleRegression();\n         regression.removeData(removeX, removeY);\n         assertEquals(regression.getN(), 0);\n     }\n-    \n+\n     // Remove multiple observations to empty\n     public void testRemoveMultipleToEmpty() {\n         SimpleRegression regression = new SimpleRegression();\n         regression.removeData(removeMultiple);\n         assertEquals(regression.getN(), 0);\n     }\n-    \n+\n     // Remove multiple observations past empty (i.e. size of array > n)\n     public void testRemoveMultiplePastEmpty() {\n         SimpleRegression regression = new SimpleRegression();\n--- a/src/test/java/org/apache/commons/math/transform/FastCosineTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastCosineTransformerTest.java\n  * <p>\n  * FCT algorithm is exact, the small tolerance number is used only\n  * to account for round-off errors.\n- * \n- * @version $Revision$ $Date$ \n+ *\n+ * @version $Revision$ $Date$\n  */\n public final class FastCosineTransformerTest extends TestCase {\n \n--- a/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n  * <p>\n  * FFT algorithm is exact, the small tolerance number is used only\n  * to account for round-off errors.\n- * \n- * @version $Revision$ $Date$ \n+ *\n+ * @version $Revision$ $Date$\n  */\n public final class FastFourierTransformerTest extends TestCase {\n \n             assertEquals(y2[i].getImaginary(), result[i].getImaginary(), tolerance);\n         }\n     }\n-    \n+\n     public void test2DData() {\n         FastFourierTransformer transformer = new FastFourierTransformer();\n         double tolerance = 1E-12;\n                 -1.5), new Complex(0, .5)}};\n         Complex[][] output = (Complex[][])transformer.mdfft(input, true);\n         Complex[][] output2 = (Complex[][])transformer.mdfft(output, false);\n-        \n+\n         assertEquals(input.length, output.length);\n         assertEquals(input.length, output2.length);\n         assertEquals(input[0].length, output[0].length);\n         assertEquals(input[0].length, output2[0].length);\n         assertEquals(input[1].length, output[1].length);\n         assertEquals(input[1].length, output2[1].length);\n-        \n+\n         for (int i = 0; i < input.length; i++) {\n             for (int j = 0; j < input[0].length; j++) {\n                 assertEquals(input[i][j].getImaginary(), output2[i][j].getImaginary(),\n             }\n         }\n     }\n-    \n+\n     /**\n      * Test of transformer for the sine function.\n      */\n--- a/src/test/java/org/apache/commons/math/transform/FastHadamardTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastHadamardTransformerTest.java\n         }\n \n     }\n-    \n+\n     private void checkInverseDoubleTransform(int[]x, int[] y) {\n         // Initiate the transformer\n         FastHadamardTransformer transformer = new FastHadamardTransformer();\n         }\n \n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/math/transform/FastSineTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastSineTransformerTest.java\n  * <p>\n  * FST algorithm is exact, the small tolerance number is used only\n  * to account for round-off errors.\n- * \n- * @version $Revision$ $Date$ \n+ *\n+ * @version $Revision$ $Date$\n  */\n public final class FastSineTransformerTest extends TestCase {\n \n--- a/src/test/java/org/apache/commons/math/util/ContinuedFractionTest.java\n+++ b/src/test/java/org/apache/commons/math/util/ContinuedFractionTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n     public void testGoldenRatio(){\n         ContinuedFraction cf = new ContinuedFraction() {\n-            \n+\n             @Override\n             public double getA(int n, double x) {\n                 return 1.0;\n                 return 1.0;\n             }\n         };\n-        \n+\n         try {\n             double gr = cf.evaluate(0.0, 10e-9);\n             assertEquals(1.61803399, gr, 10e-9);\n--- a/src/test/java/org/apache/commons/math/util/DefaultTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/util/DefaultTransformerTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  */\n public class DefaultTransformerTest extends TestCase {\n     /**\n-     * \n+     *\n      */\n     public void testTransformDouble() throws Exception {\n         double expected = 1.0;\n         DefaultTransformer t = new DefaultTransformer();\n         assertEquals(expected, t.transform(input), 1.0e-4);\n     }\n-    \n+\n     /**\n-     * \n+     *\n      */\n     public void testTransformNull(){\n         DefaultTransformer t = new DefaultTransformer();\n             // expected\n         }\n     }\n-    \n+\n     /**\n-     * \n+     *\n      */\n     public void testTransformInteger() throws Exception {\n         double expected = 1.0;\n         Integer input = Integer.valueOf(1);\n         DefaultTransformer t = new DefaultTransformer();\n         assertEquals(expected, t.transform(input), 1.0e-4);\n-    }        \n-    \n+    }\n+\n     /**\n-     * \n+     *\n      */\n     public void testTransformBigDecimal() throws Exception {\n         double expected = 1.0;\n         BigDecimal input = new BigDecimal(\"1.0\");\n         DefaultTransformer t = new DefaultTransformer();\n         assertEquals(expected, t.transform(input), 1.0e-4);\n-    }        \n-    \n+    }\n+\n     /**\n-     * \n+     *\n      */\n     public void testTransformString() throws Exception {\n         double expected = 1.0;\n         DefaultTransformer t = new DefaultTransformer();\n         assertEquals(expected, t.transform(input), 1.0e-4);\n     }\n-    \n+\n     /**\n-     * \n+     *\n      */\n     public void testTransformObject(){\n         Boolean input = Boolean.TRUE;\n--- a/src/test/java/org/apache/commons/math/util/DoubleArrayAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/util/DoubleArrayAbstractTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n /**\n  * This class contains test cases for the ExpandableDoubleArray.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public abstract class DoubleArrayAbstractTest extends TestCase {\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n       assertTrue(MathUtils.compareTo(152.308, 152.32, .011) < 0);\n       assertTrue(MathUtils.compareTo(152.33, 152.318, .011) > 0);\n     }\n-    \n+\n     public void testCosh() {\n         double x = 3.0;\n         double expected = 10.06766;\n         assertFalse(MathUtils.equals(153, 153.00000000000006, 1));\n         assertTrue(MathUtils.equals(153, 152.99999999999997, 1));\n         assertFalse(MathUtils.equals(153, 152.99999999999994, 1));\n-        \n+\n         assertTrue(MathUtils.equals(-128, -127.99999999999999, 1));\n         assertFalse(MathUtils.equals(-128, -127.99999999999997, 1));\n         assertTrue(MathUtils.equals(-128, -128.00000000000003, 1));\n \n         assertFalse(MathUtils.equals(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 100000));\n     }\n-    \n+\n     public void testArrayEquals() {\n         assertFalse(MathUtils.equals(new double[] { 1d }, null));\n         assertFalse(MathUtils.equals(null, new double[] { 1d }));\n             assertEquals(i + \"! \", factorial(i), MathUtils.factorialDouble(i), Double.MIN_VALUE);\n             assertEquals(i + \"! \", Math.log(factorial(i)), MathUtils.factorialLog(i), 10E-12);\n         }\n-        \n+\n         assertEquals(\"0\", 1, MathUtils.factorial(0));\n         assertEquals(\"0\", 1.0d, MathUtils.factorialDouble(0), 1E-14);\n         assertEquals(\"0\", 0.0d, MathUtils.factorialLog(0), 1E-14);\n         assertFalse(MathUtils.hash(new double[] { 1d }) ==\n                     MathUtils.hash(new double[] { 1d, 1d }));\n     }\n-    \n+\n     /**\n      * Make sure that permuted arrays do not hash to the same value.\n      */\n         double[] original = new double[10];\n         double[] permuted = new double[10];\n         RandomDataImpl random = new RandomDataImpl();\n-        \n+\n         // Generate 10 distinct random values\n         for (int i = 0; i < 10; i++) {\n             original[i] = random.nextUniform(i + 0.5, i + 0.75);\n         }\n-        \n+\n         // Generate a random permutation, making sure it is not the identity\n         boolean isIdentity = true;\n         do {\n                 permuted[i] = original[permutation[i]];\n             }\n         } while (isIdentity);\n-        \n+\n         // Verify that permuted array has different hash\n         assertFalse(MathUtils.hash(original) == MathUtils.hash(permuted));\n     }\n         } catch (ArithmeticException ex) {\n             // expected\n         }\n-        \n+\n         try {\n             // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n             MathUtils.lcm(Integer.MIN_VALUE, 1<<20);\n             }\n         }\n     }\n-    \n+\n     public void testNormalizeArray() {\n         double[] testValues1 = new double[] {1, 1, 2};\n         TestUtils.assertEquals(\n                 new double[] {.25, .25, .5},\n                 MathUtils.normalizeArray(testValues1, 1),\n                 Double.MIN_VALUE);\n-     \n+\n         double[] testValues2 = new double[] {-1, -1, 1};\n         TestUtils.assertEquals(\n                 new double[] {1, 1, -1},\n                 MathUtils.normalizeArray(testValues2, 1),\n                 Double.MIN_VALUE);\n-        \n+\n         // Ignore NaNs\n         double[] testValues3 = new double[] {-1, -1, Double.NaN, 1, Double.NaN};\n         TestUtils.assertEquals(\n                 new double[] {1, 1,Double.NaN, -1, Double.NaN},\n                 MathUtils.normalizeArray(testValues3, 1),\n                 Double.MIN_VALUE);\n-        \n+\n         // Zero sum -> ArithmeticException\n         double[] zeroSum = new double[] {-1, 1};\n         try {\n             MathUtils.normalizeArray(zeroSum, 1);\n             fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n-        \n+\n         // Infinite elements -> ArithmeticException\n         double[] hasInf = new double[] {1, 2, 1, Double.NEGATIVE_INFINITY};\n         try {\n             MathUtils.normalizeArray(hasInf, 1);\n             fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException ex) {}\n-        \n+\n         // Infinite target -> IllegalArgumentException\n         try {\n             MathUtils.normalizeArray(testValues1, Double.POSITIVE_INFINITY);\n             fail(\"expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {}\n-        \n+\n         // NaN target -> IllegalArgumentException\n         try {\n             MathUtils.normalizeArray(testValues1, Double.NaN);\n             fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {}  \n-        \n+        } catch (IllegalArgumentException ex) {}\n+\n     }\n \n     public void testRoundDouble() {\n         assertEquals(bigOne, MathUtils.pow(twentyOne, 103));\n         assertEquals(bigOne, MathUtils.pow(twentyOne, 103l));\n         assertEquals(bigOne, MathUtils.pow(twentyOne, BigInteger.valueOf(103l)));\n-        \n+\n     }\n \n     public void testL1DistanceDouble() {\n--- a/src/test/java/org/apache/commons/math/util/OpenIntToDoubleHashMapTest.java\n+++ b/src/test/java/org/apache/commons/math/util/OpenIntToDoubleHashMapTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n         }\n         return map;\n     }\n-    \n+\n     public void testPutAndGetWith0ExpectedSize() {\n         OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(0);\n         assertPutAndGet(map);\n     }\n-    \n+\n     public void testPutAndGetWithExpectedSize() {\n         OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap(500);\n         assertPutAndGet(map);\n     public void testGetAbsent() {\n         Map<Integer, Double> generated = generateAbsent();\n         OpenIntToDoubleHashMap map = createFromJavaMap();\n-        \n+\n         for (Map.Entry<Integer, Double> mapEntry : generated.entrySet())\n             assertTrue(Double.isNaN(map.get(mapEntry.getKey())));\n     }\n \n         OpenIntToDoubleHashMap map = createFromJavaMap();\n         int mapSize = map.size();\n-        \n+\n         for (Map.Entry<Integer, Double> mapEntry : generated.entrySet()) {\n             map.remove(mapEntry.getKey());\n             assertEquals(mapSize, map.size());\n         map.put(key3, value1);\n         assertEquals(value1, map.get(key3));\n         assertEquals(3, map.size());\n-        \n+\n         map.remove(key2);\n         double value2 = 2.0;\n         map.put(key3, value2);\n         assertEquals(value2, map.get(key3));\n         assertEquals(2, map.size());\n     }\n-    \n+\n     /**\n      * Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly\n      * different manner.\n         map.put(key2, value1);\n         assertEquals(2, map.size());\n         assertEquals(value1, map.get(key2));\n-        \n+\n         map.remove(key1);\n         double value2 = 2.0;\n         map.put(key2, value2);\n--- a/src/test/java/org/apache/commons/math/util/OpenIntToFieldTest.java\n+++ b/src/test/java/org/apache/commons/math/util/OpenIntToFieldTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n         Random r = new Random();\n         double dd=0;\n         for (int i = 0; i < 2000; ++i)\n-            dd = r.nextDouble(); \n+            dd = r.nextDouble();\n             try {\n                 map.put(r.nextInt(), new Fraction(dd));\n             } catch (FractionConversionException e) {\n         }\n         return map;\n     }\n-    \n+\n     public void testPutAndGetWith0ExpectedSize() {\n         OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field,0);\n         assertPutAndGet(map);\n     }\n-    \n+\n     public void testPutAndGetWithExpectedSize() {\n         OpenIntToFieldHashMap<Fraction> map = new OpenIntToFieldHashMap<Fraction>(field,500);\n         assertPutAndGet(map);\n     public void testGetAbsent() {\n         Map<Integer, Fraction> generated = generateAbsent();\n         OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n-        \n+\n         for (Map.Entry<Integer, Fraction> mapEntry : generated.entrySet())\n             assertTrue(field.getZero().equals(map.get(mapEntry.getKey())));\n     }\n \n         OpenIntToFieldHashMap<Fraction> map = createFromJavaMap(field);\n         int mapSize = map.size();\n-        \n+\n         for (Map.Entry<Integer, Fraction> mapEntry : generated.entrySet()) {\n             map.remove(mapEntry.getKey());\n             assertEquals(mapSize, map.size());\n         map.put(key3, value1);\n         assertEquals(value1, map.get(key3));\n         assertEquals(3, map.size());\n-        \n+\n         map.remove(key2);\n         Fraction value2 = new Fraction(2);\n         map.put(key3, value2);\n         assertEquals(value2, map.get(key3));\n         assertEquals(2, map.size());\n     }\n-    \n+\n     /**\n      * Similar to testPutKeysWithCollisions() but exercises the codepaths in a slightly\n      * different manner.\n         map.put(key2, value1);\n         assertEquals(2, map.size());\n         assertEquals(value1, map.get(key2));\n-        \n+\n         map.remove(key1);\n         Fraction value2 = new Fraction(2);\n         map.put(key2, value2);\n--- a/src/test/java/org/apache/commons/math/util/ResizableDoubleArrayTest.java\n+++ b/src/test/java/org/apache/commons/math/util/ResizableDoubleArrayTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n \n /**\n  * This class contains test cases for the ResizableDoubleArray.\n- * \n+ *\n  * @version $Revision$ $Date$\n  */\n public class ResizableDoubleArrayTest extends DoubleArrayAbstractTest {\n-    \n+\n     public ResizableDoubleArrayTest(String name) {\n         super( name );\n     }\n         da = null;\n         ra = null;\n     }\n-       \n+\n     @Override\n     protected void setUp() throws Exception {\n         da = new ResizableDoubleArray();\n         ra = new ResizableDoubleArray();\n     }\n-    \n+\n     public void testConstructors() {\n         float defaultExpansionFactor = 2.0f;\n         float defaultContractionCriteria = 2.5f;\n         int defaultMode = ResizableDoubleArray.MULTIPLICATIVE_MODE;\n-        \n+\n         ResizableDoubleArray testDa = new ResizableDoubleArray(2);\n         assertEquals(0, testDa.getNumElements());\n         assertEquals(2, testDa.getInternalLength());\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-        \n+\n         testDa = new ResizableDoubleArray(2, 2.0f);\n         assertEquals(0, testDa.getNumElements());\n         assertEquals(2, testDa.getInternalLength());\n         assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);\n         assertEquals(defaultContractionCriteria, testDa.getContractionCriteria(), 0);\n         assertEquals(defaultMode, testDa.getExpansionMode());\n-        \n+\n         try {\n             da = new ResizableDoubleArray(2, 0.5f);\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-        \n+\n         testDa = new ResizableDoubleArray(2, 3.0f);\n         assertEquals(3.0f, testDa.getExpansionFactor(), 0);\n         assertEquals(3.5f, testDa.getContractionCriteria(), 0);\n-        \n+\n         testDa = new ResizableDoubleArray(2, 2.0f, 3.0f);\n         assertEquals(0, testDa.getNumElements());\n         assertEquals(2, testDa.getInternalLength());\n         assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);\n         assertEquals(3.0f, testDa.getContractionCriteria(), 0);\n         assertEquals(defaultMode, testDa.getExpansionMode());\n-        \n+\n         try {\n             da = new ResizableDoubleArray(2, 2.0f, 1.5f);\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-        \n-        testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, \n+\n+        testDa = new ResizableDoubleArray(2, 2.0f, 3.0f,\n                 ResizableDoubleArray.ADDITIVE_MODE);\n         assertEquals(0, testDa.getNumElements());\n         assertEquals(2, testDa.getInternalLength());\n         assertEquals(defaultExpansionFactor, testDa.getExpansionFactor(), 0);\n         assertEquals(3.0f, testDa.getContractionCriteria(), 0);\n-        assertEquals(ResizableDoubleArray.ADDITIVE_MODE, \n+        assertEquals(ResizableDoubleArray.ADDITIVE_MODE,\n                 testDa.getExpansionMode());\n-        \n+\n         try {\n             da = new ResizableDoubleArray(2, 2.0f, 2.5f, -1);\n             fail(\"Expecting IllegalArgumentException\");\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-        \n+\n         // Copy constructor\n-        testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, \n+        testDa = new ResizableDoubleArray(2, 2.0f, 3.0f,\n                 ResizableDoubleArray.ADDITIVE_MODE);\n         testDa.addElement(2.0);\n         testDa.addElement(3.2);\n         ResizableDoubleArray copyDa = new ResizableDoubleArray(testDa);\n         assertEquals(copyDa, testDa);\n-        assertEquals(testDa, copyDa);   \n-    }\n-    \n-    \n+        assertEquals(testDa, copyDa);\n+    }\n+\n+\n     public void testSetElementArbitraryExpansion() {\n-        \n-        // MULTIPLICATIVE_MODE \n+\n+        // MULTIPLICATIVE_MODE\n         da.addElement(2.0);\n         da.addElement(4.0);\n         da.addElement(6.0);\n         da.setElement(1, 3.0);\n-        \n+\n         // Expand the array arbitrarily to 1000 items\n         da.setElement(1000, 3.4);\n-        \n-        assertEquals( \"The number of elements should now be 1001, it isn't\", \n+\n+        assertEquals( \"The number of elements should now be 1001, it isn't\",\n                 da.getNumElements(), 1001);\n-        \n+\n         assertEquals( \"Uninitialized Elements are default value of 0.0, index 766 wasn't\", 0.0,\n                 da.getElement( 760 ), Double.MIN_VALUE );\n-        \n-        assertEquals( \"The 1000th index should be 3.4, it isn't\", 3.4, da.getElement(1000), \n+\n+        assertEquals( \"The 1000th index should be 3.4, it isn't\", 3.4, da.getElement(1000),\n                 Double.MIN_VALUE );\n-        assertEquals( \"The 0th index should be 2.0, it isn't\", 2.0, da.getElement(0), \n-                Double.MIN_VALUE); \n-        \n+        assertEquals( \"The 0th index should be 2.0, it isn't\", 2.0, da.getElement(0),\n+                Double.MIN_VALUE);\n+\n         // Make sure numElements and expansion work correctly for expansion boundary cases\n         da.clear();\n         da.addElement(2.0);\n         da.setElement(9, 10.0);\n         assertEquals(11, ((ResizableDoubleArray) da).getInternalLength());\n         assertEquals(11, da.getNumElements());\n-        \n+\n         try {\n             da.setElement(-2, 3);\n             fail(\"Expecting ArrayIndexOutOfBoundsException for negative index\");\n         } catch (ArrayIndexOutOfBoundsException ex) {\n             // expected\n         }\n-        \n+\n         // ADDITIVE_MODE\n-        \n-        ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, \n+\n+        ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 3.0f,\n                 ResizableDoubleArray.ADDITIVE_MODE);\n         assertEquals(2, testDa.getInternalLength());\n         testDa.addElement(1d);\n         testDa.addElement(1d);\n         assertEquals(2, testDa.getInternalLength());\n         testDa.addElement(1d);\n-        assertEquals(4, testDa.getInternalLength());         \n+        assertEquals(4, testDa.getInternalLength());\n     }\n \n     @Override\n     @Override\n     public void testAddElementRolling() {\n         super.testAddElementRolling();\n-        \n+\n         // MULTIPLICATIVE_MODE\n         da.clear();\n         da.addElement(1);\n         da.addElementRolling(6);\n         assertEquals(4, da.getElement(0), 0);\n         assertEquals(5, da.getElement(1), 0);\n-        assertEquals(6, da.getElement(2), 0);   \n-        \n+        assertEquals(6, da.getElement(2), 0);\n+\n         // ADDITIVE_MODE  (x's are occupied storage locations, 0's are open)\n-        ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 2.5f, \n+        ResizableDoubleArray testDa = new ResizableDoubleArray(2, 2.0f, 2.5f,\n                 ResizableDoubleArray.ADDITIVE_MODE);\n         assertEquals(2, testDa.getInternalLength());\n         testDa.addElement(1d); // x,0\n         testDa.addElement(3d); // x,x,x,0 -- expanded\n         assertEquals(1d, testDa.getElement(0), 0);\n         assertEquals(2d, testDa.getElement(1), 0);\n-        assertEquals(3d, testDa.getElement(2), 0);   \n-        assertEquals(4, testDa.getInternalLength());  // x,x,x,0 \n+        assertEquals(3d, testDa.getElement(2), 0);\n+        assertEquals(4, testDa.getInternalLength());  // x,x,x,0\n         assertEquals(3, testDa.getNumElements());\n         testDa.addElementRolling(4d);\n         assertEquals(2d, testDa.getElement(0), 0);\n         assertEquals(3d, testDa.getElement(1), 0);\n-        assertEquals(4d, testDa.getElement(2), 0);   \n+        assertEquals(4d, testDa.getElement(2), 0);\n         assertEquals(4, testDa.getInternalLength());  // 0,x,x,x\n         assertEquals(3, testDa.getNumElements());\n         testDa.addElementRolling(5d);   // 0,0,x,x,x,0 -- time to contract\n         assertEquals(3d, testDa.getElement(0), 0);\n         assertEquals(4d, testDa.getElement(1), 0);\n-        assertEquals(5d, testDa.getElement(2), 0);   \n-        assertEquals(4, testDa.getInternalLength());  // contracted -- x,x,x,0     \n+        assertEquals(5d, testDa.getElement(2), 0);\n+        assertEquals(4, testDa.getInternalLength());  // contracted -- x,x,x,0\n         assertEquals(3, testDa.getNumElements());\n         try {\n             testDa.getElement(4);\n             fail(\"Expecting ArrayIndexOutOfBoundsException\");\n         } catch (ArrayIndexOutOfBoundsException ex) {\n             // expected\n-        }  \n+        }\n         try {\n             testDa.getElement(-1);\n             fail(\"Expecting ArrayIndexOutOfBoundsException\");\n             // expected\n         }\n     }\n-    \n+\n     public void testSetNumberOfElements() {\n         da.addElement( 1.0 );\n         da.addElement( 1.0 );\n         da.addElement( 1.0 );\n         da.addElement( 1.0 );\n         assertEquals( \"Number of elements should equal 6\", da.getNumElements(), 6);\n-        \n+\n         ((ResizableDoubleArray) da).setNumElements( 3 );\n         assertEquals( \"Number of elements should equal 3\", da.getNumElements(), 3);\n-        \n+\n         try {\n             ((ResizableDoubleArray) da).setNumElements( -3 );\n             fail( \"Setting number of elements to negative should've thrown an exception\");\n         } catch( IllegalArgumentException iae ) {\n         }\n-        \n+\n         ((ResizableDoubleArray) da).setNumElements(1024);\n         assertEquals( \"Number of elements should now be 1024\", da.getNumElements(), 1024);\n         assertEquals( \"Element 453 should be a default double\", da.getElement( 453 ), 0.0, Double.MIN_VALUE);\n-        \n-    }\n-    \n+\n+    }\n+\n     public void testWithInitialCapacity() {\n-        \n+\n         ResizableDoubleArray eDA2 = new ResizableDoubleArray(2);\n         assertEquals(\"Initial number of elements should be 0\", 0, eDA2.getNumElements());\n-        \n+\n         RandomData randomData = new RandomDataImpl();\n         int iterations = randomData.nextInt(100, 1000);\n-        \n+\n         for( int i = 0; i < iterations; i++) {\n             eDA2.addElement( i );\n         }\n-        \n+\n         assertEquals(\"Number of elements should be equal to \" + iterations, iterations, eDA2.getNumElements());\n-        \n+\n         eDA2.addElement( 2.0 );\n-        \n+\n         assertEquals(\"Number of elements should be equals to \" + (iterations +1),\n                 iterations + 1 , eDA2.getNumElements() );\n     }\n-    \n+\n     public void testWithInitialCapacityAndExpansionFactor() {\n-        \n+\n         ResizableDoubleArray eDA3 = new ResizableDoubleArray(3, 3.0f, 3.5f);\n         assertEquals(\"Initial number of elements should be 0\", 0, eDA3.getNumElements() );\n-        \n+\n         RandomData randomData = new RandomDataImpl();\n         int iterations = randomData.nextInt(100, 3000);\n-        \n+\n         for( int i = 0; i < iterations; i++) {\n             eDA3.addElement( i );\n         }\n-        \n+\n         assertEquals(\"Number of elements should be equal to \" + iterations, iterations,eDA3.getNumElements());\n-        \n+\n         eDA3.addElement( 2.0 );\n-        \n+\n         assertEquals(\"Number of elements should be equals to \" + (iterations +1),\n                 iterations +1, eDA3.getNumElements() );\n-        \n+\n         assertEquals(\"Expansion factor should equal 3.0\", 3.0f, eDA3.getExpansionFactor(), Double.MIN_VALUE);\n     }\n-    \n+\n     public void testDiscard() {\n         da.addElement(2.0);\n         da.addElement(2.0);\n         da.addElement(2.0);\n         da.addElement(2.0);\n         assertEquals( \"Number of elements should be 11\", 11, da.getNumElements());\n-        \n+\n         ((ResizableDoubleArray)da).discardFrontElements(5);\n         assertEquals( \"Number of elements should be 6\", 6, da.getNumElements());\n \n \n         ((ResizableDoubleArray)da).discardMostRecentElements(2);\n         assertEquals( \"Number of elements should be 8\", 8, da.getNumElements());\n-        \n+\n         try {\n             ((ResizableDoubleArray)da).discardFrontElements(-1);\n             fail( \"Trying to discard a negative number of element is not allowed\");\n     }\n \n     public void testSubstitute() {\n-    \n+\n         da.addElement(2.0);\n         da.addElement(2.0);\n         da.addElement(2.0);\n         da.addElement(2.0);\n         da.addElement(2.0);\n         assertEquals( \"Number of elements should be 11\", 11, da.getNumElements());\n-        \n+\n         ((ResizableDoubleArray)da).substituteMostRecentElement(24);\n \n         assertEquals( \"Number of elements should be 11\", 11, da.getNumElements());\n         assertEquals( \"Number of elements should be 1\", 1, da.getNumElements());\n \n     }\n-    \n+\n     public void testMutators() {\n         ((ResizableDoubleArray)da).setContractionCriteria(10f);\n         assertEquals(10f, ((ResizableDoubleArray)da).getContractionCriteria(), 0);\n-        ((ResizableDoubleArray)da).setExpansionFactor(8f);  \n+        ((ResizableDoubleArray)da).setExpansionFactor(8f);\n         assertEquals(8f, ((ResizableDoubleArray)da).getExpansionFactor(), 0);\n         try {\n             ((ResizableDoubleArray)da).setExpansionFactor(11f);  // greater than contractionCriteria\n         }\n         ((ResizableDoubleArray)da).setExpansionMode(\n                 ResizableDoubleArray.ADDITIVE_MODE);\n-        assertEquals(ResizableDoubleArray.ADDITIVE_MODE, \n+        assertEquals(ResizableDoubleArray.ADDITIVE_MODE,\n                 ((ResizableDoubleArray)da).getExpansionMode());\n         try {\n             ((ResizableDoubleArray)da).setExpansionMode(-1);\n             // expected\n         }\n     }\n-    \n+\n     public void testEqualsAndHashCode() throws Exception {\n-        \n+\n         // Wrong type\n         ResizableDoubleArray first = new ResizableDoubleArray();\n         Double other = new Double(2);\n         assertFalse(first.equals(other));\n-        \n+\n         // Null\n         other = null;\n         assertFalse(first.equals(other));\n-        \n+\n         // Reflexive\n         assertTrue(first.equals(first));\n-        \n+\n         // Argumentless constructor\n         ResizableDoubleArray second = new ResizableDoubleArray();\n         verifyEquality(first, second);\n-        \n+\n         // Equals iff same data, same properties\n         ResizableDoubleArray third = new ResizableDoubleArray(3, 2.0f, 2.0f);\n         verifyInequality(third, first);\n         fourth.addElement(4.2);\n         fourth.addElement(4.3);\n         verifyEquality(third, fourth);\n-        \n+\n         // expand\n         fourth.addElement(4.4);\n         verifyInequality(third, fourth);\n         fourth.addElementRolling(4.5);\n         third.addElementRolling(4.5);\n         verifyEquality(third, fourth);\n-        \n+\n         // discard\n         third.discardFrontElements(1);\n         verifyInequality(third, fourth);\n         fourth.discardFrontElements(1);\n         verifyEquality(third, fourth);\n-        \n+\n         // discard recent\n         third.discardMostRecentElements(2);\n         fourth.discardMostRecentElements(2);\n         verifyEquality(third, fourth);\n-        \n+\n         // wrong order\n         third.addElement(18);\n         fourth.addElement(17);\n         third.addElement(17);\n         fourth.addElement(18);\n         verifyInequality(third, fourth);\n-        \n+\n         // copy\n         ResizableDoubleArray.copy(fourth, fifth);\n         verifyEquality(fourth, fifth);\n-        \n+\n         // Copy constructor\n         verifyEquality(fourth, new ResizableDoubleArray(fourth));\n-        \n+\n         // Instance copy\n-        verifyEquality(fourth, fourth.copy());   \n-             \n-    }\n-    \n+        verifyEquality(fourth, fourth.copy());\n+\n+    }\n+\n     private void verifyEquality(ResizableDoubleArray a, ResizableDoubleArray b) {\n         assertTrue(b.equals(a));\n         assertTrue(a.equals(b));\n-        assertEquals(a.hashCode(), b.hashCode());    \n-    }\n-    \n+        assertEquals(a.hashCode(), b.hashCode());\n+    }\n+\n     private void verifyInequality(ResizableDoubleArray a, ResizableDoubleArray b) {\n         assertFalse(b.equals(a));\n         assertFalse(a.equals(b));\n         assertFalse(a.hashCode() == b.hashCode());\n     }\n-    \n+\n }\n--- a/src/test/java/org/apache/commons/math/util/TestBean.java\n+++ b/src/test/java/org/apache/commons/math/util/TestBean.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n     private String y = \"1.0\";\n \n     /**\n-     * \n+     *\n      */\n     public Double getX() {\n         return x;\n     }\n \n     /**\n-     * \n+     *\n      */\n     public String getY() {\n         return y;\n     }\n \n     /**\n-     * \n+     *\n      */\n     public void setX(Double double1) {\n         x = double1;\n     }\n \n     /**\n-     * \n+     *\n      */\n     public void setY(String string) {\n         y = string;\n     }\n-    \n+\n     /**\n-     * \n+     *\n      */\n     public Double getZ() {\n         throw new MathRuntimeException(\"?\");\n     }\n \n     /**\n-     * \n+     *\n      */\n     public void setZ(Double double1) {\n     }\n--- a/src/test/java/org/apache/commons/math/util/TransformerMapTest.java\n+++ b/src/test/java/org/apache/commons/math/util/TransformerMapTest.java\n  * The ASF licenses this file to You under the Apache License, Version 2.0\n  * (the \"License\"); you may not use this file except in compliance with\n  * the License.  You may obtain a copy of the License at\n- * \n+ *\n  *      http://www.apache.org/licenses/LICENSE-2.0\n- * \n+ *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  */\n public class TransformerMapTest extends TestCase {\n     /**\n-     * \n+     *\n      */\n     public void testPutTransformer(){\n         NumberTransformer expected = new DefaultTransformer();\n-        \n+\n         TransformerMap map = new TransformerMap();\n         map.putTransformer(TransformerMapTest.class, expected);\n         assertEquals(expected, map.getTransformer(TransformerMapTest.class));\n     }\n-    \n+\n     /**\n-     * \n+     *\n      */\n     public void testContainsClass(){\n         NumberTransformer expected = new DefaultTransformer();\n         map.putTransformer(TransformerMapTest.class, expected);\n         assertTrue(map.containsClass(TransformerMapTest.class));\n     }\n-    \n+\n     /**\n-     * \n+     *\n      */\n     public void testContainsTransformer(){\n         NumberTransformer expected = new DefaultTransformer();\n     }\n \n     /**\n-     * \n+     *\n      */\n     public void testRemoveTransformer(){\n         NumberTransformer expected = new DefaultTransformer();\n-        \n+\n         TransformerMap map = new TransformerMap();\n         map.putTransformer(TransformerMapTest.class, expected);\n         assertTrue(map.containsClass(TransformerMapTest.class));\n     }\n \n     /**\n-     * \n+     *\n      */\n     public void testClear(){\n         NumberTransformer expected = new DefaultTransformer();\n-        \n+\n         TransformerMap map = new TransformerMap();\n         map.putTransformer(TransformerMapTest.class, expected);\n         assertTrue(map.containsClass(TransformerMapTest.class));\n         map.clear();\n         assertFalse(map.containsClass(TransformerMapTest.class));\n     }\n-    \n+\n     /**\n-     * \n+     *\n      */\n     public void testClasses(){\n         NumberTransformer expected = new DefaultTransformer();\n         map.putTransformer(TransformerMapTest.class, expected);\n         assertTrue(map.classes().contains(TransformerMapTest.class));\n     }\n-    \n+\n     /**\n-     * \n+     *\n      */\n     public void testTransformers(){\n         NumberTransformer expected = new DefaultTransformer();", "timestamp": 1252172208, "metainfo": ""}