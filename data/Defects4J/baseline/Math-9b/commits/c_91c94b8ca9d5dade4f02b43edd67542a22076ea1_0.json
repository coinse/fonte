{"sha": "91c94b8ca9d5dade4f02b43edd67542a22076ea1", "log": "Trailing spaces.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n  * @since 2.0\n  */\n public class SimplexSolver extends AbstractLinearOptimizer {\n-    \n+\n     /** Default amount of error to accept for algorithm convergence. */\n     private static final double DEFAULT_EPSILON = 1.0e-6;\n-     \n+\n     /** Amount of error to accept for algorithm convergence. */\n     protected final double epsilon;\n \n     /**\n      * Build a simplex solver with a specified accepted amount of error\n      * @param epsilon the amount of error to accept for algorithm convergence\n-     * @param maxUlps amount of error to accept in floating point comparisons \n+     * @param maxUlps amount of error to accept in floating point comparisons\n      */\n     public SimplexSolver(final double epsilon, final int maxUlps) {\n         this.epsilon = epsilon;\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            \n+\n             if (MathUtils.compareTo(entry, 0d, maxUlps) > 0) {\n                 final double ratio = rhs / entry;\n                 final int cmp = MathUtils.compareTo(ratio, minRatio, maxUlps);\n     @Override\n     public RealPointValuePair doOptimize() throws OptimizationException {\n         final SimplexTableau tableau =\n-            new SimplexTableau(function, linearConstraints, goal, nonNegative, \n+            new SimplexTableau(function, linearConstraints, goal, nonNegative,\n                                epsilon, maxUlps);\n \n         solvePhase1(tableau);\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n                    final double epsilon) {\n         this(f, constraints, goalType, restrictToNonNegative, epsilon, DEFAULT_ULPS);\n     }\n-    \n+\n     /**\n      * Build a tableau for a linear problem.\n      * @param f linear objective function\n      * or {@link GoalType#MINIMIZE}\n      * @param restrictToNonNegative whether to restrict the variables to non-negative values\n      * @param epsilon amount of error to accept when checking for optimality\n-     * @param maxUlps amount of error to accept in floating point comparisons \n+     * @param maxUlps amount of error to accept in floating point comparisons\n      */\n     SimplexTableau(final LinearObjectiveFunction f,\n                    final Collection<LinearConstraint> constraints,\n       throws ClassNotFoundException, IOException {\n         ois.defaultReadObject();\n         MatrixUtils.deserializeRealMatrix(this, \"tableau\", ois);\n-    }    \n+    }\n }\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n \n         // create the initial clusters\n         List<Cluster<T>> clusters = chooseInitialCenters(points, k, random);\n-        \n+\n         // create an array containing the latest assignment of a point to a cluster\n         // no need to initialize the array, as it will be filled with the first assignment\n         int[] assignments = new int[points.size()];\n             }\n             int changes = assignPointsToClusters(newClusters, points, assignments);\n             clusters = newClusters;\n-            \n+\n             // if there were no more changes in the point-to-cluster assignment\n             // and there are no empty clusters left, return the current clusters\n             if (changes == 0 && !emptyCluster) {\n      * @return the number of points assigned to different clusters as the iteration before\n      */\n     private static <T extends Clusterable<T>> int\n-        assignPointsToClusters(final List<Cluster<T>> clusters, final Collection<T> points, \n+        assignPointsToClusters(final List<Cluster<T>> clusters, final Collection<T> points,\n                                final int[] assignments) {\n         int assignedDifferently = 0;\n         int pointIndex = 0;\n             if (clusterIndex != assignments[pointIndex]) {\n                 assignedDifferently++;\n             }\n-            \n+\n             Cluster<T> cluster = clusters.get(clusterIndex);\n             cluster.addPoint(p);\n             assignments[pointIndex++] = clusterIndex;\n         }\n-        \n+\n         return assignedDifferently;\n     }\n ", "timestamp": 1302607742, "metainfo": ""}