{"sha": "a4a9dbb5d12b4264de88b929202627097f55872a", "log": "MATH-708. New utility method.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/Precision.java\n+++ b/src/main/java/org/apache/commons/math/util/Precision.java\n         }\n         return unscaled;\n     }\n+\n+\n+    /**\n+     * Computes a number {@code delta} close to {@code originalDelta} with\n+     * the property that <pre><code>\n+     *   x + delta - x\n+     * </code></pre>\n+     * is exactly machine-representable.\n+     * This is useful when computing numerical derivatives, in order to reduce\n+     * roundoff errors.\n+     *\n+     * @param x Value.\n+     * @param originalDelta Offset value.\n+     * @return a number {@code delta} so that {@code x + delta} and {@code x}\n+     * differ by a representable floating number.\n+     */\n+    public static double representableDelta(double x,\n+                                            double originalDelta) {\n+        return x + originalDelta - x;\n+    }\n }\n--- a/src/test/java/org/apache/commons/math/util/PrecisionTest.java\n+++ b/src/test/java/org/apache/commons/math/util/PrecisionTest.java\n         Assert.assertEquals(Float.POSITIVE_INFINITY, Precision.round(Float.POSITIVE_INFINITY, 2), 0.0f);\n         Assert.assertEquals(Float.NEGATIVE_INFINITY, Precision.round(Float.NEGATIVE_INFINITY, 2), 0.0f);\n     }\n+\n+\n+    @Test\n+    public void testRepresentableDelta() {\n+        int totalCount = 0;\n+        int nonRepresentableCount = 0;\n+        final double x = 100;\n+        final int numTrials = 10000;\n+        for (int i = 0; i < numTrials; i++) {\n+            final double originalDelta = Math.random();\n+            final double delta = Precision.representableDelta(x, originalDelta);\n+            if (delta != originalDelta) {\n+                ++nonRepresentableCount;\n+            }\n+        }\n+\n+        Assert.assertTrue(nonRepresentableCount / (double) numTrials > 0.9);\n+    }\n }", "timestamp": 1321540390, "metainfo": ""}