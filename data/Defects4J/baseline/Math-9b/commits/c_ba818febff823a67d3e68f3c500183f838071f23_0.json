{"sha": "ba818febff823a67d3e68f3c500183f838071f23", "log": "Prevent ODE integration to be stuck at initial point when it is restarted after an event has stopped the previous integration JIRA: MATH-421  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\n             if (! initialized) {\n \n                 // initialize the events states\n-                final double t0 = interpolator.getPreviousTime();\n-                interpolator.setInterpolatedTime(t0);\n-                final double [] y = interpolator.getInterpolatedState();\n                 for (EventState state : states) {\n-                    state.reinitializeBegin(t0, y);\n+                    state.reinitializeBegin(interpolator);\n                 }\n \n                 initialized = true;\n--- a/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n     }\n \n     /** Reinitialize the beginning of the step.\n-     * @param tStart value of the independent <i>time</i> variable at the\n-     * beginning of the step\n-     * @param yStart array containing the current value of the state vector\n-     * at the beginning of the step\n+     * @param interpolator valid for the current step\n      * @exception EventException if the event handler\n      * value cannot be evaluated at the beginning of the step\n      */\n-    public void reinitializeBegin(final double tStart, final double[] yStart)\n+    public void reinitializeBegin(final StepInterpolator interpolator)\n         throws EventException {\n-        t0 = tStart;\n-        g0 = handler.g(tStart, yStart);\n-        g0Positive = g0 >= 0;\n+        try {\n+            // excerpt from MATH-421 issue:\n+            // If an ODE solver is setup with an EventHandler that return STOP\n+            // when the even is triggered, the integrator stops (which is exactly\n+            // the expected behavior). If however the user want to restart the\n+            // solver from the final state reached at the event with the same\n+            // configuration (expecting the event to be triggered again at a\n+            // later time), then the integrator may fail to start. It can get stuck\n+            // at the previous event.\n+\n+            // The use case for the bug MATH-421 is fairly general, so events occurring\n+            // less than epsilon after the solver start in the first step should be ignored,\n+            // where epsilon is the convergence threshold of the event. The sign of the g\n+            // function should be evaluated after this initial ignore zone, not exactly at\n+            // beginning (if there are no event at the very beginning g(t0) and g(t0+epsilon)\n+            // have the same sign, so this does not hurt ; if there is an event at the very\n+            // beginning, g(t0) and g(t0+epsilon) have opposite signs and we want to start\n+            // with the second one. Of course, the sign of epsilon depend on the integration\n+            // direction (forward or backward). This explains what is done below.\n+\n+            final double ignoreZone = interpolator.isForward() ? getConvergence() : -getConvergence();\n+            t0 = interpolator.getPreviousTime() + ignoreZone;\n+            interpolator.setInterpolatedTime(t0);\n+            g0 = handler.g(t0, interpolator.getInterpolatedState());\n+            if (g0 == 0) {\n+                // extremely rare case: there is a zero EXACTLY at end of ignore zone\n+                // we will use the opposite of sign at step beginning to force ignoring this zero\n+                final double tStart = interpolator.getPreviousTime();\n+                interpolator.setInterpolatedTime(tStart);\n+                g0Positive = handler.g(tStart, interpolator.getInterpolatedState()) <= 0;\n+            } else {\n+                g0Positive = g0 >= 0;\n+            }\n+\n+        } catch (DerivativeException de) {\n+            throw new EventException(de);\n+        }\n     }\n \n     /** Evaluate the impact of the proposed step on the event handler.\n--- a/src/test/java/org/apache/commons/math/ode/events/EventStateTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/events/EventStateTest.java\n         final double tolerance = 0.1;\n         EventState es = new EventState(closeEventsGenerator, 1.5 * gap, tolerance, 10);\n \n-        double t0 = r1 - 0.5 * gap;\n-        es.reinitializeBegin(t0, new double[0]);\n         AbstractStepInterpolator interpolator =\n             new DummyStepInterpolator(new double[0], new double[0], true);\n-        interpolator.storeTime(t0);\n+        interpolator.storeTime(r1 - 2.5 * gap);\n+        interpolator.shift();\n+        interpolator.storeTime(r1 - 1.5 * gap);\n+        es.reinitializeBegin(interpolator);\n+\n+        interpolator.shift();\n+        interpolator.storeTime(r1 - 0.5 * gap);\n+        Assert.assertFalse(es.evaluateStep(interpolator));\n \n         interpolator.shift();\n         interpolator.storeTime(0.5 * (r1 + r2));", "timestamp": 1285789824, "metainfo": ""}