{"sha": "bfd118d14d97383f36805beb7561f8bc3cb849db", "log": "Fixed ignored scale in penalty function adapter for direct optimizers.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultivariateFunctionPenaltyAdapter.java\n \n     /** Compute the underlying function value from an unbounded point.\n      * <p>\n-     * This method simply bounds the unbounded point using the mappings\n-     * set up at construction and calls the underlying function using\n-     * the bounded point.\n+     * This method simply returns the value of the underlying function\n+     * if the unbounded point already fulfills the bounds, and compute\n+     * a replacement value using the offset and scale if bounds are\n+     * violated, without calling the function at all.\n      * </p>\n-     * @see #unboundedToBounded(double[])\n+     * @return either underlying function value or penalty function value\n      */\n     public double value(double[] point) {\n \n                 for (int j = i; j < scale.length; ++j) {\n                     final double overshoot;\n                     if (point[j] < lower[j]) {\n-                        overshoot = lower[j] - point[j];\n+                        overshoot = scale[j] * (lower[j] - point[j]);\n                     } else if (point[j] > upper[j]) {\n-                        overshoot = point[j] - upper[j];\n+                        overshoot = scale[j] * (point[j] - upper[j]);\n                     } else {\n                         overshoot = 0;\n                     }", "timestamp": 1322595340, "metainfo": ""}