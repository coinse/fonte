{"sha": "dda2b4b8b6a6571de05d2c6cee9cc99e61815bb4", "log": "applied Cyril Briquet's patch (with slight changes) to improve FastFourierTransform efficiency JIRA: MATH-216  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n    // org.apache.commons.math.transform.FastFourierTransformer\n    { \"cannot compute 0-th root of unity, indefinite result\",\n      \"impossible de calculer la racine z\\u00e9roi\\u00e8me de l''unit\\u00e9, r\\u00e9sultat ind\\u00e9fini\" },\n+   { \"roots of unity have not been computed yet\",\n+     \"les racines de l''unit\\u00e9 n''ont pas encore \\u00e9t\\u00e9 calcul\\u00e9es\" },\n+   { \"out of range root of unity index {0} (must be in [{1};{2}])\",\n+     \"index de racine de l''unit\\u00e9 hors domaine (devrait \\u00eatre dans [{1}; {2}])\" },\n    { \"number of sample is not positive: {0}\",\n      \"le nombre d''\\u00e9chantillons n''est pas positif : {0}\" },\n    { \"{0} is not a power of 2, consider padding for fix\",\n--- a/src/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+++ b/src/java/org/apache/commons/math/transform/FastFourierTransformer.java\n     /** Serializable version identifier. */\n     static final long serialVersionUID = 5138259215438106000L;\n \n-    /** array of the roots of unity */\n-    private Complex omega[] = new Complex[0];\n-\n-    /**\n-     * |omegaCount| is the length of lasted computed omega[]. omegaCount\n-     * is positive for forward transform and negative for inverse transform.\n-     */\n-    private int omegaCount = 0;\n+    /** roots of unity */\n+    private RootsOfUnity roots = new RootsOfUnity();\n \n     /**\n      * Construct a default transformer.\n      */\n     public Complex[] transform(Complex f[])\n         throws IllegalArgumentException {\n-        computeOmega(f.length);\n+        roots.computeOmega(f.length);\n         return fft(f);\n     }\n \n     public Complex[] transform2(Complex f[])\n         throws IllegalArgumentException {\n \n-        computeOmega(f.length);\n+        roots.computeOmega(f.length);\n         double scaling_coefficient = 1.0 / Math.sqrt(f.length);\n         return scaleArray(fft(f), scaling_coefficient);\n     }\n     public Complex[] inversetransform(Complex f[])\n         throws IllegalArgumentException {\n \n-        computeOmega(-f.length);    // pass negative argument\n+        roots.computeOmega(-f.length);    // pass negative argument\n         double scaling_coefficient = 1.0 / f.length;\n         return scaleArray(fft(f), scaling_coefficient);\n     }\n     public Complex[] inversetransform2(Complex f[])\n         throws IllegalArgumentException {\n \n-        computeOmega(-f.length);    // pass negative argument\n+        roots.computeOmega(-f.length);    // pass negative argument\n         double scaling_coefficient = 1.0 / Math.sqrt(f.length);\n         return scaleArray(fft(f), scaling_coefficient);\n     }\n         for (int i = 0; i < N; i++) {\n             c[i] = new Complex(f[2*i], f[2*i+1]);\n         }\n-        computeOmega(isInverse ? -N : N);\n+        roots.computeOmega(isInverse ? -N : N);\n         Complex z[] = fft(c);\n \n         // reconstruct the FFT result for the original array\n-        computeOmega(isInverse ? -2*N : 2*N);\n+        roots.computeOmega(isInverse ? -2*N : 2*N);\n         F[0] = new Complex(2 * (z[0].getReal() + z[0].getImaginary()), 0.0);\n         F[N] = new Complex(2 * (z[0].getReal() - z[0].getImaginary()), 0.0);\n         for (int i = 1; i < N; i++) {\n             Complex A = z[N-i].conjugate();\n             Complex B = z[i].add(A);\n             Complex C = z[i].subtract(A);\n-            Complex D = omega[i].multiply(Complex.I);\n+            //Complex D = roots.getOmega(i).multiply(Complex.I);\n+            Complex D = new Complex(-roots.getOmegaImaginary(i),\n+                                    roots.getOmegaReal(i));\n             F[i] = B.subtract(C.multiply(D));\n             F[2*N-i] = F[i].conjugate();\n         }\n             f[i] = A.add(B);\n             f[i+2] = A.subtract(B);\n             // omegaCount indicates forward or inverse transform\n-            f[i+1] = omegaCount < 0 ? E : F;\n-            f[i+3] = omegaCount > 0 ? E : F;\n+            f[i+1] = roots.isForward() ? F : E;\n+            f[i+3] = roots.isForward() ? E : F;\n         }\n \n         // iterations from bottom to top take O(N*logN) time\n             m = N / (i<<1);\n             for (j = 0; j < N; j += i<<1) {\n                 for (k = 0; k < i; k++) {\n-                    z = f[i+j+k].multiply(omega[k*m]);\n+                    //z = f[i+j+k].multiply(roots.getOmega(k*m));\n+                    final int k_times_m = k*m;\n+                    final double omega_k_times_m_real = roots.getOmegaReal(k_times_m);\n+                    final double omega_k_times_m_imaginary = roots.getOmegaImaginary(k_times_m);\n+                    //z = f[i+j+k].multiply(omega[k*m]);\n+                    z = new Complex(\n+                        f[i+j+k].getReal() * omega_k_times_m_real -\n+                        f[i+j+k].getImaginary() * omega_k_times_m_imaginary,\n+                        f[i+j+k].getReal() * omega_k_times_m_imaginary +\n+                        f[i+j+k].getImaginary() * omega_k_times_m_real);\n+                  \n                     f[i+j+k] = f[j+k].subtract(z);\n                     f[j+k] = f[j+k].add(z);\n                 }\n             }\n         }\n         return f;\n-    }\n-\n-    /**\n-     * Calculate the n-th roots of unity.\n-     * <p>\n-     * The computed omega[] = { 1, w, w^2, ... w^(n-1) } where\n-     * w = exp(-2 \\pi i / n), i = sqrt(-1). Note n is positive for\n-     * forward transform and negative for inverse transform. </p>\n-     * \n-     * @param n the integer passed in\n-     * @throws IllegalArgumentException if n = 0\n-     */\n-    protected void computeOmega(int n)\n-        throws IllegalArgumentException {\n-        if (n == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\"cannot compute 0-th root of unity, indefinite result\",\n-                                                                      null);\n-        }\n-        // avoid repetitive calculations\n-        if (n == omegaCount) { return; }\n-        if (n + omegaCount == 0) {\n-            for (int i = 0; i < Math.abs(omegaCount); i++) {\n-                omega[i] = omega[i].conjugate();\n-            }\n-            omegaCount = n;\n-            return;\n-        }\n-        // calculate everything from scratch\n-        omega = new Complex[Math.abs(n)];\n-        double t = 2.0 * Math.PI / n;\n-        double cost = Math.cos(t);\n-        double sint = Math.sin(t);\n-        omega[0] = new Complex(1.0, 0.0);\n-        for (int i = 1; i < Math.abs(n); i++) {\n-            omega[i] = new Complex(\n-                omega[i-1].getReal() * cost + omega[i-1].getImaginary() * sint,\n-                omega[i-1].getImaginary() * cost - omega[i-1].getReal() * sint);\n-        }\n-        omegaCount = n;\n     }\n \n     /**\n             }\n         }\n     }\n+    \n+    \n+    /** Computes the n<sup>th</sup> roots of unity. \n+     * A cache of already computed values is maintained.\n+     */\n+    private static class RootsOfUnity {\n+      \n+      private int      omegaCount;\n+      private double[] omegaReal;\n+      private double[] omegaImaginaryForward;\n+      private double[] omegaImaginaryInverse;\n+      private boolean  isForward;\n+      \n+      public RootsOfUnity() {\n+        \n+        omegaCount = 0;\n+        omegaReal = null;\n+        omegaImaginaryForward = null;\n+        omegaImaginaryInverse = null;\n+        isForward = true;\n+        \n+      }\n+\n+      /**\n+       * Check if computation has been done for forward or reverse transform.\n+       * @return true if computation has been done for forward transform\n+       * @throws IllegalStateException if no roots of unity have been computed yet\n+       */\n+      public synchronized boolean isForward() throws IllegalStateException {\n+          \n+        if (omegaCount == 0) {\n+          throw MathRuntimeException.createIllegalStateException(\n+                  \"roots of unity have not been computed yet\",\n+                  null);\n+        }        \n+        return isForward;\n+        \n+      }\n+      \n+      /** Computes the n<sup>th</sup> roots of unity.\n+       * <p>The computed omega[] = { 1, w, w<sup>2</sup>, ... w<sup>(n-1)</sup> } where\n+       * w = exp(-2 &pi; i / n), i = &sqrt;(-1).</p>\n+       * <p>Note that n is positive for\n+       * forward transform and negative for inverse transform.</p>\n+       * @param n number of roots of unity to compute,\n+       * positive for forward transform, negative for inverse transform\n+       * @throws IllegalArgumentException if n = 0\n+       */\n+      public synchronized void computeOmega(int n) throws IllegalArgumentException {\n+\n+        if (n == 0) {\n+          throw MathRuntimeException.createIllegalArgumentException(\n+                  \"cannot compute 0-th root of unity, indefinite result\",\n+                  null);\n+        }\n+\n+        isForward = (n > 0);\n+        \n+        // avoid repetitive calculations\n+        final int absN = Math.abs(n);\n+        \n+        if (absN == omegaCount) {\n+            return;\n+        }\n+\n+        // calculate everything from scratch, for both forward and inverse versions\n+        final double t    = 2.0 * Math.PI / absN;\n+        final double cosT = Math.cos(t);\n+        final double sinT = Math.sin(t);\n+        omegaReal             = new double[absN];\n+        omegaImaginaryForward = new double[absN];\n+        omegaImaginaryInverse = new double[absN];\n+        omegaReal[0]             = 1.0;\n+        omegaImaginaryForward[0] = 0.0;\n+        omegaImaginaryInverse[0] = 0.0;\n+        for (int i = 1; i < absN; i++) {\n+          omegaReal[i] =\n+            omegaReal[i-1] * cosT + omegaImaginaryForward[i-1] * sinT;\n+          omegaImaginaryForward[i] =\n+             omegaImaginaryForward[i-1] * cosT - omegaReal[i-1] * sinT;\n+          omegaImaginaryInverse[i] = -omegaImaginaryForward[i];\n+        }\n+        omegaCount = absN;\n+\n+      }\n+\n+      /**\n+       * Get the real part of the k<sup>th</sup> n<sup>th</sup> root of unity\n+       * @param k index of the n<sup>th</sup> root of unity\n+       * @return real part of the k<sup>th</sup> n<sup>th</sup> root of unity\n+       * @throws IllegalStateException if no roots of unity have been computed yet\n+       * @throws IllegalArgumentException if k is out of range\n+       */\n+      public synchronized double getOmegaReal(int k)\n+        throws IllegalStateException, IllegalArgumentException {\n+        \n+        if (omegaCount == 0) {\n+            throw MathRuntimeException.createIllegalStateException(\n+                    \"roots of unity have not been computed yet\",\n+                    null);\n+        }\n+        if ((k < 0) || (k >= omegaCount)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"out of range root of unity index {0} (must be in [{1};{2}])\",\n+                    new Object[] { k, 0, omegaCount - 1 });\n+        }\n+        \n+        return omegaReal[k];\n+        \n+      }\n+\n+      /**\n+       * Get the imaginary part of the k<sup>th</sup> n<sup>th</sup> root of unity\n+       * @param k index of the n<sup>th</sup> root of unity\n+       * @return imaginary part of the k<sup>th</sup> n<sup>th</sup> root of unity\n+       * @throws IllegalStateException if no roots of unity have been computed yet\n+       * @throws IllegalArgumentException if k is out of range\n+       */\n+      public synchronized double getOmegaImaginary(int k)\n+        throws IllegalStateException, IllegalArgumentException {\n+      \n+        if (omegaCount == 0) {\n+            throw MathRuntimeException.createIllegalStateException(\n+                    \"roots of unity have not been computed yet\",\n+                    null);\n+        }\n+        if ((k < 0) || (k >= omegaCount)) {\n+          throw MathRuntimeException.createIllegalArgumentException(\n+                  \"out of range root of unity index {0} (must be in [{1};{2}])\",\n+                  new Object[] { k, 0, omegaCount - 1 });\n+        }\n+\n+        return (isForward) ?\n+            omegaImaginaryForward[k] : omegaImaginaryInverse[k];\n+        \n+      }\n+\n+    }\n+    \n }", "timestamp": 1233691160, "metainfo": ""}