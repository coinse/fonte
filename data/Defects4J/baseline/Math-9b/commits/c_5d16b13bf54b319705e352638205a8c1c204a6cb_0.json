{"sha": "5d16b13bf54b319705e352638205a8c1c204a6cb", "log": "added miscellaneous methods to get some feedback on the integration process (step start, step size, number of evaluations ...)  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobians.java\n+++ b/src/main/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobians.java\n import java.util.Collection;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxEvaluationsExceededException;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n     /** Raw equations to integrate. */\n     private final ParameterizedODEWithJacobians ode;\n \n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n+    /** Number of evaluations already performed. */\n+    private int evaluations;\n+\n     /** Build an enhanced integrator using internal differentiation to compute jacobians.\n      * @param integrator underlying integrator to solve the compound problem\n      * @param ode original problem (f in the equation y' = f(t, y))\n         checkDimension(ode.getParametersDimension(), hP);\n         this.integrator = integrator;\n         this.ode = new FiniteDifferencesWrapper(ode, p, hY, hP);\n+        setMaxEvaluations(-1);\n     }\n \n     /** Build an enhanced integrator using ODE builtin jacobian computation features.\n                                              final ParameterizedODEWithJacobians ode) {\n         this.integrator = integrator;\n         this.ode = ode;\n+        setMaxEvaluations(-1);\n     }\n \n     /** Add a step handler to this integrator.\n         }\n \n         // integrate the compound state variational equations\n-        final double stopTime = integrator.integrate(new MappingWrapper(ode), t0, z, t, z);\n+        evaluations = 0;\n+        final double stopTime = integrator.integrate(new MappingWrapper(), t0, z, t, z);\n \n         // dispatch the final compound state into the state and partial derivatives arrays\n         System.arraycopy(z, 0, y, 0, n);\n \n         return stopTime;\n \n+    }\n+\n+    /** Get the current value of the step start time t<sub>i</sub>.\n+     * <p>This method can be called during integration (typically by\n+     * the object implementing the {@link FirstOrderDifferentialEquations\n+     * differential equations} problem) if the value of the current step that\n+     * is attempted is needed.</p>\n+     * <p>The result is undefined if the method is called outside of\n+     * calls to <code>integrate</code>.</p>\n+     * @return current value of the step start time t<sub>i</sub>\n+     */\n+    public double getCurrentStepStart() {\n+        return integrator.getCurrentStepStart();\n+    }\n+\n+    /** Get the current signed value of the integration stepsize.\n+     * <p>This method can be called during integration (typically by\n+     * the object implementing the {@link FirstOrderDifferentialEquations\n+     * differential equations} problem) if the signed value of the current stepsize\n+     * that is tried is needed.</p>\n+     * <p>The result is undefined if the method is called outside of\n+     * calls to <code>integrate</code>.</p>\n+     * @return current signed value of the stepsize\n+     */\n+    public double getCurrentSignedStepsize() {\n+        return integrator.getCurrentSignedStepsize();\n+    }\n+\n+    /** Set the maximal number of differential equations function evaluations.\n+     * <p>The purpose of this method is to avoid infinite loops which can occur\n+     * for example when stringent error constraints are set or when lots of\n+     * discrete events are triggered, thus leading to many rejected steps.</p>\n+     * @param maxEvaluations maximal number of function evaluations (negative\n+     * values are silently converted to maximal integer value, thus representing\n+     * almost unlimited evaluations)\n+     */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = (maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations;\n+    }\n+\n+    /** Get the maximal number of functions evaluations.\n+     * @return maximal number of functions evaluations\n+     */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** Get the number of evaluations of the differential equations function.\n+     * <p>\n+     * The number of evaluations corresponds to the last call to the\n+     * <code>integrate</code> method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the differential equations function\n+     */\n+    public int getEvaluations() {\n+        return evaluations;\n     }\n \n     /** Check array dimensions.\n     }\n \n     /** Wrapper class used to map state and jacobians into compound state. */\n-    private static class MappingWrapper implements  FirstOrderDifferentialEquations {\n-\n-        /** Underlying ODE with jacobians. */\n-        private final ParameterizedODEWithJacobians ode;\n+    private class MappingWrapper implements  FirstOrderDifferentialEquations {\n \n         /** Current state. */\n         private final double[]   y;\n         private final double[][] dFdP;\n \n         /** Simple constructor.\n-         * @param ode underlying ODE with jacobians\n-         */\n-        public MappingWrapper(final ParameterizedODEWithJacobians ode) {\n-\n-            this.ode = ode;\n+         */\n+        public MappingWrapper() {\n \n             final int n = ode.getDimension();\n             final int k = ode.getParametersDimension();\n \n             // compute raw ODE and its jacobians: dy/dt, d[dy/dt]/dy0 and d[dy/dt]/dp\n             System.arraycopy(z,    0, y,    0, n);\n+            if (++evaluations > maxEvaluations) {\n+                throw new DerivativeException(new MaxEvaluationsExceededException(maxEvaluations));\n+            }\n             ode.computeDerivatives(t, y, yDot);\n             ode.computeJacobians(t, y, yDot, dFdY, dFdP);\n \n     }\n \n     /** Wrapper class to compute jacobians by finite differences for ODE which do not compute them themselves. */\n-    private static class FiniteDifferencesWrapper\n+    private class FiniteDifferencesWrapper\n         implements ParameterizedODEWithJacobians {\n \n         /** Raw ODE without jacobians computation. */\n \n         /** {@inheritDoc} */\n         public void computeDerivatives(double t, double[] y, double[] yDot) throws DerivativeException {\n+            // this call to computeDerivatives has already been counted,\n+            // we must not increment the counter again\n             ode.computeDerivatives(t, y, yDot);\n         }\n \n \n             final int n = ode.getDimension();\n             final int k = ode.getParametersDimension();\n+\n+            evaluations += n + k;\n+            if (evaluations > maxEvaluations) {\n+                throw new DerivativeException(new MaxEvaluationsExceededException(maxEvaluations));\n+            }\n \n             // compute df/dy where f is the ODE and y is the state array\n             for (int j = 0; j < n; ++j) {\n--- a/src/test/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobiansTest.java\n+++ b/src/test/java/org/apache/commons/math/ode/jacobians/FirstOrderIntegratorWithJacobiansTest.java\n             FirstOrderIntegratorWithJacobians extInt =\n                 new FirstOrderIntegratorWithJacobians(integ, brusselator, new double[] { b },\n                                                       new double[] { hY, hY }, new double[] { hP });\n+            extInt.setMaxEvaluations(5000);\n             extInt.integrate(0, z, new double[][] { { 0.0 }, { 1.0 } }, 20.0, z, dZdZ0, dZdP);\n+            Assert.assertEquals(5000, extInt.getMaxEvaluations());\n+            Assert.assertTrue(extInt.getEvaluations() > 2000);\n+            Assert.assertTrue(extInt.getEvaluations() < 2500);\n+            Assert.assertEquals(4 * integ.getEvaluations(), extInt.getEvaluations());\n             residualsP0.addValue(dZdP[0][0] - brusselator.dYdP0());\n             residualsP1.addValue(dZdP[1][0] - brusselator.dYdP1());\n         }\n     public void testAnalyticalDifferentiation()\n         throws IntegratorException, DerivativeException {\n         FirstOrderIntegrator integ =\n-            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-10, 1.0e-10);\n+            new DormandPrince54Integrator(1.0e-8, 100.0, 1.0e-4, 1.0e-4);\n         SummaryStatistics residualsP0 = new SummaryStatistics();\n         SummaryStatistics residualsP1 = new SummaryStatistics();\n         for (double b = 2.88; b < 3.08; b += 0.001) {\n             double[][] dZdP  = new double[2][1];\n             FirstOrderIntegratorWithJacobians extInt =\n                 new FirstOrderIntegratorWithJacobians(integ, brusselator);\n+            extInt.setMaxEvaluations(5000);\n             extInt.integrate(0, z, new double[][] { { 0.0 }, { 1.0 } }, 20.0, z, dZdZ0, dZdP);\n+            Assert.assertEquals(5000, extInt.getMaxEvaluations());\n+            Assert.assertTrue(extInt.getEvaluations() > 510);\n+            Assert.assertTrue(extInt.getEvaluations() < 610);\n+            Assert.assertEquals(integ.getEvaluations(), extInt.getEvaluations());\n             residualsP0.addValue(dZdP[0][0] - brusselator.dYdP0());\n             residualsP1.addValue(dZdP[1][0] - brusselator.dYdP1());\n         }\n         double[][] dydy0 = new double[2][2];\n         double[][] dydp  = new double[2][3];\n         double t = 18 * Math.PI;\n-        FirstOrderIntegratorWithJacobians extInt =\n+        final FirstOrderIntegratorWithJacobians extInt =\n             new FirstOrderIntegratorWithJacobians(integ, circle);\n         extInt.addStepHandler(new StepHandlerWithJacobians() {\n             \n                 double[]   y     = interpolator.getInterpolatedY();\n                 double[][] dydy0 = interpolator.getInterpolatedDyDy0();\n                 double[][] dydp  = interpolator.getInterpolatedDyDp();\n+                Assert.assertEquals(interpolator.getPreviousTime(), extInt.getCurrentStepStart(), 1.0e-10);\n+                Assert.assertTrue(extInt.getCurrentSignedStepsize() < 0.5);\n                 for (int i = 0; i < y.length; ++i) {\n                     Assert.assertEquals(circle.exactY(t)[i], y[i], 1.0e-10);\n                 }", "timestamp": 1267904357, "metainfo": ""}