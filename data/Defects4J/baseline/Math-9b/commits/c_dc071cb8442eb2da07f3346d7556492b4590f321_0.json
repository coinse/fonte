{"sha": "dc071cb8442eb2da07f3346d7556492b4590f321", "log": "Modified luDecompose to require that the matrix be square. Added RealMatrix preMultiply(RealMatrix). Modified preMultiply(double[]) to return a double[]. Renamed private pivot[] array to permutation[]. Exposed lu decomposition matrix and associated permutation array as protected properties.   ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n  * explicitly invoke <code>LUDecompose()</code> to recompute the decomposition\n  * before using any of the methods above.\n  *\n- * @version $Revision: 1.15 $ $Date: 2004/04/03 22:18:04 $\n+ * @version $Revision: 1.16 $ $Date: 2004/04/08 07:01:17 $\n  */\n public class RealMatrixImpl implements RealMatrix, Serializable {\n \n \t/** Entries of the matrix */\n \tprivate double data[][] = null;\n \n-\t/** Entries of LU decomposition.\n-\t * All updates to data (other than luDecompostion) *must* set this to null\n+\t/** Entries of cached LU decomposition.\n+\t *  All updates to data (other than luDecompose()) *must* set this to null\n \t */\n \tprivate double lu[][] = null;\n \n-\t/** Pivot array associated with LU decompostion */\n-\tprivate int[] pivot = null;\n+\t/** Permutation associated with LU decompostion */\n+\tprivate int[] permutation = null;\n \n \t/** Parity of the permutation associated with the LU decomposition */\n \tprivate int parity = 1;\n \n \t/** Bound to determine effective singularity in LU decomposition */\n-\tprivate static double TOO_SMALL = 10E-12;\n+\tprotected static double TOO_SMALL = 10E-12;\n \n \t/** \n \t * Creates a matrix with no data\n \t\t}\n \t\treturn new RealMatrixImpl(outData);\n \t}\n+    \n+    /**\n+     * Returns the result premultiplying this by <code>m</code>.\n+     * @param m    matrix to premultiply by\n+     * @return     m * this\n+     * @throws     IllegalArgumentException\n+     *             if rowDimension(this) != columnDimension(m)\n+     */\n+    public RealMatrix preMultiply(RealMatrix m) throws IllegalArgumentException {\n+        return m.multiply(this);\n+    }\n \n \t/**\n \t * Returns matrix entries as a two-dimensional array.\n \t\t\treturn det;\n \t\t}\n \t}\n-\n+    \n \t/**\n \t * @return true if the matrix is square (rowDimension = columnDimension)\n \t */\n \tpublic boolean isSingular() {\n \t\tif (lu == null) {\n \t\t\ttry {\n-\t\t\t\tLUDecompose();\n+\t\t\t\tluDecompose();\n \t\t\t\treturn false;\n \t\t\t} catch (InvalidMatrixException ex) {\n \t\t\t\treturn true;\n \t * @throws IllegalArgumentException if rowDimension != v.length\n \t * @return resulting matrix\n \t */\n-\tpublic RealMatrix preMultiply(double[] v) throws IllegalArgumentException {\n-\t\tint nCols = this.getColumnDimension();\n-\t\tif (v.length != nCols) {\n+\tpublic double[] preMultiply(double[] v) throws IllegalArgumentException {\n+\t\tint nRows = this.getRowDimension();\n+\t\tif (v.length != nRows) {\n \t\t\tthrow new IllegalArgumentException(\"vector has wrong length\");\n \t\t}\n-\t\t// being a bit lazy here -- probably should implement directly, like\n-\t\t// operate\n-\t\tRealMatrix pm = new RealMatrixImpl(v).transpose();\n-\t\treturn pm.multiply(this);\n+        int nCols = this.getColumnDimension();\n+        double[] out = new double[nCols];\n+        for (int col = 0; col < nCols; col++) {\n+            double sum = 0;\n+            for (int i = 0; i < nRows; i++) {\n+                sum += data[i][col] * v[i];\n+            }\n+            out[col] = sum;\n+        }\n+        return out;\n \t}\n \n \t/**\n \t\tdouble[][] bp = new double[nRowB][nColB];\n \t\tfor (int row = 0; row < nRowB; row++) {\n \t\t\tfor (int col = 0; col < nColB; col++) {\n-\t\t\t\tbp[row][col] = bv[pivot[row]][col];\n+\t\t\t\tbp[row][col] = bv[permutation[row]][col];\n \t\t\t}\n \t\t}\n \t\tbv = null;\n \t/**\n \t * Computes a new <a href=\"http://www.math.gatech.edu/~bourbaki/\n \t * math2601/Web-notes/2num.pdf\">LU decompostion</a> for this matrix,\n-\t * storing the result for use by other methods.\n+\t * storing the result for use by other methods. \n \t * <p>\n \t * <strong>Implementation Note</strong>:<br>\n \t * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/\n \t * made using setXxx methods will trigger recomputation when needed\n \t * automatically.\n \t *\n-\t * @throws InvalidMatrixException if the matrix is singular or if the matrix has more rows than columns\n-\t */\n-\tpublic void LUDecompose() throws InvalidMatrixException {\n-\t\t// @TODO Bad method name - get rid of leading capitals\n-\t\t\n+\t * @throws InvalidMatrixException if the matrix is non-square or singular.\n+\t */\n+\tpublic void luDecompose() throws InvalidMatrixException {\n+\t\t \n \t\tint nRows = this.getRowDimension();\n \t\tint nCols = this.getColumnDimension();\n-\t\tif (nRows < nCols) {\n-\t\t\tthrow new InvalidMatrixException(\"LU decomposition requires row dimension >= column dimension\");\n+\t\tif (nRows != nCols) {\n+\t\t\tthrow new InvalidMatrixException(\"LU decomposition requires that the matrix be square.\");\n \t\t}\n \t\tlu = this.getData();\n \n-\t\t// Initialize pivot array and parity\n-\t\tpivot = new int[nRows];\n+\t\t// Initialize permutation array and parity\n+\t\tpermutation = new int[nRows];\n \t\tfor (int row = 0; row < nRows; row++) {\n-\t\t\tpivot[row] = row;\n+\t\t\tpermutation[row] = row;\n \t\t}\n \t\tparity = 1;\n \n \t\t\t}\n \n \t\t\t// lower\n-\t\t\tint max = col; // pivot row\n+\t\t\tint max = col; // permutation row\n \t\t\tdouble largest = 0d;\n \t\t\tfor (int row = col; row < nRows; row++) {\n \t\t\t\tsum = lu[row][col];\n \t\t\t\t}\n \t\t\t\tlu[row][col] = sum;\n \n-\t\t\t\t// maintain best pivot choice\n+\t\t\t\t// maintain best permutation choice\n \t\t\t\tif (Math.abs(sum) > largest) {\n \t\t\t\t\tlargest = Math.abs(sum);\n \t\t\t\t\tmax = row;\n \t\t\t\t\tlu[max][i] = lu[col][i];\n \t\t\t\t\tlu[col][i] = tmp;\n \t\t\t\t}\n-\t\t\t\tint temp = pivot[max];\n-\t\t\t\tpivot[max] = pivot[col];\n-\t\t\t\tpivot[col] = temp;\n+\t\t\t\tint temp = permutation[max];\n+\t\t\t\tpermutation[max] = permutation[col];\n+\t\t\t\tpermutation[col] = temp;\n \t\t\t\tparity = -parity;\n \t\t\t}\n \n \t\t}\n \t\treturn out;\n \t}\n+\t\n+\t/**\n+\t *  Returns the LU decomposition as a RealMatrix.\n+\t *  Returns a fresh copy of the cached LU matrix if this has been computed; \n+\t *  otherwise the composition is computed and cached for use by other methods.   \n+\t *  Since a copy is returned in either case, changes to the returned matrix do not \n+\t *  affect the LU decomposition property. \n+\t * <p>\n+\t * The matrix returned is a compact representation of the LU decomposition. \n+\t * Elements below the main diagonal correspond to entries of the \"L\" matrix;   \n+\t * elements on and above the main diagonal correspond to entries of the \"U\"\n+\t * matrix.\n+\t * <p>\n+\t * Example: <pre>\n+\t * \n+\t *     Returned matrix                L                  U\n+\t *         2  3  1                   1  0  0            2  3  1          \n+\t *         5  4  6                   5  1  0            0  4  6\n+\t *         1  7  8                   1  7  1            0  0  8          \n+\t * </pre>\n+\t * \n+\t * The L and U matrices satisfy the matrix equation LU = permuteRows(this), <br>\n+\t *  where permuteRows reorders the rows of the matrix to follow the order determined\n+\t *  by the <a href=#getPermutation()>permutation</a> property.\n+\t * \n+\t * @return LU decomposition matrix\n+\t * @throws InvalidMatrixException if the matrix is non-square or singular.\n+\t */\n+\tprotected RealMatrix getLUMatrix() throws InvalidMatrixException {\n+\t    if (lu == null) {\n+\t        luDecompose();\n+\t    }\n+\t    return new RealMatrixImpl(lu);   \n+\t}\n+\t\n+\t/**\n+\t * Returns the permutation associated with the lu decomposition.\n+\t * The entries of the array represent a permutation of the numbers 0, ... , nRows - 1.\n+\t * <p>\n+\t * Example:\n+\t * permutation = [1, 2, 0] means current 2nd row is first, current third row is second\n+\t * and current first row is last.\n+\t * <p>\n+\t * Returns a fresh copy of the array.\n+\t * \n+\t * @return the permutation\n+\t */\n+\tprotected int[] getPermutation() {\n+\t    int[] out = new int[permutation.length];\n+\t    System.arraycopy(permutation, 0, out, 0, permutation.length);\n+\t    return out;\n+\t}\n \n \t//------------------------ Private methods\n \n \n \t\treturn !(row < 1 || row > nRows || col < 1 || col > nCols);\n \t}\n-\n+\t\n }", "timestamp": 1081407677, "metainfo": ""}