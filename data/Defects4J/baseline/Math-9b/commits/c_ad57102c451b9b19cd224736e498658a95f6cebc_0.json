{"sha": "ad57102c451b9b19cd224736e498658a95f6cebc", "log": "MATH-707 \"SimpleScalarValueChecker\" renamed to \"SimpleValueChecker\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/ConvergenceChecker.java\n+++ b/src/main/java/org/apache/commons/math/optimization/ConvergenceChecker.java\n  *\n  * @param <PAIR> Type of the (point, objective value) pair.\n  *\n- * @see org.apache.commons.math.optimization.SimpleScalarValueChecker\n+ * @see org.apache.commons.math.optimization.SimpleValueChecker\n  * @see org.apache.commons.math.optimization.SimplePointChecker<PointValuePair>\n  *\n  * @version $Id$\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleValueChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * Simple implementation of the {@link ConvergenceChecker} interface using\n+ * only objective function values.\n+ *\n+ * Convergence is considered to have been reached if either the relative\n+ * difference between the objective function values is smaller than a\n+ * threshold or if either the absolute difference between the objective\n+ * function values is smaller than another threshold.\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+public class SimpleValueChecker\n+    extends AbstractConvergenceChecker<PointValuePair> {\n+    /**\n+     * Build an instance with default thresholds.\n+     */\n+    public SimpleValueChecker() {}\n+\n+    /** Build an instance with specified thresholds.\n+     *\n+     * In order to perform only relative checks, the absolute tolerance\n+     * must be set to a negative value. In order to perform only absolute\n+     * checks, the relative tolerance must be set to a negative value.\n+     *\n+     * @param relativeThreshold relative tolerance threshold\n+     * @param absoluteThreshold absolute tolerance threshold\n+     */\n+    public SimpleValueChecker(final double relativeThreshold,\n+                                    final double absoluteThreshold) {\n+        super(relativeThreshold, absoluteThreshold);\n+    }\n+\n+    /**\n+     * Check if the optimization algorithm has converged considering the\n+     * last two points.\n+     * This method may be called several time from the same algorithm\n+     * iteration with different points. This can be detected by checking the\n+     * iteration number at each call if needed. Each time this method is\n+     * called, the previous and current point correspond to points with the\n+     * same role at each iteration, so they can be compared. As an example,\n+     * simplex-based algorithms call this method for all points of the simplex,\n+     * not only for the best or worst ones.\n+     *\n+     * @param iteration Index of current iteration\n+     * @param previous Best point in the previous iteration.\n+     * @param current Best point in the current iteration.\n+     * @return {@code true} if the algorithm has converged.\n+     */\n+    @Override\n+    public boolean converged(final int iteration,\n+                             final PointValuePair previous,\n+                             final PointValuePair current) {\n+        final double p = previous.getValue();\n+        final double c = current.getValue();\n+        final double difference = FastMath.abs(p - c);\n+        final double size = FastMath.max(FastMath.abs(p), FastMath.abs(c));\n+        return difference <= size * getRelativeThreshold() ||\n+            difference <= getAbsoluteThreshold();\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractMultivariateOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractMultivariateOptimizer.java\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.PointValuePair;\n-import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+import org.apache.commons.math.optimization.SimpleValueChecker;\n \n /**\n  * Base class for implementing optimizers for multivariate scalar functions.\n \n     /**\n      * Simple constructor with default settings.\n-     * The convergence check is set to a {@link SimpleScalarValueChecker} and\n+     * The convergence check is set to a {@link SimpleValueChecker} and\n      * the allowed number of evaluations is set to {@link Integer#MAX_VALUE}.\n      */\n     protected BaseAbstractMultivariateOptimizer() {\n-        this(new SimpleScalarValueChecker());\n+        this(new SimpleValueChecker());\n     }\n     /**\n      * @param checker Convergence checker.\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractMultivariateSimpleBoundsOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractMultivariateSimpleBoundsOptimizer.java\n     /**\n      * Simple constructor with default settings.\n      * The convergence checker is set to a\n-     * {@link org.apache.commons.math.optimization.SimpleScalarValueChecker} and\n+     * {@link org.apache.commons.math.optimization.SimpleValueChecker} and\n      * the allowed number of evaluations is set to {@link Integer#MAX_VALUE}.\n      *\n      * @see BaseAbstractMultivariateOptimizer#BaseAbstractMultivariateOptimizer()\n--- a/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.MultivariateOptimizer;\n import org.apache.commons.math.optimization.PointValuePair;\n-import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+import org.apache.commons.math.optimization.SimpleValueChecker;\n import org.apache.commons.math.random.MersenneTwister;\n import org.apache.commons.math.random.RandomGenerator;\n import org.apache.commons.math.util.MathArrays;\n                           RandomGenerator random, boolean generateStatistics) {\n         this(lambda, inputSigma, boundaries, maxIterations, stopFitness, isActiveCMA,\n              diagonalOnly, checkFeasableCount, random, generateStatistics,\n-             new SimpleScalarValueChecker());\n+             new SimpleValueChecker());\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/optimization/direct/SimplexOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/SimplexOptimizer.java\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.optimization.PointValuePair;\n-import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+import org.apache.commons.math.optimization.SimpleValueChecker;\n import org.apache.commons.math.optimization.MultivariateOptimizer;\n \n /**\n     private AbstractSimplex simplex;\n \n     /**\n-     * Constructor using a default {@link SimpleScalarValueChecker convergence\n+     * Constructor using a default {@link SimpleValueChecker convergence\n      * checker}.\n      */\n     public SimplexOptimizer() {\n-        this(new SimpleScalarValueChecker());\n+        this(new SimpleValueChecker());\n     }\n \n     /**\n      * @param abs Absolute threshold.\n      */\n     public SimplexOptimizer(double rel, double abs) {\n-        this(new SimpleScalarValueChecker(rel, abs));\n+        this(new SimpleValueChecker(rel, abs));\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n     /**\n      * Simple constructor with default settings.\n      * The convergence check is set to a\n-     * {@link org.apache.commons.math.optimization.SimpleScalarValueChecker\n-     * SimpleScalarValueChecker}.\n+     * {@link org.apache.commons.math.optimization.SimpleValueChecker\n+     * SimpleValueChecker}.\n      */\n     protected AbstractScalarDifferentiableOptimizer() {}\n     /**\n--- a/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.PointValuePair;\n-import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+import org.apache.commons.math.optimization.SimpleValueChecker;\n import org.apache.commons.math.optimization.ConvergenceChecker;\n import org.apache.commons.math.util.FastMath;\n \n     private double[] point;\n \n     /**\n-     * Constructor with default {@link SimpleScalarValueChecker checker},\n+     * Constructor with default {@link SimpleValueChecker checker},\n      * {@link BrentSolver line search solver} and\n      * {@link IdentityPreconditioner preconditioner}.\n      *\n      */\n     public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula) {\n         this(updateFormula,\n-             new SimpleScalarValueChecker());\n+             new SimpleValueChecker());\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/optimization/DifferentiableMultivariateMultiStartOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/DifferentiableMultivariateMultiStartOptimizerTest.java\n         circle.addPoint( 45.0,  97.0);\n         NonLinearConjugateGradientOptimizer underlying =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n-                                                    new SimpleScalarValueChecker(1.0e-10, 1.0e-10));\n+                                                    new SimpleValueChecker(1.0e-10, 1.0e-10));\n         JDKRandomGenerator g = new JDKRandomGenerator();\n         g.setSeed(753289573253l);\n         RandomVectorGenerator generator =\n--- a/src/test/java/org/apache/commons/math/optimization/MultivariateMultiStartOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/MultivariateMultiStartOptimizerTest.java\n     public void testRosenbrock() {\n         Rosenbrock rosenbrock = new Rosenbrock();\n         SimplexOptimizer underlying\n-            = new SimplexOptimizer(new SimpleScalarValueChecker(-1, 1.0e-3));\n+            = new SimplexOptimizer(new SimpleValueChecker(-1, 1.0e-3));\n         NelderMeadSimplex simplex = new NelderMeadSimplex(new double[][] {\n                 { -1.2,  1.0 }, { 0.9, 1.2 } , {  3.5, -2.3 }\n             });\n--- a/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerMultiDirectionalTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/SimplexOptimizerMultiDirectionalTest.java\n import org.apache.commons.math.analysis.MultivariateFunction;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.PointValuePair;\n-import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+import org.apache.commons.math.optimization.SimpleValueChecker;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n \n     @Test\n     public void testMaximize2() {\n-        SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleScalarValueChecker(1e-15, 1e-30));\n+        SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleValueChecker(1e-15, 1e-30));\n         optimizer.setSimplex(new MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\n         final FourExtrema fourExtrema = new FourExtrema();\n \n--- a/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizerTest.java\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.optimization.GoalType;\n import org.apache.commons.math.optimization.PointValuePair;\n-import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+import org.apache.commons.math.optimization.SimpleValueChecker;\n import org.junit.Assert;\n import org.junit.Test;\n \n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n-                                                    new SimpleScalarValueChecker(1e-6, 1e-6));\n+                                                    new SimpleValueChecker(1e-6, 1e-6));\n         PointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0 });\n         Assert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\n \n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n-                                                    new SimpleScalarValueChecker(1e-6, 1e-6));\n+                                                    new SimpleValueChecker(1e-6, 1e-6));\n         PointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0 });\n         Assert.assertEquals(7.0, optimum.getPoint()[0], 1.0e-10);\n         }, new double[] { 0.0, 1.1, 2.2, 3.3, 4.4, 5.5 });\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n-                                                    new SimpleScalarValueChecker(1e-6, 1e-6));\n+                                                    new SimpleValueChecker(1e-6, 1e-6));\n         PointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0, 0, 0, 0 });\n         for (int i = 0; i < problem.target.length; ++i) {\n         }, new double[] { 1, 1, 1});\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n-                                                    new SimpleScalarValueChecker(1e-6, 1e-6));\n+                                                    new SimpleValueChecker(1e-6, 1e-6));\n         PointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });\n         Assert.assertEquals(1.0, optimum.getPoint()[0], 1.0e-10);\n \n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n-                                                    new SimpleScalarValueChecker(1e-13, 1e-13),\n+                                                    new SimpleValueChecker(1e-13, 1e-13),\n                                                     new BrentSolver(),\n                                                     preconditioner);\n                                                     \n         }, new double[] { 1, 1, 1 });\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n-                                                    new SimpleScalarValueChecker(1e-6, 1e-6));\n+                                                    new SimpleValueChecker(1e-6, 1e-6));\n         PointValuePair optimum =\n                 optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 0, 0, 0 });\n         Assert.assertTrue(optimum.getValue() > 0.5);\n         }, new double[] { 32, 23, 33, 31 });\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n-                                                    new SimpleScalarValueChecker(1e-13, 1e-13),\n+                                                    new SimpleValueChecker(1e-13, 1e-13),\n                                                     new BrentSolver(1e-15, 1e-15));\n         PointValuePair optimum1 =\n             optimizer.optimize(200, problem1, GoalType.MINIMIZE, new double[] { 0, 1, 2, 3 });\n \n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n-                                                    new SimpleScalarValueChecker(1e-6, 1e-6));\n+                                                    new SimpleValueChecker(1e-6, 1e-6));\n         PointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 7, 6, 5, 4 });\n         Assert.assertEquals(0, optimum.getValue(), 1.0e-10);\n         }, new double[] { 3.0, 12.0, -1.0, 7.0, 1.0 });\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n-                                                    new SimpleScalarValueChecker(1e-6, 1e-6));\n+                                                    new SimpleValueChecker(1e-6, 1e-6));\n         PointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 2, 2, 2, 2, 2, 2 });\n         Assert.assertEquals(0, optimum.getValue(), 1.0e-10);\n \n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n-                                                    new SimpleScalarValueChecker(1e-6, 1e-6));\n+                                                    new SimpleValueChecker(1e-6, 1e-6));\n         PointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 1, 1 });\n         Assert.assertEquals(2.0, optimum.getPoint()[0], 1.0e-8);\n \n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n-                                                    new SimpleScalarValueChecker(1e-6, 1e-6));\n+                                                    new SimpleValueChecker(1e-6, 1e-6));\n         PointValuePair optimum =\n             optimizer.optimize(100, problem, GoalType.MINIMIZE, new double[] { 1, 1 });\n         Assert.assertTrue(optimum.getValue() > 0.1);\n         circle.addPoint( 45.0,  97.0);\n         NonLinearConjugateGradientOptimizer optimizer =\n             new NonLinearConjugateGradientOptimizer(ConjugateGradientFormula.POLAK_RIBIERE,\n-                                                    new SimpleScalarValueChecker(1e-30, 1e-30),\n+                                                    new SimpleValueChecker(1e-30, 1e-30),\n                                                     new BrentSolver(1e-15, 1e-13));\n         PointValuePair optimum =\n             optimizer.optimize(100, circle, GoalType.MINIMIZE, new double[] { 98.680, 47.345 });", "timestamp": 1329089904, "metainfo": ""}