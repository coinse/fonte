{"sha": "0eac35b89d3ae8cb8b989db0cde22cee0511268d", "log": "added a transformer between Nordsieck form and multistep form for state history in multistep ODE integrators (this will help implementing adaptive stepsize multistep integrators)  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/NordsieckTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import java.io.Serializable;\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.fraction.BigFraction;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.RealMatrixImpl;\n+\n+/**\n+ * This class transforms state history between multistep (with or without\n+ * derivatives) and Nordsieck forms.\n+ * <p>\n+ * {@link MultistepIntegrator multistep integrators} use state history\n+ * from several previous steps to compute the current state. They may also use\n+ * the first derivative of current state. All states are separated by a fixed\n+ * step size h from each other. Since these methods are based on polynomial\n+ * interpolation, the information from the previous state may be represented\n+ * in another equivalent way: using the state higher order derivatives at\n+ * current step rather. This class transforms state history between these three\n+ * equivalent forms.\n+ * <p>\n+ * <p>\n+ * The supported forms for a dimension n history are:\n+ * <ul>\n+ *   <li>multistep without derivatives:<br/>\n+ *     <pre>\n+ *       y<sub>k</sub>, y<sub>k-1</sub> ... y<sub>k-(n-2), y<sub>k-(n-1)</sub>\n+ *     </pre>\n+ *   </li>\n+ *   <li>multistep with first derivative at current step:<br/>\n+ *     <pre>\n+ *       y<sub>k</sub>, y'<sub>k</sub>, y<sub>k-1</sub> ... y<sub>k-(n-2)</sub>\n+ *     </pre>\n+ *   </li>\n+ *   <li>Nordsieck:\n+ *     <pre>\n+ *       y<sub>k</sub>, h y'<sub>k</sub>, h<sup>2</sup>/2 y''<sub>k</sub> ... h<sup>n-1</sup>/(n-1)! yn-1<sub>k</sub>\n+ *     </pre>\n+ *   </li>\n+ * </ul> \n+ * In these expressions, y<sub>k</sub> is the state at the current step. For each p,\n+ * y<sub>k-p</sub> is the state at the p<sup>th</sup> previous step. y'<sub>k</sub>,\n+ * y''<sub>k</sub> ... yn-1<sub>k</sub> are respectively the first, second, ...\n+ * (n-1)<sup>th</sup> derivatives of the state at current step and h is the fixed\n+ * step size.\n+ * </p>\n+ * <p>\n+ * The transforms are exact for polynomials.\n+ * </p>\n+ * <p>\n+ * In Nordsieck form, the state history can be converted from step size h to step\n+ * size h' by rescaling each component by 1, h'/h, (h'/h)<sup>2</sup> ...\n+ * (h'/h)<sup>n-1</sup>.\n+ * </p>\n+ * <p>\n+ * Instances of this class are guaranteed to be immutable.\n+ * </p>\n+ * @see org.apache.commons.math.ode.MultistepIntegrator\n+ * @see org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator\n+ * @see org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class NordsieckTransformer implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -2707468304560314664L;\n+\n+    /** Nordsieck to Multistep  without derivatives matrix. */\n+    private final RealMatrix matNtoMWD;\n+                                           \n+    /** Multistep without derivatives to Nordsieck matrix. */\n+    private final RealMatrix matMWDtoN;\n+\n+    /** Nordsieck to Multistep matrix. */\n+    private final RealMatrix matNtoM;\n+                                           \n+    /** Multistep to Nordsieck matrix. */\n+    private final RealMatrix matMtoN;\n+\n+    /**\n+     * Build a transformer for a specified order.\n+     * @param n dimension of the history\n+     */\n+    public NordsieckTransformer(final int n) {\n+\n+        // from Nordsieck to multistep without derivatives\n+        final BigInteger[][] bigNtoMWD = buildNordsieckToMultistepWithoutDerivatives(n);\n+        double[][] dataNtoMWD = new double[n][n];\n+        for (int i = 0; i < n; ++i) {\n+            double[]     dRow = dataNtoMWD[i];\n+            BigInteger[] bRow = bigNtoMWD[i];\n+            for (int j = 0; j < n; ++j) {\n+                dRow[j] = bRow[j].doubleValue();\n+            }\n+        }\n+        matNtoMWD = new RealMatrixImpl(dataNtoMWD, false);\n+\n+        // from multistep without derivatives to Nordsieck\n+        final BigFraction[][] bigToN = buildMultistepWithoutDerivativesToNordsieck(n);\n+        double[][] dataMWDtoN = new double[n][n];\n+        for (int i = 0; i < n; ++i) {\n+            double[]     dRow = dataMWDtoN[i];\n+            BigFraction[] bRow = bigToN[i];\n+            for (int j = 0; j < n; ++j) {\n+                dRow[j] = bRow[j].doubleValue();\n+            }\n+        }\n+        matMWDtoN = new RealMatrixImpl(dataMWDtoN, false);\n+\n+        // from Nordsieck to multistep\n+        final BigInteger[][] bigNtoM = buildNordsieckToMultistep(n);\n+        double[][] dataNtoM = new double[n][n];\n+        for (int i = 0; i < n; ++i) {\n+            double[]     dRow = dataNtoM[i];\n+            BigInteger[] bRow = bigNtoM[i];\n+            for (int j = 0; j < n; ++j) {\n+                dRow[j] = bRow[j].doubleValue();\n+            }\n+        }\n+        matNtoM = new RealMatrixImpl(dataNtoM, false);\n+\n+        // from multistep to Nordsieck\n+        convertMWDtNtoMtN(bigToN);\n+        double[][] dataMtoN = new double[n][n];\n+        for (int i = 0; i < n; ++i) {\n+            double[]     dRow = dataMtoN[i];\n+            BigFraction[] bRow = bigToN[i];\n+            for (int j = 0; j < n; ++j) {\n+                dRow[j] = bRow[j].doubleValue();\n+            }\n+        }\n+        matMtoN = new RealMatrixImpl(dataMtoN, false);\n+\n+    }\n+\n+    /**\n+     * Build the transform from Nordsieck to multistep without derivatives.\n+     * @param n dimension of the history\n+     * @return transform from Nordsieck to multistep without derivatives\n+     */\n+    public static BigInteger[][] buildNordsieckToMultistepWithoutDerivatives(final int n) {\n+\n+        final BigInteger[][] array = new BigInteger[n][n];\n+\n+        // row 0: [1 0 0 0 ... 0 ]\n+        array[0][0] = BigInteger.ONE;\n+        Arrays.fill(array[0], 1, n, BigInteger.ZERO);\n+\n+        // the following expressions are direct applications of Taylor series\n+        // rows 1 to n-1: aij = (-i)^j\n+        // [ 1  -1   1  -1   1 ...]\n+        // [ 1  -2   4  -8  16 ...]\n+        // [ 1  -3   9 -27  81 ...]\n+        // [ 1  -4  16 -64 256 ...]\n+        for (int i = 1; i < n; ++i) {\n+            final BigInteger[] row  = array[i];\n+            final BigInteger factor = BigInteger.valueOf(-i);\n+            BigInteger aj = BigInteger.ONE;\n+            for (int j = 0; j < n; ++j) {\n+                row[j] = aj;\n+                aj = aj.multiply(factor);\n+            }\n+        }\n+\n+        return array;\n+\n+    }\n+\n+    /**\n+     * Build the transform from multistep without derivatives to Nordsieck.\n+     * @param n dimension of the history\n+     * @return transform from multistep without derivatives to Nordsieck\n+     */\n+    public static BigFraction[][] buildMultistepWithoutDerivativesToNordsieck(final int n) {\n+\n+        final BigInteger[][] iArray = new BigInteger[n][n];\n+\n+        // row 0: [1 0 0 0 ... 0 ]\n+        iArray[0][0] = BigInteger.ONE;\n+        Arrays.fill(iArray[0], 1, n, BigInteger.ZERO);\n+\n+        // We use recursive definitions of triangular integer series for each column.\n+        // For example column 0 of matrices of increasing dimensions are:\n+        //  1/0! for dimension 1\n+        //  1/1!,  1/1! for dimension 2\n+        //  2/2!,  3/2!,  1/2! for dimension 3\n+        //  6/3!, 11/3!,  6/3!,  1/3! for dimension 4\n+        // 24/4!, 50/4!, 35/4!, 10/4!, 1/4! for dimension 5\n+        // The numerators are the Stirling numbers of the first kind, (A008275 in\n+        // Sloane's encyclopedia http://www.research.att.com/~njas/sequences/A008275)\n+        // with a multiplicative factor of +/-1 (which we will write +/-binomial(n-1, 0)).\n+        // In the same way, column 1 is A049444 with a multiplicative factor of\n+        // +/-binomial(n-1, 1) and column 2 is A123319 with a multiplicative factor of\n+        // +/-binomial(n-1, 2). The next columns are defined by similar definitions but\n+        // are not identified in Sloane's encyclopedia.\n+        // Another interesting observation is that for each dimension k, the last column\n+        // (except the initial 0) is a copy of the first column of the dimension k-1 matrix,\n+        // possibly with an opposite sign (i.e. these columns are also linked to Stirling\n+        // numbers of the first kind).\n+        for (int i = 1; i < n; ++i) {\n+\n+            final BigInteger bigI = BigInteger.valueOf(i);\n+\n+            // row i\n+            BigInteger[] rowK   = iArray[i];\n+            BigInteger[] rowKm1 = iArray[i - 1];\n+            for (int j = 0; j < i; ++j) {\n+                rowK[j] = BigInteger.ONE;\n+            }\n+            rowK[i] = rowKm1[0];\n+\n+            // rows i-1 to 1\n+            for (int k = i - 1; k > 0; --k) {\n+\n+                // select rows\n+                rowK   = rowKm1;\n+                rowKm1 = iArray[k - 1];\n+\n+                // apply recursive defining formula\n+                for (int j = 0; j < i; ++j) {\n+                    rowK[j] = rowK[j].multiply(bigI).add(rowKm1[j]);\n+                }\n+\n+                // initialize new last column\n+                rowK[i] = rowKm1[0];\n+\n+            }\n+            rowKm1[0] = rowKm1[0].multiply(bigI);\n+\n+        }\n+\n+        // apply column specific factors\n+        final BigInteger factorial = iArray[0][0];\n+        final BigFraction[][] fArray = new BigFraction[n][n];\n+        for (int i = 0; i < n; ++i) {\n+            final BigFraction[] fRow = fArray[i];\n+            final BigInteger[]  iRow = iArray[i];\n+            BigInteger binomial = BigInteger.ONE;\n+            for (int j = 0; j < n; ++j) {\n+                fRow[j] = new BigFraction(binomial.multiply(iRow[j]), factorial);\n+                binomial = binomial.negate().multiply(BigInteger.valueOf(n - j - 1)).divide(BigInteger.valueOf(j + 1));\n+            }\n+        }\n+\n+        return fArray;\n+\n+    }\n+\n+    /**\n+     * Build the transform from Nordsieck to multistep.\n+     * @param n dimension of the history\n+     * @return transform from Nordsieck to multistep\n+     */\n+    public static BigInteger[][] buildNordsieckToMultistep(final int n) {\n+\n+        final BigInteger[][] array = new BigInteger[n][n];\n+\n+        // row 0: [1 0 0 0 ... 0 ]\n+        array[0][0] = BigInteger.ONE;\n+        Arrays.fill(array[0], 1, n, BigInteger.ZERO);\n+\n+        if (n > 1) {\n+\n+            // row 1: [0 1 0 0 ... 0 ]\n+            array[1][0] = BigInteger.ZERO;\n+            array[1][1] = BigInteger.ONE;\n+            Arrays.fill(array[1], 2, n, BigInteger.ZERO);\n+\n+            // the following expressions are direct applications of Taylor series\n+            // rows 2 to n-1: aij = (1-i)^j\n+            // [ 1  -1   1  -1   1 ...]\n+            // [ 1  -2   4  -8  16 ...]\n+            // [ 1  -3   9 -27  81 ...]\n+            // [ 1  -4  16 -64 256 ...]\n+            for (int i = 2; i < n; ++i) {\n+                final BigInteger[] row  = array[i];\n+                final BigInteger factor = BigInteger.valueOf(1 - i);\n+                BigInteger aj = BigInteger.ONE;\n+                for (int j = 0; j < n; ++j) {\n+                    row[j] = aj;\n+                    aj = aj.multiply(factor);\n+                }\n+            }\n+\n+        }\n+\n+        return array;\n+\n+    }\n+\n+    /**\n+     * Build the transform from multistep to Nordsieck.\n+     * @param n dimension of the history\n+     * @return transform from multistep to Nordsieck\n+     */\n+    public static BigFraction[][] buildMultistepToNordsieck(final int n) {\n+        final BigFraction[][] array = buildMultistepWithoutDerivativesToNordsieck(n);\n+        convertMWDtNtoMtN(array);\n+        return array;\n+    }\n+\n+    /**\n+     * Convert a transform from multistep without derivatives to Nordsieck to\n+     * multistep to Nordsieck.\n+     * @param work array, contains tansform from multistep without derivatives\n+     * to Nordsieck on input, will be overwritten with tansform from multistep\n+     * to Nordsieck on output\n+     */\n+    private static void convertMWDtNtoMtN(BigFraction[][] array) {\n+\n+        final int n = array.length;\n+        if (n == 1) {\n+            return;\n+        }\n+\n+        // the second row of the matrix without derivatives represents the linear equation:\n+        // hy' = a0 yk + a1 yk-1 + ... + a(n-1) yk-(n-1)\n+        // we solve it with respect to the oldest state yk-(n-1) and get\n+        // yk-(n-1) = -a0/a(n-1) yk + 1/a(n-1) hy' - a1/a(n-1) yk-1 - ...\n+        final BigFraction[] secondRow = array[1];\n+        final BigFraction[] solved    = new BigFraction[n];\n+        final BigFraction f = secondRow[n - 1].reciprocal().negate();\n+        solved[0] = secondRow[0].multiply(f);\n+        solved[1] = f.negate();\n+        for (int j = 2; j < n; ++j) {\n+            solved[j] = secondRow[j - 1].multiply(f);\n+        }\n+\n+        // update the matrix so it expects hy' in second element\n+        // rather than yk-(n-1) in last elements when post-multiplied\n+        for (int i = 0; i < n; ++i) {\n+            final BigFraction[] rowI = array[i];\n+            final BigFraction last = rowI[n - 1];\n+            for (int j = n - 1; j > 1; --j) {\n+                rowI[j] = rowI[j - 1].add(last.multiply(solved[j]));\n+            }\n+            rowI[1] = last.multiply(solved[1]);\n+            rowI[0] = rowI[0].add(last.multiply(solved[0]));\n+        }\n+\n+    }\n+\n+    /**\n+     * Transform a scalar state history from multistep form to Nordsieck form.\n+     * <p>\n+     * The input state history must be in multistep form with element 0 for\n+     * current state, element 1 for current state scaled first derivative, element\n+     * 2 for previous state ... element n-1 for (n-2)<sup>th</sup> previous state.\n+     * The output state history will be in Nordsieck form with element 0 for\n+     * current state, element 1 for current state scaled first derivative, element\n+     * 2 for current state scaled second derivative ... element n-1 for current state\n+     * scaled (n-1)<sup>th</sup> derivative.\n+     * </p>\n+     * @param multistepHistory scalar state history in multistep form\n+     * @return scalar state history in Nordsieck form\n+     */\n+    public double[] multistepToNordsieck(final double[] multistepHistory) {\n+        return matMtoN.operate(multistepHistory);\n+    }\n+\n+    /**\n+     * Transform a vectorial state history from multistep form to Nordsieck form.\n+     * <p>\n+     * The input state history must be in multistep form with row 0 for\n+     * current state, row 1 for current state scaled first derivative, row\n+     * 2 for previous state ... row n-1 for (n-2)<sup>th</sup> previous state.\n+     * The output state history will be in Nordsieck form with row 0 for\n+     * current state, row 1 for current state scaled first derivative, row\n+     * 2 for current state scaled second derivative ... row n-1 for current state\n+     * scaled (n-1)<sup>th</sup> derivative.\n+     * </p>\n+     * @param multistepHistory vectorial state history in multistep form\n+     * @return vectorial state history in Nordsieck form\n+     */\n+    public RealMatrix multistepToNordsieck(final RealMatrix multistepHistory) {\n+        return matMtoN.multiply(multistepHistory);\n+    }\n+\n+    /**\n+     * Transform a scalar state history from Nordsieck form to multistep form.\n+     * <p>\n+     * The input state history must be in Nordsieck form with element 0 for\n+     * current state, element 1 for current state scaled first derivative, element\n+     * 2 for current state scaled second derivative ... element n-1 for current state\n+     * scaled (n-1)<sup>th</sup> derivative.\n+     * The output state history will be in multistep form with element 0 for\n+     * current state, element 1 for current state scaled first derivative, element\n+     * 2 for previous state ... element n-1 for (n-2)<sup>th</sup> previous state.\n+     * </p>\n+     * @param nordsieckHistory scalar state history in Nordsieck form\n+     * @return scalar state history in multistep form\n+     */\n+    public double[] nordsieckToMultistep(final double[] nordsieckHistory) {\n+        return matNtoM.operate(nordsieckHistory);\n+    }\n+\n+    /**\n+     * Transform a vectorial state history from Nordsieck form to multistep form.\n+     * <p>\n+     * The input state history must be in Nordsieck form with row 0 for\n+     * current state, row 1 for current state scaled first derivative, row\n+     * 2 for current state scaled second derivative ... row n-1 for current state\n+     * scaled (n-1)<sup>th</sup> derivative.\n+     * The output state history will be in multistep form with row 0 for\n+     * current state, row 1 for current state scaled first derivative, row\n+     * 2 for previous state ... row n-1 for (n-2)<sup>th</sup> previous state.\n+     * </p>\n+     * @param nordsieckHistory vectorial state history in Nordsieck form\n+     * @return vectorial state history in multistep form\n+     */\n+    public RealMatrix nordsieckToMultistep(final RealMatrix nordsieckHistory) {\n+        return matNtoM.multiply(nordsieckHistory);\n+    }\n+\n+    /**\n+     * Transform a scalar state history from multistep without derivatives form\n+     * to Nordsieck form.\n+     * <p>\n+     * The input state history must be in multistep without derivatives form with\n+     * element 0 for current state, element 1 for previous state ... element n-1\n+     * for (n-1)<sup>th</sup> previous state.\n+     * The output state history will be in Nordsieck form with element 0 for\n+     * current state, element 1 for current state scaled first derivative, element\n+     * 2 for current state scaled second derivative ... element n-1 for current state\n+     * scaled (n-1)<sup>th</sup> derivative.\n+     * </p>\n+     * @param mwdHistory scalar state history in multistep without derivatives form\n+     * @return scalar state history in Nordsieck form\n+     */\n+    public double[] multistepWithoutDerivativesToNordsieck(final double[] mwdHistory) {\n+        return matMWDtoN.operate(mwdHistory);\n+    }\n+\n+    /**\n+     * Transform a vectorial state history from multistep without derivatives form\n+     * to Nordsieck form.\n+     * <p>\n+     * The input state history must be in multistep without derivatives form with\n+     * row 0 for current state, row 1 for previous state ... row n-1\n+     * for (n-1)<sup>th</sup> previous state.\n+     * The output state history will be in Nordsieck form with row 0 for\n+     * current state, row 1 for current state scaled first derivative, row\n+     * 2 for current state scaled second derivative ... row n-1 for current state\n+     * scaled (n-1)<sup>th</sup> derivative.\n+     * </p>\n+     * @param mwdHistory vectorial state history in multistep without derivatives form\n+     * @return vectorial state history in Nordsieck form\n+     */\n+    public RealMatrix multistepWithoutDerivativesToNordsieck(final RealMatrix mwdHistory) {\n+        return matMWDtoN.multiply(mwdHistory);\n+    }\n+\n+    /**\n+     * Transform a scalar state history from Nordsieck form to multistep without\n+     * derivatives form.\n+     * <p>\n+     * The input state history must be in Nordsieck form with element 0 for\n+     * current state, element 1 for current state scaled first derivative, element\n+     * 2 for current state scaled second derivative ... element n-1 for current state\n+     * scaled (n-1)<sup>th</sup> derivative.\n+     * The output state history will be in multistep without derivatives form with\n+     * element 0 for current state, element 1 for previous state ... element n-1\n+     * for (n-1)<sup>th</sup> previous state.\n+     * </p>\n+     * @param nordsieckHistory scalar state history in Nordsieck form\n+     * @return scalar state history in multistep without derivatives form\n+     */\n+    public double[] nordsieckToMultistepWithoutDerivatives(final double[] nordsieckHistory) {\n+        return matNtoMWD.operate(nordsieckHistory);\n+    }\n+\n+    /**\n+     * Transform a vectorial state history from Nordsieck form to multistep without\n+     * derivatives form.\n+     * <p>\n+     * The input state history must be in Nordsieck form with row 0 for\n+     * current state, row 1 for current state scaled first derivative, row\n+     * 2 for current state scaled second derivative ... row n-1 for current state\n+     * scaled (n-1)<sup>th</sup> derivative.\n+     * The output state history will be in multistep without derivatives form with\n+     * row 0 for current state, row 1 for previous state ... row n-1\n+     * for (n-1)<sup>th</sup> previous state.\n+     * </p>\n+     * @param nordsieckHistory vectorial state history in Nordsieck form\n+     * @return vectorial state history in multistep without derivatives form\n+     */\n+    public RealMatrix nordsieckToMultistepWithoutDerivatives(final RealMatrix nordsieckHistory) {\n+        return matNtoMWD.multiply(nordsieckHistory);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/NordsieckTransformerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import java.math.BigInteger;\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math.fraction.BigFraction;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.RealMatrixImpl;\n+\n+public class NordsieckTransformerTest\n+extends TestCase {\n+\n+    public NordsieckTransformerTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testDimension2() {\n+        NordsieckTransformer transformer = new NordsieckTransformer(2);\n+        double[] nordsieckHistory = new double[] { 1.0,  2.0 };\n+        double[] mwdHistory       = new double[] { 1.0, -1.0 };\n+        double[] multistepHistory = new double[] { 1.0,  2.0 };\n+        checkVector(nordsieckHistory, transformer.multistepWithoutDerivativesToNordsieck(mwdHistory));\n+        checkVector(mwdHistory, transformer.nordsieckToMultistepWithoutDerivatives(nordsieckHistory));\n+        checkVector(nordsieckHistory, transformer.multistepToNordsieck(multistepHistory));\n+        checkVector(multistepHistory, transformer.nordsieckToMultistep(nordsieckHistory));\n+    }\n+\n+    public void testDimension3() {\n+        NordsieckTransformer transformer = new NordsieckTransformer(3);\n+        double[] nordsieckHistory = new double[] { 1.0,  4.0, 18.0 };\n+        double[] mwdHistory       = new double[] { 1.0, 15.0, 65.0 };\n+        double[] multistepHistory = new double[] { 1.0,  4.0, 15.0 };\n+        checkVector(nordsieckHistory, transformer.multistepWithoutDerivativesToNordsieck(mwdHistory));\n+        checkVector(mwdHistory, transformer.nordsieckToMultistepWithoutDerivatives(nordsieckHistory));\n+        checkVector(nordsieckHistory, transformer.multistepToNordsieck(multistepHistory));\n+        checkVector(multistepHistory, transformer.nordsieckToMultistep(nordsieckHistory));\n+    }\n+\n+    public void testDimension7() {\n+        NordsieckTransformer transformer = new NordsieckTransformer(7);\n+        RealMatrix nordsieckHistory =\n+            new RealMatrixImpl(new double[][] {\n+                                   {  1,  2,  3 },\n+                                   { -2,  1,  0 },\n+                                   {  1,  1,  1 },\n+                                   {  0, -1,  1 },\n+                                   {  1, -1,  2 },\n+                                   {  2,  0,  1 },\n+                                   {  1,  1,  2 }\n+                                }, false);\n+        RealMatrix mwdHistory       =\n+            new RealMatrixImpl(new double[][] {\n+                                   {     1,     2,     3 },\n+                                   {     4,     3,     6 },\n+                                   {    25,    60,   127 },\n+                                   {   340,   683,  1362 },\n+                                   {  2329,  3918,  7635 },\n+                                   { 10036, 15147, 29278 },\n+                                   { 32449, 45608, 87951 }\n+                               }, false);\n+        RealMatrix multistepHistory =\n+            new RealMatrixImpl(new double[][] {\n+                                   {     1,     2,     3 },\n+                                   {    -2,     1,     0 },\n+                                   {     4,     3,     6 },\n+                                   {    25,    60,   127 },\n+                                   {   340,   683,  1362 },\n+                                   {  2329,  3918,  7635 },\n+                                   { 10036, 15147, 29278 }\n+                               }, false);\n+\n+        RealMatrix m = transformer.multistepWithoutDerivativesToNordsieck(mwdHistory);\n+        assertEquals(0.0, m.subtract(nordsieckHistory).getNorm(), 1.0e-11);\n+        m = transformer.nordsieckToMultistepWithoutDerivatives(nordsieckHistory);\n+        assertEquals(0.0, m.subtract(mwdHistory).getNorm(), 1.0e-11);\n+        m = transformer.multistepToNordsieck(multistepHistory);\n+        assertEquals(0.0, m.subtract(nordsieckHistory).getNorm(), 1.0e-11);\n+        m = transformer.nordsieckToMultistep(nordsieckHistory);\n+        assertEquals(0.0, m.subtract(multistepHistory).getNorm(), 1.0e-11);\n+\n+    }\n+\n+    public void testInverseWithoutDerivatives() {\n+        for (int n = 1; n < 20; ++n) {\n+            BigInteger[][] nTom =\n+                NordsieckTransformer.buildNordsieckToMultistepWithoutDerivatives(n);\n+            BigFraction[][] mTon =\n+                NordsieckTransformer.buildMultistepWithoutDerivativesToNordsieck(n);\n+            for (int i = 0; i < n; ++i) {\n+                for (int j = 0; j < n; ++j) {\n+                    BigFraction s = BigFraction.ZERO;\n+                    for (int k = 0; k < n; ++k) {\n+                        s = s.add(mTon[i][k].multiply(nTom[k][j]));\n+                    }\n+                    assertEquals((i == j) ? BigFraction.ONE : BigFraction.ZERO, s);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void testInverse() {\n+        for (int n = 1; n < 20; ++n) {\n+            BigInteger[][] nTom =\n+                NordsieckTransformer.buildNordsieckToMultistep(n);\n+            BigFraction[][] mTon =\n+                NordsieckTransformer.buildMultistepToNordsieck(n);\n+            for (int i = 0; i < n; ++i) {\n+                for (int j = 0; j < n; ++j) {\n+                    BigFraction s = BigFraction.ZERO;\n+                    for (int k = 0; k < n; ++k) {\n+                        s = s.add(mTon[i][k].multiply(nTom[k][j]));\n+                    }\n+                    assertEquals((i == j) ? BigFraction.ONE : BigFraction.ZERO, s);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void testMatrices1() {\n+        checkMatrix(1, new int[][] { { 1 } },\n+                    NordsieckTransformer.buildMultistepWithoutDerivativesToNordsieck(1));\n+        checkMatrix(new int[][] { { 1 } },\n+                    NordsieckTransformer.buildNordsieckToMultistepWithoutDerivatives(1));\n+        checkMatrix(1, new int[][] { { 1 } },\n+                    NordsieckTransformer.buildMultistepToNordsieck(1));\n+        checkMatrix(new int[][] { { 1 } },\n+                    NordsieckTransformer.buildNordsieckToMultistep(1));\n+    }\n+\n+    public void testMatrices2() {\n+        checkMatrix(1, new int[][] { { 1, 0 }, { 1, -1 } },\n+                    NordsieckTransformer.buildMultistepWithoutDerivativesToNordsieck(2));\n+        checkMatrix(new int[][] { { 1, 0 }, { 1, -1 } },\n+                    NordsieckTransformer.buildNordsieckToMultistepWithoutDerivatives(2));\n+        checkMatrix(1, new int[][] { { 1, 0 }, { 0, 1 } },\n+                    NordsieckTransformer.buildMultistepToNordsieck(2));\n+        checkMatrix(new int[][] { { 1, 0 }, { 0, 1 } },\n+                    NordsieckTransformer.buildNordsieckToMultistep(2));\n+    }\n+\n+    public void testMatrices3() {\n+        checkMatrix(2, new int[][] { { 2, 0, 0 }, { 3, -4, 1 }, { 1, -2, 1 } },\n+                    NordsieckTransformer.buildMultistepWithoutDerivativesToNordsieck(3));\n+        checkMatrix(new int[][] { { 1, 0, 0 }, { 1, -1, 1 }, { 1, -2, 4 } },\n+                    NordsieckTransformer.buildNordsieckToMultistepWithoutDerivatives(3));\n+        checkMatrix(1, new int[][] { { 1, 0, 0 }, { 0, 1, 0 }, { -1, 1, 1} },\n+                    NordsieckTransformer.buildMultistepToNordsieck(3));\n+        checkMatrix(new int[][] { { 1, 0, 0 }, { 0, 1, 0 }, { 1, -1, 1 } },\n+                    NordsieckTransformer.buildNordsieckToMultistep(3));\n+    }\n+\n+    public void testMatrices4() {\n+        checkMatrix(6, new int[][] { { 6, 0, 0, 0 }, { 11, -18, 9, -2 }, { 6, -15, 12, -3 }, { 1, -3, 3, -1 } },\n+                    NordsieckTransformer.buildMultistepWithoutDerivativesToNordsieck(4));\n+        checkMatrix(new int[][] { { 1, 0, 0, 0 }, { 1, -1, 1, -1 }, { 1, -2, 4, -8 }, { 1, -3, 9, -27 } },\n+                    NordsieckTransformer.buildNordsieckToMultistepWithoutDerivatives(4));\n+        checkMatrix(4, new int[][] { { 4, 0, 0, 0 }, { 0, 4, 0, 0 }, { -7, 6, 8, -1 }, { -3, 2, 4, -1 } },\n+                    NordsieckTransformer.buildMultistepToNordsieck(4));\n+        checkMatrix(new int[][] { { 1, 0, 0, 0 }, { 0, 1, 0, 0 }, { 1, -1, 1, -1 }, { 1, -2, 4, -8 } },\n+                    NordsieckTransformer.buildNordsieckToMultistep(4));\n+    }\n+\n+    public void testPolynomial() {\n+        Random r = new Random(1847222905841997856l);\n+        for (int n = 2; n < 9; ++n) {\n+\n+            // build a polynomial and its derivatives\n+            double[] coeffs = new double[n + 1];\n+            for (int i = 0; i < n; ++i) {\n+                coeffs[i] = 2 * r.nextDouble() - 1.0;\n+            }\n+            PolynomialFunction[] polynomials = new PolynomialFunction[n];\n+            polynomials[0] = new PolynomialFunction(coeffs);\n+            for (int k = 1; k < polynomials.length; ++k) {\n+                polynomials[k] = (PolynomialFunction) polynomials[k - 1].derivative();\n+            }\n+            double h = 0.01;\n+\n+            // build a state history in multistep form\n+            double[] multistepHistory = new double[n];\n+            multistepHistory[0] = polynomials[0].value(1.0);\n+            multistepHistory[1] = h * polynomials[1].value(1.0);\n+            for (int i = 2; i < multistepHistory.length; ++i) {\n+                multistepHistory[i] = polynomials[0].value(1.0 - (i - 1) * h);\n+            }\n+\n+            // build the same state history in multistep without derivatives form\n+            double[] mwdHistory = new double[n];\n+            for (int i = 0; i < multistepHistory.length; ++i) {\n+                mwdHistory[i] = polynomials[0].value(1.0 - i * h);\n+            }\n+\n+            // build the same state history in Nordsieck form\n+            double[] nordsieckHistory = new double[n];\n+            double scale = 1.0;\n+            for (int i = 0; i < nordsieckHistory.length; ++i) {\n+                nordsieckHistory[i] = scale * polynomials[i].value(1.0);\n+                scale *= h / (i + 1);\n+            }\n+\n+            // check the transform is exact for these polynomials states\n+            NordsieckTransformer transformer = new NordsieckTransformer(n);\n+            checkVector(nordsieckHistory, transformer.multistepWithoutDerivativesToNordsieck(mwdHistory));\n+            checkVector(mwdHistory,       transformer.nordsieckToMultistepWithoutDerivatives(nordsieckHistory));\n+            checkVector(nordsieckHistory, transformer.multistepToNordsieck(multistepHistory));\n+            checkVector(multistepHistory, transformer.nordsieckToMultistep(nordsieckHistory));\n+\n+        }\n+    }\n+\n+    private void checkVector(double[] reference, double[] candidate) {\n+        assertEquals(reference.length, candidate.length);\n+        for (int i = 0; i < reference.length; ++i) {\n+            assertEquals(reference[i], candidate[i], 1.0e-14);\n+        }\n+    }\n+\n+    private void checkMatrix(int[][] reference, BigInteger[][] candidate) {\n+        assertEquals(reference.length, candidate.length);\n+        for (int i = 0; i < reference.length; ++i) {\n+            int[] rRow = reference[i];\n+            BigInteger[] cRow = candidate[i];\n+            assertEquals(rRow.length, cRow.length);\n+            for (int j = 0; j < rRow.length; ++j) {\n+                assertEquals(rRow[j], cRow[j].intValue());\n+            }\n+        }\n+    }\n+\n+    private void checkMatrix(int denominator, int[][] reference, BigFraction[][] candidate) {\n+        assertEquals(reference.length, candidate.length);\n+        for (int i = 0; i < reference.length; ++i) {\n+            int[] rRow = reference[i];\n+            BigFraction[] cRow = candidate[i];\n+            assertEquals(rRow.length, cRow.length);\n+            for (int j = 0; j < rRow.length; ++j) {\n+                assertEquals(new BigFraction(rRow[j], denominator), cRow[j]);\n+            }\n+        }\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(NordsieckTransformerTest.class);\n+      }\n+\n+}", "timestamp": 1239290591, "metainfo": ""}