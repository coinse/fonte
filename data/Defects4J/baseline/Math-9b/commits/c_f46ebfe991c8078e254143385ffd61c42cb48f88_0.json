{"sha": "f46ebfe991c8078e254143385ffd61c42cb48f88", "log": "Remove unnecessary casts  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n    */\n   @Override\n   public Object[][] getContents() {\n-    return (Object[][]) contents.clone();\n+    return contents.clone();\n   }\n \n   /** Non-translated/translated messages arrays. */\n--- a/src/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n+++ b/src/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n         }\n         double[] result = new double[n - 1];\n         for (int i = n - 1; i  > 0; i--) {\n-            result[i - 1] = (double) i * coefficients[i];\n+            result[i - 1] = i * coefficients[i];\n         }\n         return result;\n     }\n--- a/src/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n             throw new IllegalArgumentException\n                 (\"Polynomial degree must be positive: degree=\" + n);\n         }\n-        Complex N = new Complex((double)n, 0.0);\n-        Complex N1 = new Complex((double)(n-1), 0.0);\n+        Complex N = new Complex(n, 0.0);\n+        Complex N1 = new Complex((n-1), 0.0);\n \n         int i = 1;\n         Complex pv = null;\n--- a/src/java/org/apache/commons/math/estimation/SimpleEstimationProblem.java\n+++ b/src/java/org/apache/commons/math/estimation/SimpleEstimationProblem.java\n      * @return parameters\n      */\n     public EstimatedParameter[] getAllParameters() {\n-        return (EstimatedParameter[]) parameters.toArray(new EstimatedParameter[parameters.size()]);\n+        return parameters.toArray(new EstimatedParameter[parameters.size()]);\n     }\n \n     /** \n         }\n \n         // convert to an array\n-        return (EstimatedParameter[]) unbound.toArray(new EstimatedParameter[unbound.size()]);\n+        return unbound.toArray(new EstimatedParameter[unbound.size()]);\n         \n     }\n \n      * @return measurements\n      */\n     public WeightedMeasurement[] getMeasurements() {\n-        return (WeightedMeasurement[]) measurements.toArray(new WeightedMeasurement[measurements.size()]);\n+        return measurements.toArray(new WeightedMeasurement[measurements.size()]);\n     }\n \n     /** Add a parameter to the problem.\n--- a/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n+++ b/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n         throw new IllegalArgumentException(\"propagation direction mismatch\");\n       }\n \n-      final StepInterpolator lastInterpolator = (StepInterpolator) steps.get(index);\n+      final StepInterpolator lastInterpolator = steps.get(index);\n       final double current  = lastInterpolator.getCurrentTime();\n       final double previous = lastInterpolator.getPreviousTime();\n       final double step = current - previous;\n     }\n \n     index = steps.size() - 1;\n-    finalTime = ((StepInterpolator) steps.get(index)).getCurrentTime();\n+    finalTime = (steps.get(index)).getCurrentTime();\n \n   }\n \n--- a/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n \n     } else {\n \n-      v1 = (double[]) interpolator.v1.clone();\n-      v2 = (double[]) interpolator.v2.clone();\n-      v3 = (double[]) interpolator.v3.clone();\n-      v4 = (double[]) interpolator.v4.clone();\n+      v1 = interpolator.v1.clone();\n+      v2 = interpolator.v2.clone();\n+      v3 = interpolator.v3.clone();\n+      v4 = interpolator.v4.clone();\n       vectorsInitialized = interpolator.vectorsInitialized;\n \n     }\n--- a/src/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n     interpolatedTime  = interpolator.interpolatedTime;\n \n     if (interpolator.currentState != null) {\n-      currentState            = (double[]) interpolator.currentState.clone();\n-      interpolatedState       = (double[]) interpolator.interpolatedState.clone();\n-      interpolatedDerivatives = (double[]) interpolator.interpolatedDerivatives.clone();\n+      currentState            = interpolator.currentState.clone();\n+      interpolatedState       = interpolator.interpolatedState.clone();\n+      interpolatedDerivatives = interpolator.interpolatedDerivatives.clone();\n     } else {\n       currentState            = null;\n       interpolatedState       = null;\n--- a/src/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizer.java\n         if (optima == null) {\n             throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n         }\n-        return (RealPointValuePair[]) optima.clone();\n+        return optima.clone();\n     }\n \n     /** {@inheritDoc} */\n--- a/src/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizer.java\n         if (optima == null) {\n             throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n         }\n-        return (VectorialPointValuePair[]) optima.clone();\n+        return optima.clone();\n     }\n \n     /** {@inheritDoc} */\n--- a/src/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizer.java\n         if (optima == null) {\n             throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n         }\n-        return (RealPointValuePair[]) optima.clone();\n+        return optima.clone();\n     }\n \n     /** {@inheritDoc} */\n--- a/src/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n+++ b/src/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n         if (mean.length != order) {\n             throw new DimensionMismatchException(mean.length, order);\n         }\n-        this.mean = (double[]) mean.clone();\n+        this.mean = mean.clone();\n \n         decompose(covariance, small);\n \n--- a/src/java/org/apache/commons/math/random/UncorrelatedRandomVectorGenerator.java\n+++ b/src/java/org/apache/commons/math/random/UncorrelatedRandomVectorGenerator.java\n     if (mean.length != standardDeviation.length) {\n       throw new IllegalArgumentException(\"dimension mismatch\");\n     }\n-    this.mean              = (double[]) mean.clone();\n-    this.standardDeviation = (double[]) standardDeviation.clone();\n+    this.mean              = mean.clone();\n+    this.standardDeviation = standardDeviation.clone();\n     this.generator = generator;\n   }\n \n--- a/src/java/org/apache/commons/math/stat/StatUtils.java\n+++ b/src/java/org/apache/commons/math/stat/StatUtils.java\n      */\n     public static double meanDifference(final double[] sample1, final double[] sample2)\n     throws IllegalArgumentException {\n-        return sumDifference(sample1, sample2) / (double) sample1.length;\n+        return sumDifference(sample1, sample2) / sample1.length;\n     }\n     \n     /**\n             sum1 += (diff - meanDifference) *(diff - meanDifference);\n             sum2 += diff - meanDifference;\n         }\n-        return (sum1 - (sum2 * sum2 / (double) n)) / (double) (n - 1);\n+        return (sum1 - (sum2 * sum2 / n)) / (n - 1);\n     }      \n     \n }\n--- a/src/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n      * @return the StorelessUnivariateStatistic implementing the sum\n      */\n     public StorelessUnivariateStatistic[] getSumImpl() {\n-        return (StorelessUnivariateStatistic[]) sumImpl.clone();\n+        return sumImpl.clone();\n     }\n \n     /**\n      * @return the StorelessUnivariateStatistic implementing the sum of squares\n      */\n     public StorelessUnivariateStatistic[] getSumsqImpl() {\n-        return (StorelessUnivariateStatistic[]) sumSqImpl.clone();\n+        return sumSqImpl.clone();\n     }\n \n     /**\n      * @return the StorelessUnivariateStatistic implementing the minimum\n      */\n     public StorelessUnivariateStatistic[] getMinImpl() {\n-        return (StorelessUnivariateStatistic[]) minImpl.clone();\n+        return minImpl.clone();\n     }\n \n     /**\n      * @return the StorelessUnivariateStatistic implementing the maximum\n      */\n     public StorelessUnivariateStatistic[] getMaxImpl() {\n-        return (StorelessUnivariateStatistic[]) maxImpl.clone();\n+        return maxImpl.clone();\n     }\n \n     /**\n      * @return the StorelessUnivariateStatistic implementing the log sum\n      */\n     public StorelessUnivariateStatistic[] getSumLogImpl() {\n-        return (StorelessUnivariateStatistic[]) sumLogImpl.clone();\n+        return sumLogImpl.clone();\n     }\n \n     /**\n      * @return the StorelessUnivariateStatistic implementing the geometric mean\n      */\n     public StorelessUnivariateStatistic[] getGeoMeanImpl() {\n-        return (StorelessUnivariateStatistic[]) geoMeanImpl.clone();\n+        return geoMeanImpl.clone();\n     }\n \n     /**\n      * @return the StorelessUnivariateStatistic implementing the mean\n      */\n     public StorelessUnivariateStatistic[] getMeanImpl() {\n-        return (StorelessUnivariateStatistic[]) meanImpl.clone();\n+        return meanImpl.clone();\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/FirstMoment.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/FirstMoment.java\n             m1 = 0.0;\n         }\n         n++;\n-        double n0 = (double) n;\n+        double n0 = n;\n         dev = d - m1;\n         nDev = dev / n0;\n         m1 += nDev;\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/FourthMoment.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/FourthMoment.java\n         \n         super.increment(d);\n         \n-        double n0 = (double) n;\n+        double n0 = n;\n \n         m4 = m4 - 4.0 * nDev * prevM3 + 6.0 * nDevSq * prevM2 +\n             ((n0 * n0) - 3 * (n0 -1)) * (nDevSq * nDevSq * (n0 - 1) * n0);\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n     @Override\n     public double getResult() {\n         if (sumOfLogs.getN() > 0) {\n-            return Math.exp(sumOfLogs.getResult() / (double) sumOfLogs.getN());\n+            return Math.exp(sumOfLogs.getResult() / sumOfLogs.getN());\n         } else {\n             return Double.NaN;\n         }\n     public double evaluate(\n         final double[] values, final int begin, final int length) {\n         return Math.exp(\n-            sumOfLogs.evaluate(values, begin, length) / (double) length);\n+            sumOfLogs.evaluate(values, begin, length) / length);\n     }\n     \n     /**\n      * @throws NullPointerException if either source or dest is null\n      */\n     public static void copy(GeometricMean source, GeometricMean dest) {\n-        dest.sumOfLogs = (SumOfLogs) source.sumOfLogs.copy();\n+        dest.sumOfLogs = source.sumOfLogs.copy();\n     }\n     \n     \n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n     public double getResult() {\n         double kurtosis = Double.NaN;\n         if (moment.getN() > 3) {\n-            double variance = moment.m2 / (double) (moment.n - 1);\n+            double variance = moment.m2 / (moment.n - 1);\n                 if (moment.n <= 3 || variance < 10E-20) {\n                     kurtosis = 0.0;\n                 } else {\n-                    double n = (double) moment.n;\n+                    double n = moment.n;\n                     kurtosis =\n                         (n * (n + 1) * moment.m4 -\n                                 3 * moment.m2 * moment.m2 * (n - 1)) /\n      * @throws NullPointerException if either source or dest is null\n      */\n     public static void copy(Kurtosis source, Kurtosis dest) {\n-        dest.moment = (FourthMoment) source.moment.copy();\n+        dest.moment = source.moment.copy();\n         dest.incMoment = source.incMoment;\n     }\n \n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n     public double evaluate(final double[] values,final int begin, final int length) {\n         if (test(values, begin, length)) {\n             Sum sum = new Sum();\n-            double sampleSize = (double) length;\n+            double sampleSize = length;\n             \n             // Compute initial estimate using definitional formula\n             double xbar = sum.evaluate(values, begin, length) / sampleSize;\n      */\n     public static void copy(Mean source, Mean dest) {\n         dest.incMoment = source.incMoment;\n-        dest.moment = (FirstMoment) source.moment.copy();\n+        dest.moment = source.moment.copy();\n     }\n }\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n         if (moment.n < 3) {\n             return Double.NaN;\n         }\n-        double variance = moment.m2 / (double) (moment.n - 1);\n+        double variance = moment.m2 / (moment.n - 1);\n         if (variance < 10E-20) {\n             return 0.0d;\n         } else {\n-            double n0 = (double) moment.getN();\n+            double n0 = moment.getN();\n             return  (n0 * moment.m3) /\n             ((n0 - 1) * (n0 -2) * Math.sqrt(variance) * variance);\n         }\n                 accum += Math.pow((values[i] - m), 2.0);\n                 accum2 += (values[i] - m);\n             }\n-            double stdDev = Math.sqrt((accum - (Math.pow(accum2, 2) / ((double) length))) /\n-                    (double) (length - 1));\n+            double stdDev = Math.sqrt((accum - (Math.pow(accum2, 2) / (length))) /\n+                    (length - 1));\n             \n             double accum3 = 0.0;\n             for (int i = begin; i < begin + length; i++) {\n      * @throws NullPointerException if either source or dest is null\n      */\n     public static void copy(Skewness source, Skewness dest) {\n-        dest.moment = new ThirdMoment((ThirdMoment) source.moment.copy());\n+        dest.moment = new ThirdMoment(source.moment.copy());\n         dest.incMoment = source.incMoment;\n     }\n }\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java\n      * @throws NullPointerException if either source or dest is null\n      */\n     public static void copy(StandardDeviation source, StandardDeviation dest) {\n-        dest.variance = (Variance) source.variance.copy();\n+        dest.variance = source.variance.copy();\n     }\n     \n }\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/ThirdMoment.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/ThirdMoment.java\n         double prevM2 = m2;\n         super.increment(d);\n         nDevSq = nDev * nDev;\n-        double n0 = (double) n;\n+        double n0 = n;\n         m3 = m3 - 3.0 * nDev * prevM2 + (n0 - 1) * (n0 - 2) * nDevSq * dev;\n     }\n \n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n                 return 0d;\n             } else {\n                 if (isBiasCorrected) {\n-                    return moment.m2 / ((double) moment.n - 1d);\n+                    return moment.m2 / (moment.n - 1d);\n                 } else {\n-                    return moment.m2 / ((double) moment.n);\n+                    return moment.m2 / (moment.n);\n                 }\n             }\n     }\n                     accum += dev * dev;\n                     accum2 += dev;\n                 }\n-                double len = (double) length;            \n+                double len = length;            \n                 if (isBiasCorrected) {\n                     var = (accum - (accum2 * accum2 / len)) / (len - 1.0);\n                 } else {\n      * @throws NullPointerException if either source or dest is null\n      */\n     public static void copy(Variance source, Variance dest) {\n-        dest.moment = (SecondMoment) source.moment.copy();\n+        dest.moment = source.moment.copy();\n         dest.isBiasCorrected = source.isBiasCorrected;\n         dest.incMoment = source.incMoment;\n     }\n--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n         if (length == 1) {\n             return values[begin]; // always return single value for n = 1\n         }\n-        double n = (double) length;\n+        double n = length;\n         double pos = p * (n + 1) / 100;\n         double fpos = Math.floor(pos);\n         int intPos = (int) fpos;\n--- a/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n+++ b/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n         double dev = 0.0d;\n         for (int i = 0; i < observed.length; i++) {\n             if (rescale) {\n-                dev = ((double) observed[i] - ratio * expected[i]);\n+                dev = (observed[i] - ratio * expected[i]);\n                 sumSq += dev * dev / (ratio * expected[i]);\n             } else {\n-                dev = ((double) observed[i] - expected[i]);\n+                dev = (observed[i] - expected[i]);\n                 sumSq += dev * dev / expected[i];\n             }\n         }\n         double total = 0.0d;\n         for (int row = 0; row < nRows; row++) {\n             for (int col = 0; col < nCols; col++) {\n-                rowSum[row] += (double) counts[row][col];\n-                colSum[col] += (double) counts[row][col];\n-                total += (double) counts[row][col];\n+                rowSum[row] += counts[row][col];\n+                colSum[col] += counts[row][col];\n+                total += counts[row][col];\n             }\n         }\n         \n         for (int row = 0; row < nRows; row++) {\n             for (int col = 0; col < nCols; col++) {\n                 expected = (rowSum[row] * colSum[col]) / total;\n-                sumSq += (((double) counts[row][col] - expected) * \n-                        ((double) counts[row][col] - expected)) / expected; \n+                sumSq += ((counts[row][col] - expected) * \n+                        (counts[row][col] - expected)) / expected; \n             }\n         } \n         return sumSq;\n                 throw new IllegalArgumentException(\n                         \"observed counts must not both be zero\");\n             } else {\n-                obs1 = (double) observed1[i];\n-                obs2 = (double) observed2[i];\n+                obs1 = observed1[i];\n+                obs2 = observed2[i];\n                 if (unequalCounts) { // apply weights\n                     dev = obs1/weight - obs2 * weight;\n                 } else {\n--- a/src/java/org/apache/commons/math/stat/inference/TTestImpl.java\n+++ b/src/java/org/apache/commons/math/stat/inference/TTestImpl.java\n         double meanDifference = StatUtils.meanDifference(sample1, sample2);\n         return t(meanDifference, 0,  \n                 StatUtils.varianceDifference(sample1, sample2, meanDifference),\n-                (double) sample1.length);\n+                sample1.length);\n     }\n \n      /**\n         double meanDifference = StatUtils.meanDifference(sample1, sample2);\n         return tTest(meanDifference, 0, \n                 StatUtils.varianceDifference(sample1, sample2, meanDifference), \n-                (double) sample1.length);\n+                sample1.length);\n     }\n \n      /**\n         }\n         return homoscedasticT(StatUtils.mean(sample1), StatUtils.mean(sample2),\n                 StatUtils.variance(sample1), StatUtils.variance(sample2),\n-                (double) sample1.length, (double) sample2.length);\n+                sample1.length, sample2.length);\n     }\n     \n     /**\n         }\n         return t(StatUtils.mean(sample1), StatUtils.mean(sample2),\n                 StatUtils.variance(sample1), StatUtils.variance(sample2),\n-                (double) sample1.length, (double) sample2.length);\n+                sample1.length, sample2.length);\n     }\n \n     /**\n         }\n         return t(sampleStats1.getMean(), sampleStats2.getMean(), \n                 sampleStats1.getVariance(), sampleStats2.getVariance(),\n-                (double) sampleStats1.getN(), (double) sampleStats2.getN());\n+                sampleStats1.getN(), sampleStats2.getN());\n     }\n     \n     /**\n         }\n         return homoscedasticT(sampleStats1.getMean(), sampleStats2.getMean(), \n                 sampleStats1.getVariance(), sampleStats2.getVariance(), \n-                (double) sampleStats1.getN(), (double) sampleStats2.getN());\n+                sampleStats1.getN(), sampleStats2.getN());\n     }\n \n      /**\n         }\n         return tTest(StatUtils.mean(sample1), StatUtils.mean(sample2),\n                 StatUtils.variance(sample1), StatUtils.variance(sample2),\n-                (double) sample1.length, (double) sample2.length);\n+                sample1.length, sample2.length);\n     }\n     \n     /**\n         }\n         return homoscedasticTTest(StatUtils.mean(sample1), \n                 StatUtils.mean(sample2), StatUtils.variance(sample1),\n-                StatUtils.variance(sample2), (double) sample1.length, \n-                (double) sample2.length);\n+                StatUtils.variance(sample2), sample1.length, \n+                sample2.length);\n     }\n     \n \n             throw new IllegalArgumentException(\"insufficient data for t statistic\");\n         }\n         return tTest(sampleStats1.getMean(), sampleStats2.getMean(), sampleStats1.getVariance(),\n-                sampleStats2.getVariance(), (double) sampleStats1.getN(), \n-                (double) sampleStats2.getN());\n+                sampleStats2.getVariance(), sampleStats1.getN(), \n+                sampleStats2.getN());\n     }\n     \n     /**\n         }\n         return homoscedasticTTest(sampleStats1.getMean(),\n                 sampleStats2.getMean(), sampleStats1.getVariance(),\n-                sampleStats2.getVariance(), (double) sampleStats1.getN(), \n-                (double) sampleStats2.getN());\n+                sampleStats2.getVariance(), sampleStats1.getN(), \n+                sampleStats2.getN());\n     }\n \n     /**\n             double v2, double n1, double n2)\n     throws MathException {\n         double t = Math.abs(homoscedasticT(m1, m2, v1, v2, n1, n2));\n-        double degreesOfFreedom = (double) (n1 + n2 - 2);\n+        double degreesOfFreedom = (n1 + n2 - 2);\n         distribution.setDegreesOfFreedom(degreesOfFreedom);\n         return 2.0 * distribution.cumulativeProbability(-t);\n     }\n--- a/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n         } else {\n             double dx = x - xbar;\n             double dy = y - ybar;\n-            sumXX += dx * dx * (double) n / (double) (n + 1.0);\n-            sumYY += dy * dy * (double) n / (double) (n + 1.0);\n-            sumXY += dx * dy * (double) n / (double) (n + 1.0);\n-            xbar += dx / (double) (n + 1.0);\n-            ybar += dy / (double) (n + 1.0);\n+            sumXX += dx * dx * n / (n + 1.0);\n+            sumYY += dy * dy * n / (n + 1.0);\n+            sumXY += dx * dy * n / (n + 1.0);\n+            xbar += dx / (n + 1.0);\n+            ybar += dy / (n + 1.0);\n         }\n         sumX += x;\n         sumY += y;\n         if (n > 0) {\n             double dx = x - xbar;\n             double dy = y - ybar;\n-            sumXX -= dx * dx * (double) n / (double) (n - 1.0);\n-            sumYY -= dy * dy * (double) n / (double) (n - 1.0);\n-            sumXY -= dx * dy * (double) n / (double) (n - 1.0);\n-            xbar -= dx / (double) (n - 1.0);\n-            ybar -= dy / (double) (n - 1.0);\n+            sumXX -= dx * dx * n / (n - 1.0);\n+            sumYY -= dy * dy * n / (n - 1.0);\n+            sumXY -= dx * dy * n / (n - 1.0);\n+            xbar -= dx / (n - 1.0);\n+            ybar -= dy / (n - 1.0);\n             sumX -= x;\n             sumY -= y;\n             n--;\n         if (n < 3) {\n             return Double.NaN;\n         }\n-        return getSumSquaredErrors() / (double) (n - 2);\n+        return getSumSquaredErrors() / (n - 2);\n     }\n \n     /**\n      */\n     public double getInterceptStdErr() {\n         return Math.sqrt(\n-            getMeanSquareError() * ((1d / (double) n) + (xbar * xbar) / sumXX));\n+            getMeanSquareError() * ((1d / n) + (xbar * xbar) / sumXX));\n     }\n \n     /**\n     * @return the intercept of the regression line\n     */\n     private double getIntercept(double slope) {\n-        return (sumY - slope * sumX) / ((double) n);\n+        return (sumY - slope * sumX) / (n);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n             return 0;\n         }\n         if ((k == 1) || (k == n - 1)) {\n-            return Math.log((double) n);\n+            return Math.log(n);\n         }\n         \n         /*\n \n         // n!/(n-k)!\n         for (int i = n - k + 1; i <= n; i++) {\n-            logSum += Math.log((double) i);\n+            logSum += Math.log(i);\n         }\n \n         // divide by k!\n         for (int i = 2; i <= k; i++) {\n-            logSum -= Math.log((double) i);\n+            logSum -= Math.log(i);\n         }\n \n         return logSum;      \n         }\n         double logSum = 0;\n         for (int i = 2; i <= n; i++) {\n-            logSum += Math.log((double)i);\n+            logSum += Math.log(i);\n         }\n         return logSum;\n     }\n--- a/src/java/org/apache/commons/math/util/TransformerMap.java\n+++ b/src/java/org/apache/commons/math/util/TransformerMap.java\n      * @return the mapped NumberTransformer or null.\n      */\n     public NumberTransformer getTransformer(Class<?> key) {\n-        return (NumberTransformer) map.get(key);\n+        return map.get(key);\n     }\n \n     /**", "timestamp": 1238950133, "metainfo": ""}