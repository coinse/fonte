{"sha": "a49a809e9ce54de4287e72ae9ebdb833432c8fec", "log": "Moved math 2.0 branch to trunk.  ", "commit": "\n--- a/src/experimental/org/apache/commons/math/function/DefaultContext.java\n+++ b/src/experimental/org/apache/commons/math/function/DefaultContext.java\n         }\n                 \n         DefaultValue(double d) {\n-            value = new Double(d);\n+            value = Double.valueOf(d);\n         }\n \n         DefaultValue(float f) {\n-            value = new Float(f);\n+            value = Float.valueOf(f);\n         }\n \n         DefaultValue(int i) {\n-            value = new Integer(i);\n+            value = Integer.valueOf(i);\n         }\n \n         DefaultValue(long l) {\n-            value = new Long(l);\n+            value = Long.valueOf(l);\n         }\n         \n         /* (non-Javadoc)\n--- a/src/experimental/org/apache/commons/math/stat/univariate/BeanListUnivariateImpl.java\n+++ b/src/experimental/org/apache/commons/math/stat/univariate/BeanListUnivariateImpl.java\n \t    } catch (Exception ex) {              // InstantiationException, IllegalAccessException\n \t        throw new RuntimeException(ex);   // should never happen\n \t    }\n-\t\tdynaBean.set(propertyName, new Double(v));\n+\t\tdynaBean.set(propertyName, Double.valueOf(v));\n \t\taddObject(dynaBean);\n \t}\n \n--- a/src/experimental/org/apache/commons/math/stat/univariate/BeanListUnivariateImplTest.java\n+++ b/src/experimental/org/apache/commons/math/stat/univariate/BeanListUnivariateImplTest.java\n         patientList = new ArrayList();\n \n         // Create and add patient bean 1\n-        VitalStats vs1 = new VitalStats( new Double(120.0), \n-                                         new Double(96.4) );\n-        Patient p1 = new Patient( vs1, new Integer( 35 ) );\n+        VitalStats vs1 = new VitalStats( Double.valueOf(120.0), \n+                                         Double.valueOf(96.4) );\n+        Patient p1 = new Patient( vs1, Integer.valueOf( 35 ) );\n         patientList.add( p1 );\n \n         // Create and add patient bean 2\n-        VitalStats vs2 = new VitalStats( new Double(70.0), \n-                                         new Double(97.4) );\n-        Patient p2 = new Patient( vs2, new Integer( 23 ) );\n+        VitalStats vs2 = new VitalStats( Double.valueOf(70.0), \n+                                         Double.valueOf(97.4) );\n+        Patient p2 = new Patient( vs2, Integer.valueOf( 23 ) );\n         patientList.add( p2 );\n \n         // Create and add patient bean 3\n-        VitalStats vs3 = new VitalStats( new Double(90.0), \n-                                         new Double(98.6) );\n-        Patient p3 = new Patient( vs3, new Integer( 42 ) );\n+        VitalStats vs3 = new VitalStats( Double.valueOf(90.0), \n+                                         Double.valueOf(98.6) );\n+        Patient p3 = new Patient( vs3, Integer.valueOf( 42 ) );\n         patientList.add( p3 );\n     }\n     \n--- a/src/java/org/apache/commons/math/ArgumentOutsideDomainException.java\n+++ b/src/java/org/apache/commons/math/ArgumentOutsideDomainException.java\n     public ArgumentOutsideDomainException(double argument, double lower, double upper) {\n         super(argument,\n               \"Argument {0} outside domain [{1} ; {2}]\",\n-              new Object[] { new Double(argument), new Double(lower), new Double(upper) });\n+              new Object[] { Double.valueOf(argument), Double.valueOf(lower), Double.valueOf(upper) });\n     }\n \n }\n--- a/src/java/org/apache/commons/math/ConvergenceException.java\n+++ b/src/java/org/apache/commons/math/ConvergenceException.java\n      * Default constructor.\n      */\n     public ConvergenceException() {\n-        super(\"Convergence failed\", new Object[0]);\n+        super(\"Convergence failed\", null);\n     }\n     \n     /**\n         super(pattern, arguments, cause);\n     }\n     \n-    /**\n-     * Constructs a new <code>ConvergenceException</code> with specified\n-     * detail message and nested <code>Throwable</code> root cause.\n-     *\n-     * @param msg  the error message.\n-     * @param rootCause  the exception or error that caused this exception\n-     * to be thrown.\n-     * @deprecated as of 1.2, replaced by \n-     * {@link #ConvergenceException(String, Object[], Throwable)}\n-     */\n-    public ConvergenceException(String msg, Throwable rootCause) {\n-        super(msg, rootCause);\n-    }\n-    \n-    /**\n-     * Constructs a new <code>ConvergenceException</code> with specified\n-     * detail message.\n-     *\n-     * @param msg  the error message.\n-     * @deprecated as of 1.2, replaced by \n-     * {@link #ConvergenceException(String, Object[])}\n-     */\n-    public ConvergenceException(String msg) {\n-        super(msg);\n-    }\n-\n }\n--- a/src/java/org/apache/commons/math/DimensionMismatchException.java\n+++ b/src/java/org/apache/commons/math/DimensionMismatchException.java\n     public DimensionMismatchException(int dimension1, int dimension2) {\n         super(\"dimension mismatch {0} != {1}\",\n               new Object[] {\n-                new Integer(dimension1), new Integer(dimension2)\n+                Integer.valueOf(dimension1), Integer.valueOf(dimension2)\n               });\n         this.dimension1 = dimension1;\n         this.dimension2 = dimension2;\n--- a/src/java/org/apache/commons/math/DuplicateSampleAbscissaException.java\n+++ b/src/java/org/apache/commons/math/DuplicateSampleAbscissaException.java\n      */\n     public DuplicateSampleAbscissaException(double abscissa, int i1, int i2) {\n         super(\"Abscissa {0} is duplicated at both indices {1} and {2}\",\n-              new Object[] { new Double(abscissa), new Integer(i1), new Integer(i2) });\n+              new Object[] { Double.valueOf(abscissa), Integer.valueOf(i1), Integer.valueOf(i2) });\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/FunctionEvaluationException.java\n+++ b/src/java/org/apache/commons/math/FunctionEvaluationException.java\n public class FunctionEvaluationException extends MathException  {\n     \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -7619974756160279127L;\n+    private static final long serialVersionUID = -2193260774031645876L;\n \n     /** Argument causing function evaluation failure */\n     private double argument = Double.NaN;\n      */\n     public FunctionEvaluationException(double argument) {\n         super(\"Evaluation failed for argument = {0}\",\n-              new Object[] { new Double(argument) });\n+              new Object[] { Double.valueOf(argument) });\n         this.argument = argument;\n     }\n     \n-    /**\n-     * Construct an exception using the given argument and message\n-     * text.\n-     * \n-     * @param argument  the failing function argument \n-     * @param message  the exception message text\n-     * @deprecated as of 1.2, replaced by {@link #FunctionEvaluationException(double, String, Object[])}\n-     */\n-    public FunctionEvaluationException(double argument, String message) {\n-        super(message);\n-        this.argument = argument;\n-    }\n-\n     /**\n      * Constructs an exception with specified formatted detail message.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n     public FunctionEvaluationException(double argument,\n                                        String pattern, Object[] arguments) {\n         super(pattern, arguments);\n-        this.argument = argument;\n-    }\n-\n-    /**\n-     * Construct an exception with the given argument, message and root cause.\n-     * \n-     * @param argument  the failing function argument \n-     * @param message descriptive error message\n-     * @param cause root cause.\n-     * @deprecated as of 1.2, replaced by {@link #FunctionEvaluationException(double, String, Object[], Throwable)}\n-     */\n-    public FunctionEvaluationException(double argument,\n-                                       String message, Throwable cause) {\n-        super(message, cause);\n         this.argument = argument;\n     }\n \n--- a/src/java/org/apache/commons/math/MathConfigurationException.java\n+++ b/src/java/org/apache/commons/math/MathConfigurationException.java\n public class MathConfigurationException extends MathException implements Serializable{\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -4056541384141349722L;\n+    private static final long serialVersionUID = 5261476508226103366L;\n+\n     /**\n      * Default constructor.\n      */\n         super();\n     }\n     \n-    /**\n-     * Construct an exception with the given message.\n-     * @param message descriptive error message\n-     * @deprecated as of 1.2, replaced by {@link #MathConfigurationException(String, Object[])}\n-     */\n-    public MathConfigurationException(String message) {\n-        super(message);\n-    }\n-\n     /**\n      * Constructs an exception with specified formatted detail message.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      */\n     public MathConfigurationException(String pattern, Object[] arguments) {\n         super(pattern, arguments);\n-    }\n-\n-    /**\n-     * Construct an exception with the given message and root cause.\n-     * @param message descriptive error message\n-     * @param cause  the exception or error that caused this exception to be thrown\n-     * @deprecated as of 1.2, replaced by {@link #MathConfigurationException(String, Object[], Throwable)}\n-     */\n-    public MathConfigurationException(String message, Throwable cause) {\n-        super(message, cause);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/MathException.java\n+++ b/src/java/org/apache/commons/math/MathException.java\n */\n public class MathException extends Exception {\n     \n-    /** Serializable version identifier */\n-    private static final long serialVersionUID = -8602234299177097102L;\n-\n-    /**\n-     * Does JDK support nested exceptions?\n-     */\n-    private static final boolean JDK_SUPPORTS_NESTED;\n-    \n-    static {\n-        boolean flag = false;\n-        try {\n-            Throwable.class.getDeclaredMethod(\"getCause\", new Class[0]);\n-            flag = true;\n-        } catch (NoSuchMethodException ex) {\n-            flag = false;\n-        }\n-        JDK_SUPPORTS_NESTED = flag;\n-    }\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 5924076008552401454L;\n \n     /** Cache for resources bundle. */\n     private static ResourceBundle cachedResources = null;\n      */\n     private final Object[] arguments;\n \n-    /**\n-     * Root cause of the exception\n-     */\n-    private final Throwable rootCause;\n-    \n     /**\n      * Translate a string to a given locale.\n      * @param s string to translate\n      * @return a message string\n      */\n     private static String buildMessage(String pattern, Object[] arguments, Locale locale) {\n-        // do it the hard way, for Java 1.3. compatibility\n-        MessageFormat mf = new MessageFormat(translate(pattern, locale));\n-        mf.setLocale(locale);\n-        return mf.format(arguments);        \n+        return (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);        \n     }\n \n     /**\n         super();\n         this.pattern   = null;\n         this.arguments = new Object[0];\n-        this.rootCause = null;\n-    }\n-    \n-    /**\n-     * Constructs a new <code>MathException</code> with specified\n-     * detail message.\n-     *\n-     * @param msg  the error message.\n-     * @deprecated as of 1.2, replaced by {@link #MathException(String, Object[])}\n-     */\n-    public MathException(String msg) {\n-        super(msg);\n-        this.pattern   = msg;\n-        this.arguments = new Object[0];\n-        this.rootCause = null;\n-    }\n-\n+    }\n+    \n     /**\n      * Constructs a new <code>MathException</code> with specified\n      * formatted detail message.\n     public MathException(String pattern, Object[] arguments) {\n       super(buildMessage(pattern, arguments, Locale.US));\n       this.pattern   = pattern;\n-      this.arguments = (Object[]) arguments.clone();\n-      this.rootCause = null;\n+      this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n     }\n \n     /**\n      *                   to be thrown.\n      */\n     public MathException(Throwable rootCause) {\n-        super((rootCause == null ? null : rootCause.getMessage()));\n+        super(rootCause);\n         this.pattern   = getMessage();\n         this.arguments = new Object[0];\n-        this.rootCause = rootCause;\n-    }\n-    \n-    /**\n-     * Constructs a new <code>MathException</code> with specified\n-     * detail message and nested <code>Throwable</code> root cause.\n-     *\n-     * @param msg  the error message.\n-     * @param rootCause  the exception or error that caused this exception\n-     *                   to be thrown.\n-     * @deprecated as of 1.2, replaced by {@link #MathException(String, Object[], Throwable)}\n-     */\n-    public MathException(String msg, Throwable rootCause) {\n-        super(msg);\n-        this.pattern   = msg;\n-        this.arguments = new Object[0];\n-        this.rootCause = rootCause;\n-    }\n-\n+    }\n+    \n     /**\n      * Constructs a new <code>MathException</code> with specified\n      * formatted detail message and nested <code>Throwable</code> root cause.\n      * @since 1.2\n      */\n     public MathException(String pattern, Object[] arguments, Throwable rootCause) {\n-      super(buildMessage(pattern, arguments, Locale.US));\n+      super(buildMessage(pattern, arguments, Locale.US), rootCause);\n       this.pattern   = pattern;\n-      this.arguments = (Object[]) arguments.clone();\n-      this.rootCause = rootCause;\n+      this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n     }\n \n     /** Gets the pattern used to build the message of this throwable.\n      * @since 1.2\n      */\n     public Object[] getArguments() {\n-        return (Object[]) arguments.clone();\n+        return arguments.clone();\n     }\n \n     /** Gets the message in a specified locale.\n      * @since 1.2\n      */\n     public String getMessage(Locale locale) {\n-        return (pattern == null) ? null : buildMessage(pattern, arguments, locale);\n-    }\n-\n-    /**\n-     * Gets the cause of this throwable.\n-     * \n-     * @return  the cause of this throwable, or <code>null</code>\n-     */\n-    public Throwable getCause() {\n-        return rootCause;\n-    }\n-    \n+        return buildMessage(pattern, arguments, locale);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public String getLocalizedMessage() {\n+        return getMessage(Locale.getDefault());\n+    }\n+\n     /**\n      * Prints the stack trace of this exception to the standard error stream.\n      */\n             pw.flush();\n         }\n     }\n-    \n-    /**\n-     * Prints the stack trace of this exception to the specified writer.\n-     *\n-     * @param out  the <code>PrintWriter</code> to use for output\n-     */\n-    public void printStackTrace(PrintWriter out) {\n-        synchronized (out) {\n-            super.printStackTrace(out);\n-            if (rootCause != null && JDK_SUPPORTS_NESTED == false) {\n-                out.print(\"Caused by: \");\n-                rootCause.printStackTrace(out);\n-            }\n-        }\n-    }\n \n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/MathRuntimeException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.util.Locale;\n+import java.util.MissingResourceException;\n+import java.util.ResourceBundle;\n+\n+/**\n+* Base class for commons-math unchecked exceptions.\n+* \n+* @version $Revision$ $Date$\n+* @since 2.0\n+*/\n+public class MathRuntimeException extends RuntimeException {\n+    \n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 8560172512507661982L;\n+\n+    /** Cache for resources bundle. */\n+    private static ResourceBundle cachedResources = null;\n+ \n+    /**\n+     * Pattern used to build the message.\n+     */\n+    private final String pattern;\n+\n+    /**\n+     * Arguments used to build the message.\n+     */\n+    private final Object[] arguments;\n+\n+    /**\n+     * Translate a string to a given locale.\n+     * @param s string to translate\n+     * @param locale locale into which to translate the string\n+     * @return translated string or original string\n+     * for unsupported locales or unknown strings\n+     */\n+    private static String translate(final String s, final Locale locale) {\n+        try {\n+            if ((cachedResources == null) || (! cachedResources.getLocale().equals(locale))) {\n+                // caching the resource bundle\n+                cachedResources =\n+                    ResourceBundle.getBundle(\"org.apache.commons.math.MessagesResources\", locale);\n+            }\n+\n+            if (cachedResources.getLocale().getLanguage().equals(locale.getLanguage())) {\n+                // the value of the resource is the translated string\n+                return cachedResources.getString(s);\n+            }\n+            \n+        } catch (MissingResourceException mre) {\n+            // do nothing here\n+        }\n+\n+        // the locale is not supported or the resource is unknown\n+        // don't translate and fall back to using the string as is\n+        return s;\n+\n+    }\n+\n+    /**\n+     * Builds a message string by from a pattern and its arguments.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @param locale Locale in which the message should be translated\n+     * @return a message string\n+     */\n+    private static String buildMessage(final String pattern, final Object[] arguments,\n+                                       final Locale locale) {\n+        return (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);        \n+    }\n+\n+    /**\n+     * Constructs a new <code>MathRuntimeException</code> with specified\n+     * formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public MathRuntimeException(final String pattern, final Object[] arguments) {\n+      super(buildMessage(pattern, arguments, Locale.US));\n+      this.pattern   = pattern;\n+      this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n+    }\n+\n+    /**\n+     * Constructs a new <code>MathRuntimeException</code> with specified\n+     * nested <code>Throwable</code> root cause.\n+     *\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public MathRuntimeException(final Throwable rootCause) {\n+        super(rootCause);\n+        this.pattern   = getMessage();\n+        this.arguments = new Object[0];\n+    }\n+    \n+    /**\n+     * Constructs a new <code>MathRuntimeException</code> with specified\n+     * formatted detail message and nested <code>Throwable</code> root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @param rootCause the exception or error that caused this exception\n+     * to be thrown.\n+     */\n+    public MathRuntimeException(final String pattern, final Object[] arguments,\n+                                final Throwable rootCause) {\n+      super(buildMessage(pattern, arguments, Locale.US), rootCause);\n+      this.pattern   = pattern;\n+      this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n+    }\n+\n+    /** Gets the pattern used to build the message of this throwable.\n+     *\n+     * @return the pattern used to build the message of this throwable\n+     */\n+    public String getPattern() {\n+        return pattern;\n+    }\n+\n+    /** Gets the arguments used to build the message of this throwable.\n+     *\n+     * @return the arguments used to build the message of this throwable\n+     */\n+    public Object[] getArguments() {\n+        return arguments.clone();\n+    }\n+\n+    /** Gets the message in a specified locale.\n+     *\n+     * @param locale Locale in which the message should be translated\n+     * \n+     * @return localized message\n+     */\n+    public String getMessage(final Locale locale) {\n+        return buildMessage(pattern, arguments, locale);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public String getLocalizedMessage() {\n+        return getMessage(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Prints the stack trace of this exception to the standard error stream.\n+     */\n+    public void printStackTrace() {\n+        printStackTrace(System.err);\n+    }\n+    \n+    /**\n+     * Prints the stack trace of this exception to the specified stream.\n+     *\n+     * @param out  the <code>PrintStream</code> to use for output\n+     */\n+    public void printStackTrace(final PrintStream out) {\n+        synchronized (out) {\n+            PrintWriter pw = new PrintWriter(out, false);\n+            printStackTrace(pw);\n+            // Flush the PrintWriter before it's GC'ed.\n+            pw.flush();\n+        }\n+    }\n+\n+    /**\n+     * Constructs a new <code>ArithmeticException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public static ArithmeticException createArithmeticException(final String pattern,\n+                                                                final Object[] arguments) {\n+        return new ArithmeticException(buildMessage(pattern, arguments, Locale.US)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = 7705628723242533939L;\n+\n+            /** {@inheritDoc} */\n+            public String getLocalizedMessage() {\n+                return buildMessage(pattern, arguments, Locale.getDefault());\n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     * Constructs a new <code>ArrayIndexOutOfBoundsException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public static ArrayIndexOutOfBoundsException createArrayIndexOutOfBoundsException(final String pattern,\n+                                                                                      final Object[] arguments) {\n+        return new ArrayIndexOutOfBoundsException(buildMessage(pattern, arguments, Locale.US)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = 8077627622976962141L;\n+\n+            /** {@inheritDoc} */\n+            public String getLocalizedMessage() {\n+                return buildMessage(pattern, arguments, Locale.getDefault());\n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     * Constructs a new <code>EOFException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public static EOFException createEOFException(final String pattern,\n+                                                  final Object[] arguments) {\n+        return new EOFException(buildMessage(pattern, arguments, Locale.US)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = 279461544586092584L;\n+\n+            /** {@inheritDoc} */\n+            public String getLocalizedMessage() {\n+                return buildMessage(pattern, arguments, Locale.getDefault());\n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     * Constructs a new <code>IOException</code> with specified nested\n+     * <code>Throwable</code> root cause.\n+     * <p>This factory method allows chaining of other exceptions within an\n+     * <code>IOException</code> even for Java 5. The constructor for\n+     * <code>IOException</code> with a cause parameter was introduced only\n+     * with Java 6.</p>\n+     * @param rootCause the exception or error that caused this exception\n+     * to be thrown.\n+     */\n+    public static IOException createIOException(final Throwable rootCause) {\n+        IOException ioe = new IOException(rootCause.getLocalizedMessage());\n+        ioe.initCause(rootCause);\n+        return ioe;\n+    }\n+\n+    /**\n+     * Constructs a new <code>IllegalArgumentException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public static IllegalArgumentException createIllegalArgumentException(final String pattern,\n+                                                                          final Object[] arguments) {\n+        return new IllegalArgumentException(buildMessage(pattern, arguments, Locale.US)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = -7537852425838457684L;\n+\n+            /** {@inheritDoc} */\n+            public String getLocalizedMessage() {\n+                return buildMessage(pattern, arguments, Locale.getDefault());\n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     * Constructs a new <code>IllegalStateException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public static IllegalStateException createIllegalStateException(final String pattern,\n+                                                                    final Object[] arguments) {\n+        return new IllegalStateException(buildMessage(pattern, arguments, Locale.US)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = 5173599768297434381L;\n+\n+            /** {@inheritDoc} */\n+            public String getLocalizedMessage() {\n+                return buildMessage(pattern, arguments, Locale.getDefault());\n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     * Constructs a new <code>ParseException</code> with specified\n+     * formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @param offset offset at which error occurred\n+     */\n+    public static ParseException createParseException(final String pattern,\n+                                                      final Object[] arguments,\n+                                                      final int offset) {\n+        return new ParseException(buildMessage(pattern, arguments, Locale.US), offset) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = -1103502177342465975L;\n+\n+            /** {@inheritDoc} */\n+            public String getLocalizedMessage() {\n+                return buildMessage(pattern, arguments, Locale.getDefault());\n+            }\n+\n+        };\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/MaxIterationsExceededException.java\n+++ b/src/java/org/apache/commons/math/MaxIterationsExceededException.java\n      */\n     public MaxIterationsExceededException(int maxIterations) {\n         super(\"Maximal number of iterations ({0}) exceeded\",\n-              new Object[] { new Integer(maxIterations) });\n+              new Object[] { Integer.valueOf(maxIterations) });\n         this.maxIterations = maxIterations;\n     }\n \n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n     { \"unable to orthogonalize matrix in {0} iterations\",\n       \"impossible de rendre la matrice orthogonale en {0} it\\u00e9rations\" },\n \n-    // org.apache.commons.math.ode.AdaptiveStepsizeIntegrator\n+    // org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator\n     { \"minimal step size ({0}) reached, integration needs {1}\",\n       \"pas minimal ({0}) atteint, l''int\\u00e9gration n\\u00e9cessite {1}\" },\n     { \"dimensions mismatch: state vector has dimension {0},\" +\n       \"incompatibilit\\u00e9 de dimensions entre le vecteur d''\\u00e9tat ({0}),\" +\n       \" et le vecteur de tol\\u00e9rance relative ({1})\" },\n \n-    // org.apache.commons.math.ode.AdaptiveStepsizeIntegrator,\n-    // org.apache.commons.math.ode.RungeKuttaIntegrator\n+    // org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator,\n+    // org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator\n     { \"dimensions mismatch: ODE problem has dimension {0},\" +\n       \" initial state vector has dimension {1}\",\n       \"incompatibilit\\u00e9 de dimensions entre le probl\\u00e8me ODE ({0}),\" +\n     { \"too small integration interval: length = {0}\",\n       \"intervalle d''int\\u00e9gration trop petit : {0}\" },\n \n+    // org.apache.commons.math.ode.ContinuousOutputModel\n+    // org.apache.commons.math.optimization.DirectSearchOptimizer\n+    { \"unexpected exception caught\",\n+      \"exception inattendue lev\\u00e9e\" },\n+\n     // org.apache.commons.math.optimization.DirectSearchOptimizer\n     { \"none of the {0} start points lead to convergence\",\n-      \"aucun des {0} points de d\\u00e9part n''aboutit \\u00e0 une convergence\"  }\n+      \"aucun des {0} points de d\\u00e9part n''aboutit \\u00e0 une convergence\"  },\n+\n+    // org.apache.commons.math.random.EmpiricalDistributionImpl\n+    { \"no bin selected\",\n+      \"aucun compartiment s\\u00e9lectionn\\u00e9\" },\n+\n+    // org.apache.commons.math.linear.EigenDecompositionImpl\n+    { \"cannot solve degree {0} equation\",\n+      \"impossible de r\\u00e9soudre une \\u00e9quation de degr\\u00e9 {0}\" },\n+    { \"negative element on decomposed tridiagonal of {0}x{1} matrix\",\n+      \"\\u00e9l\\u00e9ment n\\u00e9gatif dans la d\\u00e9composition tri-diagonale d''une matrice {0}x{1}\" },\n+\n+    // org.apache.commons.math.linear.NonSquareMatrixException\n+    { \"a {0}x{1} matrix was provided instead of a square matrix\",\n+      \"une matrice {0}x{1} a \\u00e9t\\u00e9 fournie \\u00e0 la place d''une matrice carr\\u00e9e\" },\n+\n+    // org.apache.commons.math.linear.SingularMatrixException\n+    { \"matrix is singular\",\n+      \"matrice singuli\\u00e8re\" },\n+\n+    // org.apache.commons.math.linear.RankDeficientMatrixException\n+    { \"matrix is rank-deficient\",\n+      \"le rang de la matrice est inf\\u00e9rieur \\u00e0 sa dimension\" },\n+\n+    // org.apache.commons.math.linear.RealVectorImpl\n+    { \"index {0} out of allowed range [{1}, {2}]\",\n+      \"index {0} hors de la plage autoris\\u00e9e [{1}, {2}]\" },\n+\n+    // org.apache.commons.math.linear.BigMatrixImpl\n+    // org.apache.commons.math.linear.RealMatrixImpl\n+    { \"row index {0} out of allowed range [{1}, {2}]\",\n+      \"index de ligne {0} hors de la plage autoris\\u00e9e [{1}, {2}]\" },\n+    { \"column index {0} out of allowed range [{1}, {2}]\",\n+      \"index de colonne {0} hors de la plage autoris\\u00e9e [{1}, {2}]\" },\n+    { \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+      \"pas d''entr\\u00e9e aux indices ({0}, {1}) dans une matrice {2}x{3}\" },\n+    { \"initial row {0} after final row {1}\",\n+      \"ligne initiale {0} apr\\u00e8s la ligne finale {1}\" },\n+    { \"initial column {0} after final column {1}\",\n+      \"colonne initiale {0} apr\\u00e8s la colonne finale {1}\" },\n+    { \"empty selected row index array\",\n+      \"tableau des indices de lignes s\\u00e9lectionn\\u00e9es vide\" },\n+    { \"empty selected column index array\",\n+      \"tableau des indices de colonnes s\\u00e9lectionn\\u00e9es vide\" },\n+\n+   // org.apache.commons.math.random.EmpiricalDistributionImpl\n+   // org.apache.commons.math.random.ValueServer\n+   { \"URL {0} contains no data\",\n+     \"l''adresse {0} ne contient aucune donn\\u00e9e\" },\n+\n+   // org.apache.commons.math.complex.ComplexFormat\n+   { \"unparseable complex number: \\\"{0}\\\"\",\n+     \"\\u00e9chec d''analyse du nombre complexe \\\"{0}\\\"\" },\n+\n+   // org.apache.commons.math.fraction.FractionFormat\n+   { \"unparseable fraction number: \\\"{0}\\\"\",\n+     \"\\u00e9chec d''analyse du nombre rationnel \\\"{0}\\\"\" },\n+\n+   // org.apache.commons.math.geometry.Vector3DFormat\n+   { \"unparseable 3D vector: \\\"{0}\\\"\",\n+     \"\\u00e9chec d''analyse du vecteur de dimension 3 \\\"{0}\\\"\" },\n+\n+   // org.apache.commons.math.linear.RealVectorFormat\n+   { \"unparseable real vector: \\\"{0}\\\"\",\n+     \"\\u00e9chec d''analyse du vecteur r\\u00e9el \\\"{0}\\\"\" },\n+\n+   // org.apache.commons.math.util.ResizableDoubleArray\n+   { \"the index specified: {0} is larger than the current maximal index {1}\",\n+     \"l''index sp\\u00e9cifi\\u00e9 ({0}) d\\u00e9passe l''index maximal courant ({1})\" },\n+   { \"elements cannot be retrieved from a negative array index {0}\",\n+     \"impossible d''extraire un \\u00e9l\\u00e9ment \\u00e0 un index n\\u00e9gatif ({0})\" },\n+   { \"cannot set an element at a negative index {0}\",\n+     \"impossible de mettre un \\u00e9l\\u00e9ment \\u00e0 un index n\\u00e9gatif ({0})\" },\n+   { \"cannot substitute an element from an empty array\",\n+     \"impossible de substituer un \\u00e9l\\u00e9ment dans un tableau vide\" },\n+\n+   // org.apache.commons.math.analysis.PolynomialFunctionLagrangeForm\n+   { \"identical abscissas x[{0}] == x[{1}] == {2} cause division by zero\",\n+     \"division par z\\u00e9ro caus\\u00e9e par les abscisses identiques x[{0}] == x[{1}] == {2}\" },\n+\n+   // org.apache.commons.math.fraction.Fraction\n+   { \"zero denominator in fraction {0}/{1}\",\n+     \"d\\u00e9nominateur null dans le nombre rationnel {0}/{1}\" },\n+   { \"overflow in fraction {0}/{1}, cannot negate\",\n+     \"d\\u00e9passement de capacit\\u00e9 pour la fraction {0}/{1}, son signe ne peut \\u00eatre chang\\u00e9\" },\n+   { \"overflow, numerator too large after multiply: {0}\",\n+     \"d\\u00e9passement de capacit\\u00e9 pour le num\\u00e9rateur apr\\u00e8s multiplication : {0}\" },\n+   { \"the fraction to divide by must not be zero: {0}/{1}\",\n+     \"division par un nombre rationnel nul : {0}/{1}\" },\n+\n+   // org.apache.commons.math.geometry.Rotation\n+   { \"zero norm for rotation axis\",\n+     \"norme nulle pour un axe de rotation\" },\n+\n+   // org.apache.commons.math.geometry.Vector3D\n+   // org.apache.commons.math.linear.RealVectorImpl\n+   { \"cannot normalize a zero norm vector\",\n+     \"impossible de normer un vecteur de norme nulle\" },\n+   { \"zero norm\",\n+     \"norme nulle\" },\n+\n+   // org.apache.commons.math.analysis.UnivariateRealIntegratorImpl\n+   // org.apache.commons.math.analysis.UnivariateRealSolverImpl\n+   { \"no result available\",\n+     \"aucun r\\u00e9sultat n''est disponible\" },\n+\n+   // org.apache.commons.math.linear.BigMatrixImpl\n+   { \"first {0} rows are not initialized yet\",\n+     \"les {0} premi\\u00e8res lignes ne sont pas encore initialis\\u00e9es\" },\n+   { \"first {0} columns are not initialized yet\",\n+     \"les {0} premi\\u00e8res colonnes ne sont pas encore initialis\\u00e9es\" },\n+\n+   // org.apache.commons.math.linear.EigenDecompositionImpl\n+   // org.apache.commons.math.linear.LUDecompositionImpl\n+   // org.apache.commons.math.linear.QRDecompositionImpl\n+   // org.apache.commons.math.linear.SingularValueDecompositionImpl\n+   { \"no matrix have been decomposed yet\",\n+     \"aucune matrice n''a encore \\u00e9t\\u00e9 d\\u00e9compos\\u00e9e\" },\n+\n+   // org.apache.commons.math.random.EmpiricalDistributionImpl\n+   { \"distribution not loaded\",\n+     \"aucune distribution n''a \\u00e9t\\u00e9 charg\\u00e9e\" },\n+\n+   // org.apache.commons.math.random.ValueServer\n+   { \"unknown mode {0}, known modes: {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}) and {11} ({12})\",\n+     \"mode {0} inconnu, modes connus : {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}) et {11} ({12})\" },\n+   { \"digest not initialized\",\n+     \"mod\\u00e8le empirique non initialis\\u00e9\" },\n+\n+   // org.apache.commons.math.stat.descriptive.moment.GeometricMean\n+   // org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics\n+   // org.apache.commons.math.stat.descriptive.SummaryStatistics\n+   { \"{0} values have been added before statistic is configured\",\n+     \"{0} valeurs ont \\u00e9t\\u00e9 ajout\\u00e9es avant que la statistique ne soit configur\\u00e9e\" },\n+\n+   // org.apache.commons.math.stat.descriptive.moment.Kurtosis\n+   { \"statistics constructed from external moments cannot be incremented\",\n+     \"les statistiques bas\\u00e9es sur des moments externes ne peuvent pas \\u00eatre incr\\u00e9ment\\u00e9es\" },\n+   { \"statistics constructed from external moments cannot be cleared\",\n+     \"les statistiques bas\\u00e9es sur des moments externes ne peuvent pas \\u00eatre remises \\u00e0 z\\u00e9ro\" }\n \n   };\n \n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n  * <p>\n  * The function should be continuous but not necessarily smooth.</p>\n  *  \n- * @version $Revision$ $Date$\n+ * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $\n  */\n public class BrentSolver extends UnivariateRealSolverImpl {\n     \n--- a/src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java\n+++ b/src/java/org/apache/commons/math/analysis/DividedDifferenceInterpolator.java\n  * functions. For reference, see <b>Introduction to Numerical Analysis</b>,\n  * ISBN 038795452X, chapter 2.\n  * <p>\n- * The actual code of Neville's evalution is in PolynomialFunctionLagrangeForm,\n+ * The actual code of Neville's evaluation is in PolynomialFunctionLagrangeForm,\n  * this class provides an easy-to-use interface to it.</p>\n  *\n  * @version $Revision$ $Date$\n--- a/src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java\n+++ b/src/java/org/apache/commons/math/analysis/PolynomialFunctionLagrangeForm.java\n \n import org.apache.commons.math.DuplicateSampleAbscissaException;\n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * Implements the representation of a real polynomial function in\n             }\n             if (d == 0.0) {\n                 // This happens only when two abscissas are identical.\n-                throw new ArithmeticException\n-                    (\"Identical abscissas cause division by zero.\");\n+                for (int k = 0; k < n; ++k) {\n+                    if ((i != k) && (x[i] == x[k])) {\n+                        throw MathRuntimeException.createArithmeticException(\"identical abscissas x[{0}] == x[{1}] == {2} cause division by zero\",\n+                                                                             new Object[] {\n+                                                                                 i, k, x[i]\n+                                                                             });\n+                    }\n+                }\n             }\n             t = y[i] / d;\n             // Lagrange polynomial is the sum of n terms, each of which is a\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealIntegratorImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealIntegratorImpl.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math.MathRuntimeException;\n+\n /**\n  * Provide a default implementation for several generic functions.\n  *  \n         if (resultComputed) {\n             return result;\n         } else {\n-            throw new IllegalStateException(\"No result available.\");\n+            throw MathRuntimeException.createIllegalStateException(\"no result available\", null);\n         }\n     }\n \n         if (resultComputed) {\n             return iterationCount;\n         } else {\n-            throw new IllegalStateException(\"No result available.\");\n+            throw MathRuntimeException.createIllegalStateException(\"no result available\", null);\n         }\n     }\n \n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactory.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactory.java\n  * limitations under the License.\n  */\n package org.apache.commons.math.analysis;\n-\n-import org.apache.commons.discovery.tools.DiscoverClass;\n \n /**\n  * Abstract factory class used to create {@link UnivariateRealSolver} instances.\n  * BrentSolver solver = factory.newBrentSolver(f);\n  * </pre>\n  *\n- * <a href=\"http://commons.apache.org/discovery/\">Apache Commons Discovery</a>\n- * is used to determine the concrete factory returned by \n- * <code>UnivariateRealSolverFactory.newInstance().</code>  The default is\n- * {@link UnivariateRealSolverFactoryImpl}.\n- *\n  * @version $Revision$ $Date$\n  */\n public abstract class UnivariateRealSolverFactory {\n      * @return a new factory.\n      */\n     public static UnivariateRealSolverFactory newInstance() {\n-        UnivariateRealSolverFactory factory = null;\n-        try {\n-            DiscoverClass dc = new DiscoverClass();\n-            factory = (UnivariateRealSolverFactory) dc.newInstance(\n-                UnivariateRealSolverFactory.class,\n-                \"org.apache.commons.math.analysis.UnivariateRealSolverFactoryImpl\");\n-        } catch(Throwable t) {\n-            return new UnivariateRealSolverFactoryImpl();\n-        }\n-        return factory;\n+        return new UnivariateRealSolverFactoryImpl();\n     }\n     \n     /**\n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverImpl.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * Provide a default implementation for several functions useful to generic\n         if (resultComputed) {\n             return result;\n         } else {\n-            throw new IllegalStateException(\"No result available\");\n+            throw MathRuntimeException.createIllegalStateException(\"no result available\", null);\n         }\n     }\n \n         if (resultComputed) {\n             return iterationCount;\n         } else {\n-            throw new IllegalStateException(\"No result available\");\n+            throw MathRuntimeException.createIllegalStateException(\"no result available\", null);\n         }\n     }\n \n--- a/src/java/org/apache/commons/math/analysis/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverUtils.java\n         if (fa * fb >= 0.0 ) {\n             throw new ConvergenceException\n             (\"Number of iterations={0}, maximum iterations={1}, initial={2}, lower bound={3}, upper bound={4}, final a value={5}, final b value={6}, f(a)={7}, f(b)={8}\",\n-             new Object[] { new Integer(numIterations), new Integer(maximumIterations),\n-                            new Double(initial), new Double(lowerBound), new Double(upperBound),\n-                            new Double(a), new Double(b), new Double(fa), new Double(fb) });\n+             new Object[] { Integer.valueOf(numIterations), Integer.valueOf(maximumIterations),\n+                            Double.valueOf(initial), Double.valueOf(lowerBound), Double.valueOf(upperBound),\n+                            Double.valueOf(a), Double.valueOf(b), Double.valueOf(fa), Double.valueOf(fb) });\n         }\n         \n         return new double[]{a, b};\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n     \n     /** \n      * The imaginary part \n-     * @deprecated to be made final and private in 2.0\n-     */\n-    protected double imaginary;\n+     */\n+    private final double imaginary;\n     \n     /** \n      * The real part \n-     * @deprecated to be made final and private in 2.0\n-     */\n-    protected double real;\n+     */\n+    private final double real;\n     \n     /**\n      * Create a complex number given the real and imaginary parts.\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                ret = (Double.doubleToRawLongBits(real) ==\n-                        Double.doubleToRawLongBits(rhs.getReal())) &&\n-                    (Double.doubleToRawLongBits(imaginary) ==\n-                        Double.doubleToRawLongBits(rhs.getImaginary())); \n+                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); \n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception\n--- a/src/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java\n \n package org.apache.commons.math.complex;\n \n-import java.io.Serializable;\n import java.text.FieldPosition;\n-import java.text.Format;\n import java.text.NumberFormat;\n import java.text.ParseException;\n import java.text.ParsePosition;\n import java.util.Locale;\n \n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.CompositeFormat;\n+\n /**\n  * Formats a Complex number in cartesian format \"Re(c) + Im(c)i\".  'i' can\n- * be replaced with 'j', and the number format for both real and imaginary parts\n- * can be configured.\n+ * be replaced with 'j' (or anything else), and the number format for both real\n+ * and imaginary parts can be configured.\n  *\n  * @author Apache Software Foundation\n  * @version $Revision$ $Date$\n  */\n-public class ComplexFormat extends Format implements Serializable {\n+public class ComplexFormat extends CompositeFormat {\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -6337346779577272306L;\n-    \n-    /** The default imaginary character. */\n+    private static final long serialVersionUID = -3343698360149467646L;\n+\n+     /** The default imaginary character. */\n     private static final String DEFAULT_IMAGINARY_CHARACTER = \"i\";\n     \n     /** The notation used to signify the imaginary part of the complex number. */\n      * @param realFormat the custom format for the real part.\n      * @param imaginaryFormat the custom format for the imaginary part.\n      */\n-    public ComplexFormat(NumberFormat realFormat,\n-            NumberFormat imaginaryFormat) {\n+    public ComplexFormat(NumberFormat realFormat, NumberFormat imaginaryFormat) {\n         this(DEFAULT_IMAGINARY_CHARACTER, realFormat, imaginaryFormat);\n     }\n     \n     }\n \n     /**\n-     * This static method calls formatComplex() on a default instance of\n+     * Get the set of locales for which complex formats are available.\n+     * <p>This is the same set as the {@link NumberFormat} set.</p> \n+     * @return available complex format locales.\n+     */\n+    public static Locale[] getAvailableLocales() {\n+        return NumberFormat.getAvailableLocales();\n+    }\n+\n+    /**\n+     * This static method calls {@link #format(Object)} on a default instance of\n      * ComplexFormat.\n      *\n      * @param c Complex object to format\n      * @return A formatted number in the form \"Re(c) + Im(c)i\"\n      */\n-    public static String formatComplex( Complex c ) {\n-        return getInstance().format( c );\n+    public static String formatComplex(Complex c) {\n+        return getInstance().format(c);\n     }\n     \n     /**\n             ret = format( new Complex(((Number)obj).doubleValue(), 0.0),\n                 toAppendTo, pos);\n         } else { \n-            throw new IllegalArgumentException(\n-                \"Cannot format given Object as a Date\");\n+            throw new IllegalArgumentException(\"Cannot format given Object as a Complex\");\n         }\n         \n         return ret;\n     }\n \n-    /**\n-     * Formats a double value to produce a string.  In general, the value is\n-     * formatted using the formatting rules of <code>format</code>.  There are\n-     * three exceptions to this:\n-     * <ol>\n-     * <li>NaN is formatted as '(NaN)'</li>\n-     * <li>Positive infinity is formatted as '(Infinity)'</li>\n-     * <li>Negative infinity is formatted as '(-Infinity)'</li>\n-     * </ol>\n-     *\n-     * @param value the double to format.\n-     * @param format the format used.\n-     * @param toAppendTo where the text is to be appended\n-     * @param pos On input: an alignment field, if desired. On output: the\n-     *            offsets of the alignment field\n-     * @return the value passed in as toAppendTo.\n-     */\n-    private StringBuffer formatDouble(double value, NumberFormat format,\n-            StringBuffer toAppendTo, FieldPosition pos) {\n-        if( Double.isNaN(value) || Double.isInfinite(value) ) {\n-            toAppendTo.append('(');\n-            toAppendTo.append(value);\n-            toAppendTo.append(')');\n-        } else {\n-            format.format(value, toAppendTo, pos);\n-        }\n-        return toAppendTo;\n-    }\n-    \n-    /**\n-     * Get the set of locales for which complex formats are available.  This\n-     * is the same set as the {@link NumberFormat} set. \n-     * @return available complex format locales.\n-     */\n-    public static Locale[] getAvailableLocales() {\n-        return NumberFormat.getAvailableLocales();\n-    }\n-    \n-    /**\n-     * Create a default number format.  The default number format is based on\n-     * {@link NumberFormat#getInstance()} with the only customizing is the\n-     * maximum number of fraction digits, which is set to 2.  \n-     * @return the default number format.\n-     */\n-    private static NumberFormat getDefaultNumberFormat() {\n-        return getDefaultNumberFormat(Locale.getDefault());\n-    }\n-    \n-    /**\n-     * Create a default number format.  The default number format is based on\n-     * {@link NumberFormat#getInstance(java.util.Locale)} with the only\n-     * customizing is the maximum number of fraction digits, which is set to 2.  \n-     * @param locale the specific locale used by the format.\n-     * @return the default number format specific to the given locale.\n-     */\n-    private static NumberFormat getDefaultNumberFormat(Locale locale) {\n-        NumberFormat nf = NumberFormat.getInstance(locale);\n-        nf.setMaximumFractionDigits(2);\n-        return nf;\n-    }\n-    \n     /**\n      * Access the imaginaryCharacter.\n      * @return the imaginaryCharacter.\n         ParsePosition parsePosition = new ParsePosition(0);\n         Complex result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n-            throw new ParseException(\"Unparseable complex number: \\\"\" + source +\n-                \"\\\"\", parsePosition.getErrorIndex());\n+            throw MathRuntimeException.createParseException(\"unparseable complex number: \\\"{0}\\\"\",\n+                                                            new Object[] { source },\n+                                                            parsePosition.getErrorIndex());\n         }\n         return result;\n     }\n         if (re == null) {\n             // invalid real number\n             // set index back to initial, error index should already be set\n-            // character examined.\n             pos.setIndex(initialIndex);\n             return null;\n         }\n         if (im == null) {\n             // invalid imaginary number\n             // set index back to initial, error index should already be set\n-            // character examined.\n             pos.setIndex(initialIndex);\n             return null;\n         }\n \n         // parse imaginary character\n-        int n = getImaginaryCharacter().length();\n-        startIndex = pos.getIndex();\n-        int endIndex = startIndex + n;\n-        if ((startIndex >= source.length()) ||\n-            (endIndex > source.length()) ||\n-            source.substring(startIndex, endIndex).compareTo(\n-            getImaginaryCharacter()) != 0) {\n-            // set index back to initial, error index should be the start index\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            pos.setErrorIndex(startIndex);\n+        if (!parseFixedstring(source, getImaginaryCharacter(), pos)) {\n             return null;\n         }\n-        pos.setIndex(endIndex);\n \n         return new Complex(re.doubleValue(), im.doubleValue() * sign);\n+\n     }\n      \n-    /**\n-     * Parses <code>source</code> until a non-whitespace character is found.\n-     *\n-     * @param source the string to parse\n-     * @param pos input/ouput parsing parameter.  On output, <code>pos</code>\n-     *        holds the index of the next non-whitespace character.\n-     */\n-    private void parseAndIgnoreWhitespace(String source, ParsePosition pos) {\n-        parseNextCharacter(source, pos);\n-        pos.setIndex(pos.getIndex() - 1);\n-    }\n-\n-    /**\n-     * Parses <code>source</code> until a non-whitespace character is found.\n-     *\n-     * @param source the string to parse\n-     * @param pos input/ouput parsing parameter.\n-     * @return the first non-whitespace character.\n-     */\n-    private char parseNextCharacter(String source, ParsePosition pos) {\n-         int index = pos.getIndex();\n-         int n = source.length();\n-         char ret = 0;\n-\n-         if (index < n) {\n-             char c;\n-             do {\n-                 c = source.charAt(index++);\n-             } while (Character.isWhitespace(c) && index < n);\n-             pos.setIndex(index);\n-         \n-             if (index < n) {\n-                 ret = c;\n-             }\n-         }\n-         \n-         return ret;\n-    }\n-    \n-    /**\n-     * Parses <code>source</code> for a special double values.  These values\n-     * include Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n-     *\n-     * @param source the string to parse\n-     * @param value the special value to parse.\n-     * @param pos input/ouput parsing parameter.\n-     * @return the special number.\n-     */\n-    private Number parseNumber(String source, double value, ParsePosition pos) {\n-        Number ret = null;\n-        \n-        StringBuffer sb = new StringBuffer();\n-        sb.append('(');\n-        sb.append(value);\n-        sb.append(')');\n-        \n-        int n = sb.length();\n-        int startIndex = pos.getIndex();\n-        int endIndex = startIndex + n;\n-        if (endIndex < source.length()) {\n-            if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {\n-                ret = new Double(value);\n-                pos.setIndex(endIndex);\n-            }\n-        }\n-        \n-        return ret;\n-    }\n-    \n-    /**\n-     * Parses <code>source</code> for a number.  This method can parse normal,\n-     * numeric values as well as special values.  These special values include\n-     * Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n-     *\n-     * @param source the string to parse\n-     * @param format the number format used to parse normal, numeric values.\n-     * @param pos input/ouput parsing parameter.\n-     * @return the parsed number.\n-     */\n-    private Number parseNumber(String source, NumberFormat format, ParsePosition pos) {\n-        int startIndex = pos.getIndex();\n-        Number number = format.parse(source, pos);\n-        int endIndex = pos.getIndex();\n-        \n-        // check for error parsing number\n-        if (startIndex == endIndex) {\n-            // try parsing special numbers\n-            double[] special = {Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY};\n-            for (int i = 0; i < special.length; ++i) {\n-                number = parseNumber(source, special[i], pos);\n-                if (number != null) {\n-                    break;\n-                }\n-            }\n-        }\n-        \n-        return number;\n-    }\n-\n     /**\n      * Parses a string to produce a object.\n      *\n     public Object parseObject(String source, ParsePosition pos) {\n         return parse(source, pos);\n     }\n+\n     /**\n      * Modify the imaginaryCharacter.\n      * @param imaginaryCharacter The new imaginaryCharacter value.\n         }\n         this.realFormat = realFormat;\n     }\n+\n }\n--- a/src/java/org/apache/commons/math/complex/ComplexUtils.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexUtils.java\n \n package org.apache.commons.math.complex;\n \n-import org.apache.commons.math.util.MathUtils;\n-\n /**\n  * Static implementations of common \n- * {@link org.apache.commons.math.complex.Complex}-valued functions.  Included\n- * are trigonometric, exponential, log, power and square root functions.\n- *<p>\n- * Reference:\n- * <ul>\n- * <li><a href=\"http://myweb.lmu.edu/dmsmith/ZMLIB.pdf\">\n- * Multiple Precision Complex Arithmetic and Functions</a></li>\n- * </ul>\n- * See individual method javadocs for the computational formulas used.\n- * In general, NaN values in either real or imaginary parts of input arguments\n- * result in {@link Complex#NaN} returned.  Otherwise, infinite or NaN values\n- * are returned as they arise in computing the real functions specified in the\n- * computational formulas.  Null arguments result in NullPointerExceptions.\n+ * {@link org.apache.commons.math.complex.Complex} utilities functions.\n  *\n  * @version $Revision$ $Date$\n  */\n      */\n     private ComplexUtils() {\n         super();\n-    }\n-    \n-    /**\n-     * Compute the \n-     * <a href=\"http://mathworld.wolfram.com/InverseCosine.html\" TARGET=\"_top\">\n-     * inverse cosine</a> for the given complex argument.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code> acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))</code></pre>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code> or infinite.\n-     * \n-     * @param z the value whose inverse cosine is to be returned\n-     * @return the inverse cosine of <code>z</code>\n-     * @throws NullPointerException if <code>z</code> is null\n-     * @deprecated use Complex.acos()\n-     */\n-    public static Complex acos(Complex z) {\n-        return z.acos();\n-    }\n-    \n-    /**\n-     * Compute the \n-     * <a href=\"http://mathworld.wolfram.com/InverseSine.html\" TARGET=\"_top\">\n-     * inverse sine</a> for the given complex argument.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code> asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz)) </code></pre>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code> or infinite.\n-     * \n-     * @param z the value whose inverse sine is to be returned.\n-     * @return the inverse sine of <code>z</code>.\n-     * @throws NullPointerException if <code>z</code> is null\n-     * @deprecated use Complex.asin()\n-     */\n-    public static Complex asin(Complex z) {\n-        return z.asin();\n-    }\n-    \n-    /**\n-     * Compute the \n-     * <a href=\"http://mathworld.wolfram.com/InverseTangent.html\" TARGET=\"_top\">\n-     * inverse tangent</a> for the given complex argument.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code> atan(z) = (i/2) log((i + z)/(i - z)) </code></pre>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code> or infinite. \n-     * \n-     * @param z the value whose inverse tangent is to be returned\n-     * @return the inverse tangent of <code>z</code>\n-     * @throws NullPointerException if <code>z</code> is null\n-     * @deprecated use Complex.atan()\n-     */\n-    public static Complex atan(Complex z) {\n-        return z.atan();\n-    }\n-    \n-    /**\n-     * Compute the \n-     * <a href=\"http://mathworld.wolfram.com/Cosine.html\" TARGET=\"_top\">\n-     * cosine</a>\n-     * for the given complex argument.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code> cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i</code></pre>\n-     * where the (real) functions on the right-hand side are\n-     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n-     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n-     * <p>\n-     * Infinite values in real or imaginary parts of the input may result in\n-     * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples: \n-     * <code>\n-     * cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i\n-     * cos(&plusmn;INFINITY + i) = NaN + NaN i\n-     * cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>\n-     * \n-     * @param z the value whose cosine is to be returned\n-     * @return the cosine of <code>z</code>\n-     * @throws NullPointerException if <code>z</code> is null\n-     * @deprecated use Complex.cos()\n-     */\n-    public static Complex cos(Complex z) {\n-        return z.cos();\n-    }\n-    \n-    /**\n-     * Compute the \n-     * <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\" TARGET=\"_top\">\n-     * hyperbolic cosine</a> for the given complex argument.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code> cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i</code></pre>\n-     * where the (real) functions on the right-hand side are\n-     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n-     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n-     * <p>\n-     * Infinite values in real or imaginary parts of the input may result in\n-     * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples: \n-     * <code>\n-     * cosh(1 &plusmn; INFINITY i) = NaN + NaN i\n-     * cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i\n-     * cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>\n-     * <p>\n-     * Throws <code>NullPointerException</code> if z is null.\n-     * \n-     * @param z the value whose hyperbolic cosine is to be returned.\n-     * @return the hyperbolic cosine of <code>z</code>.\n-     * @deprecated use Complex.cosh()\n-     */\n-    public static Complex cosh(Complex z) {\n-        return z.cosh();\n-    }\n-    \n-    /**\n-     * Compute the\n-     * <a href=\"http://mathworld.wolfram.com/ExponentialFunction.html\" TARGET=\"_top\">\n-     * exponential function</a> for the given complex argument.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code> exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i</code></pre>\n-     * where the (real) functions on the right-hand side are\n-     * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and\n-     * {@link java.lang.Math#sin}.\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n-     * <p>\n-     * Infinite values in real or imaginary parts of the input may result in\n-     * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples: \n-     * <code>\n-     * exp(1 &plusmn; INFINITY i) = NaN + NaN i\n-     * exp(INFINITY + i) = INFINITY + INFINITY i\n-     * exp(-INFINITY + i) = 0 + 0i\n-     * exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>\n-     * <p>\n-     * Throws <code>NullPointerException</code> if z is null.\n-     * \n-     * @param z the value\n-     * @return <i>e</i><sup><code>z</code></sup>\n-     * @deprecated use Complex.exp()\n-     */\n-    public static Complex exp(Complex z) {\n-        return z.exp();\n-    }\n-    \n-    /**\n-     * Compute the \n-     * <a href=\"http://mathworld.wolfram.com/NaturalLogarithm.html\" TARGET=\"_top\">\n-     * natural logarithm</a> for the given complex argument.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code> log(a + bi) = ln(|a + bi|) + arg(a + bi)i</code></pre>\n-     * where ln on the right hand side is {@link java.lang.Math#log},\n-     * <code>|a + bi|</code> is the modulus, {@link Complex#abs},  and\n-     * <code>arg(a + bi) = {@link java.lang.Math#atan2}(b, a)</code>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n-     * <p>\n-     * Infinite (or critical) values in real or imaginary parts of the input may\n-     * result in infinite or NaN values returned in parts of the result.<pre>\n-     * Examples: \n-     * <code>\n-     * log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i\n-     * log(INFINITY + i) = INFINITY + 0i\n-     * log(-INFINITY + i) = INFINITY + &pi;i\n-     * log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i\n-     * log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i\n-     * log(0 + 0i) = -INFINITY + 0i\n-     * </code></pre>\n-     * Throws <code>NullPointerException</code> if z is null.\n-     * \n-     * @param z the value.\n-     * @return ln <code>z</code>.\n-     * @deprecated use Complex.log()\n-     */\n-    public static Complex log(Complex z) {\n-        return z.log();\n     }\n     \n     /**\n         return new Complex(r * Math.cos(theta), r * Math.sin(theta));\n     }\n     \n-    /**\n-     * Returns of value of <code>y</code> raised to the power of <code>x</code>.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code> y<sup>x</sup> = exp(x&middot;log(y))</code></pre> \n-     * where <code>exp</code> and <code>log</code> are {@link #exp} and\n-     * {@link #log}, respectively.\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code> or infinite, or if <code>y</code>\n-     * equals {@link Complex#ZERO}.\n-     * \n-     * @param y the base.\n-     * @param x the exponent.\n-     * @return <code>y</code><sup><code>x</code></sup>\n-     * @throws NullPointerException if either x or y is null\n-     * @deprecated use Complex.pow(x)\n-     */\n-    public static Complex pow(Complex y, Complex x) {\n-        return y.pow(x);\n-    }\n-    \n-    /**\n-     * Compute the \n-     * <a href=\"http://mathworld.wolfram.com/Sine.html\" TARGET=\"_top\">\n-     * sine</a>\n-     * for the given complex argument.\n-     * <p>\n-      * Implements the formula: <pre>\n-     * <code> sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i</code></pre>\n-     * where the (real) functions on the right-hand side are\n-     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n-     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n-     * <p>\n-     * Infinite values in real or imaginary parts of the input may result in\n-     * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples: \n-     * <code>\n-     * sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i\n-     * sin(&plusmn;INFINITY + i) = NaN + NaN i\n-     * sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre>\n-     * \n-     * Throws <code>NullPointerException</code> if z is null. \n-     * \n-     * @param z the value whose sine is to be returned.\n-     * @return the sine of <code>z</code>.\n-     * @deprecated use Complex.sin()\n-     */\n-    public static Complex sin(Complex z) {\n-        return z.sin();\n-    }\n-    \n-    /**\n-     * Compute the \n-     * <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\" TARGET=\"_top\">\n-     * hyperbolic sine</a> for the given complex argument.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code> sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i</code></pre>\n-     * where the (real) functions on the right-hand side are\n-     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n-     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n-     * <p>\n-     * Infinite values in real or imaginary parts of the input may result in\n-     * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples: \n-     * <code>\n-     * sinh(1 &plusmn; INFINITY i) = NaN + NaN i\n-     * sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i\n-     * sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre\n-     * \n-     * @param z the value whose hyperbolic sine is to be returned\n-     * @return the hyperbolic sine of <code>z</code>\n-     * @throws NullPointerException if <code>z</code> is null\n-     * @deprecated use Complex.sinh()\n-     */\n-    public static Complex sinh(Complex z) {\n-        return z.sinh();\n-    }\n-    \n-    /**\n-     * Compute the \n-     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n-     * square root</a> for the given complex argument.\n-     * <p>\n-     * Implements the following algorithm to compute <code>sqrt(a + bi)</code>: \n-     * <ol><li>Let <code>t = sqrt((|a| + |a + bi|) / 2)</code></li>\n-     * <li><pre>if <code> a &#8805; 0</code> return <code>t + (b/2t)i</code>\n-     *  else return <code>|b|/2t + sign(b)t i </code></pre></li>\n-     * </ol>\n-     * where <ul>\n-     * <li><code>|a| = {@link Math#abs}(a)</code></li>\n-     * <li><code>|a + bi| = {@link Complex#abs}(a + bi) </code></li>\n-     * <li><code>sign(b) =  {@link MathUtils#indicator}(b) </code>\n-     * </ul>\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n-     * <p>\n-     * Infinite values in real or imaginary parts of the input may result in\n-     * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples: \n-     * <code>\n-     * sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i\n-     * sqrt(INFINITY + i) = INFINITY + 0i\n-     * sqrt(-INFINITY + i) = 0 + INFINITY i\n-     * sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i\n-     * sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i\n-     * </code></pre>\n-     * \n-     * @param z the value whose square root is to be returned\n-     * @return the square root of <code>z</code>\n-     * @throws NullPointerException if <code>z</code> is null\n-     * @deprecated use Complex.sqrt()\n-     */\n-    public static Complex sqrt(Complex z) {\n-        return z.sqrt();\n-    }\n-    \n-    /**\n-     * Compute the \n-     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n-     * square root</a> of 1 - <code>z</code><sup>2</sup> for the given complex\n-     * argument.\n-     * <p>\n-     * Computes the result directly as \n-     * <code>sqrt(Complex.ONE.subtract(z.multiply(z)))</code>.\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n-     * <p>\n-     * Infinite values in real or imaginary parts of the input may result in\n-     * infinite or NaN values returned in parts of the result. \n-     * \n-     * @param z the value\n-     * @return the square root of 1 - <code>z</code><sup>2</sup>\n-     * @throws NullPointerException if <code>z</code> is null\n-     * @deprecated use Complex.sqrt1z()\n-     */\n-    public static Complex sqrt1z(Complex z) {\n-        return z.sqrt1z();\n-    }\n-    \n-    /**\n-     * Compute the \n-     * <a href=\"http://mathworld.wolfram.com/Tangent.html\" TARGET=\"_top\">\n-     * tangent</a> for the given complex argument.\n-     * <p>\n-     * Implements the formula: <pre>\n-     * <code>tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i</code></pre>\n-     * where the (real) functions on the right-hand side are\n-     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n-     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n-     * <p>\n-     * Infinite (or critical) values in real or imaginary parts of the input may\n-     * result in infinite or NaN values returned in parts of the result.<pre>\n-     * Examples: \n-     * <code>\n-     * tan(1 &plusmn; INFINITY i) = 0 + NaN i\n-     * tan(&plusmn;INFINITY + i) = NaN + NaN i\n-     * tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n-     * tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i</code></pre>\n-     * \n-     * @param z the value whose tangent is to be returned\n-     * @return the tangent of <code>z</code>\n-     * @throws NullPointerException if <code>z</code> is null\n-     * @deprecated use Complex.tan()\n-     */\n-    public static Complex tan(Complex z) {\n-        return z.tan();\n-    }\n-    \n-    /**\n-     * Compute the\n-     * <a href=\"http://mathworld.wolfram.com/HyperbolicTangent.html\" TARGET=\"_top\">\n-     * hyperbolic tangent</a> for the given complex argument.\n-    * <p>\n-     * Implements the formula: <pre>\n-     * <code>tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i</code></pre>\n-     * where the (real) functions on the right-hand side are\n-     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n-     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.\n-     * <p>\n-     * Returns {@link Complex#NaN} if either real or imaginary part of the \n-     * input argument is <code>NaN</code>.\n-     * <p>\n-     * Infinite values in real or imaginary parts of the input may result in\n-     * infinite or NaN values returned in parts of the result.<pre>\n-     * Examples: \n-     * <code>\n-     * tanh(1 &plusmn; INFINITY i) = NaN + NaN i\n-     * tanh(&plusmn;INFINITY + i) = NaN + 0 i\n-     * tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n-     * tanh(0 + (&pi;/2)i) = NaN + INFINITY i</code></pre>\n-     *\n-     * @param z the value whose hyperbolic tangent is to be returned\n-     * @return the hyperbolic tangent of <code>z</code>\n-     * @throws NullPointerException if <code>z</code> is null\n-     * @deprecated use Complex.tanh()\n-     */\n-    public static Complex tanh(Complex z) {\n-        return z.tanh();\n-    }\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/distribution/BetaDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Computes the cumulative, inverse cumulative and density functions for the beta distribuiton.\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Beta_distribution\">Beta_distribution</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface BetaDistribution extends ContinuousDistribution, HasDensity<Double> {\n+    /**\n+      * Modify the shape parameter, alpha.\n+      * @param alpha the new shape parameter.\n+      */\n+     void setAlpha(double alpha);\n+\n+     /**\n+      * Access the shape parameter, alpha\n+      * @return alpha.\n+      */\n+     double getAlpha();\n+\n+     /**\n+      * Modify the shape parameter, beta.\n+      * @param beta the new scale parameter.\n+      */\n+     void setBeta(double beta);\n+\n+     /**\n+      * Access the shape parameter, beta\n+      * @return beta.\n+      */\n+     double getBeta();\n+\n+     /**\n+      * Return the probability density for a particular point.\n+      * @param x  The point at which the density should be computed.\n+      * @return  The pdf at point x.\n+      * @exception MathException if probability density cannot be computed\n+      */\n+     double density(Double x) throws MathException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.special.Gamma;\n+import org.apache.commons.math.special.Beta;\n+\n+/**\n+ * Implements the Beta distribution.\n+ * <p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://en.wikipedia.org/wiki/Beta_distribution\">\n+ * Beta distribution</a></li>\n+ * </ul>\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class BetaDistributionImpl\n+    extends AbstractContinuousDistribution implements BetaDistribution {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -1221965979403477668L;\n+\n+    /** First shape parameter. */\n+    private double alpha;\n+\n+    /** Second shape parameter. */\n+    private double beta;\n+\n+    /** Normalizing factor used in density computations.\n+     * updated whenever alpha or beta are changed.\n+     */\n+    private double z;\n+\n+    /**\n+     * Build a new instance.\n+     * @param alpha first shape parameter (must be positive)\n+     * @param beta second shape parameter (must be positive)\n+     */\n+    public BetaDistributionImpl(double alpha, double beta) {\n+        this.alpha = alpha;\n+        this.beta = beta;\n+        z = Double.NaN;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setAlpha(double alpha) {\n+        this.alpha = alpha;\n+        z = Double.NaN;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getAlpha() {\n+        return alpha;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setBeta(double beta) {\n+        this.beta = beta;\n+        z = Double.NaN;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getBeta() {\n+        return beta;\n+    }\n+\n+    /**\n+     * Recompute the normalization factor.\n+     */\n+    private void recomputeZ() {\n+        if (Double.isNaN(z)) {\n+            z = Gamma.logGamma(alpha) + Gamma.logGamma(beta) - Gamma.logGamma(alpha + beta);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double density(Double x) throws MathException {\n+        recomputeZ();\n+        if (x < 0 || x > 1) {\n+            return 0;\n+        } else if (x == 0) {\n+            if (alpha < 1) {\n+                throw new MathException(\"Cannot compute beta density at 0 when alpha = {0,number}\", new Double[]{alpha});\n+            }\n+            return 0;\n+        } else if (x == 1) {\n+            if (beta < 1) {\n+                throw new MathException(\"Cannot compute beta density at 1 when beta = %.3g\", new Double[]{beta});\n+            }\n+            return 0;\n+        } else {\n+            double logX = Math.log(x);\n+            double log1mX = Math.log1p(-x);\n+            return Math.exp((alpha - 1) * logX + (beta - 1) * log1mX - z);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double inverseCumulativeProbability(double p) throws MathException {\n+        if (p == 0) {\n+            return 0;\n+        } else if (p == 1) {\n+            return 1;\n+        } else {\n+            return super.inverseCumulativeProbability(p);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected double getInitialDomain(double p) {\n+        return p;\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected double getDomainLowerBound(double p) {\n+        return 0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected double getDomainUpperBound(double p) {\n+        return 1;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double cumulativeProbability(double x) throws MathException {\n+        if (x <= 0) {\n+            return 0;\n+        } else if (x >= 1) {\n+            return 1;\n+        } else {\n+            return Beta.regularizedBeta(x, alpha, beta);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double cumulativeProbability(double x0, double x1) throws MathException {\n+        return cumulativeProbability(x1) - cumulativeProbability(x0);\n+    }\n+}\n--- a/src/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java\n  *\n  * @version $Revision$ $Date$\n  */\n-public interface ChiSquaredDistribution extends ContinuousDistribution {\n+public interface ChiSquaredDistribution extends ContinuousDistribution, HasDensity<Double> {\n     /**\n      * Modify the degrees of freedom.\n      * @param degreesOfFreedom the new degrees of freedom.\n      * @return the degrees of freedom.\n      */\n     double getDegreesOfFreedom();\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     * @param x  The point at which the density should be computed.\n+     * @return  The pdf at point x.\n+     */\n+    double density(Double x);\n }\n--- a/src/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n     public double getDegreesOfFreedom() {\n         return getGamma().getAlpha() * 2.0;\n     }\n-        \n+\n+    /**\n+     * Return the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    public double density(Double x) {\n+        return gamma.density(x);\n+    }\n+\n     /**\n      * For this distribution, X, this method returns P(X &lt; x).\n      * @param x the value at which the CDF is evaluated.\n--- a/src/java/org/apache/commons/math/distribution/ExponentialDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/ExponentialDistribution.java\n  *\n  * @version $Revision$ $Date$\n  */\n-public interface ExponentialDistribution extends ContinuousDistribution {\n+public interface ExponentialDistribution extends ContinuousDistribution, HasDensity<Double> {\n     /**\n      * Modify the mean.\n      * @param mean the new mean.\n      * @return the mean.\n      */\n     double getMean();\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     * @param x  The point at which the density should be computed.\n+     * @return  The pdf at point x.\n+     */\n+    double density(Double x);\n }\n--- a/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n      */\n     public double getMean() {\n         return mean;\n+    }\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    public double density(Double x) {\n+        if (x < 0) {\n+            return 0;\n+        }\n+        return Math.exp(-x / getMean()) / getMean();\n     }\n \n     /**\n      */\n     protected double getInitialDomain(double p) {\n         // TODO: try to improve on this estimate\n+        // TODO: what should really happen here is not derive from AbstractContinuousDistribution\n+        // TODO: because the inverse cumulative distribution is simple.\n         // Exponential is skewed to the left, therefore, P(X < &mu;) > .5\n         if (p < .5) {\n             // use 1/2 mean\n--- a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n /**\n  * Default implementation of\n  * {@link org.apache.commons.math.distribution.FDistribution}.\n- * \n- * @version $Revision$ $Date: 2008-02-08 09:44:11 -0600 (Fri, 08 Feb\n- *          2008) $\n+ *\n+ * @version $Revision$ $Date$\n  */\n-public class FDistributionImpl extends AbstractContinuousDistribution implements\n-\t\tFDistribution, Serializable {\n+public class FDistributionImpl\n+    extends AbstractContinuousDistribution\n+    implements FDistribution, Serializable  {\n \n-\t/** Serializable version identifier */\n-\tprivate static final long serialVersionUID = -8516354193418641566L;\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -8516354193418641566L;\n \n-\t/** The numerator degrees of freedom */\n-\tprivate double numeratorDegreesOfFreedom;\n+    /** The numerator degrees of freedom*/\n+    private double numeratorDegreesOfFreedom;\n \n-\t/** The numerator degrees of freedom */\n-\tprivate double denominatorDegreesOfFreedom;\n+    /** The numerator degrees of freedom*/\n+    private double denominatorDegreesOfFreedom;\n+    \n+    /**\n+     * Create a F distribution using the given degrees of freedom.\n+     * @param numeratorDegreesOfFreedom the numerator degrees of freedom.\n+     * @param denominatorDegreesOfFreedom the denominator degrees of freedom.\n+     */\n+    public FDistributionImpl(double numeratorDegreesOfFreedom,\n+            double denominatorDegreesOfFreedom) {\n+        super();\n+        setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);\n+        setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n+    }\n+    \n+    /**\n+     * For this distribution, X, this method returns P(X &lt; x).\n+     * \n+     * The implementation of this method is based on:\n+     * <ul>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/F-Distribution.html\">\n+     * F-Distribution</a>, equation (4).</li>\n+     * </ul>\n+     * \n+     * @param x the value at which the CDF is evaluated.\n+     * @return CDF for this distribution. \n+     * @throws MathException if the cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     */\n+    public double cumulativeProbability(double x) throws MathException {\n+        double ret;\n+        if (x <= 0.0) {\n+            ret = 0.0;\n+        } else {\n+            double n = getNumeratorDegreesOfFreedom();\n+            double m = getDenominatorDegreesOfFreedom();\n+            \n+            ret = Beta.regularizedBeta((n * x) / (m + n * x),\n+                0.5 * n,\n+                0.5 * m);\n+        }\n+        return ret;\n+    }\n+    \n+    /**\n+     * For this distribution, X, this method returns the critical point x, such\n+     * that P(X &lt; x) = <code>p</code>.\n+     * <p>\n+     * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n+     *\n+     * @param p the desired probability\n+     * @return x, such that P(X &lt; x) = <code>p</code>\n+     * @throws MathException if the inverse cumulative probability can not be\n+     *         computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if <code>p</code> is not a valid\n+     *         probability.\n+     */\n+    public double inverseCumulativeProbability(final double p) \n+        throws MathException {\n+        if (p == 0) {\n+            return 0d;\n+        }\n+        if (p == 1) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+        return super.inverseCumulativeProbability(p);\n+    }\n+        \n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     */\n+    protected double getDomainLowerBound(double p) {\n+        return 0.0;\n+    }\n \n-\t/**\n-\t * Create a F distribution using the given degrees of freedom.\n-\t * \n-\t * @param numeratorDegreesOfFreedom\n-\t *            the numerator degrees of freedom.\n-\t * @param denominatorDegreesOfFreedom\n-\t *            the denominator degrees of freedom.\n-\t */\n-\tpublic FDistributionImpl(double numeratorDegreesOfFreedom,\n-\t\t\tdouble denominatorDegreesOfFreedom) {\n-\t\tsuper();\n-\t\tsetNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);\n-\t\tsetDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n-\t}\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    protected double getDomainUpperBound(double p) {\n+        return Double.MAX_VALUE;\n+    }\n \n-\t/**\n-\t * For this distribution, X, this method returns P(X &lt; x).\n-\t * \n-\t * The implementation of this method is based on:\n-\t * <ul>\n-\t * <li>\n-\t * <a href=\"http://mathworld.wolfram.com/F-Distribution.html\">\n-\t * F-Distribution</a>, equation (4).</li>\n-\t * </ul>\n-\t * \n-\t * @param x\n-\t *            the value at which the CDF is evaluated.\n-\t * @return CDF for this distribution.\n-\t * @throws MathException\n-\t *             if the cumulative probability can not be computed due to\n-\t *             convergence or other numerical errors.\n-\t */\n-\tpublic double cumulativeProbability(double x) throws MathException {\n-\t\tdouble ret;\n-\t\tif (x <= 0.0) {\n-\t\t\tret = 0.0;\n-\t\t} else {\n-\t\t\tdouble n = getNumeratorDegreesOfFreedom();\n-\t\t\tdouble m = getDenominatorDegreesOfFreedom();\n-\n-\t\t\tret = Beta.regularizedBeta((n * x) / (m + n * x), 0.5 * n, 0.5 * m);\n-\t\t}\n-\t\treturn ret;\n-\t}\n-\n-\t/**\n-\t * For this distribution, X, this method returns the critical point x, such\n-\t * that P(X &lt; x) = <code>p</code>.\n-\t * <p>\n-\t * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.\n-\t * </p>\n-\t * \n-\t * @param p\n-\t *            the desired probability\n-\t * @return x, such that P(X &lt; x) = <code>p</code>\n-\t * @throws MathException\n-\t *             if the inverse cumulative probability can not be computed due\n-\t *             to convergence or other numerical errors.\n-\t * @throws IllegalArgumentException\n-\t *             if <code>p</code> is not a valid probability.\n-\t */\n-\tpublic double inverseCumulativeProbability(final double p)\n-\t\t\tthrows MathException {\n-\t\tif (p == 0) {\n-\t\t\treturn 0d;\n-\t\t}\n-\t\tif (p == 1) {\n-\t\t\treturn Double.POSITIVE_INFINITY;\n-\t\t}\n-\t\treturn super.inverseCumulativeProbability(p);\n-\t}\n-\n-\t/**\n-\t * Access the domain value lower bound, based on <code>p</code>, used to\n-\t * bracket a CDF root. This method is used by\n-\t * {@link #inverseCumulativeProbability(double)} to find critical values.\n-\t * \n-\t * @param p\n-\t *            the desired probability for the critical value\n-\t * @return domain value lower bound, i.e. P(X &lt; <i>lower bound</i>) &lt;\n-\t *         <code>p</code>\n-\t */\n-\tprotected double getDomainLowerBound(double p) {\n-\t\treturn 0.0;\n-\t}\n-\n-\t/**\n-\t * Access the domain value upper bound, based on <code>p</code>, used to\n-\t * bracket a CDF root. This method is used by\n-\t * {@link #inverseCumulativeProbability(double)} to find critical values.\n-\t * \n-\t * @param p\n-\t *            the desired probability for the critical value\n-\t * @return domain value upper bound, i.e. P(X &lt; <i>upper bound</i>) &gt;\n-\t *         <code>p</code>\n-\t */\n-\tprotected double getDomainUpperBound(double p) {\n-\t\treturn Double.MAX_VALUE;\n-\t}\n-\n-\t/**\n-\t * Access the initial domain value, based on <code>p</code>, used to bracket\n-\t * a CDF root. This method is used by\n-\t * {@link #inverseCumulativeProbability(double)} to find critical values.\n-\t * \n-\t * @param p\n-\t *            the desired probability for the critical value\n-\t * @return initial domain value\n-\t */\n-\tprotected double getInitialDomain(double p) {\n-\t\tdouble ret = 1.0;\n-\t\tdouble d = getDenominatorDegreesOfFreedom();\n-\t\tif (d > 2.0) {\n-\t\t\t// use mean\n-\t\t\tret = d / (d - 2.0);\n-\t\t}\n-\t\treturn ret;\n-\t}\n-\n-\t/**\n-\t * Modify the numerator degrees of freedom.\n-\t * \n-\t * @param degreesOfFreedom\n-\t *            the new numerator degrees of freedom.\n-\t * @throws IllegalArgumentException\n-\t *             if <code>degreesOfFreedom</code> is not positive.\n-\t */\n-\tpublic void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {\n-\t\tif (degreesOfFreedom <= 0.0) {\n-\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\"degrees of freedom must be positive.\");\n-\t\t}\n-\t\tthis.numeratorDegreesOfFreedom = degreesOfFreedom;\n-\t}\n-\n-\t/**\n-\t * Access the numerator degrees of freedom.\n-\t * \n-\t * @return the numerator degrees of freedom.\n-\t */\n-\tpublic double getNumeratorDegreesOfFreedom() {\n-\t\treturn numeratorDegreesOfFreedom;\n-\t}\n-\n-\t/**\n-\t * Modify the denominator degrees of freedom.\n-\t * \n-\t * @param degreesOfFreedom\n-\t *            the new denominator degrees of freedom.\n-\t * @throws IllegalArgumentException\n-\t *             if <code>degreesOfFreedom</code> is not positive.\n-\t */\n-\tpublic void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {\n-\t\tif (degreesOfFreedom <= 0.0) {\n-\t\t\tthrow new IllegalArgumentException(\n-\t\t\t\t\t\"degrees of freedom must be positive.\");\n-\t\t}\n-\t\tthis.denominatorDegreesOfFreedom = degreesOfFreedom;\n-\t}\n-\n-\t/**\n-\t * Access the denominator degrees of freedom.\n-\t * \n-\t * @return the denominator degrees of freedom.\n-\t */\n-\tpublic double getDenominatorDegreesOfFreedom() {\n-\t\treturn denominatorDegreesOfFreedom;\n-\t}\n+    /**\n+     * Access the initial domain value, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return initial domain value\n+     */\n+    protected double getInitialDomain(double p) {\n+        double ret = 1.0;\n+        double d = getDenominatorDegreesOfFreedom();\n+        if (d > 2.0) {\n+            // use mean\n+            ret = d / (d - 2.0);\n+        }\n+        return ret;\n+    }\n+    \n+    /**\n+     * Modify the numerator degrees of freedom.\n+     * @param degreesOfFreedom the new numerator degrees of freedom.\n+     * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not\n+     *         positive.\n+     */\n+    public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {\n+        if (degreesOfFreedom <= 0.0) {\n+            throw new IllegalArgumentException(\n+                \"degrees of freedom must be positive.\");\n+        }\n+        this.numeratorDegreesOfFreedom = degreesOfFreedom;\n+    }\n+    \n+    /**\n+     * Access the numerator degrees of freedom.\n+     * @return the numerator degrees of freedom.\n+     */\n+    public double getNumeratorDegreesOfFreedom() {\n+        return numeratorDegreesOfFreedom;\n+    }\n+    \n+    /**\n+     * Modify the denominator degrees of freedom.\n+     * @param degreesOfFreedom the new denominator degrees of freedom.\n+     * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not\n+     *         positive.\n+     */\n+    public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {\n+        if (degreesOfFreedom <= 0.0) {\n+            throw new IllegalArgumentException(\n+                \"degrees of freedom must be positive.\");\n+        }\n+        this.denominatorDegreesOfFreedom = degreesOfFreedom;\n+    }\n+    \n+    /**\n+     * Access the denominator degrees of freedom.\n+     * @return the denominator degrees of freedom.\n+     */\n+    public double getDenominatorDegreesOfFreedom() {\n+        return denominatorDegreesOfFreedom;\n+    }\n }\n--- a/src/java/org/apache/commons/math/distribution/GammaDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/GammaDistribution.java\n  *\n  * @version $Revision$ $Date$\n  */\n-public interface GammaDistribution extends ContinuousDistribution {\n+public interface GammaDistribution extends ContinuousDistribution, HasDensity<Double> {\n     /**\n      * Modify the shape parameter, alpha.\n      * @param alpha the new shape parameter.\n      * @return beta.\n      */\n     double getBeta();\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     * @param x  The point at which the density should be computed.\n+     * @return  The pdf at point x.\n+     */\n+    double density(Double x);\n }\n--- a/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n     public double getBeta() {\n         return beta;\n     }\n-    \n+\n+    /**\n+     * Return the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    public double density(Double x) {\n+        if (x < 0) return 0;\n+        return Math.pow(x / getBeta(), getAlpha() - 1) / getBeta() * Math.exp(-x / getBeta()) / Math.exp(Gamma.logGamma(getAlpha()));\n+    }\n+\n     /**\n      * Access the domain value lower bound, based on <code>p</code>, used to\n      * bracket a CDF root.  This method is used by\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/distribution/HasDensity.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Interface that signals that a distribution can compute the probability density function\n+ * for a particular point.\n+ * @param <P> the type of the point at which density is to be computed, this\n+ * may be for example <code>Double</code>\n+ * @version $Revision$ $Date$\n+ */\n+public interface HasDensity<P> {\n+\n+    /**\n+     * Compute the probability density function.\n+     * @param x point for which the probability density is requested\n+     * @return probability density at point x\n+     * @throws MathException if probability density cannot be computed at specifed point\n+     */\n+    double density(P x) throws MathException;\n+\n+}\n--- a/src/java/org/apache/commons/math/distribution/NormalDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/NormalDistribution.java\n  *\n  * @version $Revision$ $Date$\n  */\n-public interface NormalDistribution extends ContinuousDistribution {\n+public interface NormalDistribution extends ContinuousDistribution, HasDensity<Double> {\n     /**\n      * Access the mean.\n      * @return mean for this distribution\n      * @param sd standard deviation for this distribution\n      */\n     void setStandardDeviation(double sd);\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     * @param x  The point at which the density should be computed.\n+     * @return  The pdf at point x.\n+     */\n+    double density(Double x);\n }\n--- a/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 8589540077390120676L;\n \n+    /** &sqrt;(2 &pi;) */\n+    private static final double SQRT2PI = Math.sqrt(2 * Math.PI);\n+\n     /** The mean of this distribution. */\n     private double mean = 0;\n     \n     /** The standard deviation of this distribution. */\n     private double standardDeviation = 1;\n-    \n+\n     /**\n      * Create a normal distribution using the given mean and standard deviation.\n      * @param mean mean for this distribution\n                 \"Standard deviation must be positive.\");\n         }       \n         standardDeviation = sd;\n+    }\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    public double density(Double x) {\n+        double x0 = x - getMean();\n+        return Math.exp(-x0 * x0 / (2 * getStandardDeviation() * getStandardDeviation())) / (getStandardDeviation() * SQRT2PI);\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n \n         if (++costEvaluations > maxCostEval) {\n             throw new EstimationException(\"maximal number of evaluations exceeded ({0})\",\n-                                          new Object[] { new Integer(maxCostEval) });\n+                                          new Object[] { Integer.valueOf(maxCostEval) });\n         }\n \n         cost = 0;\n \n         try {\n             // compute the covariances matrix\n-            return new RealMatrixImpl(jTj).inverse().getData();\n+            return ((RealMatrixImpl) new RealMatrixImpl(jTj, false).inverse()).getDataRef();\n         } catch (InvalidMatrixException ime) {\n             throw new EstimationException(\"unable to compute covariances: singular problem\",\n-                                          new Object[0]);\n+                                          null);\n         }\n \n     }\n         int p = problem.getUnboundParameters().length;\n         if (m <= p) {\n             throw new EstimationException(\"no degrees of freedom ({0} measurements, {1} parameters)\",\n-                                          new Object[] { new Integer(m), new Integer(p)});\n+                                          new Object[] { Integer.valueOf(m), Integer.valueOf(p)});\n         }\n         double[] errors = new double[problem.getUnboundParameters().length];\n         final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n--- a/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n import java.io.Serializable;\n \n import org.apache.commons.math.linear.InvalidMatrixException;\n+import org.apache.commons.math.linear.LUDecompositionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.linear.RealVectorImpl;\n \n /** \n  * This class implements a solver for estimation problems.\n \n         // work matrices\n         double[] grad             = new double[parameters.length];\n-        RealMatrixImpl bDecrement = new RealMatrixImpl(parameters.length, 1);\n-        double[][] bDecrementData = bDecrement.getDataRef();\n+        RealVectorImpl bDecrement = new RealVectorImpl(parameters.length);\n+        double[] bDecrementData   = bDecrement.getDataRef();\n         RealMatrixImpl wGradGradT = new RealMatrixImpl(parameters.length, parameters.length);\n         double[][] wggData        = wGradGradT.getDataRef();\n \n \n             // build the linear problem\n             incrementJacobianEvaluationsCounter();\n-            RealMatrix b = new RealMatrixImpl(parameters.length, 1);\n+            RealVector b = new RealVectorImpl(parameters.length);\n             RealMatrix a = new RealMatrixImpl(parameters.length, parameters.length);\n             for (int i = 0; i < measurements.length; ++i) {\n                 if (! measurements [i].isIgnored()) {\n                     // compute the normal equation\n                     for (int j = 0; j < parameters.length; ++j) {\n                         grad[j] = measurements[i].getPartial(parameters[j]);\n-                        bDecrementData[j][0] = weight * residual * grad[j];\n+                        bDecrementData[j] = weight * residual * grad[j];\n                     }\n \n                     // build the contribution matrix for measurement i\n             try {\n \n                 // solve the linearized least squares problem\n-                RealMatrix dX = a.solve(b);\n+                RealVector dX = new LUDecompositionImpl(a).solve(b);\n \n                 // update the estimated parameters\n                 for (int i = 0; i < parameters.length; ++i) {\n-                    parameters[i].setEstimate(parameters[i].getEstimate() + dX.getEntry(i, 0));\n+                    parameters[i].setEstimate(parameters[i].getEstimate() + dX.getEntry(i));\n                 }\n \n             } catch(InvalidMatrixException e) {\n-                throw new EstimationException(\"unable to solve: singular problem\", new Object[0]);\n+                throw new EstimationException(\"unable to solve: singular problem\", null);\n             }\n \n \n--- a/src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n           throw new EstimationException(\"cost relative tolerance is too small ({0}),\" +\n                                         \" no further reduction in the\" +\n                                         \" sum of squares is possible\",\n-                                        new Object[] { new Double(costRelativeTolerance) });\n+                                        new Object[] { Double.valueOf(costRelativeTolerance) });\n         } else if (delta <= 2.2204e-16 * xNorm) {\n           throw new EstimationException(\"parameters relative tolerance is too small\" +\n                                         \" ({0}), no further improvement in\" +\n                                         \" the approximate solution is possible\",\n-                                        new Object[] { new Double(parRelativeTolerance) });\n+                                        new Object[] { Double.valueOf(parRelativeTolerance) });\n         } else if (maxCosine <= 2.2204e-16)  {\n           throw new EstimationException(\"orthogonality tolerance is too small ({0}),\" +\n                                         \" solution is orthogonal to the jacobian\",\n-                                        new Object[] { new Double(orthoTolerance) });\n+                                        new Object[] { Double.valueOf(orthoTolerance) });\n         }\n \n       }\n         }\n         if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n             throw new EstimationException(\"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\",\n-                                          new Object[] { new Integer(rows), new Integer(cols) });\n+                                          new Object[] { Integer.valueOf(rows), Integer.valueOf(cols) });\n         }\n         if (norm2 > ak2) {\n           nextColumn = i;\n--- a/src/java/org/apache/commons/math/estimation/SimpleEstimationProblem.java\n+++ b/src/java/org/apache/commons/math/estimation/SimpleEstimationProblem.java\n package org.apache.commons.math.estimation;\n \n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n \n /**\n      * Build an empty instance without parameters nor measurements.\n      */\n     public SimpleEstimationProblem() {\n-        parameters   = new ArrayList();\n-        measurements = new ArrayList();\n+        parameters   = new ArrayList<EstimatedParameter>();\n+        measurements = new ArrayList<WeightedMeasurement>();\n     }\n \n     /** \n     public EstimatedParameter[] getUnboundParameters() {\n \n         // filter the unbound parameters\n-        List unbound = new ArrayList(parameters.size());\n-        for (Iterator iterator = parameters.iterator(); iterator.hasNext();) {\n-            EstimatedParameter p = (EstimatedParameter) iterator.next();\n+        List<EstimatedParameter> unbound = new ArrayList<EstimatedParameter>(parameters.size());\n+        for (EstimatedParameter p : parameters) {\n             if (! p.isBound()) {\n                 unbound.add(p);\n             }\n     }\n \n     /** Estimated parameters. */\n-    private final List parameters;\n+    private final List<EstimatedParameter> parameters;\n \n     /** Measurements. */\n-    private final List measurements;\n+    private final List<WeightedMeasurement> measurements;\n \n }\n--- a/src/java/org/apache/commons/math/estimation/WeightedMeasurement.java\n+++ b/src/java/org/apache/commons/math/estimation/WeightedMeasurement.java\n \n public abstract class WeightedMeasurement implements Serializable {\n \n-  /** \n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 4360046376796901941L;\n+\n+    /** \n    * Simple constructor.\n    * Build a measurement with the given parameters, and set its ignore\n    * flag to false.\n--- a/src/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/java/org/apache/commons/math/fraction/Fraction.java\n package org.apache.commons.math.fraction;\n \n import java.math.BigInteger;\n+\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n  * @since 1.1\n  * @version $Revision$ $Date$\n  */\n-public class Fraction extends Number implements Comparable {\n+public class Fraction extends Number implements Comparable<Fraction> {\n \n     /** A fraction representing \"1 / 1\". */\n     public static final Fraction ONE = new Fraction(1, 1);\n     public static final Fraction ZERO = new Fraction(0, 1);\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -8958519416450949235L;\n+    private static final long serialVersionUID = -5731055832688548463L;\n     \n     /** The denominator. */\n     private final int denominator;\n     public Fraction(int num, int den) {\n         super();\n         if (den == 0) {\n-            throw new ArithmeticException(\"The denominator must not be zero\");\n+            throw MathRuntimeException.createArithmeticException(\"zero denominator in fraction {0}/{1}\",\n+                                                                 new Object[] { num, den});\n         }\n         if (den < 0) {\n-            if (num == Integer.MIN_VALUE ||\n-                    den == Integer.MIN_VALUE) {\n-                throw new ArithmeticException(\"overflow: can't negate\");\n+            if (num == Integer.MIN_VALUE || den == Integer.MIN_VALUE) {\n+                throw MathRuntimeException.createArithmeticException(\"overflow in fraction {0}/{1}, cannot negate\",\n+                                                                     new Object[] { num, den});\n             }\n             num = -num;\n             den = -den;\n      * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n-    public int compareTo(Object object) {\n+    public int compareTo(Fraction object) {\n         int ret = 0;\n         \n         if (this != object) { \n-            Fraction other = (Fraction)object;\n             double first = doubleValue();\n-            double second = other.doubleValue();\n+            double second = object.doubleValue();\n             \n             if (first < second) {\n                 ret = -1;\n      */\n     public Fraction negate() {\n         if (numerator==Integer.MIN_VALUE) {\n-            throw new ArithmeticException(\"overflow: too large to negate\");\n+            throw MathRuntimeException.createArithmeticException(\"overflow in fraction {0}/{1}, cannot negate\",\n+                                                                 new Object[] { numerator, denominator});\n         }\n         return new Fraction(-numerator, denominator);\n     }\n         // result is (t/d2) / (u'/d1)(v'/d2)\n         BigInteger w = t.divide(BigInteger.valueOf(d2));\n         if (w.bitLength() > 31) {\n-            throw new ArithmeticException\n-            (\"overflow: numerator too large after multiply\");\n+            throw MathRuntimeException.createArithmeticException(\"overflow, numerator too large after multiply: {0}\",\n+                                                                 new Object[] { w });\n         }\n         return new Fraction (w.intValue(), \n                 MathUtils.mulAndCheck(denominator/d1, \n             throw new IllegalArgumentException(\"The fraction must not be null\");\n         }\n         if (fraction.numerator == 0) {\n-            throw new ArithmeticException(\"The fraction to divide by must not be zero\");\n+            throw MathRuntimeException.createArithmeticException(\"the fraction to divide by must not be zero: {0}/{1}\",\n+                                                                 new Object[] { fraction.numerator, fraction.denominator });\n         }\n         return multiply(fraction.reciprocal());\n     }\n      */\n     public static Fraction getReducedFraction(int numerator, int denominator) {\n         if (denominator == 0) {\n-            throw new ArithmeticException(\"The denominator must not be zero\");\n+            throw MathRuntimeException.createArithmeticException(\"zero denominator in fraction {0}/{1}\",\n+                                                                 new Object[] { numerator, denominator});\n         }\n         if (numerator==0) {\n             return ZERO; // normalize zero.\n         if (denominator < 0) {\n             if (numerator==Integer.MIN_VALUE ||\n                     denominator==Integer.MIN_VALUE) {\n-                throw new ArithmeticException(\"overflow: can't negate\");\n+                throw MathRuntimeException.createArithmeticException(\"overflow in fraction {0}/{1}, cannot negate\",\n+                                                                     new Object[] { numerator, denominator});\n             }\n             numerator = -numerator;\n             denominator = -denominator;\n--- a/src/java/org/apache/commons/math/fraction/FractionConversionException.java\n+++ b/src/java/org/apache/commons/math/fraction/FractionConversionException.java\n      */\n     public FractionConversionException(double value, int maxIterations) {\n         super(\"Unable to convert {0} to fraction after {1} iterations\",\n-              new Object[] { new Double(value), new Integer(maxIterations) });\n+              new Object[] { Double.valueOf(value), Integer.valueOf(maxIterations) });\n     }\n \n     /**\n      */\n     public FractionConversionException(double value, long p, long q) {\n         super(\"Overflow trying to convert {0} to fraction ({1}/{2})\",\n-              new Object[] { new Double(value), new Long(p), new Long(q) });\n+              new Object[] { Double.valueOf(value), Long.valueOf(p), Long.valueOf(q) });\n     }\n \n }\n--- a/src/java/org/apache/commons/math/fraction/FractionFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/FractionFormat.java\n import java.util.Locale;\n \n import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * Formats a Fraction number in proper format or improper format.  The number\n         ParsePosition parsePosition = new ParsePosition(0);\n         Fraction result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n-            throw new ParseException(\"Unparseable fraction number: \\\"\" +\n-                source + \"\\\"\", parsePosition.getErrorIndex());\n+            throw MathRuntimeException.createParseException(\"unparseable fraction number: \\\"{0}\\\"\",\n+                                                            new Object[] { source },\n+                                                            parsePosition.getErrorIndex());\n         }\n         return result;\n     }\n--- a/src/java/org/apache/commons/math/genetics/Chromosome.java\n+++ b/src/java/org/apache/commons/math/genetics/Chromosome.java\n \n /**\n  * Individual in a population. Chromosomes are compared based on their fitness.\n+ * @version $Revision$ $Date$\n  */\n public interface Chromosome {\n     /**\n--- a/src/java/org/apache/commons/math/genetics/ChromosomePair.java\n+++ b/src/java/org/apache/commons/math/genetics/ChromosomePair.java\n \n /**\n  * A pair of {@link Chromosome} objects.\n+ * @version $Revision$ $Date$\n  */\n public class ChromosomePair {\n     /** the first chromosome in the pair. */\n--- a/src/java/org/apache/commons/math/genetics/CrossoverPolicy.java\n+++ b/src/java/org/apache/commons/math/genetics/CrossoverPolicy.java\n /**\n  * Policy used to create a pair of new chromosomes by performing a crossover\n  * operation on a source pair of chromosomes.\n+ * @version $Revision$ $Date$\n  */\n public interface CrossoverPolicy {\n     /**\n--- a/src/java/org/apache/commons/math/genetics/GeneticAlgorithm.java\n+++ b/src/java/org/apache/commons/math/genetics/GeneticAlgorithm.java\n /**\n  * Implementation of a genetic algorithm. All factors that govern the operation\n  * of the algorithm can be configured for a specific problem.\n+ * \n+ * @version $Revision$ $Date$\n  */\n public class GeneticAlgorithm {\n     /** the crossover policy used by the algorithm. */\n     }\n \n     /**\n-     * Evolve the given population into the next generation.\n+     * <p>Evolve the given population into the next generation.</p>\n+     * <p><ol>\n+     *    <li>Get nextGeneration polulation to fill from <code>current</code>\n+     *        generation, using its nextGeneration method</li>\n+     *    <li>Loop until new generation is filled:</li>\n+     *    <ul><li>Apply configured SelectionPolicy to select a pair of parents\n+     *            from <code>current</code></li>\n+     *        <li>With probability = {@link #getCrossoverRate()}, apply\n+     *            configured {@link CrossoverPolicy} to parents</li>\n+     *        <li>With probability = {@link #getMutationRate()}, apply\n+     *            configured {@link MutationPolicy} to each of the offspring</li>\n+     *        <li>Add offspring individually to nextGeneration,\n+     *            space permitting</li>\n+     *    </ul>\n+     *    <li>Return nextGeneration</li>\n+     *    </ol>\n+     * </p>\n+     * \n      * \n      * @param current the current population.\n      * @return the population for the next generation.\n             // select parent chromosomes\n             ChromosomePair pair = getSelectionPolicy().select(current);\n \n-            // apply crossover policy to create two offspring\n+            // crossover?\n             if (Math.random() < getCrossoverRate()) {\n+                // apply crossover policy to create two offspring\n                 pair = getCrossoverPolicy().crossover(pair.getFirst(),\n                         pair.getSecond());\n             }\n \n-            // apply mutation policy to first offspring\n+            // mutation?\n             if (Math.random() < getMutationRate()) {\n-                nextGeneration.addChromosome(getMutationPolicy().mutate(\n-                        pair.getFirst()));\n-\n-                if (nextGeneration.getPopulationSize() < nextGeneration\n-                        .getPopulationLimit()) {\n-                    // apply mutation policy to second offspring\n-                    nextGeneration.addChromosome(getMutationPolicy().mutate(\n-                            pair.getSecond()));\n-                }\n+                // apply mutation policy to the chromosomes\n+                pair = new ChromosomePair(\n+                              getMutationPolicy().mutate(pair.getFirst()),\n+                              getMutationPolicy().mutate(pair.getSecond())\n+                           );\n+            }\n+\n+            // add the first chromosome to the population\n+            nextGeneration.addChromosome(pair.getFirst());\n+            // is there still a place for the second chromosome?\n+            if (nextGeneration.getPopulationSize() < nextGeneration\n+                    .getPopulationLimit()) {\n+                // add the second chromosome to the population\n+                nextGeneration.addChromosome(pair.getSecond());\n             }\n         }\n \n--- a/src/java/org/apache/commons/math/genetics/MutationPolicy.java\n+++ b/src/java/org/apache/commons/math/genetics/MutationPolicy.java\n \n /**\n  * Algorithm used to mutate a chrommosome.\n+ * @version $Revision$ $Date$\n  */\n public interface MutationPolicy {\n \n--- a/src/java/org/apache/commons/math/genetics/Population.java\n+++ b/src/java/org/apache/commons/math/genetics/Population.java\n \n /**\n  * A collection of chromosomes that facilitates generational evolution.\n+ * @version $Revision$ $Date$\n  */\n public interface Population {\n     /**\n--- a/src/java/org/apache/commons/math/genetics/SelectionPolicy.java\n+++ b/src/java/org/apache/commons/math/genetics/SelectionPolicy.java\n \n /**\n  * Algorithm used to select a chromosome pair from a population.\n+ * @version $Revision$ $Date$\n  */\n public interface SelectionPolicy {\n     /**\n--- a/src/java/org/apache/commons/math/genetics/StoppingCondition.java\n+++ b/src/java/org/apache/commons/math/genetics/StoppingCondition.java\n \n /**\n  * Algorithm used to determine when to stop evolution.\n+ * @version $Revision$ $Date$\n  */\n public interface StoppingCondition {\n     /**\n--- a/src/java/org/apache/commons/math/geometry/CardanEulerSingularityException.java\n+++ b/src/java/org/apache/commons/math/geometry/CardanEulerSingularityException.java\n    * if false it is related to EulerAngles\n    */\n   public CardanEulerSingularityException(boolean isCardan) {\n-    super(isCardan ? \"Cardan angles singularity\" : \"Euler angles singularity\", new Object[0]);\n+    super(isCardan ? \"Cardan angles singularity\" : \"Euler angles singularity\", null);\n   }\n \n   /** Serializable version identifier */\n--- a/src/java/org/apache/commons/math/geometry/Rotation.java\n+++ b/src/java/org/apache/commons/math/geometry/Rotation.java\n package org.apache.commons.math.geometry;\n \n import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * This class implements rotations in a three-dimensional space.\n \n public class Rotation implements Serializable {\n \n-  /** Build the identity rotation.\n-   */\n-  public Rotation() {\n-    q0 = 1;\n-    q1 = 0;\n-    q2 = 0;\n-    q3 = 0;\n-  }\n+  /** Identity rotation. */\n+  public static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false);\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -2153622329907944313L;\n+\n+  /** Scalar coordinate of the quaternion. */\n+  private final double q0;\n+\n+  /** First coordinate of the vectorial part of the quaternion. */\n+  private final double q1;\n+\n+  /** Second coordinate of the vectorial part of the quaternion. */\n+  private final double q2;\n+\n+  /** Third coordinate of the vectorial part of the quaternion. */\n+  private final double q3;\n \n   /** Build a rotation from the quaternion coordinates.\n    * <p>A rotation can be built from a <em>normalized</em> quaternion,\n \n     double norm = axis.getNorm();\n     if (norm == 0) {\n-      throw new ArithmeticException(\"zero norm for rotation axis\");\n+      throw MathRuntimeException.createArithmeticException(\"zero norm for rotation axis\",\n+                                                           null);\n     }\n \n     double halfAngle = -0.5 * angle;\n   /** Build a rotation from three Cardan or Euler elementary rotations.\n \n    * <p>Cardan rotations are three successive rotations around the\n-   * canonical axes X, Y and Z, each axis beeing used once. There are\n+   * canonical axes X, Y and Z, each axis being used once. There are\n    * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n    * rotations are three successive rotations around the canonical\n-   * axes X, Y and Z, the first and last rotations beeing around the\n+   * axes X, Y and Z, the first and last rotations being around the\n    * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n    * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n    * <p>Beware that many people routinely use the term Euler angles even\n       // (-r) (Vector3D.plusI) coordinates are :\n       // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n       // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n-      Vector3D v1 = applyTo(Vector3D.plusK);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusI);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n       if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(true);\n       }\n       // (-r) (Vector3D.plusI) coordinates are :\n       // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n       // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n-      Vector3D v1 = applyTo(Vector3D.plusJ);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusI);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n       if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(true);\n       }\n       // (-r) (Vector3D.plusJ) coordinates are :\n       // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n       // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n-      Vector3D v1 = applyTo(Vector3D.plusK);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusJ);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n       if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(true);\n       }\n       // (-r) (Vector3D.plusJ) coordinates are :\n       // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n       // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n-      Vector3D v1 = applyTo(Vector3D.plusI);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusJ);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n       if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(true);\n       }\n       // (-r) (Vector3D.plusK) coordinates are :\n       // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n       // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n-      Vector3D v1 = applyTo(Vector3D.plusJ);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusK);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n       if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(true);\n       }\n       // (-r) (Vector3D.plusK) coordinates are :\n       // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n       // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n-      Vector3D v1 = applyTo(Vector3D.plusI);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusK);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n       if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(true);\n       }\n       // (-r) (Vector3D.plusI) coordinates are :\n       // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n       // and we can choose to have theta in the interval [0 ; PI]\n-      Vector3D v1 = applyTo(Vector3D.plusI);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusI);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n       if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(false);\n       }\n       // (-r) (Vector3D.plusI) coordinates are :\n       // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n       // and we can choose to have psi in the interval [0 ; PI]\n-      Vector3D v1 = applyTo(Vector3D.plusI);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusI);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n       if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(false);\n       }\n       // (-r) (Vector3D.plusJ) coordinates are :\n       // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n       // and we can choose to have phi in the interval [0 ; PI]\n-      Vector3D v1 = applyTo(Vector3D.plusJ);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusJ);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n       if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(false);\n       }\n       // (-r) (Vector3D.plusJ) coordinates are :\n       // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n       // and we can choose to have psi in the interval [0 ; PI]\n-      Vector3D v1 = applyTo(Vector3D.plusJ);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusJ);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n       if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(false);\n       }\n       // (-r) (Vector3D.plusK) coordinates are :\n       // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n       // and we can choose to have phi in the interval [0 ; PI]\n-      Vector3D v1 = applyTo(Vector3D.plusK);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusK);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n       if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(false);\n       }\n       // (-r) (Vector3D.plusK) coordinates are :\n       // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n       // and we can choose to have theta in the interval [0 ; PI]\n-      Vector3D v1 = applyTo(Vector3D.plusK);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusK);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n       if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(false);\n       }\n                                           });\n   }\n \n-  /** Scalar coordinate of the quaternion. */\n-  private final double q0;\n-\n-  /** First coordinate of the vectorial part of the quaternion. */\n-  private final double q1;\n-\n-  /** Second coordinate of the vectorial part of the quaternion. */\n-  private final double q2;\n-\n-  /** Third coordinate of the vectorial part of the quaternion. */\n-  private final double q3;\n-\n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = 8225864499430109352L;\n+  /** Compute the <i>distance</i> between two rotations.\n+   * <p>The <i>distance</i> is intended here as a way to check if two\n+   * rotations are almost similar (i.e. they transform vectors the same way)\n+   * or very different. It is mathematically defined as the angle of\n+   * the rotation r that prepended to one of the rotations gives the other\n+   * one:</p>\n+   * <pre>\n+   *        r<sub>1</sub>(r) = r<sub>2</sub>\n+   * </pre>\n+   * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n+   * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n+   * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n+   * reached for some v. The distance is equal to 0 if and only if the two\n+   * rotations are identical.</p>\n+   * <p>Comparing two rotations should always be done using this value rather\n+   * than for example comparing the components of the quaternions. It is much\n+   * more stable, and has a geometric meaning. Also comparing quaternions\n+   * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n+   * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n+   * their components are different (they are exact opposites).</p>\n+   * @param r1 first rotation\n+   * @param r2 second rotation\n+   * @return <i>distance</i> between r1 and r2\n+   */\n+  public static double distance(Rotation r1, Rotation r2) {\n+      return r1.applyInverseTo(r2).getAngle();\n+  }\n \n }\n--- a/src/java/org/apache/commons/math/geometry/RotationOrder.java\n+++ b/src/java/org/apache/commons/math/geometry/RotationOrder.java\n    * around Z\n    */\n   public static final RotationOrder XYZ =\n-    new RotationOrder(\"XYZ\", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusK);\n+    new RotationOrder(\"XYZ\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);\n \n   /** Set of Cardan angles.\n    * this ordered set of rotations is around X, then around Z, then\n    * around Y\n    */\n   public static final RotationOrder XZY =\n-    new RotationOrder(\"XZY\", Vector3D.plusI, Vector3D.plusK, Vector3D.plusJ);\n+    new RotationOrder(\"XZY\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);\n \n   /** Set of Cardan angles.\n    * this ordered set of rotations is around Y, then around X, then\n    * around Z\n    */\n   public static final RotationOrder YXZ =\n-    new RotationOrder(\"YXZ\", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusK);\n+    new RotationOrder(\"YXZ\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);\n \n   /** Set of Cardan angles.\n    * this ordered set of rotations is around Y, then around Z, then\n    * around X\n    */\n   public static final RotationOrder YZX =\n-    new RotationOrder(\"YZX\", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusI);\n+    new RotationOrder(\"YZX\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);\n \n   /** Set of Cardan angles.\n    * this ordered set of rotations is around Z, then around X, then\n    * around Y\n    */\n   public static final RotationOrder ZXY =\n-    new RotationOrder(\"ZXY\", Vector3D.plusK, Vector3D.plusI, Vector3D.plusJ);\n+    new RotationOrder(\"ZXY\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);\n \n   /** Set of Cardan angles.\n    * this ordered set of rotations is around Z, then around Y, then\n    * around X\n    */\n   public static final RotationOrder ZYX =\n-    new RotationOrder(\"ZYX\", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusI);\n+    new RotationOrder(\"ZYX\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);\n \n   /** Set of Euler angles.\n    * this ordered set of rotations is around X, then around Y, then\n    * around X\n    */\n   public static final RotationOrder XYX =\n-    new RotationOrder(\"XYX\", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusI);\n+    new RotationOrder(\"XYX\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);\n \n   /** Set of Euler angles.\n    * this ordered set of rotations is around X, then around Z, then\n    * around X\n    */\n   public static final RotationOrder XZX =\n-    new RotationOrder(\"XZX\", Vector3D.plusI, Vector3D.plusK, Vector3D.plusI);\n+    new RotationOrder(\"XZX\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);\n \n   /** Set of Euler angles.\n    * this ordered set of rotations is around Y, then around X, then\n    * around Y\n    */\n   public static final RotationOrder YXY =\n-    new RotationOrder(\"YXY\", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusJ);\n+    new RotationOrder(\"YXY\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);\n \n   /** Set of Euler angles.\n    * this ordered set of rotations is around Y, then around Z, then\n    * around Y\n    */\n   public static final RotationOrder YZY =\n-    new RotationOrder(\"YZY\", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusJ);\n+    new RotationOrder(\"YZY\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);\n \n   /** Set of Euler angles.\n    * this ordered set of rotations is around Z, then around X, then\n    * around Z\n    */\n   public static final RotationOrder ZXZ =\n-    new RotationOrder(\"ZXZ\", Vector3D.plusK, Vector3D.plusI, Vector3D.plusK);\n+    new RotationOrder(\"ZXZ\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);\n \n   /** Set of Euler angles.\n    * this ordered set of rotations is around Z, then around Y, then\n    * around Z\n    */\n   public static final RotationOrder ZYZ =\n-    new RotationOrder(\"ZYZ\", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusK);\n+    new RotationOrder(\"ZYZ\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);\n \n   /** Name of the rotations order. */\n   private final String name;\n--- a/src/java/org/apache/commons/math/geometry/Vector3D.java\n+++ b/src/java/org/apache/commons/math/geometry/Vector3D.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.MathUtils;\n+\n /** \n  * This class implements vectors in a three-dimensional space.\n  * <p>Instance of this class are guaranteed to be immutable.</p>\n public class Vector3D\n   implements Serializable {\n \n+  /** Null vector (coordinates: 0, 0, 0). */\n+  public static final Vector3D ZERO   = new Vector3D(0, 0, 0);\n+\n   /** First canonical vector (coordinates: 1, 0, 0). */\n-  public static final Vector3D plusI = new Vector3D(1, 0, 0);\n+  public static final Vector3D PLUS_I = new Vector3D(1, 0, 0);\n \n   /** Opposite of the first canonical vector (coordinates: -1, 0, 0). */\n-  public static final Vector3D minusI = new Vector3D(-1, 0, 0);\n+  public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);\n \n   /** Second canonical vector (coordinates: 0, 1, 0). */\n-  public static final Vector3D plusJ = new Vector3D(0, 1, 0);\n+  public static final Vector3D PLUS_J = new Vector3D(0, 1, 0);\n \n   /** Opposite of the second canonical vector (coordinates: 0, -1, 0). */\n-  public static final Vector3D minusJ = new Vector3D(0, -1, 0);\n+  public static final Vector3D MINUS_J = new Vector3D(0, -1, 0);\n \n   /** Third canonical vector (coordinates: 0, 0, 1). */\n-  public static final Vector3D plusK = new Vector3D(0, 0, 1);\n+  public static final Vector3D PLUS_K = new Vector3D(0, 0, 1);\n \n   /** Opposite of the third canonical vector (coordinates: 0, 0, -1).  */\n-  public static final Vector3D minusK = new Vector3D(0, 0, -1);\n-\n-  /** Null vector (coordinates: 0, 0, 0). */\n-  public static final Vector3D zero   = new Vector3D(0, 0, 0);\n-\n-  /** Simple constructor.\n-   * Build a null vector.\n-   */\n-  public Vector3D() {\n-    x = 0;\n-    y = 0;\n-    z = 0;\n-  }\n+  public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);\n+\n+  /** A vector with all coordinates set to NaN. */\n+  public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);\n+\n+  /** A vector with all coordinates set to positive infinity. */\n+  public static final Vector3D POSITIVE_INFINITY =\n+      new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+\n+  /** A vector with all coordinates set to negative infinity. */\n+  public static final Vector3D NEGATIVE_INFINITY =\n+      new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n+\n+  /** Default format. */\n+  private static final Vector3DFormat DEFAULT_FORMAT =\n+      Vector3DFormat.getInstance();\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 5133268763396045979L;\n+\n+  /** Abscissa. */\n+  private final double x;\n+\n+  /** Ordinate. */\n+  private final double y;\n+\n+  /** Height. */\n+  private final double z;\n \n   /** Simple constructor.\n    * Build a vector from its coordinates\n     return Math.sqrt (x * x + y * y + z * z);\n   }\n \n+  /** Get the square of the norm for the vector.\n+   * @return square of the euclidian norm for the vector\n+   */\n+  public double getNormSq() {\n+    return x * x + y * y + z * z;\n+  }\n+\n   /** Get the azimuth of the vector.\n    * @return azimuth (&alpha;) of the vector, between -&pi; and +&pi;\n    * @see #Vector3D(double, double)\n   public Vector3D normalize() {\n     double s = getNorm();\n     if (s == 0) {\n-      throw new ArithmeticException(\"cannot normalize a zero norm vector\");\n+      throw MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\",\n+                                                           null);\n     }\n     return scalarMultiply(1 / s);\n   }\n \n     double threshold = 0.6 * getNorm();\n     if (threshold == 0) {\n-      throw new ArithmeticException(\"null norm\");\n+      throw MathRuntimeException.createArithmeticException(\"zero norm\", null);\n     }\n \n     if ((x >= -threshold) && (x <= threshold)) {\n \n     double normProduct = v1.getNorm() * v2.getNorm();\n     if (normProduct == 0) {\n-      throw new ArithmeticException(\"null norm\");\n+      throw MathRuntimeException.createArithmeticException(\"zero norm\", null);\n     }\n \n     double dot = dotProduct(v1, v2);\n     return new Vector3D(a * x, a * y, a * z);\n   }\n \n+  /**\n+   * Returns true if any coordinate of this vector is NaN; false otherwise\n+   * @return  true if any coordinate of this vector is NaN; false otherwise\n+   */\n+  public boolean isNaN() {\n+      return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z);        \n+  }\n+  \n+  /**\n+   * Returns true if any coordinate of this vector is infinite and none are NaN;\n+   * false otherwise\n+   * @return  true if any coordinate of this vector is infinite and none are NaN;\n+   * false otherwise\n+   */\n+  public boolean isInfinite() {\n+      return !isNaN() && (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z));        \n+  }\n+  \n+  /**\n+   * Test for the equality of two 3D vectors.\n+   * <p>\n+   * If all coordinates of two 3D vectors are exactly the same, and none are\n+   * <code>Double.NaN</code>, the two 3D vectors are considered to be equal.\n+   * </p>\n+   * <p>\n+   * <code>NaN</code> coordinates are considered to affect globally the vector\n+   * and be equals to each other - i.e, if either (or all) coordinates of the\n+   * 3D vector are equal to <code>Double.NaN</code>, the 3D vector is equal to\n+   * {@link #NaN}.\n+   * </p>\n+   *\n+   * @param other Object to test for equality to this\n+   * @return true if two 3D vector objects are equal, false if\n+   *         object is null, not an instance of Vector3D, or\n+   *         not equal to this Vector3D instance\n+   * \n+   */\n+  public boolean equals(Object other) {\n+\n+    if (this == other) { \n+      return true;\n+    }\n+\n+    if (other == null) {\n+      return false;\n+    }\n+\n+    try {\n+\n+      final Vector3D rhs = (Vector3D)other;\n+      if (rhs.isNaN()) {\n+          return this.isNaN();\n+      }\n+\n+      return (x == rhs.x) && (y == rhs.y) && (z == rhs.z); \n+\n+    } catch (ClassCastException ex) {\n+        // ignore exception\n+        return false;\n+    }\n+\n+  }\n+  \n+  /**\n+   * Get a hashCode for the 3D vector.\n+   * <p>\n+   * All NaN values have the same hash code.</p>\n+   * \n+   * @return a hash code value for this object\n+   */\n+  public int hashCode() {\n+      if (isNaN()) {\n+          return 8;\n+      }\n+      return 31 * (23 * MathUtils.hash(x) +  19 * MathUtils.hash(y) +  MathUtils.hash(z));\n+  }\n+\n   /** Compute the dot-product of two vectors.\n    * @param v1 first vector\n    * @param v2 second vector\n                         v1.x * v2.y - v1.y * v2.x);\n   }\n \n-  /** Abscissa. */\n-  private final double x;\n-\n-  /** Ordinate. */\n-  private final double y;\n-\n-  /** Height. */\n-  private final double z;\n-\n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = -5721105387745193385L;\n-\n+  /** Compute the distance between two vectors.\n+   * <p>Calling this method is equivalent to calling:\n+   * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n+   * vector is built</p>\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the distance between v1 and v2\n+   */\n+  public static double distance(Vector3D v1, Vector3D v2) {\n+    final double dx = v2.x - v1.x;\n+    final double dy = v2.y - v1.y;\n+    final double dz = v2.z - v1.z;\n+    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n+  }\n+\n+  /** Compute the square of the distance between two vectors.\n+   * <p>Calling this method is equivalent to calling:\n+   * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n+   * vector is built</p>\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the square of the distance between v1 and v2\n+   */\n+  public static double distanceSq(Vector3D v1, Vector3D v2) {\n+    final double dx = v2.x - v1.x;\n+    final double dy = v2.y - v1.y;\n+    final double dz = v2.z - v1.z;\n+    return dx * dx + dy * dy + dz * dz;\n+  }\n+\n+  /** Get a string representation of this vector.\n+   * @return a string representation of this vector\n+   */\n+  public String toString() {\n+      return DEFAULT_FORMAT.format(this);\n+  }\n \n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/geometry/Vector3DFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.CompositeFormat;\n+\n+/**\n+ * Formats a 3D vector in components list format \"{x; y; z}\".\n+ * <p>The prefix and suffix \"{\" and \"}\" and the separator \"; \" can be replaced by\n+ * any user-defined strings. The number format for components can be configured.</p>\n+ * <p>White space is ignored at parse time, even if it is in the prefix, suffix\n+ * or separator specifications. So even if the default separator does include a space\n+ * character that is used at format time, both input string \"{1;1;1}\" and\n+ * \" { 1 ; 1 ; 1 } \" will be parsed without error and the same vector will be\n+ * returned. In the second case, however, the parse position after parsing will be\n+ * just after the closing curly brace, i.e. just before the trailing space.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class Vector3DFormat extends CompositeFormat {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -5447606608652576301L;\n+\n+    /** The default prefix: \"{\". */\n+    private static final String DEFAULT_PREFIX = \"{\";\n+\n+    /** The default suffix: \"}\". */\n+    private static final String DEFAULT_SUFFIX = \"}\";\n+\n+    /** The default separator: \", \". */\n+    private static final String DEFAULT_SEPARATOR = \"; \";\n+\n+    /** Prefix. */\n+    private final String prefix;\n+\n+    /** Suffix. */\n+    private final String suffix;\n+\n+    /** Separator. */\n+    private final String separator;\n+\n+    /** Trimmed prefix. */\n+    private final String trimmedPrefix;\n+\n+    /** Trimmed suffix. */\n+    private final String trimmedSuffix;\n+\n+    /** Trimmed separator. */\n+    private final String trimmedSeparator;\n+\n+    /** The format used for components. */\n+    private NumberFormat format;\n+\n+    /**\n+     * Create an instance with default settings.\n+     * <p>The instance uses the default prefix, suffix and separator:\n+     * \"{\", \"}\", and \"; \" and the default number format for components.</p>\n+     */\n+    public Vector3DFormat() {\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with a custom number format for components.\n+     * @param format the custom format for components.\n+     */\n+    public Vector3DFormat(final NumberFormat format) {\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix and separator.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param separator separator to use instead of the default \"; \"\n+     */\n+    public Vector3DFormat(final String prefix, final String suffix,\n+                          final String separator) {\n+        this(prefix, suffix, separator, getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix, separator and format\n+     * for components.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param separator separator to use instead of the default \"; \"\n+     * @param format the custom format for components.\n+     */\n+    public Vector3DFormat(final String prefix, final String suffix,\n+                          final String separator, final NumberFormat format) {\n+        this.prefix      = prefix;\n+        this.suffix      = suffix;\n+        this.separator   = separator;\n+        trimmedPrefix    = prefix.trim();\n+        trimmedSuffix    = suffix.trim();\n+        trimmedSeparator = separator.trim();\n+        this.format      = format;\n+    }\n+\n+    /**\n+     * Get the set of locales for which 3D vectors formats are available.\n+     * <p>This is the same set as the {@link NumberFormat} set.</p>\n+     * @return available 3D vector format locales.\n+     */\n+    public static Locale[] getAvailableLocales() {\n+        return NumberFormat.getAvailableLocales();\n+    }\n+\n+    /**\n+     * Get the format prefix.\n+     * @return format prefix.\n+     */\n+    public String getPrefix() {\n+        return prefix;\n+    }\n+\n+    /**\n+     * Get the format suffix.\n+     * @return format suffix.\n+     */\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    /**\n+     * Get the format separator between components.\n+     * @return format separator.\n+     */\n+    public String getSeparator() {\n+        return separator;\n+    }\n+\n+    /**\n+     * Get the components format.\n+     * @return components format.\n+     */\n+    public NumberFormat getFormat() {\n+        return format;\n+    }\n+\n+    /**\n+     * Returns the default 3D vector format for the current locale.\n+     * @return the default 3D vector format.\n+     */\n+    public static Vector3DFormat getInstance() {\n+        return getInstance(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Returns the default 3D vector format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the 3D vector format specific to the given locale.\n+     */\n+    public static Vector3DFormat getInstance(final Locale locale) {\n+        return new Vector3DFormat(getDefaultNumberFormat(locale));\n+    }\n+\n+    /**\n+     * This static method calls {@link #format(Object)} on a default instance of\n+     * Vector3DFormat.\n+     *\n+     * @param v Vector3D object to format\n+     * @return A formatted vector\n+     */\n+    public static String formatVector3D(Vector3D v) {\n+        return getInstance().format(v);\n+    }\n+\n+    /**\n+     * Formats a {@link Vector3D} object to produce a string.\n+     * @param vector the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(Vector3D vector, StringBuffer toAppendTo,\n+                               FieldPosition pos) {\n+\n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        // format prefix\n+        toAppendTo.append(prefix);\n+\n+        // format components\n+        formatDouble(vector.getX(), format, toAppendTo, pos);\n+        toAppendTo.append(separator);\n+        formatDouble(vector.getY(), format, toAppendTo, pos);\n+        toAppendTo.append(separator);\n+        formatDouble(vector.getZ(), format, toAppendTo, pos);\n+\n+        // format suffix\n+        toAppendTo.append(suffix);\n+\n+        return toAppendTo;\n+\n+    }\n+\n+    /**\n+     * Formats a object to produce a string.\n+     * <p><code>obj</code> must be a  {@link Vector3D} object. Any other type of\n+     * object will result in an {@link IllegalArgumentException} being thrown.</p>\n+     * @param obj the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n+     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n+     */\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+                               FieldPosition pos) {\n+\n+        if (obj instanceof Vector3D) {\n+            return format( (Vector3D)obj, toAppendTo, pos);\n+        }\n+\n+        throw new IllegalArgumentException(\"Cannot format given Object as a Vector3D\");\n+\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link Vector3D} object.\n+     * @param source the string to parse\n+     * @return the parsed {@link Vector3D} object.\n+     * @exception ParseException if the beginning of the specified string\n+     *            cannot be parsed.\n+     */\n+    public Vector3D parse(String source) throws ParseException {\n+        ParsePosition parsePosition = new ParsePosition(0);\n+        Vector3D result = parse(source, parsePosition);\n+        if (parsePosition.getIndex() == 0) {\n+            throw MathRuntimeException.createParseException(\"unparseable 3D vector: \\\"{0}\\\"\",\n+                                                            new Object[] { source },\n+                                                            parsePosition.getErrorIndex());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link Vector3D} object.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link Vector3D} object.\n+     */\n+    public Vector3D parse(String source, ParsePosition pos) {\n+        int initialIndex = pos.getIndex();\n+\n+        // parse prefix\n+        parseAndIgnoreWhitespace(source, pos);\n+        if (!parseFixedstring(source, trimmedPrefix, pos)) {\n+            return null;\n+        }\n+\n+        // parse X component\n+        parseAndIgnoreWhitespace(source, pos);\n+        Number x = parseNumber(source, format, pos);\n+        if (x == null) {\n+            // invalid abscissa\n+            // set index back to initial, error index should already be set\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse Y component\n+        parseAndIgnoreWhitespace(source, pos);\n+        if (!parseFixedstring(source, trimmedSeparator, pos)) {\n+            return null;\n+        }\n+        parseAndIgnoreWhitespace(source, pos);\n+        Number y = parseNumber(source, format, pos);\n+        if (y == null) {\n+            // invalid ordinate\n+            // set index back to initial, error index should already be set\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse Z component\n+        parseAndIgnoreWhitespace(source, pos);\n+        if (!parseFixedstring(source, trimmedSeparator, pos)) {\n+            return null;\n+        }\n+        parseAndIgnoreWhitespace(source, pos);\n+        Number z = parseNumber(source, format, pos);\n+        if (z == null) {\n+            // invalid height\n+            // set index back to initial, error index should already be set\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse suffix\n+        parseAndIgnoreWhitespace(source, pos);\n+        if (!parseFixedstring(source, trimmedSuffix, pos)) {\n+            return null;\n+        }\n+\n+        return new Vector3D(x.doubleValue(), y.doubleValue(), z.doubleValue());\n+\n+    }\n+\n+    /**\n+     * Parses a string to produce a object.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed object.\n+     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n+     */\n+    public Object parseObject(String source, ParsePosition pos) {\n+        return parse(source, pos);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/BiDiagonalTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Class transforming any matrix to bi-diagonal shape.\n+ * <p>Any m &times; n matrix A can be written as the product of three matrices:\n+ * A = U &times; B &times; V<sup>T</sup> with U an m &times; m orthogonal matrix,\n+ * B an m &times; n bi-diagonal matrix (lower diagonal if m &lt; n, upper diagonal\n+ * otherwise), and V an n &times; n orthogonal matrix.</p>\n+ * <p>Transformation to bi-diagonal shape is often not a goal by itself, but it is\n+ * an intermediate step in more general decomposition algorithms like {@link\n+ * SingularValueDecomposition Singular Value Decomposition}. This class is therefore\n+ * intended for internal use by the library and is not public. As a consequence of\n+ * this explicitly limited scope, many methods directly returns references to\n+ * internal arrays, not copies.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+class BiDiagonalTransformer implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 8935390784125343332L;\n+\n+    /** Householder vectors. */\n+    private final double householderVectors[][];\n+\n+    /** Main diagonal. */\n+    private final double[] main;\n+\n+    /** Secondary diagonal. */\n+    private final double[] secondary;\n+\n+    /** Cached value of U. */\n+    private RealMatrix cachedU;\n+\n+    /** Cached value of B. */\n+    private RealMatrix cachedB;\n+\n+    /** Cached value of V. */\n+    private RealMatrix cachedV;\n+\n+    /**\n+     * Build the transformation to bi-diagonal shape of a matrix. \n+     * @param matrix the matrix to transform.\n+     */\n+    public BiDiagonalTransformer(RealMatrix matrix) {\n+\n+        final int m = matrix.getRowDimension();\n+        final int n = matrix.getColumnDimension();\n+        final int p = Math.min(m, n);\n+        householderVectors = matrix.getData();\n+        main      = new double[p];\n+        secondary = new double[p - 1];\n+        cachedU   = null;\n+        cachedB   = null;\n+        cachedV   = null;\n+\n+        // transform matrix\n+        if (m >= n) {\n+            transformToUpperBiDiagonal();\n+        } else {\n+            transformToLowerBiDiagonal();\n+        }\n+\n+    }\n+\n+    /**\n+     * Returns the matrix U of the transform. \n+     * <p>U is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the U matrix\n+     */\n+    public RealMatrix getU() {\n+\n+        if (cachedU == null) {\n+\n+            final int m = householderVectors.length;\n+            final int n = householderVectors[0].length;\n+            final int p = main.length;\n+            final int diagOffset    = (m >= n) ? 0 : 1;\n+            final double[] diagonal = (m >= n) ? main : secondary;\n+            final double[][] uData  = new double[m][m];\n+\n+            // fill up the part of the matrix not affected by Householder transforms\n+            for (int k = m - 1; k >= p; --k) {\n+                uData[k][k] = 1;\n+            }\n+\n+            // build up first part of the matrix by applying Householder transforms\n+            for (int k = p - 1; k >= diagOffset; --k) {\n+                final double[] hK = householderVectors[k];\n+                uData[k][k] = 1;\n+                if (hK[k - diagOffset] != 0.0) {\n+                    for (int j = k; j < m; ++j) {\n+                        double alpha = 0;\n+                        for (int i = k; i < m; ++i) {\n+                            alpha -= uData[i][j] * householderVectors[i][k - diagOffset];\n+                        }\n+                        alpha /= diagonal[k - diagOffset] * hK[k - diagOffset];\n+\n+                        for (int i = k; i < m; ++i) {\n+                            uData[i][j] -= alpha * householderVectors[i][k - diagOffset];\n+                        }\n+                    }\n+                }\n+            }\n+            if (diagOffset > 0) {\n+                uData[0][0] = 1;\n+            }\n+\n+            // cache the matrix for subsequent calls\n+            cachedU = new RealMatrixImpl(uData, false);\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedU;\n+\n+    }\n+\n+    /**\n+     * Returns the bi-diagonal matrix B of the transform. \n+     * @return the B matrix\n+     */\n+    public RealMatrix getB() {\n+\n+        if (cachedB == null) {\n+\n+            final int m = householderVectors.length;\n+            final int n = householderVectors[0].length;\n+            double[][] bData = new double[m][n];\n+            for (int i = 0; i < main.length; ++i) {\n+                double[] bDataI = bData[i];\n+                bDataI[i] = main[i];\n+                if (m < n) {\n+                    if (i > 0) {\n+                        bDataI[i - 1] = secondary[i - 1];\n+                    }\n+                } else {\n+                    if (i < main.length - 1) {\n+                        bDataI[i + 1] = secondary[i];\n+                    }\n+                }\n+            }\n+\n+            // cache the matrix for subsequent calls\n+            cachedB = new RealMatrixImpl(bData, false);\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedB;\n+\n+    }\n+\n+    /**\n+     * Returns the matrix V of the transform. \n+     * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the V matrix\n+     */\n+    public RealMatrix getV() {\n+\n+        if (cachedV == null) {\n+\n+            final int m = householderVectors.length;\n+            final int n = householderVectors[0].length;\n+            final int p = main.length;\n+            final int diagOffset    = (m >= n) ? 1 : 0;\n+            final double[] diagonal = (m >= n) ? secondary : main;\n+            final double[][] vData  = new double[n][n];\n+\n+            // fill up the part of the matrix not affected by Householder transforms\n+            for (int k = n - 1; k >= p; --k) {\n+                vData[k][k] = 1;\n+            }\n+\n+            // build up first part of the matrix by applying Householder transforms\n+            for (int k = p - 1; k >= diagOffset; --k) {\n+                final double[] hK = householderVectors[k - diagOffset];\n+                vData[k][k] = 1;\n+                if (hK[k] != 0.0) {\n+                    for (int j = k; j < n; ++j) {\n+                        double beta = 0;\n+                        for (int i = k; i < n; ++i) {\n+                            beta -= vData[i][j] * hK[i];\n+                        }\n+                        beta /= diagonal[k - diagOffset] * hK[k];\n+\n+                        for (int i = k; i < n; ++i) {\n+                            vData[i][j] -= beta * hK[i];\n+                        }\n+                    }\n+                }\n+            }\n+            if (diagOffset > 0) {\n+                vData[0][0] = 1;\n+            }\n+\n+            // cache the matrix for subsequent calls\n+            cachedV = new RealMatrixImpl(vData, false);\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedV;\n+\n+    }\n+\n+    /**\n+     * Get the Householder vectors of the transform.\n+     * <p>Note that since this class is only intended for internal use,\n+     * it returns directly a reference to its internal arrays, not a copy.</p>\n+     * @return the main diagonal elements of the B matrix\n+     */\n+    double[][] getHouseholderVectorsRef() {\n+        return householderVectors;\n+    }\n+\n+    /**\n+     * Get the main diagonal elements of the matrix B of the transform.\n+     * <p>Note that since this class is only intended for internal use,\n+     * it returns directly a reference to its internal arrays, not a copy.</p>\n+     * @return the main diagonal elements of the B matrix\n+     */\n+    double[] getMainDiagonalRef() {\n+        return main;\n+    }\n+\n+    /**\n+     * Get the secondary diagonal elements of the matrix B of the transform.\n+     * <p>Note that since this class is only intended for internal use,\n+     * it returns directly a reference to its internal arrays, not a copy.</p>\n+     * @return the secondary diagonal elements of the B matrix\n+     */\n+    double[] getSecondaryDiagonalRef() {\n+        return secondary;\n+    }\n+\n+    /**\n+     * Check if the matrix is transformed to upper bi-diagonal.\n+     * @return true if the matrix is transformed to upper bi-diagonal\n+     */\n+    boolean isUpperBiDiagonal() {\n+        return householderVectors.length >=  householderVectors[0].length;\n+    }\n+\n+    /**\n+     * Transform original matrix to upper bi-diagonal form.\n+     * <p>Transformation is done using alternate Householder transforms\n+     * on columns and rows.</p>\n+     */\n+    private void transformToUpperBiDiagonal() {\n+\n+        final int m = householderVectors.length;\n+        final int n = householderVectors[0].length;\n+        for (int k = 0; k < n; k++) {\n+\n+            //zero-out a column\n+            double xNormSqr = 0;\n+            for (int i = k; i < m; ++i) {\n+                final double c = householderVectors[i][k];\n+                xNormSqr += c * c;\n+            }\n+            final double[] hK = householderVectors[k];\n+            final double a = (hK[k] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+            main[k] = a;\n+            if (a != 0.0) {\n+                hK[k] -= a;\n+                for (int j = k + 1; j < n; ++j) {\n+                    double alpha = 0;\n+                    for (int i = k; i < m; ++i) {\n+                        final double[] hI = householderVectors[i];\n+                        alpha -= hI[j] * hI[k];\n+                    }\n+                    alpha /= a * householderVectors[k][k];\n+                    for (int i = k; i < m; ++i) {\n+                        final double[] hI = householderVectors[i];\n+                        hI[j] -= alpha * hI[k];\n+                    }\n+                }\n+            }\n+\n+            if (k < n - 1) {\n+                //zero-out a row\n+                xNormSqr = 0;\n+                for (int j = k + 1; j < n; ++j) {\n+                    final double c = hK[j];\n+                    xNormSqr += c * c;\n+                }\n+                final double b = (hK[k + 1] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+                secondary[k] = b;\n+                if (b != 0.0) {\n+                    hK[k + 1] -= b;\n+                    for (int i = k + 1; i < m; ++i) {\n+                        final double[] hI = householderVectors[i];\n+                        double beta = 0;\n+                        for (int j = k + 1; j < n; ++j) {\n+                            beta -= hI[j] * hK[j];\n+                        }\n+                        beta /= b * hK[k + 1];\n+                        for (int j = k + 1; j < n; ++j) {\n+                            hI[j] -= beta * hK[j];\n+                        }\n+                    }\n+                }\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Transform original matrix to lower bi-diagonal form.\n+     * <p>Transformation is done using alternate Householder transforms\n+     * on rows and columns.</p>\n+     */\n+    private void transformToLowerBiDiagonal() {\n+\n+        final int m = householderVectors.length;\n+        final int n = householderVectors[0].length;\n+        for (int k = 0; k < m; k++) {\n+\n+            //zero-out a row\n+            final double[] hK = householderVectors[k];\n+            double xNormSqr = 0;\n+            for (int j = k; j < n; ++j) {\n+                final double c = hK[j];\n+                xNormSqr += c * c;\n+            }\n+            final double a = (hK[k] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+            main[k] = a;\n+            if (a != 0.0) {\n+                hK[k] -= a;\n+                for (int i = k + 1; i < m; ++i) {\n+                    final double[] hI = householderVectors[i];\n+                    double alpha = 0;\n+                    for (int j = k; j < n; ++j) {\n+                        alpha -= hI[j] * hK[j];\n+                    }\n+                    alpha /= a * householderVectors[k][k];\n+                    for (int j = k; j < n; ++j) {\n+                        hI[j] -= alpha * hK[j];\n+                    }\n+                }\n+            }\n+\n+            if (k < m - 1) {\n+                //zero-out a column\n+                final double[] hKp1 = householderVectors[k + 1];\n+                xNormSqr = 0;\n+                for (int i = k + 1; i < m; ++i) {\n+                    final double c = householderVectors[i][k];\n+                    xNormSqr += c * c;\n+                }\n+                final double b = (hKp1[k] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+                secondary[k] = b;\n+                if (b != 0.0) {\n+                    hKp1[k] -= b;\n+                    for (int j = k + 1; j < n; ++j) {\n+                        double beta = 0;\n+                        for (int i = k + 1; i < m; ++i) {\n+                            final double[] hI = householderVectors[i];\n+                            beta -= hI[j] * hI[k];\n+                        }\n+                        beta /= b * hKp1[k];\n+                        for (int i = k + 1; i < m; ++i) {\n+                            final double[] hI = householderVectors[i];\n+                            hI[j] -= beta * hI[k];\n+                        }\n+                    }\n+                }\n+            }\n+\n+        }\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n package org.apache.commons.math.linear;\n import java.io.Serializable;\n import java.math.BigDecimal;\n+\n+import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * Implementation of {@link BigMatrix} using a BigDecimal[][] array to store entries\n     private static final long serialVersionUID = -1011428905656140431L;\n     \n     /** Entries of the matrix */\n-    private BigDecimal data[][] = null;\n+    protected BigDecimal data[][] = null;\n     \n     /** Entries of cached LU decomposition.\n      *  All updates to data (other than luDecompose()) *must* set this to null\n      */\n-    private BigDecimal lu[][] = null;\n+    protected BigDecimal lu[][] = null;\n     \n     /** Permutation associated with LU decomposition */\n-    private int[] permutation = null;\n+    protected int[] permutation = null;\n     \n     /** Parity of the permutation associated with the LU decomposition */\n-    private int parity = 1;\n+    protected int parity = 1;\n     \n     /** Rounding mode for divisions **/\n     private int roundingMode = BigDecimal.ROUND_HALF_UP;\n     private int scale = 64;\n     \n     /** Bound to determine effective singularity in LU decomposition */\n-    protected static BigDecimal TOO_SMALL = new BigDecimal(10E-12);\n+    private static final BigDecimal TOO_SMALL = new BigDecimal(10E-12);\n     \n     /** BigDecimal 0 */\n     static final BigDecimal ZERO = new BigDecimal(0);\n     /**\n      * Create a new BigMatrix using <code>d</code> as the underlying\n      * data array.\n-     * <p>\n-     * The input array is copied, not referenced.</p>\n+     * <p>The input array is copied, not referenced. This constructor has\n+     * the same effect as calling {@link #BigMatrixImpl(BigDecimal[][], boolean)}\n+     * with the second argument set to <code>true</code>.</p>\n      *\n      * @param d data for new matrix\n      * @throws IllegalArgumentException if <code>d</code> is not rectangular\n         this.copyIn(d);\n         lu = null;\n     }\n-    \n+\n+    /**\n+     * Create a new BigMatrix using the input array as the underlying\n+     * data array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * BigMatrix and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param d data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #BigMatrixImpl(BigDecimal[][])\n+     */\n+    public BigMatrixImpl(BigDecimal[][] d, boolean copyArray) {\n+        if (copyArray) {\n+            copyIn(d);\n+        } else {\n+            if (d == null) {\n+                throw new NullPointerException();\n+            }   \n+            final int nRows = d.length;\n+            if (nRows == 0) {\n+                throw new IllegalArgumentException(\"Matrix must have at least one row.\"); \n+            }\n+            final int nCols = d[0].length;\n+            if (nCols == 0) {\n+                throw new IllegalArgumentException(\"Matrix must have at least one column.\"); \n+            }\n+            for (int r = 1; r < nRows; r++) {\n+                if (d[r].length != nCols) {\n+                    throw new IllegalArgumentException(\"All input rows must have the same length.\");\n+                }\n+            }       \n+            data = d;\n+        }\n+        lu = null;\n+    }\n+\n     /**\n      * Create a new BigMatrix using <code>d</code> as the underlying\n      * data array.\n-     * <p>\n-     * The input array is copied, not referenced.</p>\n+     * <p>Since the underlying array will hold <code>BigDecimal</code>\n+     * instances, it will be created.</p>\n      *\n      * @param d data for new matrix\n      * @throws IllegalArgumentException if <code>d</code> is not rectangular\n      * @throws NullPointerException if <code>d</code> is null\n      */\n     public BigMatrixImpl(double[][] d) {\n-        int nRows = d.length;\n+        final int nRows = d.length;\n         if (nRows == 0) {\n             throw new IllegalArgumentException(\n             \"Matrix must have at least one row.\"); \n         }\n-        int nCols = d[0].length;\n+        final int nCols = d[0].length;\n         if (nCols == 0) {\n             throw new IllegalArgumentException(\n             \"Matrix must have at least one column.\"); \n      * @throws NullPointerException if <code>d</code> is null\n      */\n     public BigMatrixImpl(String[][] d) {\n-        int nRows = d.length;\n+        final int nRows = d.length;\n         if (nRows == 0) {\n             throw new IllegalArgumentException(\n             \"Matrix must have at least one row.\"); \n         }\n-        int nCols = d[0].length;\n+        final int nCols = d[0].length;\n         if (nCols == 0) {\n             throw new IllegalArgumentException(\n             \"Matrix must have at least one column.\"); \n      * @param v column vector holding data for new matrix\n      */\n     public BigMatrixImpl(BigDecimal[] v) {\n-        int nRows = v.length;\n+        final int nRows = v.length;\n         data = new BigDecimal[nRows][1];\n         for (int row = 0; row < nRows; row++) {\n             data[row][0] = v[row];\n      * @return  the cloned matrix\n      */\n     public BigMatrix copy() {\n-        return new BigMatrixImpl(this.copyOut());\n+        return new BigMatrixImpl(this.copyOut(), false);\n     }\n     \n     /**\n      *\n      * @param m    matrix to be added\n      * @return     this + m\n-     * @exception  IllegalArgumentException if m is not the same size as this\n+     * @throws  IllegalArgumentException if m is not the same size as this\n      */\n     public BigMatrix add(BigMatrix m) throws IllegalArgumentException {\n-        if (this.getColumnDimension() != m.getColumnDimension() ||\n-                this.getRowDimension() != m.getRowDimension()) {\n+        try {\n+            return add((BigMatrixImpl) m);\n+        } catch (ClassCastException cce) {\n+            final int rowCount    = getRowDimension();\n+            final int columnCount = getColumnDimension();\n+            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n+                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n+            }\n+            final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+            for (int row = 0; row < rowCount; row++) {\n+                final BigDecimal[] dataRow    = data[row];\n+                final BigDecimal[] outDataRow = outData[row];\n+                for (int col = 0; col < columnCount; col++) {\n+                    outDataRow[col] = dataRow[col].add(m.getEntry(row, col));\n+                }  \n+            }\n+            return new BigMatrixImpl(outData, false);\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public BigMatrixImpl add(BigMatrixImpl m) throws IllegalArgumentException {\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n             throw new IllegalArgumentException(\"matrix dimension mismatch\");\n         }\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n+            final BigDecimal[] dataRow    = data[row];\n+            final BigDecimal[] mRow       = m.data[row];\n+            final BigDecimal[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col].add(m.getEntry(row, col));\n-            }\n-        }\n-        return new BigMatrixImpl(outData);\n-    }\n-    \n+                outDataRow[col] = dataRow[col].add(mRow[col]);\n+            }  \n+        }\n+        return new BigMatrixImpl(outData, false);\n+    }\n+\n     /**\n      * Compute  this minus <code>m</code>.\n      *\n      * @param m    matrix to be subtracted\n      * @return     this + m\n-     * @exception  IllegalArgumentException if m is not the same size as *this\n+     * @throws  IllegalArgumentException if m is not the same size as this\n      */\n     public BigMatrix subtract(BigMatrix m) throws IllegalArgumentException {\n-        if (this.getColumnDimension() != m.getColumnDimension() ||\n-                this.getRowDimension() != m.getRowDimension()) {\n+        try {\n+            return subtract((BigMatrixImpl) m);\n+        } catch (ClassCastException cce) {\n+            final int rowCount    = getRowDimension();\n+            final int columnCount = getColumnDimension();\n+            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n+                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n+            }\n+            final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+            for (int row = 0; row < rowCount; row++) {\n+                final BigDecimal[] dataRow    = data[row];\n+                final BigDecimal[] outDataRow = outData[row];\n+                for (int col = 0; col < columnCount; col++) {\n+                    outDataRow[col] = dataRow[col].subtract(getEntry(row, col));\n+                }  \n+            }\n+            return new BigMatrixImpl(outData, false);\n+        }\n+    }\n+\n+    /**\n+     * Compute  this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public BigMatrixImpl subtract(BigMatrixImpl m) throws IllegalArgumentException {\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n             throw new IllegalArgumentException(\"matrix dimension mismatch\");\n         }\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n+            final BigDecimal[] dataRow    = data[row];\n+            final BigDecimal[] mRow       = m.data[row];\n+            final BigDecimal[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col].subtract(m.getEntry(row, col));\n-            }\n-        }\n-        return new BigMatrixImpl(outData);\n-    }\n-    \n+                outDataRow[col] = dataRow[col].subtract(mRow[col]);\n+            }  \n+        }\n+        return new BigMatrixImpl(outData, false);\n+    }\n+\n     /**\n      * Returns the result of adding d to each entry of this.\n      *\n      * @return     d + this\n      */\n     public BigMatrix scalarAdd(BigDecimal d) {\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n+            final BigDecimal[] dataRow    = data[row];\n+            final BigDecimal[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col].add(d);\n-            }\n-        }\n-        return new BigMatrixImpl(outData);\n-    }\n-    \n-    /**\n-     * Returns the result multiplying each entry of this by <code>d</code>\n+                outDataRow[col] = dataRow[col].add(d);\n+            }\n+        }\n+        return new BigMatrixImpl(outData, false);\n+    }\n+\n+    /**\n+     * Returns the result of multiplying each entry of this by <code>d</code>\n      * @param d  value to multiply all entries by\n      * @return d * this\n      */\n     public BigMatrix scalarMultiply(BigDecimal d) {\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n+            final BigDecimal[] dataRow    = data[row];\n+            final BigDecimal[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col].multiply(d);\n-            }\n-        }\n-        return new BigMatrixImpl(outData);\n-    }\n-    \n+                outDataRow[col] = dataRow[col].multiply(d);\n+            }\n+        }\n+        return new BigMatrixImpl(outData, false);\n+    }\n+\n     /**\n      * Returns the result of postmultiplying this by <code>m</code>.\n      * @param m    matrix to postmultiply by\n      *             if columnDimension(this) != rowDimension(m)\n      */\n     public BigMatrix multiply(BigMatrix m) throws IllegalArgumentException {\n+        try {\n+            return multiply((BigMatrixImpl) m);\n+        } catch (ClassCastException cce) {\n+            if (this.getColumnDimension() != m.getRowDimension()) {\n+                throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n+            }\n+            final int nRows = this.getRowDimension();\n+            final int nCols = m.getColumnDimension();\n+            final int nSum = this.getColumnDimension();\n+            final BigDecimal[][] outData = new BigDecimal[nRows][nCols];\n+            for (int row = 0; row < nRows; row++) {\n+                final BigDecimal[] dataRow    = data[row];\n+                final BigDecimal[] outDataRow = outData[row];\n+                for (int col = 0; col < nCols; col++) {\n+                    BigDecimal sum = ZERO;\n+                    for (int i = 0; i < nSum; i++) {\n+                        sum = sum.add(dataRow[i].multiply(m.getEntry(i, col)));\n+                    }\n+                    outDataRow[col] = sum;\n+                }\n+            }\n+            return new BigMatrixImpl(outData, false);\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by <code>m</code>.\n+     * @param m    matrix to postmultiply by\n+     * @return     this*m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public BigMatrixImpl multiply(BigMatrixImpl m) throws IllegalArgumentException {\n         if (this.getColumnDimension() != m.getRowDimension()) {\n             throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n         }\n-        int nRows = this.getRowDimension();\n-        int nCols = m.getColumnDimension();\n-        int nSum = this.getColumnDimension();\n-        BigDecimal[][] outData = new BigDecimal[nRows][nCols];\n-        BigDecimal sum = ZERO;\n+        final int nRows = this.getRowDimension();\n+        final int nCols = m.getColumnDimension();\n+        final int nSum = this.getColumnDimension();\n+        final BigDecimal[][] outData = new BigDecimal[nRows][nCols];\n         for (int row = 0; row < nRows; row++) {\n+            final BigDecimal[] dataRow    = data[row];\n+            final BigDecimal[] outDataRow = outData[row];\n             for (int col = 0; col < nCols; col++) {\n-                sum = ZERO;\n+                BigDecimal sum = ZERO;\n                 for (int i = 0; i < nSum; i++) {\n-                    sum = sum.add(data[row][i].multiply(m.getEntry(i, col)));\n+                    sum = sum.add(dataRow[i].multiply(m.data[i][col]));\n                 }\n-                outData[row][col] = sum;\n-            }\n-        }\n-        return new BigMatrixImpl(outData);\n-    }\n-    \n+                outDataRow[col] = sum;\n+            }\n+        }            \n+        return new BigMatrixImpl(outData, false);\n+    }\n+\n     /**\n      * Returns the result premultiplying this by <code>m</code>.\n      * @param m    matrix to premultiply by\n     public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException {\n         return m.multiply(this);\n     }\n-    \n+\n     /**\n      * Returns matrix entries as a two-dimensional array.\n      * <p>\n      * @return    2-dimensional array of entries\n      */\n     public double[][] getDataAsDoubleArray() {\n-        int nRows = getRowDimension();\n-        int nCols = getColumnDimension();\n-        double d[][] = new double[nRows][nCols];\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        final double d[][] = new double[nRows][nCols];\n         for (int i = 0; i < nRows; i++) {\n-            for (int j=0; j<nCols;j++) {\n+            for (int j = 0; j < nCols; j++) {\n                 d[i][j] = data[i][j].doubleValue();\n             }\n         }\n      *         specified rows and columns\n      * @exception MatrixIndexException if row or column selections are not valid\n      */\n-    public BigMatrix getSubMatrix(int startRow, int endRow, int startColumn,\n-            int endColumn) throws MatrixIndexException {\n-        if (startRow < 0 || startRow > endRow || endRow > data.length ||\n-                startColumn < 0 || startColumn > endColumn ||\n-                endColumn > data[0].length ) {\n-            throw new MatrixIndexException(\n-            \"invalid row or column index selection\");\n-        }\n-        BigMatrixImpl subMatrix = new BigMatrixImpl(endRow - startRow+1,\n-                endColumn - startColumn+1);\n-        BigDecimal[][] subMatrixData = subMatrix.getDataRef();\n+    public BigMatrix getSubMatrix(int startRow, int endRow,\n+                                  int startColumn, int endColumn)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(startRow);\n+        checkRowIndex(endRow);\n+        if (startRow > endRow) {\n+            throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n+                                           new Object[] { startRow, endRow });\n+        }\n+\n+        checkColumnIndex(startColumn);\n+        checkColumnIndex(endColumn);\n+        if (startColumn > endColumn) {\n+            throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n+                                           new Object[] { startColumn, endColumn });\n+        }\n+\n+        final BigDecimal[][] subMatrixData =\n+            new BigDecimal[endRow - startRow + 1][endColumn - startColumn + 1];\n         for (int i = startRow; i <= endRow; i++) {\n-            for (int j = startColumn; j <= endColumn; j++) {\n-                subMatrixData[i - startRow][j - startColumn] = data[i][j];\n-            }\n-        }\n-        return subMatrix;\n+            System.arraycopy(data[i], startColumn,\n+                             subMatrixData[i - startRow], 0,\n+                             endColumn - startColumn + 1);\n+        }\n+\n+        return new BigMatrixImpl(subMatrixData, false);\n+\n     }\n     \n     /**\n      *     are not valid\n      */\n     public BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n-    throws MatrixIndexException {\n+        throws MatrixIndexException {\n+\n         if (selectedRows.length * selectedColumns.length == 0) {\n-            throw new MatrixIndexException(\n-            \"selected row and column index arrays must be non-empty\");\n-        }\n-        BigMatrixImpl subMatrix = new BigMatrixImpl(selectedRows.length,\n-                selectedColumns.length);\n-        BigDecimal[][] subMatrixData = subMatrix.getDataRef();\n+            if (selectedRows.length == 0) {\n+                throw new MatrixIndexException(\"empty selected row index array\", null);\n+            }\n+            throw new MatrixIndexException(\"empty selected column index array\", null);\n+        }\n+\n+        final BigDecimal[][] subMatrixData =\n+            new BigDecimal[selectedRows.length][selectedColumns.length];\n         try  {\n             for (int i = 0; i < selectedRows.length; i++) {\n+                final BigDecimal[] subI = subMatrixData[i];\n+                final BigDecimal[] dataSelectedI = data[selectedRows[i]];\n                 for (int j = 0; j < selectedColumns.length; j++) {\n-                    subMatrixData[i][j] = data[selectedRows[i]][selectedColumns[j]];\n+                    subI[j] = dataSelectedI[selectedColumns[j]];\n                 }\n             }\n-        }\n-        catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\"matrix dimension mismatch\");\n-        }\n-        return subMatrix;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            // we redo the loop with checks enabled\n+            // in order to generate an appropriate message\n+            for (final int row : selectedRows) {\n+                checkRowIndex(row);\n+            }\n+            for (final int column : selectedColumns) {\n+                checkColumnIndex(column);\n+            }\n+        }\n+        return new BigMatrixImpl(subMatrixData, false);\n     } \n     \n     /**\n      */\n     public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column) \n     throws MatrixIndexException {\n-        if ((row < 0) || (column < 0)){\n-            throw new MatrixIndexException\n-            (\"invalid row or column index selection\");          \n-        }\n-        int nRows = subMatrix.length;\n+\n+        final int nRows = subMatrix.length;\n+        final int nCols = subMatrix[0].length;\n+\n         if (nRows == 0) {\n-            throw new IllegalArgumentException(\n-            \"Matrix must have at least one row.\"); \n-        }\n-        int nCols = subMatrix[0].length;\n+            throw new IllegalArgumentException(\"Matrix must have at least one row.\"); \n+        }\n         if (nCols == 0) {\n-            throw new IllegalArgumentException(\n-            \"Matrix must have at least one column.\"); \n-        }\n+            throw new IllegalArgumentException(\"Matrix must have at least one column.\"); \n+        }\n+\n         for (int r = 1; r < nRows; r++) {\n             if (subMatrix[r].length != nCols) {\n-                throw new IllegalArgumentException(\n-                \"All input rows must have the same length.\");\n-            }\n-        }       \n+                throw new IllegalArgumentException(\"All input rows must have the same length.\");\n+            }\n+        }\n+\n         if (data == null) {\n-            if ((row > 0)||(column > 0)) throw new MatrixIndexException\n-            (\"matrix must be initialized to perfom this method\");\n+            if (row > 0) {\n+                throw MathRuntimeException.createIllegalStateException(\"first {0} rows are not initialized yet\",\n+                                                                       new Object[] { row });\n+            }\n+            if (column > 0) {\n+                throw MathRuntimeException.createIllegalStateException(\"first {0} columns are not initialized yet\",\n+                                                                       new Object[] { column });\n+            }\n             data = new BigDecimal[nRows][nCols];\n             System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);          \n-        }   \n-        if (((nRows + row) > this.getRowDimension()) ||\n-            (nCols + column > this.getColumnDimension()))\n-            throw new MatrixIndexException(\n-            \"invalid row or column index selection\");                   \n+        } else {\n+            checkRowIndex(row);\n+            checkColumnIndex(column);\n+            checkRowIndex(nRows + row - 1);\n+            checkColumnIndex(nCols + column - 1);\n+        }\n         for (int i = 0; i < nRows; i++) {\n             System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);\n         } \n+\n         lu = null;\n+\n     }\n     \n     /**\n      * @throws MatrixIndexException if the specified row index is invalid\n      */\n     public BigMatrix getRowMatrix(int row) throws MatrixIndexException {\n-        if ( !isValidCoordinate( row, 0)) {\n-            throw new MatrixIndexException(\"illegal row argument\");\n-        }\n-        int ncols = this.getColumnDimension();\n-        BigDecimal[][] out = new BigDecimal[1][ncols]; \n+        checkRowIndex(row);\n+        final int ncols = this.getColumnDimension();\n+        final BigDecimal[][] out = new BigDecimal[1][ncols]; \n         System.arraycopy(data[row], 0, out[0], 0, ncols);\n-        return new BigMatrixImpl(out);\n+        return new BigMatrixImpl(out, false);\n     } \n     \n     /**\n      * @throws MatrixIndexException if the specified column index is invalid\n      */\n     public BigMatrix getColumnMatrix(int column) throws MatrixIndexException {\n-        if ( !isValidCoordinate( 0, column)) {\n-            throw new MatrixIndexException(\"illegal column argument\");\n-        }\n-        int nRows = this.getRowDimension();\n-        BigDecimal[][] out = new BigDecimal[nRows][1]; \n+        checkColumnIndex(column);\n+        final int nRows = this.getRowDimension();\n+        final BigDecimal[][] out = new BigDecimal[nRows][1]; \n         for (int row = 0; row < nRows; row++) {\n             out[row][0] = data[row][column];\n         }\n-        return new BigMatrixImpl(out);\n+        return new BigMatrixImpl(out, false);\n     }\n     \n     /**\n      * @throws MatrixIndexException if the specified row index is not valid\n      */\n     public BigDecimal[] getRow(int row) throws MatrixIndexException {\n-        if ( !isValidCoordinate( row, 0 ) ) {\n-            throw new MatrixIndexException(\"illegal row argument\");\n-        }\n-        int ncols = this.getColumnDimension();\n-        BigDecimal[] out = new BigDecimal[ncols];\n+        checkRowIndex(row);\n+        final int ncols = this.getColumnDimension();\n+        final BigDecimal[] out = new BigDecimal[ncols];\n         System.arraycopy(data[row], 0, out, 0, ncols);\n         return out;\n     }\n      * @throws MatrixIndexException if the specified row index is not valid\n      */\n     public double[] getRowAsDoubleArray(int row) throws MatrixIndexException {\n-        if ( !isValidCoordinate( row, 0 ) ) {\n-            throw new MatrixIndexException(\"illegal row argument\");\n-        }\n-        int ncols = this.getColumnDimension();\n-        double[] out = new double[ncols];\n+        checkRowIndex(row);\n+        final int ncols = this.getColumnDimension();\n+        final double[] out = new double[ncols];\n         for (int i=0;i<ncols;i++) {\n             out[i] = data[row][i].doubleValue();\n         }\n      * @throws MatrixIndexException if the specified column index is not valid\n      */\n     public BigDecimal[] getColumn(int col) throws MatrixIndexException {\n-        if ( !isValidCoordinate(0, col) ) {\n-            throw new MatrixIndexException(\"illegal column argument\");\n-        }\n-        int nRows = this.getRowDimension();\n-        BigDecimal[] out = new BigDecimal[nRows];\n+        checkColumnIndex(col);\n+        final int nRows = this.getRowDimension();\n+        final BigDecimal[] out = new BigDecimal[nRows];\n         for (int i = 0; i < nRows; i++) {\n             out[i] = data[i][col];\n         }\n      * @throws MatrixIndexException if the specified column index is not valid\n      */\n     public double[] getColumnAsDoubleArray(int col) throws MatrixIndexException {\n-        if ( !isValidCoordinate( 0, col ) ) {\n-            throw new MatrixIndexException(\"illegal column argument\");\n-        }\n-        int nrows = this.getRowDimension();\n-        double[] out = new double[nrows];\n+        checkColumnIndex(col);\n+        final int nrows = this.getRowDimension();\n+        final double[] out = new double[nrows];\n         for (int i=0;i<nrows;i++) {\n             out[i] = data[i][col].doubleValue();\n         }\n      */\n     public BigDecimal getEntry(int row, int column)\n     throws MatrixIndexException {\n-        if (!isValidCoordinate(row,column)) {\n-            throw new MatrixIndexException(\"matrix entry does not exist\");\n-        }\n-        return data[row][column];\n+        try {\n+            return data[row][column];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                                           new Object[] {\n+                                               row, column,\n+                                               getRowDimension(), getColumnDimension()\n+                                           });\n+        }\n     }\n     \n     /**\n      * @return transpose matrix\n      */\n     public BigMatrix transpose() {\n-        int nRows = this.getRowDimension();\n-        int nCols = this.getColumnDimension();\n-        BigMatrixImpl out = new BigMatrixImpl(nCols, nRows);\n-        BigDecimal[][] outData = out.getDataRef();\n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n+        final BigDecimal[][] outData = new BigDecimal[nCols][nRows];\n         for (int row = 0; row < nRows; row++) {\n+            final BigDecimal[] dataRow = data[row];\n             for (int col = 0; col < nCols; col++) {\n-                outData[col][row] = data[row][col];\n-            }\n-        }\n-        return out;\n+                outData[col][row] = dataRow[col];\n+            }\n+        }\n+        return new BigMatrixImpl(outData, false);\n     }\n     \n     /**\n      * @throws InvalidMatrixException if this is not invertible\n      */\n     public BigMatrix inverse() throws InvalidMatrixException {\n-        return solve(MatrixUtils.createBigIdentityMatrix\n-                (this.getRowDimension()));\n+        return solve(MatrixUtils.createBigIdentityMatrix(getRowDimension()));\n     }\n     \n     /**\n      */\n     public BigDecimal getDeterminant() throws InvalidMatrixException {\n         if (!isSquare()) {\n-            throw new InvalidMatrixException(\"matrix is not square\");\n+            throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());\n         }\n         if (isSingular()) {   // note: this has side effect of attempting LU decomp if lu == null\n             return ZERO;\n         if (v.length != this.getColumnDimension()) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n-        int nRows = this.getRowDimension();\n-        int nCols = this.getColumnDimension();\n-        BigDecimal[] out = new BigDecimal[v.length];\n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n+        final BigDecimal[] out = new BigDecimal[nRows];\n         for (int row = 0; row < nRows; row++) {\n             BigDecimal sum = ZERO;\n             for (int i = 0; i < nCols; i++) {\n      * @throws IllegalArgumentException if columnDimension != v.size()\n      */\n     public BigDecimal[] operate(double[] v) throws IllegalArgumentException {\n-        BigDecimal bd[] = new BigDecimal[v.length];\n-        for (int i=0;i<bd.length;i++) {\n+        final BigDecimal bd[] = new BigDecimal[v.length];\n+        for (int i = 0; i < bd.length; i++) {\n             bd[i] = new BigDecimal(v[i]);\n         }\n         return operate(bd);\n      * @throws IllegalArgumentException if rowDimension != v.size()\n      */\n     public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n-        int nRows = this.getRowDimension();\n+        final int nRows = this.getRowDimension();\n         if (v.length != nRows) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n-        int nCols = this.getColumnDimension();\n-        BigDecimal[] out = new BigDecimal[nCols];\n+        final int nCols = this.getColumnDimension();\n+        final BigDecimal[] out = new BigDecimal[nCols];\n         for (int col = 0; col < nCols; col++) {\n             BigDecimal sum = ZERO;\n             for (int i = 0; i < nRows; i++) {\n      * @throws InvalidMatrixException if this matrix is not square or is singular\n      */\n     public BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException {\n-        int nRows = this.getRowDimension();\n+        final int nRows = this.getRowDimension();\n         if (b.length != nRows) {\n             throw new IllegalArgumentException(\"constant vector has wrong length\");\n         }\n-        BigMatrix bMatrix = new BigMatrixImpl(b);\n-        BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();\n-        BigDecimal[] out = new BigDecimal[nRows];\n+        final BigMatrix bMatrix = new BigMatrixImpl(b);\n+        final BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();\n+        final BigDecimal[] out = new BigDecimal[nRows];\n         for (int row = 0; row < nRows; row++) {\n             out[row] = solution[row][0];\n         }\n      * @throws InvalidMatrixException if this matrix is not square or is singular\n      */\n     public BigDecimal[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n-        BigDecimal bd[] = new BigDecimal[b.length];\n-        for (int i=0;i<bd.length;i++) {\n+        final BigDecimal bd[] = new BigDecimal[b.length];\n+        for (int i = 0; i < bd.length; i++) {\n             bd[i] = new BigDecimal(b[i]);\n         }\n         return solve(bd);\n             throw new IllegalArgumentException(\"Incorrect row dimension\");\n         }\n         if (!this.isSquare()) {\n-            throw new InvalidMatrixException(\"coefficient matrix is not square\");\n+            throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());\n         }\n         if (this.isSingular()) { // side effect: compute LU decomp\n-            throw new InvalidMatrixException(\"Matrix is singular.\");\n+            throw new SingularMatrixException();\n         }\n         \n-        int nCol = this.getColumnDimension();\n-        int nColB = b.getColumnDimension();\n-        int nRowB = b.getRowDimension();\n+        final int nCol = this.getColumnDimension();\n+        final int nColB = b.getColumnDimension();\n+        final int nRowB = b.getRowDimension();\n         \n         // Apply permutations to b\n-        BigDecimal[][] bp = new BigDecimal[nRowB][nColB];\n+        final BigDecimal[][] bp = new BigDecimal[nRowB][nColB];\n         for (int row = 0; row < nRowB; row++) {\n+            final BigDecimal[] bpRow = bp[row];\n             for (int col = 0; col < nColB; col++) {\n-                bp[row][col] = b.getEntry(permutation[row], col);\n+                bpRow[col] = b.getEntry(permutation[row], col);\n             }\n         }\n         \n         // Solve LY = b\n         for (int col = 0; col < nCol; col++) {\n             for (int i = col + 1; i < nCol; i++) {\n+                final BigDecimal[] bpI = bp[i];\n+                final BigDecimal[] luI = lu[i];\n                 for (int j = 0; j < nColB; j++) {\n-                    bp[i][j] = bp[i][j].subtract(bp[col][j].multiply(lu[i][col]));\n+                    bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));\n                 }\n             }\n         }\n         \n         // Solve UX = Y\n         for (int col = nCol - 1; col >= 0; col--) {\n+            final BigDecimal[] bpCol = bp[col];\n+            final BigDecimal luDiag = lu[col][col];\n             for (int j = 0; j < nColB; j++) {\n-                bp[col][j] = bp[col][j].divide(lu[col][col], scale, roundingMode);\n+                bpCol[j] = bpCol[j].divide(luDiag, scale, roundingMode);\n             }\n             for (int i = 0; i < col; i++) {\n+                final BigDecimal[] bpI = bp[i];\n+                final BigDecimal[] luI = lu[i];\n                 for (int j = 0; j < nColB; j++) {\n-                    bp[i][j] = bp[i][j].subtract(bp[col][j].multiply(lu[i][col]));\n+                    bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));\n                 }\n             }\n         }\n-        \n-        BigMatrixImpl outMat = new BigMatrixImpl(bp);\n-        return outMat;\n+\n+        return new BigMatrixImpl(bp, false);\n+\n     }\n     \n     /**\n      */\n     public void luDecompose() throws InvalidMatrixException {\n         \n-        int nRows = this.getRowDimension();\n-        int nCols = this.getColumnDimension();\n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n         if (nRows != nCols) {\n-            throw new InvalidMatrixException(\"LU decomposition requires that the matrix be square.\");\n+            throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());\n         }\n         lu = this.getData();\n         \n             \n             // upper\n             for (int row = 0; row < col; row++) {\n-                sum = lu[row][col];\n+                final BigDecimal[] luRow = lu[row];\n+                sum = luRow[col];\n                 for (int i = 0; i < row; i++) {\n-                    sum = sum.subtract(lu[row][i].multiply(lu[i][col]));\n+                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n                 }\n-                lu[row][col] = sum;\n+                luRow[col] = sum;\n             }\n             \n             // lower\n             int max = col; // permutation row\n             BigDecimal largest = ZERO;\n             for (int row = col; row < nRows; row++) {\n-                sum = lu[row][col];\n+                final BigDecimal[] luRow = lu[row];\n+                sum = luRow[col];\n                 for (int i = 0; i < col; i++) {\n-                    sum = sum.subtract(lu[row][i].multiply(lu[i][col]));\n+                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n                 }\n-                lu[row][col] = sum;\n+                luRow[col] = sum;\n                 \n                 // maintain best permutation choice\n                 if (sum.abs().compareTo(largest) == 1) {\n             // Singularity check\n             if (lu[max][col].abs().compareTo(TOO_SMALL) <= 0) {\n                 lu = null;\n-                throw new InvalidMatrixException(\"matrix is singular\");\n+                throw new SingularMatrixException();\n             }\n             \n             // Pivot if necessary\n                 parity = -parity;\n             }\n             \n-            //Divide the lower elements by the \"winning\" diagonal elt.\n+            // Divide the lower elements by the \"winning\" diagonal elt.\n+            final BigDecimal luDiag = lu[col][col];\n             for (int row = col + 1; row < nRows; row++) {\n-                lu[row][col] = lu[row][col].divide(lu[col][col], scale, roundingMode);\n+                final BigDecimal[] luRow = lu[row];\n+                luRow[col] = luRow[col].divide(luDiag, scale, roundingMode);\n             }\n             \n         }\n         res.append(\"BigMatrixImpl{\");\n         if (data != null) {\n             for (int i = 0; i < data.length; i++) {\n-                if (i > 0)\n+                if (i > 0) {\n                     res.append(\",\");\n+                }\n                 res.append(\"{\");\n                 for (int j = 0; j < data[0].length; j++) {\n-                    if (j > 0)\n+                    if (j > 0) {\n                         res.append(\",\");\n+                    }\n                     res.append(data[i][j]);\n                 } \n                 res.append(\"}\");\n         if (object instanceof BigMatrixImpl == false) {\n             return false;\n         }\n-        BigMatrix m = (BigMatrix) object;\n-        int nRows = getRowDimension();\n-        int nCols = getColumnDimension();\n+        final BigMatrix m = (BigMatrix) object;\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n         if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {\n             return false;\n         }\n         for (int row = 0; row < nRows; row++) {\n+            final BigDecimal[] dataRow = data[row];\n             for (int col = 0; col < nCols; col++) {\n-                if (!data[row][col].equals(m.getEntry(row, col))) {\n+                if (!dataRow[col].equals(m.getEntry(row, col))) {\n                     return false;\n                 }\n             }\n      */\n     public int hashCode() {\n         int ret = 7;\n-        int nRows = getRowDimension();\n-        int nCols = getColumnDimension();\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n         ret = ret * 31 + nRows;\n         ret = ret * 31 + nCols;\n         for (int row = 0; row < nRows; row++) {\n+            final BigDecimal[] dataRow = data[row];\n             for (int col = 0; col < nCols; col++) {\n                 ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * \n-                data[row][col].hashCode();\n+                dataRow[col].hashCode();\n             }\n         }   \n         return ret;\n     }\n     \n     //------------------------ Protected methods\n-    \n-    /**\n-     * Returns <code>dimension x dimension</code> identity matrix.\n-     *\n-     * @param dimension dimension of identity matrix to generate\n-     * @return identity matrix\n-     * @throws IllegalArgumentException if dimension is not positive\n-     * @deprecated  use {@link MatrixUtils#createBigIdentityMatrix}\n-     */\n-    protected BigMatrix getIdentity(int dimension) {\n-        return MatrixUtils.createBigIdentityMatrix(dimension);\n-    }\n     \n     /**\n      *  Returns the LU decomposition as a BigMatrix.\n      * @return the permutation\n      */\n     protected int[] getPermutation() {\n-        int[] out = new int[permutation.length];\n+        final int[] out = new int[permutation.length];\n         System.arraycopy(permutation, 0, out, 0, permutation.length);\n         return out;\n     }\n      * @return a copy of the underlying data array.\n      */\n     private BigDecimal[][] copyOut() {\n-        int nRows = this.getRowDimension();\n-        BigDecimal[][] out = new BigDecimal[nRows][this.getColumnDimension()];\n+        final int nRows = this.getRowDimension();\n+        final BigDecimal[][] out = new BigDecimal[nRows][this.getColumnDimension()];\n         // can't copy 2-d array in one shot, otherwise get row references\n         for (int i = 0; i < nRows; i++) {\n             System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n      * @param in data to copy in\n      */\n     private void copyIn(double[][] in) {\n-        int nRows = in.length;\n-        int nCols = in[0].length;\n+        final int nRows = in.length;\n+        final int nCols = in[0].length;\n         data = new BigDecimal[nRows][nCols];\n         for (int i = 0; i < nRows; i++) {\n-            for (int j=0; j < nCols; j++) {\n-                data[i][j] = new BigDecimal(in[i][j]);\n+            final BigDecimal[] dataI = data[i];\n+            final double[] inI = in[i];\n+            for (int j = 0; j < nCols; j++) {\n+                dataI[j] = new BigDecimal(inI[j]);\n             }\n         }\n         lu = null;\n      * @param in data to copy in\n      */\n     private void copyIn(String[][] in) {\n-        int nRows = in.length;\n-        int nCols = in[0].length;\n+        final int nRows = in.length;\n+        final int nCols = in[0].length;\n         data = new BigDecimal[nRows][nCols];\n         for (int i = 0; i < nRows; i++) {\n-            for (int j=0; j < nCols; j++) {\n-                data[i][j] = new BigDecimal(in[i][j]);\n+            final BigDecimal[] dataI = data[i];\n+            final String[] inI = in[i];\n+            for (int j = 0; j < nCols; j++) {\n+                dataI[j] = new BigDecimal(inI[j]);\n             }\n         }\n         lu = null;\n     }\n-    \n-    /**\n-     * Tests a given coordinate as being valid or invalid\n-     *\n-     * @param row the row index.\n-     * @param col the column index.\n-     * @return true if the coordinate is with the current dimensions\n-     */\n-    private boolean isValidCoordinate(int row, int col) {\n-        int nRows = this.getRowDimension();\n-        int nCols = this.getColumnDimension();\n-        \n-        return !(row < 0 || row >= nRows || col < 0 || col >= nCols);\n-    }\n-    \n+\n+    /**\n+     * Check if a row index is valid.\n+     * @param row row index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    private void checkRowIndex(final int row) {\n+        if (row < 0 || row >= getRowDimension()) {\n+            throw new MatrixIndexException(\"row index {0} out of allowed range [{1}, {2}]\",\n+                                           new Object[] { row, 0, getRowDimension() - 1});\n+        }\n+    }\n+\n+    /**\n+     * Check if a column index is valid.\n+     * @param column column index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    private void checkColumnIndex(final int column)\n+        throws MatrixIndexException {\n+        if (column < 0 || column >= getColumnDimension()) {\n+            throw new MatrixIndexException(\"column index {0} out of allowed range [{1}, {2}]\",\n+                                           new Object[] { column, 0, getColumnDimension() - 1});\n+        }\n+    }\n+\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/DecompositionSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * A base interface to decomposition algorithms that can solve A &times; X = B.\n+ * <p>This interface is the common base of decomposition algorithms like\n+ * {@link QRDecomposition}, {@link LUDecomposition}, {@link\n+ * SingularValueDecomposition} or {@link EigenDecomposition}. All these\n+ * algorithms decompose an A matrix has a product of several specific matrices\n+ * from which they can solve A &times; X = B in least squares sense: they find X\n+ * such that ||A &times; X - B|| is minimal.</p>\n+ * <p>Some solvers like {@link LUDecomposition} can only find the solution for\n+ * square matrices and when the solution is an exact linear solution, i.e. when\n+ * ||A &times; X - B|| is exactly 0. Other solvers can also find solutions\n+ * with non-square matrix A and with non-null minimal norm. If an exact linear\n+ * solution exists it is also the minimal norm solution.</p>\n+ *   \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface DecompositionSolver extends Serializable {\n+\n+    /**\n+     * Decompose a matrix.\n+     * @param matrix matrix to decompose\n+     * @exception InvalidMatrixException if matrix does not fulfill\n+     * the decomposition requirements (for example non-square matrix\n+     * for {@link LUDecomposition})\n+     */\n+    void decompose(RealMatrix matrix)\n+        throws InvalidMatrixException;\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    double[] solve(double[] b)\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException;\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    RealVector solve(RealVector b)\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException;\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a matrix X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    RealMatrix solve(RealMatrix b)\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException;\n+\n+    /**\n+     * Check if the decomposed matrix is non-singular.\n+     * @return true if the decomposed matrix is non-singular\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     */\n+    boolean isNonSingular() throws IllegalStateException;\n+\n+    /** Get the inverse of the decomposed matrix.\n+     * @return inverse matrix\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    RealMatrix getInverse()\n+        throws IllegalStateException, InvalidMatrixException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/EigenDecomposition.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * An interface to classes that implement an algorithm to calculate the \n+ * eigen decomposition of a real symmetric matrix.\n+ * <p>The eigen decomposition of matrix A is a set of two matrices:\n+ * V and D such that A = V &times; D &times; V<sup>T</sup>.\n+ * A, V and D are all m &times; m matrices.</p>\n+ * <p>This interface is similar in spirit to the <code>EigenvalueDecomposition</code>\n+ * class from the now defunct <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a>\n+ * library, with the following changes:</p>\n+ * <ul>\n+ *   <li><code>solve</code> methods have been added (in the superinterface),</li>\n+ *   <li>a {@link DecompositionSolver#decompose(RealMatrix) decompose(RealMatrix)}\n+ *   method has been added (in the superinterface),</li>\n+ *   <li>a {@link DecompositionSolver#isNonSingular() isNonSingular} method has\n+ *   been added (in the superinterface),</li>\n+ *   <li>a {@link DecompositionSolver#getInverse() getInverse} method has been\n+ *   added (in the superinterface),</li>\n+ *   <li>a {@link #getVT() getVt} method has been added,</li>\n+ *   <li>a {@link #getEigenvalue(int) getEigenvalue} method to pick up a single\n+ *   eigenvalue has been added,</li>\n+ *   <li>a {@link #getEigenvector(int) getEigenvector} method to pick up a single\n+ *   eigenvector has been added,</li>\n+ *   <li>the <code>getRealEigenvalues</code> method has been renamed as {@link\n+ *   #getEigenValues() getEigenValues},</li>\n+ *   <li>the <code>getImagEigenvalues</code> method has been removed</li>\n+ * </ul>\n+ * @see <a href=\"http://mathworld.wolfram.com/EigenDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix\">Wikipedia</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface EigenDecomposition extends DecompositionSolver {\n+\n+    /**\n+     * Returns the matrix V of the decomposition. \n+     * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * <p>The columns of V are the eigenvectors of the original matrix.</p>\n+     * @return the V matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     */\n+    RealMatrix getV() throws IllegalStateException;\n+\n+    /**\n+     * Returns the diagonal matrix D of the decomposition. \n+     * <p>D is a diagonal matrix.</p>\n+     * <p>The values on the diagonal are the eigenvalues of the original matrix.</p>\n+     * @return the D matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     * @see #getEigenValues()\n+     */\n+    RealMatrix getD() throws IllegalStateException;\n+\n+    /**\n+     * Returns the transpose of the matrix V of the decomposition. \n+     * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * <p>The columns of V are the eigenvectors of the original matrix.</p>\n+     * @return the transpose of the V matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     */\n+    RealMatrix getVT() throws IllegalStateException;\n+\n+    /**\n+     * Returns a copy of the eigenvalues of the original matrix.\n+     * @return a copy of the eigenvalues of the original matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     * @see #getD()\n+     */\n+    double[] getEigenvalues() throws IllegalStateException;\n+\n+    /**\n+     * Returns the i<sup>th</sup> eigenvalue of the original matrix.\n+     * @param i index of the eigenvalue (counting from 0)\n+     * @return i<sup>th</sup> eigenvalue of the original matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     * @exception ArrayIndexOutOfBoundsException if i is not\n+     * @see #getD()\n+     */\n+    double getEigenvalue(int i) throws IllegalStateException;\n+\n+    /**\n+     * Returns a copy of the i<sup>th</sup> eigenvector of the original matrix.\n+     * @param i index of the eigenvector (counting from 0)\n+     * @return copy of the i<sup>th</sup> eigenvector of the original matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     * @see #getD()\n+     */\n+    RealVector getEigenvector(int i) throws IllegalStateException;\n+\n+    /**\n+     * Return the determinant of the matrix\n+     * @return determinant of the matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     * @see #isNonSingular()\n+     */\n+    double getDeterminant() throws IllegalStateException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Calculates the eigen decomposition of a <strong>symmetric</strong> matrix.\n+ * <p>The eigen decomposition of symmetric matrix A is a set of two matrices:\n+ * V and D such that A = V D V<sup>T</sup>. A, V and D are all m &times; m\n+ * matrices.</p>\n+ * <p>This implementation only uses the upper part of the matrix, the part below the\n+ * diagonal is not accessed at all.</p>\n+ * <p>Eigenvalues are computed as soon as the matrix is decomposed, but eigenvectors\n+ * are computed only when required, i.e. only when one of the {@link #getEigenvector(int)},\n+ * {@link #getV()}, {@link #getVT()}, {@link #getInverse()}, {@link #solve(double[])},\n+ * {@link #solve(RealMatrix)}, {@link #solve(RealVector)} or {@link #solve(RealVectorImpl)}\n+ * methods is called.</p>\n+ * <p>This implementation is based on Inderjit Singh Dhillon thesis\n+ * <a href=\"http://www.cs.utexas.edu/users/inderjit/public_papers/thesis.pdf\">A\n+ * New O(n<sup>2</sup>) Algorithm for the Symmetric Tridiagonal Eigenvalue/Eigenvector\n+ * Problem</a>, on Beresford N. Parlett and Osni A. Marques paper <a\n+ * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An Implementation of the\n+ * dqds Algorithm (Positive Case)</a> and on the corresponding LAPACK routines (DLARRE,\n+ * DLASQ2, DLAZQ3, DLAZQ4, DLASQ5 and DLASQ6).</p>\n+ * @author Beresford Parlett, University of California, Berkeley, USA (fortran version)\n+ * @author Jim Demmel, University of California, Berkeley, USA (fortran version)\n+ * @author Inderjit Dhillon, University of Texas, Austin, USA(fortran version)\n+ * @author Osni Marques, LBNL/NERSC, USA (fortran version)\n+ * @author Christof Voemel, University of California, Berkeley, USA(fortran version)\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class EigenDecompositionImpl implements EigenDecomposition {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -4976315828448620858L;\n+\n+    /** Tolerance. */\n+    private static final double TOLERANCE = 100 * MathUtils.EPSILON;\n+\n+    /** Squared tolerance. */\n+    private static final double TOLERANCE_2 = TOLERANCE * TOLERANCE;\n+\n+    /** Split tolerance. */\n+    private double splitTolerance;\n+\n+    /** Main diagonal of the tridiagonal matrix. */\n+    private double[] main;\n+\n+    /** Secondary diagonal of the tridiagonal matrix. */\n+    private double[] secondary;\n+\n+    /** Squared secondary diagonal of the tridiagonal matrix. */\n+    private double[] squaredSecondary;\n+\n+    /** Orthogonal matrix of tridiagonal transformation. */\n+    private RealMatrix orthoTridiag;\n+\n+    /** Lower bound of spectra. */\n+    private double lowerSpectra;\n+\n+    /** Upper bound of spectra. */\n+    private double upperSpectra;\n+\n+    /** Minimum pivot in the Sturm sequence. */\n+    private double minPivot;\n+\n+    /** Current shift. */\n+    private double sigma;\n+\n+    /** Low part of the current shift. */\n+    private double sigmaLow;\n+\n+    /** Shift increment to apply. */\n+    private double tau;\n+\n+    /** Work array for all decomposition algorithms. */\n+    private double[] work;\n+\n+    /** Shift within qd array for ping-pong implementation. */\n+    private int pingPong;\n+\n+    /** Max value of diagonal elements in current segment. */\n+    private double qMax;\n+\n+    /** Min value of off-diagonal elements in current segment. */\n+    private double eMin;\n+\n+    /** Type of the last dqds shift. */\n+    private int    tType;\n+\n+    /** Minimal value on current state of the diagonal. */\n+    private double dMin;\n+\n+    /** Minimal value on current state of the diagonal, excluding last element. */\n+    private double dMin1;\n+\n+    /** Minimal value on current state of the diagonal, excluding last two elements. */\n+    private double dMin2;\n+\n+    /** Last value on current state of the diagonal. */\n+    private double dN;\n+\n+    /** Last but one value on current state of the diagonal. */\n+    private double dN1;\n+\n+    /** Last but two on current state of the diagonal. */\n+    private double dN2;\n+\n+    /** Shift ratio with respect to dMin used when tType == 6. */\n+    private double g;\n+\n+    /** Eigenvalues. */\n+    private double[] eigenvalues;\n+\n+    /** Eigenvectors. */\n+    private RealVectorImpl[] eigenvectors;\n+\n+    /** Cached value of V. */\n+    private RealMatrix cachedV;\n+\n+    /** Cached value of D. */\n+    private RealMatrix cachedD;\n+\n+    /** Cached value of Vt. */\n+    private RealMatrix cachedVt;\n+\n+    /**\n+     * Build a new instance.\n+     * <p>Note that {@link #decompose(RealMatrix)} <strong>must</strong> be called\n+     * before any of the {@link #getV()}, {@link #getD()}, {@link #getVT()},\n+     * {@link #getEignevalues()}, {@link #solve(double[])}, {@link #solve(RealMatrix)},\n+     * {@link #solve(RealVector)} or {@link #solve(RealVectorImpl)} methods can be\n+     * called.</p>\n+     * @see #decompose(RealMatrix)\n+     */\n+    public EigenDecompositionImpl() {\n+        setRelativeAccuracySplitTolerance(MathUtils.SAFE_MIN);\n+    }\n+\n+    /**\n+     * Calculates the eigen decomposition of the given symmetric matrix. \n+     * <p>Calling this constructor is equivalent to first call the no-arguments\n+     * constructor and then call {@link #decompose(RealMatrix)}.</p>\n+     * <p>The specified matrix is assumed to be symmetrical without any check.\n+     * Only the upper triangular part of the matrix is used.</p>\n+     * @param matrix The <strong>symmetric</strong> matrix to decompose.\n+     * @exception InvalidMatrixException (wrapping a {@link ConvergenceException}\n+     * if algorithm fails to converge\n+     */\n+    public EigenDecompositionImpl(final RealMatrix matrix)\n+        throws InvalidMatrixException {\n+        setRelativeAccuracySplitTolerance(MathUtils.SAFE_MIN);\n+        decompose(matrix);\n+    }\n+\n+    /**\n+     * Set split tolerance based on absolute off-diagonal elements.\n+     * @param tolerance tolerance to set\n+     */\n+    public void setAbsoluteSplitTolerance(final double tolerance) {\n+        splitTolerance = -Math.abs(tolerance);\n+    }\n+\n+    /**\n+     * Set split tolerance preserving relative accuracy.\n+     * @param tolerance tolerance to set\n+     */\n+    public void setRelativeAccuracySplitTolerance(final double tolerance) {\n+        splitTolerance = Math.abs(tolerance);\n+    }\n+\n+    /**\n+     * Decompose a <strong>symmetric</strong> matrix.\n+     * <p>The specified matrix is assumed to be symmetrical without any check.\n+     * Only the upper triangular part of the matrix is used.</p>\n+     * @param matrix symmetric matrix to decompose\n+     * @exception InvalidMatrixException if matrix cannot be diagonalized\n+     */\n+    public void decompose(final RealMatrix matrix)\n+        throws InvalidMatrixException {\n+\n+        cachedV  = null;\n+        cachedD  = null;\n+        cachedVt = null;\n+        work     = new double[6 * matrix.getRowDimension()];\n+\n+        // compute tridiagonal representation of the initial matrix\n+        transformToTridiagonal(matrix);\n+        computeGershgorinCircles();\n+\n+        // find all the eigenvalues\n+        findEigenvalues();\n+\n+        // we will search for eigenvectors only if required\n+        eigenvectors = null;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getV()\n+        throws InvalidMatrixException {\n+\n+        if (cachedV == null) {\n+            cachedV = getVT().transpose();\n+        }\n+\n+        // return the cached matrix\n+        return cachedV;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getD()\n+        throws InvalidMatrixException {\n+\n+        if (cachedD == null) {\n+\n+            checkDecomposed();\n+\n+            final int m = eigenvalues.length;\n+            final double[][] sData = new double[m][m];\n+            for (int i = 0; i < m; ++i) {\n+                sData[i][i] = eigenvalues[i];\n+            }\n+\n+            // cache the matrix for subsequent calls\n+            cachedD = new RealMatrixImpl(sData, false);\n+\n+        }\n+        return cachedD;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getVT()\n+        throws InvalidMatrixException {\n+\n+        if (cachedVt == null) {\n+\n+            checkDecomposed();\n+            if (eigenvectors == null) {\n+                findEigenVectors();\n+            }\n+\n+            final double[][] vtData = new double[eigenvectors.length][];\n+            for (int k = 0; k < eigenvectors.length; ++k) {\n+                vtData[k] = eigenvectors[k].getData();\n+            }\n+\n+            // cache the matrix for subsequent calls\n+            cachedVt = new RealMatrixImpl(vtData, false);\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedVt;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getEigenvalues()\n+        throws InvalidMatrixException {\n+        checkDecomposed();\n+        return eigenvalues.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getEigenvalue(final int i)\n+        throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n+        checkDecomposed();\n+        return eigenvalues[i];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector getEigenvector(final int i)\n+        throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n+        checkDecomposed();\n+        if (eigenvectors == null) {\n+            findEigenVectors();\n+        }\n+        return eigenvectors[i].copy();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isNonSingular()\n+        throws IllegalStateException {\n+        for (double lambda : eigenvalues) {\n+            if (lambda == 0) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] solve(final double[] b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        checkNonSingular();\n+\n+        final int m = eigenvalues.length;\n+        if (b.length != m) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+\n+        if (eigenvectors == null) {\n+            findEigenVectors();\n+        }\n+\n+        final double[] bp = new double[m];\n+        for (int i = 0; i < m; ++i) {\n+            final RealVectorImpl v = eigenvectors[i];\n+            final double s = v.dotProduct(b) / eigenvalues[i];\n+            final double[] vData = v.getDataRef();\n+            for (int j = 0; j < m; ++j) {\n+                bp[j] += s * vData[j];\n+            }\n+        }\n+\n+        return bp;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector solve(final RealVector b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+        try {\n+            return solve((RealVectorImpl) b);\n+        } catch (ClassCastException cce) {\n+\n+            checkNonSingular();\n+\n+            final int m = eigenvalues.length;\n+            if (b.getDimension() != m) {\n+                throw new IllegalArgumentException(\"constant vector has wrong length\");\n+            }\n+\n+            if (eigenvectors == null) {\n+                findEigenVectors();\n+            }\n+\n+            final double[] bp = new double[m];\n+            for (int i = 0; i < m; ++i) {\n+                final RealVectorImpl v = eigenvectors[i];\n+                final double s = v.dotProduct(b) / eigenvalues[i];\n+                final double[] vData = v.getDataRef();\n+                for (int j = 0; j < m; ++j) {\n+                    bp[j] += s * vData[j];\n+                }\n+            }\n+\n+            return new RealVectorImpl(bp, false);\n+\n+        }\n+    }\n+\n+    /**\n+     * Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X such that A &times; X = B\n+     * @throws IllegalArgumentException if matrices dimensions don't match\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealVectorImpl solve(final RealVectorImpl b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+        return new RealVectorImpl(solve(b.getDataRef()), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix solve(final RealMatrix b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        checkNonSingular();\n+\n+        final int m = eigenvalues.length;\n+        if (b.getRowDimension() != m) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+\n+        if (eigenvectors == null) {\n+            findEigenVectors();\n+        }\n+\n+        final int nColB = b.getColumnDimension();\n+        final double[][] bp = new double[m][nColB];\n+        for (int k = 0; k < nColB; ++k) {\n+            for (int i = 0; i < m; ++i) {\n+                final double[] vData = eigenvectors[i].getDataRef();\n+                double s = 0;\n+                for (int j = 0; j < m; ++j) {\n+                    s += vData[j] * b.getEntry(j, k);\n+                }\n+                s /= eigenvalues[i];\n+                for (int j = 0; j < m; ++j) {\n+                    bp[j][k] += s * vData[j];\n+                }\n+            }\n+        }\n+\n+        return new RealMatrixImpl(bp, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getInverse()\n+        throws IllegalStateException, InvalidMatrixException {\n+\n+        checkNonSingular();\n+        final int m = eigenvalues.length;\n+        final double[][] invData = new double[m][m];\n+\n+        if (eigenvectors == null) {\n+            findEigenVectors();\n+        }\n+\n+        for (int i = 0; i < m; ++i) {\n+            final double[] invI = invData[i];\n+            for (int j = 0; j < m; ++j) {\n+                double invIJ = 0;\n+                for (int k = 0; k < m; ++k) {\n+                    final double[] vK = eigenvectors[k].getDataRef();\n+                    invIJ += vK[i] * vK[j] / eigenvalues[k];\n+                }\n+                invI[j] = invIJ;\n+            }\n+        }\n+        return new RealMatrixImpl(invData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDeterminant()\n+        throws IllegalStateException {\n+        double determinant = 1;\n+        for (double lambda : eigenvalues) {\n+            determinant *= lambda;\n+        }\n+        return determinant;\n+    }\n+\n+    /**\n+     * Transform matrix to tridiagonal.\n+     * @param matrix matrix to transform\n+     */\n+    private void transformToTridiagonal(final RealMatrix matrix) {\n+\n+        // transform the matrix to tridiagonal\n+        TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix);\n+        main      = transformer.getMainDiagonalRef();\n+        secondary = transformer.getSecondaryDiagonalRef();\n+\n+        // pre-compute some elements\n+        squaredSecondary = new double[secondary.length];\n+        for (int i = 0; i < squaredSecondary.length; ++i) {\n+            final double s = secondary[i];\n+            squaredSecondary[i] = s * s;\n+        }\n+\n+        orthoTridiag = transformer.getQ();\n+\n+    }\n+\n+    /**\n+     * Compute the Gershgorin circles for all rows.\n+     */\n+    private void computeGershgorinCircles() {\n+\n+        final int m     = main.length;\n+        final int lowerStart = 4 * m;\n+        final int upperStart = 5 * m;\n+        lowerSpectra = Double.POSITIVE_INFINITY;\n+        upperSpectra = Double.NEGATIVE_INFINITY;\n+        double eMax = 0;\n+\n+        double eCurrent = 0;\n+        for (int i = 0; i < m - 1; ++i) {\n+\n+            final double dCurrent = main[i];\n+            final double ePrevious = eCurrent;\n+            eCurrent = Math.abs(secondary[i]);\n+            eMax = Math.max(eMax, eCurrent);\n+            final double radius = ePrevious + eCurrent;\n+\n+            final double lower = dCurrent - radius;\n+            work[lowerStart + i] = lower;\n+            lowerSpectra = Math.min(lowerSpectra, lower);\n+\n+            final double upper = dCurrent + radius;\n+            work[upperStart + i] = upper;\n+            upperSpectra = Math.max(upperSpectra, upper);\n+            \n+        }\n+\n+        final double dCurrent = main[m - 1];\n+        work[lowerStart + m - 1] = dCurrent - eCurrent;\n+        work[upperStart + m - 1] = dCurrent + eCurrent;\n+        minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n+\n+    }\n+\n+    /**\n+     * Find the eigenvalues.\n+     * @exception InvalidMatrixException if a block cannot be diagonalized\n+     */\n+    private void findEigenvalues()\n+        throws InvalidMatrixException {\n+\n+        // compute splitting points\n+        List<Integer> splitIndices = computeSplits();\n+\n+        // find eigenvalues in each block\n+        eigenvalues = new double[main.length];\n+        int begin = 0;\n+        for (final int end : splitIndices) {\n+            final int n = end - begin;\n+            switch (n) {\n+\n+            case 1:\n+                // apply dedicated method for dimension 1\n+                process1RowBlock(begin);\n+                break;\n+\n+            case 2:\n+                // apply dedicated method for dimension 2\n+                process2RowsBlock(begin);\n+                break;\n+\n+            case 3:\n+                // apply dedicated method for dimension 3\n+                process3RowsBlock(begin);\n+                break;\n+\n+            default:\n+\n+                // choose an initial shift for LDL<sup>T</sup> decomposition\n+                final double[] range       = eigenvaluesRange(begin, n);\n+                final double oneFourth     = 0.25 * (3 * range[0] + range[1]);\n+                final int oneFourthCount   = countEigenValues(oneFourth, begin, n);\n+                final double threeFourth   = 0.25 * (range[0] + 3 * range[1]);\n+                final int threeFourthCount = countEigenValues(threeFourth, begin, n);\n+                final boolean chooseLeft   = (oneFourthCount - 1) >= (n - threeFourthCount);\n+                final double lambda        = chooseLeft ? range[0] : range[1];\n+\n+                tau = (range[1] - range[0]) * MathUtils.EPSILON * n + 2 * minPivot;\n+\n+                // decompose T&lambda;I as LDL<sup>T</sup>\n+                ldlTDecomposition(lambda, begin, n);\n+\n+                // apply general dqd/dqds method\n+                processGeneralBlock(n);\n+\n+                // extract eigenvalues\n+                if (chooseLeft) {\n+                    for (int i = 0; i < n; ++i) {\n+                        eigenvalues[begin + i] = lambda + work[4 * i];\n+                    }\n+                } else {\n+                    for (int i = 0; i < n; ++i) {\n+                        eigenvalues[begin + i] = lambda - work[4 * i];\n+                    }                    \n+                }\n+\n+            }\n+            begin = end;\n+        }\n+\n+        // sort the eigenvalues in decreasing order\n+        Arrays.sort(eigenvalues);\n+        for (int i = 0, j = eigenvalues.length - 1; i < j; ++i, --j) {\n+            final double tmp = eigenvalues[i];\n+            eigenvalues[i] = eigenvalues[j];\n+            eigenvalues[j] = tmp;\n+        }\n+\n+    }\n+\n+    /**\n+     * Compute splitting points.\n+     * @return list of indices after matrix can be split\n+     */\n+    private List<Integer> computeSplits() {\n+\n+        final List<Integer> list = new ArrayList<Integer>();\n+\n+        if (splitTolerance < 0) {\n+            // splitting based on absolute off-diagonal value\n+            final double max = Math.abs(splitTolerance) * (upperSpectra - lowerSpectra);\n+            for (int i = 0; i < secondary.length; ++i) {\n+                if (Math.abs(secondary[i]) <= max) {\n+                    list.add(i + 1);\n+                    secondary[i] = 0;\n+                    squaredSecondary[i] = 0;\n+                }\n+            }\n+        } else {\n+            // splitting preserving relative accuracy\n+            double absDCurrent = Math.abs(0);\n+            for (int i = 0; i < secondary.length; ++i) {\n+                final double absDPrevious = absDCurrent;\n+                absDCurrent = Math.abs(i + 1);\n+                final double max = splitTolerance * Math.sqrt(absDPrevious * absDCurrent);\n+                if (Math.abs(secondary[i]) <= max) {\n+                    list.add(i + 1);\n+                    secondary[i] = 0;\n+                    squaredSecondary[i] = 0;\n+                }\n+            }            \n+        }\n+\n+        list.add(secondary.length + 1);\n+        return list;\n+\n+    }\n+\n+    /**\n+     * Find eigenvalue in a block with 1 row.\n+     * <p>In low dimensions, we simply solve the characteristic polynomial.</p>\n+     * @param index index of the first row of the block\n+     */\n+    private void process1RowBlock(final int index) {\n+        eigenvalues[index] = main[index];\n+    }\n+\n+    /**\n+     * Find eigenvalues in a block with 2 rows.\n+     * <p>In low dimensions, we simply solve the characteristic polynomial.</p>\n+     * @param index index of the first row of the block\n+     * @exception InvalidMatrixException if characteristic polynomial cannot be solved\n+     */\n+    private void process2RowsBlock(final int index)\n+        throws InvalidMatrixException {\n+\n+        // the characteristic polynomial is\n+        // X^2 - (q0 + q1) X + q0 q1 - e1^2\n+        final double q0   = main[index];\n+        final double q1   = main[index + 1];\n+        final double e12  = squaredSecondary[index];\n+\n+        final double s     = q0 + q1;\n+        final double p     = q0 * q1 - e12;\n+        final double delta = s * s - 4 * p;\n+        if (delta < 0) {\n+            throw new InvalidMatrixException(\"cannot solve degree {0} equation\", new Object[] { 2 });\n+        }\n+\n+        final double largestRoot = 0.5 * (s + Math.sqrt(delta));\n+        eigenvalues[index]     = largestRoot;\n+        eigenvalues[index + 1] = p / largestRoot;\n+\n+    }\n+\n+    /**\n+     * Find eigenvalues in a block with 3 rows.\n+     * <p>In low dimensions, we simply solve the characteristic polynomial.</p>\n+     * @param index index of the first row of the block\n+     * @exception InvalidMatrixException if diagonal elements are not positive\n+     */\n+    private void process3RowsBlock(final int index)\n+        throws InvalidMatrixException {\n+\n+        // the characteristic polynomial is\n+        // X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2\n+        final double q0       = main[index];\n+        final double q1       = main[index + 1];\n+        final double q2       = main[index + 2];\n+        final double e12      = squaredSecondary[index];\n+        final double q1q2Me22 = q1 * q2 - squaredSecondary[index + 1];\n+\n+        // compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0\n+        final double b        = -(q0 + q1 + q2);\n+        final double c        = q0 * q1 + q0 * q2 + q1q2Me22 - e12;\n+        final double d        = q2 * e12 - q0 * q1q2Me22;\n+\n+        // solve cubic equation\n+        final double b2       = b * b;\n+        final double q        = (3 * c - b2) / 9;\n+        final double r        = ((9 * c - 2 * b2) * b - 27 * d) / 54;\n+        final double delta    = q * q * q + r * r;\n+        if (delta >= 0) {\n+            // in fact, there are solutions to the equation, but in the context\n+            // of symmetric eigenvalues problem, there should be three distinct\n+            // real roots, so we throw an error if this condition is not met\n+            throw new InvalidMatrixException(\"cannot solve degree {0} equation\", new Object[] { 3 });           \n+        }\n+        final double sqrtMq = Math.sqrt(-q);\n+        final double theta  = Math.acos(r / (-q * sqrtMq));\n+        final double alpha  = 2 * sqrtMq;\n+        final double beta   = b / 3;\n+\n+        double z0 = alpha * Math.cos(theta / 3) - beta;\n+        double z1 = alpha * Math.cos((theta + 2 * Math.PI) / 3) - beta;\n+        double z2 = alpha * Math.cos((theta + 4 * Math.PI) / 3) - beta;\n+        if (z0 < z1) {\n+            final double t = z0;\n+            z0 = z1;\n+            z1 = t;\n+        }\n+        if (z1 < z2) {\n+            final double t = z1;\n+            z1 = z2;\n+            z2 = t;\n+        }\n+        if (z0 < z1) {\n+            final double t = z0;\n+            z0 = z1;\n+            z1 = t;\n+        }\n+        eigenvalues[index]     = z0;\n+        eigenvalues[index + 1] = z1;\n+        eigenvalues[index + 2] = z2;\n+\n+    }\n+\n+    /**\n+     * Find eigenvalues using dqd/dqds algorithms.\n+     * <p>This implementation is based on Beresford N. Parlett\n+     * and Osni A. Marques paper <a\n+     * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An\n+     * Implementation of the dqds Algorithm (Positive Case)</a> and on the\n+     * corresponding LAPACK routine DLASQ2.</p>\n+     * @param n number of rows of the block\n+     * @exception InvalidMatrixException if block cannot be diagonalized\n+     * after 30 * n iterations\n+     */\n+    private void processGeneralBlock(final int n)\n+        throws InvalidMatrixException {\n+\n+        // check decomposed matrix data range\n+        final int fourN1  = 4 * (n - 1);\n+        double sumDiag    = 0;\n+        double sumOffDiag = 0;\n+//        qMax = Double.NEGATIVE_INFINITY;\n+//        eMin = Double.POSITIVE_INFINITY;\n+        for (int i = 0; i < n - 1; ++i) {\n+            final int fourI = 4 * i;\n+            final double qi = work[fourI];\n+            final double ei = work[fourI + 2];\n+//            qMax = Math.max(qMax, qi);\n+//            eMin = Math.min(eMin, ei);\n+            sumDiag    += qi;\n+            sumOffDiag += ei;\n+        }\n+        final double qi = work[fourN1];\n+//        qMax = Math.max(qMax, qi);\n+        sumDiag += qi;\n+\n+        if (sumOffDiag == 0) {\n+            // matrix is already diagonal\n+            return;\n+        }\n+\n+        // initial checks for splits (see Parlett & Marques section 3.3)\n+        flipIfWarranted(n, 2);\n+\n+        // two iterations with Li's test for initial splits\n+        initialSplits(n);\n+\n+        // initialize parameters used by goodStep\n+        tType = 0;\n+        dMin1 = 0;\n+        dMin2 = 0;\n+        dN    = 0;\n+        dN1   = 0;\n+        dN2   = 0;\n+        tau   = 0;\n+\n+        // process split segments\n+        int i0 = 0;\n+        int n0 = n;\n+        while (n0 > 0) {\n+\n+            // retrieve shift that was temporarily stored as a negative off-diagonal element\n+            sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];\n+            sigmaLow = 0;\n+\n+            // find start of a new split segment to process\n+            double eMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\n+            double eMax = 0;\n+            double qMax = work[4 * n0 - 4];\n+            double qMin = qMax;\n+            i0 = 0;\n+            for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n+                if (work[i + 2] <= 0) {\n+                    i0 = 1 + i / 4;\n+                    break;\n+                }\n+                if (qMin >= 4 * eMax) {\n+                    qMin = Math.min(qMin, work[i + 4]);\n+                    eMax = Math.max(eMax, work[i + 2]);\n+                }\n+                qMax = Math.max(qMax, work[i] + work[i + 2]);\n+                eMin = Math.min(eMin, work[i + 2]);\n+            }\n+            work[4 * n0 - 2] = eMin;\n+\n+            // lower bound of Gershgorin disk\n+            dMin = -Math.max(0, qMin - 2 * Math.sqrt(qMin * eMax));\n+\n+            pingPong = 0;\n+            int maxIter = 30 * (n0 - i0);\n+            for (int k = 0; i0 < n0; ++k) {\n+                if (k >= maxIter) {\n+                    throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\n+                }\n+\n+                // perform one step\n+                n0 = goodStep(i0, n0);\n+                pingPong = 1 - pingPong;\n+\n+                // check for new splits after \"ping\" steps\n+                // when the last elements of qd array are very small\n+                if ((pingPong == 0) && (n0 - i0 > 3) &&\n+                    (work[4 * n0 - 1] <= TOLERANCE_2 * qMax) &&\n+                    (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\n+                    int split = i0 - 1;\n+                    qMax = work[4 * i0];\n+                    eMin = work[4 * i0 + 2];\n+                    double previousEMin = work[4 * i0 + 3];\n+                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n+                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n+                            (work[i + 2] <= TOLERANCE_2 * sigma)) {\n+                            // insert a split here\n+                            work[i + 2]  = -sigma;\n+                            split        = i / 4;\n+                            qMax         = 0;\n+                            eMin         = work[i + 6];\n+                            previousEMin = work[i + 7];\n+                        } else {\n+                            qMax         = Math.max(qMax, work[i + 4]);\n+                            eMin         = Math.min(eMin, work[i + 2]);\n+                            previousEMin = Math.min(previousEMin, work[i + 3]);\n+                        }\n+                    }\n+                    work[4 * n0 - 2] = eMin;\n+                    work[4 * n0 - 1] = previousEMin;\n+                    i0 = split + 1;\n+                }\n+            }\n+\n+        }\n+\n+    }\n+\n+    /**\n+     * Perform two iterations with Li's tests for initial splits.\n+     * @param n number of rows of the matrix to process\n+     */\n+    private void initialSplits(final int n) {\n+\n+        pingPong = 0;\n+        for (int k = 0; k < 2; ++k) {\n+\n+            // apply Li's reverse test\n+            double d = work[4 * (n - 1) + pingPong];\n+            for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) {\n+                if (work[i + 2] <= TOLERANCE_2 * d) {\n+                    work[i + 2] = -0.0;\n+                    d = work[i];\n+                } else {\n+                    d *= work[i] / (d + work[i + 2]);\n+                }\n+            }\n+\n+            // apply dqd plus Li's forward test.\n+//            eMin = work[4 + pingPong];\n+            d = work[pingPong];\n+            for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) {\n+                final int j = i - 2 * pingPong - 1;\n+                work[j] = d + work[i];\n+                if (work[i] <= TOLERANCE_2 * d) {\n+                    work[i]     = -0.0;\n+                    work[j]     = d;\n+                    work[j + 2] = 0.0;\n+                    d = work[i + 2];\n+                } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&\n+                           (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {\n+                    final double tmp = work[i + 2] / work[j];\n+                    work[j + 2] = work[i] * tmp;\n+                    d *= tmp;\n+                } else {\n+                    work[j + 2] = work[i + 2] * (work[i] / work[j]);\n+                    d *= work[i + 2] / work[j];\n+               }\n+//               eMin = Math.min(eMin, work[j + 2]);\n+            }\n+            work[4 * n - 3 - pingPong] = d;\n+\n+//            // find qMax\n+//            qMax = Double.NEGATIVE_INFINITY;\n+//            for (int i = 1 - pingPong; i < 4 * n; i += 4) {\n+//                qMax = Math.max(qMax, work[i]);\n+//            }\n+\n+            // from ping to pong\n+            pingPong = 1 - pingPong;\n+\n+        }\n+\n+    }\n+\n+    /**\n+     * Perform one \"good\" dqd/dqds step.\n+     * <p>This implementation is based on Beresford N. Parlett\n+     * and Osni A. Marques paper <a\n+     * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An\n+     * Implementation of the dqds Algorithm (Positive Case)</a> and on the\n+     * corresponding LAPACK routine DLAZQ3.</p>\n+     * @param start start index\n+     * @param end end index\n+     * @return new end (maybe deflated)\n+     */\n+    private int goodStep(final int start, final int end) {\n+\n+        g = 0.0;\n+\n+        // step 1: accepting eigenvalues\n+        int deflatedEnd = end;\n+        for (boolean deflating = true; deflating;) {\n+\n+            if (start >= deflatedEnd) {\n+                // the array has been completely deflated\n+                return deflatedEnd;\n+            }\n+\n+            final int k = 4 * deflatedEnd + pingPong - 1;\n+\n+            if ((start == deflatedEnd - 1) ||\n+                ((start != deflatedEnd - 2) &&\n+                 ((work[k - 5] <= TOLERANCE_2 * (sigma + work[k - 3])) ||\n+                  (work[k - 2 * pingPong - 4] <= TOLERANCE_2 * work[k - 7])))) {\n+\n+                // one eigenvalue found, deflate array\n+                work[4 * deflatedEnd - 4] = sigma + work[4 * deflatedEnd - 4 + pingPong];\n+                deflatedEnd -= 1;\n+\n+            } else if ((start == deflatedEnd - 2) ||\n+                (work[k - 9] <= TOLERANCE_2 * sigma) ||\n+                (work[k - 2 * pingPong - 8] <= TOLERANCE_2 * work[k - 11])) {\n+\n+                // two eigenvalues found, deflate array\n+                if (work[k - 3] > work[k - 7]) {\n+                    final double tmp = work[k - 3];\n+                    work[k - 3] = work[k - 7];\n+                    work[k - 7] = tmp;\n+                }\n+\n+                if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {\n+                    double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);\n+                    double s = work[k - 3] * (work[k - 5] / t);\n+                    if (s <= t) {\n+                        s = work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));\n+                    } else {\n+                        s = work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));                      \n+                    }\n+                    t = work[k - 7] + (s + work[k - 5]);\n+                    work[k - 3] *= work[k - 7] / t;\n+                    work[k - 7]  = t;\n+                }\n+                work[4 * deflatedEnd - 8] = sigma + work[k - 7];\n+                work[4 * deflatedEnd - 4] = sigma + work[k - 3];\n+                deflatedEnd -= 2;\n+            } else {\n+\n+                // no more eigenvalues found, we need to iterate\n+                deflating = false;\n+\n+            }\n+\n+        }\n+\n+        final int l = 4 * deflatedEnd + pingPong - 1;\n+\n+        // step 2: flip array if needed\n+        if ((dMin <= 0) || (deflatedEnd < end)) {\n+            if (flipIfWarranted(deflatedEnd, 1)) {\n+                dMin2 = Math.min(dMin2, work[l - 1]);\n+                work[l - 1] =\n+                    Math.min(work[l - 1],\n+                             Math.min(work[3 + pingPong], work[7 + pingPong]));\n+                work[l - 2 * pingPong] =\n+                    Math.min(work[l - 2 * pingPong],\n+                             Math.min(work[6 + pingPong], work[6 + pingPong]));\n+                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));\n+                dMin  = -0.0;\n+            }\n+        }\n+\n+        if ((dMin < 0) ||\n+            (MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1],\n+                                                  Math.min(work[l - 9],\n+                                                           dMin2 + work[l - 2 * pingPong])))) {\n+            // step 3: choose a shift\n+            computeShiftIncrement(start, deflatedEnd, end - deflatedEnd);\n+\n+            // step 4a: dqds\n+            for (boolean loop = true; loop;) {\n+\n+                // perform one dqds step with the chosen shift\n+                dqds(start, deflatedEnd);\n+\n+                // check result of the dqds step\n+                if ((dMin >= 0) && (dMin1 > 0)) {\n+                    // the shift was good\n+                    updateSigma(tau);\n+                    return deflatedEnd;\n+                } else if ((dMin < 0.0) &&\n+                           (dMin1 > 0.0) &&\n+                           (work[4 * deflatedEnd - 5 - pingPong] < TOLERANCE * (sigma + dN1)) &&\n+                           (Math.abs(dN) < TOLERANCE * sigma)) {\n+                   // convergence hidden by negative DN.\n+                    work[4 * deflatedEnd - 3 - pingPong] = 0.0;\n+                    dMin = 0.0;\n+                    updateSigma(tau);\n+                    return deflatedEnd;\n+                } else if (dMin < 0.0) {\n+                    // tau too big. Select new tau and try again.\n+                    if (tType < -22) {\n+                        // failed twice. Play it safe.\n+                        tau = 0.0;\n+                    } else if (dMin1 > 0.0) {\n+                        // late failure. Gives excellent shift.\n+                        tau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);\n+                        tType -= 11;\n+                    } else {\n+                        // early failure. Divide by 4.\n+                        tau *= 0.25;\n+                        tType -= 12;\n+                    }\n+                } else if (Double.isNaN(dMin)) {\n+                    tau = 0.0;\n+                } else {\n+                    // possible underflow. Play it safe.\n+                    loop = false;\n+                }\n+            }\n+\n+        }\n+\n+        // perform a dqd step (i.e. no shift)\n+        dqd(start, deflatedEnd);\n+\n+        return deflatedEnd;\n+\n+    }\n+\n+    /**\n+     * Flip qd array if warranted.\n+     * @param n number of rows in the block\n+     * @param step within the array (1 for flipping all elements, 2 for flipping\n+     * only every other element)\n+     * @return true if qd array was flipped\n+     */\n+    private boolean flipIfWarranted(final int n, final int step) {\n+        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n+            // flip array\n+            for (int i = 0, j = 4 * n - 1; i < j; i += 4, j -= 4) {\n+                for (int k = 0; k < 4; k += step) {\n+                    final double tmp = work[i + k];\n+                    work[i + k] = work[j - k];\n+                    work[j - k] = tmp;\n+                }\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Compute an interval containing all eigenvalues of a block.\n+     * @param index index of the first row of the block\n+     * @param n number of rows of the block\n+     * @return an interval containing the eigenvalues\n+     */\n+    private double[] eigenvaluesRange(final int index, final int n) {\n+\n+        // find the bounds of the spectra of the local block\n+        final int lowerStart = 4 * main.length;\n+        final int upperStart = 5 * main.length;\n+        double lower = Double.POSITIVE_INFINITY;\n+        double upper = Double.NEGATIVE_INFINITY;\n+        for (int i = 0; i < n; ++i) {\n+            lower = Math.min(lower, work[lowerStart + index +i]);\n+            upper = Math.max(upper, work[upperStart + index +i]);\n+        }\n+\n+        // set thresholds\n+        final double tNorm = Math.max(Math.abs(lower), Math.abs(upper));\n+        final double relativeTolerance = Math.sqrt(MathUtils.EPSILON);\n+        final double absoluteTolerance = 4 * minPivot;\n+        final int maxIter =\n+            2 + (int) ((Math.log(tNorm + minPivot) - Math.log(minPivot)) / Math.log(2.0));\n+        final double margin = 2 * (tNorm * MathUtils.EPSILON * n + 2 * minPivot);\n+\n+        // search lower eigenvalue\n+        double left  = lower - margin;\n+        double right = upper + margin;\n+        for (int i = 0; i < maxIter; ++i) {\n+\n+            final double range = right - left;\n+            if ((range < absoluteTolerance) ||\n+                (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) {\n+                // search has converged\n+                break;\n+            }\n+\n+            final double middle = 0.5 * (left + right);\n+            if (countEigenValues(middle, index, n) >= 1) {\n+                right = middle;\n+            } else {\n+                left = middle;\n+            }\n+\n+        }\n+        lower = Math.max(lower, left - 100 * MathUtils.EPSILON * Math.abs(left));\n+\n+        // search upper eigenvalue\n+        left  = lower - margin;\n+        right = upper + margin;\n+        for (int i = 0; i < maxIter; ++i) {\n+\n+            final double range = right - left;\n+            if ((range < absoluteTolerance) ||\n+                (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) {\n+                // search has converged\n+                break;\n+            }\n+\n+            final double middle = 0.5 * (left + right);\n+            if (countEigenValues(middle, index, n) >= n) {\n+                right = middle;\n+            } else {\n+                left = middle;\n+            }\n+\n+        }\n+        upper = Math.min(upper, right + 100 * MathUtils.EPSILON * Math.abs(right));\n+\n+        return new double[] { lower, upper };\n+\n+    }\n+\n+    /**\n+     * Count the number of eigenvalues below a point.\n+     * @param t value below which we must count the number of eigenvalues\n+     * @param index index of the first row of the block\n+     * @param n number of rows of the block\n+     * @return number of eigenvalues smaller than t\n+     */\n+    private int countEigenValues(final double t, final int index, final int n) {\n+        double ratio = main[index] - t;\n+        int count = (ratio > 0) ? 0 : 1;\n+        for (int i = 1; i < n; ++i) {\n+            ratio = main[index + i] - squaredSecondary[index + i - 1] / ratio - t;\n+            if (ratio <= 0) {\n+                ++count;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Decompose the shifted tridiagonal matrix T-&lambda;I as LDL<sup>T</sup>.\n+     * <p>A shifted symmetric tridiagonal matrix T can be decomposed as\n+     * LDL<sup>T</sup> where L is a lower bidiagonal matrix with unit diagonal\n+     * and D is a diagonal matrix. This method is an implementation of\n+     * algorithm 4.4.7 from Dhillon's thesis.</p>\n+     * @param lambda shift to add to the matrix before decomposing it\n+     * to ensure it is positive definite\n+     * @param index index of the first row of the block\n+     * @param n number of rows of the block\n+     */\n+    private void ldlTDecomposition(final double lambda, final int index, final int n) {\n+        double di = main[index] - lambda;\n+        work[0] = Math.abs(di);\n+        for (int i = 1; i < n; ++i) {\n+            final int    fourI = 4 * i;\n+            final double eiM1  = secondary[index + i - 1];\n+            final double ratio = eiM1 / di;\n+            work[fourI - 2] = ratio * ratio * Math.abs(di);\n+            di = (main[index + i] - lambda) - eiM1 * ratio;\n+            work[fourI] = Math.abs(di);\n+        }\n+    }\n+\n+    /**\n+     * Perform a dqds step, using current shift increment.\n+     * <p>This implementation is a translation of the LAPACK routine DLASQ5.</p>\n+     * @param start start index\n+     * @param end end index\n+     */\n+    private void dqds(final int start, final int end) {\n+\n+        eMin = work[4 * start + pingPong + 4];\n+        double d = work[4 * start + pingPong] - tau;\n+        dMin = d;\n+        dMin1 = -work[4 * start + pingPong];\n+\n+        if (pingPong == 0) {\n+            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {\n+                work[j4 - 2] = d + work[j4 - 1];\n+                final double tmp = work[j4 + 1] / work[j4 - 2];\n+                d = d * tmp - tau;\n+                dMin = Math.min(dMin, d);\n+                work[j4] = work[j4 - 1] * tmp;\n+                eMin = Math.min(work[j4], eMin);\n+            }\n+        } else {\n+            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {\n+                work[j4 - 3] = d + work[j4];\n+                final double tmp = work[j4 + 2] / work[j4 - 3];\n+                d = d * tmp - tau;\n+                dMin = Math.min(dMin, d);\n+                work[j4 - 1] = work[j4] * tmp;\n+                eMin = Math.min(work[j4 - 1], eMin);\n+            }\n+        }\n+\n+        // unroll last two steps.\n+        dN2 = d;\n+        dMin2 = dMin;\n+        int j4 = 4 * (end - 2) - pingPong - 1;\n+        int j4p2 = j4 + 2 * pingPong - 1;\n+        work[j4 - 2] = dN2 + work[j4p2];\n+        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n+        dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]) - tau;\n+        dMin = Math.min(dMin, dN1);\n+\n+        dMin1 = dMin;\n+        j4 = j4 + 4;\n+        j4p2 = j4 + 2 * pingPong - 1;\n+        work[j4 - 2] = dN1 + work[j4p2];\n+        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n+        dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]) - tau;\n+        dMin = Math.min(dMin, dN);\n+\n+        work[j4 + 2] = dN;\n+        work[4 * end - pingPong - 1] = eMin;\n+\n+    }\n+\n+\n+    /**\n+     * Perform a dqd step.\n+     * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>\n+     * @param start start index\n+     * @param end end index\n+     */\n+    private void dqd(final int start, final int end) {\n+\n+        eMin = work[4 * start + pingPong + 4];\n+        double d = work[4 * start + pingPong];\n+        dMin = d;\n+\n+        if (pingPong == 0) {\n+            for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {\n+                work[j4 - 2] = d + work[j4 - 1];\n+                if (work[j4 - 2] == 0.0) {\n+                    work[j4] = 0.0;\n+                    d = work[j4 + 1];\n+                    dMin = d;\n+                    eMin = 0.0;\n+                } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&\n+                           (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {\n+                    final double tmp = work[j4 + 1] / work[j4 - 2];\n+                    work[j4] = work[j4 - 1] * tmp;\n+                    d *= tmp;\n+                } else {\n+                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);\n+                    d *= work[j4 + 1] / work[j4 - 2];\n+                }\n+                dMin = Math.min(dMin, d);\n+                eMin = Math.min(eMin, work[j4]);\n+            }\n+        } else {\n+            for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {\n+                work[j4 - 3] = d + work[j4];\n+                if (work[j4 - 3] == 0.0) {\n+                    work[j4 - 1] = 0.0;\n+                    d = work[j4 + 2];\n+                    dMin = d;\n+                    eMin = 0.0;\n+                } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&\n+                           (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {\n+                    final double tmp = work[j4 + 2] / work[j4 - 3];\n+                    work[j4 - 1] = work[j4] * tmp;\n+                    d *= tmp;\n+                } else {\n+                    work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);\n+                    d *= work[j4 + 2] / work[j4 - 3];\n+                }\n+                dMin = Math.min(dMin, d);\n+                eMin = Math.min(eMin, work[j4 - 1]);\n+            }\n+        }\n+\n+        // Unroll last two steps\n+        dN2   = d;\n+        dMin2 = dMin;\n+        int j4 = 4 * (end - 2) - pingPong - 1;\n+        int j4p2 = j4 + 2 * pingPong - 1;\n+        work[j4 - 2] = dN2 + work[j4p2];\n+        if (work[j4 - 2] == 0.0) {\n+            work[j4] = 0.0;\n+            dN1  = work[j4p2 + 2];\n+            dMin = dN1;\n+            eMin = 0.0;\n+        } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&\n+                   (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {\n+            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n+            work[j4] = work[j4p2] * tmp;\n+            dN1 = dN2 * tmp;\n+        } else {\n+            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n+            dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);\n+        }\n+        dMin = Math.min(dMin, dN1);\n+\n+        dMin1 = dMin;\n+        j4 = j4 + 4;\n+        j4p2 = j4 + 2 * pingPong - 1;\n+        work[j4 - 2] = dN1 + work[j4p2];\n+        if (work[j4 - 2] == 0.0) {\n+            work[j4] = 0.0;\n+            dN   = work[j4p2 + 2];\n+            dMin = dN;\n+            eMin = 0.0;\n+        } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&\n+                   (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {\n+            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n+            work[j4] = work[j4p2] * tmp;\n+            dN = dN1 * tmp;\n+        } else {\n+            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n+            dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);\n+        }\n+        dMin = Math.min(dMin, dN);\n+\n+        work[j4 + 2] = dN;\n+        work[4 * end - pingPong - 1] = eMin;\n+\n+    }\n+\n+    /**\n+     * Compute the shift increment as an estimate of the smallest eigenvalue.\n+     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n+     * @param start start index\n+     * @param end end index\n+     * @param deflated number of eigenvalues just deflated\n+     */\n+    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n+\n+        final double cnst1 = 0.563;\n+        final double cnst2 = 1.010;\n+        final double cnst3 = 1.05;\n+\n+        // a negative dMin forces the shift to take that absolute value\n+        // tType records the type of shift.\n+        if (dMin <= 0.0) {\n+            tau = -dMin;\n+            tType = -1;\n+            return;\n+        }\n+\n+        int nn = 4 * end + pingPong - 1;\n+        switch (deflated) {\n+\n+        case 0 : // no eigenvalues deflated. \n+            if (dMin == dN || dMin == dN1) {\n+\n+                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n+                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n+                double a2 = work[nn - 7] + work[nn - 5];\n+\n+                if (dMin == dN && dMin1 == dN1) {\n+                    // cases 2 and 3. \n+                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n+                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n+                    if (gap1 > 0.0 && gap1 > b1) {\n+                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n+                        tType = -2;\n+                    } else {\n+                        double s = 0.0;\n+                        if (dN > b1) {\n+                            s = dN - b1;\n+                        }\n+                        if (a2 > (b1 + b2)) {\n+                            s = Math.min(s, a2 - (b1 + b2));\n+                        }\n+                        tau   = Math.max(s, 0.333 * dMin);\n+                        tType = -3;\n+                    }\n+                } else {\n+                    // case 4.\n+                    tType = -4;\n+                    double s = 0.25 * dMin;\n+                    double gam;\n+                    int np;\n+                    if (dMin == dN) {\n+                        gam = dN;\n+                        a2 = 0.0;\n+                        if (work[nn - 5]  >  work[nn - 7]) {\n+                            return;\n+                        }\n+                        b2 = work[nn - 5] / work[nn - 7];\n+                        np = nn - 9;\n+                    } else {\n+                        np = nn - 2 * pingPong;\n+                        b2 = work[np - 2];\n+                        gam = dN1;\n+                        if (work[np - 4]  >  work[np - 2]) {\n+                            return;\n+                        }\n+                        a2 = work[np - 4] / work[np - 2];\n+                        if (work[nn - 9]  >  work[nn - 11]) {\n+                            return;\n+                        }\n+                        b2 = work[nn - 9] / work[nn - 11];\n+                        np = nn - 13;\n+                    }\n+\n+                    // approximate contribution to norm squared from i < nn-1.\n+                    a2 = a2 + b2;\n+                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n+                        if(b2 == 0.0) {\n+                            break;\n+                        }\n+                        b1 = b2;\n+                        if (work[i4]  >  work[i4 - 2]) {\n+                            return;\n+                        }\n+                        b2 = b2 * (work[i4] / work[i4 - 2]);\n+                        a2 = a2 + b2;\n+                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n+                            break;\n+                        }\n+                    }\n+                    a2 = cnst3 * a2;\n+\n+                    // rayleigh quotient residual bound.\n+                    if (a2 < cnst1) {\n+                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n+                    }\n+                    tau = s;\n+\n+                }\n+            } else if (dMin == dN2) {\n+\n+                // case 5.\n+                tType = -5;\n+                double s = 0.25 * dMin;\n+\n+                // compute contribution to norm squared from i > nn-2.\n+                final int np = nn - 2 * pingPong;\n+                double b1 = work[np - 2];\n+                double b2 = work[np - 6];\n+                final double gam = dN2;\n+                if (work[np - 8] > b2 || work[np - 4] > b1) {\n+                    return;\n+                }\n+                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n+\n+                // approximate contribution to norm squared from i < nn-2.\n+                if (end - start > 2) {\n+                    b2 = work[nn - 13] / work[nn - 15];\n+                    a2 = a2 + b2;\n+                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n+                        if (b2 == 0.0) {\n+                            break;\n+                        }\n+                        b1 = b2;\n+                        if (work[i4]  >  work[i4 - 2]) {\n+                            return;\n+                        }\n+                        b2 = b2 * (work[i4] / work[i4 - 2]);\n+                        a2 = a2 + b2;\n+                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n+                            break;\n+                        }\n+                    }\n+                    a2 = cnst3 * a2;\n+                }\n+\n+                if (a2 < cnst1) {\n+                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n+                } else {\n+                    tau = s;\n+                }\n+\n+            } else {\n+\n+                // case 6, no information to guide us.\n+                if (tType == -6) {\n+                    g += 0.333 * (1 - g);\n+                } else if (tType == -18) {\n+                    g = 0.25 * 0.333;\n+                } else {\n+                    g = 0.25;\n+                }\n+                tau   = g * dMin;\n+                tType = -6;\n+\n+            }\n+            break;\n+\n+        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n+            if (dMin1 == dN1 && dMin2 == dN2) { \n+\n+                // cases 7 and 8.\n+                tType = -7;\n+                double s = 0.333 * dMin1;\n+                if (work[nn - 5] > work[nn - 7]) {\n+                    return;\n+                }\n+                double b1 = work[nn - 5] / work[nn - 7];\n+                double b2 = b1;\n+                if (b2 != 0.0) {\n+                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n+                        final double oldB1 = b1;\n+                        if (work[i4] > work[i4 - 2]) {\n+                            return;\n+                        }\n+                        b1 = b1 * (work[i4] / work[i4 - 2]);\n+                        b2 = b2 + b1;\n+                        if (100 * Math.max(b1, oldB1) < b2) {\n+                            break;\n+                        }\n+                    }\n+                }\n+                b2 = Math.sqrt(cnst3 * b2);\n+                final double a2 = dMin1 / (1 + b2 * b2);\n+                final double gap2 = 0.5 * dMin2 - a2;\n+                if (gap2 > 0.0 && gap2 > b2 * a2) {\n+                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n+                } else {\n+                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n+                    tType = -8;\n+                }\n+            } else {\n+\n+                // case 9.\n+                tau = 0.25 * dMin1;\n+                if (dMin1 == dN1) {\n+                    tau = 0.5 * dMin1;\n+                }\n+                tType = -9;\n+            }\n+            break;\n+\n+        case 2 : // two eigenvalues deflated. use dMin2, dN2 for dMin and dN.\n+\n+            // cases 10 and 11.\n+            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { \n+                tType = -10;\n+                final double s = 0.333 * dMin2;\n+                if (work[nn - 5] > work[nn - 7]) {\n+                    return;\n+                }\n+                double b1 = work[nn - 5] / work[nn - 7];\n+                double b2 = b1;\n+                if (b2 != 0.0){\n+                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n+                        if (work[i4] > work[i4 - 2]) {\n+                            return;\n+                        }\n+                        b1 *= work[i4] / work[i4 - 2];\n+                        b2 += b1;\n+                        if (100 * b1 < b2) {\n+                            break;\n+                        }\n+                    }\n+                }\n+                b2 = Math.sqrt(cnst3 * b2);\n+                final double a2 = dMin2 / (1 + b2 * b2);\n+                final double gap2 = work[nn - 7] + work[nn - 9] -\n+                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n+                if (gap2 > 0.0 && gap2 > b2 * a2) {\n+                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n+                } else {\n+                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n+                }\n+            } else {\n+                tau   = 0.25 * dMin2;\n+                tType = -11;\n+            }\n+            break;\n+\n+        default : // case 12, more than two eigenvalues deflated. no information.\n+            tau   = 0.0;\n+            tType = -12;\n+        }\n+\n+    }\n+\n+    /**\n+     * Update sigma.\n+     * @param tau shift to apply to sigma\n+     */\n+    private void updateSigma(final double tau) {\n+        // BEWARE: do NOT attempt to simplify the following statements\n+        // the expressions below take care to accumulate the part of sigma\n+        // that does not fit within a double variable into sigmaLow\n+        if (tau < sigma) {\n+            sigmaLow += tau;\n+            final double t = sigma + sigmaLow;\n+            sigmaLow -= t - sigma;\n+            sigma = t;\n+        } else {\n+            final double t = sigma + tau;\n+            sigmaLow += sigma - (t - tau);\n+            sigma = t;\n+        }\n+    }\n+\n+    /**\n+     * Find eigenvectors.\n+     */\n+    private void findEigenVectors() {\n+\n+        final int m = main.length;\n+        eigenvectors = new RealVectorImpl[m];\n+\n+        // perform an initial non-shifted LDLt decomposition\n+        final double[] d = new double[m];\n+        final double[] l = new double[m - 1];\n+        double di = main[0];\n+        d[0] = di;\n+        for (int i = 1; i < m; ++i) {\n+            final double eiM1  = secondary[i - 1];\n+            final double ratio = eiM1 / di;\n+            di       = main[i] - eiM1 * ratio;\n+            l[i - 1] = ratio;\n+            d[i]     = di;\n+        }\n+\n+        // compute eigenvectors\n+        for (int i = 0; i < m; ++i) {\n+            eigenvectors[i] = findEigenvector(eigenvalues[i], d, l);\n+        }\n+\n+    }\n+\n+    /**\n+     * Find an eigenvector corresponding to an eigenvalue, using bidiagonals.\n+     * <p>This method corresponds to algorithm X from Dhillon's thesis.</p>\n+     * \n+     * @param eigenvalue eigenvalue for which eigenvector is desired\n+     * @param d diagonal elements of the initial non-shifted D matrix\n+     * @param l off-diagonal elements of the initial non-shifted L matrix\n+     * @return an eigenvector\n+     */\n+    private RealVectorImpl findEigenvector(final double eigenvalue,\n+                                           final double[] d, final double[] l) {\n+\n+        // compute the LDLt and UDUt decompositions of the\n+        // perfectly shifted tridiagonal matrix\n+        final int m = main.length;\n+        stationaryQuotientDifferenceWithShift(d, l, eigenvalue);\n+        progressiveQuotientDifferenceWithShift(d, l, eigenvalue);\n+\n+        // select the twist index leading to\n+        // the least diagonal element in the twisted factorization\n+        int r = m - 1;\n+        double minG = Math.abs(work[6 * r] + work[6 * r + 3] + eigenvalue);\n+        for (int i = 0, sixI = 0; i < m - 1; ++i, sixI += 6) {\n+            final double g = work[sixI] + d[i] * work[sixI + 9] / work[sixI + 10];\n+            final double absG = Math.abs(g);\n+            if (absG < minG) {\n+                r = i;\n+                minG = absG;\n+            }\n+        }\n+\n+        // solve the singular system by ignoring the equation\n+        // at twist index and propagating upwards and downwards\n+        double[] eigenvector = new double[m];\n+        double n2 = 1;\n+        eigenvector[r] = 1;\n+        double z = 1;\n+        for (int i = r - 1; i >= 0; --i) {\n+            z *= -work[6 * i + 2];\n+            eigenvector[i] = z;\n+            n2 += z * z;\n+        }\n+        z = 1;\n+        for (int i = r + 1; i < m; ++i) {\n+            z *= -work[6 * i - 1];\n+            eigenvector[i] = z;\n+            n2 += z * z;\n+        }\n+\n+        // normalize vector\n+        final double inv = 1.0 / Math.sqrt(n2);\n+        for (int i = 0; i < m; ++i) {\n+            eigenvector[i] *= inv;\n+        }\n+\n+        return new RealVectorImpl(orthoTridiag.operate(eigenvector), true);\n+\n+    }\n+\n+    /**\n+     * Decompose matrix LDL<sup>T</sup> - &lambda; I as\n+     * L<sub>+</sub>D<sub>+</sub>L<sub>+</sub><sup>T</sup>.\n+     * <p>This method corresponds to algorithm 4.4.3 (dstqds) from Dhillon's thesis.</p>\n+     * @param d diagonal elements of D,\n+     * @param l off-diagonal elements of L\n+     * @param lambda shift to apply\n+     */\n+    private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l,\n+                                                       final double lambda) {\n+        final int nM1 = d.length - 1;\n+        double si = -lambda;\n+        for (int i = 0, sixI = 0; i < nM1; ++i, sixI += 6) {\n+            final double di   = d[i];\n+            final double li   = l[i];\n+            final double diP1 = di + si;\n+            final double liP1 = li * di / diP1;\n+            work[sixI]        = si;\n+            work[sixI + 1]    = diP1;\n+            work[sixI + 2]    = liP1;\n+            si = li * liP1 * si - lambda;\n+        }\n+        work[6 * nM1 + 1] = d[nM1] + si;\n+        work[6 * nM1]     = si;\n+    }\n+\n+    /**\n+     * Decompose matrix LDL<sup>T</sup> - &lambda; I as\n+     * U<sub>-</sub>D<sub>-</sub>U<sub>-</sub><sup>T</sup>.\n+     * <p>This method corresponds to algorithm 4.4.5 (dqds) from Dhillon's thesis.</p>\n+     * @param d diagonal elements of D\n+     * @param l off-diagonal elements of L\n+     * @param lambda shift to apply\n+     */\n+    private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l,\n+                                                        final double lambda) {\n+        final int nM1 = d.length - 1;\n+        double pi = d[nM1] - lambda;\n+        for (int i = nM1 - 1, sixI = 6 * i; i >= 0; --i, sixI -= 6) {\n+            final double di   = d[i];\n+            final double li   = l[i];\n+            final double diP1 = di * li * li + pi;\n+            final double t    = di / diP1;\n+            work[sixI +  9]   = pi;\n+            work[sixI + 10]   = diP1;\n+            work[sixI +  5]   = li * t;\n+            pi = pi * t - lambda;\n+        }\n+        work[3] = pi;\n+        work[4] = pi;\n+    }\n+\n+    /**\n+     * Check if decomposition has been performed.\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n+     */\n+    private void checkDecomposed()\n+        throws IllegalStateException {\n+        if (eigenvalues == null) {\n+            throw MathRuntimeException.createIllegalStateException(\"no matrix have been decomposed yet\", null);\n+        }\n+    }\n+\n+    /**\n+     * Check if decomposed matrix is non singular.\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n+     * @exception SingularMatrixException if decomposed matrix is singular\n+     */\n+    private void checkNonSingular()\n+        throws IllegalStateException, SingularMatrixException {\n+        checkDecomposed();\n+        if (!isNonSingular()) {\n+            throw new SingularMatrixException();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/GershgorinCirclesUnion.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/** Class representing a union of Gershgorin circles.\n+ * <p>Gershgorin circles are bounding areas where eigenvalues must lie.\n+ * They are used as starting values for eigen decomposition algorithms.\n+ * In the real case, Gershgorin circles are simple intervals.</p>\n+ * @see EigenDecompositionImpl\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+class GershgorinCirclesUnion implements Comparable<GershgorinCirclesUnion> {\n+\n+    /** Lower bound of the interval. */\n+    private double low;\n+\n+    /** Higher bound of the interval. */\n+    private double high;\n+\n+    /** Create a simple Gershgorin circle.\n+     * @param d diagonal element of the current row\n+     * @param sum sum of the absolute values of the off-diagonal elements\n+     * of the current row\n+     */\n+    public GershgorinCirclesUnion(final double d, final double sum) {\n+        low  = d - sum;\n+        high = d + sum;\n+    }\n+\n+    /**\n+     * Get the lower bound of the interval.\n+     * @return lower bound of the interval\n+     */\n+    public double getLow() {\n+        return low;\n+    }\n+\n+    /**\n+     * Get the higher bound of the interval.\n+     * @return higher bound of the interval\n+     */\n+    public double getHigh() {\n+        return high;\n+    }\n+\n+    /**\n+     * Check if a Gershgorin circles union intersects instance.\n+     * @param other Gershgorin circles union to test against instance\n+     * @return true if the other Gershgorin circles union intersects instance\n+     */\n+    public boolean intersects(final GershgorinCirclesUnion other) {\n+        return (other.low <= this.high) && (other.high >= this.low);\n+    }\n+\n+    /**\n+     * Swallow another Gershgorin circles union.\n+     * <p>Swallowing another Gershgorin circles union changes the\n+     * instance such that it contains everything that was formerly in\n+     * either circles union. It is mainly intended for circles unions\n+     * that {@link #intersects(GershgorinCirclesUnion) intersect}\n+     * each other beforehand.</p>\n+     * @param other Gershgorin circles union to swallow\n+     */\n+    public void swallow(final GershgorinCirclesUnion other) {\n+        low  = Math.min(low,  other.low);\n+        high = Math.max(high, other.high);\n+    }\n+\n+    /** Compare another Gershgorin circles union in interval start order.\n+     * @param other Gershgorin circles union to compare to instance\n+     * @return a negative, zero or positive value depending on the other\n+     * union starting before, at same location or after instance\n+     */\n+    public int compareTo(GershgorinCirclesUnion other) {\n+        return Double.compare(low, other.low);\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/InvalidMatrixException.java\n+++ b/src/java/org/apache/commons/math/linear/InvalidMatrixException.java\n \n package org.apache.commons.math.linear;\n \n+import org.apache.commons.math.MathRuntimeException;\n+\n /**\n  * Thrown when a system attempts an operation on a matrix, and\n  * that matrix does not satisfy the preconditions for the\n  * aforementioned operation.\n  * @version $Revision$ $Date$\n  */\n-public class InvalidMatrixException extends RuntimeException {\n+public class InvalidMatrixException extends MathRuntimeException {\n \n-    /** Serializable version identifier */\n-    private static final long serialVersionUID = 5318837237354354107L;\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 1135533765052675495L;\n \n     /**\n-     * Default constructor.\n+     * Construct an exception with the given message.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.0\n      */\n-    public InvalidMatrixException() {\n-        this(null);\n+    public InvalidMatrixException(final String pattern, final Object[] arguments) {\n+        super(pattern, arguments);\n     }\n \n     /**\n      * Construct an exception with the given message.\n-     * @param message descriptive error message.\n+     * @param cause the exception or error that caused this exception\n+     * to be thrown.\n+     * @since 2.0\n      */\n-    public InvalidMatrixException(String message) {\n-        super(message);\n+    public InvalidMatrixException(final Throwable cause) {\n+        super(cause);\n     }\n \n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/LUDecomposition.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * An interface to classes that implement an algorithm to calculate the \n+ * LU-decomposition of a real matrix.\n+ * <p>The LU-decomposition of matrix A is a set of three matrices: P, L and U\n+ * such that P&times;A = L&times;U. P is a rows permutation matrix that is used\n+ * to rearrange the rows of A before so that it can be decomposed. L is a lower\n+ * triangular matrix with unit diagonal terms and U is an upper triangular matrix.</p>\n+ * <p>This interface is based on the class with similar name from the now defunct\n+ * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n+ * following changes:</p>\n+ * <ul>\n+ *   <li>several signatures have been added for the <code>solve</code> methods\n+ *   (in the superinterface),</li>\n+ *   <li>a {@link DecompositionSolver#decompose(RealMatrix) decompose(RealMatrix)}\n+ *   method has been added (in the superinterface),</li>\n+ *   <li>a {@link DecompositionSolver#isNonSingular() isNonSingular} method has\n+ *   been added (in the superinterface),</li>\n+ *   <li>a {@link DecompositionSolver#getInverse() getInverse} method has been\n+ *   added (in the superinterface),</li>\n+ *   <li>the <code>det</code> method has been renamed as {@link #getDeterminant() getDeterminant}.</li>\n+ * </ul>\n+ *   \n+ * @see <a href=\"http://mathworld.wolfram.com/LUDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/LU_decomposition\">Wikipedia</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface LUDecomposition extends DecompositionSolver {\n+\n+    /**\n+     * Computes a new\n+     * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n+     * LU decomposition</a> for this matrix, storing the result for use by other methods.\n+     * <p>\n+     * <strong>Implementation Note</strong>:<br>\n+     * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/people/sd/lectures/nummeth98/linear.htm\">\n+     * Crout's algorithm</a>, with partial pivoting.</p>\n+     * @param matrix The matrix to decompose.\n+     * @param singularityThreshold threshold (based on partial row norm)\n+     * under which a matrix is considered singular\n+     * @exception InvalidMatrixException if matrix is not square\n+     */\n+    void decompose(RealMatrix matrix, double singularityThreshold);\n+\n+    /**\n+     * Returns the matrix L of the decomposition. \n+     * <p>L is an lower-triangular matrix</p>\n+     * @return the L matrix (or null if decomposed matrix is singular)\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     */\n+    RealMatrix getL() throws IllegalStateException;\n+\n+    /**\n+     * Returns the matrix U of the decomposition. \n+     * <p>U is an upper-triangular matrix</p>\n+     * @return the U matrix (or null if decomposed matrix is singular)\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     */\n+    RealMatrix getU() throws IllegalStateException;\n+\n+    /**\n+     * Returns the P rows permutation matrix.\n+     * <p>P is a sparse matrix with exactly one element set to 1.0 in\n+     * each row and each column, all other elements being set to 0.0.</p>\n+     * <p>The positions of the 1 elements are given by the {@link #getPivot()\n+     * pivot permutation vector}.</p>\n+     * @return the P rows permutation matrix (or null if decomposed matrix is singular)\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     * @see #getPivot()\n+     */\n+    RealMatrix getP() throws IllegalStateException;\n+\n+    /**\n+     * Returns the pivot permutation vector.\n+     * @return the pivot permutation vector\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     * @see #getPermutation()\n+     */\n+    int[] getPivot() throws IllegalStateException;\n+\n+    /**\n+     * Return the determinant of the matrix\n+     * @return determinant of the matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     * @see #isNonSingular()\n+     */\n+    double getDeterminant() throws IllegalStateException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Calculates the LUP-decomposition of a square matrix.\n+ * <p>The LUP-decomposition of a matrix A consists of three matrices\n+ * L, U and P that satisfy: A = LUP, L is lower triangular, and U is\n+ * upper triangular and P is a permutation matrix. All matrices are\n+ * m&times;m.</p>\n+ * <p>As shown by the presence of the P matrix, this decomposition is\n+ * implemented using partial pivoting.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class LUDecompositionImpl implements LUDecomposition {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 3446121671437672843L;\n+\n+    /** Entries of LU decomposition. */\n+    private double lu[][];\n+\n+    /** Pivot permutation associated with LU decomposition */\n+    private int[] pivot;\n+\n+    /** Parity of the permutation associated with the LU decomposition */\n+    private int parity;\n+\n+    /** Singularity indicator. */\n+    private boolean singular;\n+\n+    /** Cached value of L. */\n+    private RealMatrix cachedL;\n+\n+    /** Cached value of U. */\n+    private RealMatrix cachedU;\n+\n+    /** Cached value of P. */\n+    private RealMatrix cachedP;\n+\n+    /** Default bound to determine effective singularity in LU decomposition */\n+    private static final double DEFAULT_TOO_SMALL = 10E-12;\n+\n+    /**\n+     * Build a new instance.\n+     * <p>Note that either {@link #decompose(RealMatrix)} or\n+     * {@link #decompose(RealMatrix, double)} <strong>must</strong> be called\n+     * before any of the {@link #getP()}, {@link #getPivot()}, {@link #getL()},\n+     * {@link #getU()}, {@link #getDeterminant()}, {@link #isNonSingular()},\n+     * {@link #solve(double[])}, {@link #solve(RealMatrix)}, {@link #solve(RealVector)}\n+     * or {@link #solve(RealVectorImpl)} methods can be called.</p>\n+     * @see #decompose(RealMatrix)\n+     * @see #decompose(RealMatrix, double)\n+     */\n+    public LUDecompositionImpl() {\n+    }\n+\n+    /**\n+     * Calculates the LU-decomposition of the given matrix. \n+     * <p>Calling this constructor is equivalent to first call the no-arguments\n+     * constructor and then call {@link #decompose(RealMatrix)}.</p>\n+     * @param matrix The matrix to decompose.\n+     * @exception InvalidMatrixException if matrix is not square\n+     */\n+    public LUDecompositionImpl(RealMatrix matrix)\n+        throws InvalidMatrixException {\n+        decompose(matrix);\n+    }\n+\n+    /**\n+     * Calculates the LU-decomposition of the given matrix. \n+     * <p>Calling this constructor is equivalent to first call the no-arguments\n+     * constructor and then call {@link #decompose(RealMatrix, double)}.</p>\n+     * @param matrix The matrix to decompose.\n+     * @param singularityThreshold threshold (based on partial row norm)\n+     * under which a matrix is considered singular\n+     * @exception InvalidMatrixException if matrix is not square\n+     */\n+    public LUDecompositionImpl(RealMatrix matrix, double singularityThreshold)\n+        throws InvalidMatrixException {\n+        decompose(matrix, singularityThreshold);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void decompose(RealMatrix matrix)\n+        throws InvalidMatrixException {\n+        decompose(matrix, DEFAULT_TOO_SMALL);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void decompose(RealMatrix matrix, double singularityThreshold)\n+        throws InvalidMatrixException {\n+        if (!matrix.isSquare()) {\n+            throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n+        }\n+        final int m = matrix.getColumnDimension();\n+        lu = matrix.getData();\n+        pivot = new int[m];\n+        cachedL = null;\n+        cachedU = null;\n+        cachedP = null;\n+\n+        // Initialize permutation array and parity\n+        for (int row = 0; row < m; row++) {\n+            pivot[row] = row;\n+        }\n+        parity = 1;\n+        singular = false;\n+\n+        // Loop over columns\n+        for (int col = 0; col < m; col++) {\n+\n+            double sum = 0;\n+\n+            // upper\n+            for (int row = 0; row < col; row++) {\n+                final double[] luRow = lu[row];\n+                sum = luRow[col];\n+                for (int i = 0; i < row; i++) {\n+                    sum -= luRow[i] * lu[i][col];\n+                }\n+                luRow[col] = sum;\n+            }\n+\n+            // lower\n+            int max = col; // permutation row\n+            double largest = Double.NEGATIVE_INFINITY;\n+            for (int row = col; row < m; row++) {\n+                final double[] luRow = lu[row];\n+                sum = luRow[col];\n+                for (int i = 0; i < col; i++) {\n+                    sum -= luRow[i] * lu[i][col];\n+                }\n+                luRow[col] = sum;\n+\n+                // maintain best permutation choice\n+                if (Math.abs(sum) > largest) {\n+                    largest = Math.abs(sum);\n+                    max = row;\n+                }\n+            }\n+\n+            // Singularity check\n+            if (Math.abs(lu[max][col]) < singularityThreshold) {\n+                singular = true;\n+                return;\n+            }\n+\n+            // Pivot if necessary\n+            if (max != col) {\n+                double tmp = 0;\n+                for (int i = 0; i < m; i++) {\n+                    tmp = lu[max][i];\n+                    lu[max][i] = lu[col][i];\n+                    lu[col][i] = tmp;\n+                }\n+                int temp = pivot[max];\n+                pivot[max] = pivot[col];\n+                pivot[col] = temp;\n+                parity = -parity;\n+            }\n+\n+            // Divide the lower elements by the \"winning\" diagonal elt.\n+            final double luDiag = lu[col][col];\n+            for (int row = col + 1; row < m; row++) {\n+                lu[row][col] /= luDiag;\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getL()\n+        throws IllegalStateException {\n+        checkDecomposed();\n+        if ((cachedL == null) && !singular) {\n+            final int m = pivot.length;\n+            final double[][] lData = new double[m][m];\n+            for (int i = 0; i < m; ++i) {\n+                System.arraycopy(lu[i], 0, lData[i], 0, i);\n+                lData[i][i] = 1.0;\n+            }\n+            cachedL = new RealMatrixImpl(lData, false);\n+        }\n+        return cachedL;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getU()\n+        throws IllegalStateException {\n+        checkDecomposed();\n+        if ((cachedU == null) && !singular) {\n+            final int m = pivot.length;\n+            final double[][] uData = new double[m][m];\n+            for (int i = 0; i < m; ++i) {\n+                System.arraycopy(lu[i], i, uData[i], i, m - i);\n+            }\n+            cachedU = new RealMatrixImpl(uData, false);\n+        }\n+        return cachedU;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getP()\n+        throws IllegalStateException {\n+        checkDecomposed();\n+        if ((cachedP == null) && !singular) {\n+            final int m = pivot.length;\n+            final double[][] pData = new double[m][m];\n+            for (int i = 0; i < m; ++i) {\n+                pData[i][pivot[i]] = 1.0;\n+            }\n+            cachedP = new RealMatrixImpl(pData, false);\n+        }\n+        return cachedP;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int[] getPivot()\n+        throws IllegalStateException {\n+        checkDecomposed();\n+        return pivot.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isNonSingular()\n+        throws IllegalStateException {\n+        checkDecomposed();\n+        return !singular;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDeterminant()\n+        throws IllegalStateException {\n+        checkDecomposed();\n+        if (singular) {\n+            return 0;\n+        } else {\n+            final int m = pivot.length;\n+            double determinant = parity;\n+            for (int i = 0; i < m; i++) {\n+                determinant *= lu[i][i];\n+            }\n+            return determinant;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] solve(double[] b)\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+\n+        checkDecomposed();\n+        final int m = pivot.length;\n+        if (b.length != m) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+        if (singular) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        final double[] bp = new double[m];\n+\n+        // Apply permutations to b\n+        for (int row = 0; row < m; row++) {\n+            bp[row] = b[pivot[row]];\n+        }\n+\n+        // Solve LY = b\n+        for (int col = 0; col < m; col++) {\n+            for (int i = col + 1; i < m; i++) {\n+                bp[i] -= bp[col] * lu[i][col];\n+            }\n+        }\n+\n+        // Solve UX = Y\n+        for (int col = m - 1; col >= 0; col--) {\n+            bp[col] /= lu[col][col];\n+            for (int i = 0; i < col; i++) {\n+                bp[i] -= bp[col] * lu[i][col];\n+            }\n+        }\n+\n+        return bp;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector solve(RealVector b)\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+        try {\n+            return solve((RealVectorImpl) b);\n+        } catch (ClassCastException cce) {\n+\n+            checkDecomposed();\n+            final int m = pivot.length;\n+            if (b.getDimension() != m) {\n+                throw new IllegalArgumentException(\"constant vector has wrong length\");\n+            }\n+            if (singular) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final double[] bp = new double[m];\n+\n+            // Apply permutations to b\n+            for (int row = 0; row < m; row++) {\n+                bp[row] = b.getEntry(pivot[row]);\n+            }\n+\n+            // Solve LY = b\n+            for (int col = 0; col < m; col++) {\n+                for (int i = col + 1; i < m; i++) {\n+                    bp[i] -= bp[col] * lu[i][col];\n+                }\n+            }\n+\n+            // Solve UX = Y\n+            for (int col = m - 1; col >= 0; col--) {\n+                bp[col] /= lu[col][col];\n+                for (int i = 0; i < col; i++) {\n+                    bp[i] -= bp[col] * lu[i][col];\n+                }\n+            }\n+\n+            return new RealVectorImpl(bp, false);\n+\n+        }\n+    }\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It is </p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X such that A &times; X = B\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealVectorImpl solve(RealVectorImpl b)\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+        return new RealVectorImpl(solve(b.getDataRef()), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix solve(RealMatrix b)\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+\n+        checkDecomposed();\n+        final int m = pivot.length;\n+        if (b.getRowDimension() != m) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+        if (singular) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        final int nColB = b.getColumnDimension();\n+\n+        // Apply permutations to b\n+        final double[][] bp = new double[m][nColB];\n+        for (int row = 0; row < m; row++) {\n+            final double[] bpRow = bp[row];\n+            final int pRow = pivot[row];\n+            for (int col = 0; col < nColB; col++) {\n+                bpRow[col] = b.getEntry(pRow, col);\n+            }\n+        }\n+\n+        // Solve LY = b\n+        for (int col = 0; col < m; col++) {\n+            final double[] bpCol = bp[col];\n+            for (int i = col + 1; i < m; i++) {\n+                final double[] bpI = bp[i];\n+                final double luICol = lu[i][col];\n+                for (int j = 0; j < nColB; j++) {\n+                    bpI[j] -= bpCol[j] * luICol;\n+                }\n+            }\n+        }\n+\n+        // Solve UX = Y\n+        for (int col = m - 1; col >= 0; col--) {\n+            final double[] bpCol = bp[col];\n+            final double luDiag = lu[col][col];\n+            for (int j = 0; j < nColB; j++) {\n+                bpCol[j] /= luDiag;\n+            }\n+            for (int i = 0; i < col; i++) {\n+                final double[] bpI = bp[i];\n+                final double luICol = lu[i][col];\n+                for (int j = 0; j < nColB; j++) {\n+                    bpI[j] -= bpCol[j] * luICol;\n+                }\n+            }\n+        }\n+\n+        return new RealMatrixImpl(bp, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getInverse()\n+        throws IllegalStateException, InvalidMatrixException {\n+        checkDecomposed();\n+        return solve(MatrixUtils.createRealIdentityMatrix(pivot.length));\n+    }\n+\n+    /**\n+     * Check if either {@link #decompose(RealMatrix)} or {@link\n+     * #decompose(RealMatrix, double) has been called.\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n+     */\n+    private void checkDecomposed()\n+        throws IllegalStateException {\n+        if (lu == null) {\n+            throw MathRuntimeException.createIllegalStateException(\"no matrix have been decomposed yet\", null);\n+        }\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/MatrixIndexException.java\n+++ b/src/java/org/apache/commons/math/linear/MatrixIndexException.java\n \n package org.apache.commons.math.linear;\n \n+import org.apache.commons.math.MathRuntimeException;\n+\n /**\n- * Thrown when an operation addresses a matrix coordinate (row,col)\n+ * Thrown when an operation addresses a matrix coordinate (row, col)\n  * which is outside of the dimensions of a matrix.\n  * @version $Revision$ $Date$\n  */\n-public class MatrixIndexException extends RuntimeException {\n+public class MatrixIndexException extends MathRuntimeException {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -1341109412864309526L;\n+    private static final long serialVersionUID = -2382324504109300625L;\n \n     /**\n-     * Default constructor.\n-     * @deprecated as of 1.2 replaced by #MatrixIndexException(String)\n+     * Constructs a new instance with specified formatted detail message.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n      */\n-    public MatrixIndexException() {\n-        this(null);\n-    }\n-\n-    /**\n-     * Construct an exception with the given message and root cause.\n-     * @param message descriptive error message.\n-     */\n-    public MatrixIndexException(String message) {\n-        super(message);\n+    public MatrixIndexException(final String pattern, final Object[] arguments) {\n+      super(pattern, arguments);\n     }\n \n }\n--- a/src/java/org/apache/commons/math/linear/MatrixUtils.java\n+++ b/src/java/org/apache/commons/math/linear/MatrixUtils.java\n package org.apache.commons.math.linear;\n \n import java.math.BigDecimal;\n+import java.util.Arrays;\n \n /**\n  * A collection of static methods that operate on or return matrices.\n      * @return  RealMatrix containing the values of the array\n      * @throws IllegalArgumentException if <code>data</code> is not rectangular\n      *  (not all rows have the same length) or empty\n-     * @throws NullPointerException if data is null\n+     * @throws NullPointerException if <code>data</code> is null\n+     * @see #createRealMatrix(double[][], boolean)\n      */\n     public static RealMatrix createRealMatrix(double[][] data) {\n         return new RealMatrixImpl(data);\n     }\n-    \n+\n+    /**\n+     * Returns a {@link RealMatrix} whose entries are the the values in the\n+     * the input array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * RealMatrix and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param data data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @return  RealMatrix containing the values of the array\n+     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>data</code> is null\n+     * @see #createRealMatrix(double[][])\n+     */\n+    public static RealMatrix createRealMatrix(double[][] data, boolean copyArray) {\n+        return new RealMatrixImpl(data, copyArray);\n+    }\n+\n     /**\n      * Returns <code>dimension x dimension</code> identity matrix.\n      *\n      * @since 1.1\n      */\n     public static RealMatrix createRealIdentityMatrix(int dimension) {\n-        RealMatrixImpl out = new RealMatrixImpl(dimension, dimension);\n-        double[][] d = out.getDataRef();\n+        double[][] d = new double[dimension][dimension];\n         for (int row = 0; row < dimension; row++) {\n-            for (int col = 0; col < dimension; col++) {\n-                d[row][col] = row == col ? 1d : 0d;\n-            }\n-        }\n-        return out;\n+            d[row][row] = 1d;\n+        }\n+        return new RealMatrixImpl(d, false);\n     }\n     \n     /**\n     public static BigMatrix createBigMatrix(BigDecimal[][] data) {\n         return new BigMatrixImpl(data);\n     }\n-    \n+\n+    /**\n+     * Returns a {@link BigMatrix} whose entries are the the values in the\n+     * the input array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * BigMatrix and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param data data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @return  BigMatrix containing the values of the array\n+     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>data</code> is null\n+     * @see #createRealMatrix(double[][])\n+     */\n+    public static BigMatrix createBigMatrix(BigDecimal[][] data, boolean copyArray) {\n+        return new BigMatrixImpl(data, copyArray);\n+    }\n+\n     /**\n      * Returns a {@link BigMatrix} whose entries are the the values in the\n      * the input array.  The input array is copied, not referenced.\n      */\n     public static BigMatrix createBigMatrix(String[][] data) {\n         return new BigMatrixImpl(data);\n+    }\n+    \n+    /**\n+     * Creates a {@link RealVector} using the data from the input array. \n+     * \n+     * @param data the input data\n+     * @return a data.length RealVector\n+     * @throws IllegalArgumentException if <code>data</code> is empty\n+     * @throws NullPointerException if <code>data</code>is null\n+     */\n+    public static RealVector createRealVector(double[] data) {\n+        return new RealVectorImpl(data, true);\n     }\n     \n     /**\n      * @throws NullPointerException if <code>rowData</code>is null\n      */\n     public static RealMatrix createRowRealMatrix(double[] rowData) {\n-        int nCols = rowData.length;\n-        double[][] data = new double[1][nCols];\n+        final int nCols = rowData.length;\n+        final double[][] data = new double[1][nCols];\n         System.arraycopy(rowData, 0, data[0], 0, nCols);\n-        return new RealMatrixImpl(data);\n+        return new RealMatrixImpl(data, false);\n     }\n     \n     /**\n      * @throws NullPointerException if <code>rowData</code>is null\n      */\n     public static BigMatrix createRowBigMatrix(double[] rowData) {\n-        int nCols = rowData.length;\n-        double[][] data = new double[1][nCols];\n-        System.arraycopy(rowData, 0, data[0], 0, nCols);\n-        return new BigMatrixImpl(data);\n+        final int nCols = rowData.length;\n+        final BigDecimal[][] data = new BigDecimal[1][nCols];\n+        for (int i = 0; i < nCols; ++i) {\n+            data[0][i] = new BigDecimal(rowData[i]);\n+        }\n+        return new BigMatrixImpl(data, false);\n     }\n     \n     /**\n      * @throws NullPointerException if <code>rowData</code>is null\n      */\n     public static BigMatrix createRowBigMatrix(BigDecimal[] rowData) {\n-        int nCols = rowData.length;\n-        BigDecimal[][] data = new BigDecimal[1][nCols];\n+        final int nCols = rowData.length;\n+        final BigDecimal[][] data = new BigDecimal[1][nCols];\n         System.arraycopy(rowData, 0, data[0], 0, nCols);\n-        return new BigMatrixImpl(data);\n+        return new BigMatrixImpl(data, false);\n     }\n     \n     /**\n      * @throws NullPointerException if <code>rowData</code>is null\n      */\n     public static BigMatrix createRowBigMatrix(String[] rowData) {\n-        int nCols = rowData.length;\n-        String[][] data = new String[1][nCols];\n-        System.arraycopy(rowData, 0, data[0], 0, nCols);\n-        return new BigMatrixImpl(data);\n+        final int nCols = rowData.length;\n+        final BigDecimal[][] data = new BigDecimal[1][nCols];\n+        for (int i = 0; i < nCols; ++i) {\n+            data[0][i] = new BigDecimal(rowData[i]);\n+        }\n+        return new BigMatrixImpl(data, false);\n     }\n     \n     /**\n      * @throws NullPointerException if <code>columnData</code>is null\n      */\n     public static RealMatrix createColumnRealMatrix(double[] columnData) {\n-        int nRows = columnData.length;\n-        double[][] data = new double[nRows][1];\n+        final int nRows = columnData.length;\n+        final double[][] data = new double[nRows][1];\n         for (int row = 0; row < nRows; row++) {\n             data[row][0] = columnData[row];\n         }\n-        return new RealMatrixImpl(data);\n+        return new RealMatrixImpl(data, false);\n     }\n     \n     /**\n      * @throws NullPointerException if <code>columnData</code>is null\n      */\n     public static BigMatrix createColumnBigMatrix(double[] columnData) {\n-        int nRows = columnData.length;\n-        double[][] data = new double[nRows][1];\n+        final int nRows = columnData.length;\n+        final BigDecimal[][] data = new BigDecimal[nRows][1];\n         for (int row = 0; row < nRows; row++) {\n-            data[row][0] = columnData[row];\n-        }\n-        return new BigMatrixImpl(data);\n+            data[row][0] = new BigDecimal(columnData[row]);\n+        }\n+        return new BigMatrixImpl(data, false);\n     }\n     \n     /**\n      * @throws NullPointerException if <code>columnData</code>is null\n      */\n     public static BigMatrix createColumnBigMatrix(BigDecimal[] columnData) {\n-        int nRows = columnData.length;\n-        BigDecimal[][] data = new BigDecimal[nRows][1];\n+        final int nRows = columnData.length;\n+        final BigDecimal[][] data = new BigDecimal[nRows][1];\n         for (int row = 0; row < nRows; row++) {\n             data[row][0] = columnData[row];\n         }\n-        return new BigMatrixImpl(data);\n+        return new BigMatrixImpl(data, false);\n     }\n     \n     /**\n      */\n     public static BigMatrix createColumnBigMatrix(String[] columnData) {\n         int nRows = columnData.length;\n-        String[][] data = new String[nRows][1];\n+        final BigDecimal[][] data = new BigDecimal[nRows][1];\n         for (int row = 0; row < nRows; row++) {\n-            data[row][0] = columnData[row];\n-        }\n-        return new BigMatrixImpl(data);\n+            data[row][0] = new BigDecimal(columnData[row]);\n+        }\n+        return new BigMatrixImpl(data, false);\n     }\n     \n     /**\n      * @since 1.1\n      */\n     public static BigMatrix createBigIdentityMatrix(int dimension) {\n-        BigMatrixImpl out = new BigMatrixImpl(dimension, dimension);\n-        BigDecimal[][] d = out.getDataRef();\n+        final BigDecimal[][] d = new BigDecimal[dimension][dimension];\n         for (int row = 0; row < dimension; row++) {\n-            for (int col = 0; col < dimension; col++) {\n-                d[row][col] = row == col ? BigMatrixImpl.ONE : BigMatrixImpl.ZERO;\n-            }\n-        }\n-        return out;\n+            final BigDecimal[] dRow = d[row];\n+            Arrays.fill(dRow, BigMatrixImpl.ZERO);\n+            dRow[row] = BigMatrixImpl.ONE;\n+        }\n+        return new BigMatrixImpl(d, false);\n     }\n     \n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/NonSquareMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Thrown when an operation defined only for square matrices is applied to non-square ones.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class NonSquareMatrixException extends InvalidMatrixException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 8996207526636673730L;\n+\n+    /**\n+     * Construct an exception with the given message.\n+     * @param rows number of rows of the faulty matrix\n+     * @param columns number of columns of the faulty matrix\n+     */\n+    public NonSquareMatrixException(final int rows, final int columns) {\n+        super(\"a {0}x{1} matrix was provided instead of a square matrix\",\n+              new Object[] { rows, columns });\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/QRDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecomposition.java\n package org.apache.commons.math.linear;\n \n /**\n- * An interface to classes that implement a algorithm to calculate the \n+ * An interface to classes that implement an algorithm to calculate the \n  * QR-decomposition of a real matrix.\n+ * <p>This interface is based on the class with similar name from the now defunct\n+ * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n+ * following changes:</p>\n+ * <ul>\n+ *   <li>several signatures have been added for the <code>solve</code> methods\n+ *   (in the superinterface),</li>\n+ *   <li>a {@link DecompositionSolver#decompose(RealMatrix) decompose(RealMatrix)}\n+ *   method has been added (in the superinterface),</li>\n+ *   <li>a {@link DecompositionSolver#getInverse() getInverse} method has been\n+ *   added (in the superinterface),</li>\n+ *   <li>the <code>isFullRank</code> method has been replaced by the {@link\n+ *   DecompositionSolver#isNonSingular() isNonSingular} method in the superinterface.</li>\n+ * </ul>\n  *   \n  * @see <a href=\"http://mathworld.wolfram.com/QRDecomposition.html\">MathWorld</a>\n  * @see <a href=\"http://en.wikipedia.org/wiki/QR_decomposition\">Wikipedia</a>\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n-public interface QRDecomposition {\n+public interface QRDecomposition extends DecompositionSolver {\n \n     /**\n      * Returns the matrix R of the decomposition. \n-     * \n+     * <p>R is an upper-triangular matrix</p>\n      * @return the R matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    public abstract RealMatrix getR();\n+    RealMatrix getR() throws IllegalStateException;\n \n     /**\n      * Returns the matrix Q of the decomposition.\n-     * \n+     * <p>Q is an orthogonal matrix</p>\n      * @return the Q matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    public abstract RealMatrix getQ();\n+    RealMatrix getQ() throws IllegalStateException;\n+\n+    /**\n+     * Returns the transpose of the matrix Q of the decomposition.\n+     * <p>Q is an orthogonal matrix</p>\n+     * @return the Q matrix\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     */\n+    RealMatrix getQT() throws IllegalStateException;\n+\n+    /**\n+     * Returns the Householder reflector vectors.\n+     * <p>H is a lower trapezoidal matrix whose columns represent\n+     * each successive Householder reflector vector. This matrix is used\n+     * to compute Q.</p>\n+     * @return a matrix containing the Householder reflector vectors\n+     * @exception IllegalStateException if {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n+     */\n+    RealMatrix getH() throws IllegalStateException;\n+\n }\n--- a/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n \n package org.apache.commons.math.linear;\n \n+import org.apache.commons.math.MathRuntimeException;\n+\n /**\n- * Calculates the QR-decomposition of a matrix. In the QR-decomposition of\n- * a matrix A consists of two matrices Q and R that satisfy: A = QR, Q is\n- * orthogonal (Q<sup>T</sup>Q = I), and R is upper triangular. If A is\n- * m&times;n, Q is m&times;m and R m&times;n. \n- * <p>\n- * Implemented using Householder reflectors.</p>\n+ * Calculates the QR-decomposition of a matrix.\n+ * <p>The QR-decomposition of a matrix A consists of two matrices Q and R\n+ * that satisfy: A = QR, Q is orthogonal (Q<sup>T</sup>Q = I), and R is\n+ * upper triangular. If A is m&times;n, Q is m&times;m and R m&times;n.</p>\n+ * <p>This class compute the decomposition using Householder reflectors.</p>\n+ * <p>For efficiency purposes, the decomposition in packed form is transposed.\n+ * This allows inner loop to iterate inside rows, which is much more cache-efficient\n+ * in Java.</p>\n  *\n  * @see <a href=\"http://mathworld.wolfram.com/QRDecomposition.html\">MathWorld</a>\n  * @see <a href=\"http://en.wikipedia.org/wiki/QR_decomposition\">Wikipedia</a>\n- * \n+ *\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n public class QRDecompositionImpl implements QRDecomposition {\n \n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -5179446891802932307L;\n+\n     /**\n-     * A packed representation of the QR decomposition. The elements above the \n-     * diagonal are the elements of R, and the columns of the lower triangle \n-     * are the Householder reflector vectors of which an explicit form of Q can\n-     * be calculated. \n+     * A packed TRANSPOSED representation of the QR decomposition.\n+     * <p>The elements BELOW the diagonal are the elements of the UPPER triangular\n+     * matrix R, and the rows ABOVE the diagonal are the Householder reflector vectors\n+     * from which an explicit form of Q can be recomputed if desired.</p>\n      */\n-    private double[][] qr;\n+    private double[][] qrt;\n+\n+    /** The diagonal elements of R. */\n+    private double[] rDiag;\n+\n+    /** Cached value of Q. */\n+    private RealMatrix cachedQ;\n+\n+    /** Cached value of QT. */\n+    private RealMatrix cachedQT;\n+\n+    /** Cached value of R. */\n+    private RealMatrix cachedR;\n+\n+    /** Cached value of H. */\n+    private RealMatrix cachedH;\n \n     /**\n-     * The diagonal elements of R.\n+     * Build a new instance.\n+     * <p>Note that {@link #decompose(RealMatrix)} <strong>must</strong> be called\n+     * before any of the {@link #getQ()}, {@link #getR()}, {@link #getH()},\n+     * {@link #isFullRank()}, {@link #solve(double[])}, {@link #solve(RealMatrix)},\n+     * {@link #solve(RealVector)} or {@link #solve(RealVectorImpl)} methods can be\n+     * called.</p>\n+     * @see #decompose(RealMatrix)\n      */\n-    private double[] rDiag;\n+    public QRDecompositionImpl() {\n+    }\n \n     /**\n-     * The row dimension of the given matrix. The size of Q will be m x m, the \n-     * size of R will be m x n. \n-     */\n-    private int m;\n-\n-    /**\n-     * The column dimension of the given matrix. The size of R will be m x n. \n-     */\n-    private int n;\n-\n-    /**\n-     * Calculates the QR decomposition of the given matrix. \n-     * \n+     * Calculates the QR-decomposition of the given matrix. \n+     * <p>Calling this constructor is equivalent to first call the no-arguments\n+     * constructor and then call {@link #decompose(RealMatrix)}.</p>\n      * @param matrix The matrix to decompose.\n      */\n     public QRDecompositionImpl(RealMatrix matrix) {\n-        m = matrix.getRowDimension();\n-        n = matrix.getColumnDimension();\n-        qr = matrix.getData();\n+        decompose(matrix);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void decompose(RealMatrix matrix) {\n+\n+        final int m = matrix.getRowDimension();\n+        final int n = matrix.getColumnDimension();\n+        qrt = matrix.transpose().getData();\n         rDiag = new double[n];\n+        cachedQ  = null;\n+        cachedQT = null;\n+        cachedR  = null;\n+        cachedH  = null;\n \n         /*\n          * The QR decomposition of a matrix A is calculated using Householder\n          * A(minor,minor) of A:\n          */\n         for (int minor = 0; minor < Math.min(m, n); minor++) {\n+\n+            final double[] qrtMinor = qrt[minor];\n+\n             /*\n              * Let x be the first column of the minor, and a^2 = |x|^2.\n              * x will be in the positions qr[minor][minor] through qr[m][minor].\n              */\n             double xNormSqr = 0;\n             for (int row = minor; row < m; row++) {\n-                xNormSqr += qr[row][minor]*qr[row][minor];\n-            }\n-            double a = Math.sqrt(xNormSqr);\n-            if (qr[minor][minor] > 0) a = -a;\n+                final double c = qrtMinor[row];\n+                xNormSqr += c * c;\n+            }\n+            final double a = (qrtMinor[minor] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n             rDiag[minor] = a;\n \n             if (a != 0.0) {\n                  * Here <x, e> is now qr[minor][minor].\n                  * v = x-ae is stored in the column at qr:\n                  */\n-                qr[minor][minor] -= a; // now |v|^2 = -2a*(qr[minor][minor])\n+                qrtMinor[minor] -= a; // now |v|^2 = -2a*(qr[minor][minor])\n \n                 /*\n                  * Transform the rest of the columns of the minor:\n                  * Hx = (I-2vv'/|v|^2)x = x-2vv'x/|v|^2 = x - 2<x,v>/|v|^2 v.\n                  * Therefore the transformation is easily calculated by\n                  * subtracting the column vector (2<x,v>/|v|^2)v from x.\n-                 * \n+                 *\n                  * Let 2<x,v>/|v|^2 = alpha. From above we have\n                  * |v|^2 = -2a*(qr[minor][minor]), so\n                  * alpha = -<x,v>/(a*qr[minor][minor])\n                  */\n                 for (int col = minor+1; col < n; col++) {\n+                    final double[] qrtCol = qrt[col];\n                     double alpha = 0;\n                     for (int row = minor; row < m; row++) {\n-                        alpha -= qr[row][col]*qr[row][minor];\n+                        alpha -= qrtCol[row] * qrtMinor[row];\n                     }\n-                    alpha /= a*qr[minor][minor];\n+                    alpha /= a * qrtMinor[minor];\n \n                     // Subtract the column vector alpha*v from x.\n                     for (int row = minor; row < m; row++) {\n-                        qr[row][col] -= alpha*qr[row][minor];\n+                        qrtCol[row] -= alpha * qrtMinor[row];\n                     }\n                 }\n             }\n         }\n     }\n \n+    /** {@inheritDoc} */\n+    public RealMatrix getR()\n+        throws IllegalStateException {\n+\n+        if (cachedR == null) {\n+\n+            checkDecomposed();\n+\n+            // R is supposed to be m x n\n+            final int n = qrt.length;\n+            final int m = qrt[0].length;\n+            double[][] r = new double[m][n];\n+\n+            // copy the diagonal from rDiag and the upper triangle of qr\n+            for (int row = Math.min(m, n) - 1; row >= 0; row--) {\n+                double[] rRow = r[row];\n+                rRow[row] = rDiag[row];\n+                for (int col = row + 1; col < n; col++) {\n+                    rRow[col] = qrt[col][row];\n+                }\n+            }\n+\n+            // cache the matrix for subsequent calls\n+            cachedR = new RealMatrixImpl(r, false);\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedR;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getQ()\n+        throws IllegalStateException {\n+        if (cachedQ == null) {\n+            cachedQ = getQT().transpose();\n+        }\n+        return cachedQ;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getQT()\n+        throws IllegalStateException {\n+\n+        if (cachedQT == null) {\n+\n+            checkDecomposed();\n+\n+            // QT is supposed to be m x m\n+            final int n = qrt.length;\n+            final int m = qrt[0].length;\n+            double[][] qT = new double[m][m];\n+\n+            /* \n+             * Q = Q1 Q2 ... Q_m, so Q is formed by first constructing Q_m and then \n+             * applying the Householder transformations Q_(m-1),Q_(m-2),...,Q1 in \n+             * succession to the result \n+             */ \n+            for (int minor = m - 1; minor >= Math.min(m, n); minor--) {\n+                qT[minor][minor]=1;\n+            }\n+\n+            for (int minor = Math.min(m,n)-1; minor >= 0; minor--){\n+                final double[] qrtMinor = qrt[minor];\n+                qT[minor][minor] = 1;\n+                if (qrtMinor[minor] != 0.0) {\n+                    for (int col = minor; col < m; col++) {\n+                        final double[] qTCol = qT[col];\n+                        double alpha = 0;\n+                        for (int row = minor; row < m; row++) {\n+                            alpha -= qTCol[row] * qrtMinor[row];\n+                        }\n+                        alpha /= rDiag[minor] * qrtMinor[minor];\n+\n+                        for (int row = minor; row < m; row++) {\n+                            qTCol[row] -= alpha * qrtMinor[row];\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // cache the matrix for subsequent calls\n+            cachedQT = new RealMatrixImpl(qT, false);\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedQT;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getH()\n+        throws IllegalStateException {\n+\n+        if (cachedH == null) {\n+\n+            checkDecomposed();\n+\n+            final int n = qrt.length;\n+            final int m = qrt[0].length;\n+            double[][] hData = new double[m][n];\n+            for (int i = 0; i < m; ++i) {\n+                final double[] hDataI = hData[i];\n+                for (int j = 0; j < Math.min(i + 1, n); ++j) {\n+                    hDataI[j] = qrt[j][i] / -rDiag[j];\n+                }\n+            }\n+\n+            // cache the matrix for subsequent calls\n+            cachedH = new RealMatrixImpl(hData, false);\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedH;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isNonSingular()\n+        throws IllegalStateException {\n+\n+        checkDecomposed();\n+\n+        for (double diag : rDiag) {\n+            if (diag == 0) {\n+                return false;\n+            }\n+        }\n+        return true;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] solve(double[] b)\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+ \n+        checkDecomposed();\n+\n+        final int n = qrt.length;\n+        final int m = qrt[0].length;\n+        if (b.length != m) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+        if (!isNonSingular()) {\n+            throw new RankDeficientMatrixException();\n+        }\n+\n+        final double[] x = new double[n];\n+        final double[] y = b.clone();\n+\n+        // apply Householder transforms to solve Q.y = b\n+        for (int minor = 0; minor < Math.min(m, n); minor++) {\n+\n+            final double[] qrtMinor = qrt[minor];\n+            double dotProduct = 0;\n+            for (int row = minor; row < m; row++) {\n+                dotProduct += y[row] * qrtMinor[row];\n+            }\n+            dotProduct /= rDiag[minor] * qrtMinor[minor];\n+\n+            for (int row = minor; row < m; row++) {\n+                y[row] += dotProduct * qrtMinor[row];\n+            }\n+\n+        }\n+\n+        // solve triangular system R.x = y\n+        for (int row = n - 1; row >= 0; --row) {\n+            y[row] /= rDiag[row];\n+            final double yRow   = y[row];\n+            final double[] qrtRow = qrt[row];\n+            x[row] = yRow;\n+            for (int i = 0; i < row; i++) {\n+                y[i] -= yRow * qrtRow[i];\n+            }\n+        }\n+\n+        return x;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector solve(RealVector b)\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+        try {\n+            return solve((RealVectorImpl) b);\n+        } catch (ClassCastException cce) {\n+            checkDecomposed();\n+            return new RealVectorImpl(solve(b.getData()), false);\n+        }\n+    }\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It is </p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n+     * @throws IllegalArgumentException if matrices dimensions don't match\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealVectorImpl solve(RealVectorImpl b)\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+        return new RealVectorImpl(solve(b.getDataRef()), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix solve(RealMatrix b)\n+        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n+\n+        checkDecomposed();\n+\n+        final int n = qrt.length;\n+        final int m = qrt[0].length;\n+        if (b.getRowDimension() != m) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+        if (!isNonSingular()) {\n+            throw new RankDeficientMatrixException();\n+        }\n+\n+        final int cols = b.getColumnDimension();\n+        final double[][] xData = new double[n][cols];\n+        final double[] y = new double[b.getRowDimension()];\n+\n+        for (int k = 0; k < cols; ++k) {\n+\n+            // get the right hand side vector\n+            for (int j = 0; j < y.length; ++j) {\n+                y[j] = b.getEntry(j, k);\n+            }\n+\n+            // apply Householder transforms to solve Q.y = b\n+            for (int minor = 0; minor < Math.min(m, n); minor++) {\n+\n+                final double[] qrtMinor = qrt[minor];\n+                double dotProduct = 0;\n+                for (int row = minor; row < m; row++) {\n+                    dotProduct += y[row] * qrtMinor[row];\n+                }\n+                dotProduct /= rDiag[minor] * qrtMinor[minor];\n+\n+                for (int row = minor; row < m; row++) {\n+                    y[row] += dotProduct * qrtMinor[row];\n+                }\n+\n+            }\n+\n+            // solve triangular system R.x = y\n+            for (int row = n - 1; row >= 0; --row) {\n+                y[row] /= rDiag[row];\n+                final double yRow = y[row];\n+                final double[] qrtRow = qrt[row];\n+                xData[row][k] = yRow;\n+                for (int i = 0; i < row; i++) {\n+                   y[i] -= yRow * qrtRow[i];\n+                }\n+             }\n+\n+        }\n+\n+        return new RealMatrixImpl(xData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getInverse()\n+        throws IllegalStateException, InvalidMatrixException {\n+        checkDecomposed();\n+        return solve(MatrixUtils.createRealIdentityMatrix(rDiag.length));\n+    }\n+\n     /**\n-     * Returns the matrix R of the QR-decomposition. \n-     * \n-     * @return the R matrix\n+     * Check if {@link #decompose(RealMatrix)} has been called.\n+     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n+     * has not been called\n      */\n-    public RealMatrix getR()\n-    {\n-        // R is supposed to be m x n\n-        RealMatrixImpl ret = new RealMatrixImpl(m,n);\n-        double[][] r = ret.getDataRef();\n-\n-        // copy the diagonal from rDiag and the upper triangle of qr\n-        for (int row = Math.min(m,n)-1; row >= 0; row--) {\n-            r[row][row] = rDiag[row];\n-            for (int col = row+1; col < n; col++) {\n-                r[row][col] = qr[row][col];\n-            }\n-        }\n-        return ret;\n-    }\n-\n-    /**\n-     * Returns the matrix Q of the QR-decomposition.\n-     * \n-     * @return the Q matrix\n-     */\n-    public RealMatrix getQ()\n-    {\n-        // Q is supposed to be m x m\n-        RealMatrixImpl ret = new RealMatrixImpl(m,m);\n-        double[][] Q = ret.getDataRef();\n-\n-        /* \n-         * Q = Q1 Q2 ... Q_m, so Q is formed by first constructing Q_m and then \n-         * applying the Householder transformations Q_(m-1),Q_(m-2),...,Q1 in \n-         * succession to the result \n-         */ \n-        for (int minor = m-1; minor >= Math.min(m,n); minor--) {\n-            Q[minor][minor]=1;\n-        }\n-\n-        for (int minor = Math.min(m,n)-1; minor >= 0; minor--){\n-            Q[minor][minor] = 1;\n-            if (qr[minor][minor] != 0.0) {\n-                for (int col = minor; col < m; col++) {\n-                    double alpha = 0;\n-                    for (int row = minor; row < m; row++) {\n-                        alpha -= Q[row][col] * qr[row][minor];\n-                    }\n-                    alpha /= rDiag[minor]*qr[minor][minor];\n-\n-                    for (int row = minor; row < m; row++) {\n-                        Q[row][col] -= alpha*qr[row][minor];\n-                    }\n-                }\n-            }\n-        }\n-\n-        return ret;\n-    }\n+    private void checkDecomposed()\n+        throws IllegalStateException {\n+        if (qrt == null) {\n+            throw MathRuntimeException.createIllegalStateException(\"no matrix have been decomposed yet\", null);\n+        }\n+    }\n+\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/RankDeficientMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Thrown when a matrix is singular.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class RankDeficientMatrixException extends InvalidMatrixException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 7051890448195709736L;\n+\n+    /**\n+     * Construct an exception with a default message.\n+     */\n+    public RankDeficientMatrixException() {\n+        super(\"matrix is rank-deficient\", null);\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrix.java\n     * @throws MatrixIndexException if the specified column index is invalid\n     */\n    RealMatrix getColumnMatrix(int column) throws MatrixIndexException;\n+\n+   /**\n+    * Returns the entries in row number <code>row</code>\n+    * as a vector.  Row indices start at 0.\n+    *\n+    * @param row the row to be fetched\n+    * @return row vector\n+    * @throws MatrixIndexException if the specified row index is invalid\n+    */\n+   RealVector getRowVector(int row) throws MatrixIndexException;\n+   \n+   /**\n+    * Returns the entries in column number <code>column</code>\n+    * as a column vector.  Column indices start at 0.\n+    *\n+    * @param column the column to be fetched\n+    * @return column vector\n+    * @throws MatrixIndexException if the specified column index is invalid\n+    */\n+   RealVector getColumnVector(int column) throws MatrixIndexException;\n     \n     /**\n      * Returns the entries in row number <code>row</code> as an array.\n      *\n      * @return inverse matrix\n      * @throws InvalidMatrixException if  this is not invertible\n-     */\n+     * @deprecated as of release 2.0, replaced by {@link DecompositionSolver#getInverse()}\n+     */\n+    @Deprecated\n     RealMatrix inverse() throws InvalidMatrixException;\n \n     /**\n      * Returns the determinant of this matrix.\n      *\n      * @return determinant\n-     */\n+     * @deprecated as of release 2.0, replaced by {@link LUDecomposition#getDeterminant()}\n+     */\n+    @Deprecated\n     double getDeterminant();\n \n     /**\n     /**\n      * Is this a singular matrix?\n      * @return true if the matrix is singular\n-     */\n+     * @deprecated as of release 2.0, replaced by the boolean negation of\n+     * {@link DecompositionSolver#isNonSingular()}\n+     */\n+    @Deprecated\n     boolean isSingular();\n \n     /**\n     double[] operate(double[] v) throws IllegalArgumentException;\n \n     /**\n+     * Returns the result of multiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the vector to operate on\n+     * @return this*v\n+     * @throws IllegalArgumentException if columnDimension != v.size()\n+     */\n+    RealVector operate(RealVector v) throws IllegalArgumentException;\n+\n+    /**\n      * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n      *\n      * @param v the row vector to premultiply by\n      * @throws IllegalArgumentException if rowDimension != v.size()\n      */\n     double[] preMultiply(double[] v) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the row vector to premultiply by\n+     * @return v*this\n+     * @throws IllegalArgumentException if rowDimension != v.size()\n+     */\n+    RealVector preMultiply(RealVector v) throws IllegalArgumentException;\n \n     /**\n      * Returns the solution vector for a linear system with coefficient\n      * @return vector of solution values to AX = b, where A is *this\n      * @throws IllegalArgumentException if this.rowDimension != b.length\n      * @throws InvalidMatrixException if this matrix is not square or is singular\n-     */\n+     * @deprecated as of release 2.0, replaced by {@link DecompositionSolver#solve(double[])}\n+     */\n+    @Deprecated\n     double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException;\n \n     /**\n      * @return matrix of solution vectors\n      * @throws IllegalArgumentException if this.rowDimension != row dimension\n      * @throws InvalidMatrixException if this matrix is not square or is singular\n-     */\n+     * @deprecated as of release 2.0, replaced by {@link DecompositionSolver#solve(RealMatrix)}\n+     */\n+    @Deprecated\n     RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException;\n+\n }\n-\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n package org.apache.commons.math.linear;\n \n import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.MathUtils;\n \n \n public class RealMatrixImpl implements RealMatrix, Serializable {\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 4237564493130426188L;\n+    private static final long serialVersionUID = 4970229902484487012L;\n \n     /** Entries of the matrix */\n-    private double data[][] = null;\n-\n-    /** Entries of cached LU decomposition.\n-     *  All updates to data (other than luDecompose()) *must* set this to null\n-     */\n-    private double lu[][] = null;\n-\n-    /** Permutation associated with LU decomposition */\n-    private int[] permutation = null;\n-\n-    /** Parity of the permutation associated with the LU decomposition */\n-    private int parity = 1;\n-\n-    /** Bound to determine effective singularity in LU decomposition */\n-    protected static double TOO_SMALL = 10E-12;\n+    protected double data[][];\n+\n+    /** Cached LU decomposition.\n+     * @deprecated as of release 2.0, since all methods using this are deprecated\n+     */\n+    private LUDecomposition lu;\n \n     /**\n      * Creates a matrix with no data\n     /**\n      * Create a new RealMatrix using the input array as the underlying\n      * data array.\n-     * <p>\n-     * The input array is copied, not referenced.</p>\n+     * <p>The input array is copied, not referenced. This constructor has\n+     * the same effect as calling {@link #RealMatrixImpl(double[][], boolean)}\n+     * with the second argument set to <code>true</code>.</p>\n      *\n      * @param d data for new matrix\n      * @throws IllegalArgumentException if <code>d</code> is not rectangular\n      *  (not all rows have the same length) or empty\n      * @throws NullPointerException if <code>d</code> is null\n+     * @see #RealMatrixImpl(double[][], boolean)\n      */\n     public RealMatrixImpl(double[][] d) {\n-        this.copyIn(d);\n+        copyIn(d);\n+        lu = null;\n+    }\n+\n+    /**\n+     * Create a new RealMatrix using the input array as the underlying\n+     * data array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * RealMatrix and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param d data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #RealMatrixImpl(double[][])\n+     */\n+    public RealMatrixImpl(double[][] d, boolean copyArray) {\n+        if (copyArray) {\n+            copyIn(d);\n+        } else {\n+            if (d == null) {\n+                throw new NullPointerException();\n+            }   \n+            final int nRows = d.length;\n+            if (nRows == 0) {\n+                throw new IllegalArgumentException(\"Matrix must have at least one row.\"); \n+            }\n+            final int nCols = d[0].length;\n+            if (nCols == 0) {\n+                throw new IllegalArgumentException(\"Matrix must have at least one column.\"); \n+            }\n+            for (int r = 1; r < nRows; r++) {\n+                if (d[r].length != nCols) {\n+                    throw new IllegalArgumentException(\"All input rows must have the same length.\");\n+                }\n+            }       \n+            data = d;\n+        }\n         lu = null;\n     }\n \n      * Create a new (column) RealMatrix using <code>v</code> as the\n      * data for the unique column of the <code>v.length x 1</code> matrix\n      * created.\n-     * <p>\n-     * The input array is copied, not referenced.</p>\n+     * <p>The input array is copied, not referenced.</p>\n      *\n      * @param v column vector holding data for new matrix\n      */\n     public RealMatrixImpl(double[] v) {\n-        int nRows = v.length;\n+        final int nRows = v.length;\n         data = new double[nRows][1];\n         for (int row = 0; row < nRows; row++) {\n             data[row][0] = v[row];\n         }\n     }\n \n-    /**\n-     * Create a new RealMatrix which is a copy of this.\n-     *\n-     * @return  the cloned matrix\n-     */\n+    /** {@inheritDoc} */\n     public RealMatrix copy() {\n-        return new RealMatrixImpl(this.copyOut());\n+        return new RealMatrixImpl(copyOut(), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix add(RealMatrix m) throws IllegalArgumentException {\n+        try {\n+            return add((RealMatrixImpl) m);\n+        } catch (ClassCastException cce) {\n+            final int rowCount    = getRowDimension();\n+            final int columnCount = getColumnDimension();\n+            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n+                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n+            }\n+            final double[][] outData = new double[rowCount][columnCount];\n+            for (int row = 0; row < rowCount; row++) {\n+                final double[] dataRow    = data[row];\n+                final double[] outDataRow = outData[row];\n+                for (int col = 0; col < columnCount; col++) {\n+                    outDataRow[col] = dataRow[col] + m.getEntry(row, col);\n+                }  \n+            }\n+            return new RealMatrixImpl(outData, false);\n+        }\n     }\n \n     /**\n      * @return     this + m\n      * @throws  IllegalArgumentException if m is not the same size as this\n      */\n-    public RealMatrix add(RealMatrix m) throws IllegalArgumentException {\n-        if (this.getColumnDimension() != m.getColumnDimension() ||\n-                this.getRowDimension() != m.getRowDimension()) {\n+    public RealMatrixImpl add(RealMatrixImpl m) throws IllegalArgumentException {\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n             throw new IllegalArgumentException(\"matrix dimension mismatch\");\n         }\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        double[][] outData = new double[rowCount][columnCount];\n+        final double[][] outData = new double[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n+            final double[] dataRow    = data[row];\n+            final double[] mRow       = m.data[row];\n+            final double[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col] + m.getEntry(row, col);\n+                outDataRow[col] = dataRow[col] + mRow[col];\n             }  \n         }\n-        return new RealMatrixImpl(outData);\n+        return new RealMatrixImpl(outData, false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix subtract(RealMatrix m) throws IllegalArgumentException {\n+        try {\n+            return subtract((RealMatrixImpl) m);\n+        } catch (ClassCastException cce) {\n+            final int rowCount    = getRowDimension();\n+            final int columnCount = getColumnDimension();\n+            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n+                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n+            }\n+            final double[][] outData = new double[rowCount][columnCount];\n+            for (int row = 0; row < rowCount; row++) {\n+                final double[] dataRow    = data[row];\n+                final double[] outDataRow = outData[row];\n+                for (int col = 0; col < columnCount; col++) {\n+                    outDataRow[col] = dataRow[col] - m.getEntry(row, col);\n+                }  \n+            }\n+            return new RealMatrixImpl(outData, false);\n+        }\n     }\n \n     /**\n      * @return     this + m\n      * @throws  IllegalArgumentException if m is not the same size as this\n      */\n-    public RealMatrix subtract(RealMatrix m) throws IllegalArgumentException {\n-        if (this.getColumnDimension() != m.getColumnDimension() ||\n-                this.getRowDimension() != m.getRowDimension()) {\n+    public RealMatrixImpl subtract(RealMatrixImpl m) throws IllegalArgumentException {\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n             throw new IllegalArgumentException(\"matrix dimension mismatch\");\n         }\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        double[][] outData = new double[rowCount][columnCount];\n+        final double[][] outData = new double[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n+            final double[] dataRow    = data[row];\n+            final double[] mRow       = m.data[row];\n+            final double[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col] - m.getEntry(row, col);\n-            }\n-        }\n-        return new RealMatrixImpl(outData);\n-    }\n-\n-    /**\n-     * Returns the result of adding d to each entry of this.\n-     *\n-     * @param d    value to be added to each entry\n-     * @return     d + this\n-     */\n+                outDataRow[col] = dataRow[col] - mRow[col];\n+            }  \n+        }\n+        return new RealMatrixImpl(outData, false);\n+    }\n+\n+    /** {@inheritDoc} */\n     public RealMatrix scalarAdd(double d) {\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        double[][] outData = new double[rowCount][columnCount];\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final double[][] outData = new double[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n+            final double[] dataRow    = data[row];\n+            final double[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col] + d;\n-            }\n-        }\n-        return new RealMatrixImpl(outData);\n-    }\n-\n-    /**\n-     * Returns the result multiplying each entry of this by <code>d</code>\n-     * @param d  value to multiply all entries by\n-     * @return d * this\n-     */\n+                outDataRow[col] = dataRow[col] + d;\n+            }\n+        }\n+        return new RealMatrixImpl(outData, false);\n+    }\n+\n+    /** {@inheritDoc} */\n     public RealMatrix scalarMultiply(double d) {\n-        int rowCount = this.getRowDimension();\n-        int columnCount = this.getColumnDimension();\n-        double[][] outData = new double[rowCount][columnCount];\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final double[][] outData = new double[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n+            final double[] dataRow    = data[row];\n+            final double[] outDataRow = outData[row];\n             for (int col = 0; col < columnCount; col++) {\n-                outData[row][col] = data[row][col] * d;\n-            }\n-        }\n-        return new RealMatrixImpl(outData);\n+                outDataRow[col] = dataRow[col] * d;\n+            }\n+        }\n+        return new RealMatrixImpl(outData, false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix multiply(RealMatrix m) throws IllegalArgumentException {\n+        try {\n+            return multiply((RealMatrixImpl) m);\n+        } catch (ClassCastException cce) {\n+            if (this.getColumnDimension() != m.getRowDimension()) {\n+                throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n+            }\n+            final int nRows = this.getRowDimension();\n+            final int nCols = m.getColumnDimension();\n+            final int nSum = this.getColumnDimension();\n+            final double[][] outData = new double[nRows][nCols];\n+            for (int row = 0; row < nRows; row++) {\n+                final double[] dataRow    = data[row];\n+                final double[] outDataRow = outData[row];\n+                for (int col = 0; col < nCols; col++) {\n+                    double sum = 0;\n+                    for (int i = 0; i < nSum; i++) {\n+                        sum += dataRow[i] * m.getEntry(i, col);\n+                    }\n+                    outDataRow[col] = sum;\n+                }\n+            }\n+            return new RealMatrixImpl(outData, false);\n+        }\n     }\n \n     /**\n      * @throws     IllegalArgumentException\n      *             if columnDimension(this) != rowDimension(m)\n      */\n-    public RealMatrix multiply(RealMatrix m) throws IllegalArgumentException {\n+    public RealMatrixImpl multiply(RealMatrixImpl m) throws IllegalArgumentException {\n         if (this.getColumnDimension() != m.getRowDimension()) {\n             throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n         }\n-        int nRows = this.getRowDimension();\n-        int nCols = m.getColumnDimension();\n-        int nSum = this.getColumnDimension();\n-        double[][] outData = new double[nRows][nCols];\n-        double sum = 0;\n+        final int nRows = this.getRowDimension();\n+        final int nCols = m.getColumnDimension();\n+        final int nSum = this.getColumnDimension();\n+        final double[][] outData = new double[nRows][nCols];\n         for (int row = 0; row < nRows; row++) {\n+            final double[] dataRow    = data[row];\n+            final double[] outDataRow = outData[row];\n             for (int col = 0; col < nCols; col++) {\n-                sum = 0;\n+                double sum = 0;\n                 for (int i = 0; i < nSum; i++) {\n-                    sum += data[row][i] * m.getEntry(i, col);\n+                    sum += dataRow[i] * m.data[i][col];\n                 }\n-                outData[row][col] = sum;\n-            }\n-        }\n-        return new RealMatrixImpl(outData);\n-    }\n-\n-    /**\n-     * Returns the result premultiplying this by <code>m</code>.\n-     * @param m    matrix to premultiply by\n-     * @return     m * this\n-     * @throws     IllegalArgumentException\n-     *             if rowDimension(this) != columnDimension(m)\n-     */\n+                outDataRow[col] = sum;\n+            }\n+        }            \n+        return new RealMatrixImpl(outData, false);\n+    }\n+\n+    /** {@inheritDoc} */\n     public RealMatrix preMultiply(RealMatrix m) throws IllegalArgumentException {\n         return m.multiply(this);\n     }\n \n-    /**\n-     * Returns matrix entries as a two-dimensional array.\n-     * <p>\n-     * Makes a fresh copy of the underlying data.</p>\n-     *\n-     * @return    2-dimensional array of entries\n-     */\n+    /** {@inheritDoc} */\n     public double[][] getData() {\n         return copyOut();\n     }\n     /**\n      * Returns a reference to the underlying data array.\n      * <p>\n-     * Does not make a fresh copy of the underlying data.</p>\n+     * Does <strong>not</strong> make a fresh copy of the underlying data.</p>\n      *\n      * @return 2-dimensional array of entries\n      */\n         return data;\n     }\n \n-    /**\n-     *\n-     * @return norm\n-     */\n+    /** {@inheritDoc} */\n     public double getNorm() {\n         double maxColSum = 0;\n         for (int col = 0; col < this.getColumnDimension(); col++) {\n         return maxColSum;\n     }\n     \n-    /**\n-     * Gets a submatrix. Rows and columns are indicated\n-     * counting from 0 to n-1.\n-     *\n-     * @param startRow Initial row index\n-     * @param endRow Final row index\n-     * @param startColumn Initial column index\n-     * @param endColumn Final column index\n-     * @return The subMatrix containing the data of the\n-     *         specified rows and columns\n-     * @exception MatrixIndexException if row or column selections are not valid\n-     */\n-    public RealMatrix getSubMatrix(int startRow, int endRow, int startColumn,\n-            int endColumn) throws MatrixIndexException {\n-        if (startRow < 0 || startRow > endRow || endRow > data.length ||\n-             startColumn < 0 || startColumn > endColumn ||\n-             endColumn > data[0].length ) {\n-            throw new MatrixIndexException(\n-                    \"invalid row or column index selection\");\n-        }\n-        RealMatrixImpl subMatrix = new RealMatrixImpl(endRow - startRow+1,\n-                endColumn - startColumn+1);\n-        double[][] subMatrixData = subMatrix.getDataRef();\n+    /** {@inheritDoc} */\n+    public RealMatrix getSubMatrix(int startRow, int endRow,\n+                                   int startColumn, int endColumn)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(startRow);\n+        checkRowIndex(endRow);\n+        if (startRow > endRow) {\n+            throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n+                                           new Object[] { startRow, endRow });\n+        }\n+\n+        checkColumnIndex(startColumn);\n+        checkColumnIndex(endColumn);\n+        if (startColumn > endColumn) {\n+            throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n+                                           new Object[] { startColumn, endColumn });\n+        }\n+\n+        final double[][] subMatrixData =\n+            new double[endRow - startRow + 1][endColumn - startColumn + 1];\n         for (int i = startRow; i <= endRow; i++) {\n-            for (int j = startColumn; j <= endColumn; j++) {\n-                    subMatrixData[i - startRow][j - startColumn] = data[i][j];\n-                }\n-            }\n-        return subMatrix;\n+            System.arraycopy(data[i], startColumn,\n+                             subMatrixData[i - startRow], 0,\n+                             endColumn - startColumn + 1);\n+        }\n+        return new RealMatrixImpl(subMatrixData, false);\n     }\n     \n-    /**\n-     * Gets a submatrix. Rows and columns are indicated\n-     * counting from 0 to n-1.\n-     *\n-     * @param selectedRows Array of row indices must be non-empty\n-     * @param selectedColumns Array of column indices must be non-empty\n-     * @return The subMatrix containing the data in the\n-     *     specified rows and columns\n-     * @exception MatrixIndexException  if supplied row or column index arrays\n-     *     are not valid\n-     */\n+    /** {@inheritDoc} */\n     public RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n-    throws MatrixIndexException {\n+        throws MatrixIndexException {\n+\n         if (selectedRows.length * selectedColumns.length == 0) {\n-            throw new MatrixIndexException(\n-                    \"selected row and column index arrays must be non-empty\");\n-        }\n-        RealMatrixImpl subMatrix = new RealMatrixImpl(selectedRows.length,\n-                selectedColumns.length);\n-        double[][] subMatrixData = subMatrix.getDataRef();\n+            if (selectedRows.length == 0) {\n+                throw new MatrixIndexException(\"empty selected row index array\", null);\n+            }\n+            throw new MatrixIndexException(\"empty selected column index array\", null);\n+        }\n+\n+        final double[][] subMatrixData =\n+            new double[selectedRows.length][selectedColumns.length];\n         try  {\n             for (int i = 0; i < selectedRows.length; i++) {\n+                final double[] subI = subMatrixData[i];\n+                final double[] dataSelectedI = data[selectedRows[i]];\n                 for (int j = 0; j < selectedColumns.length; j++) {\n-                    subMatrixData[i][j] = data[selectedRows[i]][selectedColumns[j]];\n+                    subI[j] = dataSelectedI[selectedColumns[j]];\n                 }\n             }\n-        }\n-        catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\"matrix dimension mismatch\");\n-        }\n-        return subMatrix;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            // we redo the loop with checks enabled\n+            // in order to generate an appropriate message\n+            for (final int row : selectedRows) {\n+                checkRowIndex(row);\n+            }\n+            for (final int column : selectedColumns) {\n+                checkColumnIndex(column);\n+            }\n+        }\n+        return new RealMatrixImpl(subMatrixData, false);\n     } \n \n     /**\n      */\n     public void setSubMatrix(double[][] subMatrix, int row, int column) \n         throws MatrixIndexException {\n-        if ((row < 0) || (column < 0)){\n-            throw new MatrixIndexException\n-                (\"invalid row or column index selection\");          \n-        }\n-        int nRows = subMatrix.length;\n+\n+        final int nRows = subMatrix.length;\n         if (nRows == 0) {\n-            throw new IllegalArgumentException(\n-            \"Matrix must have at least one row.\"); \n-        }\n-        int nCols = subMatrix[0].length;\n+            throw new IllegalArgumentException(\"Matrix must have at least one row.\"); \n+        }\n+\n+        final int nCols = subMatrix[0].length;\n         if (nCols == 0) {\n-            throw new IllegalArgumentException(\n-            \"Matrix must have at least one column.\"); \n-        }\n+            throw new IllegalArgumentException(\"Matrix must have at least one column.\"); \n+        }\n+\n         for (int r = 1; r < nRows; r++) {\n             if (subMatrix[r].length != nCols) {\n-                throw new IllegalArgumentException(\n-                \"All input rows must have the same length.\");\n-            }\n-        }       \n+                throw new IllegalArgumentException(\"All input rows must have the same length.\");\n+            }\n+        }\n+\n         if (data == null) {\n-            if ((row > 0)||(column > 0)) throw new MatrixIndexException\n-                (\"matrix must be initialized to perfom this method\");\n+            if (row > 0) {\n+                throw MathRuntimeException.createIllegalStateException(\"first {0} rows are not initialized yet\",\n+                                                                       new Object[] { row });\n+            }\n+            if (column > 0) {\n+                throw MathRuntimeException.createIllegalStateException(\"first {0} columns are not initialized yet\",\n+                                                                       new Object[] { column });\n+            }\n             data = new double[nRows][nCols];\n             System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);          \n-        }   \n-        if (((nRows + row) > this.getRowDimension()) ||\n-            (nCols + column > this.getColumnDimension()))\n-            throw new MatrixIndexException(\n-                    \"invalid row or column index selection\");                   \n+        } else {\n+            checkRowIndex(row);\n+            checkColumnIndex(column);\n+            checkRowIndex(nRows + row - 1);\n+            checkColumnIndex(nCols + column - 1);\n+        }\n+\n         for (int i = 0; i < nRows; i++) {\n             System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);\n         } \n+\n         lu = null;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getRowMatrix(int row) throws MatrixIndexException {\n+        checkRowIndex(row);\n+        final int ncols = this.getColumnDimension();\n+        final double[][] out = new double[1][ncols]; \n+        System.arraycopy(data[row], 0, out[0], 0, ncols);\n+        return new RealMatrixImpl(out, false);\n     }\n     \n-    /**\n-     * Returns the entries in row number <code>row</code> as a row matrix.\n-     * Row indices start at 0.\n-     * \n-     * @param row  the row to be fetched\n-     * @return row matrix\n-     * @throws MatrixIndexException if the specified row index is invalid\n-     */\n-    public RealMatrix getRowMatrix(int row) throws MatrixIndexException {\n-        if ( !isValidCoordinate( row, 0)) {\n-            throw new MatrixIndexException(\"illegal row argument\");\n-        }\n-        int ncols = this.getColumnDimension();\n-        double[][] out = new double[1][ncols]; \n-        System.arraycopy(data[row], 0, out[0], 0, ncols);\n-        return new RealMatrixImpl(out);\n-    }\n-    \n-    /**\n-     * Returns the entries in column number <code>column</code>\n-     * as a column matrix.  Column indices start at 0.\n-     *\n-     * @param column the column to be fetched\n-     * @return column matrix\n-     * @throws MatrixIndexException if the specified column index is invalid\n-     */\n+    /** {@inheritDoc} */\n     public RealMatrix getColumnMatrix(int column) throws MatrixIndexException {\n-        if ( !isValidCoordinate( 0, column)) {\n-            throw new MatrixIndexException(\"illegal column argument\");\n-        }\n-        int nRows = this.getRowDimension();\n-        double[][] out = new double[nRows][1]; \n+        checkColumnIndex(column);\n+        final int nRows = this.getRowDimension();\n+        final double[][] out = new double[nRows][1]; \n         for (int row = 0; row < nRows; row++) {\n             out[row][0] = data[row][column];\n         }\n-        return new RealMatrixImpl(out);\n-    }\n-\n-     /**\n-     * Returns the entries in row number <code>row</code> as an array.\n-     * <p>\n-     * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown\n-     * unless <code>0 <= row < rowDimension.</code></p>\n-     *\n-     * @param row the row to be fetched\n-     * @return array of entries in the row\n-     * @throws MatrixIndexException if the specified row index is not valid\n-     */\n+        return new RealMatrixImpl(out, false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector getColumnVector(int column) throws MatrixIndexException {\n+        return new RealVectorImpl(getColumn(column), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector getRowVector(int row) throws MatrixIndexException {\n+        return new RealVectorImpl(getRow(row), false);\n+    }\n+\n+    /** {@inheritDoc} */\n     public double[] getRow(int row) throws MatrixIndexException {\n-        if ( !isValidCoordinate( row, 0 ) ) {\n-            throw new MatrixIndexException(\"illegal row argument\");\n-        }\n-        int ncols = this.getColumnDimension();\n-        double[] out = new double[ncols];\n+        checkRowIndex(row);\n+        final int ncols = this.getColumnDimension();\n+        final double[] out = new double[ncols];\n         System.arraycopy(data[row], 0, out, 0, ncols);\n         return out;\n     }\n \n-    /**\n-     * Returns the entries in column number <code>col</code> as an array.\n-     * <p>\n-     * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown\n-     * unless <code>0 <= column < columnDimension.</code></p>\n-     *\n-     * @param col the column to be fetched\n-     * @return array of entries in the column\n-     * @throws MatrixIndexException if the specified column index is not valid\n-     */\n+    /** {@inheritDoc} */\n     public double[] getColumn(int col) throws MatrixIndexException {\n-        if ( !isValidCoordinate(0, col) ) {\n-            throw new MatrixIndexException(\"illegal column argument\");\n-        }\n-        int nRows = this.getRowDimension();\n-        double[] out = new double[nRows];\n+        checkColumnIndex(col);\n+        final int nRows = this.getRowDimension();\n+        final double[] out = new double[nRows];\n         for (int row = 0; row < nRows; row++) {\n             out[row] = data[row][col];\n         }\n         return out;\n     }\n \n-    /**\n-     * Returns the entry in the specified row and column.\n-     * <p>\n-     * Row and column indices start at 0 and must satisfy \n-     * <ul>\n-     * <li><code>0 <= row < rowDimension</code></li>\n-     * <li><code> 0 <= column < columnDimension</code></li>\n-     * </ul>\n-     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n-     * \n-     * @param row  row location of entry to be fetched\n-     * @param column  column location of entry to be fetched\n-     * @return matrix entry in row,column\n-     * @throws MatrixIndexException if the row or column index is not valid\n-     */\n+    /** {@inheritDoc} */\n     public double getEntry(int row, int column)\n         throws MatrixIndexException {\n-        if (!isValidCoordinate(row,column)) {\n-            throw new MatrixIndexException(\"matrix entry does not exist\");\n-        }\n-        return data[row][column];\n-    }\n-\n-    /**\n-     * Returns the transpose matrix.\n-     *\n-     * @return transpose matrix\n-     */\n+        try {\n+            return data[row][column];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                                           new Object[] {\n+                                               row, column,\n+                                               getRowDimension(), getColumnDimension()\n+                                           });\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n     public RealMatrix transpose() {\n-        int nRows = this.getRowDimension();\n-        int nCols = this.getColumnDimension();\n-        RealMatrixImpl out = new RealMatrixImpl(nCols, nRows);\n-        double[][] outData = out.getDataRef();\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        final double[][] outData = new double[nCols][nRows];\n         for (int row = 0; row < nRows; row++) {\n+            final double[] dataRow = data[row];\n             for (int col = 0; col < nCols; col++) {\n-                outData[col][row] = data[row][col];\n-            }\n-        }\n-        return out;\n-    }\n-\n-    /**\n-     * Returns the inverse matrix if this matrix is invertible.\n-     *\n-     * @return inverse matrix\n-     * @throws InvalidMatrixException if this is not invertible\n-     */\n+                outData[col][row] = dataRow[col];\n+            }\n+        }\n+        return new RealMatrixImpl(outData, false);\n+    }\n+\n+    /** {@inheritDoc} */\n     public RealMatrix inverse() throws InvalidMatrixException {\n-        return solve(MatrixUtils.createRealIdentityMatrix\n-                (this.getRowDimension()));\n-    }\n-\n-    /**\n-     * @return determinant\n-     * @throws InvalidMatrixException if matrix is not square\n-     */\n+        if (lu == null) {\n+            lu = new LUDecompositionImpl(this);\n+        }\n+        return lu.getInverse();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n     public double getDeterminant() throws InvalidMatrixException {\n-        if (!isSquare()) {\n-            throw new InvalidMatrixException(\"matrix is not square\");\n-        }\n-        if (isSingular()) {   // note: this has side effect of attempting LU decomp if lu == null\n-            return 0d;\n-        } else {\n-            double det = parity;\n-            for (int i = 0; i < this.getRowDimension(); i++) {\n-                det *= lu[i][i];\n-            }\n-            return det;\n-        }\n-    }\n-\n-    /**\n-     * @return true if the matrix is square (rowDimension = columnDimension)\n-     */\n+        if (lu == null) {\n+            lu = new LUDecompositionImpl(this);\n+        }\n+        return lu.getDeterminant();\n+    }\n+\n+    /** {@inheritDoc} */\n     public boolean isSquare() {\n         return (this.getColumnDimension() == this.getRowDimension());\n     }\n \n-    /**\n-     * @return true if the matrix is singular\n-     */\n+    /** {@inheritDoc} */\n+    @Deprecated\n     public boolean isSingular() {\n         if (lu == null) {\n-            try {\n-                luDecompose();\n-                return false;\n-            } catch (InvalidMatrixException ex) {\n-                return true;\n-            }\n-        } else { // LU decomp must have been successfully performed\n-            return false; // so the matrix is not singular\n-        }\n-    }\n-\n-    /**\n-     * @return rowDimension\n-     */\n+            lu = new LUDecompositionImpl(this);\n+        }\n+        return !lu.isNonSingular();\n+    }\n+\n+    /** {@inheritDoc} */\n     public int getRowDimension() {\n         return data.length;\n     }\n \n-    /**\n-     * @return columnDimension\n-     */\n+    /** {@inheritDoc} */\n     public int getColumnDimension() {\n         return data[0].length;\n     }\n \n-    /**\n-     * @return trace\n-     * @throws IllegalArgumentException if the matrix is not square\n-     */\n+    /** {@inheritDoc} */\n     public double getTrace() throws IllegalArgumentException {\n         if (!isSquare()) {\n             throw new IllegalArgumentException(\"matrix is not square\");\n         return trace;\n     }\n \n-    /**\n-     * @param v vector to operate on\n-     * @throws IllegalArgumentException if columnDimension != v.length\n-     * @return resulting vector\n-     */\n+    /** {@inheritDoc} */\n     public double[] operate(double[] v) throws IllegalArgumentException {\n-        if (v.length != this.getColumnDimension()) {\n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n+        if (v.length != nCols) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n-        int nRows = this.getRowDimension();\n-        int nCols = this.getColumnDimension();\n-        double[] out = new double[v.length];\n+        final double[] out = new double[nRows];\n         for (int row = 0; row < nRows; row++) {\n+            final double[] dataRow = data[row];\n             double sum = 0;\n             for (int i = 0; i < nCols; i++) {\n-                sum += data[row][i] * v[i];\n+                sum += dataRow[i] * v[i];\n             }\n             out[row] = sum;\n         }\n         return out;\n     }\n \n-    /**\n-     * @param v vector to premultiply by\n-     * @throws IllegalArgumentException if rowDimension != v.length\n-     * @return resulting matrix\n-     */\n+    /** {@inheritDoc} */\n+    public RealVector operate(RealVector v) throws IllegalArgumentException {\n+        try {\n+            return operate((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            final int nRows = this.getRowDimension();\n+            final int nCols = this.getColumnDimension();\n+            if (v.getDimension() != nCols) {\n+                throw new IllegalArgumentException(\"vector has wrong length\");\n+            }\n+            final double[] out = new double[nRows];\n+            for (int row = 0; row < nRows; row++) {\n+                final double[] dataRow = data[row];\n+                double sum = 0;\n+                for (int i = 0; i < nCols; i++) {\n+                    sum += dataRow[i] * v.getEntry(i);\n+                }\n+                out[row] = sum;\n+            }\n+            return new RealVectorImpl(out, false);\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of multiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the vector to operate on\n+     * @return this*v\n+     * @throws IllegalArgumentException if columnDimension != v.size()\n+     */\n+    public RealVectorImpl operate(RealVectorImpl v) throws IllegalArgumentException {\n+        return new RealVectorImpl(operate(v.getDataRef()), false);\n+    }\n+\n+    /** {@inheritDoc} */\n     public double[] preMultiply(double[] v) throws IllegalArgumentException {\n-        int nRows = this.getRowDimension();\n+        final int nRows = this.getRowDimension();\n         if (v.length != nRows) {\n             throw new IllegalArgumentException(\"vector has wrong length\");\n         }\n-        int nCols = this.getColumnDimension();\n-        double[] out = new double[nCols];\n+        final int nCols = this.getColumnDimension();\n+        final double[] out = new double[nCols];\n         for (int col = 0; col < nCols; col++) {\n             double sum = 0;\n             for (int i = 0; i < nRows; i++) {\n         return out;\n     }\n \n-    /**\n-     * Returns a matrix of (column) solution vectors for linear systems with\n-     * coefficient matrix = this and constant vectors = columns of\n-     * <code>b</code>.\n-     *\n-     * @param b  array of constant forming RHS of linear systems to\n-     * to solve\n-     * @return solution array\n-     * @throws IllegalArgumentException if this.rowDimension != row dimension\n-     * @throws InvalidMatrixException if this matrix is not square or is singular\n-     */\n+    /** {@inheritDoc} */\n+    public RealVector preMultiply(RealVector v) throws IllegalArgumentException {\n+        try {\n+            return preMultiply((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            final int nRows = this.getRowDimension();\n+            if (v.getDimension() != nRows) {\n+                throw new IllegalArgumentException(\"vector has wrong length\");\n+            }\n+            final int nCols = this.getColumnDimension();\n+            final double[] out = new double[nCols];\n+            for (int col = 0; col < nCols; col++) {\n+                double sum = 0;\n+                for (int i = 0; i < nRows; i++) {\n+                    sum += data[i][col] * v.getEntry(i);\n+                }\n+                out[col] = sum;\n+            }\n+            return new RealVectorImpl(out, false);\n+        }\n+    }\n+\n+    /**\n+     * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the row vector to premultiply by\n+     * @return v*this\n+     * @throws IllegalArgumentException if rowDimension != v.size()\n+     */\n+    RealVectorImpl preMultiply(RealVectorImpl v) throws IllegalArgumentException {\n+        return new RealVectorImpl(preMultiply(v.getDataRef()), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n     public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n-        int nRows = this.getRowDimension();\n-        if (b.length != nRows) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");\n-        }\n-        RealMatrix bMatrix = new RealMatrixImpl(b);\n-        double[][] solution = ((RealMatrixImpl) (solve(bMatrix))).getDataRef();\n-        double[] out = new double[nRows];\n-        for (int row = 0; row < nRows; row++) {\n-            out[row] = solution[row][0];\n-        }\n-        return out;\n-    }\n-\n-    /**\n-     * Returns a matrix of (column) solution vectors for linear systems with\n-     * coefficient matrix = this and constant vectors = columns of\n-     * <code>b</code>.\n-     *\n-     * @param b  matrix of constant vectors forming RHS of linear systems to\n-     * to solve\n-     * @return matrix of solution vectors\n-     * @throws IllegalArgumentException if this.rowDimension != row dimension\n-     * @throws InvalidMatrixException if this matrix is not square or is singular\n-     */\n+        if (lu == null) {\n+            lu = new LUDecompositionImpl(this);\n+        }\n+        return lu.solve(b);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n     public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException  {\n-        if (b.getRowDimension() != this.getRowDimension()) {\n-            throw new IllegalArgumentException(\"Incorrect row dimension\");\n-        }\n-        if (!this.isSquare()) {\n-            throw new InvalidMatrixException(\"coefficient matrix is not square\");\n-        }\n-        if (this.isSingular()) { // side effect: compute LU decomp\n-            throw new InvalidMatrixException(\"Matrix is singular.\");\n-        }\n-\n-        int nCol = this.getColumnDimension();\n-        int nColB = b.getColumnDimension();\n-        int nRowB = b.getRowDimension();\n-\n-        // Apply permutations to b\n-        double[][] bp = new double[nRowB][nColB];\n-        for (int row = 0; row < nRowB; row++) {\n-            for (int col = 0; col < nColB; col++) {\n-                bp[row][col] = b.getEntry(permutation[row], col);\n-            }\n-        }\n-\n-        // Solve LY = b\n-        for (int col = 0; col < nCol; col++) {\n-            for (int i = col + 1; i < nCol; i++) {\n-                for (int j = 0; j < nColB; j++) {\n-                    bp[i][j] -= bp[col][j] * lu[i][col];\n-                }\n-            }\n-        }\n-\n-        // Solve UX = Y\n-        for (int col = nCol - 1; col >= 0; col--) {\n-            for (int j = 0; j < nColB; j++) {\n-                bp[col][j] /= lu[col][col];\n-            }\n-            for (int i = 0; i < col; i++) {\n-                for (int j = 0; j < nColB; j++) {\n-                    bp[i][j] -= bp[col][j] * lu[i][col];\n-                }\n-            }\n-        }\n-\n-        RealMatrixImpl outMat = new RealMatrixImpl(bp);\n-        return outMat;\n+        if (lu == null) {\n+            lu = new LUDecompositionImpl(this);\n+        }\n+        return lu.solve(b);\n     }\n \n     /**\n      * automatically.</p>\n      *\n      * @throws InvalidMatrixException if the matrix is non-square or singular.\n-     */\n+     * @deprecated as of release 2.0, replaced by {@link LUDecomposition}\n+     */\n+    @Deprecated\n     public void luDecompose() throws InvalidMatrixException {\n-\n-        int nRows = this.getRowDimension();\n-        int nCols = this.getColumnDimension();\n-        if (nRows != nCols) {\n-            throw new InvalidMatrixException(\"LU decomposition requires that the matrix be square.\");\n-        }\n-        lu = this.getData();\n-\n-        // Initialize permutation array and parity\n-        permutation = new int[nRows];\n-        for (int row = 0; row < nRows; row++) {\n-            permutation[row] = row;\n-        }\n-        parity = 1;\n-\n-        // Loop over columns\n-        for (int col = 0; col < nCols; col++) {\n-\n-            double sum = 0;\n-\n-            // upper\n-            for (int row = 0; row < col; row++) {\n-                sum = lu[row][col];\n-                for (int i = 0; i < row; i++) {\n-                    sum -= lu[row][i] * lu[i][col];\n-                }\n-                lu[row][col] = sum;\n-            }\n-\n-            // lower\n-            int max = col; // permutation row\n-            double largest = 0d;\n-            for (int row = col; row < nRows; row++) {\n-                sum = lu[row][col];\n-                for (int i = 0; i < col; i++) {\n-                    sum -= lu[row][i] * lu[i][col];\n-                }\n-                lu[row][col] = sum;\n-\n-                // maintain best permutation choice\n-                if (Math.abs(sum) > largest) {\n-                    largest = Math.abs(sum);\n-                    max = row;\n-                }\n-            }\n-\n-            // Singularity check\n-            if (Math.abs(lu[max][col]) < TOO_SMALL) {\n-                lu = null;\n-                throw new InvalidMatrixException(\"matrix is singular\");\n-            }\n-\n-            // Pivot if necessary\n-            if (max != col) {\n-                double tmp = 0;\n-                for (int i = 0; i < nCols; i++) {\n-                    tmp = lu[max][i];\n-                    lu[max][i] = lu[col][i];\n-                    lu[col][i] = tmp;\n-                }\n-                int temp = permutation[max];\n-                permutation[max] = permutation[col];\n-                permutation[col] = temp;\n-                parity = -parity;\n-            }\n-\n-            //Divide the lower elements by the \"winning\" diagonal elt.\n-            for (int row = col + 1; row < nRows; row++) {\n-                lu[row][col] /= lu[col][col];\n-            }\n+        if (lu == null) {\n+            lu = new LUDecompositionImpl(this);\n         }\n     }\n \n         res.append(\"RealMatrixImpl{\");\n         if (data != null) {\n             for (int i = 0; i < data.length; i++) {\n-                if (i > 0)\n+                if (i > 0) {\n                     res.append(\",\");\n+                }\n                 res.append(\"{\");\n                 for (int j = 0; j < data[0].length; j++) {\n-                    if (j > 0)\n+                    if (j > 0) {\n                         res.append(\",\");\n+                    }\n                     res.append(data[i][j]);\n                 } \n                 res.append(\"}\");\n     /**\n      * Returns true iff <code>object</code> is a \n      * <code>RealMatrixImpl</code> instance with the same dimensions as this\n-     * and all corresponding matrix entries are equal.  Corresponding entries\n-     * are compared using {@link java.lang.Double#doubleToLongBits(double)}\n+     * and all corresponding matrix entries are equal.\n      * \n      * @param object the object to test equality against.\n      * @return true if object equals this\n             return false;\n         }\n         RealMatrix m = (RealMatrix) object;\n-        int nRows = getRowDimension();\n-        int nCols = getColumnDimension();\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n         if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {\n             return false;\n         }\n         for (int row = 0; row < nRows; row++) {\n+            final double[] dataRow = data[row];\n             for (int col = 0; col < nCols; col++) {\n-                if (Double.doubleToLongBits(data[row][col]) != \n-                    Double.doubleToLongBits(m.getEntry(row, col))) {\n+                if (dataRow[col] != m.getEntry(row, col)) {\n                     return false;\n                 }\n             }\n      */\n     public int hashCode() {\n         int ret = 7;\n-        int nRows = getRowDimension();\n-        int nCols = getColumnDimension();\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n         ret = ret * 31 + nRows;\n         ret = ret * 31 + nCols;\n         for (int row = 0; row < nRows; row++) {\n-           for (int col = 0; col < nCols; col++) {\n+            final double[] dataRow = data[row];\n+            for (int col = 0; col < nCols; col++) {\n                ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * \n-                   MathUtils.hash(data[row][col]);\n+                   MathUtils.hash(dataRow[col]);\n            }\n         }\n         return ret;\n     }\n \n-    //------------------------ Protected methods\n-\n-    /**\n-     * Returns <code>dimension x dimension</code> identity matrix.\n-     *\n-     * @param dimension dimension of identity matrix to generate\n-     * @return identity matrix\n-     * @throws IllegalArgumentException  if dimension is not positive\n-     * @deprecated use {@link MatrixUtils#createRealIdentityMatrix}\n-     */\n-    protected RealMatrix getIdentity(int dimension) {\n-        return MatrixUtils.createRealIdentityMatrix(dimension);\n-    }\n-\n-    /**\n-     *  Returns the LU decomposition as a RealMatrix.\n-     *  Returns a fresh copy of the cached LU matrix if this has been computed;\n-     *  otherwise the composition is computed and cached for use by other methods.\n-     *  Since a copy is returned in either case, changes to the returned matrix do not\n-     *  affect the LU decomposition property.\n-     * <p>\n-     * The matrix returned is a compact representation of the LU decomposition.\n-     * Elements below the main diagonal correspond to entries of the \"L\" matrix;\n-     * elements on and above the main diagonal correspond to entries of the \"U\"\n-     * matrix.</p>\n-     * <p>\n-     * Example: <pre>\n-     *\n-     *     Returned matrix                L                  U\n-     *         2  3  1                   1  0  0            2  3  1\n-     *         5  4  6                   5  1  0            0  4  6\n-     *         1  7  8                   1  7  1            0  0  8\n-     * </pre>\n-     *\n-     * The L and U matrices satisfy the matrix equation LU = permuteRows(this), <br>\n-     *  where permuteRows reorders the rows of the matrix to follow the order determined\n-     *  by the <a href=#getPermutation()>permutation</a> property.</p>\n-     *\n-     * @return LU decomposition matrix\n-     * @throws InvalidMatrixException if the matrix is non-square or singular.\n-     */\n-    protected RealMatrix getLUMatrix() throws InvalidMatrixException {\n-        if (lu == null) {\n-            luDecompose();\n-        }\n-        return new RealMatrixImpl(lu);\n-    }\n-\n-    /**\n-     * Returns the permutation associated with the lu decomposition.\n-     * The entries of the array represent a permutation of the numbers 0, ... , nRows - 1.\n-     * <p>\n-     * Example:\n-     * permutation = [1, 2, 0] means current 2nd row is first, current third row is second\n-     * and current first row is last.</p>\n-     * <p>\n-     * Returns a fresh copy of the array.</p>\n-     *\n-     * @return the permutation\n-     */\n-    protected int[] getPermutation() {\n-        int[] out = new int[permutation.length];\n-        System.arraycopy(permutation, 0, out, 0, permutation.length);\n-        return out;\n-    }\n-\n     //------------------------ Private methods\n \n     /**\n      * @return a copy of the underlying data array.\n      */\n     private double[][] copyOut() {\n-        int nRows = this.getRowDimension();\n-        double[][] out = new double[nRows][this.getColumnDimension()];\n+        final int nRows = this.getRowDimension();\n+        final double[][] out = new double[nRows][this.getColumnDimension()];\n         // can't copy 2-d array in one shot, otherwise get row references\n         for (int i = 0; i < nRows; i++) {\n             System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n      * @throws NullPointerException if input array is null\n      */\n     private void copyIn(double[][] in) {\n-        setSubMatrix(in,0,0);\n-    }\n-\n-    /**\n-     * Tests a given coordinate as being valid or invalid\n-     *\n-     * @param row the row index.\n-     * @param col the column index.\n-     * @return true if the coordinate is with the current dimensions\n-     */\n-    private boolean isValidCoordinate(int row, int col) {\n-        int nRows = this.getRowDimension();\n-        int nCols = this.getColumnDimension();\n-\n-        return !(row < 0 || row > nRows - 1 || col < 0 || col > nCols -1);\n+        setSubMatrix(in, 0, 0);\n+    }\n+\n+    /**\n+     * Check if a row index is valid.\n+     * @param row row index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    private void checkRowIndex(final int row) {\n+        if (row < 0 || row >= getRowDimension()) {\n+            throw new MatrixIndexException(\"row index {0} out of allowed range [{1}, {2}]\",\n+                                           new Object[] { row, 0, getRowDimension() - 1});\n+        }\n+    }\n+\n+    /**\n+     * Check if a column index is valid.\n+     * @param column column index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    private void checkColumnIndex(final int column)\n+        throws MatrixIndexException {\n+        if (column < 0 || column >= getColumnDimension()) {\n+            throw new MatrixIndexException(\"column index {0} out of allowed range [{1}, {2}]\",\n+                                           new Object[] { column, 0, getColumnDimension() - 1});\n+        }\n     }\n \n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/RealVector.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Interface defining a real-valued vector with basic algebraic operations.\n+ * <p>\n+ * vector element indexing is 0-based -- e.g., <code>getEntry(0)</code>\n+ * returns the first element of the vector.\n+ * </p>\n+ * <p>\n+ * The various <code>mapXxx</code> and <code>mapXxxToSelf</code> methods operate\n+ * on vectors element-wise, i.e. they perform the same operation (adding a scalar,\n+ * applying a function ...) on each element in turn. The <code>mapXxx</code>\n+ * versions create a new vector to hold the result and do not change the instance.\n+ * The <code>mapXxxToSelf</code> versions use the instance itself to store the\n+ * results, so the instance is changed by these methods. In both cases, the result\n+ * vector is returned by the methods, this allows to use the <i>fluent API</i>\n+ * style, like this:\n+ * </p>\n+ * <pre>\n+ *   RealVector result = v.mapAddToSelf(3.0).mapTanToSelf().mapSquareToSelf();\n+ * </pre>\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface RealVector {\n+\n+    /**\n+     * Returns a (deep) copy of this.\n+     * @return vector copy\n+     */\n+    RealVector copy();\n+\n+    /**\n+     * Compute the sum of this and v.\n+     * @param v vector to be added\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    RealVector add(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute the sum of this and v.\n+     * @param v vector to be added\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    RealVector add(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute this minus v.\n+     * @param v vector to be subtracted\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    RealVector subtract(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute this minus v.\n+     * @param v vector to be subtracted\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    RealVector subtract(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Map an addition operation to each entry.\n+     * @param d value to be added to each entry\n+     * @return this + d\n+     */\n+    RealVector mapAdd(double d);\n+\n+    /**\n+     * Map an addition operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to be added to each entry\n+     * @return for convenience, return this\n+     */\n+    RealVector mapAddToSelf(double d);\n+\n+    /**\n+     * Map a subtraction operation to each entry.\n+     * @param d value to be subtracted to each entry\n+     * @return this - d\n+     */\n+    RealVector mapSubtract(double d);\n+\n+    /**\n+     * Map a subtraction operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to be subtracted to each entry\n+     * @return for convenience, return this\n+     */\n+    RealVector mapSubtractToSelf(double d);\n+\n+    /**\n+     * Map a multiplication operation to each entry.\n+     * @param d value to multiply all entries by\n+     * @return this * d\n+     */\n+    RealVector mapMultiply(double d);\n+\n+    /**\n+     * Map a multiplication operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to multiply all entries by\n+     * @return for convenience, return this\n+     */\n+    RealVector mapMultiplyToSelf(double d);\n+\n+    /**\n+     * Map a division operation to each entry.\n+     * @param d value to divide all entries by\n+     * @return this / d\n+     */\n+    RealVector mapDivide(double d);\n+\n+    /**\n+     * Map a division operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to divide all entries by\n+     * @return for convenience, return this\n+     */\n+    RealVector mapDivideToSelf(double d);\n+\n+    /**\n+     * Map a power operation to each entry.\n+     * @param d value to raise all entries to\n+     * @return this ^ d\n+     */\n+    RealVector mapPow(double d);\n+\n+    /**\n+     * Map a power operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to raise all entries to\n+     * @return for convenience, return this\n+     */\n+    RealVector mapPowToSelf(double d);\n+\n+    /**\n+     * Map the {@link Math#exp(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapExp();\n+\n+    /**\n+     * Map the {@link Math#exp(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapExpToSelf();\n+\n+    /**\n+     * Map the {@link Math#expm1(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapExpm1();\n+\n+    /**\n+     * Map the {@link Math#expm1(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapExpm1ToSelf();\n+\n+    /**\n+     * Map the {@link Math#log(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapLog();\n+\n+    /**\n+     * Map the {@link Math#log(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapLogToSelf();\n+\n+    /**\n+     * Map the {@link Math#log10(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapLog10();\n+\n+    /**\n+     * Map the {@link Math#log10(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapLog10ToSelf();\n+\n+    /**\n+     * Map the {@link Math#log1p(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapLog1p();\n+\n+    /**\n+     * Map the {@link Math#log1p(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapLog1pToSelf();\n+\n+    /**\n+     * Map the {@link Math#cosh(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapCosh();\n+\n+    /**\n+     * Map the {@link Math#cosh(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapCoshToSelf();\n+\n+    /**\n+     * Map the {@link Math#sinh(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapSinh();\n+\n+    /**\n+     * Map the {@link Math#sinh(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapSinhToSelf();\n+\n+    /**\n+     * Map the {@link Math#tanh(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapTanh();\n+\n+    /**\n+     * Map the {@link Math#tanh(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapTanhToSelf();\n+\n+    /**\n+     * Map the {@link Math#cos(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapCos();\n+\n+    /**\n+     * Map the {@link Math#cos(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapCosToSelf();\n+\n+    /**\n+     * Map the {@link Math#sin(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapSin();\n+\n+    /**\n+     * Map the {@link Math#sin(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapSinToSelf();\n+\n+    /**\n+     * Map the {@link Math#tan(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapTan();\n+\n+    /**\n+     * Map the {@link Math#tan(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapTanToSelf();\n+\n+    /**\n+     * Map the {@link Math#acos(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapAcos();\n+\n+    /**\n+     * Map the {@link Math#acos(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapAcosToSelf();\n+\n+    /**\n+     * Map the {@link Math#asin(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapAsin();\n+\n+    /**\n+     * Map the {@link Math#asin(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapAsinToSelf();\n+\n+    /**\n+     * Map the {@link Math#atan(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapAtan();\n+\n+    /**\n+     * Map the {@link Math#atan(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapAtanToSelf();\n+\n+    /**\n+     * Map the 1/x function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapInv();\n+\n+    /**\n+     * Map the 1/x function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapInvToSelf();\n+\n+    /**\n+     * Map the {@link Math#abs(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapAbs();\n+\n+    /**\n+     * Map the {@link Math#abs(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapAbsToSelf();\n+\n+    /**\n+     * Map the {@link Math#sqrt(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapSqrt();\n+\n+    /**\n+     * Map the {@link Math#sqrt(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapSqrtToSelf();\n+\n+    /**\n+     * Map the {@link Math#cbrt(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapCbrt();\n+\n+    /**\n+     * Map the {@link Math#cbrt(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapCbrtToSelf();\n+\n+    /**\n+     * Map the {@link Math#ceil(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapCeil();\n+\n+    /**\n+     * Map the {@link Math#ceil(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapCeilToSelf();\n+\n+    /**\n+     * Map the {@link Math#floor(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapFloor();\n+\n+    /**\n+     * Map the {@link Math#floor(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapFloorToSelf();\n+\n+    /**\n+     * Map the {@link Math#rint(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapRint();\n+\n+    /**\n+     * Map the {@link Math#rint(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapRintToSelf();\n+\n+    /**\n+     * Map the {@link Math#signum(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapSignum();\n+\n+    /**\n+     * Map the {@link Math#signum(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapSignumToSelf();\n+\n+    /**\n+     * Map the {@link Math#ulp(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapUlp();\n+\n+    /**\n+     * Map the {@link Math#ulp(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapUlpToSelf();\n+\n+    /**\n+     * Element-by-element multiplication.\n+     * @param v vector by which instance elements must be multiplied\n+     * @return a vector containing this[i] * v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVector ebeMultiply(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Element-by-element multiplication.\n+     * @param v vector by which instance elements must be multiplied\n+     * @return a vector containing this[i] * v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVector ebeMultiply(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Element-by-element division.\n+     * @param v vector by which instance elements must be divided\n+     * @return a vector containing this[i] / v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVector ebeDivide(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Element-by-element division.\n+     * @param v vector by which instance elements must be divided\n+     * @return a vector containing this[i] / v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVector ebeDivide(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Returns vector entries as a double array.\n+     * @return double array of entries\n+     */\n+     double[] getData();\n+\n+    /**\n+     * Compute the dot product.\n+     * @param v vector with which dot product should be computed\n+     * @return the scalar dot product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    double dotProduct(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute the dot product.\n+     * @param v vector with which dot product should be computed\n+     * @return the scalar dot product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    double dotProduct(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the L<sub>2</sub> norm of the vector.\n+     * <p>The L<sub>2</sub> norm is the root of the sum of\n+     * the squared elements.</p>\n+     * @return norm\n+     * @see #getL1Norm()\n+     * @see #getLInfNorm()\n+     * @see #getDistance(RealVector)\n+     */\n+    double getNorm();\n+\n+    /**\n+     * Returns the L<sub>1</sub> norm of the vector.\n+     * <p>The L<sub>1</sub> norm is the sum of the absolute\n+     * values of elements.</p>\n+     * @return norm\n+     * @see #getNorm()\n+     * @see #getLInfNorm()\n+     * @see #getL1Distance(RealVector)\n+     */\n+    double getL1Norm();\n+\n+    /**\n+     * Returns the L<sub>&infty;</sub> norm of the vector.\n+     * <p>The L<sub>&infty;</sub> norm is the max of the absolute\n+     * values of elements.</p>\n+     * @return norm\n+     * @see #getNorm()\n+     * @see #getL1Norm()\n+     * @see #getLInfDistance(RealVector)\n+     */\n+    double getLInfNorm();\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with the\n+     * L<sub>2</sub> norm, i.e. the square root of the sum of\n+     * elements differences, or euclidian distance.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getL1Distance(RealVector)\n+     * @see #getLInfDistance(RealVector)\n+     * @see #getNorm()\n+     */\n+    double getDistance(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with the\n+     * L<sub>2</sub> norm, i.e. the square root of the sum of\n+     * elements differences, or euclidian distance.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getL1Distance(double[])\n+     * @see #getLInfDistance(double[])\n+     * @see #getNorm()\n+     */\n+    double getDistance(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(RealVector)\n+     * @see #getLInfDistance(RealVector)\n+     * @see #getL1Norm()\n+     */\n+    double getL1Distance(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(double[])\n+     * @see #getLInfDistance(double[])\n+     * @see #getL1Norm()\n+     */\n+    double getL1Distance(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>&infty;</sub> norm, i.e. the max of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(RealVector)\n+     * @see #getL1Distance(RealVector)\n+     * @see #getLInfNorm()\n+     */\n+    double getLInfDistance(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>&infty;</sub> norm, i.e. the max of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(double[])\n+     * @see #getL1Distance(double[])\n+     * @see #getLInfNorm()\n+     */\n+    double getLInfDistance(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /** Creates a unit vector pointing in the direction of this vector.\n+     * <p>The instance is not changed by this method.</p>\n+     * @return a unit vector pointing in direction of this vector\n+     * @exception ArithmeticException if the norm is null\n+     */\n+    RealVector unitVector();\n+\n+    /** Converts this vector into a unit vector.\n+     * <p>The instance itself is changed by this method.</p>\n+     * @exception ArithmeticException if the norm is null\n+     */\n+    void unitize();\n+\n+    /** Find the orthogonal projection of this vector onto another vector.\n+     * @param v vector onto which instance must be projected\n+     * @return projection of the instance onto v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    RealVector projection(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /** Find the orthogonal projection of this vector onto another vector.\n+     * @param v vector onto which instance must be projected\n+     * @return projection of the instance onto v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    RealVector projection(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute the outer product.\n+     * @param v vector with which outer product should be computed\n+     * @return the square matrix outer product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    RealMatrix outerProduct(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute the outer product.\n+     * @param v vector with which outer product should be computed\n+     * @return the square matrix outer product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    RealMatrix outerProduct(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the entry in the specified index.\n+     * <p>\n+     * The index start at 0 and must be lesser than the size,\n+     * otherwise a {@link MatrixIndexException} is thrown.\n+     * </p>\n+     * @param index  index location of entry to be fetched\n+     * @return vector entry at index\n+     * @throws MatrixIndexException if the index is not valid\n+     */\n+    double getEntry(int index)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Returns the size of the vector.\n+     * @return size\n+     */\n+    int getDimension();\n+\n+    /**\n+     * Construct a vector by appending a vector to this vector.\n+     * @param v vector to append to this one.\n+     * @return a new vector\n+     */\n+    RealVector append(RealVector v);\n+\n+    /**\n+     * Construct a vector by appending a double to this vector.\n+     * @param d double to append.\n+     * @return a new vector\n+     */\n+    RealVector append(double d);\n+\n+    /**\n+     * Construct a vector by appending a double array to this vector.\n+     * @param a double array to append.\n+     * @return a new vector\n+     */\n+    RealVector append(double[] a);\n+\n+    /**\n+     * Get a subvector from consecutive elements.\n+     * @param index index of first element.\n+     * @param n number of elements to be retrieved.\n+     * @return a vector containing n elements.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     */\n+    RealVector get(int index, int n)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set a single element.\n+     * @param index element index.\n+     * @param value new value for the element.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     */\n+    void set(int index, double value)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set a set of consecutive elements.\n+     * @param index index of first element to be set.\n+     * @param v vector containing the values to set.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     */\n+    void set(int index, RealVector v)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set a set of consecutive elements.\n+     * @param index index of first element to be set.\n+     * @param v vector containing the values to set.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     */\n+    void set(int index, double[] v)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set all elements to a single value.\n+     * @param value single value to set for all elements\n+     */\n+    void set(double value);\n+\n+    /**\n+     * Convert the vector to a double array.\n+     * <p>The array is independent from vector data, it's elements\n+     * are copied.</p>\n+     * @return array containing a copy of vector elements\n+     */\n+    double[] toArray();\n+\n+    /**\n+     * Returns true if any coordinate of this vector is NaN; false otherwise\n+     * @return  true if any coordinate of this vector is NaN; false otherwise\n+     */\n+    public boolean isNaN();\n+    \n+    /**\n+     * Returns true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     * @return  true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     */\n+    public boolean isInfinite();\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/RealVectorFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.CompositeFormat;\n+\n+/**\n+ * Formats a vector in components list format \"{v0; v1; ...; vk-1}\".\n+ * <p>The prefix and suffix \"{\" and \"}\" and the separator \"; \" can be replaced by\n+ * any user-defined strings. The number format for components can be configured.</p>\n+ * <p>White space is ignored at parse time, even if it is in the prefix, suffix\n+ * or separator specifications. So even if the default separator does include a space\n+ * character that is used at format time, both input string \"{1;1;1}\" and\n+ * \" { 1 ; 1 ; 1 } \" will be parsed without error and the same vector will be\n+ * returned. In the second case, however, the parse position after parsing will be\n+ * just after the closing curly brace, i.e. just before the trailing space.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class RealVectorFormat extends CompositeFormat {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -708767813036157690L;\n+\n+    /** The default prefix: \"{\". */\n+    private static final String DEFAULT_PREFIX = \"{\";\n+\n+    /** The default suffix: \"}\". */\n+    private static final String DEFAULT_SUFFIX = \"}\";\n+\n+    /** The default separator: \", \". */\n+    private static final String DEFAULT_SEPARATOR = \"; \";\n+\n+    /** Prefix. */\n+    private final String prefix;\n+\n+    /** Suffix. */\n+    private final String suffix;\n+\n+    /** Separator. */\n+    private final String separator;\n+\n+    /** Trimmed prefix. */\n+    private final String trimmedPrefix;\n+\n+    /** Trimmed suffix. */\n+    private final String trimmedSuffix;\n+\n+    /** Trimmed separator. */\n+    private final String trimmedSeparator;\n+\n+    /** The format used for components. */\n+    private NumberFormat format;\n+\n+    /**\n+     * Create an instance with default settings.\n+     * <p>The instance uses the default prefix, suffix and separator:\n+     * \"{\", \"}\", and \"; \" and the default number format for components.</p>\n+     */\n+    public RealVectorFormat() {\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with a custom number format for components.\n+     * @param format the custom format for components.\n+     */\n+    public RealVectorFormat(final NumberFormat format) {\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix and separator.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param separator separator to use instead of the default \"; \"\n+     */\n+    public RealVectorFormat(final String prefix, final String suffix,\n+                            final String separator) {\n+        this(prefix, suffix, separator, getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix, separator and format\n+     * for components.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param separator separator to use instead of the default \"; \"\n+     * @param format the custom format for components.\n+     */\n+    public RealVectorFormat(final String prefix, final String suffix,\n+                            final String separator, final NumberFormat format) {\n+        this.prefix      = prefix;\n+        this.suffix      = suffix;\n+        this.separator   = separator;\n+        trimmedPrefix    = prefix.trim();\n+        trimmedSuffix    = suffix.trim();\n+        trimmedSeparator = separator.trim();\n+        this.format      = format;\n+    }\n+\n+    /**\n+     * Get the set of locales for which real vectors formats are available.\n+     * <p>This is the same set as the {@link NumberFormat} set.</p>\n+     * @return available real vector format locales.\n+     */\n+    public static Locale[] getAvailableLocales() {\n+        return NumberFormat.getAvailableLocales();\n+    }\n+\n+    /**\n+     * Get the format prefix.\n+     * @return format prefix.\n+     */\n+    public String getPrefix() {\n+        return prefix;\n+    }\n+\n+    /**\n+     * Get the format suffix.\n+     * @return format suffix.\n+     */\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    /**\n+     * Get the format separator between components.\n+     * @return format separator.\n+     */\n+    public String getSeparator() {\n+        return separator;\n+    }\n+\n+    /**\n+     * Get the components format.\n+     * @return components format.\n+     */\n+    public NumberFormat getFormat() {\n+        return format;\n+    }\n+\n+    /**\n+     * Returns the default real vector format for the current locale.\n+     * @return the default real vector format.\n+     */\n+    public static RealVectorFormat getInstance() {\n+        return getInstance(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Returns the default real vector format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the real vector format specific to the given locale.\n+     */\n+    public static RealVectorFormat getInstance(final Locale locale) {\n+        return new RealVectorFormat(getDefaultNumberFormat(locale));\n+    }\n+\n+    /**\n+     * This static method calls {@link #format(Object)} on a default instance of\n+     * RealVectorFormat.\n+     *\n+     * @param v RealVector object to format\n+     * @return A formatted vector\n+     */\n+    public static String formatRealVector(RealVector v) {\n+        return getInstance().format(v);\n+    }\n+\n+    /**\n+     * Formats a {@link RealVector} object to produce a string.\n+     * @param vector the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(RealVector vector, StringBuffer toAppendTo,\n+                               FieldPosition pos) {\n+\n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        // format prefix\n+        toAppendTo.append(prefix);\n+\n+        // format components\n+        for (int i = 0; i < vector.getDimension(); ++i) {\n+            if (i > 0) {\n+                toAppendTo.append(separator);\n+            }\n+            formatDouble(vector.getEntry(i), format, toAppendTo, pos);\n+        }\n+\n+        // format suffix\n+        toAppendTo.append(suffix);\n+\n+        return toAppendTo;\n+\n+    }\n+\n+    /**\n+     * Formats a object to produce a string.\n+     * <p><code>obj</code> must be a  {@link RealVector} object. Any other type of\n+     * object will result in an {@link IllegalArgumentException} being thrown.</p>\n+     * @param obj the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n+     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n+     */\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+                               FieldPosition pos) {\n+\n+        if (obj instanceof RealVector) {\n+            return format( (RealVector)obj, toAppendTo, pos);\n+        }\n+\n+        throw new IllegalArgumentException(\"Cannot format given Object as a RealVector\");\n+\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link RealVector} object.\n+     * @param source the string to parse\n+     * @return the parsed {@link RealVector} object.\n+     * @exception ParseException if the beginning of the specified string\n+     *            cannot be parsed.\n+     */\n+    public RealVectorImpl parse(String source) throws ParseException {\n+        ParsePosition parsePosition = new ParsePosition(0);\n+        RealVectorImpl result = parse(source, parsePosition);\n+        if (parsePosition.getIndex() == 0) {\n+            throw MathRuntimeException.createParseException(\"unparseable real vector: \\\"{0}\\\"\",\n+                                                            new Object[] { source },\n+                                                            parsePosition.getErrorIndex());\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link RealVector} object.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link RealVector} object.\n+     */\n+    public RealVectorImpl parse(String source, ParsePosition pos) {\n+        int initialIndex = pos.getIndex();\n+\n+        // parse prefix\n+        parseAndIgnoreWhitespace(source, pos);\n+        if (!parseFixedstring(source, trimmedPrefix, pos)) {\n+            return null;\n+        }\n+\n+        // parse components\n+        List<Number> components = new ArrayList<Number>();\n+        for (boolean loop = true; loop;){\n+\n+            if (!components.isEmpty()) {\n+                parseAndIgnoreWhitespace(source, pos);\n+                if (!parseFixedstring(source, trimmedSeparator, pos)) {\n+                    loop = false;\n+                }\n+            }\n+\n+            if (loop) {\n+                parseAndIgnoreWhitespace(source, pos);\n+                Number component = parseNumber(source, format, pos);\n+                if (component != null) {\n+                    components.add(component);\n+                } else {\n+                    // invalid component\n+                    // set index back to initial, error index should already be set\n+                    pos.setIndex(initialIndex);\n+                    return null;\n+                }\n+            }\n+\n+        }\n+\n+        // parse suffix\n+        parseAndIgnoreWhitespace(source, pos);\n+        if (!parseFixedstring(source, trimmedSuffix, pos)) {\n+            return null;\n+        }\n+\n+        // build vector\n+        double[] data = new double[components.size()];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = components.get(i).doubleValue();\n+        }\n+        return new RealVectorImpl(data, false);\n+\n+    }\n+\n+    /**\n+     * Parses a string to produce a object.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed object.\n+     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n+     */\n+    public Object parseObject(String source, ParsePosition pos) {\n+        return parse(source, pos);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * This class implements the {@link RealVector} interface with a double array.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class RealVectorImpl implements RealVector, Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -1097961340710804027L;\n+\n+    /** Default format. */\n+    private static final RealVectorFormat DEFAULT_FORMAT =\n+        RealVectorFormat.getInstance();\n+\n+    /** Entries of the vector. */\n+    protected double data[];\n+\n+    /**\n+     * Build a 0-length vector.\n+     * <p>Zero-length vectors may be used to initialized construction of vectors\n+     * by data gathering. We start with zero-length and use either the {@link\n+     * #RealVectorImpl(RealVectorImpl, RealVectorImpl)} constructor\n+     * or one of the <code>append</code> method ({@link #append(double)}, {@link\n+     * #append(double[])}, {@link #append(RealVectorImpl)}) to gather data\n+     * into this vector.</p>\n+     */\n+    public RealVectorImpl() {\n+        data = new double[0];\n+    }\n+\n+    /**\n+     * Construct a (size)-length vector of zeros.\n+     * @param size size of the vector\n+     */\n+    public RealVectorImpl(int size) {\n+        data = new double[size];\n+    }\n+\n+    /**\n+     * Construct an (size)-length vector with preset values.\n+     * @param size size of the vector\n+     * @param preset fill the vector with this scalar value\n+     */\n+    public RealVectorImpl(int size, double preset) {\n+        data = new double[size];\n+        Arrays.fill(data, preset);\n+    }\n+\n+    /**\n+     * Construct a vector from an array, copying the input array.\n+     * @param d array of doubles.\n+     */\n+    public RealVectorImpl(double[] d) {\n+        data = d.clone();\n+    }\n+\n+    /**\n+     * Create a new RealVectorImpl using the input array as the underlying\n+     * data array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * RealVectorImpl and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param d data for new vector\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @throws IllegalArgumentException if <code>d</code> is empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #RealVectorImpl(double[])\n+     */\n+    public RealVectorImpl(double[] d, boolean copyArray)\n+        throws NullPointerException, IllegalArgumentException {\n+        if (d == null) {\n+            throw new NullPointerException();\n+        }   \n+        if (d.length == 0) {\n+            throw new IllegalArgumentException(\"Vector must have at least one element.\"); \n+        }\n+        data = copyArray ? d.clone() :  d;\n+    }\n+\n+    /**\n+     * Construct a vector from part of a array.\n+     * @param d array of doubles.\n+     * @param pos position of first entry\n+     * @param size number of entries to copy\n+     */\n+    public RealVectorImpl(double[] d, int pos, int size) {\n+        if (d.length < pos + size) {\n+            throw new IllegalArgumentException(\"Position \" + pos + \" and size \" + size +\n+                                               \" don't fit to the size of the input array \" +\n+                                               d.length);\n+        }\n+        data = new double[size];\n+        System.arraycopy(d, pos, data, 0, size);\n+    }\n+\n+    /**\n+     * Construct a vector from an array.\n+     * @param d array of Doubles.\n+     */\n+    public RealVectorImpl(Double[] d) {\n+        data = new double[d.length];\n+        for (int i = 0; i < d.length; i++) {\n+            data[i] = d[i].doubleValue();\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector from part of a Double array\n+     * @param d array of Doubles.\n+     * @param pos position of first entry\n+     * @param size number of entries to copy\n+     */\n+    public RealVectorImpl(Double[] d, int pos, int size) {\n+        if (d.length < pos + size) {\n+            throw new IllegalArgumentException(\"Position \" + pos + \" and size \" + size +\n+                                               \" don't fit to the size of the input array \" +\n+                                               d.length);\n+        }\n+        data = new double[size];\n+        for (int i = pos; i < pos + size; i++) {\n+            data[i-pos] = d[i].doubleValue();\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector from another vector, using a deep copy.\n+     * @param v vector to copy\n+     */\n+    public RealVectorImpl(RealVector v) {\n+        data = new double[v.getDimension()];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = v.getEntry(i);\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector from another vector, using a deep copy.\n+     * @param v vector to copy\n+     */\n+    public RealVectorImpl(RealVectorImpl v) {\n+        data = v.data.clone();\n+    }\n+\n+    /**\n+     * Construct a vector from another vector.\n+     * @param v vector to copy\n+     * @param deep if true perform a deep copy otherwise perform a shallow copy\n+     */\n+    public RealVectorImpl(RealVectorImpl v, boolean deep) {\n+        data = deep ? v.data.clone() : v.data;\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public RealVectorImpl(RealVectorImpl v1, RealVectorImpl v2) {\n+        data = new double[v1.data.length + v2.data.length];\n+        System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n+        System.arraycopy(v2.data, 0, data, v1.data.length, v2.data.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public RealVectorImpl(RealVectorImpl v1, double[] v2) {\n+        data = new double[v1.data.length + v2.length];\n+        System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n+        System.arraycopy(v2, 0, data, v1.data.length, v2.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public RealVectorImpl(double[] v1, RealVectorImpl v2) {\n+        data = new double[v1.length + v2.data.length];\n+        System.arraycopy(v1, 0, data, 0, v1.length);\n+        System.arraycopy(v2.data, 0, data, v1.length, v2.data.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public RealVectorImpl(double[] v1, double[] v2) {\n+        data = new double[v1.length + v2.length];\n+        System.arraycopy(v1, 0, data, 0, v1.length);\n+        System.arraycopy(v2, 0, data, v1.length, v2.length);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector copy() {\n+        return new RealVectorImpl(this, true);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector add(RealVector v)\n+    throws IllegalArgumentException {\n+        try {\n+            return add((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] + v.getEntry(i);\n+            }\n+            return new RealVectorImpl(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector add(double[] v)\n+    throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] + v[i];\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /**\n+     * Compute the sum of this and v.\n+     * @param v vector to be added\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVectorImpl add(RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        return (RealVectorImpl) add(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector subtract(RealVector v)\n+    throws IllegalArgumentException {\n+        try {\n+            return subtract((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] - v.getEntry(i);\n+            }\n+            return new RealVectorImpl(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector subtract(double[] v)\n+    throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] - v[i];\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /**\n+     * Compute this minus v.\n+     * @param v vector to be subtracted\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVectorImpl subtract(RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        return (RealVectorImpl) subtract(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAdd(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] + d;\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAddToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i] + d;\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSubtract(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] - d;\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSubtractToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i] - d;\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapMultiply(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] * d;\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapMultiplyToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i] * d;\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapDivide(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] / d;\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapDivideToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i] / d;\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapPow(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.pow(data[i], d);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapPowToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.pow(data[i], d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExp() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.exp(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.exp(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpm1() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.expm1(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpm1ToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.expm1(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.log(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLogToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.log(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog10() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.log10(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog10ToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.log10(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog1p() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.log1p(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog1pToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.log1p(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCosh() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.cosh(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCoshToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.cosh(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinh() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.sinh(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinhToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.sinh(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanh() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.tanh(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanhToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.tanh(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCos() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.cos(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCosToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.cos(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSin() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.sin(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.sin(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTan() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.tan(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.tan(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAcos() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.acos(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAcosToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.acos(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAsin() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.asin(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAsinToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.asin(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAtan() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.atan(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAtanToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.atan(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapInv() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = 1.0 / data[i];\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapInvToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = 1.0 / data[i];\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAbs() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.abs(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAbsToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.abs(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSqrt() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.sqrt(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSqrtToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.sqrt(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCbrt() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.cbrt(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCbrtToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.cbrt(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCeil() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.ceil(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCeilToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.ceil(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapFloor() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.floor(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapFloorToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.floor(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapRint() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.rint(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapRintToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.rint(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSignum() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.signum(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSignumToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.signum(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapUlp() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.ulp(data[i]);\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapUlpToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.ulp(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeMultiply(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return ebeMultiply((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] * v.getEntry(i);\n+            }\n+            return new RealVectorImpl(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeMultiply(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] * v[i];\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /**\n+     * Element-by-element multiplication.\n+     * @param v vector by which instance elements must be multiplied\n+     * @return a vector containing this[i] * v[i] for all i\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVectorImpl ebeMultiply(RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        return (RealVectorImpl) ebeMultiply(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeDivide(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return ebeDivide((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] / v.getEntry(i);\n+            }\n+            return new RealVectorImpl(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeDivide(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] / v[i];\n+        }\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /**\n+     * Element-by-element division.\n+     * @param v vector by which instance elements must be divided\n+     * @return a vector containing this[i] / v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVectorImpl ebeDivide(RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        return (RealVectorImpl) ebeDivide(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getData() {\n+        return data.clone();\n+    }\n+\n+    /**\n+     * Returns a reference to the underlying data array.\n+     * <p>Does not make a fresh copy of the underlying data.</p>\n+     * @return array of entries\n+     */\n+    public double[] getDataRef() {\n+        return data;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double dotProduct(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return dotProduct((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double dot = 0;\n+            for (int i = 0; i < data.length; i++) {\n+                dot += data[i] * v.getEntry(i);\n+            }\n+            return dot;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double dotProduct(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double dot = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            dot += data[i] * v[i];\n+        }\n+        return dot;\n+    }\n+\n+    /**\n+     * Compute the dot product.\n+     * @param v vector with which dot product should be computed\n+     * @return the scalar dot product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public double dotProduct(RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        return dotProduct(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNorm() {\n+        double sum = 0;\n+        for (double a : data) {\n+            sum += a * a;\n+        }\n+        return Math.sqrt(sum);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Norm() {\n+        double sum = 0;\n+        for (double a : data) {\n+            sum += Math.abs(a);\n+        }\n+        return sum;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfNorm() {\n+        double max = 0;\n+        for (double a : data) {\n+            max += Math.max(max, Math.abs(a));\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDistance(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return getDistance((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double sum = 0;\n+            for (int i = 0; i < data.length; ++i) {\n+                final double delta = data[i] - v.getEntry(i); \n+                sum += delta * delta;\n+            }\n+            return Math.sqrt(sum);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDistance(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double sum = 0;\n+        for (int i = 0; i < data.length; ++i) {\n+            final double delta = data[i] - v[i];\n+            sum += delta * delta;\n+        }\n+        return Math.sqrt(sum);\n+    }\n+\n+   /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with the\n+     * L<sub>2</sub> norm, i.e. the square root of the sum of\n+     * elements differences, or euclidian distance.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(RealVector)\n+     * @see #getL1Distance(RealVectorImpl)\n+     * @see #getLInfDistance(RealVectorImpl)\n+     * @see #getNorm()\n+     */\n+    public double getDistance(RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        return getDistance(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Distance(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return getL1Distance((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double sum = 0;\n+            for (int i = 0; i < data.length; ++i) {\n+                final double delta = data[i] - v.getEntry(i); \n+                sum += Math.abs(delta);\n+            }\n+            return sum;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Distance(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double sum = 0;\n+        for (int i = 0; i < data.length; ++i) {\n+            final double delta = data[i] - v[i];\n+            sum += Math.abs(delta);\n+        }\n+        return sum;\n+    }\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(RealVector)\n+     * @see #getL1Distance(RealVectorImpl)\n+     * @see #getLInfDistance(RealVectorImpl)\n+     * @see #getNorm()\n+     */\n+    public double getL1Distance(RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        return getL1Distance(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfDistance(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return getLInfDistance((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double max = 0;\n+            for (int i = 0; i < data.length; ++i) {\n+                final double delta = data[i] - v.getEntry(i); \n+                max = Math.max(max, Math.abs(delta));\n+            }\n+            return max;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfDistance(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double max = 0;\n+        for (int i = 0; i < data.length; ++i) {\n+            final double delta = data[i] - v[i];\n+            max = Math.max(max, Math.abs(delta));\n+        }\n+        return max;\n+    }\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>&infty;</sub> norm, i.e. the max of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(RealVector)\n+     * @see #getL1Distance(RealVectorImpl)\n+     * @see #getLInfDistance(RealVectorImpl)\n+     * @see #getNorm()\n+     */\n+    public double getLInfDistance(RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        return getLInfDistance(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector unitVector() throws ArithmeticException {\n+        final double norm = getNorm();\n+        if (norm == 0) {\n+            throw MathRuntimeException.createArithmeticException(\"zero norm\", null);\n+        }\n+        return mapDivide(getNorm());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void unitize() throws ArithmeticException {\n+        final double norm = getNorm();\n+        if (norm == 0) {\n+            throw MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\",\n+                                                                 null);\n+        }\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] /= norm;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector projection(RealVector v) {\n+        return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector projection(double[] v) {\n+        return projection(new RealVectorImpl(v, false));\n+    }\n+\n+   /** Find the orthogonal projection of this vector onto another vector.\n+     * @param v vector onto which instance must be projected\n+     * @return projection of the instance onto v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVectorImpl projection(RealVectorImpl v) {\n+        return (RealVectorImpl) v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix outerProduct(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return outerProduct((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double[][] out = new double[data.length][data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                for (int j = 0; j < data.length; j++) {\n+                    out[i][j] = data[i] * v.getEntry(j);\n+                }\n+            }\n+            return new RealMatrixImpl(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix outerProduct(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double[][] out = new double[data.length][data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            for (int j = 0; j < data.length; j++) {\n+                out[i][j] = data[i] * v[j];\n+            }\n+        }\n+        return new RealMatrixImpl(out);\n+    }\n+\n+    /**\n+     * Compute the outer product.\n+     * @param v vector with which outer product should be computed\n+     * @return the square matrix outer product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealMatrixImpl outerProduct(RealVectorImpl v)\n+        throws IllegalArgumentException {\n+        return (RealMatrixImpl) outerProduct(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getEntry(int index) throws MatrixIndexException {\n+        return data[index];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getDimension() {\n+        return data.length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector append(RealVector v) {\n+        try {\n+            return append((RealVectorImpl) v);\n+        } catch (ClassCastException cce) {\n+            return new RealVectorImpl(this,new RealVectorImpl(v));\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector by appending a vector to this vector.\n+     * @param v vector to append to this one.\n+     * @return a new vector\n+     */\n+    public RealVectorImpl append(RealVectorImpl v) {\n+        return new RealVectorImpl(this, v);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector append(double in) {\n+        final double[] out = new double[data.length + 1];\n+        System.arraycopy(data, 0, out, 0, data.length);\n+        out[data.length] = in;\n+        return new RealVectorImpl(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector append(double[] in) {\n+        return new RealVectorImpl(this, in);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector get(int index, int n) {\n+        RealVectorImpl out = new RealVectorImpl(n);\n+        try {\n+            System.arraycopy(data, index, out.data, 0, n);\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+            checkIndex(index + n - 1);\n+        }\n+        return out;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(int index, double value) {\n+        try {\n+            data[index] = value;\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(int index, RealVector v) {\n+        try {\n+            try {\n+                set(index, (RealVectorImpl) v);\n+            } catch (ClassCastException cce) {\n+                for (int i = index; i < index + v.getDimension(); ++i) {\n+                    data[i] = v.getEntry(i-index);\n+                }\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+            checkIndex(index + v.getDimension() - 1);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(int index, double[] v) {\n+        try {\n+            System.arraycopy(v, 0, data, index, v.length);\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+            checkIndex(index + v.length - 1);\n+        }\n+    }\n+\n+    /**\n+     * Set a set of consecutive elements.\n+     * \n+     * @param index index of first element to be set.\n+     * @param v vector containing the values to set.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     */\n+    public void set(int index, RealVectorImpl v)\n+        throws MatrixIndexException {\n+        set(index, v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(double value) {\n+        Arrays.fill(data, value);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] toArray(){\n+        return data.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public String toString(){\n+        return DEFAULT_FORMAT.format(this);\n+    }\n+\n+    /**\n+     * Check if instance and specified vectors have the same dimension.\n+     * @param v vector to compare instance with\n+     * @exception IllegalArgumentException if the vectors do not\n+     * have the same dimension\n+     */\n+    public void checkVectorDimensions(RealVector v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+    }\n+\n+    /**\n+     * Check if instance dimension is equal to some expected value.\n+     * \n+     * @param n expected dimension.\n+     * @exception IllegalArgumentException if the dimension is\n+     * inconsistent with vector size\n+     */\n+    public void checkVectorDimensions(int n)\n+        throws IllegalArgumentException {\n+        if (data.length != n) {\n+            throw new IllegalArgumentException(\"vector dimension is \" + data.length +\n+                                               \", not \" + n + \" as expected\");\n+        }\n+    }\n+\n+    /**\n+     * Returns true if any coordinate of this vector is NaN; false otherwise\n+     * @return  true if any coordinate of this vector is NaN; false otherwise\n+     */\n+    public boolean isNaN() {\n+        for (double v : data) {\n+            if (Double.isNaN(v)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * Returns true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     * @return  true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     */\n+    public boolean isInfinite() {\n+\n+        if (isNaN()) {\n+            return false;\n+        }\n+\n+        for (double v : data) {\n+            if (Double.isInfinite(v)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+\n+    }\n+    \n+    /**\n+     * Test for the equality of two real vectors.\n+     * <p>\n+     * If all coordinates of two real vectors are exactly the same, and none are\n+     * <code>Double.NaN</code>, the two real vectors are considered to be equal.\n+     * </p>\n+     * <p>\n+     * <code>NaN</code> coordinates are considered to affect globally the vector\n+     * and be equals to each other - i.e, if either (or all) coordinates of the\n+     * real vector are equal to <code>Double.NaN</code>, the real vector is equal to\n+     * a vector with all <code>Double.NaN</code> coordinates.\n+     * </p>\n+     *\n+     * @param other Object to test for equality to this\n+     * @return true if two 3D vector objects are equal, false if\n+     *         object is null, not an instance of Vector3D, or\n+     *         not equal to this Vector3D instance\n+     * \n+     */\n+    public boolean equals(Object other) {\n+\n+      if (this == other) { \n+        return true;\n+      }\n+\n+      if (other == null) {\n+        return false;\n+      }\n+\n+      try {\n+\n+          RealVector rhs = (RealVector) other;\n+          if (data.length != rhs.getDimension()) {\n+              return false;\n+          }\n+\n+          if (rhs.isNaN()) {\n+              return this.isNaN();\n+          }\n+\n+          for (int i = 0; i < data.length; ++i) {\n+              if (data[i] != rhs.getEntry(i)) {\n+                  return false;\n+              }\n+          }\n+          return true;\n+\n+      } catch (ClassCastException ex) {\n+          // ignore exception\n+          return false;\n+      }\n+\n+    }\n+    \n+    /**\n+     * Get a hashCode for the real vector.\n+     * <p>All NaN values have the same hash code.</p>\n+     * @return a hash code value for this object\n+     */\n+    public int hashCode() {\n+        if (isNaN()) {\n+            return 9;\n+        }\n+        return MathUtils.hash(data);\n+    }\n+\n+    /**\n+     * Check if an index is valid.\n+     * @param index index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    private void checkIndex(final int index)\n+        throws MatrixIndexException {\n+        if (index < 0 || index >= getDimension()) {\n+            throw new MatrixIndexException(\"index {0} out of allowed range [{1}, {2}]\",\n+                                           new Object[] { index, 0, getDimension() - 1});\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/SingularMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Thrown when a matrix is singular.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class SingularMatrixException extends InvalidMatrixException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -7379143356784298432L;\n+\n+    /**\n+     * Construct an exception with a default message.\n+     */\n+    public SingularMatrixException() {\n+        super(\"matrix is singular\", null);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.ConvergenceException;\n+\n+/**\n+ * An interface to classes that implement an algorithm to calculate the \n+ * Singular Value Decomposition of a real matrix.\n+ * <p>The Singular Value Decomposition of matrix A is a set of three matrices:\n+ * U, &Sigma; and V such that A = U &times; &Sigma; &times; V<sup>T</sup>.\n+ * Let A be an m &times; n matrix, then U is an m &times; m orthogonal matrix,\n+ * &Sigma; is a m &times; n diagonal matrix with positive diagonal elements,\n+ * and V is an n &times; n orthogonal matrix.</p>\n+ * <p>This interface is similar to the class with similar name from the now defunct\n+ * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n+ * following changes:</p>\n+ * <ul>\n+ *   <li><code>solve</code> methods have been added (in the superinterface),</li>\n+ *   <li>a {@link DecompositionSolver#decompose(RealMatrix) decompose(RealMatrix)}\n+ *   method has been added (in the superinterface),</li>\n+ *   <li>a {@link #decompose(RealMatrix, int) decompose(RealMatrix), int)} method\n+ *   has been added,</li>\n+ *   <li>a {@link DecompositionSolver#isNonSingular() isNonSingular} method has\n+ *   been added (in the superinterface),</li>\n+ *   <li>a {@link DecompositionSolver#getInverse() getInverse} method has been\n+ *   added (in the superinterface),</li>\n+ *   <li>the <code>norm2</code> method which has been renamed as {@link #getNorm()\n+ *   getNorm},</li>\n+ *   <li>the <code>cond</code> method which has been renamed as {@link\n+ *   #getConditionNumber() getConditionNumber},</li>\n+ *   <li>the <code>rank</code> method which has been renamed as {@link #getRank()\n+ *   getRank}</li>\n+ * </ul>\n+ * @see <a href=\"http://mathworld.wolfram.com/SingularValueDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Singular_value_decomposition\">Wikipedia</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface SingularValueDecomposition extends DecompositionSolver {\n+\n+    /**\n+     * Decompose a matrix to find its largest singular values.\n+     * @param matrix matrix to decompose\n+     * @param maxSingularValues maximal number of singular values to compute\n+     * @exception InvalidMatrixException (wrapping a {@link ConvergenceException}\n+     * if algorithm fails to converge\n+     */\n+    void decompose(RealMatrix matrix, int maxSingularValues)\n+      throws InvalidMatrixException;\n+\n+    /**\n+     * Returns the matrix U of the decomposition. \n+     * <p>U is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the U matrix\n+     * @exception IllegalStateException if neither {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n+     * #decompose(RealMatrix, int)} have not been called\n+     */\n+    RealMatrix getU() throws IllegalStateException;\n+\n+    /**\n+     * Returns the diagonal matrix &Sigma; of the decomposition. \n+     * <p>&Sigma; is a diagonal matrix.</p>\n+     * @return the &Sigma; matrix\n+     * @exception IllegalStateException if neither {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n+     * #decompose(RealMatrix, int)} have not been called\n+     */\n+    RealMatrix getS() throws IllegalStateException;\n+\n+    /**\n+     * Returns the diagonal elements of the matrix &Sigma; of the decomposition. \n+     * @return the diagonal elements of the &Sigma; matrix\n+     * @exception IllegalStateException if neither {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n+     * #decompose(RealMatrix, int)} have not been called\n+     */\n+    double[] getSingularValues() throws IllegalStateException;\n+\n+    /**\n+     * Returns the matrix V of the decomposition. \n+     * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the V matrix (or null if decomposed matrix is singular)\n+     * @exception IllegalStateException if neither {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n+     * #decompose(RealMatrix, int)} have not been called\n+     */\n+    RealMatrix getV() throws IllegalStateException;\n+\n+    /**\n+     * Returns the L<sub>2</sub> norm of the matrix.\n+     * <p>The L<sub>2</sub> norm is max(|A &times; u|<sub>2</sub> /\n+     * |u|<sub>2</sub>), where |.|<sub>2</sub> denotes the vectorial 2-norm\n+     * (i.e. the traditional euclidian norm).</p>\n+     * @return norm\n+     * @exception IllegalStateException if neither {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n+     * #decompose(RealMatrix, int)} have not been called\n+     */\n+    double getNorm() throws IllegalStateException;\n+\n+    /**\n+     * Return the condition number of the matrix.\n+     * @return condition number of the matrix\n+     * @exception IllegalStateException if neither {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n+     * #decompose(RealMatrix, int)} have not been called\n+     */\n+    double getConditionNumber() throws IllegalStateException;\n+\n+    /**\n+     * Return the effective numerical matrix rank.\n+     * <p>The effective numerical rank is the number of non-negligible\n+     * singular values. The threshold used to identify non-negligible\n+     * terms is max(m,n) &times; ulp(s<sub>1</sub>) where ulp(s<sub>1</sub>)\n+     * is the least significant bit of the largest singular value.</p>\n+     * @return effective numerical matrix rank\n+     * @exception IllegalStateException if neither {@link\n+     * DecompositionSolver#decompose(RealMatrix) decompose} nor {@link\n+     * #decompose(RealMatrix, int)} have not been called\n+     */\n+    int getRank() throws IllegalStateException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/TriDiagonalTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+/**\n+ * Class transforming a symmetrical matrix to tridiagonal shape.\n+ * <p>A symmetrical m &times; m matrix A can be written as the product of three matrices:\n+ * A = Q &times; T &times; Q<sup>T</sup> with Q an orthogonal matrix and T a symmetrical\n+ * tridiagonal matrix. Both Q and T are m &times; m matrices.</p>\n+ * <p>This implementation only uses the upper part of the matrix, the part below the\n+ * diagonal is not accessed at all.</p>\n+ * <p>Transformation to tridiagonal shape is often not a goal by itself, but it is\n+ * an intermediate step in more general decomposition algorithms like {@link\n+ * EigenDecomposition eigen decomposition}. This class is therefore intended for internal\n+ * use by the library and is not public. As a consequence of this explicitly limited scope,\n+ * many methods directly returns references to internal arrays, not copies.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+class TriDiagonalTransformer implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 8935390784125343332L;\n+\n+    /** Householder vectors. */\n+    private final double householderVectors[][];\n+\n+    /** Main diagonal. */\n+    private final double[] main;\n+\n+    /** Secondary diagonal. */\n+    private final double[] secondary;\n+\n+    /** Cached value of Q. */\n+    private RealMatrix cachedQ;\n+\n+    /** Cached value of Qt. */\n+    private RealMatrix cachedQt;\n+\n+    /** Cached value of T. */\n+    private RealMatrix cachedT;\n+\n+    /**\n+     * Build the transformation to tridiagonal shape of a symmetrical matrix.\n+     * <p>The specified matrix is assumed to be symmetrical without any check.\n+     * Only the upper triangular part of the matrix is used.</p>\n+     * @param matrix the symmetrical matrix to transform.\n+     * @exception InvalidMatrixException if matrix is not square\n+     */\n+    public TriDiagonalTransformer(RealMatrix matrix)\n+        throws InvalidMatrixException {\n+        if (!matrix.isSquare()) {\n+            throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n+        }\n+\n+        final int m = matrix.getRowDimension();\n+        householderVectors = matrix.getData();\n+        main      = new double[m];\n+        secondary = new double[m - 1];\n+        cachedQ   = null;\n+        cachedQt  = null;\n+        cachedT   = null;\n+\n+        // transform matrix\n+        transform();\n+\n+    }\n+\n+    /**\n+     * Returns the matrix Q of the transform. \n+     * <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the Q matrix\n+     */\n+    public RealMatrix getQ() {\n+        if (cachedQ == null) {\n+            cachedQ = getQT().transpose();\n+        }\n+        return cachedQ;\n+    }\n+\n+    /**\n+     * Returns the transpose of the matrix Q of the transform. \n+     * <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the Q matrix\n+     */\n+    public RealMatrix getQT() {\n+\n+        if (cachedQt == null) {\n+\n+            final int m = householderVectors.length;\n+            final double[][] qtData  = new double[m][m];\n+\n+            // build up first part of the matrix by applying Householder transforms\n+            for (int k = m - 1; k >= 1; --k) {\n+                final double[] hK = householderVectors[k - 1];\n+                final double inv = 1.0 / (secondary[k - 1] * hK[k]);\n+                qtData[k][k] = 1;\n+                if (hK[k] != 0.0) {\n+                    final double[] qtK = qtData[k];\n+                    double beta = 1.0 / secondary[k - 1];\n+                    qtK[k] = 1 + beta * hK[k];\n+                    for (int i = k + 1; i < m; ++i) {\n+                        qtK[i] = beta * hK[i];\n+                    }\n+                    for (int j = k + 1; j < m; ++j) {\n+                        final double[] qtJ = qtData[j];\n+                        beta = 0;\n+                        for (int i = k + 1; i < m; ++i) {\n+                            beta += qtJ[i] * hK[i];\n+                        }\n+                        beta *= inv;\n+                        qtJ[k] = beta * hK[k];\n+                        for (int i = k + 1; i < m; ++i) {\n+                            qtJ[i] += beta * hK[i];\n+                        }\n+                    }\n+                }\n+            }\n+            qtData[0][0] = 1;\n+\n+            // cache the matrix for subsequent calls\n+            cachedQt = new RealMatrixImpl(qtData, false);\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedQt;\n+\n+    }\n+\n+    /**\n+     * Returns the tridiagonal matrix T of the transform. \n+     * @return the T matrix\n+     */\n+    public RealMatrix getT() {\n+\n+        if (cachedT == null) {\n+\n+            final int m = main.length;\n+            double[][] tData = new double[m][m];\n+            for (int i = 0; i < m; ++i) {\n+                double[] tDataI = tData[i];\n+                tDataI[i] = main[i];\n+                if (i > 0) {\n+                    tDataI[i - 1] = secondary[i - 1];\n+                }\n+                if (i < main.length - 1) {\n+                    tDataI[i + 1] = secondary[i];\n+                }\n+            }\n+\n+            // cache the matrix for subsequent calls\n+            cachedT = new RealMatrixImpl(tData, false);\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedT;\n+\n+    }\n+\n+    /**\n+     * Get the Householder vectors of the transform.\n+     * <p>Note that since this class is only intended for internal use,\n+     * it returns directly a reference to its internal arrays, not a copy.</p>\n+     * @return the main diagonal elements of the B matrix\n+     */\n+    double[][] getHouseholderVectorsRef() {\n+        return householderVectors;\n+    }\n+\n+    /**\n+     * Get the main diagonal elements of the matrix T of the transform.\n+     * <p>Note that since this class is only intended for internal use,\n+     * it returns directly a reference to its internal arrays, not a copy.</p>\n+     * @return the main diagonal elements of the T matrix\n+     */\n+    double[] getMainDiagonalRef() {\n+        return main;\n+    }\n+\n+    /**\n+     * Get the secondary diagonal elements of the matrix T of the transform.\n+     * <p>Note that since this class is only intended for internal use,\n+     * it returns directly a reference to its internal arrays, not a copy.</p>\n+     * @return the secondary diagonal elements of the T matrix\n+     */\n+    double[] getSecondaryDiagonalRef() {\n+        return secondary;\n+    }\n+\n+    /**\n+     * Transform original matrix to tridiagonal form.\n+     * <p>Transformation is done using Householder transforms.</p>\n+     */\n+    private void transform() {\n+\n+        final int m = householderVectors.length;\n+        final double[] z = new double[m];\n+        for (int k = 0; k < m - 1; k++) {\n+\n+            //zero-out a row and a column simultaneously\n+            final double[] hK = householderVectors[k];\n+            main[k] = hK[k];\n+            double xNormSqr = 0;\n+            for (int j = k + 1; j < m; ++j) {\n+                final double c = hK[j];\n+                xNormSqr += c * c;\n+            }\n+            final double a = (hK[k + 1] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+            secondary[k] = a;\n+            if (a != 0.0) {\n+                // apply Householder transform from left and right simultaneously\n+\n+                hK[k + 1] -= a;\n+                final double beta = -1 / (a * hK[k + 1]);\n+\n+                // compute a = beta A v, where v is the Householder vector\n+                // this loop is written in such a way\n+                //   1) only the upper triangular part of the matrix is accessed\n+                //   2) access is cache-friendly for a matrix stored in rows\n+                Arrays.fill(z, k + 1, m, 0);\n+                for (int i = k + 1; i < m; ++i) {\n+                    final double[] hI = householderVectors[i];\n+                    final double hKI = hK[i];\n+                    double zI = hI[i] * hKI;\n+                    for (int j = i + 1; j < m; ++j) {\n+                        final double hIJ = hI[j];\n+                        zI   += hIJ * hK[j];\n+                        z[j] += hIJ * hKI;\n+                    }\n+                    z[i] = beta * (z[i] + zI);\n+                }\n+\n+                // compute gamma = beta vT z / 2\n+                double gamma = 0;\n+                for (int i = k + 1; i < m; ++i) {\n+                    gamma += z[i] * hK[i];\n+                }\n+                gamma *= beta / 2;\n+\n+                // compute z = z - gamma v\n+                for (int i = k + 1; i < m; ++i) {\n+                    z[i] -= gamma * hK[i];\n+                }\n+\n+                // update matrix: A = A - v zT - z vT\n+                // only the upper triangular part of the matrix is updated\n+                for (int i = k + 1; i < m; ++i) {\n+                    final double[] hI = householderVectors[i];\n+                    for (int j = i; j < m; ++j) {\n+                        hI[j] -= hK[i] * z[j] + z[i] * hK[j];\n+                    }\n+                }\n+\n+            }\n+\n+        }\n+        main[m - 1] = householderVectors[m - 1][m - 1];\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.events.EventState;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+/**\n+ * Base class managing common boilerplate for all integrators.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 5771479854166853494L;\n+\n+    /** Name of the method. */\n+    private final String name;\n+\n+    /** Step handler. */\n+    protected Collection<StepHandler> stepHandlers;\n+\n+    /** Current step start time. */\n+    protected double stepStart;\n+\n+    /** Current stepsize. */\n+    protected double stepSize;\n+\n+    /** Events handlers manager. */\n+    protected CombinedEventsManager eventsHandlersManager;\n+\n+    /** Build an instance.\n+     * @param name name of the method\n+     */\n+    public AbstractIntegrator(final String name) {\n+        this.name = name;\n+        stepHandlers = new ArrayList<StepHandler>();\n+        stepStart = Double.NaN;\n+        stepSize  = Double.NaN;\n+        eventsHandlersManager = new CombinedEventsManager();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void addStepHandler(final StepHandler handler) {\n+        stepHandlers.add(handler);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Collection<StepHandler> getStepHandlers() {\n+        return Collections.unmodifiableCollection(stepHandlers);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void clearStepHandlers() {\n+        stepHandlers.clear();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void addEventHandler(final EventHandler function,\n+                                final double maxCheckInterval,\n+                                final double convergence,\n+                                final int maxIterationCount) {\n+        eventsHandlersManager.addEventHandler(function, maxCheckInterval,\n+                                              convergence, maxIterationCount);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Collection<EventHandler> getEventHandlers() {\n+        return eventsHandlersManager.getEventsHandlers();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void clearEventHandlers() {\n+        eventsHandlersManager.clearEventsHandlers();\n+    }\n+\n+    /** Check if one of the step handlers requires dense output.\n+     * @return true if one of the step handlers requires dense output\n+     */\n+    protected boolean requiresDenseOutput() {\n+        for (StepHandler handler : stepHandlers) {\n+            if (handler.requiresDenseOutput()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getCurrentStepStart() {\n+        return stepStart;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getCurrentSignedStepsize() {\n+        return stepSize;\n+    }\n+\n+    /** Perform some sanity checks on the integration parameters.\n+     * @param equations differential equations set\n+     * @param t0 start time\n+     * @param y0 state vector at t0\n+     * @param t target time for the integration\n+     * @param y placeholder where to put the state vector\n+     * @exception IntegratorException if some inconsistency is detected\n+     */\n+    protected void sanityChecks(final FirstOrderDifferentialEquations equations,\n+                                final double t0, final double[] y0,\n+                                final double t, final double[] y)\n+        throws IntegratorException {\n+\n+        if (equations.getDimension() != y0.length) {\n+            throw new IntegratorException(\"dimensions mismatch: ODE problem has dimension {0},\" +\n+                                          \" initial state vector has dimension {1}\",\n+                                          new Object[] {\n+                                              Integer.valueOf(equations.getDimension()),\n+                                              Integer.valueOf(y0.length)\n+                                          });\n+        }\n+\n+        if (equations.getDimension() != y.length) {\n+            throw new IntegratorException(\"dimensions mismatch: ODE problem has dimension {0},\" +\n+                                          \" final state vector has dimension {1}\",\n+                                          new Object[] {\n+                                              Integer.valueOf(equations.getDimension()),\n+                                              Integer.valueOf(y.length)\n+                                          });\n+        }\n+\n+        if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\n+            throw new IntegratorException(\"too small integration interval: length = {0}\",\n+                                          new Object[] {\n+                                              Double.valueOf(Math.abs(t - t0))\n+                                          });\n+        }\n+\n+    }\n+\n+    /** Add an event handler for end time checking.\n+     * <p>This method can be used to simplify handling of integration end time.\n+     * It leverages the nominal stop condition with the exceptional stop\n+     * conditions.</p>\n+     * @param startTime integration start time\n+     * @param endTime desired end time\n+     * @param manager manager containing the user-defined handlers\n+     * @return a new manager containing all the user-defined handlers plus a\n+     * dedicated manager triggering a stop event at entTime\n+     */\n+    protected CombinedEventsManager addEndTimeChecker(final double startTime,\n+                                                      final double endTime,\n+                                                      final CombinedEventsManager manager) {\n+        CombinedEventsManager newManager = new CombinedEventsManager();\n+        for (final EventState state : manager.getEventsStates()) {\n+            newManager.addEventHandler(state.getEventHandler(),\n+                                       state.getMaxCheckInterval(),\n+                                       state.getConvergence(),\n+                                       state.getMaxIterationCount());\n+        }\n+        newManager.addEventHandler(new EndTimeChecker(endTime),\n+                                   Double.POSITIVE_INFINITY,\n+                                   Math.ulp(Math.max(Math.abs(startTime), Math.abs(endTime))),\n+                                   100);\n+        return newManager;\n+    }\n+\n+    /** Specialized event handler to stop integration. */\n+    private static class EndTimeChecker implements EventHandler {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = -5211782540446301964L;\n+\n+        /** DEsiredt end time. */\n+        private final double endTime;\n+\n+        /** Build an instance.\n+         * @param endTime desired time\n+         */\n+        public EndTimeChecker(final double endTime) {\n+            this.endTime = endTime;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int eventOccurred(double t, double[] y) {\n+            return STOP;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double g(double t, double[] y) {\n+            return t - endTime;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void resetState(double t, double[] y) {\n+        }\n+        \n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n+++ b/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n package org.apache.commons.math.ode;\n \n import java.util.ArrayList;\n-import java.util.Iterator;\n import java.util.List;\n import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n /**\n  * This class stores all information provided by an ODE integrator\n  * get the model value at any time or to navigate through the\n  * data).</p>\n  *\n- * <p>If problem modelization is done with several separate\n+ * <p>If problem modeling is done with several separate\n  * integration phases for contiguous intervals, the same\n  * ContinuousOutputModel can be used as step handler for all\n  * integration phases as long as they are performed in order and in\n  * the same direction. As an example, one can extrapolate the\n  * trajectory of a satellite with one model (i.e. one set of\n  * differential equations) up to the beginning of a maneuver, use\n- * another more complex model including thrusters modelization and\n+ * another more complex model including thrusters modeling and\n  * accurate attitude control during the maneuver, and revert to the\n  * first model after the end of the maneuver. If the same continuous\n  * output model handles the steps of all integration phases, the user\n    * Build an empty continuous output model.\n    */\n   public ContinuousOutputModel() {\n-    steps = new ArrayList();\n+    steps = new ArrayList<StepInterpolator>();\n     reset();\n   }\n \n    * compatible with the instance (dimension of the state vector,\n    * propagation direction, hole between the dates)\n    */\n-  public void append(ContinuousOutputModel model)\n+  public void append(final ContinuousOutputModel model)\n     throws DerivativeException {\n \n     if (model.steps.size() == 0) {\n         throw new IllegalArgumentException(\"propagation direction mismatch\");\n       }\n \n-      StepInterpolator lastInterpolator = (StepInterpolator) steps.get(index);\n-      double current  = lastInterpolator.getCurrentTime();\n-      double previous = lastInterpolator.getPreviousTime();\n-      double step = current - previous;\n-      double gap = model.getInitialTime() - current;\n+      final StepInterpolator lastInterpolator = (StepInterpolator) steps.get(index);\n+      final double current  = lastInterpolator.getCurrentTime();\n+      final double previous = lastInterpolator.getPreviousTime();\n+      final double step = current - previous;\n+      final double gap = model.getInitialTime() - current;\n       if (Math.abs(gap) > 1.0e-3 * Math.abs(step)) {\n         throw new IllegalArgumentException(\"hole between time ranges\");\n       }\n \n     }\n \n-    for (Iterator iter = model.steps.iterator(); iter.hasNext(); ) {\n-      steps.add(((AbstractStepInterpolator) iter.next()).copy());\n+    for (StepInterpolator interpolator : model.steps) {\n+      steps.add(interpolator.copy());\n     }\n \n     index = steps.size() - 1;\n    * @throws DerivativeException this exception is propagated to the\n    * caller if the underlying user function triggers one\n    */\n-  public void handleStep(StepInterpolator interpolator, boolean isLast)\n+  public void handleStep(final StepInterpolator interpolator, final boolean isLast)\n     throws DerivativeException {\n-\n-    AbstractStepInterpolator ai = (AbstractStepInterpolator) interpolator;\n \n     if (steps.size() == 0) {\n       initialTime = interpolator.getPreviousTime();\n       forward     = interpolator.isForward();\n     }\n \n-    steps.add(ai.copy());\n+    steps.add(interpolator.copy());\n \n     if (isLast) {\n-      finalTime = ai.getCurrentTime();\n+      finalTime = interpolator.getCurrentTime();\n       index     = steps.size() - 1;\n     }\n \n    * @return interpolation point time\n    */\n   public double getInterpolatedTime() {\n-    return ((StepInterpolator) steps.get(index)).getInterpolatedTime();\n+    return steps.get(index).getInterpolatedTime();\n   }\n     \n   /** Set the time of the interpolated point.\n    * near the interval endpoints.</p>\n    * @param time time of the interpolated point\n    */\n-  public void setInterpolatedTime(double time) {\n+  public void setInterpolatedTime(final double time) {\n \n     try {\n       // initialize the search with the complete steps table\n       int iMin = 0;\n-      StepInterpolator sMin = (StepInterpolator) steps.get(iMin);\n+      final StepInterpolator sMin = steps.get(iMin);\n       double tMin = 0.5 * (sMin.getPreviousTime() + sMin.getCurrentTime());\n \n       int iMax = steps.size() - 1;\n-      StepInterpolator sMax = (StepInterpolator) steps.get(iMax);\n+      final StepInterpolator sMax = steps.get(iMax);\n       double tMax = 0.5 * (sMax.getPreviousTime() + sMax.getCurrentTime());\n \n       // handle points outside of the integration interval\n       while (iMax - iMin > 5) {\n \n         // use the last estimated index as the splitting index\n-        StepInterpolator si = (StepInterpolator) steps.get(index);\n-        int location = locatePoint(time, si);\n+        final StepInterpolator si = steps.get(index);\n+        final int location = locatePoint(time, si);\n         if (location < 0) {\n           iMax = index;\n           tMax = 0.5 * (si.getPreviousTime() + si.getCurrentTime());\n         }\n \n         // compute a new estimate of the index in the reduced table slice\n-        int iMed = (iMin + iMax) / 2;\n-        StepInterpolator sMed = (StepInterpolator) steps.get(iMed);\n-        double tMed = 0.5 * (sMed.getPreviousTime() + sMed.getCurrentTime());\n+        final int iMed = (iMin + iMax) / 2;\n+        final StepInterpolator sMed = steps.get(iMed);\n+        final double tMed = 0.5 * (sMed.getPreviousTime() + sMed.getCurrentTime());\n \n         if ((Math.abs(tMed - tMin) < 1e-6) || (Math.abs(tMax - tMed) < 1e-6)) {\n           // too close to the bounds, we estimate using a simple dichotomy\n           // estimate the index using a reverse quadratic polynom\n           // (reverse means we have i = P(t), thus allowing to simply\n           // compute index = P(time) rather than solving a quadratic equation)\n-          double d12 = tMax - tMed;\n-          double d23 = tMed - tMin;\n-          double d13 = tMax - tMin;\n-          double dt1 = time - tMax;\n-          double dt2 = time - tMed;\n-          double dt3 = time - tMin;\n-          double iLagrange = ((dt2 * dt3 * d23) * iMax -\n-                              (dt1 * dt3 * d13) * iMed +\n-                              (dt1 * dt2 * d12) * iMin) /\n-                             (d12 * d23 * d13);\n+          final double d12 = tMax - tMed;\n+          final double d23 = tMed - tMin;\n+          final double d13 = tMax - tMin;\n+          final double dt1 = time - tMax;\n+          final double dt2 = time - tMed;\n+          final double dt3 = time - tMin;\n+          final double iLagrange = ((dt2 * dt3 * d23) * iMax -\n+                                    (dt1 * dt3 * d13) * iMed +\n+                                    (dt1 * dt2 * d12) * iMin) /\n+                                   (d12 * d23 * d13);\n           index = (int) Math.rint(iLagrange);\n         }\n \n         // force the next size reduction to be at least one tenth\n-        int low  = Math.max(iMin + 1, (9 * iMin + iMax) / 10);\n-        int high = Math.min(iMax - 1, (iMin + 9 * iMax) / 10);\n+        final int low  = Math.max(iMin + 1, (9 * iMin + iMax) / 10);\n+        final int high = Math.min(iMax - 1, (iMin + 9 * iMax) / 10);\n         if (index < low) {\n           index = low;\n         } else if (index > high) {\n \n       // now the table slice is very small, we perform an iterative search\n       index = iMin;\n-      while ((index <= iMax) &&\n-             (locatePoint(time, (StepInterpolator) steps.get(index)) > 0)) {\n+      while ((index <= iMax) && (locatePoint(time, steps.get(index)) > 0)) {\n         ++index;\n       }\n \n-      StepInterpolator si = (StepInterpolator) steps.get(index);\n-\n-      si.setInterpolatedTime(time);\n+      steps.get(index).setInterpolatedTime(time);\n \n     } catch (DerivativeException de) {\n-      throw new RuntimeException(\"unexpected DerivativeException caught: \" +\n-                                 de.getMessage());\n+      throw new MathRuntimeException(\"unexpected exception caught\", null, de);\n     }\n \n   }\n    * @return state vector at time {@link #getInterpolatedTime}\n    */\n   public double[] getInterpolatedState() {\n-    return ((StepInterpolator) steps.get(index)).getInterpolatedState();\n+    return steps.get(index).getInterpolatedState();\n   }\n \n   /** Compare a step interval and a double. \n    * the interval, and +1 if it is after the interval, according to\n    * the interval direction\n    */\n-  private int locatePoint(double time, StepInterpolator interval) {\n+  private int locatePoint(final double time, final StepInterpolator interval) {\n     if (forward) {\n       if (time < interval.getPreviousTime()) {\n         return -1;\n   private int index;\n \n   /** Steps table. */\n-  private List steps;\n+  private List<StepInterpolator> steps;\n \n   /** Serializable version identifier */\n-  private static final long serialVersionUID = 2259286184268533249L;\n+  private static final long serialVersionUID = -1417964919405031606L;\n \n }\n--- a/src/java/org/apache/commons/math/ode/DerivativeException.java\n+++ b/src/java/org/apache/commons/math/ode/DerivativeException.java\n \n /**\n  * This exception is made available to users to report\n- * the error conditions that are trigegred while computing\n+ * the error conditions that are triggered while computing\n  * the differential equations.\n  * @version $Revision$ $Date$\n  * @since 1.2\n    * @param specifier format specifier (to be translated)\n    * @param parts to insert in the format (no translation)\n    */\n-  public DerivativeException(String specifier, String[] parts) {\n+  public DerivativeException(final String specifier, final Object[] parts) {\n     super(specifier, parts);\n   }\n \n   /** Build an instance from an underlying cause.\n    * @param cause cause for the exception\n    */\n-  public DerivativeException(Throwable cause) {\n+  public DerivativeException(final Throwable cause) {\n     super(cause);\n   }\n \n--- a/src/java/org/apache/commons/math/ode/FirstOrderConverter.java\n+++ b/src/java/org/apache/commons/math/ode/FirstOrderConverter.java\n public class FirstOrderConverter\n   implements FirstOrderDifferentialEquations {\n \n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -8233657110042144146L;\n+\n   /** Simple constructor.\n    * Build a converter around a second order equations set.\n    * @param equations second order equations set to convert\n    */\n-  public FirstOrderConverter (SecondOrderDifferentialEquations equations) {\n+  public FirstOrderConverter (final SecondOrderDifferentialEquations equations) {\n       this.equations = equations;\n       dimension      = equations.getDimension();\n       z              = new double[dimension];\n    * @throws DerivativeException this exception is propagated to the caller if the\n    * underlying user function triggers one\n    */\n-  public void computeDerivatives(double t, double[] y, double[] yDot)\n-  throws DerivativeException {\n+  public void computeDerivatives(final double t, final double[] y, final double[] yDot)\n+      throws DerivativeException {\n \n     // split the state vector in two\n     System.arraycopy(y, 0,         z,    0, dimension);\n--- a/src/java/org/apache/commons/math/ode/FirstOrderDifferentialEquations.java\n+++ b/src/java/org/apache/commons/math/ode/FirstOrderDifferentialEquations.java\n  */\n \n package org.apache.commons.math.ode;\n+\n+import java.io.Serializable;\n \n /** This interface represents a first order differential equations set.\n  *\n  * @since 1.2\n  */\n \n-public interface FirstOrderDifferentialEquations {\n+public interface FirstOrderDifferentialEquations extends Serializable {\n     \n     /** Get the dimension of the problem.\n      * @return dimension of the problem\n--- a/src/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n \n package org.apache.commons.math.ode;\n \n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n /** This interface represents a first order integrator for\n  * differential equations.\n \n  *\n  * @see FirstOrderDifferentialEquations\n  * @see StepHandler\n- * @see SwitchingFunction\n+ * @see EventHandler\n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n \n-public interface FirstOrderIntegrator {\n-\n-  /** Get the name of the method.\n-   * @return name of the method\n-   */\n-  public String getName();\n-\n-  /** Set the step handler for this integrator.\n-   * The handler will be called by the integrator for each accepted\n-   * step.\n-   * @param handler handler for the accepted steps\n-   */\n-  public void setStepHandler (StepHandler handler);\n-\n-  /** Get the step handler for this integrator.\n-   * @return the step handler for this integrator\n-   */\n-  public StepHandler getStepHandler();\n-\n-  /** Add a switching function to the integrator.\n-   * @param function switching function\n-   * @param maxCheckInterval maximal time interval between switching\n-   * function checks (this interval prevents missing sign changes in\n-   * case the integration steps becomes very large)\n-   * @param convergence convergence threshold in the event time search\n-   * @param maxIterationCount upper limit of the iteration count in\n-   * the event time search\n-   */\n-  public void addSwitchingFunction(SwitchingFunction function,\n-                                   double maxCheckInterval,\n-                                   double convergence,\n-                                   int maxIterationCount);\n+public interface FirstOrderIntegrator extends ODEIntegrator {\n \n   /** Integrate the differential equations up to the given time.\n    * <p>This method solves an Initial Value Problem (IVP).</p>\n    * (can be set to a value smaller than <code>t0</code> for backward integration)\n    * @param y placeholder where to put the state vector at each successful\n    *  step (and hence at the end of integration), can be the same object as y0\n+   * @return stop time, will be the same as target time if integration reached its\n+   * target, but may be different if some {@link EventHandler} stops it at some point.\n    * @throws IntegratorException if the integrator cannot perform integration\n    * @throws DerivativeException this exception is propagated to the caller if\n    * the underlying user function triggers one\n    */\n-  public void integrate (FirstOrderDifferentialEquations equations,\n-                         double t0, double[] y0,\n-                         double t, double[] y)\n+  public double integrate (FirstOrderDifferentialEquations equations,\n+                           double t0, double[] y0,\n+                           double t, double[] y)\n     throws DerivativeException, IntegratorException;\n \n-  /** Get the current value of the step start time t<sub>i</sub>.\n-   * <p>This method can be called during integration (typically by\n-   * the object implementing the {@link FirstOrderDifferentialEquations\n-   * differential equations} problem) if the value of the current step that\n-   * is attempted is needed.</p>\n-   * <p>The result is undefined if the method is called outside of\n-   * calls to {@link #integrate}</p>\n-   * @return current value of the step start time t<sub>i</sub>\n-   */\n-  public double getCurrentStepStart();\n-\n-  /** Get the current signed value of the integration stepsize.\n-   * <p>This method can be called during integration (typically by\n-   * the object implementing the {@link FirstOrderDifferentialEquations\n-   * differential equations} problem) if the signed value of the current stepsize\n-   * that is tried is needed.</p>\n-   * <p>The result is undefined if the method is called outside of\n-   * calls to {@link #integrate}</p>\n-   * @return current signed value of the stepsize\n-   */\n-  public double getCurrentSignedStepsize();\n-\n }\n--- a/src/java/org/apache/commons/math/ode/IntegratorException.java\n+++ b/src/java/org/apache/commons/math/ode/IntegratorException.java\n    * @param specifier format specifier (to be translated)\n    * @param parts to insert in the format (no translation)\n    */\n-  public IntegratorException(String specifier, Object[] parts) {\n+  public IntegratorException(final String specifier, final Object[] parts) {\n     super(specifier, parts);\n   }\n \n    * Create an exception with a given root cause.\n    * @param cause  the exception or error that caused this exception to be thrown\n    */\n-  public IntegratorException(Throwable cause) {\n+  public IntegratorException(final Throwable cause) {\n     super(cause);\n   }\n \n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/ODEIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+/**\n+ * This interface defines the common parts shared by integrators\n+ * for first and second order differential equations.\n+ * @see FirstOrderIntegrator\n+ * @see SecondOrderIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface ODEIntegrator extends Serializable {\n+\n+    /** Get the name of the method.\n+     * @return name of the method\n+     */\n+    String getName();\n+\n+    /** Add a step handler to this integrator.\n+     * <p>The handler will be called by the integrator for each accepted\n+     * step.</p>\n+     * @param handler handler for the accepted steps\n+     * @see #getStepHandlers()\n+     * @see #clearStepHandlers()\n+     * @since 2.0\n+     */\n+    void addStepHandler(StepHandler handler);\n+\n+    /** Get all the step handlers that have been added to the integrator.\n+     * @return an unmodifiable collection of the added events handlers\n+     * @see #addStepHandler(StepHandler)\n+     * @see #clearStepHandlers()\n+     * @since 2.0\n+     */\n+    Collection<StepHandler> getStepHandlers();\n+\n+    /** Remove all the step handlers that have been added to the integrator.\n+     * @see #addStepHandler(StepHandler)\n+     * @see #getStepHandlers()\n+     * @since 2.0\n+     */\n+    void clearStepHandlers();\n+\n+    /** Add an event handler to the integrator.\n+     * @param handler event handler\n+     * @param maxCheckInterval maximal time interval between switching\n+     * function checks (this interval prevents missing sign changes in\n+     * case the integration steps becomes very large)\n+     * @param convergence convergence threshold in the event time search\n+     * @param maxIterationCount upper limit of the iteration count in\n+     * the event time search\n+     * @see #getEventHandlers()\n+     * @see #clearEventHandlers()\n+     */\n+    void addEventHandler(EventHandler handler,\n+                                         double maxCheckInterval,\n+                                         double convergence,\n+                                         int maxIterationCount);\n+\n+    /** Get all the event handlers that have been added to the integrator.\n+     * @return an unmodifiable collection of the added events handlers\n+     * @see #addEventHandler(EventHandler, double, double, int)\n+     * @see #clearEventHandlers()\n+     */\n+    Collection<EventHandler> getEventHandlers();\n+\n+    /** Remove all the event handlers that have been added to the integrator.\n+     * @see #addEventHandler(EventHandler, double, double, int)\n+     * @see #getEventHandlers()\n+     */\n+    void clearEventHandlers();\n+\n+    /** Get the current value of the step start time t<sub>i</sub>.\n+     * <p>This method can be called during integration (typically by\n+     * the object implementing the {@link FirstOrderDifferentialEquations\n+     * differential equations} problem) if the value of the current step that\n+     * is attempted is needed.</p>\n+     * <p>The result is undefined if the method is called outside of\n+     * calls to {@link #integrate}</p>\n+     * @return current value of the step start time t<sub>i</sub>\n+     */\n+    double getCurrentStepStart();\n+\n+    /** Get the current signed value of the integration stepsize.\n+     * <p>This method can be called during integration (typically by\n+     * the object implementing the {@link FirstOrderDifferentialEquations\n+     * differential equations} problem) if the signed value of the current stepsize\n+     * that is tried is needed.</p>\n+     * <p>The result is undefined if the method is called outside of\n+     * calls to {@link #integrate}</p>\n+     * @return current signed value of the stepsize\n+     */\n+    double getCurrentSignedStepsize();\n+\n+}\n--- a/src/java/org/apache/commons/math/ode/SecondOrderIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/SecondOrderIntegrator.java\n \n package org.apache.commons.math.ode;\n \n+\n /** This interface represents a second order integrator for\n  * differential equations.\n  *\n  * @since 1.2\n  */\n \n-public interface SecondOrderIntegrator {\n-\n-  /** Get the name of the method.\n-   * @return name of the method\n-   */\n-  public String getName();\n-\n-  /** Set the step handler for this integrator.\n-   * The handler will be called by the integrator for each accepted\n-   * step.\n-   * @param handler handler for the accepted steps\n-   */\n-  public void setStepHandler (StepHandler handler);\n-\n-  /** Get the step handler for this integrator.\n-   * @return the step handler for this integrator\n-   */\n-  public StepHandler getStepHandler();\n+public interface SecondOrderIntegrator extends ODEIntegrator {\n \n   /** Integrate the differential equations up to the given time\n    * @param equations differential equations to integrate\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.events;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/** This class manages several {@link EventHandler event handlers} during integration.\n+ *\n+ * @see EventHandler\n+ * @see EventState\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class CombinedEventsManager implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -4151965151236441261L;\n+\n+    /** Events states. */\n+    private final List<EventState> states;\n+\n+    /** First active event. */\n+    private EventState first;\n+\n+    /** Initialization indicator. */\n+    private boolean initialized;\n+\n+    /** Simple constructor.\n+     * Create an empty manager\n+     */\n+    public CombinedEventsManager() {\n+        states      = new ArrayList<EventState>();\n+        first       = null;\n+        initialized = false;\n+    }\n+\n+    /** Add an events handler.\n+     * @param handler event handler\n+     * @param maxCheckInterval maximal time interval between events\n+     * checks (this interval prevents missing sign changes in\n+     * case the integration steps becomes very large)\n+     * @param convergence convergence threshold in the event time search\n+     * @param maxIterationCount upper limit of the iteration count in\n+     * the event time search\n+     * @see #getEventsHandlers()\n+     * @see #clearEventsHandlers()\n+     */\n+    public void addEventHandler(final EventHandler handler, final double maxCheckInterval,\n+                                final double convergence, final int maxIterationCount) {\n+        states.add(new EventState(handler, maxCheckInterval,\n+                                  convergence, maxIterationCount));\n+    }\n+\n+    /** Get all the events handlers that have been added to the manager.\n+     * @return an unmodifiable collection of the added event handlers\n+     * @see #addEventHandler(EventHandler, double, double, int)\n+     * @see #clearEventsHandlers()\n+     * @see #getEventsStates()\n+     */\n+    public Collection<EventHandler> getEventsHandlers() {\n+        final List<EventHandler> list = new ArrayList<EventHandler>();\n+        for (EventState state : states) {\n+            list.add(state.getEventHandler());\n+        }\n+        return Collections.unmodifiableCollection(list);\n+    }\n+\n+    /** Remove all the events handlers that have been added to the manager.\n+     * @see #addEventHandler(EventHandler, double, double, int)\n+     * @see #getEventsHandlers()\n+     */\n+    public void clearEventsHandlers() {\n+        states.clear();\n+    }\n+\n+    /** Get all the events state wrapping the handlers that have been added to the manager.\n+     * @return a collection of the events states\n+     * @see #getEventsHandlers()\n+     */\n+    public Collection<EventState> getEventsStates() {\n+        return states;\n+    }\n+\n+    /** Check if the manager does not manage any event handlers.\n+     * @return true if manager is empty\n+     */\n+    public boolean isEmpty() {\n+        return states.isEmpty();\n+    }\n+\n+    /** Evaluate the impact of the proposed step on all managed\n+     * event handlers.\n+     * @param interpolator step interpolator for the proposed step\n+     * @return true if at least one event handler triggers an event\n+     * before the end of the proposed step (this implies the step should\n+     * be rejected)\n+     * @exception DerivativeException if the interpolator fails to\n+     * compute the function somewhere within the step\n+     * @exception IntegratorException if an event cannot be located\n+     */\n+    public boolean evaluateStep(final StepInterpolator interpolator)\n+    throws DerivativeException, IntegratorException {\n+\n+        try {\n+\n+            first = null;\n+            if (states.isEmpty()) {\n+                // there is nothing to do, return now to avoid setting the\n+                // interpolator time (and hence avoid unneeded calls to the\n+                // user function due to interpolator finalization)\n+                return false;\n+            }\n+\n+            if (! initialized) {\n+\n+                // initialize the events states\n+                final double t0 = interpolator.getPreviousTime();\n+                interpolator.setInterpolatedTime(t0);\n+                final double [] y = interpolator.getInterpolatedState();\n+                for (EventState state : states) {\n+                    state.reinitializeBegin(t0, y);\n+                }\n+\n+                initialized = true;\n+\n+            }\n+\n+            // check events occurrence\n+            for (EventState state : states) {\n+\n+                if (state.evaluateStep(interpolator)) {\n+                    if (first == null) {\n+                        first = state;\n+                    } else {\n+                        if (interpolator.isForward()) {\n+                            if (state.getEventTime() < first.getEventTime()) {\n+                                first = state;\n+                            }\n+                        } else {\n+                            if (state.getEventTime() > first.getEventTime()) {\n+                                first = state;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+            }\n+\n+            return first != null;\n+\n+        } catch (EventException se) {\n+            throw new IntegratorException(se);\n+        } catch (ConvergenceException ce) {\n+            throw new IntegratorException(ce);\n+        }\n+\n+    }\n+\n+    /** Get the occurrence time of the first event triggered in the\n+     * last evaluated step.\n+     * @return occurrence time of the first event triggered in the last\n+     * evaluated step, or </code>Double.NaN</code> if no event is\n+     * triggered\n+     */\n+    public double getEventTime() {\n+        return (first == null) ? Double.NaN : first.getEventTime();\n+    }\n+\n+    /** Inform the event handlers that the step has been accepted\n+     * by the integrator.\n+     * @param t value of the independent <i>time</i> variable at the\n+     * end of the step\n+     * @param y array containing the current value of the state vector\n+     * at the end of the step\n+     * @exception IntegratorException if the value of one of the\n+     * events states cannot be evaluated\n+     */\n+    public void stepAccepted(final double t, final double[] y)\n+    throws IntegratorException {\n+        try {\n+            for (EventState state : states) {\n+                state.stepAccepted(t, y);\n+            }\n+        } catch (EventException se) {\n+            throw new IntegratorException(se);\n+        }\n+    }\n+\n+    /** Check if the integration should be stopped at the end of the\n+     * current step.\n+     * @return true if the integration should be stopped\n+     */\n+    public boolean stop() {\n+        for (EventState state : states) {\n+            if (state.stop()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /** Let the event handlers reset the state if they want.\n+     * @param t value of the independent <i>time</i> variable at the\n+     * beginning of the next step\n+     * @param y array were to put the desired state vector at the beginning\n+     * of the next step\n+     * @return true if the integrator should reset the derivatives too\n+     * @exception IntegratorException if one of the events states\n+     * that should reset the state fails to do it\n+     */\n+    public boolean reset(final double t, final double[] y)\n+        throws IntegratorException {\n+        try {\n+            boolean resetDerivatives = false;\n+            for (EventState state : states) {\n+                if (state.reset(t, y)) {\n+                    resetDerivatives = true;\n+                }\n+            }\n+            return resetDerivatives;\n+        } catch (EventException se) {\n+            throw new IntegratorException(se);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/events/EventException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.events;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * This exception is made available to users to report\n+ * the error conditions that are triggered by {@link EventHandler}\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class EventException extends MathException {\n+\n+    /** Serialization UID. */\n+    private static final long serialVersionUID = -898215297400035290L;\n+\n+    /** Simple constructor.\n+     * Build an exception by translating and formating a message\n+     * @param specifier format specifier (to be translated)\n+     * @param parts to insert in the format (no translation)\n+     */\n+    public EventException(final String specifier, final Object[] parts) {\n+        super(specifier, parts);\n+    }\n+\n+    /**\n+     * Create an exception with a given root cause.\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     */\n+    public EventException(final Throwable cause) {\n+        super(cause);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/events/EventHandler.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.events;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+/** This interface represents a handler for discrete events triggered\n+ * during ODE integration.\n+ *\n+ * <p>Some events can be triggered at discrete times as an ODE problem\n+ * is solved. These occurs for example when the integration process\n+ * should be stopped as some state is reached (G-stop facility) when the\n+ * precise date is unknown a priori, or when the derivatives have\n+ * discontinuities, or simply when the user wants to monitor some\n+ * states boundaries crossings.\n+ * </p>\n+ * \n+ * <p>These events are defined as occurring when a <code>g</code>\n+ * switching function sign changes.</p>\n+ *\n+ * <p>Since events are only problem-dependent and are triggered by the\n+ * independent <i>time</i> variable and the state vector, they can\n+ * occur at virtually any time, unknown in advance. The integrators will\n+ * take care to avoid sign changes inside the steps, they will reduce\n+ * the step size when such an event is detected in order to put this\n+ * event exactly at the end of the current step. This guarantees that\n+ * step interpolation (which always has a one step scope) is relevant\n+ * even in presence of discontinuities. This is independent from the\n+ * stepsize control provided by integrators that monitor the local\n+ * error (this event handling feature is available for all integrators,\n+ * including fixed step ones).</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public interface EventHandler extends Serializable {\n+\n+  /** Stop indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should be\n+   * stopped after the event ending the current step.</p>\n+   */\n+  public static final int STOP = 0;\n+\n+  /** Reset state indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should\n+   * go on after the event ending the current step, with a new state\n+   * vector (which will be retrieved thanks to the {@link #resetState\n+   * resetState} method).</p>\n+   */\n+  public static final int RESET_STATE = 1;\n+\n+  /** Reset derivatives indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should\n+   * go on after the event ending the current step, with a new derivatives\n+   * vector (which will be retrieved thanks to the {@link\n+   * FirstOrderDifferentialEquations#computeDerivatives} method).</p>\n+   */\n+  public static final int RESET_DERIVATIVES = 2;\n+\n+  /** Continue indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should go\n+   * on after the event ending the current step.</p>\n+   */\n+  public static final int CONTINUE = 3;\n+\n+  /** Compute the value of the switching function.\n+\n+   * <p>The discrete events are generated when the sign of this \n+   * switching function changes. The integrator will take care to change\n+   * the stepsize in such a way these events occur exactly at step boundaries.\n+   * The switching function must be continuous in its roots neighborhood\n+   * (but not necessarily smooth), as the integrator will need to find its\n+   * roots to locate precisely the events.</p>\n+\n+   * @param t current value of the independent <i>time</i> variable\n+   * @param y array containing the current value of the state vector\n+   * @return value of the g switching function\n+   * @exception EventException if the switching function cannot be evaluated\n+   */\n+  public double g(double t, double[] y) throws EventException;\n+\n+  /** Handle an event and choose what to do next.\n+\n+   * <p>This method is called when the integrator has accepted a step\n+   * ending exactly on a sign change of the function, just before the\n+   * step handler itself is called. It allows the user to update his\n+   * internal data to acknowledge the fact the event has been handled\n+   * (for example setting a flag in the {@link\n+   * FirstOrderDifferentialEquations differential equations} to switch\n+   * the derivatives computation in case of discontinuity), or to\n+   * direct the integrator to either stop or continue integration,\n+   * possibly with a reset state or derivatives.</p>\n+\n+   * <ul>\n+   *   <li>if {@link #STOP} is returned, the step handler will be called\n+   *   with the <code>isLast</code> flag of the {@link\n+   *   StepHandler#handleStep handleStep} method set to true and the\n+   *   integration will be stopped,</li>\n+   *   <li>if {@link #RESET_STATE} is returned, the {@link #resetState\n+   *   resetState} method will be called once the step handler has\n+   *   finished its task, and the integrator will also recompute the\n+   *   derivatives,</li>\n+   *   <li>if {@link #RESET_DERIVATIVES} is returned, the integrator\n+   *   will recompute the derivatives,\n+   *   <li>if {@link #CONTINUE} is returned, no specific action will\n+   *   be taken (apart from having called this method) and integration\n+   *   will continue.</li>\n+   * </ul>\n+\n+   * @param t current value of the independent <i>time</i> variable\n+   * @param y array containing the current value of the state vector\n+   * @return indication of what the integrator should do next, this\n+   * value must be one of {@link #STOP}, {@link #RESET_STATE},\n+   * {@link #RESET_DERIVATIVES} or {@link #CONTINUE}\n+   * @exception EventException if the event occurrence triggers an error\n+   */\n+  public int eventOccurred(double t, double[] y) throws EventException;\n+  \n+  /** Reset the state prior to continue the integration.\n+\n+   * <p>This method is called after the step handler has returned and\n+   * before the next step is started, but only when {@link\n+   * #eventOccurred} has itself returned the {@link #RESET_STATE}\n+   * indicator. It allows the user to reset the state vector for the\n+   * next step, without perturbing the step handler of the finishing\n+   * step. If the {@link #eventOccurred} never returns the {@link\n+   * #RESET_STATE} indicator, this function will never be called, and it is\n+   * safe to leave its body empty.</p>\n+\n+   * @param t current value of the independent <i>time</i> variable\n+   * @param y array containing the current value of the state vector\n+   * the new state should be put in the same array\n+   * @exception EventException if the state cannot be reseted\n+   */\n+  public void resetState(double t, double[] y) throws EventException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/events/EventState.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.events;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.BrentSolver;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateRealSolver;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/** This class handles the state for one {@link EventHandler\n+ * event handler} during integration steps.\n+ *\n+ * <p>Each time the integrator proposes a step, the event handler\n+ * switching function should be checked. This class handles the state\n+ * of one handler during one integration step, with references to the\n+ * state at the end of the preceding step. This information is used to\n+ * decide if the handler should trigger an event or not during the\n+ * proposed step (and hence the step should be reduced to ensure the\n+ * event occurs at a bound rather than inside the step).</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class EventState implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -216176055159247559L;\n+\n+    /** Event handler. */\n+    private final EventHandler handler;\n+\n+    /** Maximal time interval between events handler checks. */\n+    private final double maxCheckInterval;\n+\n+    /** Convergence threshold for event localization. */\n+    private final double convergence;\n+\n+    /** Upper limit in the iteration count for event localization. */\n+    private final int maxIterationCount;\n+\n+    /** Time at the beginning of the step. */\n+    private double t0;\n+\n+    /** Value of the events handler at the beginning of the step. */\n+    private double g0;\n+\n+    /** Simulated sign of g0 (we cheat when crossing events). */\n+    private boolean g0Positive;\n+\n+    /** Indicator of event expected during the step. */\n+    private boolean pendingEvent;\n+\n+    /** Occurrence time of the pending event. */\n+    private double pendingEventTime;\n+\n+    /** Occurrence time of the previous event. */\n+    private double previousEventTime;\n+\n+    /** Variation direction around pending event.\n+     *  (this is considered with respect to the integration direction)\n+     */\n+    private boolean increasing;\n+\n+    /** Next action indicator. */\n+    private int nextAction;\n+\n+    /** Simple constructor.\n+     * @param handler event handler\n+     * @param maxCheckInterval maximal time interval between switching\n+     * function checks (this interval prevents missing sign changes in\n+     * case the integration steps becomes very large)\n+     * @param convergence convergence threshold in the event time search\n+     * @param maxIterationCount upper limit of the iteration count in\n+     * the event time search\n+     */\n+    public EventState(final EventHandler handler, final double maxCheckInterval,\n+                      final double convergence, final int maxIterationCount) {\n+        this.handler           = handler;\n+        this.maxCheckInterval  = maxCheckInterval;\n+        this.convergence       = Math.abs(convergence);\n+        this.maxIterationCount = maxIterationCount;\n+\n+        // some dummy values ...\n+        t0                = Double.NaN;\n+        g0                = Double.NaN;\n+        g0Positive        = true;\n+        pendingEvent      = false;\n+        pendingEventTime  = Double.NaN;\n+        previousEventTime = Double.NaN;\n+        increasing        = true;\n+        nextAction        = EventHandler.CONTINUE;\n+\n+    }\n+\n+    /** Get the underlying event handler.\n+     * @return underlying event handler\n+     */\n+    public EventHandler getEventHandler() {\n+        return handler;\n+    }\n+\n+    /** Get the maximal time interval between events handler checks.\n+     * @return maximal time interval between events handler checks\n+     */\n+    public double getMaxCheckInterval() {\n+        return maxCheckInterval;\n+    }\n+\n+    /** Get the convergence threshold for event localization.\n+     * @return convergence threshold for event localization\n+     */\n+    public double getConvergence() {\n+        return convergence;\n+    }\n+\n+    /** Get the upper limit in the iteration count for event localization.\n+     * @return upper limit in the iteration count for event localization\n+     */\n+    public int getMaxIterationCount() {\n+        return maxIterationCount;\n+    }\n+\n+    /** Reinitialize the beginning of the step.\n+     * @param t0 value of the independent <i>time</i> variable at the\n+     * beginning of the step\n+     * @param y0 array containing the current value of the state vector\n+     * at the beginning of the step\n+     * @exception EventException if the event handler\n+     * value cannot be evaluated at the beginning of the step\n+     */\n+    public void reinitializeBegin(final double t0, final double[] y0)\n+        throws EventException {\n+        this.t0 = t0;\n+        g0 = handler.g(t0, y0);\n+        g0Positive = (g0 >= 0);\n+    }\n+\n+    /** Evaluate the impact of the proposed step on the event handler.\n+     * @param interpolator step interpolator for the proposed step\n+     * @return true if the event handler triggers an event before\n+     * the end of the proposed step (this implies the step should be\n+     * rejected)\n+     * @exception DerivativeException if the interpolator fails to\n+     * compute the switching function somewhere within the step\n+     * @exception EventException if the switching function\n+     * cannot be evaluated\n+     * @exception ConvergenceException if an event cannot be located\n+     */\n+    public boolean evaluateStep(final StepInterpolator interpolator)\n+        throws DerivativeException, EventException, ConvergenceException {\n+\n+        try {\n+\n+            final double t1 = interpolator.getCurrentTime();\n+            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n+            final double h  = (t1 - t0) / n;\n+\n+            double ta = t0;\n+            double ga = g0;\n+            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n+            for (int i = 0; i < n; ++i) {\n+\n+                // evaluate handler value at the end of the substep\n+                tb += h;\n+                interpolator.setInterpolatedTime(tb);\n+                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n+\n+                // check events occurrence\n+                if (g0Positive ^ (gb >= 0)) {\n+                    // there is a sign change: an event is expected during this step\n+\n+                    // variation direction, with respect to the integration direction\n+                    increasing = (gb >= ga);\n+\n+                    final UnivariateRealSolver solver = new BrentSolver(new UnivariateRealFunction() {\n+                        public double value(final double t) throws FunctionEvaluationException {\n+                            try {\n+                                interpolator.setInterpolatedTime(t);\n+                                return handler.g(t, interpolator.getInterpolatedState());\n+                            } catch (DerivativeException e) {\n+                                throw new FunctionEvaluationException(t, e);\n+                            } catch (EventException e) {\n+                                throw new FunctionEvaluationException(t, e);\n+                            }\n+                        }\n+                    });\n+                    solver.setAbsoluteAccuracy(convergence);\n+                    solver.setMaximalIterationCount(maxIterationCount);\n+                    final double root = (ta <= tb) ? solver.solve(ta, tb) : solver.solve(tb, ta);\n+                    if (Math.abs(root - ta) <= convergence) {\n+                        // we have found (again ?) a past event, we simply ignore it\n+                        ta = tb;\n+                        ga = gb;\n+                    } else if (Double.isNaN(previousEventTime) ||\n+                        (Math.abs(previousEventTime - root) > convergence)) {\n+                        pendingEventTime = root;\n+                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+                            // we were already waiting for this event which was\n+                            // found during a previous call for a step that was\n+                            // rejected, this step must now be accepted since it\n+                            // properly ends exactly at the event occurrence\n+                            return false;\n+                        }\n+                        // either we were not waiting for the event or it has\n+                        // moved in such a way the step cannot be accepted\n+                        pendingEvent = true;\n+                        return true;\n+                    }\n+\n+                } else {\n+                    // no sign change: there is no event for now\n+                    ta = tb;\n+                    ga = gb;\n+                }\n+\n+            }\n+\n+            // no event during the whole step\n+            pendingEvent     = false;\n+            pendingEventTime = Double.NaN;\n+            return false;\n+\n+        } catch (FunctionEvaluationException e) {\n+            final Throwable cause = e.getCause();\n+            if ((cause != null) && (cause instanceof DerivativeException)) {\n+                throw (DerivativeException) cause;\n+            } else if ((cause != null) && (cause instanceof EventException)) {\n+                throw (EventException) cause;\n+            }\n+            throw new EventException(e);\n+        }\n+\n+    }\n+\n+    /** Get the occurrence time of the event triggered in the current\n+     * step.\n+     * @return occurrence time of the event triggered in the current\n+     * step.\n+     */\n+    public double getEventTime() {\n+        return pendingEventTime;\n+    }\n+\n+    /** Acknowledge the fact the step has been accepted by the integrator.\n+     * @param t value of the independent <i>time</i> variable at the\n+     * end of the step\n+     * @param y array containing the current value of the state vector\n+     * at the end of the step\n+     * @exception EventException if the value of the event\n+     * handler cannot be evaluated\n+     */\n+    public void stepAccepted(final double t, final double[] y)\n+        throws EventException {\n+\n+        t0 = t;\n+        g0 = handler.g(t, y);\n+\n+        if (pendingEvent) {\n+            // force the sign to its value \"just after the event\"\n+            previousEventTime = t;\n+            g0Positive        = increasing;\n+            nextAction        = handler.eventOccurred(t, y);\n+        } else {\n+            g0Positive = (g0 >= 0);\n+            nextAction = EventHandler.CONTINUE;\n+        }\n+    }\n+\n+    /** Check if the integration should be stopped at the end of the\n+     * current step.\n+     * @return true if the integration should be stopped\n+     */\n+    public boolean stop() {\n+        return nextAction == EventHandler.STOP;\n+    }\n+\n+    /** Let the event handler reset the state if it wants.\n+     * @param t value of the independent <i>time</i> variable at the\n+     * beginning of the next step\n+     * @param y array were to put the desired state vector at the beginning\n+     * of the next step\n+     * @return true if the integrator should reset the derivatives too\n+     * @exception EventException if the state cannot be reseted by the event\n+     * handler\n+     */\n+    public boolean reset(final double t, final double[] y)\n+        throws EventException {\n+\n+        if (! pendingEvent) {\n+            return false;\n+        }\n+\n+        if (nextAction == EventHandler.RESET_STATE) {\n+            handler.resetState(t, y);\n+        }\n+        pendingEvent      = false;\n+        pendingEventTime  = Double.NaN;\n+\n+        return (nextAction == EventHandler.RESET_STATE) ||\n+               (nextAction == EventHandler.RESET_DERIVATIVES);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+\n+/**\n+ * This class implements explicit Adams-Bashforth integrators for Ordinary\n+ * Differential Equations.\n+ *\n+ * <p>Adams-Bashforth (in fact due to Adams alone) methods are explicit\n+ * multistep ODE solvers witch fixed stepsize. The value of state vector\n+ * at step n+1 is a simple combination of the value at step n and of the\n+ * derivatives at steps n, n-1, n-2 ... Depending on the number k of previous\n+ * steps one wants to use for computing the next value, different formulas\n+ * are available:</p>\n+ * <ul>\n+ *   <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + h f<sub>n</sub></li>\n+ *   <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + h (3f<sub>n</sub>-f<sub>n-1</sub>)/2</li>\n+ *   <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + h (23f<sub>n</sub>-16f<sub>n-1</sub>+5f<sub>n-2</sub>)/12</li>\n+ *   <li>k = 4: y<sub>n+1</sub> = y<sub>n</sub> + h (55f<sub>n</sub>-59f<sub>n-1</sub>+37f<sub>n-2</sub>-9f<sub>n-3)/24</sub></li>\n+ *   <li>...</li>\n+ * </ul>\n+ *\n+ * <p>A k-steps Adams-Bashforth method is of order k. There is no limit to the\n+ * value of k.</p>\n+ *\n+ * <p>These methods are explicit: f<sub>n+1</sub> is not used to compute\n+ * y<sub>n+1</sub>. More accurate implicit Adams methods exist: the\n+ * Adams-Moulton methods (which are also due to Adams alone). They are\n+ * provided by the {@link AdamsMoultonIntegrator AdamsMoultonIntegrator} class.</p>\n+ *\n+ * @see AdamsMoultonIntegrator\n+ * @see BDFIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class AdamsBashforthIntegrator extends MultistepIntegrator {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 1676381657635800870L;\n+\n+    /** Integrator method name. */\n+    private static final String METHOD_NAME = \"Adams-Bashforth\";\n+\n+   /** Coefficients for the current method. */\n+    private final double[] coeffs;\n+\n+    /** Integration step. */\n+    private final double step;\n+\n+    /**\n+     * Build an Adams-Bashforth integrator with the given order and step size.\n+     * @param order order of the method (must be strictly positive)\n+     * @param step integration step size\n+     */\n+    public AdamsBashforthIntegrator(final int order, final double step) {\n+\n+        super(METHOD_NAME, order, new AdamsBashforthStepInterpolator());\n+\n+        // compute the integration coefficients\n+        int[][] bdArray = computeBackwardDifferencesArray(order);\n+        Fraction[] gamma = computeGammaArray(order);\n+        coeffs = new double[order];\n+        for (int i = 0; i < order; ++i) {\n+            Fraction f = Fraction.ZERO;\n+            for (int j = i; j < order; ++j) {\n+                f = f.add(gamma[j].multiply(new Fraction(bdArray[j][i], 1)));\n+            }\n+            coeffs[i] = f.doubleValue();\n+        }\n+\n+        this.step = Math.abs(step);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double integrate(FirstOrderDifferentialEquations equations,\n+                            double t0, double[] y0, double t, double[] y)\n+        throws DerivativeException, IntegratorException {\n+\n+        sanityChecks(equations, t0, y0, t, y);\n+        final boolean forward = (t > t0);\n+\n+        // initialize working arrays\n+        if (y != y0) {\n+            System.arraycopy(y0, 0, y, 0, y0.length);\n+        }\n+        final double[] yTmp = new double[y0.length];\n+\n+        // set up an interpolator sharing the integrator arrays\n+        final AdamsBashforthStepInterpolator interpolator =\n+                (AdamsBashforthStepInterpolator) prototype.copy();\n+        interpolator.reinitialize(yTmp, previousT, previousF, forward);\n+\n+        // set up integration control objects\n+        stepStart = t0;\n+        stepSize  = forward ? step : -step;\n+        for (StepHandler handler : stepHandlers) {\n+            handler.reset();\n+        }\n+        CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n+\n+        // compute the first few steps using the configured starter integrator\n+        double stopTime =\n+            start(previousF.length, stepSize, manager, equations, stepStart, y);\n+        if (Double.isNaN(previousT[0])) {\n+            return stopTime;\n+        }\n+        stepStart = previousT[0];\n+        interpolator.storeTime(stepStart);\n+\n+        boolean lastStep = false;\n+        while (!lastStep) {\n+\n+            // shift all data\n+            interpolator.shift();\n+\n+            // estimate the state at the end of the step\n+            for (int j = 0; j < y0.length; ++j) {\n+                double sum = 0;\n+                for (int l = 0; l < coeffs.length; ++l) {\n+                    sum += coeffs[l] * previousF[l][j];\n+                }\n+                yTmp[j] = y[j] + stepSize * sum;\n+            }\n+\n+            // discrete events handling\n+            interpolator.storeTime(stepStart + stepSize);\n+            final boolean truncated;\n+            if (manager.evaluateStep(interpolator)) {\n+                truncated = true;\n+                interpolator.truncateStep(manager.getEventTime());\n+            } else {\n+                truncated = false;\n+            }\n+\n+            // the step has been accepted (may have been truncated)\n+            final double nextStep = interpolator.getCurrentTime();\n+            interpolator.setInterpolatedTime(nextStep);\n+            System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, y0.length);\n+            manager.stepAccepted(nextStep, y);\n+            lastStep = manager.stop();\n+\n+            // provide the step data to the step handler\n+            for (StepHandler handler : stepHandlers) {\n+                handler.handleStep(interpolator, lastStep);\n+            }\n+            stepStart = nextStep;\n+\n+            if (!lastStep) {\n+                // prepare next step\n+\n+                if (manager.reset(stepStart, y)) {\n+\n+                    // some events handler has triggered changes that\n+                    // invalidate the derivatives, we need to restart from scratch\n+                    stopTime =\n+                        start(previousF.length, stepSize, manager, equations, stepStart, y);\n+                    if (Double.isNaN(previousT[0])) {\n+                        return stopTime;\n+                    }\n+                    stepStart = previousT[0];\n+\n+                } else {\n+\n+                    if (truncated) {\n+                        // the step has been truncated, we need to adjust the previous steps\n+                        for (int i = 1; i < previousF.length; ++i) {\n+                            previousT[i] = stepStart - i * stepSize;\n+                            interpolator.setInterpolatedTime(previousT[i]);\n+                            System.arraycopy(interpolator.getInterpolatedState(), 0,\n+                                             previousF[i], 0, y0.length);\n+                        }\n+                    } else {\n+                        rotatePreviousSteps();\n+                    }\n+\n+                    // evaluate differential equations for next step\n+                    previousT[0] = stepStart;\n+                    equations.computeDerivatives(stepStart, y, previousF[0]);\n+\n+                }\n+            }\n+\n+        }\n+\n+        stopTime  = stepStart;\n+        stepStart = Double.NaN;\n+        stepSize  = Double.NaN;\n+        return stopTime;\n+\n+    }\n+\n+    /** Get the coefficients of the method.\n+     * <p>The coefficients are the c<sub>i</sub> terms in the following formula:</p>\n+     * <pre>\n+     *   y<sub>n+1</sub> = y<sub>n</sub> + h &times; &sum;<sub>i=0</sub><sup>i=k-1</sup> c<sub>i</sub>f<sub>n-i</sub></li>\n+     * </pre>\n+     * @return a copy of the coefficients of the method\n+     */\n+    public double[] getCoeffs() {\n+        return coeffs.clone();\n+    }\n+\n+    /** Compute the backward differences coefficients array.\n+     * <p>This is quite similar to the Pascal triangle containing the\n+     * binomial coefficiens, except for an additional (-1)<sup>i</sup> sign.\n+     * We use a straightforward approach here, since we don't expect this to\n+     * be run too many times with too high k. It is based on the recurrence\n+     * relations:</p>\n+     * <pre>\n+     *   &nabla;<sup>0</sup> f<sub>n</sub> = f<sub>n</sub>\n+     *   &nabla;<sup>i+1</sup> f<sub>n</sub> = &nabla;<sup>i</sup>f<sub>n</sub> - &nabla;<sup>i</sup>f<sub>n-1</sub>\n+     * </pre>\n+     * @param order order of the integration method\n+     * @return the coefficients array for backward differences\n+     */\n+    static int[][] computeBackwardDifferencesArray(final int order) {\n+\n+        // create the array\n+        int[][] bdArray = new int[order][];\n+\n+        // recurrence initialization\n+        bdArray[0] = new int[] { 1 };\n+\n+        // fill up array using recurrence relation\n+        for (int i = 1; i < order; ++i) {\n+            bdArray[i] = new int[i + 1];\n+            bdArray[i][0] = 1;\n+            for (int j = 0; j < i - 1; ++j) {\n+                bdArray[i][j + 1] = bdArray[i - 1][j + 1] - bdArray[i - 1][j];\n+            }\n+            bdArray[i][i] = -bdArray[i - 1][i - 1];\n+        }\n+\n+        return bdArray;\n+\n+    }\n+\n+    /** Compute the gamma coefficients.\n+     * @param order order of the integration method\n+     * @return gamma coefficients array\n+     */\n+    static Fraction[] computeGammaArray(final int order) {\n+\n+        // create the array\n+        Fraction[] gammaArray = new Fraction[order];\n+\n+        // recurrence initialization\n+        gammaArray[0] = Fraction.ONE;\n+\n+        // fill up array using recurrence relation\n+        for (int i = 1; i < order; ++i) {\n+            Fraction gamma = Fraction.ONE;\n+            for (int j = 1; j <= i; ++j) {\n+                gamma = gamma.subtract(gammaArray[i - j].multiply(new Fraction(1, j + 1)));\n+            }\n+            gammaArray[i] = gamma;\n+        }\n+\n+        return gammaArray;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements an interpolator for Adams-Bashforth multiple steps.\n+ *\n+ * <p>This interpolator computes dense output inside the last few\n+ * steps computed. The interpolation equation is consistent with the\n+ * integration scheme, it is based on a kind of <em>rollback</em> of the\n+ * integration from step end to interpolation date:\n+ * <pre>\n+ *   y(t<sub>n</sub> + theta h) = y (t<sub>n</sub> + h) - &int;<sub>t<sub>n</sub> + theta h</sub><sup>t<sub>n</sub> + h</sup>p(t)dt\n+ * </pre>\n+ * where theta belongs to [0 ; 1] and p(t) is the interpolation polynomial based on\n+ * the derivatives at previous steps f<sub>n-k+1</sub>, f<sub>n-k+2</sub> ...\n+ * f<sub>n</sub> and f<sub>n</sub>.</p>\n+ *\n+ * @see AdamsBashforthIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+\n+class AdamsBashforthStepInterpolator extends MultistepStepInterpolator {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -7179861704951334960L;\n+\n+    /** Neville's interpolation array. */\n+    private double[] neville;\n+\n+    /** Integration rollback array. */\n+    private double[] rollback;\n+\n+    /** &gamma; array. */\n+    private double[] gamma;\n+\n+    /** Backward differences array. */\n+    private int[][] bdArray;\n+\n+    /** Original non-truncated step end time. */\n+    private double nonTruncatedEnd;\n+\n+    /** Original non-truncated step size. */\n+    private double nonTruncatedH;\n+\n+    /** Simple constructor.\n+     * This constructor builds an instance that is not usable yet, the\n+     * {@link AbstractStepInterpolator#reinitialize} method should be called\n+     * before using the instance in order to initialize the internal arrays. This\n+     * constructor is used only in order to delay the initialization in\n+     * some cases.\n+     */\n+    public AdamsBashforthStepInterpolator() {\n+    }\n+\n+    /** Copy constructor.\n+     * @param interpolator interpolator to copy from. The copy is a deep\n+     * copy: its arrays are separated from the original arrays of the\n+     * instance\n+     */\n+    public AdamsBashforthStepInterpolator(final AdamsBashforthStepInterpolator interpolator) {\n+        super(interpolator);\n+        nonTruncatedEnd = interpolator.nonTruncatedEnd;\n+        nonTruncatedH   = interpolator.nonTruncatedH;\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected StepInterpolator doCopy() {\n+        return new AdamsBashforthStepInterpolator(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected void initializeCoefficients() {\n+\n+        neville  = new double[previousF.length];\n+        rollback = new double[previousF.length];\n+\n+        bdArray = AdamsBashforthIntegrator.computeBackwardDifferencesArray(previousF.length);\n+\n+        Fraction[] fGamma = AdamsBashforthIntegrator.computeGammaArray(previousF.length);\n+        gamma = new double[fGamma.length];\n+        for (int i = 0; i < fGamma.length; ++i) {\n+            gamma[i] = fGamma[i].doubleValue();\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void storeTime(final double t) {\n+        nonTruncatedEnd = t;\n+        nonTruncatedH   = nonTruncatedEnd - previousTime;\n+        super.storeTime(t);\n+    }\n+\n+    /** Truncate a step.\n+     * <p>Truncating a step is necessary when an event is triggered\n+     * before the nominal end of the step.</p>\n+     * @param truncatedEndTime end time of truncated step\n+     */\n+    void truncateStep(final double truncatedEndTime) {\n+        currentTime = truncatedEndTime;\n+        h = currentTime - previousTime;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setInterpolatedTime(final double time)\n+        throws DerivativeException {\n+        interpolatedTime = time;\n+        final double oneMinusThetaH = nonTruncatedEnd - interpolatedTime;\n+        final double theta = (nonTruncatedH == 0) ?\n+                             0 : (nonTruncatedH - oneMinusThetaH) / nonTruncatedH;\n+        computeInterpolatedState(theta, oneMinusThetaH);\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected void computeInterpolatedState(final double theta, final double oneMinusThetaH) {\n+        interpolateDerivatives();\n+        interpolateState(theta);\n+    }\n+\n+    /** Interpolate the derivatives.\n+     * <p>The Adams method is based on a polynomial interpolation of the\n+     * derivatives based on the preceding steps. So the interpolation of\n+     * the derivatives here is strictly equivalent: it is a simple polynomial\n+     * interpolation.</p>\n+     */\n+    private void interpolateDerivatives() {\n+\n+        for (int i = 0; i < interpolatedDerivatives.length; ++i) {\n+\n+            // initialize the Neville's interpolation algorithm\n+            for (int k = 0; k < previousF.length; ++k) {\n+                neville[k] = previousF[k][i];\n+            }\n+\n+            // combine the contributions of each points\n+            for (int l = 1; l < neville.length; ++l) {\n+                for (int m = neville.length - 1; m >= l; --m) {\n+                    final double xm   = previousT[m];\n+                    final double xmMl = previousT[m - l];\n+                    neville[m] = ((interpolatedTime - xm) * neville[m-1] +\n+                                  (xmMl - interpolatedTime) * neville[m]) / (xmMl - xm);\n+                }\n+            }\n+\n+            // the interpolation polynomial value is in the array last element\n+            interpolatedDerivatives[i] = neville[neville.length - 1];\n+\n+        }\n+\n+    }\n+\n+    /** Interpolate the state.\n+     * <p>The Adams method is based on a polynomial interpolation of the\n+     * derivatives based on the preceding steps. The polynomial model is\n+     * integrated analytically throughout the last step. Using the notations\n+     * found in the second edition of the first volume (Nonstiff Problems)\n+     * of the reference book by Hairer, Norsett and Wanner: <i>Solving Ordinary\n+     * Differential Equations</i> (Springer-Verlag, ISBN 3-540-56670-8), this\n+     * process leads to the following expression:</p>\n+     * <pre>\n+     * y<sub>n+1</sub> = y<sub>n</sub> +\n+     * h &times; &sum;<sub>j=0</sub><sup>j=k-1</sup> &gamma;<sub>j</sub>&nabla;<sup>j</sup>f<sub>n</sub>\n+     * </pre>\n+     * <p>In the previous expression, the &gamma;<sub>j</sub> terms are the\n+     * ones that result from the analytical integration, and can be computed form\n+     * the binomial coefficients C<sub>j</sub><sup>-s</sup>:</p>\n+     * <p>\n+     * &gamma;<sub>j</sub> = (-1)<sup>j</sup>&int;<sub>0</sub><sup>1</sup>C<sub>j</sub><sup>-s</sup>ds\n+     * </p>\n+     * <p>In order to interpolate the state in a manner that is consistent with the\n+     * integration scheme, we simply subtract from the current state (at the end of the step)\n+     * the integral computed from interpolation time to step end time.</p>\n+     * <p>\n+     * &eta;<sub>j</sub>(&theta;)=\n+     * (-1)<sup>j</sup>&int;<sub>&theta;</sub><sup>1</sup>C<sub>j</sub><sup>-s</sup>ds\n+     * </p>\n+     * The method described in the Hairer, Norsett and Wanner book to compute &gamma;<sub>j</sub>\n+     * is easily extended to compute &gamma;<sub>j</sub>(&theta;)=\n+     * (-1)<sup>j</sup>&int;<sub>0</sub><sup>&theta;</sup>C<sub>j</sub><sup>-s</sup>ds. From this,\n+     * we can compute &eta;<sub>j</sub>(&theta;) = &gamma;<sub>j</sub>-&gamma;<sub>j</sub>(&theta;).\n+     * The first few values are:</p>\n+     * <table>\n+     * <tr><td>j</td><td>&gamma;<sub>j</sub></td><td>&gamma;<sub>j</sub>(&theta;)</td><td>&eta;<sub>j</sub>(&theta;)</td></tr>\n+     * <tr><td>0</td><td>1</td><td></td>&theta;<td>1-&theta;</td></tr>\n+     * <tr><td>1</td><td>1/2</td><td></td>&theta;<sup>2</sup>/2<td>(1-&theta;<sup>2</sup>)/2</td></tr>\n+     * <tr><td>2</td><td>5/12</td><td></td>(3&theta;<sup>2</sup>+2&theta;<sup>3</sup>)/12<td>(5-3&theta;<sup>2</sup>-2&theta;<sup>3</sup>)/12</td></tr>\n+     * </table>\n+     * <p>\n+     * The &eta;<sub>j</sub>(&theta;) functions appear to be polynomial ones. As expected,\n+     * we see that &eta;<sub>j</sub>(1)= 0. The recurrence relation derived for\n+     * &gamma;<sub>j</sub>(&theta;) is:\n+     * </p>\n+     * <p>\n+     * &sum<sub>j=0</sub><sup>j=m</sup>&gamma;<sub>j</sub>(&theta;)/(m+1-j) =\n+     * 1/(m+1)! &prod;<sub>k=0</sub><sup>k=m</sup>(&theta;+k)\n+     * </p>\n+     * @param theta location of the interpolation point within the last step\n+     */\n+    private void interpolateState(final double theta) {\n+\n+        // compute the integrals to remove from the final state\n+        computeRollback(previousT.length - 1, theta);\n+\n+        // remove these integrals from the final state\n+        for (int j = 0; j < interpolatedState.length; ++j) {\n+            double sum = 0;\n+            for (int l = 0; l < previousT.length; ++l) {\n+                sum += rollback[l] * previousF[l][j];\n+            }\n+            interpolatedState[j] = currentState[j] - h * sum;\n+        }\n+\n+    }\n+\n+    /** Compute the rollback coefficients.\n+     * @param order order of the integration method\n+     * @param theta current value for theta\n+     */\n+    private void computeRollback(final int order, final double theta) {\n+\n+        // compute the gamma(theta) values from the recurrence relation\n+        double product = theta;\n+        rollback[0]  = theta;\n+        for (int i = 1; i < order; ++i) {\n+            product *= (i + theta) / (i + 1);\n+            double g = product;\n+            for (int j = 1; j <= i; ++j) {\n+                g -= rollback[i - j] / (j + 1);\n+            }\n+            rollback[i] = g;\n+        }\n+\n+        // subtract it from gamma to get eta(theta)\n+        for (int i = 0; i < order; ++i) {\n+            rollback[i] -= gamma[i];\n+        }\n+\n+        // combine the eta integrals with the backward differences array\n+        // to get the rollback coefficients\n+        for (int i = 0; i < order; ++i) {\n+            double f = 0;\n+            for (int j = i; j <= order; ++j) {\n+                f -= rollback[j] * bdArray[j][i];\n+            }\n+            rollback[i] = f;\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void writeExternal(final ObjectOutput out)\n+        throws IOException {\n+        super.writeExternal(out);\n+        out.writeDouble(nonTruncatedEnd);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void readExternal(final ObjectInput in)\n+        throws IOException {\n+        nonTruncatedEnd = in.readDouble();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+\n+/**\n+ * This class implements implicit Adams-Moulton integrators for Ordinary\n+ * Differential Equations.\n+ *\n+ * <p>Adams-Moulton (in fact due to Adams alone) methods are implicit\n+ * multistep ODE solvers witch fixed stepsize. The value of state vector\n+ * at step n+1 is a simple combination of the value at step n and of the\n+ * derivatives at steps n+1, n, n-1 ... Depending on the number k of previous\n+ * steps one wants to use for computing the next value, different formulas\n+ * are available:</p>\n+ * <ul>\n+ *   <li>k = 0: y<sub>n+1</sub> = y<sub>n</sub> + h f<sub>n+1</sub></li>\n+ *   <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + h (f<sub>n+1</sub>+f<sub>n</sub>)/2</li>\n+ *   <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + h (5f<sub>n+1</sub>+8f<sub>n</sub>-f<sub>n-1</sub>)/12</li>\n+ *   <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + h (9f<sub>n+1</sub>+19f<sub>n</sub>-5f<sub>n-1</sub>+f<sub>n-2)/24</sub></li>\n+ *   <li>...</li>\n+ * </ul>\n+ *\n+ * <p>A k-steps Adams-Moulton method is of order k+1. There is no limit to the\n+ * value of k.</p>\n+ *\n+ * <p>These methods are implicit: f<sub>n+1</sub> is used to compute\n+ * y<sub>n+1</sub>. Simpler explicit Adams methods exist: the\n+ * Adams-Bashforth methods (which are also due to Adams alone). They are\n+ * provided by the {@link AdamsBashforthIntegrator AdamsBashforthIntegrator} class.</p>\n+ *\n+ * @see AdamsBashforthIntegrator\n+ * @see BDFIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class AdamsMoultonIntegrator extends MultistepIntegrator {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 4990335331377040417L;\n+\n+    /** Integrator method name. */\n+    private static final String METHOD_NAME = \"Adams-Moulton\";\n+\n+    /** Coefficients for the predictor phase of the method. */\n+    private final double[] predictorCoeffs;\n+\n+    /** Coefficients for the corrector phase of the method. */\n+    private final double[] correctorCoeffs;\n+\n+    /** Integration step. */\n+    private final double step;\n+\n+    /**\n+     * Build an Adams-Moulton integrator with the given order and step size.\n+     * @param order order of the method (must be strictly positive)\n+     * @param step integration step size\n+     */\n+    public AdamsMoultonIntegrator(final int order, final double step) {\n+\n+        super(METHOD_NAME, order + 1, new AdamsMoultonStepInterpolator());\n+\n+        // compute the integration coefficients\n+        int[][] bdArray      = AdamsBashforthIntegrator.computeBackwardDifferencesArray(order + 1);\n+\n+        Fraction[] gamma     = AdamsBashforthIntegrator.computeGammaArray(order);\n+        predictorCoeffs = new double[order];\n+        for (int i = 0; i < order; ++i) {\n+            Fraction fPredictor = Fraction.ZERO;\n+            for (int j = i; j < order; ++j) {\n+                Fraction f = new Fraction(bdArray[j][i], 1);\n+                fPredictor = fPredictor.add(gamma[j].multiply(f));\n+            }\n+            predictorCoeffs[i] = fPredictor.doubleValue();\n+        }\n+\n+        Fraction[] gammaStar = computeGammaStarArray(order);\n+        correctorCoeffs = new double[order + 1];\n+        for (int i = 0; i <= order; ++i) {\n+            Fraction fCorrector = Fraction.ZERO;\n+            for (int j = i; j <= order; ++j) {\n+                Fraction f = new Fraction(bdArray[j][i], 1);\n+                fCorrector = fCorrector.add(gammaStar[j].multiply(f));\n+            }\n+            correctorCoeffs[i] = fCorrector.doubleValue();\n+        }\n+\n+        this.step = Math.abs(step);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double integrate(FirstOrderDifferentialEquations equations,\n+                            double t0, double[] y0, double t, double[] y)\n+        throws DerivativeException, IntegratorException {\n+\n+        sanityChecks(equations, t0, y0, t, y);\n+        final boolean forward = (t > t0);\n+\n+        // initialize working arrays\n+        if (y != y0) {\n+            System.arraycopy(y0, 0, y, 0, y0.length);\n+        }\n+        final double[] yTmp = new double[y0.length];\n+\n+        // set up an interpolator sharing the integrator arrays\n+        final AdamsMoultonStepInterpolator interpolator =\n+                (AdamsMoultonStepInterpolator) prototype.copy();\n+        interpolator.reinitialize(yTmp, previousT, previousF, forward);\n+\n+        // set up integration control objects\n+        stepStart = t0;\n+        stepSize  = forward ? step : -step;\n+        for (StepHandler handler : stepHandlers) {\n+            handler.reset();\n+        }\n+        CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n+\n+        // compute the first few steps using the configured starter integrator\n+        double stopTime =\n+            start(previousF.length - 1, stepSize, manager, equations, stepStart, y);\n+        if (Double.isNaN(previousT[0])) {\n+            return stopTime;\n+        }\n+        stepStart = previousT[0];\n+        rotatePreviousSteps();\n+        previousF[0] = new double[y0.length];\n+        interpolator.storeTime(stepStart);\n+\n+        boolean lastStep = false;\n+        while (!lastStep) {\n+\n+            // shift all data\n+            interpolator.shift();\n+\n+            // predict state at end of step\n+            for (int j = 0; j < y0.length; ++j) {\n+                double sum = 0;\n+                for (int l = 0; l < predictorCoeffs.length; ++l) {\n+                    sum += predictorCoeffs[l] * previousF[l+1][j];\n+                }\n+                yTmp[j] = y[j] + stepSize * sum;\n+            }\n+\n+            // evaluate the derivatives\n+            final double stepEnd = stepStart + stepSize;\n+            equations.computeDerivatives(stepEnd, yTmp, previousF[0]);\n+\n+            // apply corrector\n+            for (int j = 0; j < y0.length; ++j) {\n+                double sum = 0;\n+                for (int l = 0; l < correctorCoeffs.length; ++l) {\n+                    sum += correctorCoeffs[l] * previousF[l][j];\n+                }\n+                yTmp[j] = y[j] + stepSize * sum;\n+            }\n+\n+            // discrete events handling\n+            interpolator.storeTime(stepEnd);\n+            final boolean truncated;\n+            if (manager.evaluateStep(interpolator)) {\n+                truncated = true;\n+                interpolator.truncateStep(manager.getEventTime());\n+            } else {\n+                truncated = false;\n+            }\n+\n+            // the step has been accepted (may have been truncated)\n+            final double nextStep = interpolator.getCurrentTime();\n+            interpolator.setInterpolatedTime(nextStep);\n+            System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, y0.length);\n+            manager.stepAccepted(nextStep, y);\n+            lastStep = manager.stop();\n+\n+            // provide the step data to the step handler\n+            for (StepHandler handler : stepHandlers) {\n+                handler.handleStep(interpolator, lastStep);\n+            }\n+            stepStart = nextStep;\n+\n+            if (!lastStep) {\n+                // prepare next step\n+\n+                if (manager.reset(stepStart, y)) {\n+\n+                    // some events handler has triggered changes that\n+                    // invalidate the derivatives, we need to restart from scratch\n+                    stopTime =\n+                        start(previousF.length - 1, stepSize, manager, equations, stepStart, y);\n+                    if (Double.isNaN(previousT[0])) {\n+                        return stopTime;\n+                    }\n+                    stepStart = previousT[0];\n+                    rotatePreviousSteps();\n+                    previousF[0] = new double[y0.length];\n+\n+                } else {\n+\n+                    if (truncated) {\n+                        // the step has been truncated, we need to adjust the previous steps\n+                        for (int i = 1; i < previousF.length; ++i) {\n+                            previousT[i] = stepStart - i * stepSize;\n+                            interpolator.setInterpolatedTime(previousT[i]);\n+                            System.arraycopy(interpolator.getInterpolatedState(), 0,\n+                                             previousF[i], 0, y0.length);\n+                        }\n+                    } else {\n+                        rotatePreviousSteps();\n+                    }\n+\n+                    // evaluate differential equations for next step\n+                    previousT[0] = stepStart;\n+                    equations.computeDerivatives(stepStart, y, previousF[0]);\n+\n+                }\n+            }\n+\n+        }\n+\n+        stopTime  = stepStart;\n+        stepStart = Double.NaN;\n+        stepSize  = Double.NaN;\n+        return stopTime;\n+\n+    }\n+\n+    /** Get the coefficients of the predictor phase of the method.\n+     * <p>The coefficients are the c<sub>i</sub> terms in the following formula:</p>\n+     * <pre>\n+     *   y<sub>n+1</sub> = y<sub>n</sub> + h &times; &sum;<sub>i=0</sub><sup>i=k-1</sup> c<sub>i</sub>f<sub>n-i</sub></li>\n+     * </pre>\n+     * @return a copy of the coefficients of the method\n+     */\n+    public double[] getPredictorCoeffs() {\n+        return predictorCoeffs.clone();\n+    }\n+\n+    /** Get the coefficients of the corrector phase of the method.\n+     * <p>The coefficients are the c<sub>i</sub> terms in the following formula:</p>\n+     * <pre>\n+     *   y<sub>n+1</sub> = y<sub>n</sub> + h &times; &sum;<sub>i=0</sub><sup>i=k</sup> c<sub>i</sub>f<sub>n-i</sub></li>\n+     * </pre>\n+     * @return a copy of the coefficients of the method\n+     */\n+    public double[] getCorrectorCoeffs() {\n+        return correctorCoeffs.clone();\n+    }\n+\n+    /** Compute the gamma star coefficients.\n+     * @param order order of the integration method\n+     * @return gamma star coefficients array\n+     */\n+    static Fraction[] computeGammaStarArray(final int order) {\n+\n+        // create the array\n+        Fraction[] gammaStarArray = new Fraction[order + 1];\n+\n+        // recurrence initialization\n+        gammaStarArray[0] = Fraction.ONE;\n+\n+        // fill up array using recurrence relation\n+        for (int i = 1; i <= order; ++i) {\n+            Fraction gammaStar = Fraction.ZERO;\n+            for (int j = 1; j <= i; ++j) {\n+                gammaStar = gammaStar.subtract(gammaStarArray[i - j].multiply(new Fraction(1, j + 1)));\n+            }\n+            gammaStarArray[i] = gammaStar;\n+        }\n+\n+        return gammaStarArray;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements an interpolator for Adams-Moulton multiple steps.\n+ *\n+ * <p>This interpolator computes dense output inside the last few\n+ * steps computed. The interpolation equation is consistent with the\n+ * integration scheme, it is based on a kind of <em>rollback</em> of the\n+ * integration from step end to interpolation date:\n+ * <pre>\n+ *   y(t<sub>n</sub> + theta h) = y (t<sub>n</sub> + h) - &int;<sub>t<sub>n</sub> + theta h</sub><sup>t<sub>n</sub> + h</sup>p(t)dt\n+ * </pre>\n+ * where theta belongs to [0 ; 1] and p(t) is the interpolation polynomial based on\n+ * the derivatives at previous steps f<sub>n-k+1</sub>, f<sub>n-k+2</sub> ...\n+ * f<sub>n</sub>, f<sub>n</sub> and f<sub>n+1</sub>.</p>\n+ *\n+ * @see AdamsMoultonIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+\n+class AdamsMoultonStepInterpolator extends MultistepStepInterpolator {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 735568489801241899L;\n+\n+    /** Neville's interpolation array. */\n+    private double[] neville;\n+\n+    /** Integration rollback array. */\n+    private double[] rollback;\n+\n+    /** &gamma; star array. */\n+    private double[] gammaStar;\n+\n+    /** Backward differences array. */\n+    private int[][] bdArray;\n+\n+    /** Original non-truncated step end time. */\n+    private double nonTruncatedEnd;\n+\n+    /** Original non-truncated step size. */\n+    private double nonTruncatedH;\n+\n+    /** Simple constructor.\n+     * This constructor builds an instance that is not usable yet, the\n+     * {@link AbstractStepInterpolator#reinitialize} method should be called\n+     * before using the instance in order to initialize the internal arrays. This\n+     * constructor is used only in order to delay the initialization in\n+     * some cases.\n+     */\n+    public AdamsMoultonStepInterpolator() {\n+    }\n+\n+    /** Copy constructor.\n+     * @param interpolator interpolator to copy from. The copy is a deep\n+     * copy: its arrays are separated from the original arrays of the\n+     * instance\n+     */\n+    public AdamsMoultonStepInterpolator(final AdamsMoultonStepInterpolator interpolator) {\n+        super(interpolator);\n+        nonTruncatedEnd = interpolator.nonTruncatedEnd;\n+        nonTruncatedH   = interpolator.nonTruncatedH;\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected StepInterpolator doCopy() {\n+        return new AdamsMoultonStepInterpolator(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected void initializeCoefficients() {\n+\n+        neville  = new double[previousF.length];\n+        rollback = new double[previousF.length];\n+\n+        bdArray = AdamsBashforthIntegrator.computeBackwardDifferencesArray(previousF.length);\n+\n+        Fraction[] fGammaStar = AdamsMoultonIntegrator.computeGammaStarArray(previousF.length);\n+        gammaStar = new double[fGammaStar.length];\n+        for (int i = 0; i < fGammaStar.length; ++i) {\n+            gammaStar[i] = fGammaStar[i].doubleValue();\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void storeTime(final double t) {\n+        nonTruncatedEnd = t;\n+        nonTruncatedH   = nonTruncatedEnd - previousTime;\n+        super.storeTime(t);\n+    }\n+\n+    /** Truncate a step.\n+     * <p>Truncating a step is necessary when an event is triggered\n+     * before the nominal end of the step.</p>\n+     * @param truncatedEndTime end time of truncated step\n+     */\n+    void truncateStep(final double truncatedEndTime) {\n+        currentTime = truncatedEndTime;\n+        h = currentTime - previousTime;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setInterpolatedTime(final double time)\n+        throws DerivativeException {\n+        interpolatedTime = time;\n+        final double oneMinusThetaH = nonTruncatedEnd - interpolatedTime;\n+        final double theta = (nonTruncatedH == 0) ?\n+                             0 : (nonTruncatedH - oneMinusThetaH) / nonTruncatedH;\n+        computeInterpolatedState(theta, oneMinusThetaH);\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected void computeInterpolatedState(final double theta, final double oneMinusThetaH) {\n+        interpolateDerivatives();\n+        interpolateState(theta);\n+    }\n+\n+    /** Interpolate the derivatives.\n+     * <p>The Adams method is based on a polynomial interpolation of the\n+     * derivatives based on the preceding steps. So the interpolation of\n+     * the derivatives here is strictly equivalent: it is a simple polynomial\n+     * interpolation.</p>\n+     */\n+    private void interpolateDerivatives() {\n+\n+        for (int i = 0; i < interpolatedDerivatives.length; ++i) {\n+\n+            // initialize the Neville's interpolation algorithm\n+            for (int k = 0; k < previousF.length; ++k) {\n+                neville[k] = previousF[k][i];\n+            }\n+\n+            // combine the contributions of each points\n+            for (int l = 1; l < neville.length; ++l) {\n+                for (int m = neville.length - 1; m >= l; --m) {\n+                    final double xm   = previousT[m];\n+                    final double xmMl = previousT[m - l];\n+                    neville[m] = ((interpolatedTime - xm) * neville[m-1] +\n+                                  (xmMl - interpolatedTime) * neville[m]) / (xmMl - xm);\n+                }\n+            }\n+\n+            // the interpolation polynomial value is in the array last element\n+            interpolatedDerivatives[i] = neville[neville.length - 1];\n+\n+        }\n+\n+    }\n+\n+    /** Interpolate the state.\n+     * <p>The Adams method is based on a polynomial interpolation of the\n+     * derivatives based on the preceding steps. The polynomial model is\n+     * integrated analytically throughout the last step. Using the notations\n+     * found in the second edition of the first volume (Nonstiff Problems)\n+     * of the reference book by Hairer, Norsett and Wanner: <i>Solving Ordinary\n+     * Differential Equations</i> (Springer-Verlag, ISBN 3-540-56670-8), this\n+     * process leads to the following expression:</p>\n+     * <pre>\n+     * y<sub>n+1</sub> = y<sub>n</sub> +\n+     * h &times; &sum;<sub>j=0</sub><sup>j=k</sup> &gamma;<sub>j</sub><sup>*</sup>&nabla;<sup>j</sup>f<sub>n+1</sub>\n+     * </pre>\n+     * <p>In the previous expression, the &gamma;<sub>j</sub><sup>*</sup> terms are the\n+     * ones that result from the analytical integration, and can be computed form\n+     * the binomial coefficients C<sub>j</sub><sup>-s</sup>:</p>\n+     * <p>\n+     * &gamma;<sub>j</sub><sup>*</sup> = (-1)<sup>j</sup>&int;<sub>0</sub><sup>1</sup>C<sub>j</sub><sup>1-s</sup>ds\n+     * </p>\n+     * <p>In order to interpolate the state in a manner that is consistent with the\n+     * integration scheme, we simply subtract from the current state (at the end of the step)\n+     * the integral computed from interpolation time to step end time.</p>\n+     * <p>\n+     * &eta;<sub>j</sub><sup>*</sup>(&theta;)=\n+     * (-1)<sup>j</sup>&int;<sub>&theta;</sub><sup>1</sup>C<sub>j</sub><sup>1-s</sup>ds\n+     * </p>\n+     * The method described in the Hairer, Norsett and Wanner book to compute &gamma;<sub>j</sub><sup>*</sup>\n+     * is easily extended to compute &gamma;<sub>j</sub><sup>*</sup>(&theta;)=\n+     * (-1)<sup>j</sup>&int;<sub>0</sub><sup>&theta;</sup>C<sub>j</sub><sup>1-s</sup>ds. From this,\n+     * we can compute &eta;<sub>j</sub><sup>*</sup>(&theta;) =\n+     * &gamma;<sub>j</sub><sup>*</sup>-&gamma;<sub>j</sub><sup>*</sup>(&theta;).\n+     * The first few values are:</p>\n+     * <table>\n+     * <tr><td>j</td><td>&gamma;<sub>j</sub><sup>*</sup></td><td>&gamma;<sub>j</sub><sup>*</sup>(&theta;)</td><td>&eta;<sub>j</sub><sup>*</sup>(&theta;)</td></tr>\n+     * <tr><td>0</td><td>1</td><td>&theta;</td><td>1-&theta;</td></tr>\n+     * <tr><td>1</td><td>-1/2</td><td>(&theta;<sup>2</sup>-2&theta;)/2</td><td>(-1+2&theta;-&theta;<sup>2</sup>)/2</td></tr>\n+     * <tr><td>2</td><td>-1/12</td><td>(2&theta;<sup>3</sup>-3&theta;<sup>2</sup>)/12</td><td>(-1+3&theta;<sup>2</sup>-2&theta;<sup>3</sup>)/12</td></tr>\n+     * </table>\n+     * <p>\n+     * The &eta;<sub>j</sub>(&theta;) functions appear to be polynomial ones. As expected,\n+     * we see that &eta;<sub>j</sub>(1)= 0. The recurrence relation derived for\n+     * &gamma;<sub>j</sub>(&theta;) is:\n+     * </p>\n+     * <p>\n+     * &sum<sub>j=0</sub><sup>j=m</sup>&gamma;<sub>j</sub><sup>*</sup>(&theta;)/(m+1-j) =\n+     * 1/(m+1)! &prod;<sub>k=0</sub><sup>k=m</sup>(&theta;+k-1)\n+     * </p>\n+     * @param theta location of the interpolation point within the last step\n+     */\n+    private void interpolateState(final double theta) {\n+\n+        // compute the integrals to remove from the final state\n+        computeRollback(previousT.length - 1, theta);\n+\n+        // remove these integrals from the final state\n+        for (int j = 0; j < interpolatedState.length; ++j) {\n+            double sum = 0;\n+            for (int l = 0; l < previousT.length; ++l) {\n+                sum += rollback[l] * previousF[l][j];\n+            }\n+            interpolatedState[j] = currentState[j] - h * sum;\n+        }\n+\n+    }\n+\n+    /** Compute the rollback coefficients.\n+     * @param order order of the integration method\n+     * @param theta current value for theta\n+     */\n+    private void computeRollback(final int order, final double theta) {\n+\n+        // compute the gamma star(theta) values from the recurrence relation\n+        double product = theta - 1;\n+        rollback[0]  = theta;\n+        for (int i = 1; i <= order; ++i) {\n+            product *= (i - 1 + theta) / (i + 1);\n+            double gStar = product;\n+            for (int j = 1; j <= i; ++j) {\n+                gStar -= rollback[i - j] / (j + 1);\n+            }\n+            rollback[i] = gStar;\n+        }\n+\n+        // subtract it from gamma star to get eta star(theta)\n+        for (int i = 0; i <= order; ++i) {\n+            rollback[i] -= gammaStar[i];\n+        }\n+\n+        // combine the eta star integrals with the backward differences array\n+        // to get the rollback coefficients\n+        for (int i = 0; i <= order; ++i) {\n+            double f = 0;\n+            for (int j = i; j <= order; ++j) {\n+                f -= rollback[j] * bdArray[j][i];\n+            }\n+            rollback[i] = f;\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void writeExternal(final ObjectOutput out)\n+        throws IOException {\n+        super.writeExternal(out);\n+        out.writeDouble(nonTruncatedEnd);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void readExternal(final ObjectInput in)\n+        throws IOException {\n+        nonTruncatedEnd = in.readDouble();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.AbstractIntegrator;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+\n+/**\n+ * This abstract class holds the common part of all adaptive\n+ * stepsize integrators for Ordinary Differential Equations.\n+ *\n+ * <p>These algorithms perform integration with stepsize control, which\n+ * means the user does not specify the integration step but rather a\n+ * tolerance on error. The error threshold is computed as\n+ * <pre>\n+ * threshold_i = absTol_i + relTol_i * max (abs (ym), abs (ym+1))\n+ * </pre>\n+ * where absTol_i is the absolute tolerance for component i of the\n+ * state vector and relTol_i is the relative tolerance for the same\n+ * component. The user can also use only two scalar values absTol and\n+ * relTol which will be used for all components.</p>\n+ *\n+ * <p>If the estimated error for ym+1 is such that\n+ * <pre>\n+ * sqrt((sum (errEst_i / threshold_i)^2 ) / n) < 1\n+ * </pre>\n+ *\n+ * (where n is the state vector dimension) then the step is accepted,\n+ * otherwise the step is rejected and a new attempt is made with a new\n+ * stepsize.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ *\n+ */\n+\n+public abstract class AdaptiveStepsizeIntegrator\n+  extends AbstractIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -6883579828273958419L;\n+\n+  /** Build an integrator with the given stepsize bounds.\n+   * The default step handler does nothing.\n+   * @param name name of the method\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public AdaptiveStepsizeIntegrator(final String name,\n+                                    final double minStep, final double maxStep,\n+                                    final double scalAbsoluteTolerance,\n+                                    final double scalRelativeTolerance) {\n+\n+    super(name);\n+\n+    this.minStep     = Math.abs(minStep);\n+    this.maxStep     = Math.abs(maxStep);\n+    this.initialStep = -1.0;\n+\n+    this.scalAbsoluteTolerance = scalAbsoluteTolerance;\n+    this.scalRelativeTolerance = scalRelativeTolerance;\n+    this.vecAbsoluteTolerance  = null;\n+    this.vecRelativeTolerance  = null;\n+\n+    resetInternalState();\n+\n+  }\n+\n+  /** Build an integrator with the given stepsize bounds.\n+   * The default step handler does nothing.\n+   * @param name name of the method\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public AdaptiveStepsizeIntegrator(final String name,\n+                                    final double minStep, final double maxStep,\n+                                    final double[] vecAbsoluteTolerance,\n+                                    final double[] vecRelativeTolerance) {\n+\n+    super(name);\n+\n+    this.minStep     = minStep;\n+    this.maxStep     = maxStep;\n+    this.initialStep = -1.0;\n+\n+    this.scalAbsoluteTolerance = 0;\n+    this.scalRelativeTolerance = 0;\n+    this.vecAbsoluteTolerance  = vecAbsoluteTolerance;\n+    this.vecRelativeTolerance  = vecRelativeTolerance;\n+\n+    resetInternalState();\n+\n+  }\n+\n+  /** Set the initial step size.\n+   * <p>This method allows the user to specify an initial positive\n+   * step size instead of letting the integrator guess it by\n+   * itself. If this method is not called before integration is\n+   * started, the initial step size will be estimated by the\n+   * integrator.</p>\n+   * @param initialStepSize initial step size to use (must be positive even\n+   * for backward integration ; providing a negative value or a value\n+   * outside of the min/max step interval will lead the integrator to\n+   * ignore the value and compute the initial step size by itself)\n+   */\n+  public void setInitialStepSize(final double initialStepSize) {\n+    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n+      initialStep = -1.0;\n+    } else {\n+      initialStep = initialStepSize;\n+    }\n+  }\n+\n+  /** Perform some sanity checks on the integration parameters.\n+   * @param equations differential equations set\n+   * @param t0 start time\n+   * @param y0 state vector at t0\n+   * @param t target time for the integration\n+   * @param y placeholder where to put the state vector\n+   * @exception IntegratorException if some inconsistency is detected\n+   */\n+  protected void sanityChecks(final FirstOrderDifferentialEquations equations,\n+                              final double t0, final double[] y0,\n+                              final double t, final double[] y)\n+      throws IntegratorException {\n+\n+      super.sanityChecks(equations, t0, y0, t, y);\n+\n+      if ((vecAbsoluteTolerance != null) && (vecAbsoluteTolerance.length != y0.length)) {\n+          throw new IntegratorException(\"dimensions mismatch: state vector has dimension {0},\" +\n+                                        \" absolute tolerance vector has dimension {1}\",\n+                                        new Object[] {\n+                                          Integer.valueOf(y0.length),\n+                                          Integer.valueOf(vecAbsoluteTolerance.length)\n+                                        });\n+      }\n+\n+      if ((vecRelativeTolerance != null) && (vecRelativeTolerance.length != y0.length)) {\n+          throw new IntegratorException(\"dimensions mismatch: state vector has dimension {0},\" +\n+                                        \" relative tolerance vector has dimension {1}\",\n+                                        new Object[] {\n+                                          Integer.valueOf(y0.length),\n+                                          Integer.valueOf(vecRelativeTolerance.length)\n+                                        });\n+      }\n+\n+  }\n+\n+  /** Initialize the integration step.\n+   * @param equations differential equations set\n+   * @param forward forward integration indicator\n+   * @param order order of the method\n+   * @param scale scaling vector for the state vector\n+   * @param t0 start time\n+   * @param y0 state vector at t0\n+   * @param yDot0 first time derivative of y0\n+   * @param y1 work array for a state vector\n+   * @param yDot1 work array for the first time derivative of y1\n+   * @return first integration step\n+   * @exception DerivativeException this exception is propagated to\n+   * the caller if the underlying user function triggers one\n+   */\n+  public double initializeStep(final FirstOrderDifferentialEquations equations,\n+                               final boolean forward, final int order, final double[] scale,\n+                               final double t0, final double[] y0, final double[] yDot0,\n+                               final double[] y1, final double[] yDot1)\n+      throws DerivativeException {\n+\n+    if (initialStep > 0) {\n+      // use the user provided value\n+      return forward ? initialStep : -initialStep;\n+    }\n+\n+    // very rough first guess : h = 0.01 * ||y/scale|| / ||y'/scale||\n+    // this guess will be used to perform an Euler step\n+    double ratio;\n+    double yOnScale2 = 0;\n+    double yDotOnScale2 = 0;\n+    for (int j = 0; j < y0.length; ++j) {\n+      ratio         = y0[j] / scale[j];\n+      yOnScale2    += ratio * ratio;\n+      ratio         = yDot0[j] / scale[j];\n+      yDotOnScale2 += ratio * ratio;\n+    }\n+\n+    double h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10)) ?\n+               1.0e-6 : (0.01 * Math.sqrt(yOnScale2 / yDotOnScale2));\n+    if (! forward) {\n+      h = -h;\n+    }\n+\n+    // perform an Euler step using the preceding rough guess\n+    for (int j = 0; j < y0.length; ++j) {\n+      y1[j] = y0[j] + h * yDot0[j];\n+    }\n+    equations.computeDerivatives(t0 + h, y1, yDot1);\n+\n+    // estimate the second derivative of the solution\n+    double yDDotOnScale = 0;\n+    for (int j = 0; j < y0.length; ++j) {\n+      ratio         = (yDot1[j] - yDot0[j]) / scale[j];\n+      yDDotOnScale += ratio * ratio;\n+    }\n+    yDDotOnScale = Math.sqrt(yDDotOnScale) / h;\n+\n+    // step size is computed such that\n+    // h^order * max (||y'/tol||, ||y''/tol||) = 0.01\n+    final double maxInv2 = Math.max(Math.sqrt(yDotOnScale2), yDDotOnScale);\n+    final double h1 = (maxInv2 < 1.0e-15) ?\n+                      Math.max(1.0e-6, 0.001 * Math.abs(h)) :\n+                      Math.pow(0.01 / maxInv2, 1.0 / order);\n+    h = Math.min(100.0 * Math.abs(h), h1);\n+    h = Math.max(h, 1.0e-12 * Math.abs(t0));  // avoids cancellation when computing t1 - t0\n+    if (h < getMinStep()) {\n+      h = getMinStep();\n+    }\n+    if (h > getMaxStep()) {\n+      h = getMaxStep();\n+    }\n+    if (! forward) {\n+      h = -h;\n+    }\n+\n+    return h;\n+\n+  }\n+\n+  /** Filter the integration step.\n+   * @param h signed step\n+   * @param forward forward integration indicator\n+   * @param acceptSmall if true, steps smaller than the minimal value\n+   * are silently increased up to this value, if false such small\n+   * steps generate an exception\n+   * @return a bounded integration step (h if no bound is reach, or a bounded value)\n+   * @exception IntegratorException if the step is too small and acceptSmall is false\n+   */\n+  protected double filterStep(final double h, final boolean forward, final boolean acceptSmall)\n+    throws IntegratorException {\n+\n+      double filteredH = h;\n+      if (Math.abs(h) < minStep) {\n+          if (acceptSmall) {\n+              filteredH = forward ? minStep : -minStep;\n+          } else {\n+              throw new IntegratorException(\"minimal step size ({0}) reached,\" +\n+                                            \" integration needs {1}\",\n+                                            new Object[] {\n+                                                Double.valueOf(minStep),\n+                                                Double.valueOf(Math.abs(h))\n+                                            });\n+          }\n+      }\n+\n+      if (filteredH > maxStep) {\n+          filteredH = maxStep;\n+      } else if (filteredH < -maxStep) {\n+          filteredH = -maxStep;\n+      }\n+\n+      return filteredH;\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public abstract double integrate (FirstOrderDifferentialEquations equations,\n+                                    double t0, double[] y0,\n+                                    double t, double[] y)\n+    throws DerivativeException, IntegratorException;\n+\n+  /** {@inheritDoc} */\n+  public double getCurrentStepStart() {\n+    return stepStart;\n+  }\n+\n+  /** Reset internal state to dummy values. */\n+  protected void resetInternalState() {\n+    stepStart = Double.NaN;\n+    stepSize  = Math.sqrt(minStep * maxStep);\n+  }\n+\n+  /** Get the minimal step.\n+   * @return minimal step\n+   */\n+  public double getMinStep() {\n+    return minStep;\n+  }\n+\n+  /** Get the maximal step.\n+   * @return maximal step\n+   */\n+  public double getMaxStep() {\n+    return maxStep;\n+  }\n+\n+  /** Minimal step. */\n+  private double minStep;\n+\n+  /** Maximal step. */\n+  private double maxStep;\n+\n+  /** User supplied initial step. */\n+  private double initialStep;\n+\n+  /** Allowed absolute scalar error. */\n+  protected double scalAbsoluteTolerance;\n+\n+  /** Allowed relative scalar error. */\n+  protected double scalRelativeTolerance;\n+\n+  /** Allowed absolute vectorial error. */\n+  protected double[] vecAbsoluteTolerance;\n+\n+  /** Allowed relative vectorial error. */\n+  protected double[] vecRelativeTolerance;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class implements the classical fourth order Runge-Kutta\n+ * integrator for Ordinary Differential Equations (it is the most\n+ * often used Runge-Kutta method).\n+ *\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |  0    0    0    0\n+ *   1/2 | 1/2   0    0    0\n+ *   1/2 |  0   1/2   0    0\n+ *    1  |  0    0    1    0\n+ *       |--------------------\n+ *       | 1/6  1/3  1/3  1/6\n+ * </pre>\n+ * </p>\n+ *\n+ * @see EulerIntegrator\n+ * @see GillIntegrator\n+ * @see MidpointIntegrator\n+ * @see ThreeEighthesIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class ClassicalRungeKuttaIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  /** Serializable version identifier. */\n+    private static final long serialVersionUID = 3710070023793519840L;\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] c = {\n+    1.0 / 2.0, 1.0 / 2.0, 1.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] a = {\n+    { 1.0 / 2.0 },\n+    { 0.0, 1.0 / 2.0 },\n+    { 0.0, 0.0, 1.0 }\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] b = {\n+    1.0 / 6.0, 1.0 / 3.0, 1.0 / 3.0, 1.0 / 6.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a fourth-order Runge-Kutta integrator with the given\n+   * step.\n+   * @param step integration step\n+   */\n+  public ClassicalRungeKuttaIntegrator(final double step) {\n+    super(\"classical Runge-Kutta\", c, a, b,\n+          new ClassicalRungeKuttaStepInterpolator(), step);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements a step interpolator for the classical fourth\n+ * order Runge-Kutta integrator.\n+ *\n+ * <p>This interpolator allows to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h)\n+ *                    + (1 - theta) (h/6) [ (-4 theta^2 + 5 theta - 1) y'_1\n+ *                                          +(4 theta^2 - 2 theta - 2) (y'_2 + y'_3)\n+ *                                          -(4 theta^2 +   theta + 1) y'_4\n+ *                                        ]\n+ * </pre>\n+ *\n+ * where theta belongs to [0 ; 1] and where y'_1 to y'_4 are the four\n+ * evaluations of the derivatives already computed during the\n+ * step.</p>\n+ *\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class ClassicalRungeKuttaStepInterpolator\n+    extends RungeKuttaStepInterpolator {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -6576285612589783992L;\n+\n+    /** Simple constructor.\n+     * This constructor builds an instance that is not usable yet, the\n+     * {@link RungeKuttaStepInterpolator#reinitialize} method should be\n+     * called before using the instance in order to initialize the\n+     * internal arrays. This constructor is used only in order to delay\n+     * the initialization in some cases. The {@link RungeKuttaIntegrator}\n+     * class uses the prototyping design pattern to create the step\n+     * interpolators by cloning an uninitialized model and latter initializing\n+     * the copy.\n+     */\n+    public ClassicalRungeKuttaStepInterpolator() {\n+    }\n+\n+    /** Copy constructor.\n+     * @param interpolator interpolator to copy from. The copy is a deep\n+     * copy: its arrays are separated from the original arrays of the\n+     * instance\n+     */\n+    public ClassicalRungeKuttaStepInterpolator(final ClassicalRungeKuttaStepInterpolator interpolator) {\n+        super(interpolator);\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected StepInterpolator doCopy() {\n+        return new ClassicalRungeKuttaStepInterpolator(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected void computeInterpolatedState(final double theta,\n+                                            final double oneMinusThetaH)\n+        throws DerivativeException {\n+\n+        final double fourTheta      = 4 * theta;\n+        final double oneMinusTheta  = 1 - theta;\n+        final double oneMinus2Theta = 1 - 2 * theta;\n+        final double s             = oneMinusThetaH / 6.0;\n+        final double coeff1        = s * ((-fourTheta + 5) * theta - 1);\n+        final double coeff23       = s * (( fourTheta - 2) * theta - 2);\n+        final double coeff4        = s * ((-fourTheta - 1) * theta - 1);\n+        final double coeffDot1     = oneMinusTheta * oneMinus2Theta;\n+        final double coeffDot23    = 2 * theta * oneMinusTheta;\n+        final double coeffDot4     = -theta * oneMinus2Theta;\n+        for (int i = 0; i < interpolatedState.length; ++i) {\n+            final double yDot1  = yDotK[0][i];\n+            final double yDot23 = yDotK[1][i] + yDotK[2][i];\n+            final double yDot4  = yDotK[3][i];\n+            interpolatedState[i] =\n+                currentState[i] + coeff1  * yDot1 + coeff23 * yDot23 + coeff4  * yDot4;\n+            interpolatedDerivatives[i] =\n+                coeffDot1 * yDot1 + coeffDot23 * yDot23 + coeffDot4 * yDot4;\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince54Integrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class implements the 5(4) Dormand-Prince integrator for Ordinary\n+ * Differential Equations.\n+\n+ * <p>This integrator is an embedded Runge-Kutta integrator\n+ * of order 5(4) used in local extrapolation mode (i.e. the solution\n+ * is computed using the high order formula) with stepsize control\n+ * (and automatic step initialization) and continuous output. This\n+ * method uses 7 functions evaluations per step. However, since this\n+ * is an <i>fsal</i>, the last evaluation of one step is the same as\n+ * the first evaluation of the next step and hence can be avoided. So\n+ * the cost is really 6 functions evaluations per step.</p>\n+ *\n+ * <p>This method has been published (whithout the continuous output\n+ * that was added by Shampine in 1986) in the following article :\n+ * <pre>\n+ *  A family of embedded Runge-Kutta formulae\n+ *  J. R. Dormand and P. J. Prince\n+ *  Journal of Computational and Applied Mathematics\n+ *  volume 6, no 1, 1980, pp. 19-26\n+ * </pre></p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class DormandPrince54Integrator\n+  extends EmbeddedRungeKuttaIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -7932553613600031791L;\n+\n+  /** Integrator method name. */\n+  private static final String METHOD_NAME = \"Dormand-Prince 5(4)\";\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] staticC = {\n+    1.0/5.0, 3.0/10.0, 4.0/5.0, 8.0/9.0, 1.0, 1.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] staticA = {\n+    {1.0/5.0},\n+    {3.0/40.0, 9.0/40.0},\n+    {44.0/45.0, -56.0/15.0, 32.0/9.0},\n+    {19372.0/6561.0, -25360.0/2187.0, 64448.0/6561.0,  -212.0/729.0},\n+    {9017.0/3168.0, -355.0/33.0, 46732.0/5247.0, 49.0/176.0, -5103.0/18656.0},\n+    {35.0/384.0, 0.0, 500.0/1113.0, 125.0/192.0, -2187.0/6784.0, 11.0/84.0}\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] staticB = {\n+    35.0/384.0, 0.0, 500.0/1113.0, 125.0/192.0, -2187.0/6784.0, 11.0/84.0, 0.0\n+  };\n+\n+  /** Error array, element 1. */\n+  private static final double e1 =     71.0 / 57600.0;\n+\n+  // element 2 is zero, so it is neither stored nor used\n+\n+  /** Error array, element 3. */\n+  private static final double e3 =    -71.0 / 16695.0;\n+\n+  /** Error array, element 4. */\n+  private static final double e4 =     71.0 / 1920.0;\n+\n+  /** Error array, element 5. */\n+  private static final double e5 = -17253.0 / 339200.0;\n+\n+  /** Error array, element 6. */\n+  private static final double e6 =     22.0 / 525.0;\n+\n+  /** Error array, element 7. */\n+  private static final double e7 =     -1.0 / 40.0;\n+\n+  /** Simple constructor.\n+   * Build a fifth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince54Integrator(final double minStep, final double maxStep,\n+                                   final double scalAbsoluteTolerance,\n+                                   final double scalRelativeTolerance) {\n+    super(METHOD_NAME, true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),\n+          minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a fifth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince54Integrator(final double minStep, final double maxStep,\n+                                   final double[] vecAbsoluteTolerance,\n+                                   final double[] vecRelativeTolerance) {\n+    super(METHOD_NAME, true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),\n+          minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+  }\n+\n+  /** {@inheritDoc} */\n+  public int getOrder() {\n+    return 5;\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected double estimateError(final double[][] yDotK,\n+                                 final double[] y0, final double[] y1,\n+                                 final double h) {\n+\n+    double error = 0;\n+\n+    for (int j = 0; j < y0.length; ++j) {\n+        final double errSum = e1 * yDotK[0][j] +  e3 * yDotK[2][j] +\n+                              e4 * yDotK[3][j] +  e5 * yDotK[4][j] +\n+                              e6 * yDotK[5][j] +  e7 * yDotK[6][j];\n+\n+        final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n+        final double tol = (vecAbsoluteTolerance == null) ?\n+                           (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n+                               (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n+        final double ratio  = h * errSum / tol;\n+        error += ratio * ratio;\n+\n+    }\n+\n+    return Math.sqrt(error / y0.length);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class represents an interpolator over the last step during an\n+ * ODE integration for the 5(4) Dormand-Prince integrator.\n+ *\n+ * @see DormandPrince54Integrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class DormandPrince54StepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link EmbeddedRungeKuttaIntegrator} uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public DormandPrince54StepInterpolator() {\n+    super();\n+    v1 = null;\n+    v2 = null;\n+    v3 = null;\n+    v4 = null;\n+    vectorsInitialized = false;\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public DormandPrince54StepInterpolator(final DormandPrince54StepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    if (interpolator.v1 == null) {\n+\n+      v1 = null;\n+      v2 = null;\n+      v3 = null;\n+      v4 = null;\n+      vectorsInitialized = false;\n+\n+    } else {\n+\n+      v1 = (double[]) interpolator.v1.clone();\n+      v2 = (double[]) interpolator.v2.clone();\n+      v3 = (double[]) interpolator.v3.clone();\n+      v4 = (double[]) interpolator.v4.clone();\n+      vectorsInitialized = interpolator.vectorsInitialized;\n+\n+    }\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected StepInterpolator doCopy() {\n+    return new DormandPrince54StepInterpolator(this);\n+  }\n+\n+\n+  /** {@inheritDoc} */\n+  public void reinitialize(final FirstOrderDifferentialEquations equations,\n+                           final double[] y, final double[][] yDotK, final boolean forward) {\n+    super.reinitialize(equations, y, yDotK, forward);\n+    v1 = null;\n+    v2 = null;\n+    v3 = null;\n+    v4 = null;\n+    vectorsInitialized = false;\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void storeTime(final double t) {\n+    super.storeTime(t);\n+    vectorsInitialized = false;\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected void computeInterpolatedState(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    if (! vectorsInitialized) {\n+\n+      if (v1 == null) {\n+        v1 = new double[interpolatedState.length];\n+        v2 = new double[interpolatedState.length];\n+        v3 = new double[interpolatedState.length];\n+        v4 = new double[interpolatedState.length];\n+      }\n+\n+      // no step finalization is needed for this interpolator\n+\n+      // we need to compute the interpolation vectors for this time step\n+      for (int i = 0; i < interpolatedState.length; ++i) {\n+          final double yDot0 = yDotK[0][i];\n+          final double yDot2 = yDotK[2][i];\n+          final double yDot3 = yDotK[3][i];\n+          final double yDot4 = yDotK[4][i];\n+          final double yDot5 = yDotK[5][i];\n+          final double yDot6 = yDotK[6][i];\n+          v1[i] = a70 * yDot0 + a72 * yDot2 + a73 * yDot3 + a74 * yDot4 + a75 * yDot5;\n+          v2[i] = yDot0 - v1[i];\n+          v3[i] = v1[i] - v2[i] - yDot6;\n+          v4[i] = d0 * yDot0 + d2 * yDot2 + d3 * yDot3 + d4 * yDot4 + d5 * yDot5 + d6 * yDot6;\n+      }\n+\n+      vectorsInitialized = true;\n+\n+    }\n+\n+    // interpolate\n+    final double eta = 1 - theta;\n+    final double twoTheta = 2 * theta;\n+    final double dot2 = 1 - twoTheta;\n+    final double dot3 = theta * (2 - 3 * theta);\n+    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] =\n+          currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n+      interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n+    }\n+\n+  }\n+\n+  /** First vector for interpolation. */\n+  private double[] v1;\n+\n+  /** Second vector for interpolation. */\n+  private double[] v2;\n+\n+  /** Third vector for interpolation. */\n+  private double[] v3;\n+\n+  /** Fourth vector for interpolation. */\n+  private double[] v4;\n+\n+  /** Initialization indicator for the interpolation vectors. */\n+  private boolean vectorsInitialized;\n+\n+  /** Last row of the Butcher-array internal weights, element 0. */\n+  private static final double a70 =    35.0 /  384.0;\n+\n+  // element 1 is zero, so it is neither stored nor used\n+\n+  /** Last row of the Butcher-array internal weights, element 2. */\n+  private static final double a72 =   500.0 / 1113.0;\n+\n+  /** Last row of the Butcher-array internal weights, element 3. */\n+  private static final double a73 =   125.0 /  192.0;\n+\n+  /** Last row of the Butcher-array internal weights, element 4. */\n+  private static final double a74 = -2187.0 / 6784.0;\n+\n+  /** Last row of the Butcher-array internal weights, element 5. */\n+  private static final double a75 =    11.0 /   84.0;\n+\n+  /** Shampine (1986) Dense output, element 0. */\n+  private static final double d0 =  -12715105075.0 /  11282082432.0;\n+\n+  // element 1 is zero, so it is neither stored nor used\n+\n+  /** Shampine (1986) Dense output, element 2. */\n+  private static final double d2 =   87487479700.0 /  32700410799.0;\n+\n+  /** Shampine (1986) Dense output, element 3. */\n+  private static final double d3 =  -10690763975.0 /   1880347072.0;\n+\n+  /** Shampine (1986) Dense output, element 4. */\n+  private static final double d4 =  701980252875.0 / 199316789632.0;\n+\n+  /** Shampine (1986) Dense output, element 5. */\n+  private static final double d5 =   -1453857185.0 /    822651844.0;\n+\n+  /** Shampine (1986) Dense output, element 6. */\n+  private static final double d6 =      69997945.0 /     29380423.0;\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = 4104157279605906956L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class implements the 8(5,3) Dormand-Prince integrator for Ordinary\n+ * Differential Equations.\n+ *\n+ * <p>This integrator is an embedded Runge-Kutta integrator\n+ * of order 8(5,3) used in local extrapolation mode (i.e. the solution\n+ * is computed using the high order formula) with stepsize control\n+ * (and automatic step initialization) and continuous output. This\n+ * method uses 12 functions evaluations per step for integration and 4\n+ * evaluations for interpolation. However, since the first\n+ * interpolation evaluation is the same as the first integration\n+ * evaluation of the next step, we have included it in the integrator\n+ * rather than in the interpolator and specified the method was an\n+ * <i>fsal</i>. Hence, despite we have 13 stages here, the cost is\n+ * really 12 evaluations per step even if no interpolation is done,\n+ * and the overcost of interpolation is only 3 evaluations.</p>\n+ *\n+ * <p>This method is based on an 8(6) method by Dormand and Prince\n+ * (i.e. order 8 for the integration and order 6 for error estimation)\n+ * modified by Hairer and Wanner to use a 5th order error estimator\n+ * with 3rd order correction. This modification was introduced because\n+ * the original method failed in some cases (wrong steps can be\n+ * accepted when step size is too large, for example in the\n+ * Brusselator problem) and also had <i>severe difficulties when\n+ * applied to problems with discontinuities</i>. This modification is\n+ * explained in the second edition of the first volume (Nonstiff\n+ * Problems) of the reference book by Hairer, Norsett and Wanner:\n+ * <i>Solving Ordinary Differential Equations</i> (Springer-Verlag,\n+ * ISBN 3-540-56670-8).</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class DormandPrince853Integrator\n+  extends EmbeddedRungeKuttaIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -8627142100635188441L;\n+\n+  /** Integrator method name. */\n+  private static final String METHOD_NAME = \"Dormand-Prince 8 (5, 3)\";\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] staticC = {\n+    (12.0 - 2.0 * Math.sqrt(6.0)) / 135.0, (6.0 - Math.sqrt(6.0)) / 45.0, (6.0 - Math.sqrt(6.0)) / 30.0,\n+    (6.0 + Math.sqrt(6.0)) / 30.0, 1.0/3.0, 1.0/4.0, 4.0/13.0, 127.0/195.0, 3.0/5.0,\n+    6.0/7.0, 1.0, 1.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] staticA = {\n+\n+    // k2\n+    {(12.0 - 2.0 * Math.sqrt(6.0)) / 135.0},\n+\n+    // k3\n+    {(6.0 - Math.sqrt(6.0)) / 180.0, (6.0 - Math.sqrt(6.0)) / 60.0},\n+\n+    // k4\n+    {(6.0 - Math.sqrt(6.0)) / 120.0, 0.0, (6.0 - Math.sqrt(6.0)) / 40.0},\n+\n+    // k5\n+    {(462.0 + 107.0 * Math.sqrt(6.0)) / 3000.0, 0.0,\n+     (-402.0 - 197.0 * Math.sqrt(6.0)) / 1000.0, (168.0 + 73.0 * Math.sqrt(6.0)) / 375.0},\n+\n+    // k6\n+    {1.0 / 27.0, 0.0, 0.0, (16.0 + Math.sqrt(6.0)) / 108.0, (16.0 - Math.sqrt(6.0)) / 108.0},\n+\n+    // k7\n+    {19.0 / 512.0, 0.0, 0.0, (118.0 + 23.0 * Math.sqrt(6.0)) / 1024.0,\n+     (118.0 - 23.0 * Math.sqrt(6.0)) / 1024.0, -9.0 / 512.0},\n+\n+    // k8\n+    {13772.0 / 371293.0, 0.0, 0.0, (51544.0 + 4784.0 * Math.sqrt(6.0)) / 371293.0,\n+     (51544.0 - 4784.0 * Math.sqrt(6.0)) / 371293.0, -5688.0 / 371293.0, 3072.0 / 371293.0},\n+\n+    // k9\n+    {58656157643.0 / 93983540625.0, 0.0, 0.0,\n+     (-1324889724104.0 - 318801444819.0 * Math.sqrt(6.0)) / 626556937500.0,\n+     (-1324889724104.0 + 318801444819.0 * Math.sqrt(6.0)) / 626556937500.0,\n+     96044563816.0 / 3480871875.0, 5682451879168.0 / 281950621875.0,\n+     -165125654.0 / 3796875.0},\n+\n+    // k10\n+    {8909899.0 / 18653125.0, 0.0, 0.0,\n+     (-4521408.0 - 1137963.0 * Math.sqrt(6.0)) / 2937500.0,\n+     (-4521408.0 + 1137963.0 * Math.sqrt(6.0)) / 2937500.0,\n+     96663078.0 / 4553125.0, 2107245056.0 / 137915625.0,\n+     -4913652016.0 / 147609375.0, -78894270.0 / 3880452869.0},\n+\n+    // k11\n+    {-20401265806.0 / 21769653311.0, 0.0, 0.0,\n+     (354216.0 + 94326.0 * Math.sqrt(6.0)) / 112847.0,\n+     (354216.0 - 94326.0 * Math.sqrt(6.0)) / 112847.0,\n+     -43306765128.0 / 5313852383.0, -20866708358144.0 / 1126708119789.0,\n+     14886003438020.0 / 654632330667.0, 35290686222309375.0 / 14152473387134411.0,\n+     -1477884375.0 / 485066827.0},\n+\n+    // k12\n+    {39815761.0 / 17514443.0, 0.0, 0.0,\n+     (-3457480.0 - 960905.0 * Math.sqrt(6.0)) / 551636.0,\n+     (-3457480.0 + 960905.0 * Math.sqrt(6.0)) / 551636.0,\n+     -844554132.0 / 47026969.0, 8444996352.0 / 302158619.0,\n+     -2509602342.0 / 877790785.0, -28388795297996250.0 / 3199510091356783.0,\n+     226716250.0 / 18341897.0, 1371316744.0 / 2131383595.0},\n+\n+    // k13 should be for interpolation only, but since it is the same\n+    // stage as the first evaluation of the next step, we perform it\n+    // here at no cost by specifying this is an fsal method\n+    {104257.0/1920240.0, 0.0, 0.0, 0.0, 0.0, 3399327.0/763840.0,\n+     66578432.0/35198415.0, -1674902723.0/288716400.0,\n+     54980371265625.0/176692375811392.0, -734375.0/4826304.0,\n+     171414593.0/851261400.0, 137909.0/3084480.0}\n+\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] staticB = {\n+      104257.0/1920240.0,\n+      0.0,\n+      0.0,\n+      0.0,\n+      0.0,\n+      3399327.0/763840.0,\n+      66578432.0/35198415.0,\n+      -1674902723.0/288716400.0,\n+      54980371265625.0/176692375811392.0,\n+      -734375.0/4826304.0,\n+      171414593.0/851261400.0,\n+      137909.0/3084480.0,\n+      0.0\n+  };\n+\n+  /** First error weights array, element 1. */\n+  private static final double e1_01 =         116092271.0 / 8848465920.0;\n+\n+  // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+  /** First error weights array, element 6. */\n+  private static final double e1_06 =          -1871647.0 / 1527680.0;\n+\n+  /** First error weights array, element 7. */\n+  private static final double e1_07 =         -69799717.0 / 140793660.0;\n+\n+  /** First error weights array, element 8. */\n+  private static final double e1_08 =     1230164450203.0 / 739113984000.0;\n+\n+  /** First error weights array, element 9. */\n+  private static final double e1_09 = -1980813971228885.0 / 5654156025964544.0;\n+\n+  /** First error weights array, element 10. */\n+  private static final double e1_10 =         464500805.0 / 1389975552.0;\n+\n+  /** First error weights array, element 11. */\n+  private static final double e1_11 =     1606764981773.0 / 19613062656000.0;\n+\n+  /** First error weights array, element 12. */\n+  private static final double e1_12 =           -137909.0 / 6168960.0;\n+\n+\n+  /** Second error weights array, element 1. */\n+  private static final double e2_01 =           -364463.0 / 1920240.0;\n+\n+  // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+  /** Second error weights array, element 6. */\n+  private static final double e2_06 =           3399327.0 / 763840.0;\n+\n+  /** Second error weights array, element 7. */\n+  private static final double e2_07 =          66578432.0 / 35198415.0;\n+\n+  /** Second error weights array, element 8. */\n+  private static final double e2_08 =       -1674902723.0 / 288716400.0;\n+\n+  /** Second error weights array, element 9. */\n+  private static final double e2_09 =   -74684743568175.0 / 176692375811392.0;\n+\n+  /** Second error weights array, element 10. */\n+  private static final double e2_10 =           -734375.0 / 4826304.0;\n+\n+  /** Second error weights array, element 11. */\n+  private static final double e2_11 =         171414593.0 / 851261400.0;\n+\n+  /** Second error weights array, element 12. */\n+  private static final double e2_12 =             69869.0 / 3084480.0;\n+\n+  /** Simple constructor.\n+   * Build an eighth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince853Integrator(final double minStep, final double maxStep,\n+                                    final double scalAbsoluteTolerance,\n+                                    final double scalRelativeTolerance) {\n+    super(METHOD_NAME, true, staticC, staticA, staticB,\n+          new DormandPrince853StepInterpolator(),\n+          minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+  }\n+\n+  /** Simple constructor.\n+   * Build an eighth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince853Integrator(final double minStep, final double maxStep,\n+                                    final double[] vecAbsoluteTolerance,\n+                                    final double[] vecRelativeTolerance) {\n+    super(METHOD_NAME, true, staticC, staticA, staticB,\n+          new DormandPrince853StepInterpolator(),\n+          minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+  }\n+\n+  /** {@inheritDoc} */\n+  public int getOrder() {\n+    return 8;\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected double estimateError(final double[][] yDotK,\n+                                 final double[] y0, final double[] y1,\n+                                 final double h) {\n+    double error1 = 0;\n+    double error2 = 0;\n+\n+    for (int j = 0; j < y0.length; ++j) {\n+      final double errSum1 = e1_01 * yDotK[0][j]  + e1_06 * yDotK[5][j] +\n+                             e1_07 * yDotK[6][j]  + e1_08 * yDotK[7][j] +\n+                             e1_09 * yDotK[8][j]  + e1_10 * yDotK[9][j] +\n+                             e1_11 * yDotK[10][j] + e1_12 * yDotK[11][j];\n+      final double errSum2 = e2_01 * yDotK[0][j]  + e2_06 * yDotK[5][j] +\n+                             e2_07 * yDotK[6][j]  + e2_08 * yDotK[7][j] +\n+                             e2_09 * yDotK[8][j]  + e2_10 * yDotK[9][j] +\n+                             e2_11 * yDotK[10][j] + e2_12 * yDotK[11][j];\n+\n+      final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n+      final double tol = (vecAbsoluteTolerance == null) ?\n+                         (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n+                         (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n+      final double ratio1  = errSum1 / tol;\n+      error1        += ratio1 * ratio1;\n+      final double ratio2  = errSum2 / tol;\n+      error2        += ratio2 * ratio2;\n+    }\n+\n+    double den = error1 + 0.01 * error2;\n+    if (den <= 0.0) {\n+      den = 1.0;\n+    }\n+\n+    return Math.abs(h) * error1 / Math.sqrt(y0.length * den);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class represents an interpolator over the last step during an\n+ * ODE integration for the 8(5,3) Dormand-Prince integrator.\n+ *\n+ * @see DormandPrince853Integrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class DormandPrince853StepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link EmbeddedRungeKuttaIntegrator} uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public DormandPrince853StepInterpolator() {\n+    super();\n+    yDotKLast = null;\n+    v         = null;\n+    vectorsInitialized = false;\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public DormandPrince853StepInterpolator(final DormandPrince853StepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    if (interpolator.currentState == null) {\n+\n+      yDotKLast = null;\n+      v         = null;\n+      vectorsInitialized = false;\n+\n+    } else {\n+\n+      final int dimension = interpolator.currentState.length;\n+\n+      yDotKLast    = new double[3][];\n+      for (int k = 0; k < yDotKLast.length; ++k) {\n+        yDotKLast[k] = new double[dimension];\n+        System.arraycopy(interpolator.yDotKLast[k], 0, yDotKLast[k], 0,\n+                         dimension);\n+      }\n+\n+      v = new double[7][];\n+      for (int k = 0; k < v.length; ++k) {\n+        v[k] = new double[dimension];\n+        System.arraycopy(interpolator.v[k], 0, v[k], 0, dimension);\n+      }\n+\n+      vectorsInitialized = interpolator.vectorsInitialized;\n+\n+    }\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected StepInterpolator doCopy() {\n+    return new DormandPrince853StepInterpolator(this);\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void reinitialize(final FirstOrderDifferentialEquations equations,\n+                           final double[] y, final double[][] yDotK, final boolean forward) {\n+\n+    super.reinitialize(equations, y, yDotK, forward);\n+\n+    final int dimension = currentState.length;\n+\n+    yDotKLast = new double[3][];\n+    for (int k = 0; k < yDotKLast.length; ++k) {\n+      yDotKLast[k] = new double[dimension];\n+    }\n+\n+    v = new double[7][];\n+    for (int k = 0; k < v.length; ++k) {\n+      v[k]  = new double[dimension];\n+    }\n+\n+    vectorsInitialized = false;\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void storeTime(final double t) {\n+    super.storeTime(t);\n+    vectorsInitialized = false;\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected void computeInterpolatedState(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    if (! vectorsInitialized) {\n+\n+      if (v == null) {\n+        v = new double[7][];\n+        for (int k = 0; k < 7; ++k) {\n+          v[k] = new double[interpolatedState.length];\n+        }\n+      }\n+\n+      // perform the last evaluations if they have not been done yet\n+      finalizeStep();\n+\n+      // compute the interpolation vectors for this time step\n+      for (int i = 0; i < interpolatedState.length; ++i) {\n+          final double yDot1  = yDotK[0][i];\n+          final double yDot6  = yDotK[5][i];\n+          final double yDot7  = yDotK[6][i];\n+          final double yDot8  = yDotK[7][i];\n+          final double yDot9  = yDotK[8][i];\n+          final double yDot10 = yDotK[9][i];\n+          final double yDot11 = yDotK[10][i];\n+          final double yDot12 = yDotK[11][i];\n+          final double yDot13 = yDotK[12][i];\n+          final double yDot14 = yDotKLast[0][i];\n+          final double yDot15 = yDotKLast[1][i];\n+          final double yDot16 = yDotKLast[2][i];\n+          v[0][i] = b_01 * yDot1  + b_06 * yDot6 + b_07 * yDot7 +\n+                    b_08 * yDot8  + b_09 * yDot9 + b_10 * yDot10 +\n+                    b_11 * yDot11 + b_12 * yDot12;\n+          v[1][i] = yDot1 - v[0][i];\n+          v[2][i] = v[0][i] - v[1][i] - yDotK[12][i];\n+          for (int k = 0; k < d.length; ++k) {\n+              v[k+3][i] = d[k][0] * yDot1  + d[k][1]  * yDot6  + d[k][2]  * yDot7  +\n+                          d[k][3] * yDot8  + d[k][4]  * yDot9  + d[k][5]  * yDot10 +\n+                          d[k][6] * yDot11 + d[k][7]  * yDot12 + d[k][8]  * yDot13 +\n+                          d[k][9] * yDot14 + d[k][10] * yDot15 + d[k][11] * yDot16;\n+          }\n+      }\n+\n+      vectorsInitialized = true;\n+\n+    }\n+\n+    final double eta      = 1 - theta;\n+    final double twoTheta = 2 * theta;\n+    final double theta2   = theta * theta;\n+    final double dot1 = 1 - twoTheta;\n+    final double dot2 = theta * (2 - 3 * theta);\n+    final double dot3 = twoTheta * (1 + theta * (twoTheta -3));\n+    final double dot4 = theta2 * (3 + theta * (5 * theta - 8));\n+    final double dot5 = theta2 * (3 + theta * (-12 + theta * (15 - 6 * theta)));\n+    final double dot6 = theta2 * theta * (4 + theta * (-15 + theta * (18 - 7 * theta)));\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i] -\n+                             oneMinusThetaH * (v[0][i] -\n+                                               theta * (v[1][i] +\n+                                                        theta * (v[2][i] +\n+                                                                 eta * (v[3][i] +\n+                                                                        theta * (v[4][i] +\n+                                                                                 eta * (v[5][i] +\n+                                                                                        theta * (v[6][i])))))));\n+      interpolatedDerivatives[i] =  v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] +\n+                                    dot3 * v[3][i] + dot4 * v[4][i] +\n+                                    dot5 * v[5][i] + dot6 * v[6][i];\n+    }\n+\n+  }\n+ \n+  /** {@inheritDoc} */\n+  protected void doFinalize()\n+    throws DerivativeException {\n+\n+    if (currentState == null) {\n+      // we are finalizing an uninitialized instance\n+      return;\n+    }\n+\n+    double s;\n+    final double[] yTmp = new double[currentState.length];\n+\n+    // k14\n+    for (int j = 0; j < currentState.length; ++j) {\n+      s = k14_01 * yDotK[0][j]  + k14_06 * yDotK[5][j]  + k14_07 * yDotK[6][j] +\n+          k14_08 * yDotK[7][j]  + k14_09 * yDotK[8][j]  + k14_10 * yDotK[9][j] +\n+          k14_11 * yDotK[10][j] + k14_12 * yDotK[11][j] + k14_13 * yDotK[12][j];\n+      yTmp[j] = currentState[j] + h * s;\n+    }\n+    equations.computeDerivatives(previousTime + c14 * h, yTmp, yDotKLast[0]);\n+\n+    // k15\n+    for (int j = 0; j < currentState.length; ++j) {\n+     s = k15_01 * yDotK[0][j]  + k15_06 * yDotK[5][j]  + k15_07 * yDotK[6][j] +\n+         k15_08 * yDotK[7][j]  + k15_09 * yDotK[8][j]  + k15_10 * yDotK[9][j] +\n+         k15_11 * yDotK[10][j] + k15_12 * yDotK[11][j] + k15_13 * yDotK[12][j] +\n+         k15_14 * yDotKLast[0][j];\n+     yTmp[j] = currentState[j] + h * s;\n+    }\n+    equations.computeDerivatives(previousTime + c15 * h, yTmp, yDotKLast[1]);\n+\n+    // k16\n+    for (int j = 0; j < currentState.length; ++j) {\n+      s = k16_01 * yDotK[0][j]  + k16_06 * yDotK[5][j]  + k16_07 * yDotK[6][j] +\n+          k16_08 * yDotK[7][j]  + k16_09 * yDotK[8][j]  + k16_10 * yDotK[9][j] +\n+          k16_11 * yDotK[10][j] + k16_12 * yDotK[11][j] + k16_13 * yDotK[12][j] +\n+          k16_14 * yDotKLast[0][j] +  k16_15 * yDotKLast[1][j];\n+      yTmp[j] = currentState[j] + h * s;\n+    }\n+    equations.computeDerivatives(previousTime + c16 * h, yTmp, yDotKLast[2]);\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void writeExternal(final ObjectOutput out)\n+    throws IOException {\n+\n+    try {\n+      // save the local attributes\n+      finalizeStep();\n+    } catch (DerivativeException e) {\n+      throw MathRuntimeException.createIOException(e);\n+    }\n+    out.writeInt(currentState.length);\n+    for (int i = 0; i < currentState.length; ++i) {\n+      out.writeDouble(yDotKLast[0][i]);\n+      out.writeDouble(yDotKLast[1][i]);\n+      out.writeDouble(yDotKLast[2][i]);\n+    }\n+\n+    // save the state of the base class\n+    super.writeExternal(out);\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void readExternal(final ObjectInput in)\n+    throws IOException {\n+\n+    // read the local attributes\n+    yDotKLast = new double[3][];\n+    final int dimension = in.readInt();\n+    yDotKLast[0] = new double[dimension];\n+    yDotKLast[1] = new double[dimension];\n+    yDotKLast[2] = new double[dimension];\n+\n+    for (int i = 0; i < dimension; ++i) {\n+      yDotKLast[0][i] = in.readDouble();\n+      yDotKLast[1][i] = in.readDouble();\n+      yDotKLast[2][i] = in.readDouble();\n+    }\n+\n+    // read the base state\n+    super.readExternal(in);\n+\n+  }\n+\n+  /** Last evaluations. */\n+  private double[][] yDotKLast;\n+\n+  /** Vectors for interpolation. */\n+  private double[][] v;\n+\n+  /** Initialization indicator for the interpolation vectors. */\n+  private boolean vectorsInitialized;\n+\n+  /** Propagation weights, element 1. */\n+  private static final double b_01 =         104257.0 / 1920240.0;\n+\n+  // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+  /** Propagation weights, element 6. */\n+  private static final double b_06 =        3399327.0 / 763840.0;\n+\n+  /** Propagation weights, element 7. */\n+  private static final double b_07 =       66578432.0 / 35198415.0;\n+\n+  /** Propagation weights, element 8. */\n+  private static final double b_08 =    -1674902723.0 / 288716400.0;\n+\n+  /** Propagation weights, element 9. */\n+  private static final double b_09 = 54980371265625.0 / 176692375811392.0;\n+\n+  /** Propagation weights, element 10. */\n+  private static final double b_10 =        -734375.0 / 4826304.0;\n+\n+  /** Propagation weights, element 11. */\n+  private static final double b_11 =      171414593.0 / 851261400.0;\n+\n+  /** Propagation weights, element 12. */\n+  private static final double b_12 =         137909.0 / 3084480.0;\n+\n+  /** Time step for stage 14 (interpolation only). */\n+  private static final double c14    = 1.0 / 10.0;\n+\n+  /** Internal weights for stage 14, element 1. */\n+  private static final double k14_01 =       13481885573.0 / 240030000000.0      - b_01;\n+\n+  // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+  /** Internal weights for stage 14, element 6. */\n+  private static final double k14_06 =                 0.0                       - b_06;\n+\n+  /** Internal weights for stage 14, element 7. */\n+  private static final double k14_07 =      139418837528.0 / 549975234375.0      - b_07;\n+\n+  /** Internal weights for stage 14, element 8. */\n+  private static final double k14_08 =   -11108320068443.0 / 45111937500000.0    - b_08;\n+\n+  /** Internal weights for stage 14, element 9. */\n+  private static final double k14_09 = -1769651421925959.0 / 14249385146080000.0 - b_09;\n+\n+  /** Internal weights for stage 14, element 10. */\n+  private static final double k14_10 =          57799439.0 / 377055000.0         - b_10;\n+\n+  /** Internal weights for stage 14, element 11. */\n+  private static final double k14_11 =      793322643029.0 / 96734250000000.0    - b_11;\n+\n+  /** Internal weights for stage 14, element 12. */\n+  private static final double k14_12 =        1458939311.0 / 192780000000.0      - b_12;\n+\n+  /** Internal weights for stage 14, element 13. */\n+  private static final double k14_13 =             -4149.0 / 500000.0;\n+\n+  /** Time step for stage 15 (interpolation only). */\n+  private static final double c15    = 1.0 / 5.0;\n+\n+\n+  /** Internal weights for stage 15, element 1. */\n+  private static final double k15_01 =     1595561272731.0 / 50120273500000.0    - b_01;\n+\n+  // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+  /** Internal weights for stage 15, element 6. */\n+  private static final double k15_06 =      975183916491.0 / 34457688031250.0    - b_06;\n+\n+  /** Internal weights for stage 15, element 7. */\n+  private static final double k15_07 =    38492013932672.0 / 718912673015625.0   - b_07;\n+\n+  /** Internal weights for stage 15, element 8. */\n+  private static final double k15_08 = -1114881286517557.0 / 20298710767500000.0 - b_08;\n+\n+  /** Internal weights for stage 15, element 9. */\n+  private static final double k15_09 =                 0.0                       - b_09;\n+\n+  /** Internal weights for stage 15, element 10. */\n+  private static final double k15_10 =                 0.0                       - b_10;\n+\n+  /** Internal weights for stage 15, element 11. */\n+  private static final double k15_11 =    -2538710946863.0 / 23431227861250000.0 - b_11;\n+\n+  /** Internal weights for stage 15, element 12. */\n+  private static final double k15_12 =        8824659001.0 / 23066716781250.0    - b_12;\n+\n+  /** Internal weights for stage 15, element 13. */\n+  private static final double k15_13 =      -11518334563.0 / 33831184612500.0;\n+\n+  /** Internal weights for stage 15, element 14. */\n+  private static final double k15_14 =        1912306948.0 / 13532473845.0;\n+\n+  /** Time step for stage 16 (interpolation only). */\n+  private static final double c16    = 7.0 / 9.0;\n+\n+\n+  /** Internal weights for stage 16, element 1. */\n+  private static final double k16_01 =      -13613986967.0 / 31741908048.0       - b_01;\n+\n+  // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+  /** Internal weights for stage 16, element 6. */\n+  private static final double k16_06 =       -4755612631.0 / 1012344804.0        - b_06;\n+\n+  /** Internal weights for stage 16, element 7. */\n+  private static final double k16_07 =    42939257944576.0 / 5588559685701.0     - b_07;\n+\n+  /** Internal weights for stage 16, element 8. */\n+  private static final double k16_08 =    77881972900277.0 / 19140370552944.0    - b_08;\n+\n+  /** Internal weights for stage 16, element 9. */\n+  private static final double k16_09 =    22719829234375.0 / 63689648654052.0    - b_09;\n+\n+  /** Internal weights for stage 16, element 10. */\n+  private static final double k16_10 =                 0.0                       - b_10;\n+\n+  /** Internal weights for stage 16, element 11. */\n+  private static final double k16_11 =                 0.0                       - b_11;\n+\n+  /** Internal weights for stage 16, element 12. */\n+  private static final double k16_12 =                 0.0                       - b_12;\n+\n+  /** Internal weights for stage 16, element 13. */\n+  private static final double k16_13 =       -1199007803.0 / 857031517296.0;\n+\n+  /** Internal weights for stage 16, element 14. */\n+  private static final double k16_14 =      157882067000.0 / 53564469831.0;\n+\n+  /** Internal weights for stage 16, element 15. */\n+  private static final double k16_15 =     -290468882375.0 / 31741908048.0;\n+\n+  /** Interpolation weights.\n+   * (beware that only the non-null values are in the table)\n+   */\n+  private static final double[][] d = {\n+\n+    {        -17751989329.0 / 2106076560.0,               4272954039.0 / 7539864640.0,\n+            -118476319744.0 / 38604839385.0,            755123450731.0 / 316657731600.0,\n+      3692384461234828125.0 / 1744130441634250432.0,     -4612609375.0 / 5293382976.0,\n+            2091772278379.0 / 933644586600.0,             2136624137.0 / 3382989120.0,\n+                  -126493.0 / 1421424.0,                    98350000.0 / 5419179.0,\n+                -18878125.0 / 2053168.0,                 -1944542619.0 / 438351368.0},\n+\n+    {         32941697297.0 / 3159114840.0,             456696183123.0 / 1884966160.0,\n+           19132610714624.0 / 115814518155.0,       -177904688592943.0 / 474986597400.0,\n+     -4821139941836765625.0 / 218016305204281304.0,      30702015625.0 / 3970037232.0,\n+          -85916079474274.0 / 2800933759800.0,           -5919468007.0 / 634310460.0,\n+                  2479159.0 / 157936.0,                    -18750000.0 / 602131.0,\n+                -19203125.0 / 2053168.0,                 15700361463.0 / 438351368.0},\n+\n+    {         12627015655.0 / 631822968.0,              -72955222965.0 / 188496616.0,\n+          -13145744952320.0 / 69488710893.0,          30084216194513.0 / 56998391688.0,\n+      -296858761006640625.0 / 25648977082856624.0,         569140625.0 / 82709109.0,\n+             -18684190637.0 / 18672891732.0,                69644045.0 / 89549712.0,\n+                -11847025.0 / 4264272.0,                  -978650000.0 / 16257537.0,\n+                519371875.0 / 6159504.0,                  5256837225.0 / 438351368.0},\n+\n+    {          -450944925.0 / 17550638.0,               -14532122925.0 / 94248308.0,\n+            -595876966400.0 / 2573655959.0,             188748653015.0 / 527762886.0,\n+      2545485458115234375.0 / 27252038150535163.0,       -1376953125.0 / 36759604.0,\n+              53995596795.0 / 518691437.0,                 210311225.0 / 7047894.0,\n+                 -1718875.0 / 39484.0,                      58000000.0 / 602131.0,\n+                 -1546875.0 / 39484.0,                   -1262172375.0 / 8429834.0}\n+\n+  };\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = 7152276390558450974L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+/**\n+ * This class implements the common part of all embedded Runge-Kutta\n+ * integrators for Ordinary Differential Equations.\n+ *\n+ * <p>These methods are embedded explicit Runge-Kutta methods with two\n+ * sets of coefficients allowing to estimate the error, their Butcher\n+ * arrays are as follows :\n+ * <pre>\n+ *    0  |\n+ *   c2  | a21\n+ *   c3  | a31  a32\n+ *   ... |        ...\n+ *   cs  | as1  as2  ...  ass-1\n+ *       |--------------------------\n+ *       |  b1   b2  ...   bs-1  bs\n+ *       |  b'1  b'2 ...   b's-1 b's\n+ * </pre>\n+ * </p>\n+ *\n+ * <p>In fact, we rather use the array defined by ej = bj - b'j to\n+ * compute directly the error rather than computing two estimates and\n+ * then comparing them.</p>\n+ *\n+ * <p>Some methods are qualified as <i>fsal</i> (first same as last)\n+ * methods. This means the last evaluation of the derivatives in one\n+ * step is the same as the first in the next step. Then, this\n+ * evaluation can be reused from one step to the next one and the cost\n+ * of such a method is really s-1 evaluations despite the method still\n+ * has s stages. This behaviour is true only for successful steps, if\n+ * the step is rejected after the error estimation phase, no\n+ * evaluation is saved. For an <i>fsal</i> method, we have cs = 1 and\n+ * asi = bi for all i.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public abstract class EmbeddedRungeKuttaIntegrator\n+  extends AdaptiveStepsizeIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -8436701741819010959L;\n+\n+  /** Build a Runge-Kutta integrator with the given Butcher array.\n+   * @param name name of the method\n+   * @param fsal indicate that the method is an <i>fsal</i>\n+   * @param c time steps from Butcher array (without the first zero)\n+   * @param a internal weights from Butcher array (without the first empty row)\n+   * @param b propagation weights for the high order method from Butcher array\n+   * @param prototype prototype of the step interpolator to use\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n+                                         final double[] c, final double[][] a, final double[] b,\n+                                         final RungeKuttaStepInterpolator prototype,\n+                                         final double minStep, final double maxStep,\n+                                         final double scalAbsoluteTolerance,\n+                                         final double scalRelativeTolerance) {\n+\n+    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+\n+    this.fsal      = fsal;\n+    this.c         = c;\n+    this.a         = a;\n+    this.b         = b;\n+    this.prototype = prototype;\n+\n+    exp = -1.0 / getOrder();\n+\n+    // set the default values of the algorithm control parameters\n+    setSafety(0.9);\n+    setMinReduction(0.2);\n+    setMaxGrowth(10.0);\n+\n+  }\n+\n+  /** Build a Runge-Kutta integrator with the given Butcher array.\n+   * @param name name of the method\n+   * @param fsal indicate that the method is an <i>fsal</i>\n+   * @param c time steps from Butcher array (without the first zero)\n+   * @param a internal weights from Butcher array (without the first empty row)\n+   * @param b propagation weights for the high order method from Butcher array\n+   * @param prototype prototype of the step interpolator to use\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n+                                         final double[] c, final double[][] a, final double[] b,\n+                                         final RungeKuttaStepInterpolator prototype,\n+                                         final double   minStep, final double maxStep,\n+                                         final double[] vecAbsoluteTolerance,\n+                                         final double[] vecRelativeTolerance) {\n+\n+    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+\n+    this.fsal      = fsal;\n+    this.c         = c;\n+    this.a         = a;\n+    this.b         = b;\n+    this.prototype = prototype;\n+\n+    exp = -1.0 / getOrder();\n+\n+    // set the default values of the algorithm control parameters\n+    setSafety(0.9);\n+    setMinReduction(0.2);\n+    setMaxGrowth(10.0);\n+\n+  }\n+\n+  /** Get the order of the method.\n+   * @return order of the method\n+   */\n+  public abstract int getOrder();\n+\n+  /** Get the safety factor for stepsize control.\n+   * @return safety factor\n+   */\n+  public double getSafety() {\n+    return safety;\n+  }\n+\n+  /** Set the safety factor for stepsize control.\n+   * @param safety safety factor\n+   */\n+  public void setSafety(final double safety) {\n+    this.safety = safety;\n+  }\n+\n+  /** {@inheritDoc} */\n+  public double integrate(final FirstOrderDifferentialEquations equations,\n+                          final double t0, final double[] y0,\n+                          final double t, final double[] y)\n+  throws DerivativeException, IntegratorException {\n+\n+    sanityChecks(equations, t0, y0, t, y);\n+    final boolean forward = (t > t0);\n+\n+    // create some internal working arrays\n+    final int stages = c.length + 1;\n+    if (y != y0) {\n+      System.arraycopy(y0, 0, y, 0, y0.length);\n+    }\n+    final double[][] yDotK = new double[stages][];\n+    for (int i = 0; i < stages; ++i) {\n+      yDotK [i] = new double[y0.length];\n+    }\n+    final double[] yTmp = new double[y0.length];\n+\n+    // set up an interpolator sharing the integrator arrays\n+    AbstractStepInterpolator interpolator;\n+    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n+      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n+      rki.reinitialize(equations, yTmp, yDotK, forward);\n+      interpolator = rki;\n+    } else {\n+      interpolator = new DummyStepInterpolator(yTmp, forward);\n+    }\n+    interpolator.storeTime(t0);\n+\n+    // set up integration control objects\n+    stepStart         = t0;\n+    double  hNew      = 0;\n+    boolean firstTime = true;\n+    for (StepHandler handler : stepHandlers) {\n+        handler.reset();\n+    }\n+    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n+    boolean lastStep = false;\n+\n+    // main integration loop\n+    while (!lastStep) {\n+\n+      interpolator.shift();\n+\n+      double error = 0;\n+      for (boolean loop = true; loop;) {\n+\n+        if (firstTime || !fsal) {\n+          // first stage\n+          equations.computeDerivatives(stepStart, y, yDotK[0]);\n+        }\n+\n+        if (firstTime) {\n+          final double[] scale;\n+          if (vecAbsoluteTolerance != null) {\n+            scale = vecAbsoluteTolerance;\n+          } else {\n+            scale = new double[y0.length];\n+            for (int i = 0; i < scale.length; ++i) {\n+              scale[i] = scalAbsoluteTolerance;\n+            }\n+          }\n+          hNew = initializeStep(equations, forward, getOrder(), scale,\n+                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n+          firstTime = false;\n+        }\n+\n+        stepSize = hNew;\n+\n+        // next stages\n+        for (int k = 1; k < stages; ++k) {\n+\n+          for (int j = 0; j < y0.length; ++j) {\n+            double sum = a[k-1][0] * yDotK[0][j];\n+            for (int l = 1; l < k; ++l) {\n+              sum += a[k-1][l] * yDotK[l][j];\n+            }\n+            yTmp[j] = y[j] + stepSize * sum;\n+          }\n+\n+          equations.computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n+\n+        }\n+\n+        // estimate the state at the end of the step\n+        for (int j = 0; j < y0.length; ++j) {\n+          double sum    = b[0] * yDotK[0][j];\n+          for (int l = 1; l < stages; ++l) {\n+            sum    += b[l] * yDotK[l][j];\n+          }\n+          yTmp[j] = y[j] + stepSize * sum;\n+        }\n+\n+        // estimate the error at the end of the step\n+        error = estimateError(yDotK, y, yTmp, stepSize);\n+        if (error <= 1.0) {\n+\n+          // discrete events handling\n+          interpolator.storeTime(stepStart + stepSize);\n+          if (manager.evaluateStep(interpolator)) {\n+            // reject the step to match exactly the next switch time\n+            hNew = manager.getEventTime() - stepStart;\n+          } else {\n+            // accept the step\n+            loop = false;\n+          }\n+\n+        } else {\n+          // reject the step and attempt to reduce error by stepsize control\n+          final double factor =\n+              Math.min(maxGrowth,\n+                       Math.max(minReduction, safety * Math.pow(error, exp)));\n+          hNew = filterStep(stepSize * factor, forward, false);\n+        }\n+\n+      }\n+\n+      // the step has been accepted\n+      final double nextStep = stepStart + stepSize;\n+      System.arraycopy(yTmp, 0, y, 0, y0.length);\n+      manager.stepAccepted(nextStep, y);\n+      lastStep = manager.stop();\n+\n+      // provide the step data to the step handler\n+      interpolator.storeTime(nextStep);\n+      for (StepHandler handler : stepHandlers) {\n+          handler.handleStep(interpolator, lastStep);\n+      }\n+      stepStart = nextStep;\n+\n+      if (fsal) {\n+        // save the last evaluation for the next step\n+        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n+      }\n+\n+      if (manager.reset(stepStart, y) && ! lastStep) {\n+        // some event handler has triggered changes that\n+        // invalidate the derivatives, we need to recompute them\n+        equations.computeDerivatives(stepStart, y, yDotK[0]);\n+      }\n+\n+      if (! lastStep) {\n+        // in some rare cases we may get here with stepSize = 0, for example\n+        // when an event occurs at integration start, reducing the first step\n+        // to zero; we have to reset the step to some safe non zero value\n+          stepSize = filterStep(stepSize, forward, true);\n+\n+        // stepsize control for next step\n+        final double factor = Math.min(maxGrowth,\n+                                       Math.max(minReduction,\n+                                                safety * Math.pow(error, exp)));\n+        final double  scaledH    = stepSize * factor;\n+        final double  nextT      = stepStart + scaledH;\n+        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n+        hNew = filterStep(scaledH, forward, nextIsLast);\n+      }\n+\n+    }\n+\n+    final double stopTime = stepStart;\n+    resetInternalState();\n+    return stopTime;\n+\n+  }\n+\n+  /** Get the minimal reduction factor for stepsize control.\n+   * @return minimal reduction factor\n+   */\n+  public double getMinReduction() {\n+    return minReduction;\n+  }\n+\n+  /** Set the minimal reduction factor for stepsize control.\n+   * @param minReduction minimal reduction factor\n+   */\n+  public void setMinReduction(final double minReduction) {\n+    this.minReduction = minReduction;\n+  }\n+\n+  /** Get the maximal growth factor for stepsize control.\n+   * @return maximal growth factor\n+   */\n+  public double getMaxGrowth() {\n+    return maxGrowth;\n+  }\n+\n+  /** Set the maximal growth factor for stepsize control.\n+   * @param maxGrowth maximal growth factor\n+   */\n+  public void setMaxGrowth(final double maxGrowth) {\n+    this.maxGrowth = maxGrowth;\n+  }\n+\n+  /** Compute the error ratio.\n+   * @param yDotK derivatives computed during the first stages\n+   * @param y0 estimate of the step at the start of the step\n+   * @param y1 estimate of the step at the end of the step\n+   * @param h  current step\n+   * @return error ratio, greater than 1 if step should be rejected\n+   */\n+  protected abstract double estimateError(double[][] yDotK,\n+                                          double[] y0, double[] y1,\n+                                          double h);\n+\n+  /** Indicator for <i>fsal</i> methods. */\n+  private boolean fsal;\n+\n+  /** Time steps from Butcher array (without the first zero). */\n+  private double[] c;\n+\n+  /** Internal weights from Butcher array (without the first empty row). */\n+  private double[][] a;\n+\n+  /** External weights for the high order method from Butcher array. */\n+  private double[] b;\n+\n+  /** Prototype of the step interpolator. */\n+  private RungeKuttaStepInterpolator prototype;\n+                                         \n+  /** Stepsize control exponent. */\n+  private double exp;\n+\n+  /** Safety factor for stepsize control. */\n+  private double safety;\n+\n+  /** Minimal reduction factor for stepsize control. */\n+  private double minReduction;\n+\n+  /** Maximal growth factor for stepsize control. */\n+  private double maxGrowth;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/EulerIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class implements a simple Euler integrator for Ordinary\n+ * Differential Equations.\n+ *\n+ * <p>The Euler algorithm is the simplest one that can be used to\n+ * integrate ordinary differential equations. It is a simple inversion\n+ * of the forward difference expression :\n+ * <code>f'=(f(t+h)-f(t))/h</code> which leads to\n+ * <code>f(t+h)=f(t)+hf'</code>. The interpolation scheme used for\n+ * dense output is the linear scheme already used for integration.</p>\n+ *\n+ * <p>This algorithm looks cheap because it needs only one function\n+ * evaluation per step. However, as it uses linear estimates, it needs\n+ * very small steps to achieve high accuracy, and small steps lead to\n+ * numerical errors and instabilities.</p>\n+ *\n+ * <p>This algorithm is almost never used and has been included in\n+ * this package only as a comparison reference for more useful\n+ * integrators.</p>\n+ *\n+ * @see MidpointIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+ * @see ThreeEighthesIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class EulerIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 1828811360890387657L;\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] c = {\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] a = {\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] b = {\n+    1.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build an Euler integrator with the given step.\n+   * @param step integration step\n+   */\n+  public EulerIntegrator(final double step) {\n+    super(\"Euler\", c, a, b, new EulerStepInterpolator(), step);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements a linear interpolator for step.\n+ *\n+ * <p>This interpolator computes dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+ *\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h) - (1-theta) h y'\n+ * </pre>\n+ *\n+ * where theta belongs to [0 ; 1] and where y' is the evaluation of\n+ * the derivatives already computed during the step.</p>\n+ *\n+ * @see EulerIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class EulerStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -7179861704951334960L;\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public EulerStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public EulerStepInterpolator(final EulerStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected StepInterpolator doCopy() {\n+    return new EulerStepInterpolator(this);\n+  }\n+\n+\n+  /** {@inheritDoc} */\n+  protected void computeInterpolatedState(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i] - oneMinusThetaH * yDotK[0][i];\n+    }\n+    System.arraycopy(yDotK[0], 0, interpolatedDerivatives, 0, interpolatedDerivatives.length);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/GillIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class implements the Gill fourth order Runge-Kutta\n+ * integrator for Ordinary Differential Equations .\n+\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |    0        0       0      0\n+ *   1/2 |   1/2       0       0      0\n+ *   1/2 | (q-1)/2  (2-q)/2    0      0\n+ *    1  |    0       -q/2  (2+q)/2   0\n+ *       |-------------------------------\n+ *       |   1/6    (2-q)/6 (2+q)/6  1/6\n+ * </pre>\n+ * where q = sqrt(2)</p>\n+ *\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see MidpointIntegrator\n+ * @see ThreeEighthesIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class GillIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 5566682259665027132L;\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] c = {\n+    1.0 / 2.0, 1.0 / 2.0, 1.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] a = {\n+    { 1.0 / 2.0 },\n+    { (Math.sqrt(2.0) - 1.0) / 2.0, (2.0 - Math.sqrt(2.0)) / 2.0 },\n+    { 0.0, -Math.sqrt(2.0) / 2.0, (2.0 + Math.sqrt(2.0)) / 2.0 }\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] b = {\n+    1.0 / 6.0, (2.0 - Math.sqrt(2.0)) / 6.0, (2.0 + Math.sqrt(2.0)) / 6.0, 1.0 / 6.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a fourth-order Gill integrator with the given step.\n+   * @param step integration step\n+   */\n+  public GillIntegrator(final double step) {\n+    super(\"Gill\", c, a, b, new GillStepInterpolator(), step);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements a step interpolator for the Gill fourth\n+ * order Runge-Kutta integrator.\n+ *\n+ * <p>This interpolator allows to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+ *\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h)\n+ *                    - (1 - theta) (h/6) [ (1 - theta) (1 - 4 theta) y'_1\n+ *                                        + (1 - theta) (1 + 2 theta) ((2-q) y'_2 + (2+q) y'_3)\n+ *                                        + (1 + theta + 4 theta^2) y'_4\n+ *                                        ]\n+ * </pre>\n+ * where theta belongs to [0 ; 1], q = sqrt(2) and where y'_1 to y'_4\n+ * are the four evaluations of the derivatives already computed during\n+ * the step.</p>\n+ *\n+ * @see GillIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class GillStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+    \n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public GillStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public GillStepInterpolator(final GillStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected StepInterpolator doCopy() {\n+    return new GillStepInterpolator(this);\n+  }\n+\n+\n+  /** {@inheritDoc} */\n+  protected void computeInterpolatedState(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    final double twoTheta  = 2 * theta;\n+    final double fourTheta = 4 * theta;\n+    final double s         = oneMinusThetaH / 6.0;\n+    final double oMt       = 1 - theta;\n+    final double soMt      = s * oMt;\n+    final double c23       = soMt * (1 + twoTheta);\n+    final double coeff1    = soMt * (1 - fourTheta);\n+    final double coeff2    = c23  * tMq;\n+    final double coeff3    = c23  * tPq;\n+    final double coeff4    = s * (1 + theta * (1 + fourTheta));\n+    final double coeffDot1 = theta * (twoTheta - 3) + 1;\n+    final double cDot23    = theta * oMt;\n+    final double coeffDot2 = cDot23  * tMq;\n+    final double coeffDot3 = cDot23  * tPq;\n+    final double coeffDot4 = theta * (twoTheta - 1);\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+        final double yDot1 = yDotK[0][i];\n+        final double yDot2 = yDotK[1][i];\n+        final double yDot3 = yDotK[2][i];\n+        final double yDot4 = yDotK[3][i];\n+        interpolatedState[i] =\n+            currentState[i] - coeff1 * yDot1 - coeff2 * yDot2 - coeff3 * yDot3 - coeff4 * yDot4;\n+        interpolatedDerivatives[i] =\n+            coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;\n+     }\n+\n+  }\n+\n+  /** First Gill coefficient. */\n+  private static final double tMq = 2 - Math.sqrt(2.0);\n+\n+  /** Second Gill coefficient. */\n+  private static final double tPq = 2 + Math.sqrt(2.0);\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -107804074496313322L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+/**\n+ * This class implements a Gragg-Bulirsch-Stoer integrator for\n+ * Ordinary Differential Equations.\n+ *\n+ * <p>The Gragg-Bulirsch-Stoer algorithm is one of the most efficient\n+ * ones currently available for smooth problems. It uses Richardson\n+ * extrapolation to estimate what would be the solution if the step\n+ * size could be decreased down to zero.</p>\n+ *\n+ * <p>\n+ * This method changes both the step size and the order during\n+ * integration, in order to minimize computation cost. It is\n+ * particularly well suited when a very high precision is needed. The\n+ * limit where this method becomes more efficient than high-order\n+ * embedded Runge-Kutta methods like {@link DormandPrince853Integrator\n+ * Dormand-Prince 8(5,3)} depends on the problem. Results given in the\n+ * Hairer, Norsett and Wanner book show for example that this limit\n+ * occurs for accuracy around 1e-6 when integrating Saltzam-Lorenz\n+ * equations (the authors note this problem is <i>extremely sensitive\n+ * to the errors in the first integration steps</i>), and around 1e-11\n+ * for a two dimensional celestial mechanics problems with seven\n+ * bodies (pleiades problem, involving quasi-collisions for which\n+ * <i>automatic step size control is essential</i>).\n+ * </p>\n+ *\n+ * <p>\n+ * This implementation is basically a reimplementation in Java of the\n+ * <a\n+ * href=\"http://www.unige.ch/math/folks/hairer/prog/nonstiff/odex.f\">odex</a>\n+ * fortran code by E. Hairer and G. Wanner. The redistribution policy\n+ * for this code is available <a\n+ * href=\"http://www.unige.ch/~hairer/prog/licence.txt\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+ * </p>\n+ *\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>Copyright (c) 2004, Ernst Hairer</td></tr>\n+ *\n+ * <tr><td>Redistribution and use in source and binary forms, with or\n+ * without modification, are permitted provided that the following\n+ * conditions are met:\n+ * <ul>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ *  <li>Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in the\n+ *      documentation and/or other materials provided with the distribution.</li>\n+ * </ul></td></tr>\n+ *\n+ * <tr><td><strong>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n+ * CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</strong></td></tr>\n+ * </table>\n+ *\n+ * @author E. Hairer and G. Wanner (fortran version)\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class GraggBulirschStoerIntegrator\n+  extends AdaptiveStepsizeIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 7364884082146325264L;\n+\n+  /** Integrator method name. */\n+  private static final String METHOD_NAME = \"Gragg-Bulirsch-Stoer\";\n+\n+  /** Simple constructor.\n+   * Build a Gragg-Bulirsch-Stoer integrator with the given step\n+   * bounds. All tuning parameters are set to their default\n+   * values. The default step handler does nothing.\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public GraggBulirschStoerIntegrator(final double minStep, final double maxStep,\n+                                      final double scalAbsoluteTolerance,\n+                                      final double scalRelativeTolerance) {\n+    super(METHOD_NAME, minStep, maxStep,\n+          scalAbsoluteTolerance, scalRelativeTolerance);\n+    denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());\n+    setStabilityCheck(true, -1, -1, -1);\n+    setStepsizeControl(-1, -1, -1, -1);\n+    setOrderControl(-1, -1, -1);\n+    setInterpolationControl(true, -1);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a Gragg-Bulirsch-Stoer integrator with the given step\n+   * bounds. All tuning parameters are set to their default\n+   * values. The default step handler does nothing.\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public GraggBulirschStoerIntegrator(final double minStep, final double maxStep,\n+                                      final double[] vecAbsoluteTolerance,\n+                                      final double[] vecRelativeTolerance) {\n+    super(METHOD_NAME, minStep, maxStep,\n+          vecAbsoluteTolerance, vecRelativeTolerance);\n+    denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());\n+    setStabilityCheck(true, -1, -1, -1);\n+    setStepsizeControl(-1, -1, -1, -1);\n+    setOrderControl(-1, -1, -1);\n+    setInterpolationControl(true, -1);\n+  }\n+\n+  /** Set the stability check controls.\n+   * <p>The stability check is performed on the first few iterations of\n+   * the extrapolation scheme. If this test fails, the step is rejected\n+   * and the stepsize is reduced.</p>\n+   * <p>By default, the test is performed, at most during two\n+   * iterations at each step, and at most once for each of these\n+   * iterations. The default stepsize reduction factor is 0.5.</p>\n+   * @param performTest if true, stability check will be performed,\n+     if false, the check will be skipped\n+   * @param maxIter maximal number of iterations for which checks are\n+   * performed (the number of iterations is reset to default if negative\n+   * or null)\n+   * @param maxChecks maximal number of checks for each iteration\n+   * (the number of checks is reset to default if negative or null)\n+   * @param stabilityReduction stepsize reduction factor in case of\n+   * failure (the factor is reset to default if lower than 0.0001 or\n+   * greater than 0.9999)\n+   */\n+  public void setStabilityCheck(final boolean performTest,\n+                                final int maxIter, final int maxChecks,\n+                                final double stabilityReduction) {\n+\n+    this.performTest = performTest;\n+    this.maxIter     = (maxIter   <= 0) ? 2 : maxIter;\n+    this.maxChecks   = (maxChecks <= 0) ? 1 : maxChecks;\n+\n+    if ((stabilityReduction < 0.0001) || (stabilityReduction > 0.9999)) {\n+      this.stabilityReduction = 0.5;\n+    } else {\n+      this.stabilityReduction = stabilityReduction;\n+    }\n+\n+  }\n+\n+  /** Set the step size control factors.\n+\n+   * <p>The new step size hNew is computed from the old one h by:\n+   * <pre>\n+   * hNew = h * stepControl2 / (err/stepControl1)^(1/(2k+1))\n+   * </pre>\n+   * where err is the scaled error and k the iteration number of the\n+   * extrapolation scheme (counting from 0). The default values are\n+   * 0.65 for stepControl1 and 0.94 for stepControl2.</p>\n+   * <p>The step size is subject to the restriction:\n+   * <pre>\n+   * stepControl3^(1/(2k+1))/stepControl4 <= hNew/h <= 1/stepControl3^(1/(2k+1))\n+   * </pre>\n+   * The default values are 0.02 for stepControl3 and 4.0 for\n+   * stepControl4.</p>\n+   * @param stepControl1 first stepsize control factor (the factor is\n+   * reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param stepControl2 second stepsize control factor (the factor\n+   * is reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param stepControl3 third stepsize control factor (the factor is\n+   * reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param stepControl4 fourth stepsize control factor (the factor\n+   * is reset to default if lower than 1.0001 or greater than 999.9)\n+   */\n+  public void setStepsizeControl(final double stepControl1, final double stepControl2,\n+                                 final double stepControl3, final double stepControl4) {\n+\n+    if ((stepControl1 < 0.0001) || (stepControl1 > 0.9999)) {\n+      this.stepControl1 = 0.65;\n+    } else {\n+      this.stepControl1 = stepControl1;\n+    }\n+\n+    if ((stepControl2 < 0.0001) || (stepControl2 > 0.9999)) {\n+      this.stepControl2 = 0.94;\n+    } else {\n+      this.stepControl2 = stepControl2;\n+    }\n+\n+    if ((stepControl3 < 0.0001) || (stepControl3 > 0.9999)) {\n+      this.stepControl3 = 0.02;\n+    } else {\n+      this.stepControl3 = stepControl3;\n+    }\n+\n+    if ((stepControl4 < 1.0001) || (stepControl4 > 999.9)) {\n+      this.stepControl4 = 4.0;\n+    } else {\n+      this.stepControl4 = stepControl4;\n+    }\n+\n+  }\n+\n+  /** Set the order control parameters.\n+   * <p>The Gragg-Bulirsch-Stoer method changes both the step size and\n+   * the order during integration, in order to minimize computation\n+   * cost. Each extrapolation step increases the order by 2, so the\n+   * maximal order that will be used is always even, it is twice the\n+   * maximal number of columns in the extrapolation table.</p>\n+   * <pre>\n+   * order is decreased if w(k-1) <= w(k)   * orderControl1\n+   * order is increased if w(k)   <= w(k-1) * orderControl2\n+   * </pre>\n+   * <p>where w is the table of work per unit step for each order\n+   * (number of function calls divided by the step length), and k is\n+   * the current order.</p>\n+   * <p>The default maximal order after construction is 18 (i.e. the\n+   * maximal number of columns is 9). The default values are 0.8 for\n+   * orderControl1 and 0.9 for orderControl2.</p>\n+   * @param maxOrder maximal order in the extrapolation table (the\n+   * maximal order is reset to default if order <= 6 or odd)\n+   * @param orderControl1 first order control factor (the factor is\n+   * reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param orderControl2 second order control factor (the factor\n+   * is reset to default if lower than 0.0001 or greater than 0.9999)\n+   */\n+  public void setOrderControl(final int maxOrder,\n+                              final double orderControl1, final double orderControl2) {\n+\n+    if ((maxOrder <= 6) || (maxOrder % 2 != 0)) {\n+      this.maxOrder = 18;\n+    }\n+\n+    if ((orderControl1 < 0.0001) || (orderControl1 > 0.9999)) {\n+      this.orderControl1 = 0.8;\n+    } else {\n+      this.orderControl1 = orderControl1;\n+    }\n+\n+    if ((orderControl2 < 0.0001) || (orderControl2 > 0.9999)) {\n+      this.orderControl2 = 0.9;\n+    } else {\n+      this.orderControl2 = orderControl2;\n+    }\n+\n+    // reinitialize the arrays\n+    initializeArrays();\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void addStepHandler (final StepHandler handler) {\n+\n+    super.addStepHandler(handler);\n+    denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());\n+\n+    // reinitialize the arrays\n+    initializeArrays();\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void addEventHandler(final EventHandler function,\n+                              final double maxCheckInterval,\n+                              final double convergence,\n+                              final int maxIterationCount) {\n+    super.addEventHandler(function, maxCheckInterval, convergence, maxIterationCount);\n+    denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());\n+\n+    // reinitialize the arrays\n+    initializeArrays();\n+\n+  }\n+\n+  /** Initialize the integrator internal arrays. */\n+  private void initializeArrays() {\n+\n+    final int size = maxOrder / 2;\n+\n+    if ((sequence == null) || (sequence.length != size)) {\n+      // all arrays should be reallocated with the right size\n+      sequence        = new int[size];\n+      costPerStep     = new int[size];\n+      coeff           = new double[size][];\n+      costPerTimeUnit = new double[size];\n+      optimalStep     = new double[size];\n+    }\n+\n+    if (denseOutput) {\n+      // step size sequence: 2, 6, 10, 14, ...\n+      for (int k = 0; k < size; ++k) {\n+        sequence[k] = 4 * k + 2;\n+      }\n+    } else {\n+      // step size sequence: 2, 4, 6, 8, ...\n+      for (int k = 0; k < size; ++k) {\n+        sequence[k] = 2 * (k + 1); \n+      }\n+    }\n+\n+    // initialize the order selection cost array\n+    // (number of function calls for each column of the extrapolation table)\n+    costPerStep[0] = sequence[0] + 1;\n+    for (int k = 1; k < size; ++k) {\n+      costPerStep[k] = costPerStep[k-1] + sequence[k];\n+    }\n+\n+    // initialize the extrapolation tables\n+    for (int k = 0; k < size; ++k) {\n+      coeff[k] = (k > 0) ? new double[k] : null;\n+      for (int l = 0; l < k; ++l) {\n+        final double ratio = ((double) sequence[k]) / sequence[k-l-1];\n+        coeff[k][l] = 1.0 / (ratio * ratio - 1.0);\n+      }\n+    }\n+\n+  }\n+\n+  /** Set the interpolation order control parameter.\n+   * The interpolation order for dense output is 2k - mudif + 1. The\n+   * default value for mudif is 4 and the interpolation error is used\n+   * in stepsize control by default.\n+\n+   * @param useInterpolationError if true, interpolation error is used\n+   * for stepsize control\n+   * @param mudif interpolation order control parameter (the parameter\n+   * is reset to default if <= 0 or >= 7)\n+   */\n+  public void setInterpolationControl(final boolean useInterpolationError,\n+                                      final int mudif) {\n+\n+    this.useInterpolationError = useInterpolationError;\n+\n+    if ((mudif <= 0) || (mudif >= 7)) {\n+      this.mudif = 4;\n+    } else {\n+      this.mudif = mudif;\n+    }\n+\n+  }\n+\n+  /** Update scaling array.\n+   * @param y1 first state vector to use for scaling\n+   * @param y2 second state vector to use for scaling\n+   * @param scale scaling array to update\n+   */\n+  private void rescale(final double[] y1, final double[] y2, final double[] scale) {\n+    if (vecAbsoluteTolerance == null) {\n+      for (int i = 0; i < scale.length; ++i) {\n+        final double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));\n+        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * yi;\n+      }\n+    } else {\n+      for (int i = 0; i < scale.length; ++i) {\n+        final double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));\n+        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yi;\n+      }\n+    }\n+  }\n+\n+  /** Perform integration over one step using substeps of a modified\n+   * midpoint method.\n+   * @param equations differential equations to integrate\n+   * @param t0 initial time\n+   * @param y0 initial value of the state vector at t0\n+   * @param step global step\n+   * @param k iteration number (from 0 to sequence.length - 1)\n+   * @param scale scaling array\n+   * @param f placeholder where to put the state vector derivatives at each substep\n+   *          (element 0 already contains initial derivative)\n+   * @param yMiddle placeholder where to put the state vector at the middle of the step\n+   * @param yEnd placeholder where to put the state vector at the end\n+   * @param yTmp placeholder for one state vector\n+   * @return true if computation was done properly,\n+   *         false if stability check failed before end of computation\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  private boolean tryStep(final FirstOrderDifferentialEquations equations,\n+                          final double t0, final double[] y0, final double step, final int k,\n+                          final double[] scale, final double[][] f,\n+                          final double[] yMiddle, final double[] yEnd,\n+                          final double[] yTmp)\n+    throws DerivativeException {\n+\n+    final int    n        = sequence[k];\n+    final double subStep  = step / n;\n+    final double subStep2 = 2 * subStep;\n+\n+    // first substep\n+    double t = t0 + subStep;\n+    for (int i = 0; i < y0.length; ++i) {\n+      yTmp[i] = y0[i];\n+      yEnd[i] = y0[i] + subStep * f[0][i];\n+    }\n+    equations.computeDerivatives(t, yEnd, f[1]);\n+\n+    // other substeps\n+    for (int j = 1; j < n; ++j) {\n+\n+      if (2 * j == n) {\n+        // save the point at the middle of the step\n+        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n+      }\n+\n+      t += subStep;\n+      for (int i = 0; i < y0.length; ++i) {\n+        final double middle = yEnd[i];\n+        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n+        yTmp[i]       = middle;\n+      }\n+\n+      equations.computeDerivatives(t, yEnd, f[j+1]);\n+\n+      // stability check\n+      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n+        double initialNorm = 0.0;\n+        for (int l = 0; l < y0.length; ++l) {\n+          final double ratio = f[0][l] / scale[l];\n+          initialNorm += ratio * ratio;\n+        }\n+        double deltaNorm = 0.0;\n+        for (int l = 0; l < y0.length; ++l) {\n+          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n+          deltaNorm += ratio * ratio;\n+        }\n+        if (deltaNorm > 4 * Math.max(1.0e-15, initialNorm)) {\n+          return false;\n+        }\n+      }\n+\n+    }\n+\n+    // correction of the last substep (at t0 + step)\n+    for (int i = 0; i < y0.length; ++i) {\n+      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n+    }\n+\n+    return true;\n+\n+  }\n+\n+  /** Extrapolate a vector.\n+   * @param offset offset to use in the coefficients table\n+   * @param k index of the last updated point\n+   * @param diag working diagonal of the Aitken-Neville's\n+   * triangle, without the last element\n+   * @param last last element\n+   */\n+  private void extrapolate(final int offset, final int k,\n+                           final double[][] diag, final double[] last) {\n+\n+    // update the diagonal\n+    for (int j = 1; j < k; ++j) {\n+      for (int i = 0; i < last.length; ++i) {\n+        // Aitken-Neville's recursive formula\n+        diag[k-j-1][i] = diag[k-j][i] +\n+                         coeff[k+offset][j-1] * (diag[k-j][i] - diag[k-j-1][i]);\n+      }\n+    }\n+\n+    // update the last element\n+    for (int i = 0; i < last.length; ++i) {\n+      // Aitken-Neville's recursive formula\n+      last[i] = diag[0][i] + coeff[k+offset][k-1] * (diag[0][i] - last[i]);\n+    }\n+  }\n+\n+  /** {@inheritDoc} */\n+  public double integrate(final FirstOrderDifferentialEquations equations,\n+                          final double t0, final double[] y0, final double t, final double[] y)\n+  throws DerivativeException, IntegratorException {\n+\n+    sanityChecks(equations, t0, y0, t, y);\n+    final boolean forward = (t > t0);\n+\n+    // create some internal working arrays\n+    final double[] yDot0   = new double[y0.length];\n+    final double[] y1      = new double[y0.length];\n+    final double[] yTmp    = new double[y0.length];\n+    final double[] yTmpDot = new double[y0.length];\n+\n+    final double[][] diagonal = new double[sequence.length-1][];\n+    final double[][] y1Diag = new double[sequence.length-1][];\n+    for (int k = 0; k < sequence.length-1; ++k) {\n+      diagonal[k] = new double[y0.length];\n+      y1Diag[k] = new double[y0.length];\n+    }\n+\n+    final double[][][] fk  = new double[sequence.length][][];\n+    for (int k = 0; k < sequence.length; ++k) {\n+\n+      fk[k]    = new double[sequence[k] + 1][];\n+\n+      // all substeps start at the same point, so share the first array\n+      fk[k][0] = yDot0;\n+\n+      for (int l = 0; l < sequence[k]; ++l) {\n+        fk[k][l+1] = new double[y0.length];\n+      }\n+\n+    }\n+\n+    if (y != y0) {\n+      System.arraycopy(y0, 0, y, 0, y0.length);\n+    }\n+\n+    double[] yDot1      = null;\n+    double[][] yMidDots = null;\n+    if (denseOutput) {\n+      yDot1    = new double[y0.length];\n+      yMidDots = new double[1 + 2 * sequence.length][];\n+      for (int j = 0; j < yMidDots.length; ++j) {\n+        yMidDots[j] = new double[y0.length];\n+      }\n+    } else {\n+      yMidDots    = new double[1][];\n+      yMidDots[0] = new double[y0.length];\n+    }\n+\n+    // initial scaling\n+    final double[] scale = new double[y0.length];\n+    rescale(y, y, scale);\n+\n+    // initial order selection\n+    final double tol =\n+        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n+    final double log10R = Math.log(Math.max(1.0e-10, tol)) / Math.log(10.0);\n+    int targetIter = Math.max(1,\n+                              Math.min(sequence.length - 2,\n+                                       (int) Math.floor(0.5 - 0.6 * log10R)));\n+    // set up an interpolator sharing the integrator arrays\n+    AbstractStepInterpolator interpolator = null;\n+    if (denseOutput || (! eventsHandlersManager.isEmpty())) {\n+      interpolator = new GraggBulirschStoerStepInterpolator(y, yDot0,\n+                                                            y1, yDot1,\n+                                                            yMidDots, forward);\n+    } else {\n+      interpolator = new DummyStepInterpolator(y, forward);\n+    }\n+    interpolator.storeTime(t0);\n+\n+    stepStart = t0;\n+    double  hNew             = 0;\n+    double  maxError         = Double.MAX_VALUE;\n+    boolean previousRejected = false;\n+    boolean firstTime        = true;\n+    boolean newStep          = true;\n+    boolean lastStep         = false;\n+    boolean firstStepAlreadyComputed = false;\n+    for (StepHandler handler : stepHandlers) {\n+        handler.reset();\n+    }\n+    costPerTimeUnit[0] = 0;\n+    while (! lastStep) {\n+\n+      double error;\n+      boolean reject = false;\n+\n+      if (newStep) {\n+\n+        interpolator.shift();\n+\n+        // first evaluation, at the beginning of the step\n+        if (! firstStepAlreadyComputed) {\n+          equations.computeDerivatives(stepStart, y, yDot0);\n+        }\n+\n+        if (firstTime) {\n+\n+          hNew = initializeStep(equations, forward,\n+                                2 * targetIter + 1, scale,\n+                                stepStart, y, yDot0, yTmp, yTmpDot);\n+\n+          if (! forward) {\n+            hNew = -hNew;\n+          }\n+\n+        }\n+\n+        newStep = false;\n+\n+      }\n+\n+      stepSize = hNew;\n+\n+      // step adjustment near bounds\n+      if ((forward && (stepStart + stepSize > t)) ||\n+          ((! forward) && (stepStart + stepSize < t))) {\n+        stepSize = t - stepStart;\n+      }\n+      final double nextT = stepStart + stepSize;\n+      lastStep = forward ? (nextT >= t) : (nextT <= t);\n+\n+      // iterate over several substep sizes\n+      int k = -1;\n+      for (boolean loop = true; loop; ) {\n+\n+        ++k;\n+\n+        // modified midpoint integration with the current substep\n+        if ( ! tryStep(equations, stepStart, y, stepSize, k, scale, fk[k],\n+                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n+                       (k == 0) ? y1 : y1Diag[k-1],\n+                       yTmp)) {\n+\n+          // the stability check failed, we reduce the global step\n+          hNew   = Math.abs(filterStep(stepSize * stabilityReduction, forward, false));\n+          reject = true;\n+          loop   = false;\n+\n+        } else {\n+\n+          // the substep was computed successfully\n+          if (k > 0) {\n+\n+            // extrapolate the state at the end of the step\n+            // using last iteration data\n+            extrapolate(0, k, y1Diag, y1);\n+            rescale(y, y1, scale);\n+\n+            // estimate the error at the end of the step.\n+            error = 0;\n+            for (int j = 0; j < y0.length; ++j) {\n+              final double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j];\n+              error += e * e;\n+            }\n+            error = Math.sqrt(error / y0.length);\n+\n+            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n+              // error is too big, we reduce the global step\n+              hNew   = Math.abs(filterStep(stepSize * stabilityReduction, forward, false));\n+              reject = true;\n+              loop   = false;\n+            } else {\n+\n+              maxError = Math.max(4 * error, 1.0);\n+\n+              // compute optimal stepsize for this order\n+              final double exp = 1.0 / (2 * k + 1);\n+              double fac = stepControl2 / Math.pow(error / stepControl1, exp);\n+              final double pow = Math.pow(stepControl3, exp);\n+              fac = Math.max(pow / stepControl4, Math.min(1 / pow, fac));\n+              optimalStep[k]     = Math.abs(filterStep(stepSize * fac, forward, true));\n+              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n+\n+              // check convergence\n+              switch (k - targetIter) {\n+\n+              case -1 :\n+                if ((targetIter > 1) && ! previousRejected) {\n+\n+                  // check if we can stop iterations now\n+                  if (error <= 1.0) {\n+                    // convergence have been reached just before targetIter\n+                    loop = false;\n+                  } else {\n+                    // estimate if there is a chance convergence will\n+                    // be reached on next iteration, using the\n+                    // asymptotic evolution of error\n+                    final double ratio = ((double) sequence [k] * sequence[k+1]) /\n+                                         (sequence[0] * sequence[0]);\n+                    if (error > ratio * ratio) {\n+                      // we don't expect to converge on next iteration\n+                      // we reject the step immediately and reduce order\n+                      reject = true;\n+                      loop   = false;\n+                      targetIter = k;\n+                      if ((targetIter > 1) &&\n+                          (costPerTimeUnit[targetIter-1] <\n+                           orderControl1 * costPerTimeUnit[targetIter])) {\n+                        --targetIter;\n+                      }\n+                      hNew = optimalStep[targetIter];\n+                    }\n+                  }\n+                }\n+                break;\n+\n+              case 0:\n+                if (error <= 1.0) {\n+                  // convergence has been reached exactly at targetIter\n+                  loop = false;\n+                } else {\n+                  // estimate if there is a chance convergence will\n+                  // be reached on next iteration, using the\n+                  // asymptotic evolution of error\n+                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n+                  if (error > ratio * ratio) {\n+                    // we don't expect to converge on next iteration\n+                    // we reject the step immediately\n+                    reject = true;\n+                    loop = false;\n+                    if ((targetIter > 1) &&\n+                        (costPerTimeUnit[targetIter-1] <\n+                         orderControl1 * costPerTimeUnit[targetIter])) {\n+                      --targetIter;\n+                    }\n+                    hNew = optimalStep[targetIter];\n+                  }\n+                }\n+                break;\n+\n+              case 1 :\n+                if (error > 1.0) {\n+                  reject = true;\n+                  if ((targetIter > 1) &&\n+                      (costPerTimeUnit[targetIter-1] <\n+                       orderControl1 * costPerTimeUnit[targetIter])) {\n+                    --targetIter;\n+                  }\n+                  hNew = optimalStep[targetIter];\n+                }\n+                loop = false;\n+                break;\n+\n+              default :\n+                if ((firstTime || lastStep) && (error <= 1.0)) {\n+                  loop = false;\n+                }\n+                break;\n+\n+              }\n+\n+            }\n+          }\n+        }\n+      }\n+\n+      // dense output handling\n+      double hInt = getMaxStep();\n+      if (denseOutput && ! reject) {\n+\n+        // extrapolate state at middle point of the step\n+        for (int j = 1; j <= k; ++j) {\n+          extrapolate(0, j, diagonal, yMidDots[0]);\n+        }\n+\n+        // derivative at end of step\n+        equations.computeDerivatives(stepStart + stepSize, y1, yDot1);\n+\n+        final int mu = 2 * k - mudif + 3;\n+\n+        for (int l = 0; l < mu; ++l) {\n+\n+          // derivative at middle point of the step\n+          final int l2 = l / 2;\n+          double factor = Math.pow(0.5 * sequence[l2], l);\n+          int middleIndex = fk[l2].length / 2;\n+          for (int i = 0; i < y0.length; ++i) {\n+            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n+          }\n+          for (int j = 1; j <= k - l2; ++j) {\n+            factor = Math.pow(0.5 * sequence[j + l2], l);\n+            middleIndex = fk[l2+j].length / 2;\n+            for (int i = 0; i < y0.length; ++i) {\n+              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n+            }\n+            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n+          }\n+          for (int i = 0; i < y0.length; ++i) {\n+            yMidDots[l+1][i] *= stepSize;\n+          }\n+\n+          // compute centered differences to evaluate next derivatives\n+          for (int j = (l + 1) / 2; j <= k; ++j) {\n+            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n+              for (int i = 0; i < y0.length; ++i) {\n+                fk[j][m][i] -= fk[j][m-2][i];\n+              }\n+            }\n+          }\n+\n+        }\n+\n+        if (mu >= 0) {\n+\n+          // estimate the dense output coefficients\n+          final GraggBulirschStoerStepInterpolator gbsInterpolator\n+            = (GraggBulirschStoerStepInterpolator) interpolator;\n+          gbsInterpolator.computeCoefficients(mu, stepSize);\n+\n+          if (useInterpolationError) {\n+            // use the interpolation error to limit stepsize\n+            final double interpError = gbsInterpolator.estimateError(scale);\n+            hInt = Math.abs(stepSize / Math.max(Math.pow(interpError, 1.0 / (mu+4)),\n+                                                0.01));\n+            if (interpError > 10.0) {\n+              hNew = hInt;\n+              reject = true;\n+            }\n+          }\n+\n+          // Discrete events handling\n+          if (!reject) {\n+            interpolator.storeTime(stepStart + stepSize);\n+            if (eventsHandlersManager.evaluateStep(interpolator)) {\n+              reject = true;\n+              hNew = Math.abs(eventsHandlersManager.getEventTime() - stepStart);\n+            }\n+          }\n+\n+        }\n+\n+        if (!reject) {\n+          // we will reuse the slope for the beginning of next step\n+          firstStepAlreadyComputed = true;\n+          System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n+        }\n+\n+      }\n+\n+      if (! reject) {\n+\n+        // store end of step state\n+        final double nextStep = stepStart + stepSize;\n+        System.arraycopy(y1, 0, y, 0, y0.length);\n+\n+        eventsHandlersManager.stepAccepted(nextStep, y);\n+        if (eventsHandlersManager.stop()) {\n+          lastStep = true;\n+        }\n+\n+        // provide the step data to the step handler\n+        interpolator.storeTime(nextStep);\n+        for (StepHandler handler : stepHandlers) {\n+            handler.handleStep(interpolator, lastStep);\n+        }\n+        stepStart = nextStep;\n+\n+        if (eventsHandlersManager.reset(stepStart, y) && ! lastStep) {\n+          // some switching function has triggered changes that\n+          // invalidate the derivatives, we need to recompute them\n+          firstStepAlreadyComputed = false;\n+        }\n+\n+        int optimalIter;\n+        if (k == 1) {\n+          optimalIter = 2;\n+          if (previousRejected) {\n+            optimalIter = 1;\n+          }\n+        } else if (k <= targetIter) {\n+          optimalIter = k;\n+          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n+            optimalIter = k-1;\n+          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n+            optimalIter = Math.min(k+1, sequence.length - 2);\n+          }\n+        } else {\n+          optimalIter = k - 1;\n+          if ((k > 2) &&\n+              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n+            optimalIter = k - 2;\n+          }\n+          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n+            optimalIter = Math.min(k, sequence.length - 2);\n+          }\n+        }\n+\n+        if (previousRejected) {\n+          // after a rejected step neither order nor stepsize\n+          // should increase\n+          targetIter = Math.min(optimalIter, k);\n+          hNew = Math.min(Math.abs(stepSize), optimalStep[targetIter]);\n+        } else {\n+          // stepsize control\n+          if (optimalIter <= k) {\n+            hNew = optimalStep[optimalIter];\n+          } else {\n+            if ((k < targetIter) &&\n+                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n+              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n+                               forward, false);\n+            } else {\n+              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n+                                forward, false);\n+            }\n+          }\n+\n+          targetIter = optimalIter;\n+\n+        }\n+\n+        newStep = true;\n+\n+      }\n+\n+      hNew = Math.min(hNew, hInt);\n+      if (! forward) {\n+        hNew = -hNew;\n+      }\n+\n+      firstTime = false;\n+\n+      if (reject) {\n+        lastStep = false;\n+        previousRejected = true;\n+      } else {\n+        previousRejected = false;\n+      }\n+\n+    }\n+\n+    return stepStart;\n+\n+  }\n+\n+  /** maximal order. */\n+  private int maxOrder;\n+\n+  /** step size sequence. */\n+  private int[] sequence;\n+\n+  /** overall cost of applying step reduction up to iteration k+1,\n+   *  in number of calls.\n+   */\n+  private int[] costPerStep;\n+\n+  /** cost per unit step. */\n+  private double[] costPerTimeUnit;\n+\n+  /** optimal steps for each order. */\n+  private double[] optimalStep;\n+\n+  /** extrapolation coefficients. */\n+  private double[][] coeff;\n+\n+  /** stability check enabling parameter. */\n+  private boolean performTest;\n+\n+  /** maximal number of checks for each iteration. */\n+  private int maxChecks;\n+\n+  /** maximal number of iterations for which checks are performed. */\n+  private int maxIter;\n+\n+  /** stepsize reduction factor in case of stability check failure. */\n+  private double stabilityReduction;\n+\n+  /** first stepsize control factor. */\n+  private double stepControl1;\n+\n+  /** second stepsize control factor. */\n+  private double stepControl2;\n+\n+  /** third stepsize control factor. */\n+  private double stepControl3;\n+\n+  /** fourth stepsize control factor. */\n+  private double stepControl4;\n+\n+  /** first order control factor. */\n+  private double orderControl1;\n+\n+  /** second order control factor. */\n+  private double orderControl2;\n+\n+  /** dense outpute required. */\n+  private boolean denseOutput;\n+\n+  /** use interpolation error in stepsize control. */\n+  private boolean useInterpolationError;\n+\n+  /** interpolation order control parameter. */\n+  private int mudif;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements an interpolator for the Gragg-Bulirsch-Stoer\n+ * integrator.\n+ *\n+ * <p>This interpolator compute dense output inside the last step\n+ * produced by a Gragg-Bulirsch-Stoer integrator.</p>\n+ *\n+ * <p>\n+ * This implementation is basically a reimplementation in Java of the\n+ * <a\n+ * href=\"http://www.unige.ch/math/folks/hairer/prog/nonstiff/odex.f\">odex</a>\n+ * fortran code by E. Hairer and G. Wanner. The redistribution policy\n+ * for this code is available <a\n+ * href=\"http://www.unige.ch/~hairer/prog/licence.txt\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+ * </p>\n+ *\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>Copyright (c) 2004, Ernst Hairer</td></tr>\n+ *\n+ * <tr><td>Redistribution and use in source and binary forms, with or\n+ * without modification, are permitted provided that the following\n+ * conditions are met:\n+ * <ul>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ *  <li>Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in the\n+ *      documentation and/or other materials provided with the distribution.</li>\n+ * </ul></td></tr>\n+ *\n+ * <tr><td><strong>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n+ * CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</strong></td></tr>\n+ * </table>\n+ *\n+ * @see GraggBulirschStoerIntegrator\n+ * @version $Revision$ $Date$\n+ * @author E. Hairer and G. Wanner (fortran version)\n+ * @since 1.2\n+ */\n+\n+class GraggBulirschStoerStepInterpolator\n+  extends AbstractStepInterpolator {\n+\n+  /** Slope at the beginning of the step. */\n+  private double[] y0Dot;\n+\n+  /** State at the end of the step. */\n+  private double[] y1;\n+\n+  /** Slope at the end of the step. */\n+  private double[] y1Dot;\n+\n+  /** Derivatives at the middle of the step.\n+   * element 0 is state at midpoint, element 1 is first derivative ...\n+   */\n+  private double[][] yMidDots;\n+\n+  /** Interpolation polynoms. */\n+  private double[][] polynoms;\n+\n+  /** Error coefficients for the interpolation. */\n+  private double[] errfac;\n+\n+  /** Degree of the interpolation polynoms. */\n+  private int currentDegree;\n+\n+  /** Reallocate the internal tables.\n+   * Reallocate the internal tables in order to be able to handle\n+   * interpolation polynoms up to the given degree\n+   * @param maxDegree maximal degree to handle\n+   */\n+  private void resetTables(final int maxDegree) {\n+\n+    if (maxDegree < 0) {\n+      polynoms      = null;\n+      errfac        = null;\n+      currentDegree = -1;\n+    } else {\n+\n+      final double[][] newPols = new double[maxDegree + 1][];\n+      if (polynoms != null) {\n+        System.arraycopy(polynoms, 0, newPols, 0, polynoms.length);\n+        for (int i = polynoms.length; i < newPols.length; ++i) {\n+          newPols[i] = new double[currentState.length];\n+        }\n+      } else {\n+        for (int i = 0; i < newPols.length; ++i) {\n+          newPols[i] = new double[currentState.length];\n+        }\n+      }\n+      polynoms = newPols;\n+\n+      // initialize the error factors array for interpolation\n+      if (maxDegree <= 4) {\n+        errfac = null;\n+      } else {\n+        errfac = new double[maxDegree - 4];\n+        for (int i = 0; i < errfac.length; ++i) {\n+          final int ip5 = i + 5;\n+          errfac[i] = 1.0 / (ip5 * ip5);\n+          final double e = 0.5 * Math.sqrt (((double) (i + 1)) / ip5);\n+          for (int j = 0; j <= i; ++j) {\n+            errfac[i] *= e / (j + 1);\n+          }\n+        }\n+      }\n+\n+      currentDegree = 0;\n+\n+    }\n+\n+  }\n+\n+  /** Simple constructor.\n+   * This constructor should not be used directly, it is only intended\n+   * for the serialization process.\n+   */\n+  public GraggBulirschStoerStepInterpolator() {\n+    y0Dot    = null;\n+    y1       = null;\n+    y1Dot    = null;\n+    yMidDots = null;\n+    resetTables(-1);\n+  }\n+\n+  /** Simple constructor.\n+   * @param y reference to the integrator array holding the current state\n+   * @param y0Dot reference to the integrator array holding the slope\n+   * at the beginning of the step\n+   * @param y1 reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param y1Dot reference to the integrator array holding the slope\n+   * at theend of the step\n+   * @param yMidDots reference to the integrator array holding the\n+   * derivatives at the middle point of the step\n+   * @param forward integration direction indicator\n+   */\n+  public GraggBulirschStoerStepInterpolator(final double[] y, final double[] y0Dot,\n+                                            final double[] y1, final double[] y1Dot,\n+                                            final double[][] yMidDots,\n+                                            final boolean forward) {\n+\n+    super(y, forward);\n+    this.y0Dot    = y0Dot;\n+    this.y1       = y1;\n+    this.y1Dot    = y1Dot;\n+    this.yMidDots = yMidDots;\n+\n+    resetTables(yMidDots.length + 4);\n+\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public GraggBulirschStoerStepInterpolator\n+    (final GraggBulirschStoerStepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    final int dimension = currentState.length;\n+\n+    // the interpolator has been finalized,\n+    // the following arrays are not needed anymore\n+    y0Dot    = null;\n+    y1       = null;\n+    y1Dot    = null;\n+    yMidDots = null;\n+\n+    // copy the interpolation polynoms (up to the current degree only)\n+    if (interpolator.polynoms == null) {\n+      polynoms = null;\n+      currentDegree = -1;\n+    } else {\n+      resetTables(interpolator.currentDegree);\n+      for (int i = 0; i < polynoms.length; ++i) {\n+        polynoms[i] = new double[dimension];\n+        System.arraycopy(interpolator.polynoms[i], 0,\n+                         polynoms[i], 0, dimension);\n+      }\n+      currentDegree = interpolator.currentDegree;\n+    }\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected StepInterpolator doCopy() {\n+    return new GraggBulirschStoerStepInterpolator(this);\n+  }\n+\n+\n+  /** Compute the interpolation coefficients for dense output.\n+   * @param mu degree of the interpolation polynomial\n+   * @param h current step\n+   */\n+  public void computeCoefficients(final int mu, final double h) {\n+\n+    if ((polynoms == null) || (polynoms.length <= (mu + 4))) {\n+      resetTables(mu + 4);\n+    }\n+\n+    currentDegree = mu + 4;\n+\n+    for (int i = 0; i < currentState.length; ++i) {\n+\n+      final double yp0   = h * y0Dot[i];\n+      final double yp1   = h * y1Dot[i];\n+      final double ydiff = y1[i] - currentState[i];\n+      final double aspl  = ydiff - yp1;\n+      final double bspl  = yp0 - ydiff;\n+\n+      polynoms[0][i] = currentState[i];\n+      polynoms[1][i] = ydiff;\n+      polynoms[2][i] = aspl;\n+      polynoms[3][i] = bspl;\n+\n+      if (mu < 0) {\n+        return;\n+      }\n+\n+      // compute the remaining coefficients\n+      final double ph0 = 0.5 * (currentState[i] + y1[i]) + 0.125 * (aspl + bspl);\n+      polynoms[4][i] = 16 * (yMidDots[0][i] - ph0);\n+\n+      if (mu > 0) {\n+        final double ph1 = ydiff + 0.25 * (aspl - bspl);\n+        polynoms[5][i] = 16 * (yMidDots[1][i] - ph1);\n+\n+        if (mu > 1) {\n+          final double ph2 = yp1 - yp0;\n+          polynoms[6][i] = 16 * (yMidDots[2][i] - ph2 + polynoms[4][i]);\n+\n+          if (mu > 2) {\n+            final double ph3 = 6 * (bspl - aspl);\n+            polynoms[7][i] = 16 * (yMidDots[3][i] - ph3 + 3 * polynoms[5][i]);\n+\n+            for (int j = 4; j <= mu; ++j) {\n+              final double fac1 = 0.5 * j * (j - 1);\n+              final double fac2 = 2 * fac1 * (j - 2) * (j - 3);\n+              polynoms[j+4][i] =\n+                  16 * (yMidDots[j][i] + fac1 * polynoms[j+2][i] - fac2 * polynoms[j][i]);\n+            }\n+\n+          }\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  /** Estimate interpolation error.\n+   * @param scale scaling array\n+   * @return estimate of the interpolation error\n+   */\n+  public double estimateError(final double[] scale) {\n+    double error = 0;\n+    if (currentDegree >= 5) {\n+      for (int i = 0; i < currentState.length; ++i) {\n+        final double e = polynoms[currentDegree][i] / scale[i];\n+        error += e * e;\n+      }\n+      error = Math.sqrt(error / currentState.length) * errfac[currentDegree-5];\n+    }\n+    return error;\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected void computeInterpolatedState(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    final int dimension = currentState.length;\n+\n+    final double oneMinusTheta = 1.0 - theta;\n+    final double theta05       = theta - 0.5;\n+    final double tOmT          = theta * oneMinusTheta;\n+    final double t4            = tOmT * tOmT;\n+    final double t4Dot         = 2 * tOmT * (1 - 2 * theta);\n+    final double dot1          = 1.0 / h;\n+    final double dot2          = theta * (2 - 3 * theta) / h;\n+    final double dot3          = ((3 * theta - 4) * theta + 1) / h;\n+\n+    for (int i = 0; i < dimension; ++i) {\n+\n+        final double p0 = polynoms[0][i];\n+        final double p1 = polynoms[1][i];\n+        final double p2 = polynoms[2][i];\n+        final double p3 = polynoms[3][i];\n+        interpolatedState[i] = p0 + theta * (p1 + oneMinusTheta * (p2 * theta + p3 * oneMinusTheta));\n+        interpolatedDerivatives[i] = dot1 * p1 + dot2 * p2 + dot3 * p3;\n+\n+        if (currentDegree > 3) {\n+            double cDot = 0;\n+            double c = polynoms[currentDegree][i];\n+            for (int j = currentDegree - 1; j > 3; --j) {\n+                final double d = 1.0 / (j - 3);\n+                cDot = d * (theta05 * cDot + c);\n+                c = polynoms[j][i] + c * d * theta05;\n+            }\n+            interpolatedState[i]       += t4 * c;\n+            interpolatedDerivatives[i] += (t4 * cDot + t4Dot * c) / h;\n+        }\n+\n+    }\n+\n+    if (h == 0) {\n+        // in this degenerated case, the previous computation leads to NaN for derivatives\n+        // we fix this by using the derivatives at midpoint\n+        System.arraycopy(yMidDots[1], 0, interpolatedDerivatives, 0, dimension);\n+    }\n+\n+  }\n+    \n+  /** {@inheritDoc} */\n+  public void writeExternal(final ObjectOutput out)\n+    throws IOException {\n+\n+    final int dimension = currentState.length;\n+\n+    // save the state of the base class\n+    writeBaseExternal(out);\n+\n+    // save the local attributes (but not the temporary vectors)\n+    out.writeInt(currentDegree);\n+    for (int k = 0; k <= currentDegree; ++k) {\n+      for (int l = 0; l < dimension; ++l) {\n+        out.writeDouble(polynoms[k][l]);\n+      }\n+    }\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void readExternal(final ObjectInput in)\n+    throws IOException {\n+\n+    // read the base class \n+    final double t = readBaseExternal(in);\n+    final int dimension = currentState.length;\n+\n+    // read the local attributes\n+    final int degree = in.readInt();\n+    resetTables(degree);\n+    currentDegree = degree;\n+\n+    for (int k = 0; k <= currentDegree; ++k) {\n+      for (int l = 0; l < dimension; ++l) {\n+        polynoms[k][l] = in.readDouble();\n+      }\n+    }\n+\n+    try {\n+      // we can now set the interpolated time and state\n+      setInterpolatedTime(t);\n+    } catch (DerivativeException e) {\n+      throw MathRuntimeException.createIOException(e);\n+    }\n+\n+  }\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = 7320613236731409847L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/HighamHall54Integrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class implements the 5(4) Higham and Hall integrator for\n+ * Ordinary Differential Equations.\n+ *\n+ * <p>This integrator is an embedded Runge-Kutta integrator\n+ * of order 5(4) used in local extrapolation mode (i.e. the solution\n+ * is computed using the high order formula) with stepsize control\n+ * (and automatic step initialization) and continuous output. This\n+ * method uses 7 functions evaluations per step.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class HighamHall54Integrator\n+  extends EmbeddedRungeKuttaIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 1462328766749870097L;\n+\n+  /** Integrator method name. */\n+  private static final String METHOD_NAME = \"Higham-Hall 5(4)\";\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] staticC = {\n+    2.0/9.0, 1.0/3.0, 1.0/2.0, 3.0/5.0, 1.0, 1.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] staticA = {\n+    {2.0/9.0},\n+    {1.0/12.0, 1.0/4.0},\n+    {1.0/8.0, 0.0, 3.0/8.0},\n+    {91.0/500.0, -27.0/100.0, 78.0/125.0, 8.0/125.0},\n+    {-11.0/20.0, 27.0/20.0, 12.0/5.0, -36.0/5.0, 5.0},\n+    {1.0/12.0, 0.0, 27.0/32.0, -4.0/3.0, 125.0/96.0, 5.0/48.0}\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] staticB = {\n+    1.0/12.0, 0.0, 27.0/32.0, -4.0/3.0, 125.0/96.0, 5.0/48.0, 0.0\n+  };\n+\n+  /** Error weights Butcher array. */\n+  private static final double[] staticE = {\n+    -1.0/20.0, 0.0, 81.0/160.0, -6.0/5.0, 25.0/32.0, 1.0/16.0, -1.0/10.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a fifth order Higham and Hall integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public HighamHall54Integrator(final double minStep, final double maxStep,\n+                                final double scalAbsoluteTolerance,\n+                                final double scalRelativeTolerance) {\n+    super(METHOD_NAME, false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),\n+          minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a fifth order Higham and Hall integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public HighamHall54Integrator(final double minStep, final double maxStep,\n+                                final double[] vecAbsoluteTolerance,\n+                                final double[] vecRelativeTolerance) {\n+    super(METHOD_NAME, false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),\n+          minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+  }\n+\n+  /** {@inheritDoc} */\n+  public int getOrder() {\n+    return 5;\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected double estimateError(final double[][] yDotK,\n+                                 final double[] y0, final double[] y1,\n+                                 final double h) {\n+\n+    double error = 0;\n+\n+    for (int j = 0; j < y0.length; ++j) {\n+      double errSum = staticE[0] * yDotK[0][j];\n+      for (int l = 1; l < staticE.length; ++l) {\n+        errSum += staticE[l] * yDotK[l][j];\n+      }\n+\n+      final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n+      final double tol = (vecAbsoluteTolerance == null) ?\n+                         (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n+                         (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n+      final double ratio  = h * errSum / tol;\n+      error += ratio * ratio;\n+\n+    }\n+\n+    return Math.sqrt(error / y0.length);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class represents an interpolator over the last step during an\n+ * ODE integration for the 5(4) Higham and Hall integrator.\n+ *\n+ * @see HighamHall54Integrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class HighamHall54StepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link EmbeddedRungeKuttaIntegrator} uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public HighamHall54StepInterpolator() {\n+    super();\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public HighamHall54StepInterpolator(final HighamHall54StepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected StepInterpolator doCopy() {\n+    return new HighamHall54StepInterpolator(this);\n+  }\n+\n+\n+  /** {@inheritDoc} */\n+  protected void computeInterpolatedState(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    final double theta2 = theta * theta;\n+\n+    final double b0 = h * (-1.0/12.0 + theta * (1.0 + theta * (-15.0/4.0 + theta * (16.0/3.0 + theta * -5.0/2.0))));\n+    final double b2 = h * (-27.0/32.0 + theta2 * (459.0/32.0 + theta * (-243.0/8.0 + theta * 135.0/8.0)));\n+    final double b3 = h * (4.0/3.0 + theta2 * (-22.0 + theta * (152.0/3.0  + theta * -30.0)));\n+    final double b4 = h * (-125.0/96.0 + theta2 * (375.0/32.0 + theta * (-625.0/24.0 + theta * 125.0/8.0)));\n+    final double b5 = h * (-5.0/48.0 + theta2 * (-5.0/16.0 + theta * 5.0/12.0));\n+    final double bDot0 = 1 + theta * (-15.0/2.0 + theta * (16.0 - 10.0 * theta));\n+    final double bDot2 = theta * (459.0/16.0 + theta * (-729.0/8.0 + 135.0/2.0 * theta));\n+    final double bDot3 = theta * (-44.0 + theta * (152.0 - 120.0 * theta));\n+    final double bDot4 = theta * (375.0/16.0 + theta * (-625.0/8.0 + 125.0/2.0 * theta));\n+    final double bDot5 = theta * 5.0/8.0 * (2 * theta - 1);\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+        final double yDot0 = yDotK[0][i];\n+        final double yDot2 = yDotK[2][i];\n+        final double yDot3 = yDotK[3][i];\n+        final double yDot4 = yDotK[4][i];\n+        final double yDot5 = yDotK[5][i];\n+        interpolatedState[i] =\n+            currentState[i] + b0 * yDot0 + b2 * yDot2 + b3 * yDot3 + b4 * yDot4 + b5 * yDot5;\n+        interpolatedDerivatives[i] =\n+            bDot0 * yDot0 + bDot2 * yDot2 + bDot3 * yDot3 + bDot4 * yDot4 + bDot5 * yDot5;\n+    }\n+\n+  }\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -3583240427587318654L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/MidpointIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class implements a second order Runge-Kutta integrator for\n+ * Ordinary Differential Equations.\n+ *\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |  0    0\n+ *   1/2 | 1/2   0\n+ *       |----------\n+ *       |  0    1\n+ * </pre>\n+ * </p>\n+ *\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class MidpointIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -7690774342890000483L;\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] c = {\n+    1.0 / 2.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] a = {\n+    { 1.0 / 2.0 }\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] b = {\n+    0.0, 1.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a midpoint integrator with the given step.\n+   * @param step integration step\n+   */\n+  public MidpointIntegrator(final double step) {\n+    super(\"midpoint\", c, a, b, new MidpointStepInterpolator(), step);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements a step interpolator for second order\n+ * Runge-Kutta integrator.\n+ *\n+ * <p>This interpolator computes dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+ *\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h) + (1-theta) h [theta y'_1 - (1+theta) y'_2]\n+ * </pre>\n+ *\n+ * where theta belongs to [0 ; 1] and where y'_1 and y'_2 are the two\n+ * evaluations of the derivatives already computed during the\n+ * step.</p>\n+ *\n+ * @see MidpointIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class MidpointStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+    \n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public MidpointStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public MidpointStepInterpolator(final MidpointStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected StepInterpolator doCopy() {\n+    return new MidpointStepInterpolator(this);\n+  }\n+\n+\n+  /** {@inheritDoc} */\n+  protected void computeInterpolatedState(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    final double coeff1    = oneMinusThetaH * theta;\n+    final double coeff2    = oneMinusThetaH * (1.0 + theta);\n+    final double coeffDot2 = 2 * theta;\n+    final double coeffDot1 = 1 - coeffDot2;\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      final double yDot1 = yDotK[0][i];\n+      final double yDot2 = yDotK[1][i];\n+      interpolatedState[i] = currentState[i] + coeff1 * yDot1 - coeff2 * yDot2;\n+      interpolatedDerivatives[i] = coeffDot1 * yDot1 + coeffDot2 * yDot2;\n+    }\n+\n+  }\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -865524111506042509L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/MultistepIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.ode.AbstractIntegrator;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.ODEIntegrator;\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.events.EventException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.events.EventState;\n+import org.apache.commons.math.ode.sampling.FixedStepHandler;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepNormalizer;\n+\n+/**\n+ * This class is the base class for multistep integrators for Ordinary\n+ * Differential Equations.\n+ *\n+ * @see AdamsBashforthIntegrator\n+ * @see AdamsMoultonIntegrator\n+ * @see BDFIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class MultistepIntegrator extends AbstractIntegrator {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -1705864253238417163L;\n+\n+    /** Starter integrator. */\n+    private FirstOrderIntegrator starter;\n+\n+    /** Previous steps times. */\n+    protected double[] previousT;\n+\n+    /** Previous steps derivatives. */\n+    protected double[][] previousF;\n+\n+    /** Time of last detected reset. */\n+    private double resetTime;\n+\n+    /** Prototype of the step interpolator. */\n+    protected MultistepStepInterpolator prototype;\n+                                           \n+    /**\n+     * Build a multistep integrator with the given number of steps.\n+     * <p>The default starter integrator is set to the {@link\n+     * DormandPrince853Integrator Dormand-Prince 8(5,3)} integrator with\n+     * some defaults settings.</p>\n+     * @param name name of the method\n+     * @param k number of steps of the multistep method\n+     * (including the one being computed)\n+     * @param prototype prototype of the step interpolator to use\n+     */\n+    protected MultistepIntegrator(final String name, final int k,\n+                                  final MultistepStepInterpolator prototype) {\n+        super(name);\n+        starter = new DormandPrince853Integrator(1.0e-6, 1.0e6, 1.0e-5, 1.0e-6);\n+        previousT = new double[k];\n+        previousF = new double[k][];\n+        this.prototype = prototype;\n+    }\n+\n+    /**\n+     * Get the starter integrator.\n+     * @return starter integrator\n+     */\n+    public ODEIntegrator getStarterIntegrator() {\n+        return starter;\n+    }\n+\n+    /**\n+     * Set the starter integrator.\n+     * <p>The various step and event handlers for this starter integrator\n+     * will be managed automatically by the multi-step integrator. Any\n+     * user configuration for these elements will be cleared before use.</p>\n+     * @param starter starter integrator\n+     */\n+    public void setStarterIntegrator(FirstOrderIntegrator starter) {\n+        this.starter = starter;\n+    }\n+\n+    /** Start the integration.\n+     * <p>This method computes the first few steps of the multistep method,\n+     * using the underlying starter integrator, ensuring the returned steps\n+     * all belong to the same smooth range.</p>\n+     * <p>In order to ensure smoothness, the start phase is automatically\n+     * restarted when a state or derivative reset is triggered by the\n+     * registered events handlers before this start phase is completed. As\n+     * an example, consider integrating a differential equation from t=0\n+     * to t=100 with a 4 steps method and step size equal to 0.2. If an event\n+     * resets the state at t=0.5, the start phase will not end at t=0.7 with\n+     * steps at [0.0, 0.2, 0.4, 0.6] but instead will end at t=1.1 with steps\n+     * at [0.5, 0.7, 0.9, 1.1].</p>\n+     * <p>A side effect of the need for smoothness is that an ODE triggering\n+     * short period regular resets will remain in the start phase throughout\n+     * the integration range if the step size or the number of steps to store\n+     * are too large.</p>\n+     * <p>If the start phase ends prematurely (because of some triggered event\n+     * for example), then the time of latest previous steps will be set to\n+     * <code>Double.NaN</code>.</p>\n+     * @param n number of steps to store\n+     * @param h signed step size to use for the first steps\n+     * @param manager discrete events manager to use\n+     * @param equations differential equations to integrate\n+     * @param t0 initial time\n+     * @param y state vector: contains the initial value of the state vector at t0,\n+     * will be used to put the state vector at each successful step and hence\n+     * contains the final value at the end of the start phase\n+     * @return time of the end of the start phase\n+     * @throws IntegratorException if the integrator cannot perform integration\n+     * @throws DerivativeException this exception is propagated to the caller if\n+     * the underlying user function triggers one\n+     */\n+    protected double start(final int n, final double h,\n+                           final CombinedEventsManager manager,\n+                           final FirstOrderDifferentialEquations equations,\n+                           final double t0, final double[] y)\n+        throws DerivativeException, IntegratorException {\n+\n+        // clear the first steps\n+        Arrays.fill(previousT, Double.NaN);\n+        Arrays.fill(previousF, null);\n+\n+        // configure the event handlers\n+        starter.clearEventHandlers();\n+        for (EventState state : manager.getEventsStates()) {\n+            starter.addEventHandler(new ResetCheckingWrapper(state.getEventHandler()),\n+                                    state.getMaxCheckInterval(),\n+                                    state.getConvergence(), state.getMaxIterationCount());\n+        }\n+\n+        // configure the step handlers\n+        starter.clearStepHandlers();\n+        for (final StepHandler handler : stepHandlers) {\n+            // add the user defined step handlers, filtering out the isLast indicator\n+            starter.addStepHandler(new FilteringWrapper(handler));\n+        }\n+\n+        // add one specific step handler to store the first steps\n+        final StoringStepHandler store = new StoringStepHandler(n);\n+        starter.addStepHandler(new StepNormalizer(h, store));\n+\n+        // integrate over the first few steps, ensuring no intermediate reset occurs\n+        double t = t0;\n+        double stopTime = Double.NaN;\n+        do {\n+            resetTime = Double.NaN;\n+            store.restart();\n+            // we overshoot by 1/10000 step the end to make sure we get don't miss the last point\n+            stopTime = starter.integrate(equations, t, y, t + (n - 0.9999) * h, y);\n+            if (!Double.isNaN(resetTime)) {\n+                // there was an intermediate reset, we restart\n+                t = resetTime;\n+            }\n+        } while (!Double.isNaN(resetTime));\n+\n+        // clear configuration\n+        starter.clearEventHandlers();\n+        starter.clearStepHandlers();\n+\n+        if (store.getFinalState() != null) {\n+            System.arraycopy(store.getFinalState(), 0, y, 0, y.length);\n+        }\n+        return stopTime;\n+\n+    }\n+\n+    /** Rotate the previous steps arrays.\n+     */\n+    protected void rotatePreviousSteps() {\n+        final double[] rolled = previousF[previousT.length - 1];\n+        for (int k = previousF.length - 1; k > 0; --k) {\n+            previousT[k] = previousT[k - 1];\n+            previousF[k] = previousF[k - 1];\n+        }\n+        previousF[0] = rolled;\n+    }\n+\n+    /** Event handler wrapper to check if state or derivatives have been reset. */\n+    private class ResetCheckingWrapper implements EventHandler {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = 4922660285376467937L;\n+\n+        /** Wrapped event handler. */\n+        private final EventHandler handler;\n+\n+        /** Build a new instance.\n+         * @param handler event handler to wrap\n+         */\n+        public ResetCheckingWrapper(final EventHandler handler) {\n+            this.handler = handler;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int eventOccurred(double t, double[] y) throws EventException {\n+            final int action = handler.eventOccurred(t, y);\n+            if ((action == RESET_DERIVATIVES) || (action == RESET_STATE)) {\n+                // a singularity has been encountered\n+                // we need to restart the start phase\n+                resetTime = t;\n+                return STOP;\n+            }\n+            return action;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double g(double t, double[] y) throws EventException {\n+            return handler.g(t, y);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void resetState(double t, double[] y) throws EventException {\n+            handler.resetState(t, y);\n+        }\n+        \n+    }\n+\n+    /** Step handler wrapper filtering out the isLast indicator. */\n+    private class FilteringWrapper implements StepHandler {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = 4607975253344802232L;\n+\n+        /** Wrapped step handler. */\n+        private final StepHandler handler;\n+\n+        /** Build a new instance.\n+         * @param handler step handler to wrap\n+         */\n+        public FilteringWrapper(final StepHandler handler) {\n+            this.handler = handler;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+                throws DerivativeException {\n+            // we force the isLast indicator to false EXCEPT if some event handler triggered a stop\n+            handler.handleStep(interpolator, eventsHandlersManager.stop());\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean requiresDenseOutput() {\n+            return handler.requiresDenseOutput();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void reset() {\n+            handler.reset();\n+        }\n+        \n+    }\n+\n+    /** Specialized step handler storing the first few steps. */\n+    private class StoringStepHandler implements FixedStepHandler {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = 4592974435520688797L;\n+\n+        /** Number of steps to store. */\n+        private final int n;\n+\n+        /** Counter for already stored steps. */\n+        private int count;\n+\n+        /** Final state. */\n+        private double[] finalState;\n+\n+        /** Build a new instance.\n+         * @param n number of steps to store\n+         */\n+        public StoringStepHandler(final int n) {\n+            this.n = n;\n+            restart();\n+        }\n+\n+        /** Restart storage.\n+         */\n+        public void restart() {\n+            count = 0;\n+            finalState = null;\n+        }\n+\n+        /** Get the final state.\n+         * @return final state\n+         */\n+        public double[] getFinalState() {\n+            return finalState;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void handleStep(final double t, final double[] y, final double[] yDot,\n+                               final boolean isLast) {\n+            if (count++ < n) {\n+                previousT[n - count] = t;\n+                previousF[n - count] = yDot.clone();\n+                if (count == n) {\n+                    finalState = y.clone();\n+                }\n+            }\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/MultistepStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+\n+/** This class represents an interpolator over the last step during an\n+ * ODE integration for multistep integrators.\n+ *\n+ * @see MultistepIntegrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+\n+abstract class MultistepStepInterpolator\n+    extends AbstractStepInterpolator {\n+\n+    /** Previous steps times. */\n+    protected double[] previousT;\n+\n+    /** Previous steps derivatives. */\n+    protected double[][] previousF;\n+\n+    /** Simple constructor.\n+     * This constructor builds an instance that is not usable yet, the\n+     * {@link #reinitialize} method should be called before using the\n+     * instance in order to initialize the internal arrays. This\n+     * constructor is used only in order to delay the initialization in\n+     * some cases. The {@link MultistepIntegrator} classe uses the\n+     * prototyping design pattern to create the step interpolators by\n+     * cloning an uninitialized model and latter initializing the copy.\n+     */\n+    protected MultistepStepInterpolator() {\n+        previousT = null;\n+        previousF = null;\n+    }\n+\n+    /** Copy constructor.\n+\n+     * <p>The copied interpolator should have been finalized before the\n+     * copy, otherwise the copy will not be able to perform correctly any\n+     * interpolation and will throw a {@link NullPointerException}\n+     * later. Since we don't want this constructor to throw the\n+     * exceptions finalization may involve and since we don't want this\n+     * method to modify the state of the copied interpolator,\n+     * finalization is <strong>not</strong> done automatically, it\n+     * remains under user control.</p>\n+\n+     * <p>The copy is a deep copy: its arrays are separated from the\n+     * original arrays of the instance.</p>\n+\n+     * @param interpolator interpolator to copy from.\n+\n+     */\n+    public MultistepStepInterpolator(final MultistepStepInterpolator interpolator) {\n+\n+        super(interpolator);\n+\n+        if (interpolator.currentState != null) {\n+            previousT = interpolator.previousT.clone();\n+            previousF = new double[interpolator.previousF.length][];\n+            for (int k = 0; k < interpolator.previousF.length; ++k) {\n+                previousF[k] = interpolator.previousF[k].clone();\n+            }\n+            initializeCoefficients();\n+        } else {\n+            previousT = null;\n+            previousF = null;\n+        }\n+\n+    }\n+\n+    /** Reinitialize the instance\n+     * @param y reference to the integrator array holding the state at\n+     * the end of the step\n+     * @param previousT reference to the integrator array holding the times\n+     * of the previous steps\n+     * @param previousF reference to the integrator array holding the\n+     * previous slopes\n+     * @param forward integration direction indicator\n+     */\n+    public void reinitialize(final double[] y,\n+                             final double[] previousT, final double[][] previousF,\n+                             final boolean forward) {\n+        reinitialize(y, forward);\n+        this.previousT = previousT;\n+        this.previousF = previousF;\n+        initializeCoefficients();\n+    }\n+\n+    /** Initialize the coefficients arrays.\n+     */\n+    protected abstract void initializeCoefficients();\n+\n+    /** {@inheritDoc} */\n+    public void writeExternal(final ObjectOutput out)\n+    throws IOException {\n+\n+        // save the state of the base class\n+        writeBaseExternal(out);\n+\n+        // save the local attributes\n+        out.writeInt(previousT.length);\n+        for (int k = 0; k < previousF.length; ++k) {\n+            out.writeDouble(previousT[k]);\n+            for (int i = 0; i < currentState.length; ++i) {\n+                out.writeDouble(previousF[k][i]);\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void readExternal(final ObjectInput in)\n+    throws IOException {\n+\n+        // read the base class \n+        final double t = readBaseExternal(in);\n+\n+        // read the local attributes\n+        final int kMax = in.readInt();\n+        previousT = new double[kMax];\n+        previousF = new double[kMax][];\n+        for (int k = 0; k < kMax; ++k) {\n+            previousT[k] = in.readDouble();\n+            previousF[k] = new double[currentState.length];\n+            for (int i = 0; i < currentState.length; ++i) {\n+                previousF[k][i] = in.readDouble();\n+            }\n+        }\n+\n+        // initialize the coefficients\n+        initializeCoefficients();\n+\n+        try {\n+            // we can now set the interpolated time and state\n+            setInterpolatedTime(t);\n+        } catch (DerivativeException e) {\n+            throw MathRuntimeException.createIOException(e);\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+\n+import org.apache.commons.math.ode.AbstractIntegrator;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+/**\n+ * This class implements the common part of all fixed step Runge-Kutta\n+ * integrators for Ordinary Differential Equations.\n+ *\n+ * <p>These methods are explicit Runge-Kutta methods, their Butcher\n+ * arrays are as follows :\n+ * <pre>\n+ *    0  |\n+ *   c2  | a21\n+ *   c3  | a31  a32\n+ *   ... |        ...\n+ *   cs  | as1  as2  ...  ass-1\n+ *       |--------------------------\n+ *       |  b1   b2  ...   bs-1  bs\n+ * </pre>\n+ * </p>\n+ *\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+ * @see MidpointIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public abstract class RungeKuttaIntegrator extends AbstractIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -5346558921715095559L;\n+\n+  /** Simple constructor.\n+   * Build a Runge-Kutta integrator with the given\n+   * step. The default step handler does nothing.\n+   * @param name name of the method\n+   * @param c time steps from Butcher array (without the first zero)\n+   * @param a internal weights from Butcher array (without the first empty row)\n+   * @param b propagation weights for the high order method from Butcher array\n+   * @param prototype prototype of the step interpolator to use\n+   * @param step integration step\n+   */\n+  protected RungeKuttaIntegrator(final String name,\n+                                 final double[] c, final double[][] a, final double[] b,\n+                                 final RungeKuttaStepInterpolator prototype,\n+                                 final double step) {\n+    super(name);\n+    this.c          = c;\n+    this.a          = a;\n+    this.b          = b;\n+    this.prototype  = prototype;\n+    this.step       = Math.abs(step);\n+  }\n+\n+  /** {@inheritDoc} */\n+  public double integrate(final FirstOrderDifferentialEquations equations,\n+                          final double t0, final double[] y0,\n+                          final double t, final double[] y)\n+  throws DerivativeException, IntegratorException {\n+\n+    sanityChecks(equations, t0, y0, t, y);\n+    final boolean forward = (t > t0);\n+\n+    // create some internal working arrays\n+    final int stages = c.length + 1;\n+    if (y != y0) {\n+      System.arraycopy(y0, 0, y, 0, y0.length);\n+    }\n+    final double[][] yDotK = new double[stages][];\n+    for (int i = 0; i < stages; ++i) {\n+      yDotK [i] = new double[y0.length];\n+    }\n+    final double[] yTmp = new double[y0.length];\n+\n+    // set up an interpolator sharing the integrator arrays\n+    AbstractStepInterpolator interpolator;\n+    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n+      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n+      rki.reinitialize(equations, yTmp, yDotK, forward);\n+      interpolator = rki;\n+    } else {\n+      interpolator = new DummyStepInterpolator(yTmp, forward);\n+    }\n+    interpolator.storeTime(t0);\n+\n+    // set up integration control objects\n+    stepStart = t0;\n+    stepSize  = forward ? step : -step;\n+    for (StepHandler handler : stepHandlers) {\n+        handler.reset();\n+    }\n+    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n+    boolean lastStep = false;\n+\n+    // main integration loop\n+    while (!lastStep) {\n+\n+      interpolator.shift();\n+\n+      for (boolean loop = true; loop;) {\n+\n+        // first stage\n+        equations.computeDerivatives(stepStart, y, yDotK[0]);\n+\n+        // next stages\n+        for (int k = 1; k < stages; ++k) {\n+\n+          for (int j = 0; j < y0.length; ++j) {\n+            double sum = a[k-1][0] * yDotK[0][j];\n+            for (int l = 1; l < k; ++l) {\n+              sum += a[k-1][l] * yDotK[l][j];\n+            }\n+            yTmp[j] = y[j] + stepSize * sum;\n+          }\n+\n+          equations.computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n+\n+        }\n+\n+        // estimate the state at the end of the step\n+        for (int j = 0; j < y0.length; ++j) {\n+          double sum    = b[0] * yDotK[0][j];\n+          for (int l = 1; l < stages; ++l) {\n+            sum    += b[l] * yDotK[l][j];\n+          }\n+          yTmp[j] = y[j] + stepSize * sum;\n+        }\n+\n+        // discrete events handling\n+        interpolator.storeTime(stepStart + stepSize);\n+        if (manager.evaluateStep(interpolator)) {\n+          stepSize = manager.getEventTime() - stepStart;\n+        } else {\n+          loop = false;\n+        }\n+\n+      }\n+\n+      // the step has been accepted\n+      final double nextStep = stepStart + stepSize;\n+      System.arraycopy(yTmp, 0, y, 0, y0.length);\n+      manager.stepAccepted(nextStep, y);\n+      lastStep = manager.stop();\n+\n+      // provide the step data to the step handler\n+      interpolator.storeTime(nextStep);\n+      for (StepHandler handler : stepHandlers) {\n+          handler.handleStep(interpolator, lastStep);\n+      }\n+      stepStart = nextStep;\n+\n+      if (manager.reset(stepStart, y) && ! lastStep) {\n+        // some events handler has triggered changes that\n+        // invalidate the derivatives, we need to recompute them\n+        equations.computeDerivatives(stepStart, y, yDotK[0]);\n+      }\n+\n+      // make sure step size is set to default before next step\n+      stepSize = forward ? step : -step;\n+\n+    }\n+\n+    final double stopTime = stepStart;\n+    stepStart = Double.NaN;\n+    stepSize  = Double.NaN;\n+    return stopTime;\n+\n+  }\n+\n+  /** Time steps from Butcher array (without the first zero). */\n+  private double[] c;\n+\n+  /** Internal weights from Butcher array (without the first empty row). */\n+  private double[][] a;\n+\n+  /** External weights for the high order method from Butcher array. */\n+  private double[] b;\n+\n+  /** Prototype of the step interpolator. */\n+  private RungeKuttaStepInterpolator prototype;\n+                                         \n+  /** Integration step. */\n+  private double step;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+\n+/** This class represents an interpolator over the last step during an\n+ * ODE integration for Runge-Kutta and embedded Runge-Kutta integrators.\n+ *\n+ * @see RungeKuttaIntegrator\n+ * @see EmbeddedRungeKuttaIntegrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+abstract class RungeKuttaStepInterpolator\n+  extends AbstractStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} and {@link\n+   * EmbeddedRungeKuttaIntegrator} classes use the prototyping design\n+   * pattern to create the step interpolators by cloning an\n+   * uninitialized model and latter initializing the copy.\n+   */\n+  protected RungeKuttaStepInterpolator() {\n+    super();\n+    yDotK     = null;\n+    equations = null;\n+  }\n+\n+  /** Copy constructor.\n+\n+  * <p>The copied interpolator should have been finalized before the\n+  * copy, otherwise the copy will not be able to perform correctly any\n+  * interpolation and will throw a {@link NullPointerException}\n+  * later. Since we don't want this constructor to throw the\n+  * exceptions finalization may involve and since we don't want this\n+  * method to modify the state of the copied interpolator,\n+  * finalization is <strong>not</strong> done automatically, it\n+  * remains under user control.</p>\n+\n+  * <p>The copy is a deep copy: its arrays are separated from the\n+  * original arrays of the instance.</p>\n+\n+  * @param interpolator interpolator to copy from.\n+\n+  */\n+  public RungeKuttaStepInterpolator(final RungeKuttaStepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    if (interpolator.currentState != null) {\n+      final int dimension = currentState.length;\n+\n+      yDotK = new double[interpolator.yDotK.length][];\n+      for (int k = 0; k < interpolator.yDotK.length; ++k) {\n+        yDotK[k] = new double[dimension];\n+        System.arraycopy(interpolator.yDotK[k], 0,\n+                         yDotK[k], 0, dimension);\n+      }\n+\n+    } else {\n+      yDotK = null;\n+    }\n+\n+    // we cannot keep any reference to the equations in the copy\n+    // the interpolator should have been finalized before\n+    equations = null;\n+\n+  }\n+\n+  /** Reinitialize the instance\n+   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n+   * than their counterpart step interpolators. So the interpolator\n+   * should perform the last evaluations they need by themselves. The\n+   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n+   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n+   * abstract classes call this method in order to let the step\n+   * interpolator perform the evaluations it needs. These evaluations\n+   * will be performed during the call to <code>doFinalize</code> if\n+   * any, i.e. only if the step handler either calls the {@link\n+   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n+   * {@link AbstractStepInterpolator#getInterpolatedState\n+   * getInterpolatedState} method (for an interpolator which needs a\n+   * finalization) or if it clones the step interpolator.</p>\n+   * @param equations set of differential equations being integrated\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param yDotK reference to the integrator array holding all the\n+   * intermediate slopes\n+   * @param forward integration direction indicator\n+   */\n+  public void reinitialize(final FirstOrderDifferentialEquations equations,\n+                           final double[] y, final double[][] yDotK, final boolean forward) {\n+    reinitialize(y, forward);\n+    this.yDotK = yDotK;\n+    this.equations = equations;\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void writeExternal(final ObjectOutput out)\n+    throws IOException {\n+\n+    // save the state of the base class\n+    writeBaseExternal(out);\n+\n+    // save the local attributes\n+    out.writeInt(yDotK.length);\n+    for (int k = 0; k < yDotK.length; ++k) {\n+      for (int i = 0; i < currentState.length; ++i) {\n+        out.writeDouble(yDotK[k][i]);\n+      }\n+    }\n+\n+    // we do not save any reference to the equations\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public void readExternal(final ObjectInput in)\n+    throws IOException {\n+\n+    // read the base class \n+    final double t = readBaseExternal(in);\n+\n+    // read the local attributes\n+    final int kMax = in.readInt();\n+    yDotK = new double[kMax][];\n+    for (int k = 0; k < kMax; ++k) {\n+      yDotK[k] = new double[currentState.length];\n+      for (int i = 0; i < currentState.length; ++i) {\n+        yDotK[k][i] = in.readDouble();\n+      }\n+    }\n+\n+    equations = null;\n+\n+    try {\n+      // we can now set the interpolated time and state\n+      setInterpolatedTime(t);\n+    } catch (DerivativeException e) {\n+      throw MathRuntimeException.createIOException(e);\n+    }\n+\n+  }\n+\n+  /** Slopes at the intermediate points */\n+  protected double[][] yDotK;\n+\n+  /** Reference to the differential equations being integrated. */\n+  protected FirstOrderDifferentialEquations equations;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class implements the 3/8 fourth order Runge-Kutta\n+ * integrator for Ordinary Differential Equations.\n+ *\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |  0    0    0    0\n+ *   1/3 | 1/3   0    0    0\n+ *   2/3 |-1/3   1    0    0\n+ *    1  |  1   -1    1    0\n+ *       |--------------------\n+ *       | 1/8  3/8  3/8  1/8\n+ * </pre>\n+ * </p>\n+ *\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+ * @see MidpointIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class ThreeEighthesIntegrator\n+  extends RungeKuttaIntegrator {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -2480984691453028021L;\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] c = {\n+    1.0 / 3.0, 2.0 / 3.0, 1.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] a = {\n+    {  1.0 / 3.0 },\n+    { -1.0 / 3.0, 1.0 },\n+    {  1.0, -1.0, 1.0 }\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] b = {\n+    1.0 / 8.0, 3.0 / 8.0, 3.0 / 8.0, 1.0 / 8.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a 3/8 integrator with the given step.\n+   * @param step integration step\n+   */\n+  public ThreeEighthesIntegrator(final double step) {\n+    super(\"3/8\", c, a, b, new ThreeEighthesStepInterpolator(), step);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements a step interpolator for the 3/8 fourth\n+ * order Runge-Kutta integrator.\n+ *\n+ * <p>This interpolator allows to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+ *\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h)\n+ *                    - (1 - theta) (h/8) [ (1 - 7 theta + 8 theta^2) y'_1\n+ *                                      + 3 (1 +   theta - 4 theta^2) y'_2\n+ *                                      + 3 (1 +   theta)             y'_3\n+ *                                      +   (1 +   theta + 4 theta^2) y'_4\n+ *                                        ]\n+ * </pre>\n+ *\n+ * where theta belongs to [0 ; 1] and where y'_1 to y'_4 are the four\n+ * evaluations of the derivatives already computed during the\n+ * step.</p>\n+ *\n+ * @see ThreeEighthesIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class ThreeEighthesStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+    \n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public ThreeEighthesStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public ThreeEighthesStepInterpolator(final ThreeEighthesStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** {@inheritDoc} */\n+  protected StepInterpolator doCopy() {\n+    return new ThreeEighthesStepInterpolator(this);\n+  }\n+\n+\n+  /** {@inheritDoc} */\n+  protected void computeInterpolatedState(final double theta,\n+                                          final double oneMinusThetaH)\n+      throws DerivativeException {\n+\n+      final double fourTheta2 = 4 * theta * theta;\n+      final double s          = oneMinusThetaH / 8.0;\n+      final double coeff1     = s * (1 - 7 * theta + 2 * fourTheta2);\n+      final double coeff2     = 3 * s * (1 + theta - fourTheta2);\n+      final double coeff3     = 3 * s * (1 + theta);\n+      final double coeff4     = s * (1 + theta + fourTheta2);\n+      final double coeffDot3  = 0.75 * theta;\n+      final double coeffDot1  = coeffDot3 * (4 * theta - 5) + 1;\n+      final double coeffDot2  = coeffDot3 * (5 - 6 * theta);\n+      final double coeffDot4  = coeffDot3 * (2 * theta - 1);\n+\n+      for (int i = 0; i < interpolatedState.length; ++i) {\n+          final double yDot1 = yDotK[0][i];\n+          final double yDot2 = yDotK[1][i];\n+          final double yDot3 = yDotK[2][i];\n+          final double yDot4 = yDotK[3][i];\n+          interpolatedState[i] =\n+              currentState[i] - coeff1 * yDot1 - coeff2 * yDot2 - coeff3 * yDot3 - coeff4 * yDot4;\n+          interpolatedDerivatives[i] =\n+              coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;\n+\n+      }\n+\n+  }\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -3345024435978721931L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.SecondOrderIntegrator;\n+import org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator;\n+\n+/** This abstract class represents an interpolator over the last step\n+ * during an ODE integration.\n+ *\n+ * <p>The various ODE integrators provide objects extending this class\n+ * to the step handlers. The handlers can use these objects to\n+ * retrieve the state vector at intermediate times between the\n+ * previous and the current grid points (dense output).</p>\n+ *\n+ * @see FirstOrderIntegrator\n+ * @see SecondOrderIntegrator\n+ * @see StepHandler\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ *\n+ */\n+\n+public abstract class AbstractStepInterpolator\n+  implements StepInterpolator {\n+\n+  /** previous time */\n+  protected double previousTime;\n+\n+  /** current time */\n+  protected double currentTime;\n+\n+  /** current time step */\n+  protected double h;\n+\n+  /** current state */\n+  protected double[] currentState;\n+\n+  /** interpolated time */\n+  protected double interpolatedTime;\n+\n+  /** interpolated state */\n+  protected double[] interpolatedState;\n+\n+  /** interpolated derivatives */\n+  protected double[] interpolatedDerivatives;\n+\n+  /** indicate if the step has been finalized or not. */\n+  private boolean finalized;\n+\n+  /** integration direction. */\n+  private boolean forward;\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. As an example, the {@link\n+   * EmbeddedRungeKuttaIntegrator} uses the prototyping design pattern\n+   * to create the step interpolators by cloning an uninitialized\n+   * model and latter initializing the copy.\n+   */\n+  protected AbstractStepInterpolator() {\n+    previousTime            = Double.NaN;\n+    currentTime             = Double.NaN;\n+    h                       = Double.NaN;\n+    interpolatedTime        = Double.NaN;\n+    currentState            = null;\n+    interpolatedState       = null;\n+    interpolatedDerivatives = null;\n+    finalized               = false;\n+    this.forward            = true;\n+  }\n+\n+  /** Simple constructor.\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param forward integration direction indicator\n+   */\n+  protected AbstractStepInterpolator(final double[] y, final boolean forward) {\n+\n+    previousTime      = Double.NaN;\n+    currentTime       = Double.NaN;\n+    h                 = Double.NaN;\n+    interpolatedTime  = Double.NaN;\n+\n+    currentState            = y;\n+    interpolatedState       = new double[y.length];\n+    interpolatedDerivatives = new double[y.length];\n+\n+    finalized         = false;\n+    this.forward      = forward;\n+\n+  }\n+\n+  /** Copy constructor.\n+\n+   * <p>The copied interpolator should have been finalized before the\n+   * copy, otherwise the copy will not be able to perform correctly\n+   * any derivative computation and will throw a {@link\n+   * NullPointerException} later. Since we don't want this constructor\n+   * to throw the exceptions finalization may involve and since we\n+   * don't want this method to modify the state of the copied\n+   * interpolator, finalization is <strong>not</strong> done\n+   * automatically, it remains under user control.</p>\n+\n+   * <p>The copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance.</p>\n+\n+   * @param interpolator interpolator to copy from.\n+\n+   */\n+  protected AbstractStepInterpolator(final AbstractStepInterpolator interpolator) {\n+\n+    previousTime      = interpolator.previousTime;\n+    currentTime       = interpolator.currentTime;\n+    h                 = interpolator.h;\n+    interpolatedTime  = interpolator.interpolatedTime;\n+\n+    if (interpolator.currentState != null) {\n+      currentState            = (double[]) interpolator.currentState.clone();\n+      interpolatedState       = (double[]) interpolator.interpolatedState.clone();\n+      interpolatedDerivatives = (double[]) interpolator.interpolatedDerivatives.clone();\n+    } else {\n+      currentState            = null;\n+      interpolatedState       = null;\n+      interpolatedDerivatives = null;\n+    }\n+\n+    finalized = interpolator.finalized;\n+    forward   = interpolator.forward;\n+\n+  }\n+\n+  /** Reinitialize the instance\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param forward integration direction indicator\n+   */\n+  protected void reinitialize(final double[] y, final boolean forward) {\n+\n+    previousTime      = Double.NaN;\n+    currentTime       = Double.NaN;\n+    h                 = Double.NaN;\n+    interpolatedTime  = Double.NaN;\n+\n+    currentState            = y;\n+    interpolatedState       = new double[y.length];\n+    interpolatedDerivatives = new double[y.length];\n+\n+    finalized         = false;\n+    this.forward      = forward;\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+   public StepInterpolator copy() throws DerivativeException {\n+\n+     // finalize the step before performing copy\n+     finalizeStep();\n+\n+     // create the new independent instance\n+     return doCopy();\n+\n+   }\n+\n+   /** Really copy the finalized instance.\n+    * <p>This method is called by {@link #copy()} after the\n+    * step has been finalized. It must perform a deep copy\n+    * to have an new instance completely independent for the\n+    * original instance.\n+    * @return a copy of the finalized instance\n+    */\n+   protected abstract StepInterpolator doCopy();\n+\n+  /** Shift one step forward.\n+   * Copy the current time into the previous time, hence preparing the\n+   * interpolator for future calls to {@link #storeTime storeTime}\n+   */\n+  public void shift() {\n+    previousTime = currentTime;\n+  }\n+\n+  /** Store the current step time.\n+   * @param t current time\n+   */\n+  public void storeTime(final double t) {\n+\n+    currentTime      = t;\n+    h                = currentTime - previousTime;\n+    interpolatedTime = t;\n+    System.arraycopy(currentState, 0, interpolatedState, 0,\n+                     currentState.length);\n+\n+    // the step is not finalized anymore\n+    finalized = false;\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public double getPreviousTime() {\n+    return previousTime;\n+  }\n+    \n+  /** {@inheritDoc} */\n+  public double getCurrentTime() {\n+    return currentTime;\n+  }\n+    \n+  /** {@inheritDoc} */\n+  public double getInterpolatedTime() {\n+    return interpolatedTime;\n+  }\n+    \n+  /** {@inheritDoc} */\n+  public void setInterpolatedTime(final double time)\n+      throws DerivativeException {\n+      interpolatedTime = time;\n+      final double oneMinusThetaH = currentTime - interpolatedTime;\n+      final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\n+      computeInterpolatedState(theta, oneMinusThetaH);\n+  }\n+\n+  /** {@inheritDoc} */\n+  public boolean isForward() {\n+    return forward;\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * This is the main processing method that should be implemented by\n+   * the derived classes to perform the interpolation.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected abstract void computeInterpolatedState(double theta,\n+                                                   double oneMinusThetaH)\n+    throws DerivativeException;\n+    \n+  /** {@inheritDoc} */\n+  public double[] getInterpolatedState() {\n+    return interpolatedState;\n+  }\n+\n+  /** {@inheritDoc} */\n+  public double[] getInterpolatedDerivatives() {\n+    return interpolatedDerivatives;\n+  }\n+\n+  /**\n+   * Finalize the step.\n+\n+   * <p>Some embedded Runge-Kutta integrators need fewer functions\n+   * evaluations than their counterpart step interpolators. These\n+   * interpolators should perform the last evaluations they need by\n+   * themselves only if they need them. This method triggers these\n+   * extra evaluations. It can be called directly by the user step\n+   * handler and it is called automatically if {@link\n+   * #setInterpolatedTime} is called.</p>\n+\n+   * <p>Once this method has been called, <strong>no</strong> other\n+   * evaluation will be performed on this step. If there is a need to\n+   * have some side effects between the step handler and the\n+   * differential equations (for example update some data in the\n+   * equations once the step has been done), it is advised to call\n+   * this method explicitly from the step handler before these side\n+   * effects are set up. If the step handler induces no side effect,\n+   * then this method can safely be ignored, it will be called\n+   * transparently as needed.</p>\n+\n+   * <p><strong>Warning</strong>: since the step interpolator provided\n+   * to the step handler as a parameter of the {@link\n+   * StepHandler#handleStep handleStep} is valid only for the duration\n+   * of the {@link StepHandler#handleStep handleStep} call, one cannot\n+   * simply store a reference and reuse it later. One should first\n+   * finalize the instance, then copy this finalized instance into a\n+   * new object that can be kept.</p>\n+\n+   * <p>This method calls the protected <code>doFinalize</code> method\n+   * if it has never been called during this step and set a flag\n+   * indicating that it has been called once. It is the <code>\n+   * doFinalize</code> method which should perform the evaluations.\n+   * This wrapping prevents from calling <code>doFinalize</code> several\n+   * times and hence evaluating the differential equations too often.\n+   * Therefore, subclasses are not allowed not reimplement it, they\n+   * should rather reimplement <code>doFinalize</code>.</p>\n+\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+\n+   */\n+  public final void finalizeStep()\n+    throws DerivativeException {\n+    if (! finalized) {\n+      doFinalize();\n+      finalized = true;\n+    }\n+  }\n+\n+  /**\n+   * Really finalize the step.\n+   * The default implementation of this method does nothing.\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+   */\n+  protected void doFinalize()\n+    throws DerivativeException {\n+  }\n+\n+  /** {@inheritDoc} */\n+  public abstract void writeExternal(ObjectOutput out)\n+    throws IOException;\n+\n+  /** {@inheritDoc} */\n+  public abstract void readExternal(ObjectInput in)\n+    throws IOException;\n+\n+  /** Save the base state of the instance.\n+   * This method performs step finalization if it has not been done\n+   * before.\n+   * @param out stream where to save the state\n+   * @exception IOException in case of write error\n+   */\n+  protected void writeBaseExternal(final ObjectOutput out)\n+    throws IOException {\n+\n+    out.writeInt(currentState.length);\n+    out.writeDouble(previousTime);\n+    out.writeDouble(currentTime);\n+    out.writeDouble(h);\n+    out.writeBoolean(forward);\n+\n+    for (int i = 0; i < currentState.length; ++i) {\n+      out.writeDouble(currentState[i]);\n+    }\n+\n+    out.writeDouble(interpolatedTime);\n+\n+    // we do not store the interpolated state,\n+    // it will be recomputed as needed after reading\n+\n+    // finalize the step (and don't bother saving the now true flag)\n+    try {\n+      finalizeStep();\n+    } catch (DerivativeException e) {\n+      throw MathRuntimeException.createIOException(e);\n+    }\n+\n+  }\n+\n+  /** Read the base state of the instance.\n+   * This method does <strong>neither</strong> set the interpolated\n+   * time nor state. It is up to the derived class to reset it\n+   * properly calling the {@link #setInterpolatedTime} method later,\n+   * once all rest of the object state has been set up properly.\n+   * @param in stream where to read the state from\n+   * @return interpolated time be set later by the caller\n+   * @exception IOException in case of read error\n+   */\n+  protected double readBaseExternal(final ObjectInput in)\n+    throws IOException {\n+\n+    final int dimension = in.readInt();\n+    previousTime  = in.readDouble();\n+    currentTime   = in.readDouble();\n+    h             = in.readDouble();\n+    forward       = in.readBoolean();\n+\n+    currentState  = new double[dimension];\n+    for (int i = 0; i < currentState.length; ++i) {\n+      currentState[i] = in.readDouble();\n+    }\n+\n+    // we do NOT handle the interpolated time and state here\n+    interpolatedTime        = Double.NaN;\n+    interpolatedState       = new double[dimension];\n+    interpolatedDerivatives = new double[dimension];\n+\n+    finalized = true;\n+\n+    return in.readDouble();\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/sampling/DummyStepHandler.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * This class is a step handler that do nothing.\n+\n+ * <p>This class is provided as a convenience for users who are only\n+ * interested in the final state of an integration and not in the\n+ * intermediate steps. Its handleStep method does nothing.</p>\n+ *\n+ * <p>Since this class has no internal state, it is implemented using\n+ * the Singleton design pattern. This means that only one instance is\n+ * ever created, which can be retrieved using the getInstance\n+ * method. This explains why there is no public constructor.</p>\n+ *\n+ * @see StepHandler\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class DummyStepHandler\n+  implements StepHandler, Serializable {\n+\n+  /** Private constructor.\n+   * The constructor is private to prevent users from creating\n+   * instances (Singleton design-pattern).\n+   */\n+  private DummyStepHandler() {\n+  }\n+\n+  /** Get the only instance.\n+   * @return the only instance\n+   */\n+  public static DummyStepHandler getInstance() {\n+    return instance;\n+  }\n+\n+  /** Determines whether this handler needs dense output.\n+   * Since this handler does nothing, it does not require dense output.\n+   * @return always false\n+   */\n+  public boolean requiresDenseOutput() {\n+    return false;\n+  }\n+\n+  /** Reset the step handler.\n+   * Initialize the internal data as required before the first step is\n+   * handled.\n+   */\n+  public void reset() {\n+  }\n+\n+  /**\n+   * Handle the last accepted step.\n+   * This method does nothing in this class.\n+   * @param interpolator interpolator for the last accepted step. For\n+   * efficiency purposes, the various integrators reuse the same\n+   * object on each call, so if the instance wants to keep it across\n+   * all calls (for example to provide at the end of the integration a\n+   * continuous model valid throughout the integration range), it\n+   * should build a local copy using the clone method and store this\n+   * copy.\n+   * @param isLast true if the step is the last one\n+   */\n+  public void handleStep(final StepInterpolator interpolator, final boolean isLast) {\n+  }\n+\n+  /** The only instance. */\n+  private static DummyStepHandler instance = new DummyStepHandler();\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = 2731635121223090252L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator;\n+\n+/** This class is a step interpolator that does nothing.\n+ *\n+ * <p>This class is used when the {@link StepHandler \"step handler\"}\n+ * set up by the user does not need step interpolation. It does not\n+ * recompute the state when {@link AbstractStepInterpolator#setInterpolatedTime\n+ * setInterpolatedTime} is called. This implies the interpolated state\n+ * is always the state at the end of the current step.</p>\n+ *\n+ * @see StepHandler\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class DummyStepInterpolator\n+  extends AbstractStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * <code>AbstractStepInterpolator.reinitialize</code> protected method\n+   * should be called before using the instance in order to initialize\n+   * the internal arrays. This constructor is used only in order to delay\n+   * the initialization in some cases. As an example, the {@link\n+   * EmbeddedRungeKuttaIntegrator} uses the prototyping design pattern\n+   * to create the step interpolators by cloning an uninitialized\n+   * model and latter initializing the copy.\n+   */\n+  public DummyStepInterpolator() {\n+    super();\n+  }\n+\n+  /** Simple constructor.\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param forward integration direction indicator\n+   */\n+  public DummyStepInterpolator(final double[] y, final boolean forward) {\n+    super(y, forward);\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public DummyStepInterpolator(final DummyStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** Really copy the finalized instance.\n+   * @return a copy of the finalized instance\n+   */\n+  protected StepInterpolator doCopy() {\n+    return new DummyStepInterpolator(this);\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * In this class, this method does nothing: the interpolated state\n+   * is always the state at the end of the current step.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected void computeInterpolatedState(final double theta, final double oneMinusThetaH)\n+    throws DerivativeException {\n+      System.arraycopy(currentState, 0, interpolatedState, 0, currentState.length);\n+  }\n+    \n+  /** Write the instance to an output channel.\n+   * @param out output channel\n+   * @exception IOException if the instance cannot be written\n+   */\n+  public void writeExternal(final ObjectOutput out)\n+    throws IOException {\n+    // save the state of the base class\n+    writeBaseExternal(out);\n+  }\n+\n+  /** Read the instance from an input channel.\n+   * @param in input channel\n+   * @exception IOException if the instance cannot be read\n+   */\n+  public void readExternal(final ObjectInput in)\n+    throws IOException {\n+\n+    // read the base class \n+    final double t = readBaseExternal(in);\n+\n+    try {\n+      // we can now set the interpolated time and state\n+      setInterpolatedTime(t);\n+    } catch (DerivativeException e) {\n+      throw MathRuntimeException.createIOException(e);\n+    }\n+\n+  }\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = 1708010296707839488L;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/sampling/FixedStepHandler.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+\n+/**\n+ * This interface represents a handler that should be called after\n+ * each successful fixed step.\n+\n+ * <p>This interface should be implemented by anyone who is interested\n+ * in getting the solution of an ordinary differential equation at\n+ * fixed time steps. Objects implementing this interface should be\n+ * wrapped within an instance of {@link StepNormalizer} that itself\n+ * is used as the general {@link StepHandler} by the integrator. The\n+ * {@link StepNormalizer} object is called according to the integrator\n+ * internal algorithms and it calls objects implementing this\n+ * interface as necessary at fixed time steps.</p>\n+ *\n+ * @see StepHandler\n+ * @see StepNormalizer\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public interface FixedStepHandler extends Serializable {\n+\n+  /**\n+   * Handle the last accepted step\n+   * @param t time of the current step\n+   * @param y state vector at t. For efficiency purposes, the {@link\n+   * StepNormalizer} class reuses the same array on each call, so if\n+   * the instance wants to keep it across all calls (for example to\n+   * provide at the end of the integration a complete array of all\n+   * steps), it should build a local copy store this copy.\n+   * @param yDot derivatives of the state vector state vector at t.\n+   * For efficiency purposes, the {@link StepNormalizer} class reuses\n+   * the same array on each call, so if\n+   * the instance wants to keep it across all calls (for example to\n+   * provide at the end of the integration a complete array of all\n+   * steps), it should build a local copy store this copy.\n+   * @param isLast true if the step is the last one\n+   * @throws DerivativeException if some error condition is encountered\n+   */\n+  public void handleStep(double t, double[] y, double[] yDot, boolean isLast)\n+      throws DerivativeException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/sampling/StepHandler.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.SecondOrderIntegrator;\n+\n+/**\n+ * This interface represents a handler that should be called after\n+ * each successful step.\n+ *\n+ * <p>The ODE integrators compute the evolution of the state vector at\n+ * some grid points that depend on their own internal algorithm. Once\n+ * they have found a new grid point (possibly after having computed\n+ * several evaluation of the derivative at intermediate points), they\n+ * provide it to objects implementing this interface. These objects\n+ * typically either ignore the intermediate steps and wait for the\n+ * last one, store the points in an ephemeris, or forward them to\n+ * specialized processing or output methods.</p>\n+ *\n+ * @see FirstOrderIntegrator\n+ * @see SecondOrderIntegrator\n+ * @see StepInterpolator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public interface StepHandler extends Serializable {\n+\n+  /** Determines whether this handler needs dense output.\n+   * <p>This method allows the integrator to avoid performing extra\n+   * computation if the handler does not need dense output. If this\n+   * method returns false, the integrator will call the {@link\n+   * #handleStep} method with a {@link DummyStepInterpolator} rather\n+   * than a custom interpolator.</p>\n+   * @return true if the handler needs dense output\n+   */\n+  public boolean requiresDenseOutput();\n+\n+  /** Reset the step handler.\n+   * Initialize the internal data as required before the first step is\n+   * handled.\n+   */\n+  public void reset();\n+\n+  /**\n+   * Handle the last accepted step\n+   * @param interpolator interpolator for the last accepted step. For\n+   * efficiency purposes, the various integrators reuse the same\n+   * object on each call, so if the instance wants to keep it across\n+   * all calls (for example to provide at the end of the integration a\n+   * continuous model valid throughout the integration range, as the\n+   * {@link ContinuousOutputModel ContinuousOutputModel} class does),\n+   * it should build a local copy using the clone method of the\n+   * interpolator and store this copy. Keeping only a reference to the\n+   * interpolator and reusing it will result in unpredictable\n+   * behaviour (potentially crashing the application).\n+   * @param isLast true if the step is the last one\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+   */\n+  public void handleStep(StepInterpolator interpolator, boolean isLast)\n+    throws DerivativeException;\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/sampling/StepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import java.io.Externalizable;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.SecondOrderIntegrator;\n+\n+/** This interface represents an interpolator over the last step\n+ * during an ODE integration.\n+ *\n+ * <p>The various ODE integrators provide objects implementing this\n+ * interface to the step handlers. These objects are often custom\n+ * objects tightly bound to the integrator internal algorithms. The\n+ * handlers can use these objects to retrieve the state vector at\n+ * intermediate times between the previous and the current grid points\n+ * (this feature is often called dense output).</p>\n+ *\n+ * @see FirstOrderIntegrator\n+ * @see SecondOrderIntegrator\n+ * @see StepHandler\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public interface StepInterpolator\n+  extends Externalizable {\n+\n+  /**\n+   * Get the previous grid point time.\n+   * @return previous grid point time\n+   */\n+  public double getPreviousTime();\n+    \n+  /**\n+   * Get the current grid point time.\n+   * @return current grid point time\n+   */\n+  public double getCurrentTime();\n+    \n+  /**\n+   * Get the time of the interpolated point.\n+   * If {@link #setInterpolatedTime} has not been called, it returns\n+   * the current grid point time.\n+   * @return interpolation point time\n+   */\n+  public double getInterpolatedTime();\n+    \n+  /**\n+   * Set the time of the interpolated point.\n+   * <p>Setting the time outside of the current step is now allowed, but\n+   * should be used with care since the accuracy of the interpolator will\n+   * probably be very poor far from this step. This allowance has been\n+   * added to simplify implementation of search algorithms near the\n+   * step endpoints.</p>\n+   * <p>Setting the time changes the instance internal state. If a\n+   * specific state must be preserved, a copy of the instance must be\n+   * created using {@link #copy()}.</p>\n+   * @param time time of the interpolated point\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   */\n+  public void setInterpolatedTime(double time)\n+    throws DerivativeException;\n+\n+  /**\n+   * Get the state vector of the interpolated point.\n+   * <p>The returned vector is a reference to a reused array, so\n+   * it should not be modified and it should be copied if it needs\n+   * to be preserved across several calls.</p>\n+   * @return state vector at time {@link #getInterpolatedTime}\n+   * @see #getInterpolatedDerivatives()\n+   */\n+  public double[] getInterpolatedState();\n+\n+  /**\n+   * Get the derivatives of the state vector of the interpolated point.\n+   * <p>The returned vector is a reference to a reused array, so\n+   * it should not be modified and it should be copied if it needs\n+   * to be preserved across several calls.</p>\n+   * @return derivatives of the state vector at time {@link #getInterpolatedTime}\n+   * @see #getInterpolatedState()\n+   */\n+  public double[] getInterpolatedDerivatives();\n+\n+  /** Check if the natural integration direction is forward.\n+   * <p>This method provides the integration direction as specified by\n+   * the integrator itself, it avoid some nasty problems in\n+   * degenerated cases like null steps due to cancellation at step\n+   * initialization, step control or discrete events\n+   * triggering.</p>\n+   * @return true if the integration variable (time) increases during\n+   * integration\n+   */\n+  public boolean isForward();\n+\n+  /** Copy the instance.\n+   * <p>The copied instance is guaranteed to be independent from the\n+   * original one. Both can be used with different settings for\n+   * interpolated time without any side effect.</p>\n+   * @return a deep copy of the instance, which can be used independently.\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   * @see #setInterpolatedTime(double)\n+   */\n+   public StepInterpolator copy() throws DerivativeException;\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/ode/sampling/StepNormalizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+\n+/**\n+ * This class wraps an object implementing {@link FixedStepHandler}\n+ * into a {@link StepHandler}.\n+\n+ * <p>This wrapper allows to use fixed step handlers with general\n+ * integrators which cannot guaranty their integration steps will\n+ * remain constant and therefore only accept general step\n+ * handlers.</p>\n+ *\n+ * <p>The stepsize used is selected at construction time. The {@link\n+ * FixedStepHandler#handleStep handleStep} method of the underlying\n+ * {@link FixedStepHandler} object is called at the beginning time of\n+ * the integration t0 and also at times t0+h, t0+2h, ... If the\n+ * integration range is an integer multiple of the stepsize, then the\n+ * last point handled will be the endpoint of the integration tend, if\n+ * not, the last point will belong to the interval [tend - h ;\n+ * tend].</p>\n+ *\n+ * <p>There is no constraint on the integrator, it can use any\n+ * timestep it needs (time steps longer or shorter than the fixed time\n+ * step and non-integer ratios are all allowed).</p>\n+ *\n+ * @see StepHandler\n+ * @see FixedStepHandler\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class StepNormalizer implements StepHandler {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -789699939659144654L;\n+\n+    /** Fixed time step. */\n+    private double h;\n+\n+    /** Underlying step handler. */\n+    private final FixedStepHandler handler;\n+\n+    /** Last step time. */\n+    private double lastTime;\n+\n+    /** Last State vector. */\n+    private double[] lastState;\n+\n+    /** Last Derivatives vector. */\n+    private double[] lastDerivatives;\n+\n+    /** Integration direction indicator. */\n+    private boolean forward;\n+\n+    /** Simple constructor.\n+     * @param h fixed time step (sign is not used)\n+     * @param handler fixed time step handler to wrap\n+     */\n+    public StepNormalizer(final double h, final FixedStepHandler handler) {\n+        this.h       = Math.abs(h);\n+        this.handler = handler;\n+        reset();\n+    }\n+\n+    /** Determines whether this handler needs dense output.\n+     * This handler needs dense output in order to provide data at\n+     * regularly spaced steps regardless of the steps the integrator\n+     * uses, so this method always returns true.\n+     * @return always true\n+     */\n+    public boolean requiresDenseOutput() {\n+        return true;\n+    }\n+\n+    /** Reset the step handler.\n+     * Initialize the internal data as required before the first step is\n+     * handled.\n+     */\n+    public void reset() {\n+        lastTime        = Double.NaN;\n+        lastState       = null;\n+        lastDerivatives = null;\n+        forward         = true;\n+    }\n+\n+    /**\n+     * Handle the last accepted step\n+     * @param interpolator interpolator for the last accepted step. For\n+     * efficiency purposes, the various integrators reuse the same\n+     * object on each call, so if the instance wants to keep it across\n+     * all calls (for example to provide at the end of the integration a\n+     * continuous model valid throughout the integration range), it\n+     * should build a local copy using the clone method and store this\n+     * copy.\n+     * @param isLast true if the step is the last one\n+     * @throws DerivativeException this exception is propagated to the\n+     * caller if the underlying user function triggers one\n+     */\n+    public void handleStep(final StepInterpolator interpolator, final boolean isLast)\n+        throws DerivativeException {\n+\n+        if (lastState == null) {\n+\n+            lastTime = interpolator.getPreviousTime();\n+            interpolator.setInterpolatedTime(lastTime);\n+            lastState = interpolator.getInterpolatedState().clone();\n+            lastDerivatives = interpolator.getInterpolatedDerivatives().clone();\n+\n+            // take the integration direction into account\n+            forward = (interpolator.getCurrentTime() >= lastTime);\n+            if (! forward) {\n+                h = -h;\n+            }\n+\n+        }\n+\n+        double nextTime = lastTime + h;\n+        boolean nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());\n+        while (nextInStep) {\n+\n+            // output the stored previous step\n+            handler.handleStep(lastTime, lastState, lastDerivatives, false);\n+\n+            // store the next step\n+            lastTime = nextTime;\n+            interpolator.setInterpolatedTime(lastTime);\n+            System.arraycopy(interpolator.getInterpolatedState(), 0,\n+                             lastState, 0, lastState.length);\n+            System.arraycopy(interpolator.getInterpolatedDerivatives(), 0,\n+                             lastDerivatives, 0, lastDerivatives.length);\n+\n+            nextTime  += h;\n+            nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());\n+\n+        }\n+\n+        if (isLast) {\n+            // there will be no more steps,\n+            // the stored one should be flagged as being the last\n+            handler.handleStep(lastTime, lastState, lastDerivatives, true);\n+        }\n+\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/DirectSearchOptimizer.java\n \n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.random.CorrelatedRandomVectorGenerator;\n import org.apache.commons.math.random.JDKRandomGenerator;\n \n         } catch (DimensionMismatchException dme) {\n             // this should not happen\n-            throw new RuntimeException(\"internal error\");\n+            throw new MathRuntimeException(\"unexpected exception caught\", null, dme);\n         }\n \n     }\n     }\n \n     /** Comparator for {@link PointCostPair PointCostPair} objects. */\n-    private static Comparator pointCostPairComparator = new Comparator() {\n-        public int compare(Object o1, Object o2) {\n+    private static Comparator<PointCostPair> pointCostPairComparator =\n+        new Comparator<PointCostPair>() {\n+        public int compare(PointCostPair o1, PointCostPair o2) {\n             if (o1 == null) {\n                 return (o2 == null) ? 0 : +1;\n             } else if (o2 == null) {\n                 return -1;\n             }\n-            double cost1 = ((PointCostPair) o1).getCost();\n-            double cost2 = ((PointCostPair) o2).getCost();\n-            return (cost1 < cost2) ? -1 : ((o1 == o2) ? 0 : +1);\n+            return (o1.getCost() < o2.getCost()) ? -1 : ((o1 == o2) ? 0 : +1);\n         }\n     };\n \n--- a/src/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n+++ b/src/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n  */\n public abstract class AbstractRandomGenerator implements RandomGenerator {\n     \n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 7026539017027693474L;\n+\n     /** \n      * Cached random normal value.  The default implementation for \n      * {@link #nextGaussian} generates pairs of values and this field caches the\n--- a/src/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n+++ b/src/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n         // build the root matrix\n         root = new RealMatrixImpl(order, rank);\n         for (int i = 0; i < order; ++i) {\n-            System.arraycopy(b[i], 0, root.getDataRef()[swap[i]], 0, rank);\n+            System.arraycopy(b[i], 0, root.getDataRef()[index[i]], 0, rank);\n         }\n \n     }\n--- a/src/java/org/apache/commons/math/random/EmpiricalDistribution.java\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistribution.java\n import java.util.List;\n \n import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n \n /**\n  * Represents an <a href=\"http://random.mat.sbg.ac.at/~ste/dipl/node11.html\">\n      * \n      * @return List of bin statistics\n      */\n-    List getBinStats();\n+    List<SummaryStatistics> getBinStats();\n \n     /**\n      * Returns the array of upper bounds for the bins.  Bins are: <br/>\n--- a/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n \n package org.apache.commons.math.random;\n \n-import java.io.EOFException;\n-import java.io.Serializable;\n import java.io.BufferedReader;\n+import java.io.File;\n import java.io.FileReader;\n-import java.io.File;\n import java.io.IOException;\n import java.io.InputStreamReader;\n+import java.io.Serializable;\n import java.net.URL;\n import java.util.ArrayList;\n import java.util.List;\n \n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n-import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n \n /**\n  * Implements <code>EmpiricalDistribution</code> interface.  This implementation\n public class EmpiricalDistributionImpl implements Serializable, EmpiricalDistribution {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -6773236347582113490L;\n+    private static final long serialVersionUID = 5729073523949762654L;\n \n     /** List of SummaryStatistics objects characterizing the bins */\n-    private List binStats = null;\n+    private List<SummaryStatistics> binStats = null;\n \n     /** Sample statistics */\n     private SummaryStatistics sampleStats = null;\n      * Creates a new EmpiricalDistribution with the default bin count.\n      */\n     public EmpiricalDistributionImpl() {\n-        binStats = new ArrayList();\n+        binStats = new ArrayList<SummaryStatistics>();\n     }\n \n     /**\n      */\n     public EmpiricalDistributionImpl(int binCount) {\n         this.binCount = binCount;\n-        binStats = new ArrayList();\n+        binStats = new ArrayList<SummaryStatistics>();\n     }\n \n      /**\n             da.computeStats();\n             fillBinStats(in);\n         } catch (Exception e) {\n-            throw new RuntimeException(e.getMessage());\n+            throw new MathRuntimeException(e);\n         }\n         loaded = true;\n \n             DataAdapter da = new StreamDataAdapter(in);\n             try {\n                 da.computeStats();\n+            } catch (IOException ioe) {\n+                // don't wrap exceptions which are already IOException\n+                throw ioe;\n+            } catch (RuntimeException rte) {\n+                // don't wrap RuntimeExceptions\n+                throw rte;\n             } catch (Exception e) {\n-                throw new IOException(e.getMessage());\n+                throw MathRuntimeException.createIOException(e);\n             }\n             if (sampleStats.getN() == 0) {\n-                throw new EOFException(\"URL \" + url + \" contains no data\");\n+                throw MathRuntimeException.createEOFException(\"URL {0} contains no data\",\n+                                                              new Object[] { url });\n             }\n             in = new BufferedReader(new InputStreamReader(url.openStream()));\n             fillBinStats(in);\n             DataAdapter da = new StreamDataAdapter(in);\n             try {\n                 da.computeStats();\n+            } catch (IOException ioe) {\n+                // don't wrap exceptions which are already IOException\n+                throw ioe;\n+            } catch (RuntimeException rte) {\n+                // don't wrap RuntimeExceptions\n+                throw rte;\n             } catch (Exception e) {\n-                throw new IOException(e.getMessage());\n+                throw MathRuntimeException.createIOException(e);\n             }\n             in = new BufferedReader(new FileReader(file));\n             fillBinStats(in);\n             double val = 0.0d;\n             while ((str = inputStream.readLine()) != null) {\n                 val = Double.parseDouble(str);\n-                SummaryStatistics stats =\n-                    (SummaryStatistics) binStats.get(findBin(min, val, delta));\n+                SummaryStatistics stats = binStats.get(findBin(min, val, delta));\n                 stats.addValue(val);\n             }\n \n             double val = 0.0;\n             sampleStats = new SummaryStatistics();\n             while ((str = inputStream.readLine()) != null) {\n-                val = new Double(str).doubleValue();\n+                val = Double.valueOf(str).doubleValue();\n                 sampleStats.addValue(val);\n             }\n             inputStream.close();\n             throws IOException {\n             for (int i = 0; i < inputArray.length; i++) {\n                 SummaryStatistics stats =\n-                    (SummaryStatistics) binStats.get(\n-                            findBin(min, inputArray[i], delta));\n+                    binStats.get(findBin(min, inputArray[i], delta));\n                 stats.addValue(inputArray[i]);\n             }\n         }\n         // Load array of bin upper bounds -- evenly spaced from min - max\n         double min = sampleStats.getMin();\n         double max = sampleStats.getMax();\n-        double delta = (max - min)/(new Double(binCount)).doubleValue();\n+        double delta = (max - min)/(Double.valueOf(binCount)).doubleValue();\n         double[] binUpperBounds = new double[binCount];\n         binUpperBounds[0] = min + delta;\n         for (int i = 1; i< binCount - 1; i++) {\n         DataAdapter da = aFactory.getAdapter(in);\n         try {\n             da.computeBinStats(min, delta);\n+        } catch (IOException ioe) {\n+            // don't wrap exceptions which are already IOException\n+            throw ioe;\n+        } catch (RuntimeException rte) {\n+            // don't wrap RuntimeExceptions\n+            throw rte;\n         } catch (Exception e) {\n-            if(e instanceof RuntimeException){\n-                throw new RuntimeException(e.getMessage());\n-            }else{\n-                throw new IOException(e.getMessage());\n-            }\n+            throw MathRuntimeException.createIOException(e);\n         }\n \n         // Assign upperBounds based on bin counts\n         upperBounds = new double[binCount];\n         upperBounds[0] =\n-        ((double)((SummaryStatistics)binStats.get(0)).getN())/\n-        (double)sampleStats.getN();\n+        ((double) binStats.get(0).getN()) / (double) sampleStats.getN();\n         for (int i = 1; i < binCount-1; i++) {\n             upperBounds[i] = upperBounds[i-1] +\n-            ((double)((SummaryStatistics)binStats.get(i)).getN())/\n-            (double)sampleStats.getN();\n+            ((double) binStats.get(i).getN()) / (double) sampleStats.getN();\n         }\n         upperBounds[binCount-1] = 1.0d;\n     }\n     public double getNextValue() throws IllegalStateException {\n \n         if (!loaded) {\n-            throw new IllegalStateException(\"distribution not loaded\");\n+            throw MathRuntimeException.createIllegalStateException(\"distribution not loaded\",\n+                                                                   null);\n         }\n \n         // Start with a uniformly distributed random number in (0,1)\n         // Use this to select the bin and generate a Gaussian within the bin\n         for (int i = 0; i < binCount; i++) {\n            if (x <= upperBounds[i]) {\n-               SummaryStatistics stats = (SummaryStatistics)binStats.get(i);\n+               SummaryStatistics stats = binStats.get(i);\n                if (stats.getN() > 0) {\n                    if (stats.getStandardDeviation() > 0) {  // more than one obs\n                         return randomData.nextGaussian\n                }\n            }\n         }\n-        throw new RuntimeException(\"No bin selected\");\n+        throw new MathRuntimeException(\"no bin selected\", null);\n     }\n \n     /**\n      * \n      * @return List of bin statistics.\n      */\n-    public List getBinStats() {\n+    public List<SummaryStatistics> getBinStats() {\n         return binStats;\n     }\n \n--- a/src/java/org/apache/commons/math/random/JDKRandomGenerator.java\n+++ b/src/java/org/apache/commons/math/random/JDKRandomGenerator.java\n  * {@link RandomGenerator}.\n  *\n  * @since 1.1\n- * @version $Revision:$ $Date$\n+ * @version $Revision$ $Date$\n  */\n public class JDKRandomGenerator extends Random implements RandomGenerator {\n     /** Serializable version identifier */\n--- a/src/java/org/apache/commons/math/random/NotPositiveDefiniteMatrixException.java\n+++ b/src/java/org/apache/commons/math/random/NotPositiveDefiniteMatrixException.java\n      * build an exception with a default message.\n      */\n     public NotPositiveDefiniteMatrixException() {\n-        super(\"not positive definite matrix\", new Object[0]);\n+        super(\"not positive definite matrix\", null);\n     }\n \n }\n--- a/src/java/org/apache/commons/math/random/RandomAdaptor.java\n+++ b/src/java/org/apache/commons/math/random/RandomAdaptor.java\n  * {@link RandomGenerator}.   \n  *\n  * @since 1.1\n- * @version $Revision:$ $Date$\n+ * @version $Revision$ $Date$\n  */\n public class RandomAdaptor extends Random implements RandomGenerator {\n     \n--- a/src/java/org/apache/commons/math/random/RandomData.java\n+++ b/src/java/org/apache/commons/math/random/RandomData.java\n      * @param k size of the sample\n      * @return random sample of k elements from c\n      */\n-    Object[] nextSample(Collection c, int k);\n+    Object[] nextSample(Collection<?> c, int k);\n }\n--- a/src/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/java/org/apache/commons/math/random/RandomDataImpl.java\n \n         //Convert each byte to 2 hex digits\n         for (int i = 0; i < randomBytes.length; i++) {\n-            Integer c = new Integer(randomBytes[i]);\n+            Integer c = Integer.valueOf(randomBytes[i]);\n \n             /* Add 128 to byte value to make interval 0-255 before\n              * doing hex conversion.\n \n             //Loop over the hash, converting each byte to 2 hex digits\n             for (int i = 0; i < hash.length; i++) {\n-                Integer c = new Integer(hash[i]);\n+                Integer c = Integer.valueOf(hash[i]);\n \n                 /* Add 128 to byte value to make interval 0-255\n                  * This guarantees <= 2 hex digits from toHexString()\n     }\n \n     /**\n-     * Uses a 2-cycle permutation shuffle to generate a random permutation.\n-     * The shuffling process is described\n+     * Generates an integer array of length <code>k</code> whose entries\n+     * are selected randomly, without repetition, from the integers\n+     * <code>0 through n-1</code> (inclusive).\n+     * <p>\n+     * Generated arrays represent permutations\n+     * of <code>n</code> taken <code>k</code> at a time.</p>\n+     * <p>\n+     * <strong>Preconditions:</strong><ul>\n+     * <li> <code>k <= n</code></li>\n+     * <li> <code>n > 0</code> </li>\n+     * </ul>\n+     * If the preconditions are not met, an IllegalArgumentException is\n+     * thrown.</p>\n+     * <p>\n+     * Uses a 2-cycle permutation shuffle. The shuffling process is described\n      * <a href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n-     * here</a>.\n-     * @param n the population size.\n-     * @param k the number to choose.\n-     * @return the random permutation.\n+     * here</a>.</p>\n+     * \n+     * @param n domain of the permutation (must be positive)\n+     * @param k size of the permutation (must satisfy 0 < k <= n).\n+     * @return the random permutation as an int array\n      */\n     public int[] nextPermutation(int n, int k) {\n         if (k > n) {\n      * @param k sample size.\n      * @return the random sample.\n      */\n-    public Object[] nextSample(Collection c, int k) {\n+    public Object[] nextSample(Collection<?> c, int k) {\n         int len = c.size();\n         if (k > len) {\n             throw new IllegalArgumentException\n--- a/src/java/org/apache/commons/math/random/RandomGenerator.java\n+++ b/src/java/org/apache/commons/math/random/RandomGenerator.java\n  * implemented by {@link AbstractRandomGenerator}.  \n  *\n  * @since 1.1\n- * @version $Revision:$ $Date$\n+ * @version $Revision$ $Date$\n  */\n public interface RandomGenerator extends Serializable {\n     \n--- a/src/java/org/apache/commons/math/random/ValueServer.java\n+++ b/src/java/org/apache/commons/math/random/ValueServer.java\n \n package org.apache.commons.math.random;\n import java.io.BufferedReader;\n-import java.io.EOFException;\n+import java.io.IOException;\n import java.io.InputStreamReader;\n-import java.io.IOException;\n+import java.net.MalformedURLException;\n import java.net.URL;\n-import java.net.MalformedURLException;\n+\n+import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * Generates values for use in simulation applications.\n             case EXPONENTIAL_MODE: return getNextExponential();\n             case GAUSSIAN_MODE: return getNextGaussian();\n             case CONSTANT_MODE: return mu;\n-            default: throw new IllegalStateException\n-                       (\"Bad mode: \" + mode);\n+            default: throw MathRuntimeException.createIllegalStateException(\"unknown mode {0}, known modes: \" +\n+                                                                            \"{1} ({2}), {3} ({4}), {5} ({6}), \" +\n+                                                                            \"{7} ({8}), {9} ({10}) and {11} ({12})\",\n+                                                                            new Object[] {\n+                                                                                mode,\n+                                                                                \"DIGEST_MODE\",      DIGEST_MODE,\n+                                                                                \"REPLAY_MODE\",      REPLAY_MODE,\n+                                                                                \"UNIFORM_MODE\",     UNIFORM_MODE,\n+                                                                                \"EXPONENTIAL_MODE\", EXPONENTIAL_MODE,\n+                                                                                \"GAUSSIAN_MODE\",    GAUSSIAN_MODE,\n+                                                                                \"CONSTANT_MODE\",    CONSTANT_MODE\n+                                                                            });\n         }\n     }\n \n     private double getNextDigest() {\n         if ((empiricalDistribution == null) ||\n             (empiricalDistribution.getBinStats().size() == 0)) {\n-            throw new IllegalStateException(\"Digest not initialized\");\n+            throw MathRuntimeException.createIllegalStateException(\"digest not initialized\", null);\n         }\n         return empiricalDistribution.getNextValue();\n     }\n             closeReplayFile();\n             resetReplayFile();\n             if ((str = filePointer.readLine()) == null) {\n-                throw new EOFException(\"URL \" + valuesFileURL + \" contains no data\");\n+                throw MathRuntimeException.createEOFException(\"URL {0} contains no data\",\n+                                                              new Object[] { valuesFileURL });\n             }\n         }\n         return Double.valueOf(str).doubleValue();\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n  * throw an IllegalArgumentException.</p>\n  * <p>\n  * Integer values (int, long, Integer, Long) are not distinguished by type -- \n- * i.e. <code>addValue(new Long(2)), addValue(2), addValue(2l)</code> all have\n+ * i.e. <code>addValue(Long.valueOf(2)), addValue(2), addValue(2l)</code> all have\n  * the same effect (similarly for arguments to <code>getCount,</code> etc.).</p>\n  * <p>\n  * The values are ordered using the default (natural order), unless a  \n     public void addValue(Object v) {\n         Object obj = v;\n         if (v instanceof Integer) {\n-           obj = new Long(((Integer) v).longValue());\n+           obj = Long.valueOf(((Integer) v).longValue());\n         }\n         try {\n             Long count = (Long) freqTable.get(obj);\n             if (count == null) {\n-                freqTable.put(obj, new Long(1));\n+                freqTable.put(obj, Long.valueOf(1));\n             } else {\n-                freqTable.put(obj, new Long(count.longValue() + 1));\n+                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n             }\n         } catch (ClassCastException ex) {   \n             //TreeMap will throw ClassCastException if v is not comparable\n      * @param v the value to add.\n      */\n     public void addValue(int v) {\n-        addValue(new Long(v));\n+        addValue(Long.valueOf(v));\n     }\n     \n     /**\n      * @param v the value to add.\n      */\n     public void addValue(Integer v) {\n-        addValue(new Long(v.longValue()));\n+        addValue(Long.valueOf(v.longValue()));\n     }\n \n     /**\n      * @param v the value to add.\n      */\n     public void addValue(long v) {\n-        addValue(new Long(v));\n+        addValue(Long.valueOf(v));\n     }\n     \n     /**\n      * @param v the value to add.\n      */\n     public void addValue(char v) {\n-        addValue(new Character(v));\n+        addValue(Character.valueOf(v));\n     }\n     \n     /** Clears the frequency table */\n     /**\n      * Returns an Iterator over the set of values that have been added.\n      * <p>\n-     * If added values are itegral (i.e., integers, longs, Integers, or Longs), \n+     * If added values are integral (i.e., integers, longs, Integers, or Longs), \n      * they are converted to Longs when they are added, so the objects returned\n      * by the Iterator will in this case be Longs.</p>\n      * \n      * @return the frequency of v.\n      */\n     public long getCount(int v) {\n-        return getCount(new Long(v));\n+        return getCount(Long.valueOf(v));\n     }\n     \n     /**\n      * @return the frequency of v.\n      */\n     public long getCount(long v) {\n-        return getCount(new Long(v));\n+        return getCount(Long.valueOf(v));\n     }\n     \n     /**\n      * @return the frequency of v.\n      */\n     public long getCount(char v) {\n-        return getCount(new Character(v));\n+        return getCount(Character.valueOf(v));\n     }\n     \n     //-------------------------------------------------------------\n      * @return the proportion of values equal to v\n      */\n     public double getPct(int v) {\n-        return getPct(new Long(v));       \n+        return getPct(Long.valueOf(v));       \n     }\n     \n     /**\n      * @return the proportion of values equal to v\n      */\n     public double getPct(long v) {\n-        return getPct(new Long(v));         \n+        return getPct(Long.valueOf(v));         \n     }\n     \n     /**\n      * @return the proportion of values equal to v\n      */\n     public double getPct(char v) {\n-        return getPct(new Character(v));         \n+        return getPct(Character.valueOf(v));         \n     }\n     \n     //-----------------------------------------------------------------------------------------\n      * @return the proportion of values equal to v\n      */\n     public long getCumFreq(int v) {\n-        return getCumFreq(new Long(v));       \n+        return getCumFreq(Long.valueOf(v));       \n     }\n     \n      /**\n      * @return the proportion of values equal to v\n      */\n     public long getCumFreq(long v) {\n-        return getCumFreq(new Long(v));         \n+        return getCumFreq(Long.valueOf(v));         \n     }\n     \n     /**\n      * @return the proportion of values equal to v\n      */\n     public long getCumFreq(char v) {\n-        return getCumFreq(new Character(v));         \n+        return getCumFreq(Character.valueOf(v));         \n     }\n     \n     //----------------------------------------------------------------------------------------------\n      * @return the proportion of values less than or equal to v\n      */\n     public double getCumPct(int v) {\n-        return getCumPct(new Long(v));       \n+        return getCumPct(Long.valueOf(v));       \n     }\n     \n     /**\n      * @return the proportion of values less than or equal to v\n      */\n     public double getCumPct(long v) {\n-        return getCumPct(new Long(v));         \n+        return getCumPct(Long.valueOf(v));         \n     }\n     \n     /**\n      * @return the proportion of values less than or equal to v\n      */\n     public double getCumPct(char v) {\n-        return getCumPct(new Character(v));         \n+        return getCumPct(Character.valueOf(v));         \n     }\n     \n     /**\n--- a/src/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n      * input array.</p>\n      * <p>\n      * If the array is null, an IllegalArgumentException is thrown.</p>\n-     * \n+     * @param values input array\n+     * @return the value of the statistic applied to the input array\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatistic#evaluate(double[])\n      */\n     public double evaluate(final double[] values) {\n      * <p>\n      * If the array is null or the index parameters are not valid, an \n      * IllegalArgumentException is thrown.</p>\n-     * \n+     * @param values the input array\n+     * @param begin the index of the first element to include\n+     * @param length the number of elements to include\n+     * @return the value of the statistic applied to the included array entries\n      * @see org.apache.commons.math.stat.descriptive.UnivariateStatistic#evaluate(double[], int, int)\n      */\n     public double evaluate(final double[] values, final int begin, final int length) {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     * {@inheritDoc}\n      */\n     public abstract void clear();\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     * {@inheritDoc}\n      */\n     public abstract double getResult();\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     * {@inheritDoc}\n      */\n     public abstract void increment(final double d);\n     \n--- a/src/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n     private static final long serialVersionUID = -8007759382851708045L;\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatistic#evaluate(double[])\n+     * {@inheritDoc}\n      */\n     public double evaluate(final double[] values) {\n         test(values, 0, 0);\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.UnivariateStatistic#evaluate(double[], int, int)\n+     * {@inheritDoc}\n      */\n     public abstract double evaluate(final double[] values, final int begin, final int length);\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public abstract UnivariateStatistic copy();\n \n     /**\n      * This method is used by <code>evaluate(double[], int, int)</code> methods\n--- a/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n import java.lang.reflect.InvocationTargetException;\n import java.util.Arrays;\n \n-import org.apache.commons.discovery.tools.DiscoverClass;\n import org.apache.commons.math.stat.descriptive.moment.GeometricMean;\n import org.apache.commons.math.stat.descriptive.moment.Kurtosis;\n import org.apache.commons.math.stat.descriptive.moment.Mean;\n public class DescriptiveStatistics implements StatisticalSummary, Serializable {\n     \n     /** Serialization UID */\n-    private static final long serialVersionUID = -2734185686570407433L;\n-    \n+    private static final long serialVersionUID = 4133067267405273064L;\n+\n     /** hold the window size **/\n     protected int windowSize = INFINITE_WINDOW;\n     \n     }\n     \n     /**\n-     * Create an instance of a <code>DescriptiveStatistics</code>\n-     * @param cls the type of <code>DescriptiveStatistics</code> object to\n-     *        create. \n-     * @return a new instance. \n-     * @throws InstantiationException is thrown if the object can not be\n-     *            created.\n-     * @throws IllegalAccessException is thrown if the type's default\n-     *            constructor is not accessible.\n-     * @deprecated to be removed in commons-math 2.0\n-     */\n-    public static DescriptiveStatistics newInstance(Class cls) throws InstantiationException, IllegalAccessException {\n-        return (DescriptiveStatistics)cls.newInstance();\n-    }\n-    \n-    /**\n-     * Create an instance of a <code>DescriptiveStatistics</code>\n-     * @return a new DescriptiveStatistics instance. \n-     * @deprecated to be removed in commons-math 2.0\n-     */\n-    public static DescriptiveStatistics newInstance() {\n-        DescriptiveStatistics factory = null;\n-        try {\n-            DiscoverClass dc = new DiscoverClass();\n-            factory = (DescriptiveStatistics) dc.newInstance(\n-                DescriptiveStatistics.class,\n-                \"org.apache.commons.math.stat.descriptive.DescriptiveStatisticsImpl\");\n-        } catch(Throwable t) {\n-            return new DescriptiveStatisticsImpl();\n-        }\n-        return factory;\n+     * Copy constructor.  Construct a new DescriptiveStatistics instance that\n+     * is a copy of original.\n+     * \n+     * @param original DescriptiveStatistics instance to copy\n+     */\n+    public DescriptiveStatistics(DescriptiveStatistics original) {\n+        copy(original, this);\n     }\n     \n     /**\n         }\n     }\n \n+    /**\n+     * Removes the most recent value from the dataset.\n+     */\n+    public void removeMostRecentValue() {\n+        eDA.discardMostRecentElements(1);\n+    }\n+\n+    /**\n+     * Replaces the most recently stored value with the given value.\n+     * There must be at least one element stored to call this method.\n+     * \n+     * @param v the value to replace the most recent stored value\n+     * @return replaced value\n+     */\n+    public double replaceMostRecentValue(double v) {\n+        return eDA.substituteMostRecentElement(v);\n+    }\n+\n     /** \n      * Returns the <a href=\"http://www.xycoon.com/arithmetic_mean.htm\">\n      * arithmetic mean </a> of the available values \n      * Returns the <a href=\"http://www.xycoon.com/geometric_mean.htm\">\n      * geometric mean </a> of the available values\n      * @return The geometricMean, Double.NaN if no values have been added, \n-     * or if the productof the available values is less than or equal to 0.\n+     * or if the product of the available values is less than or equal to 0.\n      */\n     public double getGeometricMean() {\n         return apply(geometricMeanImpl);\n             try {\n                 percentileImpl.getClass().getMethod(\"setQuantile\", \n                         new Class[] {Double.TYPE}).invoke(percentileImpl,\n-                                new Object[] {new Double(p)});\n+                                new Object[] {Double.valueOf(p)});\n             } catch (NoSuchMethodException e1) { // Setter guard should prevent\n                 throw new IllegalArgumentException(\n                    \"Percentile implementation does not support setQuantile\");\n         try {\n             percentileImpl.getClass().getMethod(\"setQuantile\", \n                     new Class[] {Double.TYPE}).invoke(percentileImpl,\n-                            new Object[] {new Double(50.0d)});\n+                            new Object[] {Double.valueOf(50.0d)});\n         } catch (NoSuchMethodException e1) { \n             throw new IllegalArgumentException(\n                     \"Percentile implementation does not support setQuantile\");\n      */\n     public synchronized void setSumImpl(UnivariateStatistic sumImpl) {\n         this.sumImpl = sumImpl;\n-    }   \n+    }  \n+    \n+    /**\n+     * Returns a copy of this DescriptiveStatistics instance with the same internal state.\n+     * \n+     * @return a copy of this\n+     */\n+    public DescriptiveStatistics copy() {\n+        DescriptiveStatistics result = new DescriptiveStatistics();\n+        copy(this, result);\n+        return result; \n+    }\n+     \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source DescriptiveStatistics to copy\n+     * @param dest DescriptiveStatistics to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(DescriptiveStatistics source, DescriptiveStatistics dest) {\n+        // Copy data and window size\n+        dest.eDA = source.eDA.copy();\n+        dest.windowSize = source.windowSize;\n+        \n+        // Copy implementations\n+        dest.maxImpl = source.maxImpl.copy();\n+        dest.meanImpl = source.meanImpl.copy();\n+        dest.minImpl = source.minImpl.copy();\n+        dest.sumImpl = source.sumImpl.copy();\n+        dest.varianceImpl = source.varianceImpl.copy();\n+        dest.sumsqImpl = source.sumsqImpl.copy();\n+        dest.geometricMeanImpl = source.geometricMeanImpl.copy();\n+        dest.kurtosisImpl = source.kurtosisImpl;\n+        dest.skewnessImpl = source.skewnessImpl;\n+        dest.percentileImpl = source.percentileImpl;\n+    }\n }\n--- a/src/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n import java.util.Arrays;\n \n import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.stat.descriptive.moment.GeometricMean;\n import org.apache.commons.math.stat.descriptive.moment.Mean;\n  * threads is required.</p>\n  *\n  * @since 1.2\n- * @version $Revision: 618097 $ $Date: 2008-02-03 22:39:08 +0100 (dim., 03 f\u00e9vr. 2008) $\n+ * @version $Revision$ $Date$\n  */\n public class MultivariateSummaryStatistics\n   implements StatisticalMultivariateSummary, Serializable {\n      */\n     private void checkEmpty() {\n         if (n > 0) {\n-            throw new IllegalStateException(\n-                \"Implementations must be configured before values are added.\");\n+            throw MathRuntimeException.createIllegalStateException(\"{0} values have been added before statistic is configured\",\n+                                                                   new Object[] { n });\n         }\n     }\n \n--- a/src/java/org/apache/commons/math/stat/descriptive/StatisticalMultivariateSummary.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/StatisticalMultivariateSummary.java\n  *  Reporting interface for basic multivariate statistics.\n  *\n  * @since 1.2\n- * @version $Revision: 480440 $ $Date: 2006-11-29 08:14:12 +0100 (mer., 29 nov. 2006) $\n+ * @version $Revision$ $Date$\n  */\n public interface StatisticalMultivariateSummary {\n     /** \n--- a/src/java/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatistic.java\n     /**\n      * Updates the internal state of the statistic to reflect addition of\n      * all values in the values array.  Does not clear the statistic first --\n-     * i.e., the values are added <strong>incrementally</stong> to the dataset.\n+     * i.e., the values are added <strong>incrementally</strong> to the dataset.\n      * \n      * @param values  array holding the new values to add\n      * @throws IllegalArgumentException if the array is null\n      * Updates the internal state of the statistic to reflect addition of\n      * the values in the designated portion of the values array.  Does not\n      * clear the statistic first -- i.e., the values are added \n-     * <strong>incrementally</stong> to the dataset.\n+     * <strong>incrementally</strong> to the dataset.\n      * \n      * @param values  array holding the new values to add\n      * @param start  the array index of the first value to add\n      * Clears the internal state of the Statistic\n      */\n     void clear();\n+    \n+    /**\n+     * Returns a copy of the statistic with the same internal state.\n+     * \n+     * @return a copy of the statistic\n+     */\n+    StorelessUnivariateStatistic copy();\n \n }\n--- a/src/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n /*\n  * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements. See the NOTICE file distributed with this\n- * work for additional information regarding copyright ownership. The ASF\n- * licenses this file to You under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n- * or agreed to in writing, software distributed under the License is\n- * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied. See the License for the specific language\n- * governing permissions and limitations under the License.\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n  */\n package org.apache.commons.math.stat.descriptive;\n \n import java.io.Serializable;\n \n-import org.apache.commons.discovery.tools.DiscoverClass;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.stat.descriptive.moment.GeometricMean;\n import org.apache.commons.math.stat.descriptive.moment.Mean;\n import org.apache.commons.math.stat.descriptive.moment.SecondMoment;\n  * {@link SynchronizedSummaryStatistics} if concurrent access from multiple\n  * threads is required.\n  * </p>\n- * @version $Revision$ $Date: 2008-02-10 13:28:59 -0600 (Sun, 10 Feb\n- *          2008) $\n+ * @version $Revision$ $Date$\n  */\n public class SummaryStatistics implements StatisticalSummary, Serializable {\n \n     /** Serialization UID */\n-    private static final long serialVersionUID = -3346512372447011854L;\n-\n-    /**\n-     * Create an instance of a <code>SummaryStatistics</code>\n-     * @param cls the type of <code>SummaryStatistics</code> object to create.\n-     * @return a new instance.\n-     * @deprecated to be removed in commons-math 2.0\n-     * @throws InstantiationException is thrown if the object can not be\n-     *         created.\n-     * @throws IllegalAccessException is thrown if the type's default\n-     *         constructor is not accessible.\n-     */\n-    public static SummaryStatistics newInstance(Class cls) throws InstantiationException, IllegalAccessException {\n-        return (SummaryStatistics)cls.newInstance();\n-    }\n-\n-    /**\n-     * Create an instance of a <code>SummaryStatistics</code>\n-     * @return a new SummaryStatistics instance.\n-     * @deprecated to be removed in commons-math 2.0\n-     */\n-    public static SummaryStatistics newInstance() {\n-        SummaryStatistics instance = null;\n-        try {\n-            DiscoverClass dc = new DiscoverClass();\n-            instance = (SummaryStatistics)dc.newInstance(SummaryStatistics.class, \"org.apache.commons.math.stat.descriptive.SummaryStatisticsImpl\");\n-        } catch (Throwable t) {\n-            return new SummaryStatisticsImpl();\n-        }\n-        return instance;\n-    }\n+    private static final long serialVersionUID = -2021321786743555871L;\n \n     /**\n      * Construct a SummaryStatistics instance\n      */\n     public SummaryStatistics() {\n+    }\n+\n+    /**\n+     * A copy constructor. Creates a deep-copy of the {@code original}.\n+     * \n+     * @param original the {@code SummaryStatistics} instance to copy\n+     */\n+    public SummaryStatistics(SummaryStatistics original) {\n+        copy(original, this);\n     }\n \n     /** count of values that have been added */\n      * @return Current values of statistics\n      */\n     public StatisticalSummary getSummary() {\n-        return new StatisticalSummaryValues(getMean(), getVariance(), getN(), getMax(), getMin(), getSum());\n+        return new StatisticalSummaryValues(getMean(), getVariance(), getN(), \n+                getMax(), getMin(), getSum());\n     }\n \n     /**\n             return false;\n         }\n         SummaryStatistics stat = (SummaryStatistics)object;\n-        return (MathUtils.equals(stat.getGeometricMean(), this.getGeometricMean()) && MathUtils.equals(stat.getMax(), this.getMax())\n-            && MathUtils.equals(stat.getMean(), this.getMean()) && MathUtils.equals(stat.getMin(), this.getMin()) && MathUtils.equals(stat.getN(), this.getN())\n-            && MathUtils.equals(stat.getSum(), this.getSum()) && MathUtils.equals(stat.getSumsq(), this.getSumsq()) && MathUtils.equals(stat.getVariance(),\n+        return (MathUtils.equals(stat.getGeometricMean(), this.getGeometricMean()) &&\n+                MathUtils.equals(stat.getMax(), this.getMax()) &&\n+                MathUtils.equals(stat.getMean(), this.getMean()) &&\n+                MathUtils.equals(stat.getMin(), this.getMin()) &&\n+                MathUtils.equals(stat.getN(), this.getN()) &&\n+                MathUtils.equals(stat.getSum(), this.getSum()) &&\n+                MathUtils.equals(stat.getSumsq(), this.getSumsq()) &&\n+                MathUtils.equals(stat.getVariance(),\n             this.getVariance()));\n     }\n \n      */\n     private void checkEmpty() {\n         if (n > 0) {\n-            throw new IllegalStateException(\"Implementations must be configured before values are added.\");\n-        }\n-    }\n-\n+            throw MathRuntimeException.createIllegalStateException(\"{0} values have been added before statistic is configured\",\n+                                                                   new Object[] { n });\n+        }\n+    }\n+    \n+    /**\n+     * Returns a copy of this SummaryStatistics instance with the same internal state.\n+     * \n+     * @return a copy of this\n+     */\n+    public SummaryStatistics copy() {\n+        SummaryStatistics result = new SummaryStatistics();\n+        copy(this, result);\n+        return result; \n+    }\n+     \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source SummaryStatistics to copy\n+     * @param dest SummaryStatistics to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(SummaryStatistics source, SummaryStatistics dest) {\n+        dest.maxImpl = source.maxImpl.copy();\n+        dest.meanImpl = source.meanImpl.copy();\n+        dest.minImpl = source.minImpl.copy();\n+        dest.sumImpl = source.sumImpl.copy();\n+        dest.varianceImpl = source.varianceImpl.copy();\n+        dest.sumLogImpl = source.sumLogImpl.copy();\n+        dest.sumsqImpl = source.sumsqImpl.copy();\n+        if (source.getGeoMeanImpl() instanceof GeometricMean) {\n+            // Keep geoMeanImpl, sumLogImpl in synch\n+            dest.geoMeanImpl = new GeometricMean((SumOfLogs) dest.sumLogImpl);\n+        } else {\n+            dest.geoMeanImpl = source.geoMeanImpl.copy();\n+        }\n+        SecondMoment.copy(source.secondMoment, dest.secondMoment);\n+        dest.n = source.n;\n+        \n+        // Make sure that if stat == statImpl in source, same\n+        // holds in dest; otherwise copy stat\n+        if (source.geoMean == source.geoMeanImpl) {\n+            dest.geoMean = (GeometricMean) dest.geoMeanImpl;\n+        } else {\n+            GeometricMean.copy(source.geoMean, dest.geoMean);\n+        } \n+        if (source.max == source.maxImpl) {\n+            dest.max = (Max) dest.maxImpl;\n+        } else {\n+            Max.copy(source.max, dest.max);\n+        } \n+        if (source.mean == source.meanImpl) {\n+            dest.mean = (Mean) dest.meanImpl;\n+        } else {\n+            Mean.copy(source.mean, dest.mean);\n+        } \n+        if (source.min == source.minImpl) {\n+            dest.min = (Min) dest.minImpl;\n+        } else {\n+            Min.copy(source.min, dest.min);\n+        } \n+        if (source.sum == source.sumImpl) {\n+            dest.sum = (Sum) dest.sumImpl;\n+        } else {\n+            Sum.copy(source.sum, dest.sum);\n+        } \n+        if (source.variance == source.varianceImpl) {\n+            dest.variance = (Variance) dest.varianceImpl;\n+        } else {\n+            Variance.copy(source.variance, dest.variance);\n+        } \n+        if (source.sumLog == source.sumLogImpl) {\n+            dest.sumLog = (SumOfLogs) dest.sumLogImpl;\n+        } else {\n+            SumOfLogs.copy(source.sumLog, dest.sumLog);\n+        } \n+        if (source.sumsq == source.sumsqImpl) {\n+            dest.sumsq = (SumOfSquares) dest.sumsqImpl;\n+        } else {\n+            SumOfSquares.copy(source.sumsq, dest.sumsq);\n+        } \n+    }\n }\n--- a/src/java/org/apache/commons/math/stat/descriptive/SynchronizedDescriptiveStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/SynchronizedDescriptiveStatistics.java\n     public SynchronizedDescriptiveStatistics(int window) {\n         super(window);\n     }\n+    \n+    /**\n+     * A copy constructor. Creates a deep-copy of the {@code original}.\n+     * \n+     * @param original the {@code SynchronizedDescriptiveStatistics} instance to copy\n+     */\n+    public SynchronizedDescriptiveStatistics(SynchronizedDescriptiveStatistics original) {\n+        copy(original, this);\n+    }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#addValue(double)\n+     * {@inheritDoc}\n      */\n     public synchronized void addValue(double v) {\n         super.addValue(v);\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#clear()\n+     * {@inheritDoc}\n      */\n     public synchronized void clear() {\n         super.clear();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getElement(int)\n+     * {@inheritDoc}\n      */\n     public synchronized double getElement(int index) {\n         return super.getElement(index);\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getN()\n+     * {@inheritDoc}\n      */\n     public synchronized long getN() {\n         return super.getN();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getValues()\n+     * {@inheritDoc}\n      */\n     public synchronized double[] getValues() {\n         return super.getValues();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#setWindowSize(int)\n+     * {@inheritDoc}\n      */\n     public synchronized void setWindowSize(int windowSize) {\n         super.setWindowSize(windowSize);\n     public synchronized String toString() {\n         return super.toString();\n     }\n+    \n+    /**\n+     * Returns a copy of this SynchronizedDescriptiveStatistics instance with the\n+     * same internal state.\n+     * \n+     * @return a copy of this\n+     */\n+    public synchronized SynchronizedDescriptiveStatistics copy() {\n+        SynchronizedDescriptiveStatistics result = \n+            new SynchronizedDescriptiveStatistics();\n+        copy(this, result);\n+        return result; \n+    }\n+     \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * <p>Acquires synchronization lock on source, then dest before copying.</p>\n+     * \n+     * @param source SynchronizedDescriptiveStatistics to copy\n+     * @param dest SynchronizedDescriptiveStatistics to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(SynchronizedDescriptiveStatistics source,\n+            SynchronizedDescriptiveStatistics dest) {\n+        synchronized (source) {\n+            synchronized (dest) {\n+                DescriptiveStatistics.copy(source, dest);\n+            }\n+        }\n+    }\n }\n--- a/src/java/org/apache/commons/math/stat/descriptive/SynchronizedMultivariateSummaryStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/SynchronizedMultivariateSummaryStatistics.java\n  * thread is computing a statistic from the instance, no other thread can modify\n  * the instance nor compute another statistic.\n  * @since 1.2\n- * @version $Revision: 618097 $ $Date: 2008-02-03 22:39:08 +0100 (dim., 03 f\u00e9vr. 2008) $\n+ * @version $Revision$ $Date$\n  */\n public class SynchronizedMultivariateSummaryStatistics\n   extends MultivariateSummaryStatistics {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#addValue(double[])\n+     * {@inheritDoc}\n      */\n     public synchronized void addValue(double[] value)\n       throws DimensionMismatchException {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#getDimension()\n+     * {@inheritDoc}\n      */\n     public synchronized int getDimension() {\n         return super.getDimension();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#getN()\n+     * {@inheritDoc}\n      */\n     public synchronized long getN() {\n         return super.getN();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#getSum()\n+     * {@inheritDoc}\n      */\n     public synchronized double[] getSum() {\n         return super.getSum();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#getSumSq()\n+     * {@inheritDoc}\n      */\n     public synchronized double[] getSumSq() {\n         return super.getSumSq();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#getSumLog()\n+     * {@inheritDoc}\n      */\n     public synchronized double[] getSumLog() {\n         return super.getSumLog();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#getMean()\n+     * {@inheritDoc}\n      */\n     public synchronized double[] getMean() {\n         return super.getMean();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#getStandardDeviation()\n+     * {@inheritDoc}\n      */\n     public synchronized double[] getStandardDeviation() {\n         return super.getStandardDeviation();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#getCovariance()\n+     * {@inheritDoc}\n      */\n     public synchronized RealMatrix getCovariance() {\n         return super.getCovariance();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#getMax()\n+     * {@inheritDoc}\n      */\n     public synchronized double[] getMax() {\n         return super.getMax();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#getMin()\n+     * {@inheritDoc}\n      */\n     public synchronized double[] getMin() {\n         return super.getMin();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#getGeometricMean()\n+     * {@inheritDoc}\n      */\n     public synchronized double[] getGeometricMean() {\n         return super.getGeometricMean();\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#toString()\n+     * {@inheritDoc}\n      */\n     public synchronized String toString() {\n         return super.toString();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#clear()\n+     * {@inheritDoc}\n      */\n     public synchronized void clear() {\n         super.clear();\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#equals(Object)\n+     * {@inheritDoc}\n      */\n     public synchronized boolean equals(Object object) {\n         return super.equals(object);\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#hashCode()\n+     * {@inheritDoc}\n      */\n     public synchronized int hashCode() {\n         return super.hashCode();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#getSumImpl()\n+     * {@inheritDoc}\n      */\n     public synchronized StorelessUnivariateStatistic[] getSumImpl() {\n         return super.getSumImpl();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#setSumImpl(StorelessUnivariateStatistic[])\n+     * {@inheritDoc}\n      */\n     public synchronized void setSumImpl(StorelessUnivariateStatistic[] sumImpl)\n       throws DimensionMismatchException {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#getSumsqImpl()\n+     * {@inheritDoc}\n      */\n     public synchronized StorelessUnivariateStatistic[] getSumsqImpl() {\n         return super.getSumsqImpl();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#setSumsqImpl(StorelessUnivariateStatistic[])\n+     * {@inheritDoc}\n      */\n     public synchronized void setSumsqImpl(StorelessUnivariateStatistic[] sumsqImpl)\n       throws DimensionMismatchException {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#getMinImpl()\n+     * {@inheritDoc}\n      */\n     public synchronized StorelessUnivariateStatistic[] getMinImpl() {\n         return super.getMinImpl();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#setMinImpl(StorelessUnivariateStatistic[])\n+     * {@inheritDoc}\n      */\n     public synchronized void setMinImpl(StorelessUnivariateStatistic[] minImpl)\n       throws DimensionMismatchException {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#getMaxImpl()\n+     * {@inheritDoc}\n      */\n     public synchronized StorelessUnivariateStatistic[] getMaxImpl() {\n         return super.getMaxImpl();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#setMaxImpl(StorelessUnivariateStatistic[])\n+     * {@inheritDoc}\n      */\n     public synchronized void setMaxImpl(StorelessUnivariateStatistic[] maxImpl)\n       throws DimensionMismatchException {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#getSumLogImpl()\n+     * {@inheritDoc}\n      */\n     public synchronized StorelessUnivariateStatistic[] getSumLogImpl() {\n         return super.getSumLogImpl();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#setSumLogImpl(StorelessUnivariateStatistic[])\n+     * {@inheritDoc}\n      */\n     public synchronized void setSumLogImpl(StorelessUnivariateStatistic[] sumLogImpl)\n       throws DimensionMismatchException {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#getGeoMeanImpl()\n+     * {@inheritDoc}\n      */\n     public synchronized StorelessUnivariateStatistic[] getGeoMeanImpl() {\n         return super.getGeoMeanImpl();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#setGeoMeanImpl(StorelessUnivariateStatistic[])\n+     * {@inheritDoc}\n      */\n     public synchronized void setGeoMeanImpl(StorelessUnivariateStatistic[] geoMeanImpl)\n       throws DimensionMismatchException {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#getMeanImpl()\n+     * {@inheritDoc}\n      */\n     public synchronized StorelessUnivariateStatistic[] getMeanImpl() {\n         return super.getMeanImpl();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics#setMeanImpl(StorelessUnivariateStatistic[])\n+     * {@inheritDoc}\n      */\n     public synchronized void setMeanImpl(StorelessUnivariateStatistic[] meanImpl)\n       throws DimensionMismatchException {\n--- a/src/java/org/apache/commons/math/stat/descriptive/SynchronizedSummaryStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/SynchronizedSummaryStatistics.java\n     public SynchronizedSummaryStatistics() {\n         super();\n     }\n-\n-    /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#getSummary()\n+    \n+    /**\n+     * A copy constructor. Creates a deep-copy of the {@code original}.\n+     * \n+     * @param original the {@code SynchronizedSummaryStatistics} instance to copy\n+     */\n+    public SynchronizedSummaryStatistics(SynchronizedSummaryStatistics original) {\n+        copy(original, this);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n      */\n     public synchronized StatisticalSummary getSummary() {\n         return super.getSummary();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#addValue(double)\n+     * {@inheritDoc}\n      */\n     public synchronized void addValue(double value) {\n         super.addValue(value);\n     }\n \n     /** \n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#getN()\n+     * {@inheritDoc}\n      */\n     public synchronized long getN() {\n         return super.getN();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#getSum()\n+     * {@inheritDoc}\n      */\n     public synchronized double getSum() {\n         return super.getSum();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#getSumsq()\n+     * {@inheritDoc}\n      */\n     public synchronized double getSumsq() {\n         return super.getSumsq();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#getMean()\n+     * {@inheritDoc}\n      */\n     public synchronized double getMean() {\n         return super.getMean();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#getStandardDeviation()\n+     * {@inheritDoc}\n      */\n     public synchronized double getStandardDeviation() {\n         return super.getStandardDeviation();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#getVariance()\n+     * {@inheritDoc}\n      */\n     public synchronized double getVariance() {\n         return super.getVariance();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#getMax()\n+     * {@inheritDoc}\n      */\n     public synchronized double getMax() {\n         return super.getMax();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#getMin()\n+     * {@inheritDoc}\n      */\n     public synchronized double getMin() {\n         return super.getMin();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#getGeometricMean()\n+     * {@inheritDoc}\n      */\n     public synchronized double getGeometricMean() {\n         return super.getGeometricMean();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#toString()\n+     * {@inheritDoc}\n      */\n     public synchronized String toString() {\n         return super.toString();\n     }\n \n     /** \n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#clear()\n+     * {@inheritDoc}\n      */\n     public synchronized void clear() {\n         super.clear();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#equals(Object)\n+     * {@inheritDoc}\n      */\n     public synchronized boolean equals(Object object) {\n         return super.equals(object);\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#hashCode()\n+     * {@inheritDoc}\n      */\n     public synchronized int hashCode() {\n         return super.hashCode();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#getSumImpl()\n+     * {@inheritDoc}\n      */\n     public synchronized StorelessUnivariateStatistic getSumImpl() {\n         return super.getSumImpl();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#setSumImpl(StorelessUnivariateStatistic)\n+     * {@inheritDoc}\n      */\n     public synchronized void setSumImpl(StorelessUnivariateStatistic sumImpl) {\n         super.setSumImpl(sumImpl);\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#getSumsqImpl()\n+     * {@inheritDoc}\n      */\n     public synchronized StorelessUnivariateStatistic getSumsqImpl() {\n         return super.getSumsqImpl();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#setSumsqImpl(StorelessUnivariateStatistic)\n+     * {@inheritDoc}\n      */\n     public synchronized void setSumsqImpl(StorelessUnivariateStatistic sumsqImpl) {\n         super.setSumsqImpl(sumsqImpl);\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#getMinImpl()\n+     * {@inheritDoc}\n      */\n     public synchronized StorelessUnivariateStatistic getMinImpl() {\n         return super.getMinImpl();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#setMinImpl(StorelessUnivariateStatistic)\n+     * {@inheritDoc}\n      */\n     public synchronized void setMinImpl(StorelessUnivariateStatistic minImpl) {\n         super.setMinImpl(minImpl);\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#getMaxImpl()\n+     * {@inheritDoc}\n      */\n     public synchronized StorelessUnivariateStatistic getMaxImpl() {\n         return super.getMaxImpl();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#setMaxImpl(StorelessUnivariateStatistic)\n+     * {@inheritDoc}\n      */\n     public synchronized void setMaxImpl(StorelessUnivariateStatistic maxImpl) {\n         super.setMaxImpl(maxImpl);\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#getSumLogImpl()\n+     * {@inheritDoc}\n      */\n     public synchronized StorelessUnivariateStatistic getSumLogImpl() {\n         return super.getSumLogImpl();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#setSumLogImpl(StorelessUnivariateStatistic)\n+     * {@inheritDoc}\n      */\n     public synchronized void setSumLogImpl(StorelessUnivariateStatistic sumLogImpl) {\n         super.setSumLogImpl(sumLogImpl);\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#getGeoMeanImpl()\n+     * {@inheritDoc}\n      */\n     public synchronized StorelessUnivariateStatistic getGeoMeanImpl() {\n         return super.getGeoMeanImpl();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#setGeoMeanImpl(StorelessUnivariateStatistic)\n+     * {@inheritDoc}\n      */\n     public synchronized void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl) {\n         super.setGeoMeanImpl(geoMeanImpl);\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#getMeanImpl()\n+     * {@inheritDoc}\n      */\n     public synchronized StorelessUnivariateStatistic getMeanImpl() {\n         return super.getMeanImpl();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#setMeanImpl(StorelessUnivariateStatistic)\n+     * {@inheritDoc}\n      */\n     public synchronized void setMeanImpl(StorelessUnivariateStatistic meanImpl) {\n         super.setMeanImpl(meanImpl);\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#getVarianceImpl()\n+     * {@inheritDoc}\n      */\n     public synchronized StorelessUnivariateStatistic getVarianceImpl() {\n         return super.getVarianceImpl();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.SummaryStatistics#setVarianceImpl(StorelessUnivariateStatistic)\n+     * {@inheritDoc}\n      */\n     public synchronized void setVarianceImpl(StorelessUnivariateStatistic varianceImpl) {\n         super.setVarianceImpl(varianceImpl);\n     }\n     \n+    /**\n+     * Returns a copy of this SynchronizedSummaryStatistics instance with the\n+     * same internal state.\n+     * \n+     * @return a copy of this\n+     */\n+    public synchronized SynchronizedSummaryStatistics copy() {\n+        SynchronizedSummaryStatistics result = \n+            new SynchronizedSummaryStatistics();\n+        copy(this, result);\n+        return result; \n+    }\n+     \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * <p>Acquires synchronization lock on source, then dest before copying.</p>\n+     * \n+     * @param source SynchronizedSummaryStatistics to copy\n+     * @param dest SynchronizedSummaryStatistics to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(SynchronizedSummaryStatistics source,\n+            SynchronizedSummaryStatistics dest) {\n+        synchronized (source) {\n+            synchronized (dest) {\n+                SummaryStatistics.copy(source, dest);\n+            }\n+        }\n+    }\n+    \n }\n--- a/src/java/org/apache/commons/math/stat/descriptive/UnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/UnivariateStatistic.java\n import java.io.Serializable;\n \n /**\n- * Base evaluation interface implemented by all statistics.\n- * <p>\n- * Includes \"stateless\" <code>evaluate</code> methods that take\n- * <code>double[]</code> arrays as input and return the value of the statistic\n- * applied to the input values.</p>\n+ * Base interface implemented by all statistics.\n  * \n  * @version $Revision$ $Date$\n  */\n      * @return the value of the statistic applied to the included array entries\n      */\n     double evaluate(double[] values, int begin, int length);\n+    \n+    /**\n+     * Returns a copy of the statistic with the same internal state.\n+     * \n+     * @return a copy of the statistic\n+     */\n+    UnivariateStatistic copy();\n \n-}\n+}\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/FirstMoment.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/FirstMoment.java\n package org.apache.commons.math.stat.descriptive.moment;\n \n import java.io.Serializable;\n-\n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n \n /**\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     * Copy constructor, creates a new {@code FirstMoment} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code FirstMoment} instance to copy\n+     */\n+     public FirstMoment(FirstMoment original) {\n+         super();\n+         copy(original, this);\n+     }\n+    \n+    /**\n+     * {@inheritDoc}\n      */\n     public void increment(final double d) {\n         if (n == 0) {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     * {@inheritDoc}\n      */\n     public void clear() {\n         m1 = Double.NaN;\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     * {@inheritDoc}\n      */\n     public double getResult() {\n         return m1;\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     * {@inheritDoc}\n      */\n     public long getN() {\n         return n;\n     }\n-}\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public FirstMoment copy() {\n+        FirstMoment result = new FirstMoment();\n+        copy(this, result);\n+        return result; \n+    }\n+     \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source FirstMoment to copy\n+     * @param dest FirstMoment to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(FirstMoment source, FirstMoment dest) {\n+        dest.n = source.n;\n+        dest.m1 = source.m1;\n+        dest.dev = source.dev;\n+        dest.nDev = dest.nDev;\n+    }\n+}\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/FourthMoment.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/FourthMoment.java\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     * Copy constructor, creates a new {@code FourthMoment} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code FourthMoment} instance to copy\n+     */\n+     public FourthMoment(FourthMoment original) {\n+         super();\n+         copy(original, this);\n+     }\n+    \n+    /**\n+     * {@inheritDoc}\n      */\n     public void increment(final double d) {\n         if (n < 1) {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     * {@inheritDoc}\n      */\n     public double getResult() {\n         return m4;\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     * {@inheritDoc}\n      */\n     public void clear() {\n         super.clear();\n         m4 = Double.NaN;\n     }\n-\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public FourthMoment copy() {\n+        FourthMoment result = new FourthMoment();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source FourthMoment to copy\n+     * @param dest FourthMoment to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(FourthMoment source, FourthMoment dest) {\n+        ThirdMoment.copy(source, dest);\n+        dest.m4 = source.m4;\n+    }  \n }\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n  */\n package org.apache.commons.math.stat.descriptive.moment;\n \n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.summary.SumOfLogs;\n     }\n     \n     /**\n+     * Copy constructor, creates a new {@code GeometricMean} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code GeometricMean} instance to copy\n+     */\n+    public GeometricMean(GeometricMean original) {\n+        super();\n+        copy(original, this);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public GeometricMean copy() {\n+        GeometricMean result = new GeometricMean();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n      * Create a GeometricMean instance using the given SumOfLogs instance\n+     * @param sumOfLogs sum of logs instance to use for computation\n      */\n     public GeometricMean(SumOfLogs sumOfLogs) {\n         this.sumOfLogs = sumOfLogs;\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     * {@inheritDoc}\n      */\n     public void increment(final double d) {\n         sumOfLogs.increment(d);\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     * {@inheritDoc}\n      */\n     public double getResult() {\n         if (sumOfLogs.getN() > 0) {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     * {@inheritDoc}\n      */\n     public void clear() {\n         sumOfLogs.clear();\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     * {@inheritDoc}\n      */\n     public long getN() {\n         return sumOfLogs.getN();\n     }\n     \n     /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source GeometricMean to copy\n+     * @param dest GeometricMean to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(GeometricMean source, GeometricMean dest) {\n+        dest.sumOfLogs = (SumOfLogs) source.sumOfLogs.copy();\n+    }\n+    \n+    \n+    /**\n      * Throws IllegalStateException if n > 0.\n      */\n     private void checkEmpty() {\n         if (getN() > 0) {\n-            throw new IllegalStateException(\n-                \"Implementation must be configured before values are added.\");\n+            throw MathRuntimeException.createIllegalStateException(\"{0} values have been added before statistic is configured\",\n+                                                                   new Object[] { getN() });\n         }\n     }\n \n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n  */\n package org.apache.commons.math.stat.descriptive.moment;\n \n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n \n /**\n  * Computes the Kurtosis of the available values.\n         incMoment = false;\n         this.moment = m4;\n     }\n-\n-    /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+    \n+    /**\n+     * Copy constructor, creates a new {@code Kurtosis} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Kurtosis} instance to copy\n+     */\n+    public Kurtosis(Kurtosis original) {\n+        copy(original, this);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n      */\n     public void increment(final double d) {\n         if (incMoment) {\n             moment.increment(d);\n         }  else  {\n-            throw new IllegalStateException\n-            (\"Statistics constructed from external moments cannot be incremented\");\n+            throw MathRuntimeException.createIllegalStateException(\"statistics constructed from external \" +\n+                                                                   \"moments cannot be incremented\",\n+                                                                   null);\n         }\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     * {@inheritDoc}\n      */\n     public double getResult() {\n         double kurtosis = Double.NaN;\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     * {@inheritDoc}\n      */\n     public void clear() {\n         if (incMoment) {\n             moment.clear();\n         } else  {\n-            throw new IllegalStateException\n-                (\"Statistics constructed from external moments cannot be cleared\");\n+            throw MathRuntimeException.createIllegalStateException(\"statistics constructed from external \" +\n+                                                                   \"moments cannot be cleared\",\n+                                                                   null);\n         }\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     * {@inheritDoc}\n      */\n     public long getN() {\n         return moment.getN();\n         }       \n         return kurt;\n     }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Kurtosis copy() {\n+        Kurtosis result = new Kurtosis();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source Kurtosis to copy\n+     * @param dest Kurtosis to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(Kurtosis source, Kurtosis dest) {\n+        dest.moment = (FourthMoment) source.moment.copy();\n+        dest.incMoment = source.incMoment;\n+    }\n \n }\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n         this.moment = m1;\n         incMoment = false;\n     }\n+    \n+    /**\n+     * Copy constructor, creates a new {@code Mean} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Mean} instance to copy\n+     */\n+    public Mean(Mean original) {\n+        copy(original, this);\n+    }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     * {@inheritDoc}\n      */\n     public void increment(final double d) {\n         if (incMoment) {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     * {@inheritDoc}\n      */\n     public void clear() {\n         if (incMoment) {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     * {@inheritDoc}\n      */\n     public double getResult() {\n         return moment.m1;\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     * {@inheritDoc}\n      */\n     public long getN() {\n         return moment.getN();\n         }\n         return Double.NaN;\n     }\n-}\n+    \n+    /*\n+     * {@inheritDoc}\n+     */\n+    public Mean copy() {\n+        Mean result = new Mean();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source Mean to copy\n+     * @param dest Mean to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(Mean source, Mean dest) {\n+        dest.incMoment = source.incMoment;\n+        dest.moment = (FirstMoment) source.moment.copy();\n+    }\n+}\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/SecondMoment.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/SecondMoment.java\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     * Copy constructor, creates a new {@code SecondMoment} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code SecondMoment} instance to copy\n+     */\n+    public SecondMoment(SecondMoment original) {\n+        super(original);\n+        this.m2 = original.m2;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n      */\n     public void increment(final double d) {\n         if (n < 1) {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     * {@inheritDoc}\n      */\n     public void clear() {\n         super.clear();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     * {@inheritDoc}\n      */\n     public double getResult() {\n         return m2;\n     }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public SecondMoment copy() {\n+        SecondMoment result = new SecondMoment();\n+        copy(this, result);\n+        return result; \n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source SecondMoment to copy\n+     * @param dest SecondMoment to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(SecondMoment source, SecondMoment dest) {\n+        FirstMoment.copy(source, dest);\n+        dest.m2 = source.m2;\n+    }\n \n }\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n         incMoment = false;\n         this.moment = m3;\n     }\n-\n-    /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     \n+    /**\n+     * Copy constructor, creates a new {@code Skewness} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Skewness} instance to copy\n+     */\n+    public Skewness(Skewness original) {\n+        copy(original, this);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n      */\n     public void increment(final double d) {\n         if (incMoment) {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     * {@inheritDoc}\n      */\n     public long getN() {\n         return moment.getN();\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     * {@inheritDoc}\n      */\n     public void clear() {\n         if (incMoment) {\n         }\n         return skew;\n     }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Skewness copy() {\n+        Skewness result = new Skewness();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source Skewness to copy\n+     * @param dest Skewness to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(Skewness source, Skewness dest) {\n+        dest.moment = new ThirdMoment((ThirdMoment) source.moment.copy());\n+        dest.incMoment = source.incMoment;\n+    }\n }\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java\n     }\n     \n     /**\n+     * Copy constructor, creates a new {@code StandardDeviation} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code StandardDeviation} instance to copy\n+     */\n+    public StandardDeviation(StandardDeviation original) {\n+        copy(original, this);\n+    }\n+    \n+    /**\n      * Contructs a StandardDeviation with the specified value for the\n      * <code>isBiasCorrected</code> property.  If this property is set to \n      * <code>true</code>, the {@link Variance} used in computing results will\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     * {@inheritDoc}\n      */\n     public void increment(final double d) {\n         variance.increment(d);\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     * {@inheritDoc}\n      */\n     public long getN() {\n         return variance.getN();\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     * {@inheritDoc}\n      */\n     public double getResult() {\n         return Math.sqrt(variance.getResult());\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     * {@inheritDoc}\n      */\n     public void clear() {\n         variance.clear();\n     public void setBiasCorrected(boolean isBiasCorrected) {\n         variance.setBiasCorrected(isBiasCorrected);\n     }\n-}\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public StandardDeviation copy() {\n+        StandardDeviation result = new StandardDeviation();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source StandardDeviation to copy\n+     * @param dest StandardDeviation to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(StandardDeviation source, StandardDeviation dest) {\n+        dest.variance = (Variance) source.variance.copy();\n+    }\n+    \n+}\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/ThirdMoment.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/ThirdMoment.java\n package org.apache.commons.math.stat.descriptive.moment;\n \n import java.io.Serializable;\n+\n \n /**\n  * Computes a statistic related to the Third Central Moment.  Specifically,\n         m3 = Double.NaN;\n         nDevSq = Double.NaN;\n     }\n+    \n+    /**\n+     * Copy constructor, creates a new {@code ThirdMoment} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code ThirdMoment} instance to copy\n+     */\n+    public ThirdMoment(ThirdMoment original) {\n+        copy(original, this);\n+    }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     * {@inheritDoc}\n      */\n     public void increment(final double d) {\n         if (n < 1) {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     * {@inheritDoc}\n      */\n     public double getResult() {\n         return m3;\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     * {@inheritDoc}\n      */\n     public void clear() {\n         super.clear();\n         m3 = Double.NaN;\n         nDevSq = Double.NaN;\n     }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public ThirdMoment copy() {\n+        ThirdMoment result = new ThirdMoment();\n+        copy(this, result);\n+        return result; \n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source ThirdMoment to copy\n+     * @param dest ThirdMoment to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(ThirdMoment source, ThirdMoment dest) {\n+        SecondMoment.copy(source, dest);\n+        dest.m3 = source.m3;\n+        dest.nDevSq = source.nDevSq;\n+    }\n \n-}\n+}\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n     }\n    \n     /**\n+     * Copy constructor, creates a new {@code Variance} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Variance} instance to copy\n+     */\n+    public Variance(Variance original) {\n+        copy(original, this);\n+    }           \n+    \n+    /**\n      * {@inheritDoc}  \n      * <p>If all values are available, it is more accurate to use \n      * {@link #evaluate(double[])} rather than adding values one at a time\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     * {@inheritDoc}\n      */\n     public double getResult() {\n             if (moment.n == 0) {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     * {@inheritDoc}\n      */\n     public long getN() {\n         return moment.getN();\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     * {@inheritDoc}\n      */\n     public void clear() {\n         if (incMoment) {\n     public void setBiasCorrected(boolean isBiasCorrected) {\n         this.isBiasCorrected = isBiasCorrected;\n     }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public Variance copy() {\n+        Variance result = new Variance();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source Variance to copy\n+     * @param dest Variance to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(Variance source, Variance dest) {\n+        dest.moment = (SecondMoment) source.moment.copy();\n+        dest.isBiasCorrected = source.isBiasCorrected;\n+        dest.incMoment = source.incMoment;\n+    }\n \n }\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/VectorialCovariance.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/VectorialCovariance.java\n     /** Number of vectors in the sample. */\n     private long n;\n \n-    /** Constructs a VectorialMean.\n+    /** Constructs a VectorialCovariance.\n      * @param dimension vectors dimension\n      * @param isBiasCorrected if true, computed the unbiased sample covariance,\n      * otherwise computes the biased population covariance\n--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Max.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Max.java\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     * Copy constructor, creates a new {@code Max} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Max} instance to copy\n+     */\n+    public Max(Max original) {\n+        copy(original, this);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n      */\n     public void increment(final double d) {\n         if (d > value || Double.isNaN(value)) {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     * {@inheritDoc}\n      */\n     public void clear() {\n         value = Double.NaN;\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     * {@inheritDoc}\n      */\n     public double getResult() {\n         return value;\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     * {@inheritDoc}\n      */\n     public long getN() {\n         return n;\n         }\n         return max;\n     }\n-}\n+    \n+    /*\n+     * {@inheritDoc}\n+     */\n+    public Max copy() {\n+        Max result = new Max();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source Max to copy\n+     * @param dest Max to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(Max source, Max dest) {\n+        dest.n = source.n;\n+        dest.value = source.value;\n+    }\n+}\n--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Median.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Median.java\n     public Median() {\n         super(50.0);\n     }\n+    \n+    /**\n+     * Copy constructor, creates a new {@code Median} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Median} instance to copy\n+     */\n+    public Median(Median original) {\n+        super(original);\n+    }        \n \n }\n--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Min.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Min.java\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     * Copy constructor, creates a new {@code Min} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Min} instance to copy\n+     */\n+    public Min(Min original) {\n+        copy(original, this);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n      */\n     public void increment(final double d) {\n         if (d < value || Double.isNaN(value)) {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     * {@inheritDoc}\n      */\n     public void clear() {\n         value = Double.NaN;\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     * {@inheritDoc}\n      */\n     public double getResult() {\n         return value;\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     * {@inheritDoc}\n      */\n     public long getN() {\n         return n;\n         }\n         return min;\n     }\n-}\n+    \n+    /*\n+     * {@inheritDoc}\n+     */\n+    public Min copy() {\n+        Min result = new Min();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source Min to copy\n+     * @param dest Min to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(Min source, Min dest) {\n+        dest.n = source.n;\n+        dest.value = source.value;\n+    }\n+}\n--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n     }\n \n     /**\n+     * Copy constructor, creates a new {@code Percentile} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Percentile} instance to copy\n+     */\n+    public Percentile(Percentile original) {\n+        copy(original, this);\n+    }        \n+    \n+    /**\n      * Returns an estimate of the <code>p</code>th percentile of the values\n      * in the <code>values</code> array.\n      * <p>\n         }\n         quantile = p;\n     }\n-\n-}\n+    \n+    /*\n+     * {@inheritDoc}\n+     */\n+    public Percentile copy() {\n+        Percentile result = new Percentile();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source Percentile to copy\n+     * @param dest Percentile to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(Percentile source, Percentile dest) {\n+        dest.quantile = source.quantile;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     * Copy constructor, creates a new {@code Product} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Product} instance to copy\n+     */\n+    public Product(Product original) {\n+        copy(original, this);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n      */\n     public void increment(final double d) {\n         if (n == 0) {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     * {@inheritDoc}\n      */\n     public double getResult() {\n         return value;\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     * {@inheritDoc}\n      */\n     public long getN() {\n         return n;\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     * {@inheritDoc}\n      */\n     public void clear() {\n         value = Double.NaN;\n         }\n         return product;\n     }\n+    \n+    /*\n+     * {@inheritDoc}\n+     */\n+    public Product copy() {\n+        Product result = new Product();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source Product to copy\n+     * @param dest Product to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(Product source, Product dest) {\n+        dest.n = source.n;\n+        dest.value = source.value;\n+    }\n \n-}\n+}\n--- a/src/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     * Copy constructor, creates a new {@code Sum} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Sum} instance to copy\n+     */\n+    public Sum(Sum original) {\n+        copy(original, this);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n      */\n     public void increment(final double d) {\n         if (n == 0) {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     * {@inheritDoc}\n      */\n     public double getResult() {\n         return value;\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     * {@inheritDoc}\n      */\n     public long getN() {\n         return n;\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     * {@inheritDoc}\n      */\n     public void clear() {\n         value = Double.NaN;\n         }\n         return sum;\n     }\n+    \n+    /*\n+     * {@inheritDoc}\n+     */\n+    public Sum copy() {\n+        Sum result = new Sum();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source Sum to copy\n+     * @param dest Sum to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(Sum source, Sum dest) {\n+        dest.n = source.n;\n+        dest.value = source.value;\n+    }\n \n }\n--- a/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n        value = 0d;\n        n = 0;\n     }\n+    \n+    /**\n+     * Copy constructor, creates a new {@code SumOfLogs} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code SumOfLogs} instance to copy\n+     */\n+    public SumOfLogs(SumOfLogs original) {\n+        copy(original, this);\n+    }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     * {@inheritDoc}\n      */\n     public void increment(final double d) {\n         value += Math.log(d);\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     * {@inheritDoc}\n      */\n     public double getResult() {\n         if (n > 0) {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     * {@inheritDoc}\n      */\n     public long getN() {\n         return n;\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     * {@inheritDoc}\n      */\n     public void clear() {\n         value = 0d;\n         }\n         return sumLog;\n     }\n-}\n+    \n+    /*\n+     * {@inheritDoc}\n+     */\n+    public SumOfLogs copy() {\n+        SumOfLogs result = new SumOfLogs();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source SumOfLogs to copy\n+     * @param dest SumOfLogs to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(SumOfLogs source, SumOfLogs dest) {\n+        dest.n = source.n;\n+        dest.value = source.value;\n+    }\n+}\n--- a/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     * Copy constructor, creates a new {@code SumOfSquares} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code SumOfSquares} instance to copy\n+     */\n+    public SumOfSquares(SumOfSquares original) {\n+        copy(original, this);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n      */\n     public void increment(final double d) {\n         if (n == 0) {\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     * {@inheritDoc}\n      */\n     public double getResult() {\n         return value;\n     }\n \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     * {@inheritDoc}\n      */\n     public long getN() {\n         return n;\n     }\n     \n     /**\n-     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     * {@inheritDoc}\n      */\n     public void clear() {\n         value = Double.NaN;\n         }\n         return sumSq;\n     }\n+    \n+    /*\n+     * {@inheritDoc}\n+     */\n+    public SumOfSquares copy() {\n+        SumOfSquares result = new SumOfSquares();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source SumOfSquares to copy\n+     * @param dest SumOfSquares to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(SumOfSquares source, SumOfSquares dest) {\n+        dest.n = source.n;\n+        dest.value = source.value;\n+    }\n \n-}\n+}\n--- a/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n+++ b/src/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n import org.apache.commons.math.MathException;\n import org.apache.commons.math.distribution.ChiSquaredDistribution;\n import org.apache.commons.math.distribution.ChiSquaredDistributionImpl;\n-import org.apache.commons.math.distribution.DistributionFactory;\n \n /**\n  * Implements Chi-Square test statistics defined in the\n         \n     }\n     \n-    //---------------------  Protected methods ---------------------------------\n-    /**\n-     * Gets a DistributionFactory to use in creating ChiSquaredDistribution instances.\n-     * @deprecated inject ChiSquaredDistribution instances directly instead of\n-     *             using a factory.\n-     */\n-    protected DistributionFactory getDistributionFactory() {\n-        return DistributionFactory.newInstance();\n-    }\n-    \n     //---------------------  Private array methods -- should find a utility home for these\n     \n     /**\n--- a/src/java/org/apache/commons/math/stat/inference/OneWayAnova.java\n+++ b/src/java/org/apache/commons/math/stat/inference/OneWayAnova.java\n      * @throws MathException if the statistic can not be computed do to a\n      *         convergence or other numerical error.\n      */\n-    public double anovaFValue(Collection categoryData)\n+    public double anovaFValue(Collection<double[]> categoryData)\n         throws IllegalArgumentException, MathException;\n \n     /**\n      * @throws MathException if the statistic can not be computed do to a\n      *         convergence or other numerical error.\n      */\n-    public double anovaPValue(Collection categoryData)\n+    public double anovaPValue(Collection<double[]> categoryData)\n         throws IllegalArgumentException, MathException;\n \n     /**\n      * @throws MathException if the statistic can not be computed do to a\n      *         convergence or other numerical error.\n     */\n-    public boolean anovaTest(Collection categoryData, double alpha)\n+    public boolean anovaTest(Collection<double[]> categoryData, double alpha)\n         throws IllegalArgumentException, MathException;\n \n }\n--- a/src/java/org/apache/commons/math/stat/inference/OneWayAnovaImpl.java\n+++ b/src/java/org/apache/commons/math/stat/inference/OneWayAnovaImpl.java\n  */\n package org.apache.commons.math.stat.inference;\n \n+import java.util.Collection;\n+\n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.distribution.FDistribution;\n+import org.apache.commons.math.distribution.FDistributionImpl;\n import org.apache.commons.math.stat.descriptive.summary.Sum;\n import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n-\n-import org.apache.commons.math.distribution.FDistribution;\n-import org.apache.commons.math.distribution.FDistributionImpl;\n-\n-import java.util.Collection;\n-import java.util.Iterator;\n \n \n /**\n      * are as defined <a href=\"http://faculty.vassar.edu/lowry/ch13pt1.html\">\n      * here</a></p>\n      */\n-    public double anovaFValue(Collection categoryData)\n+    public double anovaFValue(Collection<double[]> categoryData)\n         throws IllegalArgumentException, MathException {\n         AnovaStats a = anovaStats(categoryData);\n         return a.F;\n      * where <code>F</code> is the F value and <code>cumulativeProbability</code>\n      * is the commons-math implementation of the F distribution.</p>\n      */\n-    public double anovaPValue(Collection categoryData)\n+    public double anovaPValue(Collection<double[]> categoryData)\n         throws IllegalArgumentException, MathException {\n         AnovaStats a = anovaStats(categoryData);\n         FDistribution fdist = new FDistributionImpl(a.dfbg, a.dfwg);\n      * is the commons-math implementation of the F distribution.</p>\n      * <p>True is returned iff the estimated p-value is less than alpha.</p>\n      */\n-    public boolean anovaTest(Collection categoryData, double alpha)\n+    public boolean anovaTest(Collection<double[]> categoryData, double alpha)\n         throws IllegalArgumentException, MathException {\n         if ((alpha <= 0) || (alpha > 0.5)) {\n             throw new IllegalArgumentException(\"bad significance level: \" + alpha);\n      * preconditions specified in the interface definition\n      * @throws MathException if an error occurs computing the Anova stats\n      */\n-    private AnovaStats anovaStats(Collection categoryData)\n+    private AnovaStats anovaStats(Collection<double[]> categoryData)\n         throws IllegalArgumentException, MathException {\n \n         // check if we have enough categories\n         }\n         \n         // check if each category has enough data and all is double[]\n-        for (Iterator iterator = categoryData.iterator(); iterator.hasNext();) {\n-            double[] array;\n-            try {\n-                array = (double[])iterator.next();\n-            } catch (ClassCastException ex) {\n-                throw new IllegalArgumentException(\n-                        \"ANOVA: categoryData contains non-double[] elements.\");\n-            }\n+        for (double[] array : categoryData) {\n             if (array.length <= 1) {\n                 throw new IllegalArgumentException(\n                         \"ANOVA: one element of categoryData has fewer than 2 values.\");\n         SumOfSquares totsumsq = new SumOfSquares();\n         int totnum = 0;\n         \n-        for (Iterator iterator = categoryData.iterator(); iterator.hasNext();) {\n-            double[] data = (double[])iterator.next();\n+        for (double[] data : categoryData) {\n \n             Sum sum = new Sum();\n             SumOfSquares sumsq = new SumOfSquares();\n         No get/set methods provided.\n     */\n     private static class AnovaStats {\n+\n+        /** Degrees of freedom in numerator (between groups). */\n         private int dfbg;\n+\n+        /** Degrees of freedom in denominator (within groups). */\n         private int dfwg;\n+\n+        /** Statistic. */\n         private double F;\n \n         /**\n--- a/src/java/org/apache/commons/math/stat/inference/TTestImpl.java\n+++ b/src/java/org/apache/commons/math/stat/inference/TTestImpl.java\n package org.apache.commons.math.stat.inference;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.distribution.DistributionFactory;\n import org.apache.commons.math.distribution.TDistribution;\n import org.apache.commons.math.distribution.TDistributionImpl;\n import org.apache.commons.math.stat.StatUtils;\n     //----------------------------------------------- Protected methods \n \n     /**\n-     * Gets a DistributionFactory to use in creating TDistribution instances.\n-     * @return a distribution factory.\n-     * @deprecated inject TDistribution directly instead of using a factory.\n-     */\n-    protected DistributionFactory getDistributionFactory() {\n-        return DistributionFactory.newInstance();\n-    }\n-    \n-    /**\n      * Computes approximate degrees of freedom for 2-sample t-test.\n      * \n      * @param v1 first sample variance\n--- a/src/java/org/apache/commons/math/stat/inference/TestUtils.java\n+++ b/src/java/org/apache/commons/math/stat/inference/TestUtils.java\n     }\n     \n     \n+    // CHECKSTYLE: stop JavadocMethodCheck\n+\n     /**\n      * @see org.apache.commons.math.stat.inference.TTest#homoscedasticT(double[], double[])\n      */\n      *\n      * @since 1.2\n      */\n-    public static double oneWayAnovaFValue(Collection categoryData)\n+    public static double oneWayAnovaFValue(Collection<double[]> categoryData)\n     throws IllegalArgumentException, MathException {\n         return oneWayAnova.anovaFValue(categoryData);\n     }\n      * \n      * @since 1.2\n      */\n-    public static double oneWayAnovaPValue(Collection categoryData)\n+    public static double oneWayAnovaPValue(Collection<double[]> categoryData)\n     throws IllegalArgumentException, MathException {\n         return oneWayAnova.anovaPValue(categoryData);\n     }\n      *\n      * @since 1.2\n      */\n-    public static boolean oneWayAnovaTest(Collection categoryData, double alpha)\n+    public static boolean oneWayAnovaTest(Collection<double[]> categoryData, double alpha)\n     throws IllegalArgumentException, MathException {\n         return oneWayAnova.anovaTest(categoryData, alpha);\n     }\n \n+    // CHECKSTYLE: resume JavadocMethodCheck\n+\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/regression/AbstractMultipleLinearRegression.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.regression;\n+\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.RealMatrixImpl;\n+\n+/**\n+ * Abstract base class for implementations of MultipleLinearRegression.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class AbstractMultipleLinearRegression implements\n+        MultipleLinearRegression {\n+\n+    /** X sample data. */\n+    protected RealMatrix X;\n+\n+    /** Y sample data. */\n+    protected RealMatrix Y;\n+\n+    /**\n+     * Loads model x and y sample data from a flat array of data, overriding any previous sample.\n+     * Assumes that rows are concatenated with y values first in each row.\n+     * \n+     * @param data input data array\n+     * @param nobs number of observations (rows)\n+     * @param nvars number of independent variables (columnns, not counting y)\n+     */\n+    public void newSampleData(double[] data, int nobs, int nvars) {\n+        double[] y = new double[nobs];\n+        double[][] x = new double[nobs][nvars + 1];\n+        int pointer = 0;\n+        for (int i = 0; i < nobs; i++) {\n+            y[i] = data[pointer++];\n+            x[i][0] = 1.0d;\n+            for (int j = 1; j < nvars + 1; j++) {\n+                x[i][j] = data[pointer++];\n+            }\n+        }\n+        this.X = new RealMatrixImpl(x);\n+        this.Y = new RealMatrixImpl(y);\n+    }\n+    \n+    /**\n+     * Loads new y sample data, overriding any previous sample\n+     * \n+     * @param y the [n,1] array representing the y sample\n+     */\n+    protected void newYSampleData(double[] y) {\n+        this.Y = new RealMatrixImpl(y);\n+    }\n+\n+    /**\n+     * Loads new x sample data, overriding any previous sample\n+     * \n+     * @param x the [n,k] array representing the x sample\n+     */\n+    protected void newXSampleData(double[][] x) {\n+        this.X = new RealMatrixImpl(x);\n+    }\n+\n+    /**\n+     * Validates sample data.\n+     * \n+     * @param x the [n,k] array representing the x sample\n+     * @param y the [n,1] array representing the y sample\n+     * @throws IllegalArgumentException if the x and y array data are not\n+     *             compatible for the regression\n+     */\n+    protected void validateSampleData(double[][] x, double[] y) {\n+        if (x == null) {\n+            throw new IllegalArgumentException(\"The regressors matrix x cannot be null.\");\n+        }\n+        if (y == null) {\n+            throw new IllegalArgumentException(\"The regressand vector y cannot be null.\");\n+        }\n+        if (x.length != y.length) {\n+            throw new IllegalArgumentException(\n+                    \"The regressors matrix x columns must have the same length of the regressand vector y\");\n+        }\n+    }\n+\n+    /**\n+     * Validates sample data.\n+     * \n+     * @param x the [n,k] array representing the x sample\n+     * @param covariance the [n,n] array representing the covariance matrix\n+     * @throws IllegalArgumentException if the x sample data or covariance\n+     *             matrix are not compatible for the regression\n+     */\n+    protected void validateCovarianceData(double[][] x, double[][] covariance) {\n+        if (covariance == null) {\n+            throw new IllegalArgumentException(\"Covariance matrix cannot be null.\");\n+        }\n+        if (x.length != covariance.length) {\n+            throw new IllegalArgumentException(\n+                    \"The regressors matrix x columns must have the same length of the covariance matrix columns\");\n+        }\n+        if (covariance.length > 0 && covariance.length != covariance[0].length) {\n+            throw new IllegalArgumentException(\"The covariance matrix must be square\");\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double[] estimateRegressionParameters() {\n+        RealMatrix b = calculateBeta();\n+        return b.getColumn(0);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double[] estimateResiduals() {\n+        RealMatrix b = calculateBeta();\n+        RealMatrix e = Y.subtract(X.multiply(b));\n+        return e.getColumn(0);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double[][] estimateRegressionParametersVariance() {\n+        return calculateBetaVariance().getData();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double estimateRegressandVariance() {\n+        return calculateYVariance();\n+    }\n+\n+    /**\n+     * Calculates the beta of multiple linear regression in matrix notation.\n+     * \n+     * @return beta\n+     */\n+    protected abstract RealMatrix calculateBeta();\n+\n+    /**\n+     * Calculates the beta variance of multiple linear regression in matrix\n+     * notation.\n+     * \n+     * @return beta variance\n+     */\n+    protected abstract RealMatrix calculateBetaVariance();\n+\n+    /**\n+     * Calculates the Y variance of multiple linear regression.\n+     * \n+     * @return Y variance\n+     */\n+    protected abstract double calculateYVariance();\n+\n+    /**\n+     * Calculates the residuals of multiple linear regression in matrix\n+     * notation.\n+     * \n+     * <pre>\n+     * u = y - X * b\n+     * </pre>\n+     * \n+     * @return The residuals [n,1] matrix\n+     */\n+    protected RealMatrix calculateResiduals() {\n+        RealMatrix b = calculateBeta();\n+        return Y.subtract(X.multiply(b));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegression.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.regression;\n+\n+import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.RealMatrixImpl;\n+\n+\n+/**\n+ * The GLS implementation of the multiple linear regression.\n+ * \n+ * GLS assumes a general covariance matrix Omega of the error\n+ * <pre>\n+ * u ~ N(0, Omega)\n+ * </pre>\n+ * \n+ * Estimated by GLS, \n+ * <pre>\n+ * b=(X' Omega^-1 X)^-1X'Omega^-1 y\n+ * </pre>\n+ * whose variance is\n+ * <pre>\n+ * Var(b)=(X' Omega^-1 X)^-1\n+ * </pre>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class GLSMultipleLinearRegression extends AbstractMultipleLinearRegression {\n+    \n+    /** Covariance matrix. */\n+    private RealMatrix Omega;\n+\n+    /** Inverse of covariance matrix. */\n+    private RealMatrix OmegaInverse;\n+\n+    /** Replace sample data, overriding any previous sample.\n+     * @param y y values of the sample\n+     * @param x x values of the sample\n+     * @param covariance array representing the covariance matrix\n+     */\n+    public void newSampleData(double[] y, double[][] x, double[][] covariance) {\n+        validateSampleData(x, y);\n+        newYSampleData(y);\n+        newXSampleData(x);\n+        validateCovarianceData(x, covariance);\n+        newCovarianceData(covariance);\n+    }\n+\n+    /**\n+     * Add the covariance data.\n+     * \n+     * @param omega the [n,n] array representing the covariance\n+     */\n+    protected void newCovarianceData(double[][] omega){\n+        this.Omega = new RealMatrixImpl(omega);\n+        this.OmegaInverse = null;\n+    }\n+\n+    /**\n+     * Get the inverse of the covariance.\n+     * <p>The inverse of the covariance matrix is lazily evaluated and cached.</p>\n+     * @return inverse of the covariance\n+     */\n+    protected RealMatrix getOmegaInverse() {\n+        if (OmegaInverse == null) {\n+            OmegaInverse = new LUDecompositionImpl(Omega).getInverse();\n+        }\n+        return OmegaInverse;\n+    }\n+    \n+    /**\n+     * Calculates beta by GLS.\n+     * <pre>\n+     *  b=(X' Omega^-1 X)^-1X'Omega^-1 y\n+     * </pre>\n+     * @return beta\n+     */\n+    protected RealMatrix calculateBeta() {\n+        RealMatrix OI = getOmegaInverse();\n+        RealMatrix XT = X.transpose();\n+        RealMatrix XTOIX = XT.multiply(OI).multiply(X);\n+        return new LUDecompositionImpl(XTOIX).getInverse().multiply(XT).multiply(OI).multiply(Y);\n+    }\n+\n+    /**\n+     * Calculates the variance on the beta by GLS.\n+     * <pre>\n+     *  Var(b)=(X' Omega^-1 X)^-1\n+     * </pre>\n+     * @return The beta variance matrix\n+     */\n+    protected RealMatrix calculateBetaVariance() {\n+        RealMatrix OI = getOmegaInverse();\n+        RealMatrix XTOIX = X.transpose().multiply(OI).multiply(X);\n+        return new LUDecompositionImpl(XTOIX).getInverse();\n+    }\n+\n+    /**\n+     * Calculates the variance on the y by GLS.\n+     * <pre>\n+     *  Var(y)=Tr(u' Omega^-1 u)/(n-k)\n+     * </pre>\n+     * @return The Y variance\n+     */\n+    protected double calculateYVariance() {\n+        RealMatrix u = calculateResiduals();\n+        RealMatrix sse =  u.transpose().multiply(getOmegaInverse()).multiply(u);\n+        return sse.getTrace()/(X.getRowDimension()-X.getColumnDimension());\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/regression/MultipleLinearRegression.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.regression;\n+\n+/**\n+ * The multiple linear regression can be represented in matrix-notation.\n+ * <pre>\n+ *  y=X*b+u\n+ * </pre>\n+ * where y is an <code>n-vector</code> <b>regressand</b>, X is a <code>[n,k]</code> matrix whose <code>k</code> columns are called\n+ * <b>regressors</b>, b is <code>k-vector</code> of <b>regression parameters</b> and <code>u</code> is an <code>n-vector</code>\n+ * of <b>error terms</b> or <b>residuals</b>.\n+ * \n+ * The notation is quite standard in literature, \n+ * cf eg <a href=\"http://www.econ.queensu.ca/ETM\">Davidson and MacKinnon, Econometrics Theory and Methods, 2004</a>.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface MultipleLinearRegression {\n+\n+    /**\n+     * Estimates the regression parameters b.\n+     * \n+     * @return The [k,1] array representing b\n+     */\n+    double[] estimateRegressionParameters();\n+\n+    /**\n+     * Estimates the variance of the regression parameters, ie Var(b).\n+     * \n+     * @return The [k,k] array representing the variance of b\n+     */\n+    double[][] estimateRegressionParametersVariance();\n+    \n+    /**\n+     * Estimates the residuals, ie u = y - X*b.\n+     * \n+     * @return The [n,1] array representing the residuals\n+     */\n+    double[] estimateResiduals();\n+\n+    /**\n+     * Returns the variance of the regressand, ie Var(y).\n+     * \n+     * @return The double representing the variance of y\n+     */\n+    double estimateRegressandVariance();\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.regression;\n+\n+import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.QRDecomposition;\n+import org.apache.commons.math.linear.QRDecompositionImpl;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.RealMatrixImpl;\n+\n+/**\n+ * <p>Implements ordinary least squares (OLS) to estimate the parameters of a \n+ * multiple linear regression model.</p>\n+ * \n+ * <p>OLS assumes the covariance matrix of the error to be diagonal and with\n+ * equal variance.\n+ * <pre>\n+ * u ~ N(0, sigma^2*I)\n+ * </pre></p>\n+ * \n+ * <p>The regression coefficients, b, satisfy the normal equations:\n+ * <pre>\n+ * X^T X b = X^T y\n+ * </pre></p>\n+ * \n+ * <p>To solve the normal equations, this implementation uses QR decomposition\n+ * of the X matrix. (See {@link QRDecompositionImpl} for details on the\n+ * decomposition algorithm.)\n+ * <pre>\n+ * X^T X b = X^T y\n+ * (QR)^T (QR) b = (QR)^T y\n+ * R^T (Q^T Q) R b = R^T Q^T y\n+ * R^T R b = R^T Q^T y\n+ * (R^T)^{-1} R^T R b = (R^T)^{-1} R^T Q^T y\n+ * R b = Q^T y\n+ * </pre>\n+ * Given Q and R, the last equation is solved by back-subsitution.</p>\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class OLSMultipleLinearRegression extends AbstractMultipleLinearRegression {\n+    \n+    /** Cached QR decomposition of X matrix */\n+    private QRDecomposition qr = null;\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * Computes and caches QR decomposition of the X matrix.\n+     */\n+    public void newSampleData(double[] y, double[][] x) {\n+        validateSampleData(x, y);\n+        newYSampleData(y);\n+        newXSampleData(x);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     * \n+     * Computes and caches QR decomposition of the X matrix\n+     */\n+    public void newSampleData(double[] data, int nobs, int nvars) {\n+        super.newSampleData(data, nobs, nvars);\n+        qr = new QRDecompositionImpl(X);\n+    }\n+    \n+    /**\n+     * Loads new x sample data, overriding any previous sample\n+     * \n+     * @param x the [n,k] array representing the x sample\n+     */\n+    protected void newXSampleData(double[][] x) {\n+        this.X = new RealMatrixImpl(x);\n+        qr = new QRDecompositionImpl(X);\n+    }\n+    \n+    /**\n+     * Calculates regression coefficients using OLS.\n+     * \n+     * @return beta\n+     */\n+    protected RealMatrix calculateBeta() {\n+        return solveUpperTriangular((RealMatrixImpl) qr.getR(),\n+                (RealMatrixImpl) qr.getQ().transpose().multiply(Y));\n+    }\n+\n+    /**\n+     * Calculates the variance on the beta by OLS.\n+     * <pre>\n+     *  Var(b)=(X'X)^-1\n+     * </pre>\n+     * @return The beta variance\n+     */\n+    protected RealMatrix calculateBetaVariance() {\n+        RealMatrix XTX = X.transpose().multiply(X);\n+        return new LUDecompositionImpl(XTX).getInverse();\n+    }\n+    \n+\n+    /**\n+     * Calculates the variance on the Y by OLS.\n+     * <pre>\n+     *  Var(y)=Tr(u'u)/(n-k)\n+     * </pre>\n+     * @return The Y variance\n+     */\n+    protected double calculateYVariance() {\n+        RealMatrix u = calculateResiduals();\n+        RealMatrix sse = u.transpose().multiply(u);\n+        return sse.getTrace()/(X.getRowDimension()-X.getColumnDimension());\n+    }\n+    \n+    /** TODO:  Find a home for the following methods in the linear package */   \n+    \n+    /**\n+     * <p>Uses back substitution to solve the system</p>\n+     * \n+     * <p>coefficients X = constants</p>\n+     * \n+     * <p>coefficients must upper-triangular and constants must be a column \n+     * matrix.  The solution is returned as a column matrix.</p>\n+     * \n+     * <p>The number of columns in coefficients determines the length\n+     * of the returned solution vector (column matrix).  If constants\n+     * has more rows than coefficients has columns, excess rows are ignored.\n+     * Similarly, extra (zero) rows in coefficients are ignored</p>\n+     * \n+     * @param coefficients upper-triangular coefficients matrix\n+     * @param constants column RHS constants matrix\n+     * @return solution matrix as a column matrix\n+     * \n+     */\n+    private static RealMatrix solveUpperTriangular(RealMatrixImpl coefficients,\n+            RealMatrixImpl constants) {\n+        if (!isUpperTriangular(coefficients, 1E-12)) {\n+            throw new IllegalArgumentException(\n+                   \"Coefficients is not upper-triangular\");\n+        }\n+        if (constants.getColumnDimension() != 1) {\n+            throw new IllegalArgumentException(\n+                    \"Constants not a column matrix.\");\n+        }\n+        int length = coefficients.getColumnDimension();\n+        double[][] cons = constants.getDataRef();\n+        double[][] coef = coefficients.getDataRef();\n+        double x[] = new double[length];\n+        for (int i = 0; i < length; i++) {\n+            int index = length - 1 - i;\n+            double sum = 0;\n+            for (int j = index + 1; j < length; j++) {\n+                sum += coef[index][j] * x[j];\n+            }\n+            x[index] = (cons[index][0] - sum) / coef[index][index];\n+        } \n+        return new RealMatrixImpl(x);\n+    }\n+    \n+    /**\n+     * <p>Returns true iff m is an upper-triangular matrix.</p>\n+     * \n+     * <p>Makes sure all below-diagonal elements are within epsilon of 0.</p>\n+     * \n+     * @param m matrix to check\n+     * @param epsilon maximum allowable absolute value for elements below\n+     * the main diagonal\n+     * \n+     * @return true if m is upper-triangular; false otherwise\n+     * @throws NullPointerException if m is null\n+     */\n+    private static boolean isUpperTriangular(RealMatrixImpl m, double epsilon) {\n+        double[][] data = m.getDataRef();\n+        int nCols = m.getColumnDimension();\n+        int nRows = m.getRowDimension();\n+        for (int r = 0; r < nRows; r++) {\n+            int bound = Math.min(r, nCols);\n+            for (int c = 0; c < bound; c++) {\n+                if (Math.abs(data[r][c]) > epsilon) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+}\n--- a/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n         }\n     }\n \n+    \n+    /**\n+     * Removes the observation (x,y) from the regression data set.\n+     * <p>\n+     * Mirrors the addData method.  This method permits the use of \n+     * SimpleRegression instances in streaming mode where the regression \n+     * is applied to a sliding \"window\" of observations, however the caller is \n+     * responsible for maintaining the set of observations in the window.</p>\n+     * \n+     * The method has no effect if there are no points of data (i.e. n=0)\n+     *\n+     * @param x independent variable value\n+     * @param y dependent variable value\n+     */\n+    public void removeData(double x, double y) {\n+        if (n > 0) {\n+            double dx = x - xbar;\n+            double dy = y - ybar;\n+            sumXX -= dx * dx * (double) n / (double) (n - 1.0);\n+            sumYY -= dy * dy * (double) n / (double) (n - 1.0);\n+            sumXY -= dx * dy * (double) n / (double) (n - 1.0);\n+            xbar -= dx / (double) (n - 1.0);\n+            ybar -= dy / (double) (n - 1.0);\n+            sumX -= x;\n+            sumY -= y;\n+            n--;\n+            \n+            if (n > 2) {\n+                distribution.setDegreesOfFreedom(n - 2);\n+            } \n+        }\n+    }\n+\n     /**\n      * Adds the observations represented by the elements in \n      * <code>data</code>.\n     public void addData(double[][] data) {\n         for (int i = 0; i < data.length; i++) {\n             addData(data[i][0], data[i][1]);\n+        }\n+    }\n+\n+\n+    /**\n+     * Removes observations represented by the elements in <code>data</code>.\n+      * <p> \n+     * If the array is larger than the current n, only the first n elements are \n+     * processed.  This method permits the use of SimpleRegression instances in \n+     * streaming mode where the regression is applied to a sliding \"window\" of \n+     * observations, however the caller is responsible for maintaining the set \n+     * of observations in the window.</p>\n+     * <p> \n+     * To remove all data, use <code>clear()</code>.</p>\n+     * \n+     * @param data array of observations to be removed\n+     */\n+    public void removeData(double[][] data) {\n+        for (int i = 0; i < data.length && n > 0; i++) {\n+            removeData(data[i][0], data[i][1]);\n         }\n     }\n \n--- a/src/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+++ b/src/java/org/apache/commons/math/transform/FastCosineTransformer.java\n  * power of 2 plus one. Users should especially pay attention to the\n  * function transformation on how this affects the sampling.</p>\n  *\n- * @version $Revision$ $Date$\n+ * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $\n  * @since 1.2\n  */\n public class FastCosineTransformer implements Serializable {\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/util/CompositeFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+/**\n+ * Base class for formatters of composite objects (complex numbers, vectors ...).\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Revision$ $Date$\n+ */\n+public abstract class CompositeFormat extends Format {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 5358685519349262494L;\n+\n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getInstance()} with the only customizing that the\n+     * maximum number of fraction digits is set to 2.  \n+     * @return the default number format.\n+     */\n+    protected static NumberFormat getDefaultNumberFormat() {\n+        return getDefaultNumberFormat(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getInstance(java.util.Locale)} with the only\n+     * customizing that the maximum number of fraction digits is set to 2.  \n+     * @param locale the specific locale used by the format.\n+     * @return the default number format specific to the given locale.\n+     */\n+    protected static NumberFormat getDefaultNumberFormat(final Locale locale) {\n+        final NumberFormat nf = NumberFormat.getInstance(locale);\n+        nf.setMaximumFractionDigits(2);\n+        return nf;\n+    }\n+\n+    /**\n+     * Parses <code>source</code> until a non-whitespace character is found.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.  On output, <code>pos</code>\n+     *        holds the index of the next non-whitespace character.\n+     */\n+    protected void parseAndIgnoreWhitespace(final String source,\n+                                            final ParsePosition pos) {\n+        parseNextCharacter(source, pos);\n+        pos.setIndex(pos.getIndex() - 1);\n+    }\n+\n+    /**\n+     * Parses <code>source</code> until a non-whitespace character is found.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the first non-whitespace character.\n+     */\n+    protected char parseNextCharacter(final String source,\n+                                      final ParsePosition pos) {\n+         int index = pos.getIndex();\n+         final int n = source.length();\n+         char ret = 0;\n+    \n+         if (index < n) {\n+             char c;\n+             do {\n+                 c = source.charAt(index++);\n+             } while (Character.isWhitespace(c) && index < n);\n+             pos.setIndex(index);\n+         \n+             if (index < n) {\n+                 ret = c;\n+             }\n+         }\n+         \n+         return ret;\n+    }\n+\n+    /**\n+     * Parses <code>source</code> for special double values.  These values\n+     * include Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n+     *\n+     * @param source the string to parse\n+     * @param value the special value to parse.\n+     * @param pos input/ouput parsing parameter.\n+     * @return the special number.\n+     */\n+    private Number parseNumber(final String source, final double value,\n+                               final ParsePosition pos) {\n+        Number ret = null;\n+        \n+        StringBuffer sb = new StringBuffer();\n+        sb.append('(');\n+        sb.append(value);\n+        sb.append(')');\n+        \n+        final int n = sb.length();\n+        final int startIndex = pos.getIndex();\n+        final int endIndex = startIndex + n;\n+        if (endIndex < source.length()) {\n+            if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {\n+                ret = Double.valueOf(value);\n+                pos.setIndex(endIndex);\n+            }\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Parses <code>source</code> for a number.  This method can parse normal,\n+     * numeric values as well as special values.  These special values include\n+     * Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n+     *\n+     * @param source the string to parse\n+     * @param format the number format used to parse normal, numeric values.\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed number.\n+     */\n+    protected Number parseNumber(final String source, final NumberFormat format,\n+                                 final ParsePosition pos) {\n+        final int startIndex = pos.getIndex();\n+        Number number = format.parse(source, pos);\n+        final int endIndex = pos.getIndex();\n+        \n+        // check for error parsing number\n+        if (startIndex == endIndex) {\n+            // try parsing special numbers\n+            final double[] special = {\n+                Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY\n+            };\n+            for (int i = 0; i < special.length; ++i) {\n+                number = parseNumber(source, special[i], pos);\n+                if (number != null) {\n+                    break;\n+                }\n+            }\n+        }\n+        \n+        return number;\n+    }\n+\n+    /**\n+     * Parse <code>source</code> for an expected fixed string.\n+     * @param source the string to parse\n+     * @param expected expected string\n+     * @param pos input/ouput parsing parameter.\n+     * @return true if the expected string was there\n+     */\n+    protected boolean parseFixedstring(final String source, final String expected,\n+                                       final ParsePosition pos) {\n+\n+        final int startIndex = pos.getIndex();\n+        final int endIndex = startIndex + expected.length();\n+        if ((startIndex >= source.length()) ||\n+            (endIndex > source.length()) ||\n+            (source.substring(startIndex, endIndex).compareTo(expected) != 0)) {\n+            // set index back to start, error index should be the start index\n+            pos.setIndex(startIndex);\n+            pos.setErrorIndex(startIndex);\n+            return false;\n+        }\n+\n+        // the string was here\n+        pos.setIndex(endIndex);\n+        return true;\n+\n+    }\n+\n+    /**\n+     * Formats a double value to produce a string.  In general, the value is\n+     * formatted using the formatting rules of <code>format</code>.  There are\n+     * three exceptions to this:\n+     * <ol>\n+     * <li>NaN is formatted as '(NaN)'</li>\n+     * <li>Positive infinity is formatted as '(Infinity)'</li>\n+     * <li>Negative infinity is formatted as '(-Infinity)'</li>\n+     * </ol>\n+     *\n+     * @param value the double to format.\n+     * @param format the format used.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    protected StringBuffer formatDouble(final double value, final NumberFormat format,\n+                                        final StringBuffer toAppendTo,\n+                                        final FieldPosition pos) {\n+        if( Double.isNaN(value) || Double.isInfinite(value) ) {\n+            toAppendTo.append('(');\n+            toAppendTo.append(value);\n+            toAppendTo.append(')');\n+        } else {\n+            format.format(value, toAppendTo, pos);\n+        }\n+        return toAppendTo;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/util/ContinuedFraction.java\n+++ b/src/java/org/apache/commons/math/util/ContinuedFraction.java\n                     // can not scale an convergent is unbounded.\n                     throw new ConvergenceException(\n                         \"Continued fraction convergents diverged to +/- infinity for value {0}\",\n-                        new Object[] { new Double(x) });\n+                        new Object[] { Double.valueOf(x) });\n                 }\n             }\n             double r = p2 / q2;\n         if (n >= maxIterations) {\n             throw new MaxIterationsExceededException(maxIterations,\n                 \"Continued fraction convergents failed to converge for value {0}\",\n-                new Object[] { new Double(x) });\n+                new Object[] { Double.valueOf(x) });\n         }\n \n         return c;\n--- a/src/java/org/apache/commons/math/util/DefaultTransformer.java\n+++ b/src/java/org/apache/commons/math/util/DefaultTransformer.java\n     public double transform(Object o) throws MathException{\n \n         if (o == null) {\n-            throw new MathException(\"Conversion Exception in Transformation, Object is null\", new Object[0]);\n+            throw new MathException(\"Conversion Exception in Transformation, Object is null\", null);\n         }\n \n         if (o instanceof Number) {\n         }\n             \n         try {\n-            return new Double(o.toString()).doubleValue();\n+            return Double.valueOf(o.toString()).doubleValue();\n         } catch (Exception e) {\n             throw new MathException(\"Conversion Exception in Transformation: {0}\",\n                                     new Object[] { e.getMessage() }, e);\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n package org.apache.commons.math.util;\n \n import java.math.BigDecimal;\n+import java.util.Arrays;\n \n /**\n  * Some useful additions to the built-in functions in {@link Math}.\n  * @version $Revision$ $Date$\n  */\n public final class MathUtils {\n+\n+    /** Smallest positive number such that 1 - EPSILON is not numerically equal to 1. */\n+    public static final double EPSILON = 0x1.0p-53;\n+\n+    /** Safe minimum, such that 1 / SAFE_MIN does not overflow.\n+     * <p>In IEEE 754 arithmetic, this is also the smallest normalized\n+     * number 2<sup>-1022</sup>.</p>\n+     */\n+    public static final double SAFE_MIN = 0x1.0p-1022;\n \n     /** -1.0 cast as a byte. */\n     private static final byte  NB = (byte)-1;\n      * @return the hash code\n      */\n     public static int hash(double value) {\n-        long bits = Double.doubleToLongBits(value);\n-        return (int)(bits ^ (bits >>> 32));\n-    }\n-\n-    /**\n-     * Returns an integer hash code representing the given double array value.\n+        return new Double(value).hashCode();\n+    }\n+\n+    /**\n+     * Returns an integer hash code representing the given double array.\n      * \n      * @param value the value to be hashed (may be null)\n      * @return the hash code\n      * @since 1.2\n      */\n     public static int hash(double[] value) {\n-        if (value == null) {\n-            return 0;\n-        }\n-        int result = value.length;\n-        for (int i = 0; i < value.length; ++i) {\n-            result = result * 31 + hash(value[i]);\n-        }\n-        return result;\n+        return Arrays.hashCode(value);\n     }\n \n     /**\n     }\n \n     /**\n+     * Scale a number by 2<sup>scaleFactor</sup>.\n+     * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>\n+     * \n+     * @param d base number\n+     * @param scaleFactor power of two by which d sould be multiplied\n+     * @return d &times; 2<sup>scaleFactor</sup>\n+     * @since 2.0\n+     */\n+    public static double scalb(final double d, final int scaleFactor) {\n+\n+        // handling of some important special cases\n+        if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {\n+            return d;\n+        }\n+\n+        // split the double in raw components\n+        final long bits     = Double.doubleToLongBits(d);\n+        final long exponent = bits & 0x7ff0000000000000L;\n+        final long rest     = bits & 0x800fffffffffffffL;\n+\n+        // shift the exponent\n+        final long newBits = rest | (exponent + (((long) scaleFactor) << 52));\n+        return Double.longBitsToDouble(newBits);\n+\n+    }\n+\n+    /**\n      * Normalize an angle in a 2&pi wide interval around a center value.\n      * <p>This method has three main uses:</p>\n      * <ul>\n--- a/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/util/ResizableDoubleArray.java\n package org.apache.commons.math.util;\n \n import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * <p>\n         setExpansionMode(expansionMode);\n         internalArray = new double[initialCapacity];\n     }\n+    \n+    /**\n+     * Copy constructor.  Creates a new ResizableDoubleArray that is a deep,\n+     * fresh copy of the original. Needs to acquire synchronization lock\n+     * on original.  Original may not be null; otherwise a NullPointerException\n+     * is thrown.\n+     * \n+     * @param original\n+     * @since 2.0\n+     */\n+    public ResizableDoubleArray(ResizableDoubleArray original) {\n+        copy(original, this);\n+    }\n \n     /**\n      * Adds an element to the end of this expandable array.\n         }\n         return discarded;\n     }\n-\n+       \n+    /**\n+     * Substitutes <code>value</code> for the most recently added value.\n+     * Returns the value that has been replaced. If the array is empty (i.e. \n+     * if {@link #numElements} is zero), a MathRuntimeException is thrown.\n+     * \n+     * @param value new value to substitute for the most recently added value\n+     * @return value that has been replaced in the array\n+     * @since 2.0\n+     */\n+    public synchronized double substituteMostRecentElement(double value) {\n+        if (numElements < 1) {\n+            throw MathRuntimeException.createArrayIndexOutOfBoundsException(\n+                    \"cannot substitute an element from an empty array\", null);\n+        }\n+\n+        double discarded = internalArray[startIndex + (numElements - 1)];\n+\n+        internalArray[startIndex + (numElements - 1)] = value;\n+\n+        return discarded;\n+    }\n+\n+    \n     /**\n      * Checks the expansion factor and the contraction criteria and throws an \n      * IllegalArgumentException if the contractionCriteria is less than the \n      * expansionCriteria\n      * \n      * @param expansionFactor factor to be checked\n-     * @param contractionCritera critera to be checked\n+     * @param contractionCritera criteria to be checked\n      * @throws IllegalArgumentException if the contractionCriteria is less than\n      *         the expansionCriteria.\n      */\n      * \n      * @param i  the number of elements to discard from the front of the array\n      * @throws IllegalArgumentException if i is greater than numElements.\n+     * @since 2.0\n      */\n     public synchronized void discardFrontElements(int i) {\n+\n+        discardExtremeElements(i,true);\n+        \n+    }\n+\n+    /**\n+     * Discards the <code>i<code> last elements of the array.  For example,\n+     * if the array contains the elements 1,2,3,4, invoking \n+     * <code>discardMostRecentElements(2)</code> will cause the last two elements \n+     * to be discarded, leaving 1,2 in the array.  Throws illegalArgumentException\n+     * if i exceeds numElements.\n+     * \n+     * @param i  the number of elements to discard from the end of the array\n+     * @throws IllegalArgumentException if i is greater than numElements.\n+     * @since 2.0\n+     */\n+    public synchronized void discardMostRecentElements(int i) {\n+\n+        discardExtremeElements(i,false);\n+        \n+    }\n+    \n+    /**\n+     * Discards the <code>i<code> first or last elements of the array,\n+     * depending on the value of <code>front</code>.\n+     * For example, if the array contains the elements 1,2,3,4, invoking \n+     * <code>discardExtremeElements(2,false)</code> will cause the last two elements \n+     * to be discarded, leaving 1,2 in the array.\n+     * For example, if the array contains the elements 1,2,3,4, invoking \n+     * <code>discardExtremeElements(2,true)</code> will cause the first two elements \n+     * to be discarded, leaving 3,4 in the array.\n+     * Throws illegalArgumentException\n+     * if i exceeds numElements.\n+     * \n+     * @param i  the number of elements to discard from the front/end of the array\n+     * @param front true if elements are to be discarded from the front\n+     * of the array, false if elements are to be discarded from the end\n+     * of the array \n+     * @throws IllegalArgumentException if i is greater than numElements.\n+     * @since 2.0\n+     */\n+    private synchronized void discardExtremeElements(int i,boolean front) {\n         if (i > numElements) {\n             String msg = \"Cannot discard more elements than are\" +\n             \"contained in this array.\";\n         } else {\n             // \"Subtract\" this number of discarded from numElements \n             numElements -= i;\n-            startIndex += i;\n+            if (front) startIndex += i;\n         }\n         if (shouldContract()) {\n             contract();\n      */\n     protected synchronized void expand() {\n \n-        // notice the use of Math.ceil(), this gaurantees that we will always \n+        // notice the use of Math.ceil(), this guarantees that we will always \n         // have an array of at least currentSize + 1.   Assume that the \n         // current initial capacity is 1 and the expansion factor\n         // is 1.000000000000000001.  The newly calculated size will be \n      */\n     public synchronized double getElement(int index) {\n         if (index >= numElements) {\n-            String msg =\n-                \"The index specified: \" + index +\n-                \" is larger than the current number of elements\";\n-            throw new ArrayIndexOutOfBoundsException(msg);\n+            throw MathRuntimeException.createArrayIndexOutOfBoundsException(\"the index specified: {0} is larger than the current maximal index {1}\",\n+                                                                            new Object[] { index, numElements - 1 });\n         } else if (index >= 0) {\n             return internalArray[startIndex + index];\n         } else {\n-            String msg =\n-                \"Elements cannot be retrieved from a negative array index\";\n-            throw new ArrayIndexOutOfBoundsException(msg);\n+            throw MathRuntimeException.createArrayIndexOutOfBoundsException(\"elements cannot be retrieved from a negative array index {0}\",\n+                                                                            new Object[] { index });\n         }\n     }\n     \n     }\n     \n     /**\n-     * The expansion factor controls the size of a new aray when an array \n+     * The expansion factor controls the size of a new array when an array \n      * needs to be expanded.  The <code>expansionMode</code>\n      * determines whether the size of the array is multiplied by the \n      * <code>expansionFactor</code> (MULTIPLICATIVE_MODE) or if \n      */\n     public synchronized void setElement(int index, double value) {\n         if (index < 0) {\n-            String msg = \"Cannot set an element at a negative index\";\n-            throw new ArrayIndexOutOfBoundsException(msg);\n+            throw MathRuntimeException.createArrayIndexOutOfBoundsException(\"cannot set an element at a negative index {0}\",\n+                                                                            new Object[] { index });\n         }\n         if (index + 1 > numElements) {\n             numElements = index + 1;\n         }\n \n         // Test the new num elements, check to see if the array needs to be \n-        // expanded to accomodate this new number of elements\n+        // expanded to accommodate this new number of elements\n         if ((startIndex + i) > internalArray.length) {\n             expandTo(startIndex + i);\n         }\n     public synchronized int start() {\n         return startIndex;\n     }\n-\n+    \n+    /**\n+     * <p>Copies source to dest, copying the underlying data, so dest is\n+     * a new, independent copy of source.  Does not contract before\n+     * the copy.</p>\n+     * \n+     * <p>Obtains synchronization locks on both source and dest\n+     * (in that order) before performing the copy.</p>\n+     * \n+     * <p>Neither source nor dest may be null; otherwise a NullPointerException\n+     * is thrown</p>\n+     * \n+     * @param source ResizableDoubleArray to copy\n+     * @param dest ResizableArray to replace with a copy of the source array\n+     * @since 2.0\n+     * \n+     */\n+    public static void copy(ResizableDoubleArray source, ResizableDoubleArray dest) {\n+       synchronized(source) {\n+           synchronized(dest) {\n+               dest.initialCapacity = source.initialCapacity;\n+               dest.contractionCriteria = source.contractionCriteria;\n+               dest.expansionFactor = source.expansionFactor;\n+               dest.expansionMode = source.expansionMode;\n+               dest.internalArray = new double[source.internalArray.length];\n+               System.arraycopy(source.internalArray, 0, dest.internalArray,\n+                       0, dest.internalArray.length);\n+               dest.numElements = source.numElements;\n+               dest.startIndex = source.startIndex;\n+           }\n+       }\n+    }\n+    \n+    /**\n+     * Returns a copy of the ResizableDoubleArray.  Does not contract before\n+     * the copy, so the returned object is an exact copy of this.\n+     * \n+     * @return a new ResizableDoubleArray with the same data and configuration\n+     * properties as this\n+     * @since 2.0\n+     */\n+    public synchronized ResizableDoubleArray copy() {\n+        ResizableDoubleArray result = new ResizableDoubleArray();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Returns true iff object is a ResizableDoubleArray with the same properties\n+     * as this and an identical internal storage array.\n+     * \n+     * @param object object to be compared for equality with this\n+     * @return true iff object is a ResizableDoubleArray with the same data and\n+     * properties as this\n+     * @since 2.0\n+     */\n+    public boolean equals(Object object) {\n+        if (object == this ) {\n+            return true;\n+        }\n+       if (object instanceof ResizableDoubleArray == false) {\n+            return false;\n+        }\n+       boolean result = true;\n+       ResizableDoubleArray other = (ResizableDoubleArray) object;\n+       result = result && (other.initialCapacity == initialCapacity);\n+       result = result && (other.contractionCriteria == contractionCriteria);\n+       result = result && (other.expansionFactor == expansionFactor);\n+       result = result && (other.expansionMode == expansionMode);\n+       result = result && (other.numElements == numElements);\n+       result = result && (other.startIndex == startIndex);\n+       if (!result) { \n+           return false;\n+       } else {\n+           return Arrays.equals(internalArray, other.internalArray);\n+       }\n+    }\n+    \n+    /**\n+     * Returns a hash code consistent with equals.\n+     * \n+     * @return hash code representing this ResizableDoubleArray\n+     * @since 2.0\n+     */\n+    public int hashCode() {\n+        int[] hashData = new int[7];\n+        hashData[0] = Arrays.hashCode(internalArray);\n+        hashData[1] = new Float(expansionFactor).hashCode();\n+        hashData[2] = new Float(contractionCriteria).hashCode();\n+        hashData[3] = initialCapacity;\n+        hashData[4] = expansionMode;\n+        hashData[5] = numElements;\n+        hashData[6] = startIndex;\n+        return Arrays.hashCode(hashData);\n+    }\n+         \n }\n--- a/src/java/org/apache/commons/math/util/TransformerMap.java\n+++ b/src/java/org/apache/commons/math/util/TransformerMap.java\n public class TransformerMap implements NumberTransformer, Serializable {\n \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = -942772950698439883L;\n-    \n+    private static final long serialVersionUID = 4605318041528645258L;\n+\n     /**\n      * A default Number Transformer for Numbers and numeric Strings.\n      */\n     /**\n      * The internal Map.\n      */\n-    private Map map = null;\n+    private Map<Class<?>, NumberTransformer> map = null;\n \n     /**\n-     * \n+     * Build a map containing only the default transformer.\n      */\n     public TransformerMap() {\n-        map = new HashMap();\n+        map = new HashMap<Class<?>, NumberTransformer>();\n         defaultTransformer = new DefaultTransformer();\n     }\n \n      * @param key Class to check\n      * @return true|false\n      */\n-    public boolean containsClass(Class key) {\n+    public boolean containsClass(Class<?> key) {\n         return map.containsKey(key);\n     }\n \n      * @param key The Class of the object\n      * @return the mapped NumberTransformer or null.\n      */\n-    public NumberTransformer getTransformer(Class key) {\n+    public NumberTransformer getTransformer(Class<?> key) {\n         return (NumberTransformer) map.get(key);\n     }\n \n      * @param transformer The NumberTransformer\n      * @return the replaced transformer if one is present\n      */\n-    public Object putTransformer(Class key, NumberTransformer transformer) {\n+    public NumberTransformer putTransformer(Class<?> key, NumberTransformer transformer) {\n         return map.put(key, transformer);\n     }\n \n      * @return the removed transformer if one is present or\n      * null if none was present.\n      */\n-    public Object removeTransformer(Class key) {\n+    public NumberTransformer removeTransformer(Class<?> key) {\n         return map.remove(key);\n     }\n \n      * Returns the Set of Classes used as keys in the map.\n      * @return Set of Classes\n      */\n-    public Set classes() {\n+    public Set<Class<?>> classes() {\n         return map.keySet();\n     }\n \n      * in the map.\n      * @return Set of NumberTransformers\n      */\n-    public Collection transformers() {\n+    public Collection<NumberTransformer> transformers() {\n         return map.values();\n     }\n \n--- a/src/mantissa/src/org/spaceroots/mantissa/MantissaException.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/MantissaException.java\n  * standard exceptions are thrown rather than the mantissa specific\n  * ones.</p>\n \n- * @version $Id: MantissaException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/MessagesResources.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/MessagesResources.java\n import java.util.ListResourceBundle;\n \n /** This class gather the message resources for the mantissa library.\n- * @version $Id: MessagesResources.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n  */\n \n--- a/src/mantissa/src/org/spaceroots/mantissa/MessagesResources_fr.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/MessagesResources_fr.java\n import java.util.ListResourceBundle;\n \n /** This class gather the message resources for the mantissa library.\n- * @version $Id: MessagesResources_fr.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n  */\n public class MessagesResources_fr\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/Chebyshev.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Chebyshev.java\n  *  T<sub>k+1</sub>(X) = 2X T<sub>k</sub>(X) - T<sub>k-1</sub>(X)\n  * </pre></p>\n \n- * @version $Id: Chebyshev.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/Hermite.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Hermite.java\n  *  H<sub>k+1</sub>(X) = 2X H<sub>k</sub>(X) - 2k H<sub>k-1</sub>(X)\n  * </pre></p>\n \n- * @version $Id: Hermite.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/Laguerre.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Laguerre.java\n  *  (k+1) L<sub>k+1</sub>(X) = (2k + 1 - X) L<sub>k</sub>(X) - k L<sub>k-1</sub>(X)\n  * </pre></p>\n \n- * @version $Id: Laguerre.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/Legendre.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Legendre.java\n  *  (k+1) P<sub>k+1</sub>(X) = (2k+1) X P<sub>k</sub>(X) - k P<sub>k-1</sub>(X)\n  * </pre></p>\n \n- * @version $Id: Legendre.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/OrthogonalPolynomial.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/OrthogonalPolynomial.java\n  * a<sub>4,k</sub> are simple expressions which either are\n  * constants or depend on k.</p>\n \n- * @version $Id: OrthogonalPolynomial.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/Polynomial.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/Polynomial.java\n \n  * <p>Instances of this class are immutable.</p>\n \n- * @version $Id: Polynomial.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n */\n       System.arraycopy((a.length < p.a.length) ? p.a : a,\n                        lowLength, newA, lowLength, highLength - lowLength);\n \n-      return new Double(newA);\n+      return Double.valueOf(newA);\n \n     }\n \n         System.arraycopy(a, lowLength, newA, lowLength, highLength - lowLength);\n       }\n \n-      return new Double(newA);\n+      return Double.valueOf(newA);\n \n     }\n \n       for (int i = 0; i < a.length; ++i) {\n         newA[i] = -a[i];\n       }\n-      return new Double(newA);\n+      return Double.valueOf(newA);\n     }\n \n     /** Multiply the instance by a polynomial.\n         }\n       }\n \n-      return new Double(newA);\n+      return Double.valueOf(newA);\n \n     }\n \n     public Polynomial multiply(double r) {\n \n       if (r == 0) {\n-        return new Double(new double[] { 0.0 });\n+        return Double.valueOf(new double[] { 0.0 });\n       }\n \n       double[] newA = new double[a.length];\n       for (int i = 0; i < a.length; ++i) {\n         newA[i] = a[i] * r;\n       }\n-      return new Double(newA);\n+      return Double.valueOf(newA);\n \n     }\n \n      */\n     public Polynomial getDerivative() {\n       if (a.length == 1) {\n-        return new Double();\n+        return Double.valueOf();\n       }\n       double[] newA = new double[a.length - 1];\n       for (int i = 1; i < a.length; ++i) {\n         newA[i - 1] = a[i] * i;\n       }\n-      return new Double(newA);\n+      return Double.valueOf(newA);\n     }\n \n     /** Returns a string representation of the polynomial.\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/PolynomialFraction.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/PolynomialFraction.java\n  * rational coefficients.\n  * <p>Instances of this class are immutable.</p>\n \n- * @version $Id: PolynomialFraction.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/algebra/RationalNumber.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/RationalNumber.java\n  * This class implements reduced rational numbers.\n  * <p>Instances of this class are immutable.</p>\n \n- * @version $Id: RationalNumber.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/fitting/AbstractCurveFitter.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/AbstractCurveFitter.java\n  * sub-classes to define the precise shape of the curve they\n  * represent.</p>\n \n- * @version $Id: AbstractCurveFitter.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/fitting/F2FP2Iterator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/F2FP2Iterator.java\n  * @see FFPIterator\n  * @see HarmonicCoefficientsGuesser\n \n- * @version $Id: F2FP2Iterator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/fitting/FFPIterator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/FFPIterator.java\n  * @see F2FP2Iterator\n  * @see HarmonicCoefficientsGuesser\n \n- * @version $Id: FFPIterator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/fitting/HarmonicCoefficientsGuesser.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/HarmonicCoefficientsGuesser.java\n  * estimations, these operations run in O(n) time, where n is the\n  * number of measurements.</p>\n \n- * @version $Id: HarmonicCoefficientsGuesser.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/fitting/HarmonicFitter.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/HarmonicFitter.java\n  * <p>This class <emph>is by no means optimized</emph>, neither versus\n  * space nor versus time performance.</p>\n \n- * @version $Id: HarmonicFitter.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n                         Estimator estimator) {\n     super(coefficients, estimator);\n     firstGuessNeeded = false;\n-  }\n-\n-  /**\n-   * Simple constructor.\n-   * @param maxIterations maximum number of iterations allowed\n-   * @param convergence criterion threshold below which we do not need\n-   * to improve the criterion anymore\n-   * @param steadyStateThreshold steady state detection threshold, the\n-   * problem has reached a steady state (read converged) if\n-   * <code>Math.abs (Jn - Jn-1) < Jn * convergence</code>, where\n-   * <code>Jn</code> and <code>Jn-1</code> are the current and\n-   * preceding criterion value (square sum of the weighted residuals\n-   * of considered measurements).\n-   * @param epsilon threshold under which the matrix of the linearized\n-   * problem is considered singular (see {@link\n-   * org.spaceroots.mantissa.linalg.SquareMatrix#solve(\n-   * org.spaceroots.mantissa.linalg.Matrix,double) SquareMatrix.solve}).\n-   * @deprecated replaced by {@link #HarmonicFitter(Estimator)}\n-   * as of version 7.0\n-   */\n-  public HarmonicFitter(int maxIterations, double convergence,\n-                        double steadyStateThreshold, double epsilon) {\n-    this(new GaussNewtonEstimator(maxIterations, convergence,\n-                                   steadyStateThreshold, epsilon));\n-  }\n-\n-  /**\n-   * Simple constructor.\n-\n-   * <p>This constructor can be used when a first estimate of the\n-   * coefficients is already known.</p>\n-\n-   * @param coefficients first estimate of the coefficients.\n-   * A reference to this array is hold by the newly created\n-   * object. Its elements will be adjusted during the fitting process\n-   * and they will be set to the adjusted coefficients at the end.\n-   * @param maxIterations maximum number of iterations allowed\n-   * @param convergence criterion threshold below which we do not need\n-   * to improve the criterion anymore\n-   * @param steadyStateThreshold steady state detection threshold, the\n-   * problem has reached a steady state (read converged) if\n-   * <code>Math.abs (Jn - Jn-1) < Jn * convergence</code>, where\n-   * <code>Jn</code> and <code>Jn-1</code> are the current and\n-   * preceding criterion value (square sum of the weighted residuals\n-   * of considered measurements).\n-   * @param epsilon threshold under which the matrix of the linearized\n-   * problem is considered singular (see {@link\n-   * org.spaceroots.mantissa.linalg.SquareMatrix#solve(\n-   * org.spaceroots.mantissa.linalg.Matrix,double) SquareMatrix.solve}).\n-\n-   * @deprecated replaced by {@link #HarmonicFitter(EstimatedParameter[],\n-   * Estimator)} as of version 7.0\n-   */\n-  public HarmonicFitter(EstimatedParameter[] coefficients,\n-                        int maxIterations, double convergence,\n-                        double steadyStateThreshold, double epsilon) {\n-    this(coefficients,\n-          new GaussNewtonEstimator(maxIterations, convergence,\n-                                   steadyStateThreshold, epsilon));\n   }\n \n   public double[] fit()\n--- a/src/mantissa/src/org/spaceroots/mantissa/fitting/PolynomialCoefficient.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/PolynomialCoefficient.java\n \n  * @see PolynomialFitter\n \n- * @version $Id: PolynomialCoefficient.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/fitting/PolynomialFitter.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/fitting/PolynomialFitter.java\n \n  * @see PolynomialCoefficient\n \n- * @version $Id: PolynomialFitter.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n     super(coefficients, estimator);\n   }\n \n-  /** Simple constructor.\n-\n-   * <p>The polynomial fitter built this way are complete polynoms,\n-   * ie. a n-degree polynom has n+1 coefficients. In order to build\n-   * fitter for sparse polynoms (for example <code>a x^20 - b\n-   * x^30</code>, on should first build the coefficients array and\n-   * provide it to {@link\n-   * #PolynomialFitter(PolynomialCoefficient[], int, double, double,\n-   * double)}.</p>\n-   * @param degree maximal degree of the polynom\n-   * @param maxIterations maximum number of iterations allowed\n-   * @param convergence criterion threshold below which we do not need\n-   * to improve the criterion anymore\n-   * @param steadyStateThreshold steady state detection threshold, the\n-   * problem has reached a steady state (read converged) if\n-   * <code>Math.abs (Jn - Jn-1) < Jn * convergence</code>, where\n-   * <code>Jn</code> and <code>Jn-1</code> are the current and\n-   * preceding criterion value (square sum of the weighted residuals\n-   * of considered measurements).\n-   * @param epsilon threshold under which the matrix of the linearized\n-   * problem is considered singular (see {@link\n-   * org.spaceroots.mantissa.linalg.SquareMatrix#solve(\n-   * org.spaceroots.mantissa.linalg.Matrix,double) SquareMatrix.solve}).\n- \n-   * @deprecated replaced by {@link #PolynomialFitter(int,Estimator)}\n-   * as of version 7.0\n-   */\n-  public PolynomialFitter(int degree,\n-                          int maxIterations, double convergence,\n-                          double steadyStateThreshold, double epsilon) {\n-    this(degree,\n-         new GaussNewtonEstimator(maxIterations, steadyStateThreshold,\n-                                  convergence, epsilon));\n-  }\n-\n-  /** Simple constructor.\n-\n-   * <p>This constructor can be used either when a first estimate of\n-   * the coefficients is already known (which is of little interest\n-   * because the fit cost is the same whether a first guess is known or\n-   * not) or when one needs to handle sparse polynoms like <code>a\n-   * x^20 - b x^30</code>.</p>\n-\n-   * @param coefficients first estimate of the coefficients.\n-   * A reference to this array is hold by the newly created\n-   * object. Its elements will be adjusted during the fitting process\n-   * and they will be set to the adjusted coefficients at the end.\n-   * @param maxIterations maximum number of iterations allowed\n-   * @param convergence criterion threshold below which we do not need\n-   * to improve the criterion anymore\n-   * @param steadyStateThreshold steady state detection threshold, the\n-   * problem has reached a steady state (read converged) if\n-   * <code>Math.abs (Jn - Jn-1) < Jn * convergence</code>, where\n-   * <code>Jn</code> and <code>Jn-1</code> are the current and\n-   * preceding criterion value (square sum of the weighted residuals\n-   * of considered measurements).\n-   * @param epsilon threshold under which the matrix of the linearized\n-   * problem is considered singular (see {@link\n-   * org.spaceroots.mantissa.linalg.SquareMatrix#solve(\n-   * org.spaceroots.mantissa.linalg.Matrix,double) SquareMatrix.solve}).\n-\n-   * @deprecated replaced by {@link #PolynomialFitter(PolynomialCoefficient[],\n-   * Estimator)} as of version 7.0\n-   */\n-  public PolynomialFitter(PolynomialCoefficient[] coefficients,\n-                          int maxIterations, double convergence,\n-                          double steadyStateThreshold, double epsilon) {\n-    this(coefficients,\n-         new GaussNewtonEstimator(maxIterations, steadyStateThreshold,\n-                                  convergence, epsilon));\n-  }\n-\n   /** Get the value of the function at x according to the current parameters value.\n    * @param x abscissa at which the theoretical value is requested\n    * @return theoretical value at x\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/ExhaustedSampleException.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/ExhaustedSampleException.java\n \n /** This class represents exceptions thrown by sample iterators.\n \n- * @version $Id: ExhaustedSampleException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/FunctionException.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/FunctionException.java\n \n /** This class represents exceptions thrown by scalar functions.\n \n- * @version $Id: FunctionException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/BasicSampledFunctionIterator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/BasicSampledFunctionIterator.java\n \n  * @see SampledFunction\n \n- * @version $Id: BasicSampledFunctionIterator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/ComputableFunction.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/ComputableFunction.java\n  * @see org.spaceroots.mantissa.quadrature.scalar.ComputableFunctionIntegrator\n  * @see SampledFunction\n \n- * @version $Id: ComputableFunction.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/ComputableFunctionSampler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/ComputableFunctionSampler.java\n \n  * @see ComputableFunction\n \n- * @version $Id: ComputableFunctionSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/SampledFunction.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/SampledFunction.java\n  * @see ComputableFunctionSampler\n  * @see ComputableFunction\n \n- * @version $Id: SampledFunction.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/SampledFunctionIterator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/SampledFunctionIterator.java\n \n  * @see SampledFunction\n \n- * @version $Id: SampledFunctionIterator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/ScalarValuedPair.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/scalar/ScalarValuedPair.java\n  * @see SampledFunction\n  * @see org.spaceroots.mantissa.functions.vectorial.VectorialValuedPair\n \n- * @version $Id: ScalarValuedPair.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/BasicSampledFunctionIterator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/BasicSampledFunctionIterator.java\n \n  * @see SampledFunction\n \n- * @version $Id: BasicSampledFunctionIterator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/ComputableFunction.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/ComputableFunction.java\n  * @see org.spaceroots.mantissa.quadrature.vectorial.ComputableFunctionIntegrator\n  * @see SampledFunction\n \n- * @version $Id: ComputableFunction.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/ComputableFunctionSampler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/ComputableFunctionSampler.java\n \n  * @see ComputableFunction\n \n- * @version $Id: ComputableFunctionSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/SampledFunction.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/SampledFunction.java\n  * @see ComputableFunctionSampler\n  * @see ComputableFunction\n \n- * @version $Id: SampledFunction.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/SampledFunctionIterator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/SampledFunctionIterator.java\n \n  * @see SampledFunction\n \n- * @version $Id: SampledFunctionIterator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/VectorialValuedPair.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/functions/vectorial/VectorialValuedPair.java\n  * @see SampledFunction\n  * @see org.spaceroots.mantissa.functions.vectorial.VectorialValuedPair\n \n- * @version $Id: VectorialValuedPair.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/DiagonalMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/DiagonalMatrix.java\n \n /** This class implements diagonal matrices of linear algebra.\n \n- * @version $Id: DiagonalMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/GeneralMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/GeneralMatrix.java\n  * <p>This class is the basic implementation of matrices to use when\n  * nothing special is known about the structure of the matrix.</p>\n \n- * @version $Id: GeneralMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/GeneralSquareMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/GeneralSquareMatrix.java\n \n /** This class implements general square matrices of linear algebra.\n \n- * @version $Id: GeneralSquareMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/LowerTriangularMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/LowerTriangularMatrix.java\n \n /** This class implements lower triangular matrices of linear algebra.\n \n- * @version $Id: LowerTriangularMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/Matrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/Matrix.java\n  * specific shape to the general algorithms implemented by this\n  * abstract class.</p>\n \n- * @version $Id: Matrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/MatrixFactory.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/MatrixFactory.java\n  * <p>This is a utility class, no instance of this class should be\n  * built, so the constructor is explicitly made private.</p>\n \n- * @version $Id: MatrixFactory.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/NonNullRange.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/NonNullRange.java\n  * coincidence. Therefore, the range (in row/columns count)\n  * corresponding to third row will span from 0 to 2, not from 1 to 2.</p>\n \n- * @version $Id: NonNullRange.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/SingularMatrixException.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/SingularMatrixException.java\n \n /** This class represent exceptions thrown by some matrix operations.\n \n- * @version $Id: SingularMatrixException.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/SquareMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/SquareMatrix.java\n  * implementations. It extends the {@link Matrix} class with methods\n  * specific to square matrices.</p>\n \n- * @version $Id: SquareMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/SymetricalMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/SymetricalMatrix.java\n \n /** This class implements symetrical matrices of linear algebra.\n \n- * @version $Id: SymetricalMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/linalg/UpperTriangularMatrix.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/linalg/UpperTriangularMatrix.java\n \n /** This class implements upper triangular matrices of linear algebra.\n \n- * @version $Id: UpperTriangularMatrix.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/ComputableFunctionIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/ComputableFunctionIntegrator.java\n \n  * @see org.spaceroots.mantissa.functions.scalar.ComputableFunction\n \n- * @version $Id: ComputableFunctionIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/EnhancedSimpsonIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/EnhancedSimpsonIntegrator.java\n  * points. If it is used on a regular sample, it behaves exactly as a\n  * traditional Simpson integrator.</p>\n \n- * @version $Id: EnhancedSimpsonIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/EnhancedSimpsonIntegratorSampler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/EnhancedSimpsonIntegratorSampler.java\n \n  * @see EnhancedSimpsonIntegrator\n \n- * @version $Id: EnhancedSimpsonIntegratorSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/GaussLegendreIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/GaussLegendreIntegrator.java\n  * boundary points, which means it can be undefined at these\n  * points.</p>\n \n- * @version $Id: GaussLegendreIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/RiemannIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/RiemannIntegrator.java\n \n  * @see TrapezoidIntegrator\n \n- * @version $Id: RiemannIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/RiemannIntegratorSampler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/RiemannIntegratorSampler.java\n \n  * @see RiemannIntegrator\n \n- * @version $Id: RiemannIntegratorSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/SampledFunctionIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/SampledFunctionIntegrator.java\n  * @see org.spaceroots.mantissa.functions.scalar.SampledFunctionIterator\n  * @see ComputableFunctionIntegrator\n \n- * @version $Id: SampledFunctionIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/TrapezoidIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/TrapezoidIntegrator.java\n  * <p>A trapezoid integrator is a very simple one that assumes the\n  * function is linear over the integration step.</p>\n \n- * @version $Id: TrapezoidIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/TrapezoidIntegratorSampler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/scalar/TrapezoidIntegratorSampler.java\n \n  * @see TrapezoidIntegrator\n \n- * @version $Id: TrapezoidIntegratorSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/ComputableFunctionIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/ComputableFunctionIntegrator.java\n \n  * @see org.spaceroots.mantissa.functions.vectorial.ComputableFunction\n \n- * @version $Id: ComputableFunctionIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/EnhancedSimpsonIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/EnhancedSimpsonIntegrator.java\n  * points. If it is used on a regular sample, it behaves exactly as a\n  * traditional Simpson integrator.</p>\n \n- * @version $Id: EnhancedSimpsonIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/EnhancedSimpsonIntegratorSampler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/EnhancedSimpsonIntegratorSampler.java\n \n  * @see EnhancedSimpsonIntegrator\n \n- * @version $Id: EnhancedSimpsonIntegratorSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/GaussLegendreIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/GaussLegendreIntegrator.java\n  * boundary points, which means it can be undefined at these\n  * points.</p>\n \n- * @version $Id: GaussLegendreIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/RiemannIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/RiemannIntegrator.java\n \n  * @see TrapezoidIntegrator\n \n- * @version $Id: RiemannIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/RiemannIntegratorSampler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/RiemannIntegratorSampler.java\n \n  * @see RiemannIntegrator\n \n- * @version $Id: RiemannIntegratorSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/SampledFunctionIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/SampledFunctionIntegrator.java\n  * @see org.spaceroots.mantissa.functions.vectorial.SampledFunctionIterator\n  * @see ComputableFunctionIntegrator\n \n- * @version $Id: SampledFunctionIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/TrapezoidIntegrator.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/TrapezoidIntegrator.java\n  * <p>A trapezoid integrator is a very simple one that assumes the\n  * function is linear over the integration step.</p>\n \n- * @version $Id: TrapezoidIntegrator.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/TrapezoidIntegratorSampler.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/quadrature/vectorial/TrapezoidIntegratorSampler.java\n \n  * @see TrapezoidIntegrator\n \n- * @version $Id: TrapezoidIntegratorSampler.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/random/ScalarSampleStatistics.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/random/ScalarSampleStatistics.java\n package org.spaceroots.mantissa.random;\n \n /** This class compute basic statistics on a scalar sample.\n- * @version $Id: ScalarSampleStatistics.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n  */\n public class ScalarSampleStatistics {\n--- a/src/mantissa/src/org/spaceroots/mantissa/random/VectorialSampleStatistics.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/random/VectorialSampleStatistics.java\n import org.spaceroots.mantissa.linalg.SymetricalMatrix;\n \n /** This class compute basic statistics on a scalar sample.\n- * @version $Id: VectorialSampleStatistics.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n  */\n public class VectorialSampleStatistics {\n--- a/src/mantissa/src/org/spaceroots/mantissa/roots/BrentSolver.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/roots/BrentSolver.java\n  * implementation found at netlib (<a\n  * href=\"http://www.netlib.org/fmm/zeroin.f\">zeroin.f</a>).\n \n- * @version $Id: BrentSolver.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/roots/ConvergenceChecker.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/roots/ConvergenceChecker.java\n  * to allow the root-finding algorithm to stop its search according to\n  * the problem at hand.\n \n- * @version $Id: ConvergenceChecker.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/roots/RootsFinder.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/roots/RootsFinder.java\n /** This interface specifies root-finding methods for scalar\n  * functions.\n \n- * @version $Id: RootsFinder.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/utilities/ArrayMapper.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/ArrayMapper.java\n \n  * @see ArraySliceMappable\n \n- * @version $Id: ArrayMapper.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/utilities/ArrayMapperEntry.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/ArrayMapperEntry.java\n  * This class is a simple container for an offset and an\n  * {@link ArraySliceMappable} object.\n \n- * @version $Id: ArrayMapperEntry.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/utilities/ArraySliceMappable.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/ArraySliceMappable.java\n \n  * @see ArrayMapper\n  *\n- * @version $Id: ArraySliceMappable.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n  *\n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/utilities/Interval.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/Interval.java\n \n  * @see IntervalsList\n  * @author Luc Maisonobe\n- * @version $Id: Interval.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  */\n public class Interval {\n \n--- a/src/mantissa/src/org/spaceroots/mantissa/utilities/IntervalsList.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/IntervalsList.java\n  * intersection.</p>\n  * @see Interval\n  * @author Luc Maisonobe\n- * @version $Id: IntervalsList.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  */\n public class IntervalsList {\n \n--- a/src/mantissa/src/org/spaceroots/mantissa/utilities/MappableArray.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/MappableArray.java\n  * Wrapper class around an array in order to have it implement the\n  * {@link ArraySliceMappable} interface.\n \n- * @version $Id: MappableArray.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/mantissa/src/org/spaceroots/mantissa/utilities/MappableScalar.java\n+++ b/src/mantissa/src/org/spaceroots/mantissa/utilities/MappableScalar.java\n  * Wrapper class around a scalar in order to have it implement the\n  * {@link ArraySliceMappable} interface.\n \n- * @version $Id: MappableScalar.java 1705 2006-09-17 19:57:39Z luc $\n+ * @version $Id$\n  * @author L. Maisonobe\n \n  */\n--- a/src/test/org/apache/commons/math/ArgumentOutsideDomainExceptionTest.java\n+++ b/src/test/org/apache/commons/math/ArgumentOutsideDomainExceptionTest.java\n import junit.framework.TestCase;\n \n /**\n- * @version $Revision:$\n+ * @version $Revision$ $Date$\n  */\n public class ArgumentOutsideDomainExceptionTest extends TestCase {\n     \n--- a/src/test/org/apache/commons/math/ConvergenceExceptionTest.java\n+++ b/src/test/org/apache/commons/math/ConvergenceExceptionTest.java\n import java.util.Locale;\n \n /**\n- * @version $Revision: 480442 $ $Date: 2006-11-29 08:21:22 +0100 (mer., 29 nov. 2006) $\n+ * @version $Revision$ $Date$\n  */\n public class ConvergenceExceptionTest extends TestCase {\n \n     \n     public void testConstructorPatternArguments(){\n         String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n-        Object[] arguments = { new Integer(6), new Integer(4) };\n+        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         ConvergenceException ex = new ConvergenceException(pattern, arguments);\n         assertNull(ex.getCause());\n         assertEquals(pattern, ex.getPattern());\n \n     public void testConstructorPatternArgumentsCause(){\n         String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n-        Object[] arguments = { new Integer(6), new Integer(4) };\n+        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         ConvergenceException ex = new ConvergenceException(pattern, arguments, cause);\n--- a/src/test/org/apache/commons/math/DuplicateSampleAbscissaExceptionTest.java\n+++ b/src/test/org/apache/commons/math/DuplicateSampleAbscissaExceptionTest.java\n import junit.framework.TestCase;\n \n /**\n- * @version $Revision:$\n+ * @version $Revision$ $Date$\n  */\n public class DuplicateSampleAbscissaExceptionTest extends TestCase {\n     \n--- a/src/test/org/apache/commons/math/FunctionEvaluationExceptionTest.java\n+++ b/src/test/org/apache/commons/math/FunctionEvaluationExceptionTest.java\n     \n     public void testConstructorPatternArguments(){\n         String pattern = \"Evaluation failed for argument = {0}\";\n-        Object[] arguments = { new Double(0.0) };\n+        Object[] arguments = { Double.valueOf(0.0) };\n         FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments);\n         assertNull(ex.getCause());\n         assertEquals(pattern, ex.getPattern());\n \n     public void testConstructorPatternArgumentsCause(){\n         String pattern = \"Evaluation failed for argument = {0}\";\n-        Object[] arguments = { new Double(0.0) };\n+        Object[] arguments = { Double.valueOf(0.0) };\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         FunctionEvaluationException ex = new FunctionEvaluationException(0.0, pattern, arguments, cause);\n--- a/src/test/org/apache/commons/math/MathConfigurationExceptionTest.java\n+++ b/src/test/org/apache/commons/math/MathConfigurationExceptionTest.java\n         MathConfigurationException ex = new MathConfigurationException();\n         assertNull(ex.getCause());\n         assertNull(ex.getMessage());\n-        assertNull(ex.getMessage(Locale.FRENCH));\n+        assertEquals(0, ex.getMessage(Locale.FRENCH).length());\n     }\n     \n     public void testConstructorPatternArguments(){\n         String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n-        Object[] arguments = { new Integer(6), new Integer(4) };\n+        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         MathConfigurationException ex = new MathConfigurationException(pattern, arguments);\n         assertNull(ex.getCause());\n         assertEquals(pattern, ex.getPattern());\n \n     public void testConstructorPatternArgumentsCause(){\n         String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n-        Object[] arguments = { new Integer(6), new Integer(4) };\n+        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         MathConfigurationException ex = new MathConfigurationException(pattern, arguments, cause);\n--- a/src/test/org/apache/commons/math/MathExceptionTest.java\n+++ b/src/test/org/apache/commons/math/MathExceptionTest.java\n         MathException ex = new MathException();\n         assertNull(ex.getCause());\n         assertNull(ex.getMessage());\n-        assertNull(ex.getMessage(Locale.FRENCH));\n+        assertEquals(0, ex.getMessage(Locale.FRENCH).length());\n     }\n     \n     public void testConstructorPatternArguments(){\n         String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n-        Object[] arguments = { new Integer(6), new Integer(4) };\n+        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         MathException ex = new MathException(pattern, arguments);\n         assertNull(ex.getCause());\n         assertEquals(pattern, ex.getPattern());\n \n     public void testConstructorPatternArgumentsCause(){\n         String pattern = \"a {0}x{1} matrix cannot be a rotation matrix\";\n-        Object[] arguments = { new Integer(6), new Integer(4) };\n+        Object[] arguments = { Integer.valueOf(6), Integer.valueOf(4) };\n         String inMsg = \"inner message\";\n         Exception cause = new Exception(inMsg);\n         MathException ex = new MathException(pattern, arguments, cause);\n     public void testPrintStackTrace() {\n         String outMsg = \"outer message\";\n         String inMsg = \"inner message\";\n-        MathException cause = new MathConfigurationException(inMsg, new Object[0]);\n-        MathException ex = new MathException(outMsg, new Object[0], cause);\n+        MathException cause = new MathConfigurationException(inMsg, null);\n+        MathException ex = new MathException(outMsg, null, cause);\n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n         PrintStream ps = new PrintStream(baos);\n         ex.printStackTrace(ps);\n     public void testSerialization() {\n         String outMsg = \"outer message\";\n         String inMsg = \"inner message\";\n-        MathException cause = new MathConfigurationException(inMsg, new Object[0]);\n-        MathException ex = new MathException(outMsg, new Object[0], cause);\n+        MathException cause = new MathConfigurationException(inMsg, null);\n+        MathException ex = new MathException(outMsg, null, cause);\n         MathException image = (MathException) TestUtils.serializeAndRecover(ex);\n         \n         ByteArrayOutputStream baos = new ByteArrayOutputStream();\n--- a/src/test/org/apache/commons/math/MaxIterationsExceededExceptionTest.java\n+++ b/src/test/org/apache/commons/math/MaxIterationsExceededExceptionTest.java\n import junit.framework.TestCase;\n \n /**\n- * @version $Revision:$\n+ * @version $Revision$ $Date$\n  */\n public class MaxIterationsExceededExceptionTest extends TestCase {\n     \n         MaxIterationsExceededException ex =\n             new MaxIterationsExceededException(1000000,\n                 \"Continued fraction convergents failed to converge for value {0}\",\n-                new Object[] { new Double(1234567) });\n+                new Object[] { Double.valueOf(1234567) });\n         assertNull(ex.getCause());\n         assertNotNull(ex.getMessage());\n         assertTrue(ex.getMessage().indexOf(\"1,000,000\") < 0);\n--- a/src/test/org/apache/commons/math/analysis/BrentSolverTest.java\n+++ b/src/test/org/apache/commons/math/analysis/BrentSolverTest.java\n  * default absolute accuracy of 10E-8 for sinus and the quintic function around\n  * zero, and 5..10 iterations for the other zeros.\n  * \n- * @version $Revision$ $Date$ \n+ * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $ \n  */\n public final class BrentSolverTest extends TestCase {\n \n--- a/src/test/org/apache/commons/math/analysis/MonitoredFunction.java\n+++ b/src/test/org/apache/commons/math/analysis/MonitoredFunction.java\n /**\n  * Wrapper class for counting functions calls.\n  *\n- * @version $Revision: 480442 $ $Date: 2006-11-29 08:21:22 +0100 (mer., 29 nov. 2006) $ \n+ * @version $Revision$ $Date$ \n  */\n public class MonitoredFunction implements UnivariateRealFunction {\n \n--- a/src/test/org/apache/commons/math/complex/ComplexFormatAbstractTest.java\n+++ b/src/test/org/apache/commons/math/complex/ComplexFormatAbstractTest.java\n import java.text.ParsePosition;\n import java.util.Locale;\n \n+import org.apache.commons.math.util.CompositeFormat;\n+\n import junit.framework.TestCase;\n \n public abstract class ComplexFormatAbstractTest extends TestCase {\n  \n-    ComplexFormat complexFormat = null;\n+    CompositeFormat complexFormat = null;\n     ComplexFormat complexFormatJ = null;\n \n     protected abstract Locale getLocale();\n     }\n     \n     public void testFormatNumber() {\n-        ComplexFormat cf = ComplexFormat.getInstance(getLocale());\n-        Double pi = new Double(Math.PI);\n+        CompositeFormat cf = ComplexFormat.getInstance(getLocale());\n+        Double pi = Double.valueOf(Math.PI);\n         String text = cf.format(pi);\n         assertEquals(\"3\" + getDecimalCharacter() + \"14\", text);\n     }\n     \n     public void testFormatObject() {\n         try {\n-            ComplexFormat cf = new ComplexFormat();\n+            CompositeFormat cf = new ComplexFormat();\n             Object object = new Object();\n             cf.format(object);\n             fail();\n--- a/src/test/org/apache/commons/math/complex/ComplexTest.java\n+++ b/src/test/org/apache/commons/math/complex/ComplexTest.java\n         assertTrue(z.isNaN());\n         z = new Complex(1, nan);\n         Complex w = x.add(z);\n-        assertEquals(w.real, 4.0, 0);\n-        assertTrue(Double.isNaN(w.imaginary));\n+        assertEquals(w.getReal(), 4.0, 0);\n+        assertTrue(Double.isNaN(w.getImaginary()));\n     }\n     \n     public void testAddInfinite() {\n         Complex x = new Complex(1, 1);\n         Complex z = new Complex(inf, 0);\n         Complex w = x.add(z);\n-        assertEquals(w.imaginary, 1, 0);\n-        assertEquals(inf, w.real, 0);\n+        assertEquals(w.getImaginary(), 1, 0);\n+        assertEquals(inf, w.getReal(), 0);\n         \n         x = new Complex(neginf, 0);\n-        assertTrue(Double.isNaN(x.add(z).real));\n+        assertTrue(Double.isNaN(x.add(z).getReal()));\n     }\n     \n     public void testConjugate() {\n     \n     public void testConjugateInfiinite() {\n         Complex z = new Complex(0, inf);\n-        assertEquals(neginf, z.conjugate().imaginary, 0);\n+        assertEquals(neginf, z.conjugate().getImaginary(), 0);\n         z = new Complex(0, neginf);\n-        assertEquals(inf, z.conjugate().imaginary, 0);\n+        assertEquals(inf, z.conjugate().getImaginary(), 0);\n     }\n     \n     public void testDivide() {\n         assertTrue(x.divide(w).equals(Complex.ZERO));\n         \n         Complex z = w.divide(x);\n-        assertTrue(Double.isNaN(z.real));\n-        assertEquals(inf, z.imaginary, 0);\n+        assertTrue(Double.isNaN(z.getReal()));\n+        assertEquals(inf, z.getImaginary(), 0);\n         \n         w = new Complex(inf, inf);\n         z = w.divide(x);\n-        assertTrue(Double.isNaN(z.imaginary));\n-        assertEquals(inf, z.real, 0);\n+        assertTrue(Double.isNaN(z.getImaginary()));\n+        assertEquals(inf, z.getReal(), 0);\n         \n         w = new Complex(1, inf);\n         z = w.divide(w);\n-        assertTrue(Double.isNaN(z.real));\n-        assertTrue(Double.isNaN(z.imaginary));\n+        assertTrue(Double.isNaN(z.getReal()));\n+        assertTrue(Double.isNaN(z.getImaginary()));\n     }\n     \n     public void testDivideNaN() {\n     \n     public void testDivideNaNInf() {  \n        Complex z = oneInf.divide(Complex.ONE);\n-       assertTrue(Double.isNaN(z.real));\n-       assertEquals(inf, z.imaginary, 0);\n+       assertTrue(Double.isNaN(z.getReal()));\n+       assertEquals(inf, z.getImaginary(), 0);\n        \n        z = negInfNegInf.divide(oneNaN);\n-       assertTrue(Double.isNaN(z.real));\n-       assertTrue(Double.isNaN(z.imaginary));\n+       assertTrue(Double.isNaN(z.getReal()));\n+       assertTrue(Double.isNaN(z.getImaginary()));\n        \n        z = negInfInf.divide(Complex.ONE);\n-       assertTrue(Double.isNaN(z.real));\n-       assertTrue(Double.isNaN(z.imaginary));\n+       assertTrue(Double.isNaN(z.getReal()));\n+       assertTrue(Double.isNaN(z.getImaginary()));\n     }\n     \n     public void testMultiply() {\n     public void testMultiplyNaNInf() {\n         Complex z = new Complex(1,1);\n         Complex w = z.multiply(infOne);\n-        assertEquals(w.real, inf, 0);\n-        assertEquals(w.imaginary, inf, 0);\n+        assertEquals(w.getReal(), inf, 0);\n+        assertEquals(w.getImaginary(), inf, 0);\n \n         // [MATH-164]\n         assertTrue(new Complex( 1,0).multiply(infInf).equals(Complex.INF));\n         assertTrue(new Complex( 1,0).multiply(negInfZero).equals(Complex.INF));\n         \n         w = oneInf.multiply(oneNegInf);\n-        assertEquals(w.real, inf, 0);\n-        assertEquals(w.imaginary, inf, 0);\n+        assertEquals(w.getReal(), inf, 0);\n+        assertEquals(w.getImaginary(), inf, 0);\n         \n         w = negInfNegInf.multiply(oneNaN);\n-        assertTrue(Double.isNaN(w.real));\n-        assertTrue(Double.isNaN(w.imaginary));  \n+        assertTrue(Double.isNaN(w.getReal()));\n+        assertTrue(Double.isNaN(w.getImaginary()));  \n     }\n     \n     public void testNegate() {\n     public void testTanhCritical() {\n         TestUtils.assertSame(nanInf, new Complex(0, pi/2).tanh());\n     }\n+\n+    /** test issue MATH-221 */\n+    public void testMath221() {\n+        assertEquals(new Complex(0,-1), new Complex(0,1).multiply(new Complex(-1,0)));\n+    }\n+\n }\n--- a/src/test/org/apache/commons/math/complex/ComplexUtilsTest.java\n+++ b/src/test/org/apache/commons/math/complex/ComplexUtilsTest.java\n     private double nan = Double.NaN;\n     private double pi = Math.PI;\n     \n-    private Complex oneInf = new Complex(1, inf);\n-    private Complex oneNegInf = new Complex(1, negInf);\n-    private Complex infOne = new Complex(inf, 1);\n-    private Complex negInfOne = new Complex(negInf, 1);\n     private Complex negInfInf = new Complex(negInf, inf);\n     private Complex infNegInf = new Complex(inf, negInf);\n     private Complex infInf = new Complex(inf, inf);\n     private Complex negInfNegInf = new Complex(negInf, negInf);\n     private Complex infNaN = new Complex(inf, nan);\n-    private Complex negInfNaN = new Complex(negInf, nan);\n-    private Complex nanInf = new Complex(nan, inf);\n-    private Complex nanNegInf = new Complex(nan, negInf);\n-    private Complex zeroNaN = new Complex(0, nan);\n-    private Complex nanZero = new Complex(nan, 0);\n-    private Complex infZero = new Complex(inf, 0);\n-    private Complex zeroInf = new Complex(0, inf);\n-    private Complex negInfZero = new Complex(negInf, 0);\n \n-    /** @deprecated to be removed in 2.0 */\n-    public void testAcos() {\n-        Complex z = new Complex(3, 4);\n-        Complex expected = new Complex(0.936812, -2.30551);\n-        TestUtils.assertEquals(expected, ComplexUtils.acos(z), 1.0e-5);\n-        TestUtils.assertEquals(new Complex(Math.acos(0), 0), \n-                ComplexUtils.acos(Complex.ZERO), 1.0e-12);\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testAcosInf() {\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(oneNegInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infOne));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfOne));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(infNegInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.acos(negInfNegInf));\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testAcosNaN() {\n-        assertTrue(ComplexUtils.acos(Complex.NaN).isNaN());\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testAcosNull() {\n-        try {\n-            ComplexUtils.acos(null); \n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n-            // expected\n-        }\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testAsin() {\n-        Complex z = new Complex(3, 4);\n-        Complex expected = new Complex(0.633984, 2.30551);\n-        TestUtils.assertEquals(expected, ComplexUtils.asin(z), 1.0e-5);\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testAsinNaN() {\n-        assertTrue(ComplexUtils.asin(Complex.NaN).isNaN());\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testAsinInf() {\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(oneNegInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infOne));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfOne));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(infNegInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.asin(negInfNegInf));\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testAsinNull() {\n-        try {\n-            ComplexUtils.asin(null); \n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n-            // expected\n-        }\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testAtan() {\n-        Complex z = new Complex(3, 4);\n-        Complex expected = new Complex(1.44831, 0.158997);\n-        TestUtils.assertEquals(expected, ComplexUtils.atan(z), 1.0e-5);\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testAtanInf() {\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(oneNegInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infOne));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfOne));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(infNegInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.atan(negInfNegInf));\n-    } \n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testAtanNaN() {\n-        assertTrue(ComplexUtils.atan(Complex.NaN).isNaN());\n-        assertTrue(ComplexUtils.atan(Complex.I).isNaN());\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testAtanNull() {\n-        try {\n-            ComplexUtils.atan(null); \n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n-            // expected\n-        }\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testCos() {\n-        Complex z = new Complex(3, 4);\n-        Complex expected = new Complex(-27.03495, -3.851153);\n-        TestUtils.assertEquals(expected, ComplexUtils.cos(z), 1.0e-5);\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testCosNaN() {\n-        assertTrue(ComplexUtils.cos(Complex.NaN).isNaN());\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testCosInf() {\n-        TestUtils.assertSame(infNegInf, ComplexUtils.cos(oneInf));\n-        TestUtils.assertSame(infInf, ComplexUtils.cos(oneNegInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infOne));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfOne));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(infNegInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.cos(negInfNegInf));\n-    } \n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testCosNull() {\n-        try {\n-            ComplexUtils.cos(null); \n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n-            // expected\n-        }\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testCosh() {\n-        Complex z = new Complex(3, 4);\n-        Complex expected = new Complex(-6.58066, -7.58155);\n-        TestUtils.assertEquals(expected, ComplexUtils.cosh(z), 1.0e-5);\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testCoshNaN() {\n-        assertTrue(ComplexUtils.cosh(Complex.NaN).isNaN());\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testCoshInf() {  \n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(oneNegInf));\n-        TestUtils.assertSame(infInf, ComplexUtils.cosh(infOne));\n-        TestUtils.assertSame(infNegInf, ComplexUtils.cosh(negInfOne));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(infNegInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.cosh(negInfNegInf));\n-    } \n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testCoshNull() {\n-        try {\n-            ComplexUtils.cosh(null); \n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n-            // expected\n-        }\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testExp() {\n-        Complex z = new Complex(3, 4);\n-        Complex expected = new Complex(-13.12878, -15.20078);\n-        TestUtils.assertEquals(expected, ComplexUtils.exp(z), 1.0e-5);\n-        TestUtils.assertEquals(Complex.ONE, \n-                ComplexUtils.exp(Complex.ZERO), 10e-12);\n-        Complex iPi = Complex.I.multiply(new Complex(pi,0));\n-        TestUtils.assertEquals(Complex.ONE.negate(), \n-                ComplexUtils.exp(iPi), 10e-12);\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testExpNaN() {\n-        assertTrue(ComplexUtils.exp(Complex.NaN).isNaN());\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testExpInf() {\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(oneNegInf));\n-        TestUtils.assertSame(infInf, ComplexUtils.exp(infOne));\n-        TestUtils.assertSame(Complex.ZERO, ComplexUtils.exp(negInfOne));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(infNegInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.exp(negInfNegInf));\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testExpNull() {\n-        try {\n-            ComplexUtils.exp(null); \n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n-            // expected\n-        }\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testLog() {\n-        Complex z = new Complex(3, 4);\n-        Complex expected = new Complex(1.60944, 0.927295);\n-        TestUtils.assertEquals(expected, ComplexUtils.log(z), 1.0e-5);\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testLogNaN() {\n-        assertTrue(ComplexUtils.log(Complex.NaN).isNaN());\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testLogInf() {\n-        TestUtils.assertEquals(new Complex(inf, pi / 2),\n-                ComplexUtils.log(oneInf), 10e-12);\n-        TestUtils.assertEquals(new Complex(inf, -pi / 2),\n-                ComplexUtils.log(oneNegInf), 10e-12);\n-        TestUtils.assertEquals(infZero, ComplexUtils.log(infOne), 10e-12);\n-        TestUtils.assertEquals(new Complex(inf, pi),\n-                ComplexUtils.log(negInfOne), 10e-12);\n-        TestUtils.assertEquals(new Complex(inf, pi / 4),\n-                ComplexUtils.log(infInf), 10e-12);\n-        TestUtils.assertEquals(new Complex(inf, -pi / 4),\n-                ComplexUtils.log(infNegInf), 10e-12);\n-        TestUtils.assertEquals(new Complex(inf, 3d * pi / 4),\n-                ComplexUtils.log(negInfInf), 10e-12);\n-        TestUtils.assertEquals(new Complex(inf, - 3d * pi / 4),\n-                ComplexUtils.log(negInfNegInf), 10e-12);\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testLogZero() {\n-        TestUtils.assertSame(negInfZero, ComplexUtils.log(Complex.ZERO));\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testlogNull() {\n-        try {\n-            ComplexUtils.log(null); \n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n-            // expected\n-        }\n-    }\n-    \n     public void testPolar2Complex() {\n         TestUtils.assertEquals(Complex.ONE, \n                 ComplexUtils.polar2Complex(1, 0), 10e-12);\n         }   \n     }\n \n-    /** @deprecated to be removed in 2.0 */\n     protected Complex altPolar(double r, double theta) {\n-        return ComplexUtils.exp(Complex.I.multiply\n-                (new Complex(theta, 0))).multiply(new Complex(r, 0));\n+        return Complex.I.multiply(new Complex(theta, 0)).exp().multiply(new Complex(r, 0));\n     }\n     \n     public void testPolar2ComplexIllegalModulus() {\n         TestUtils.assertSame(negInfNegInf, ComplexUtils.polar2Complex(inf, 5*pi/4));\n     }\n \n-    /** @deprecated to be removed in 2.0 */\n-    public void testPow() {\n-        Complex x = new Complex(3, 4);\n-        Complex y = new Complex(5, 6);\n-        Complex expected = new Complex(-1.860893, 11.83677);\n-        TestUtils.assertEquals(expected, ComplexUtils.pow(x, y), 1.0e-5);\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testPowNaNBase() {\n-        Complex x = new Complex(3, 4);\n-        assertTrue(ComplexUtils.pow(Complex.NaN, x).isNaN());\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testPowNaNExponent() {\n-        Complex x = new Complex(3, 4);\n-        assertTrue(ComplexUtils.pow(x, Complex.NaN).isNaN());\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-   public void testPowInf() {\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneInf));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, oneNegInf));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infOne));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infInf));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, infNegInf));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfInf));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(Complex.ONE, negInfNegInf));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infOne, Complex.ONE));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfOne, Complex.ONE));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, Complex.ONE));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, Complex.ONE));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfInf, Complex.ONE));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, Complex.ONE));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infNegInf));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, negInfNegInf));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(negInfNegInf, infInf));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infNegInf));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, negInfNegInf));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infInf, infInf));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infNegInf));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, negInfNegInf));\n-       TestUtils.assertSame(Complex.NaN,ComplexUtils.pow(infNegInf, infInf));   \n-   }\n-\n-   /** @deprecated to be removed in 2.0 */\n-   public void testPowZero() {\n-       TestUtils.assertSame(Complex.NaN, \n-               ComplexUtils.pow(Complex.ZERO, Complex.ONE));\n-       TestUtils.assertSame(Complex.NaN, \n-               ComplexUtils.pow(Complex.ZERO, Complex.ZERO));\n-       TestUtils.assertSame(Complex.NaN, \n-               ComplexUtils.pow(Complex.ZERO, Complex.I));\n-       TestUtils.assertEquals(Complex.ONE,\n-               ComplexUtils.pow(Complex.ONE, Complex.ZERO), 10e-12);\n-       TestUtils.assertEquals(Complex.ONE,\n-               ComplexUtils.pow(Complex.I, Complex.ZERO), 10e-12);\n-       TestUtils.assertEquals(Complex.ONE,\n-               ComplexUtils.pow(new Complex(-1, 3), Complex.ZERO), 10e-12);\n-   }\n-\n-   /** @deprecated to be removed in 2.0 */\n-    public void testpowNull() {\n-        try {\n-            ComplexUtils.pow(null, Complex.ONE); \n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n-            // expected\n-        }\n-        try {\n-            ComplexUtils.pow(Complex.ONE, null); \n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n-            // expected\n-        }\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testSin() {\n-        Complex z = new Complex(3, 4);\n-        Complex expected = new Complex(3.853738, -27.01681);\n-        TestUtils.assertEquals(expected, ComplexUtils.sin(z), 1.0e-5);\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testSinInf() {\n-        TestUtils.assertSame(infInf, ComplexUtils.sin(oneInf));\n-        TestUtils.assertSame(infNegInf, ComplexUtils.sin(oneNegInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infOne));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfOne));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(infNegInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.sin(negInfNegInf));\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testSinNaN() {\n-        assertTrue(ComplexUtils.sin(Complex.NaN).isNaN());\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testSinNull() {\n-        try {\n-            ComplexUtils.sin(null); \n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n-            // expected\n-        }\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testSinh() {\n-        Complex z = new Complex(3, 4);\n-        Complex expected = new Complex(-6.54812, -7.61923);\n-        TestUtils.assertEquals(expected, ComplexUtils.sinh(z), 1.0e-5);\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testSinhNaN() {\n-        assertTrue(ComplexUtils.sinh(Complex.NaN).isNaN());\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testSinhInf() {\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(oneNegInf));\n-        TestUtils.assertSame(infInf, ComplexUtils.sinh(infOne));\n-        TestUtils.assertSame(negInfInf, ComplexUtils.sinh(negInfOne));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(infNegInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.sinh(negInfNegInf));\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testsinhNull() {\n-        try {\n-            ComplexUtils.sinh(null); \n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n-            // expected\n-        }\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testSqrtRealPositive() {\n-        Complex z = new Complex(3, 4);\n-        Complex expected = new Complex(2, 1);\n-        TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testSqrtRealZero() {\n-        Complex z = new Complex(0.0, 4);\n-        Complex expected = new Complex(1.41421, 1.41421);\n-        TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testSqrtRealNegative() {\n-        Complex z = new Complex(-3.0, 4);\n-        Complex expected = new Complex(1, 2);\n-        TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testSqrtImaginaryZero() {\n-        Complex z = new Complex(-3.0, 0.0);\n-        Complex expected = new Complex(0.0, 1.73205);\n-        TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testSqrtImaginaryNegative() {\n-        Complex z = new Complex(-3.0, -4.0);\n-        Complex expected = new Complex(1.0, -2.0);\n-        TestUtils.assertEquals(expected, ComplexUtils.sqrt(z), 1.0e-5);\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testSqrtPolar() {\n-        double r = 1;\n-        for (int i = 0; i < 5; i++) {\n-            r += i;\n-            double theta = 0;\n-            for (int j =0; j < 11; j++) {\n-                theta += pi /12;\n-                Complex z = ComplexUtils.polar2Complex(r, theta);\n-                Complex sqrtz = ComplexUtils.polar2Complex(Math.sqrt(r), theta / 2);\n-                TestUtils.assertEquals(sqrtz, ComplexUtils.sqrt(z), 10e-12);\n-            }\n-        }       \n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testSqrtNaN() {\n-        assertTrue(ComplexUtils.sqrt(Complex.NaN).isNaN());\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testSqrtInf() {\n-        TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneInf));\n-        TestUtils.assertSame(infNaN, ComplexUtils.sqrt(oneNegInf));\n-        TestUtils.assertSame(infZero, ComplexUtils.sqrt(infOne));\n-        TestUtils.assertSame(zeroInf, ComplexUtils.sqrt(negInfOne));\n-        TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infInf));\n-        TestUtils.assertSame(infNaN, ComplexUtils.sqrt(infNegInf));\n-        TestUtils.assertSame(nanInf, ComplexUtils.sqrt(negInfInf));\n-        TestUtils.assertSame(nanNegInf, ComplexUtils.sqrt(negInfNegInf));\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testSqrtNull() {\n-        try {\n-            ComplexUtils.sqrt(null); \n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n-            // expected\n-        }\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testSqrt1z() {\n-        Complex z = new Complex(3, 4);\n-        Complex expected = new Complex(4.08033, -2.94094);\n-        TestUtils.assertEquals(expected, ComplexUtils.sqrt1z(z), 1.0e-5);\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testSqrt1zNaN() {\n-        assertTrue(ComplexUtils.sqrt1z(Complex.NaN).isNaN());\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testSqrt1zNull() {\n-        try {\n-            ComplexUtils.sqrt1z(null); \n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n-            // expected\n-        }\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testTan() {\n-        Complex z = new Complex(3, 4);\n-        Complex expected = new Complex(-0.000187346, 0.999356);\n-        TestUtils.assertEquals(expected, ComplexUtils.tan(z), 1.0e-5);\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testTanNaN() {\n-        assertTrue(ComplexUtils.tan(Complex.NaN).isNaN());\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testTanInf() {\n-        TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneInf));\n-        TestUtils.assertSame(zeroNaN, ComplexUtils.tan(oneNegInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infOne));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfOne));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(infNegInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.tan(negInfNegInf));\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-   public void testTanCritical() {\n-        TestUtils.assertSame(infNaN, ComplexUtils.tan(new Complex(pi/2, 0)));\n-        TestUtils.assertSame(negInfNaN, ComplexUtils.tan(new Complex(-pi/2, 0)));\n-    }\n-\n-   /** @deprecated to be removed in 2.0 */\n-    public void testTanNull() {\n-        try {\n-            ComplexUtils.tan(null); \n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n-            // expected\n-        }\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testTanh() {\n-        Complex z = new Complex(3, 4);\n-        Complex expected = new Complex(1.00071, 0.00490826);\n-        TestUtils.assertEquals(expected, ComplexUtils.tanh(z), 1.0e-5);\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testTanhNaN() {\n-        assertTrue(ComplexUtils.tanh(Complex.NaN).isNaN());\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testTanhInf() {\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(oneNegInf));\n-        TestUtils.assertSame(nanZero, ComplexUtils.tanh(infOne));\n-        TestUtils.assertSame(nanZero, ComplexUtils.tanh(negInfOne));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(infNegInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfInf));\n-        TestUtils.assertSame(Complex.NaN, ComplexUtils.tanh(negInfNegInf));\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testTanhCritical() {\n-        TestUtils.assertSame(nanInf, ComplexUtils.tanh(new Complex(0, pi/2)));\n-    }\n-\n-    /** @deprecated to be removed in 2.0 */\n-    public void testTanhNull() {\n-        try {\n-            ComplexUtils.tanh(null); \n-            fail(\"Expecting NullPointerException\");\n-        } catch (NullPointerException ex) {\n-            // expected\n-        }\n-    }\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/distribution/BetaDistributionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import junit.framework.TestCase;\n+import org.apache.commons.math.MathException;\n+\n+public class BetaDistributionTest extends TestCase {\n+    public void testCumulative() throws MathException {\n+        double[] x = new double[]{-0.1, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1};\n+        // all test data computed using R 2.5\n+        checkCumulative(0.1, 0.1,\n+                x, new double[]{\n+                0.0000000000, 0.0000000000, 0.4063850939, 0.4397091902, 0.4628041861,\n+                0.4821200456, 0.5000000000, 0.5178799544, 0.5371958139, 0.5602908098,\n+                0.5936149061, 1.0000000000, 1.0000000000});\n+        checkCumulative(0.1, 0.5,\n+                x, new double[]{\n+                0.0000000000, 0.0000000000, 0.7048336221, 0.7593042194, 0.7951765304,\n+                0.8234948385, 0.8480017124, 0.8706034370, 0.8926585878, 0.9156406404,\n+                0.9423662883, 1.0000000000, 1.0000000000});\n+        checkCumulative(0.1, 1.0,\n+                x, new double[]{\n+                0.0000000000, 0.0000000000, 0.7943282347, 0.8513399225, 0.8865681506,\n+                0.9124435366, 0.9330329915, 0.9502002165, 0.9649610951, 0.9779327685,\n+                0.9895192582, 1.0000000000, 1.0000000000});\n+        checkCumulative(0.1, 2.0,\n+                x, new double[]{\n+                0.0000000000, 0.0000000000, 0.8658177758, 0.9194471163, 0.9486279211,\n+                0.9671901487, 0.9796846411, 0.9882082252, 0.9939099280, 0.9974914239,\n+                0.9994144508, 1.0000000000, 1.0000000000});\n+        checkCumulative(0.1, 4.0,\n+                x, new double[]{\n+                0.0000000000, 0.0000000000, 0.9234991121, 0.9661958941, 0.9842285085,\n+                0.9928444112, 0.9970040660, 0.9989112804, 0.9996895625, 0.9999440793,\n+                0.9999967829, 1.0000000000, 1.0000000000});\n+        checkCumulative(0.5, 0.1,\n+                x, new double[]{\n+                0.00000000000, 0.00000000000, 0.05763371168, 0.08435935962,\n+                0.10734141216, 0.12939656302, 0.15199828760, 0.17650516146,\n+                0.20482346963, 0.24069578055, 0.29516637795, 1.00000000000, 1.00000000000});\n+\n+        checkCumulative(0.5, 0.5,\n+                x, new double[]{\n+                0.0000000000, 0.0000000000, 0.2048327647, 0.2951672353, 0.3690101196,\n+                0.4359057832, 0.5000000000, 0.5640942168, 0.6309898804, 0.7048327647,\n+                0.7951672353, 1.0000000000, 1.0000000000});\n+        checkCumulative(0.5, 1.0,\n+                x, new double[]{\n+                0.0000000000, 0.0000000000, 0.3162277660, 0.4472135955, 0.5477225575,\n+                0.6324555320, 0.7071067812, 0.7745966692, 0.8366600265, 0.8944271910,\n+                0.9486832981, 1.0000000000, 1.0000000000});\n+        checkCumulative(0.5, 2.0,\n+                x, new double[]{\n+                0.0000000000, 0.0000000000, 0.4585302607, 0.6260990337, 0.7394254526,\n+                0.8221921916, 0.8838834765, 0.9295160031, 0.9621590305, 0.9838699101,\n+                0.9961174630, 1.0000000000, 1.0000000000});\n+        checkCumulative(0.5, 4.0,\n+                x, new double[]{\n+                0.0000000000, 0.0000000000, 0.6266250826, 0.8049844719, 0.8987784842,\n+                0.9502644369, 0.9777960959, 0.9914837366, 0.9974556254, 0.9995223859,\n+                0.9999714889, 1.0000000000, 1.0000000000});\n+        checkCumulative(1.0, 0.1,\n+                x, new double[]{\n+                0.00000000000, 0.00000000000, 0.01048074179, 0.02206723146,\n+                0.03503890488, 0.04979978349, 0.06696700846, 0.08755646344,\n+                0.11343184943, 0.14866007748, 0.20567176528, 1.00000000000, 1.00000000000});\n+        checkCumulative(1.0, 0.5,\n+                x, new double[]{\n+                0.00000000000, 0.00000000000, 0.05131670195, 0.10557280900,\n+                0.16333997347, 0.22540333076, 0.29289321881, 0.36754446797,\n+                0.45227744249, 0.55278640450, 0.68377223398, 1.00000000000, 1.00000000000});\n+        checkCumulative(1, 1,\n+                x, new double[]{\n+                0.0, 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.0});\n+        checkCumulative(1, 2,\n+                x, new double[]{\n+                0.00, 0.00, 0.19, 0.36, 0.51, 0.64, 0.75, 0.84, 0.91, 0.96, 0.99, 1.00, 1.00});\n+        checkCumulative(1, 4,\n+                x, new double[]{\n+                0.0000, 0.0000, 0.3439, 0.5904, 0.7599, 0.8704, 0.9375, 0.9744, 0.9919,\n+                0.9984, 0.9999, 1.0000, 1.0000});\n+        checkCumulative(2.0, 0.1,\n+                x, new double[]{\n+                0.0000000000000, 0.0000000000000, 0.0005855492117, 0.0025085760862,\n+                0.0060900720266, 0.0117917748341, 0.0203153588864, 0.0328098512512,\n+                0.0513720788952, 0.0805528836776, 0.1341822241505, 1.0000000000000, 1.0000000000000});\n+        checkCumulative(2, 1,\n+                x, new double[]{\n+                0.00, 0.00, 0.01, 0.04, 0.09, 0.16, 0.25, 0.36, 0.49, 0.64, 0.81, 1.00, 1.00});\n+        checkCumulative(2.0, 0.5,\n+                x, new double[]{\n+                0.000000000000, 0.000000000000, 0.003882537047, 0.016130089900,\n+                0.037840969486, 0.070483996910, 0.116116523517, 0.177807808356,\n+                0.260574547368, 0.373900966300, 0.541469739276, 1.000000000000, 1.000000000000});\n+        checkCumulative(2, 2,\n+                x, new double[]{\n+                0.000, 0.000, 0.028, 0.104, 0.216, 0.352, 0.500, 0.648, 0.784, 0.896, 0.972, 1.000, 1.000});\n+        checkCumulative(2, 4,\n+                x, new double[]{\n+                0.00000, 0.00000, 0.08146, 0.26272, 0.47178, 0.66304, 0.81250, 0.91296,\n+                0.96922, 0.99328, 0.99954, 1.00000, 1.00000});\n+        checkCumulative(4.0, 0.1,\n+                x, new double[]{\n+                0.000000000e+00, 0.000000000e+00, 3.217128269e-06, 5.592070271e-05,\n+                3.104375474e-04, 1.088719595e-03, 2.995933981e-03, 7.155588777e-03,\n+                1.577149153e-02, 3.380410585e-02, 7.650088789e-02, 1.000000000e+00, 1.000000000e+00});\n+        checkCumulative(4.0, 0.5,\n+                x, new double[]{\n+                0.000000000e+00, 0.000000000e+00, 2.851114863e-05, 4.776140576e-04,\n+                2.544374616e-03, 8.516263371e-03, 2.220390414e-02, 4.973556312e-02,\n+                1.012215158e-01, 1.950155281e-01, 3.733749174e-01, 1.000000000e+00, 1.000000000e+00});\n+        checkCumulative(4, 1,\n+                x, new double[]{\n+                0.0000, 0.0000, 0.0001, 0.0016, 0.0081, 0.0256, 0.0625, 0.1296, 0.2401,\n+                0.4096, 0.6561, 1.0000, 1.0000});\n+        checkCumulative(4, 2,\n+                x, new double[]{\n+                0.00000, 0.00000, 0.00046, 0.00672, 0.03078, 0.08704, 0.18750, 0.33696,\n+                0.52822, 0.73728, 0.91854, 1.00000, 1.00000});\n+        checkCumulative(4, 4,\n+                x, new double[]{\n+                0.000000, 0.000000, 0.002728, 0.033344, 0.126036, 0.289792, 0.500000,\n+                0.710208, 0.873964, 0.966656, 0.997272, 1.000000, 1.000000});\n+\n+    }\n+\n+    private void checkCumulative(double alpha, double beta, double[] x, double[] cumes) throws MathException {\n+        BetaDistribution d = new BetaDistributionImpl(alpha, beta);\n+        for (int i = 0; i < x.length; i++) {\n+            assertEquals(cumes[i], d.cumulativeProbability(x[i]), 1e-8);\n+        }\n+\n+        for (int i = 1; i < x.length - 1; i++) {\n+            assertEquals(x[i], d.inverseCumulativeProbability(cumes[i]), 1e-5);\n+        }\n+    }\n+\n+    public void testDensity() throws MathException {\n+        double[] x = new double[]{1e-6, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9};\n+        checkDensity(0.1, 0.1,\n+                x, new double[]{\n+                12741.2357380649, 0.4429889586665234, 2.639378715e-01, 2.066393611e-01,\n+                1.832401831e-01, 1.766302780e-01, 1.832404579e-01, 2.066400696e-01,\n+                2.639396531e-01, 4.429925026e-01});\n+        checkDensity(0.1, 0.5,\n+                x, new double[]{\n+                2.218377102e+04, 7.394524202e-01, 4.203020268e-01, 3.119435533e-01,\n+                2.600787829e-01, 2.330648626e-01, 2.211408259e-01, 2.222728708e-01,\n+                2.414013907e-01, 3.070567405e-01});\n+        checkDensity(0.1, 1.0,\n+                x, new double[]{\n+                2.511886432e+04, 7.943210858e-01, 4.256680458e-01, 2.955218303e-01,\n+                2.281103709e-01, 1.866062624e-01, 1.583664652e-01, 1.378514078e-01,\n+                1.222414585e-01, 1.099464743e-01});\n+        checkDensity(0.1, 2.0,\n+                x, new double[]{\n+                2.763072312e+04, 7.863770012e-01, 3.745874120e-01, 2.275514842e-01,\n+                1.505525939e-01, 1.026332391e-01, 6.968107049e-02, 4.549081293e-02,\n+                2.689298641e-02, 1.209399123e-02});\n+        checkDensity(0.1, 4.0,\n+                x, new double[]{\n+                2.997927462e+04, 6.911058917e-01, 2.601128486e-01, 1.209774010e-01,\n+                5.880564714e-02, 2.783915474e-02, 1.209657335e-02, 4.442148268e-03,\n+                1.167143939e-03, 1.312171805e-04});\n+        checkDensity(0.5, 0.1,\n+                x, new double[]{\n+                88.3152184726, 0.3070542841, 0.2414007269, 0.2222727015,\n+                0.2211409364, 0.2330652355, 0.2600795198, 0.3119449793,\n+                0.4203052841, 0.7394649088});\n+        checkDensity(0.5, 0.5,\n+                x, new double[]{\n+                318.3100453389, 1.0610282383, 0.7957732234, 0.6946084565,\n+                0.6497470636, 0.6366197724, 0.6497476051, 0.6946097796,\n+                0.7957762075, 1.0610376697});\n+        checkDensity(0.5, 1.0,\n+                x, new double[]{\n+                500.0000000000, 1.5811309244, 1.1180311937, 0.9128694077,\n+                0.7905684268, 0.7071060741, 0.6454966865, 0.5976138778,\n+                0.5590166450, 0.5270459839});\n+        checkDensity(0.5, 2.0,\n+                x, new double[]{\n+                749.99925000000, 2.134537420613655, 1.34163575536, 0.95851150881,\n+                0.71151039830, 0.53032849490, 0.38729704363, 0.26892534859,\n+                0.16770415497, 0.07905610701});\n+        checkDensity(0.5, 4.0,\n+                x, new double[]{\n+                1.093746719e+03, 2.52142232809988, 1.252190241e+00, 6.849343920e-01,\n+                3.735417140e-01, 1.933481570e-01, 9.036885833e-02, 3.529621669e-02,\n+                9.782644546e-03, 1.152878503e-03});\n+        checkDensity(1.0, 0.1,\n+                x, new double[]{\n+                0.1000000900, 0.1099466942, 0.1222417336, 0.1378517623, 0.1583669403,\n+                0.1866069342, 0.2281113974, 0.2955236034, 0.4256718768,\n+                0.7943353837});\n+        checkDensity(1.0, 0.5,\n+                x, new double[]{\n+                0.5000002500, 0.5270465695, 0.5590173438, 0.5976147315, 0.6454977623,\n+                0.7071074883, 0.7905704033, 0.9128724506,\n+                1.1180367838, 1.5811467358});\n+        checkDensity(1, 1,\n+                x, new double[]{\n+                1, 1, 1,\n+                1, 1, 1, 1,\n+                1, 1, 1});\n+        checkDensity(1, 2,\n+                x, new double[]{\n+                1.999998, 1.799998, 1.599998, 1.399998, 1.199998, 0.999998, 0.799998,\n+                0.599998, 0.399998,\n+                0.199998});\n+        checkDensity(1, 4,\n+                x, new double[]{\n+                3.999988000012, 2.915990280011, 2.047992320010, 1.371994120008,\n+                0.863995680007, 0.499997000006, 0.255998080005, 0.107998920004,\n+                0.031999520002, 0.003999880001});\n+        checkDensity(2.0, 0.1,\n+                x, new double[]{\n+                1.100000990e-07, 1.209425730e-02, 2.689331586e-02, 4.549123318e-02,\n+                6.968162794e-02, 1.026340191e-01, 1.505537732e-01, 2.275534997e-01,\n+                3.745917198e-01, 7.863929037e-01});\n+        checkDensity(2.0, 0.5,\n+                x, new double[]{\n+                7.500003750e-07, 7.905777599e-02, 1.677060417e-01, 2.689275256e-01,\n+                3.872996256e-01, 5.303316769e-01, 7.115145488e-01, 9.585174425e-01,\n+                1.341645818e+00, 2.134537420613655});\n+        checkDensity(2, 1,\n+                x, new double[]{\n+                0.000002, 0.200002, 0.400002, 0.600002, 0.800002, 1.000002, 1.200002,\n+                1.400002, 1.600002,\n+                1.800002});\n+        checkDensity(2, 2,\n+                x, new double[]{\n+                5.9999940e-06, 5.4000480e-01, 9.6000360e-01, 1.2600024e+00,\n+                1.4400012e+00, 1.5000000e+00, 1.4399988e+00, 1.2599976e+00,\n+                9.5999640e-01, 5.3999520e-01});\n+        checkDensity(2, 4,\n+                x, new double[]{\n+                0.00001999994, 1.45800971996, 2.04800255997, 2.05799803998,\n+                1.72799567999, 1.24999500000, 0.76799552000, 0.37799676001,\n+                0.12799824001, 0.01799948000});\n+        checkDensity(4.0, 0.1,\n+                x, new double[]{\n+                1.193501074e-19, 1.312253162e-04, 1.167181580e-03, 4.442248535e-03,\n+                1.209679109e-02, 2.783958903e-02, 5.880649983e-02, 1.209791638e-01,\n+                2.601171405e-01, 6.911229392e-01});\n+        checkDensity(4.0, 0.5,\n+                x, new double[]{\n+                1.093750547e-18, 1.152948959e-03, 9.782950259e-03, 3.529697305e-02,\n+                9.037036449e-02, 1.933508639e-01, 3.735463833e-01, 6.849425461e-01,\n+                1.252205894e+00, 2.52142232809988});\n+        checkDensity(4, 1,\n+                x, new double[]{\n+                4.000000000e-18, 4.000120001e-03, 3.200048000e-02, 1.080010800e-01,\n+                2.560019200e-01, 5.000030000e-01, 8.640043200e-01, 1.372005880e+00,\n+                2.048007680e+00, 2.916009720e+00});\n+        checkDensity(4, 2,\n+                x, new double[]{\n+                1.999998000e-17, 1.800052000e-02, 1.280017600e-01, 3.780032400e-01,\n+                7.680044800e-01, 1.250005000e+00, 1.728004320e+00, 2.058001960e+00,\n+                2.047997440e+00, 1.457990280e+00});\n+        checkDensity(4, 4,\n+                x, new double[]{\n+                1.399995800e-16, 1.020627216e-01, 5.734464512e-01, 1.296547409e+00,\n+                1.935364838e+00, 2.187500000e+00, 1.935355162e+00, 1.296532591e+00,\n+                5.734335488e-01, 1.020572784e-01});\n+\n+    }\n+\n+    private void checkDensity(double alpha, double beta, double[] x, double[] expected) throws MathException {\n+        BetaDistribution d = new BetaDistributionImpl(alpha, beta);\n+        for (int i = 0; i < x.length; i++) {\n+            assertEquals(String.format(\"density at x=%.1f for alpha=%.1f, beta=%.1f\", x[i], alpha, beta), expected[i], d.density(x[i]), 1e-5);\n+        }\n+    }\n+}\n--- a/src/test/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/ChiSquareDistributionTest.java\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-    } \n-    \n+    }\n+\n+    public void testDensity() {\n+        double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5};\n+        //R 2.5: print(dchisq(x, df=1), digits=10)\n+        checkDensity(1, x, new double[]{0.00000000000, 398.94208093034, 0.43939128947, 0.24197072452, 0.10377687436, 0.01464498256});\n+        //R 2.5: print(dchisq(x, df=0.1), digits=10)\n+        checkDensity(0.1, x, new double[]{0.000000000e+00, 2.486453997e+04, 7.464238732e-02, 3.009077718e-02, 9.447299159e-03, 8.827199396e-04});\n+        //R 2.5: print(dchisq(x, df=2), digits=10)\n+        checkDensity(2, x, new double[]{0.00000000000, 0.49999975000, 0.38940039154, 0.30326532986, 0.18393972059, 0.04104249931});\n+        //R 2.5: print(dchisq(x, df=10), digits=10)\n+        checkDensity(10, x, new double[]{0.000000000e+00, 1.302082682e-27, 6.337896998e-05, 7.897534632e-04, 7.664155024e-03, 6.680094289e-02});\n+    }\n+\n+    private void checkDensity(double df, double[] x, double[] expected) {\n+        ChiSquaredDistribution d = new ChiSquaredDistributionImpl(df);\n+        for (int i = 0; i < x.length; i++) {\n+            assertEquals(expected[i], d.density(x[i]), 1e-5);\n+        }\n+    }\n+\n }\n--- a/src/test/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/ExponentialDistributionTest.java\n  * limitations under the License.\n  */\n package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n \n /**\n  * Test cases for ExponentialDistribution.\n         double actual = getDistribution().cumulativeProbability(0.25, 0.75);\n         assertEquals(0.0905214, actual, 10e-4);\n     }\n+\n+    public void testDensity() throws MathException {\n+        ExponentialDistribution d1 = new ExponentialDistributionImpl(1);\n+        assertEquals(0.0, d1.density(-1e-9));\n+        assertEquals(1.0, d1.density(0.0));\n+        assertEquals(0.0, d1.density(1000.0));\n+        assertEquals(Math.exp(-1), d1.density(1.0));\n+        assertEquals(Math.exp(-2), d1.density(2.0));\n+\n+        ExponentialDistribution d2 = new ExponentialDistributionImpl(3);\n+        assertEquals(1/3.0, d2.density(0.0));\n+        // computed using  print(dexp(1, rate=1/3), digits=10) in R 2.5\n+        assertEquals(0.2388437702, d2.density(1.0), 1e-8);\n+\n+        // computed using  print(dexp(2, rate=1/3), digits=10) in R 2.5\n+        assertEquals(0.1711390397, d2.density(2.0), 1e-8);\n+    }\n     \n     public void testMeanAccessors() {\n         ExponentialDistribution distribution = (ExponentialDistribution) getDistribution();\n--- a/src/test/org/apache/commons/math/distribution/FDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/FDistributionTest.java\n         x = fd.inverseCumulativeProbability(p);\n         assertEquals(0.975, x, 1.0e-5);\n     }\n+\n }\n--- a/src/test/org/apache/commons/math/distribution/GammaDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/GammaDistributionTest.java\n     public GammaDistributionTest(String name) {\n         super(name);\n     }\n-    \n+\n     //-------------- Implementations for abstract methods -----------------------\n-    \n+\n     /** Creates the default continuous distribution instance to use in tests. */\n     public ContinuousDistribution makeDistribution() {\n         return new GammaDistributionImpl(4d, 2d);\n-    }   \n-    \n+    }\n+\n     /** Creates the default cumulative probability distribution test input values */\n     public double[] makeCumulativeTestPoints() {\n         // quantiles computed using R version 1.8.1 (linux version)\n             3.489539, 26.12448, 20.09024, 17.53455,\n             15.50731, 13.36157};\n     }\n-    \n+\n     /** Creates the default cumulative probability density test expected values */\n     public double[] makeCumulativeTestValues() {\n         return new double[] {0.001d, 0.01d, 0.025d, 0.05d, 0.1d, 0.999d,\n-                0.990d, 0.975d, 0.950d, 0.900d}; \n+                0.990d, 0.975d, 0.950d, 0.900d};\n     }\n-    \n+\n     // --------------------- Override tolerance  --------------\n     protected void setUp() throws Exception {\n         super.setUp();\n         } catch (IllegalArgumentException ex) {\n             // expected\n         }\n-    } \n-    \n+    }\n+\n     public void testProbabilities() throws Exception {\n         testProbability(-1.000, 4.0, 2.0, .0000);\n         testProbability(15.501, 4.0, 2.0, .9499);\n         double actual = distribution.inverseCumulativeProbability(p);\n         assertEquals(\"critical value for \" + p, expected, actual, 10e-4);\n     }\n-    \n+\n+    public void testDensity() {\n+        double[] x = new double[]{-0.1, 1e-6, 0.5, 1, 2, 5};\n+        // R2.5: print(dgamma(x, shape=1, rate=1), digits=10)\n+        checkDensity(1, 1, x, new double[]{0.000000000000, 0.999999000001, 0.606530659713, 0.367879441171, 0.135335283237, 0.006737946999});\n+        // R2.5: print(dgamma(x, shape=2, rate=1), digits=10)\n+        checkDensity(2, 1, x, new double[]{0.000000000000, 0.000000999999, 0.303265329856, 0.367879441171, 0.270670566473, 0.033689734995});\n+        // R2.5: print(dgamma(x, shape=4, rate=1), digits=10)\n+        checkDensity(4, 1, x, new double[]{0.000000000e+00, 1.666665000e-19, 1.263605541e-02, 6.131324020e-02, 1.804470443e-01, 1.403738958e-01});\n+        // R2.5: print(dgamma(x, shape=4, rate=10), digits=10)\n+        checkDensity(4, 10, x, new double[]{0.000000000e+00, 1.666650000e-15, 1.403738958e+00, 7.566654960e-02, 2.748204830e-05, 4.018228850e-17});\n+        // R2.5: print(dgamma(x, shape=.1, rate=10), digits=10)\n+        checkDensity(0.1, 10, x, new double[]{0.000000000e+00, 3.323953832e+04, 1.663849010e-03, 6.007786726e-06, 1.461647647e-10, 5.996008322e-24});\n+        // R2.5: print(dgamma(x, shape=.1, rate=20), digits=10)\n+        checkDensity(0.1, 20, x, new double[]{0.000000000e+00, 3.562489883e+04, 1.201557345e-05, 2.923295295e-10, 3.228910843e-19, 1.239484589e-45});\n+        // R2.5: print(dgamma(x, shape=.1, rate=4), digits=10)\n+        checkDensity(0.1, 4, x, new double[]{0.000000000e+00, 3.032938388e+04, 3.049322494e-02, 2.211502311e-03, 2.170613371e-05, 5.846590589e-11});\n+        // R2.5: print(dgamma(x, shape=.1, rate=1), digits=10)\n+        checkDensity(0.1, 1, x, new double[]{0.000000000e+00, 2.640334143e+04, 1.189704437e-01, 3.866916944e-02, 7.623306235e-03, 1.663849010e-04});\n+    }\n+\n+    private void checkDensity(double alpha, double rate, double[] x, double[] expected) {\n+        GammaDistribution d = new GammaDistributionImpl(alpha, 1 / rate);\n+        for (int i = 0; i < x.length; i++) {\n+            assertEquals(expected[i], d.density(x[i]), 1e-5);\n+        }\n+    }\n+\n     public void testInverseCumulativeProbabilityExtremes() throws Exception {\n         setInverseCumulativeTestPoints(new double[] {0, 1});\n         setInverseCumulativeTestValues(new double[] {0, Double.POSITIVE_INFINITY});\n--- a/src/test/org/apache/commons/math/distribution/NormalDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/NormalDistributionTest.java\n             // Expected\n         }\n     }\n-    \n+\n+    public void testDensity() {\n+        double [] x = new double[]{-2, -1, 0, 1, 2};\n+        // R 2.5: print(dnorm(c(-2,-1,0,1,2)), digits=10)\n+        checkDensity(0, 1, x, new double[]{0.05399096651, 0.24197072452, 0.39894228040, 0.24197072452, 0.05399096651});\n+        // R 2.5: print(dnorm(c(-2,-1,0,1,2), mean=1.1), digits=10) \n+        checkDensity(1.1, 1, x, new double[]{0.003266819056,0.043983595980,0.217852177033,0.396952547477,0.266085249899});\n+    }\n+\n+    private void checkDensity(double mean, double sd, double[] x, double[] expected) {\n+        NormalDistribution d = new NormalDistributionImpl(mean, sd);\n+        for (int i = 0; i < x.length; i++) {\n+            assertEquals(expected[i], d.density(x[i]), 1e-9);\n+        }\n+    }\n+\n     /**\n      * Check to make sure top-coding of extreme values works correctly.\n      * Verifies fix for JIRA MATH-167\n--- a/src/test/org/apache/commons/math/distribution/PascalDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/PascalDistributionTest.java\n  * Extends IntegerDistributionAbstractTest.  See class javadoc for\n  * IntegerDistributionAbstractTest for details.\n  * \n- * @version $Revision:$ $Date:$\n+ * @version $Revision$ $Date$\n  */\n public class PascalDistributionTest extends IntegerDistributionAbstractTest {\n     \n--- a/src/test/org/apache/commons/math/distribution/WeibullDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/WeibullDistributionTest.java\n  * Extends ContinuousDistributionAbstractTest.  See class javadoc for\n  * ContinuousDistributionAbstractTest for details.\n  * \n- * @version $Revision: 1.8 $ $Date: 2004-07-24 16:41:37 -0500 (Sat, 24 Jul 2004) $\n+ * @version $Revision$ $Date$\n  */\n public class WeibullDistributionTest extends ContinuousDistributionAbstractTest  {\n     \n--- a/src/test/org/apache/commons/math/estimation/GaussNewtonEstimatorTest.java\n+++ b/src/test/org/apache/commons/math/estimation/GaussNewtonEstimatorTest.java\n \n import java.util.ArrayList;\n import java.util.HashSet;\n-import java.util.Iterator;\n-\n-import org.apache.commons.math.estimation.EstimatedParameter;\n-import org.apache.commons.math.estimation.EstimationException;\n-import org.apache.commons.math.estimation.EstimationProblem;\n-import org.apache.commons.math.estimation.GaussNewtonEstimator;\n-import org.apache.commons.math.estimation.WeightedMeasurement;\n-\n-import junit.framework.*;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n \n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n   private static class LinearProblem extends SimpleEstimationProblem {\n \n     public LinearProblem(LinearMeasurement[] measurements) {\n-      HashSet set = new HashSet();\n+      HashSet<EstimatedParameter> set = new HashSet<EstimatedParameter>();\n       for (int i = 0; i < measurements.length; ++i) {\n         addMeasurement(measurements[i]);\n         EstimatedParameter[] parameters = measurements[i].getParameters();\n           set.add(parameters[j]);\n         }\n       }\n-      for (Iterator iterator = set.iterator(); iterator.hasNext();) {\n-        addParameter((EstimatedParameter) iterator.next());\n+      for (EstimatedParameter p : set) {\n+        addParameter(p);\n       }\n     }\n \n     public Circle(double cx, double cy) {\n       this.cx = new EstimatedParameter(\"cx\", cx);\n       this.cy = new EstimatedParameter(new EstimatedParameter(\"cy\", cy));\n-      points  = new ArrayList();\n+      points  = new ArrayList<PointModel>();\n     }\n \n     public void addPoint(double px, double py) {\n \n     public double getPartialRadiusX() {\n       double dRdX = 0;\n-      for (Iterator iterator = points.iterator(); iterator.hasNext();) {\n-        dRdX += ((PointModel) iterator.next()).getPartialDiX();\n+      for (PointModel point : points) {\n+        dRdX += point.getPartialDiX();\n       }\n       return dRdX / points.size();\n     }\n \n     public double getPartialRadiusY() {\n       double dRdY = 0;\n-      for (Iterator iterator = points.iterator(); iterator.hasNext();) {\n-        dRdY += ((PointModel) iterator.next()).getPartialDiY();\n+      for (PointModel point : points) {\n+        dRdY += point.getPartialDiY();\n       }\n       return dRdY / points.size();\n     }\n \n    public double getRadius() {\n       double r = 0;\n-      for (Iterator iterator = points.iterator(); iterator.hasNext();) {\n-        r += ((PointModel) iterator.next()).getCenterDistance();\n+      for (PointModel point : points) {\n+        r += point.getCenterDistance();\n       }\n       return r / points.size();\n     }\n \n     private EstimatedParameter cx;\n     private EstimatedParameter cy;\n-    private ArrayList points;\n+    private ArrayList<PointModel> points;\n \n   }\n \n--- a/src/test/org/apache/commons/math/estimation/LevenbergMarquardtEstimatorTest.java\n+++ b/src/test/org/apache/commons/math/estimation/LevenbergMarquardtEstimatorTest.java\n package org.apache.commons.math.estimation;\n \n import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.Set;\n-\n-import org.apache.commons.math.estimation.EstimatedParameter;\n-import org.apache.commons.math.estimation.EstimationException;\n-import org.apache.commons.math.estimation.EstimationProblem;\n-import org.apache.commons.math.estimation.LevenbergMarquardtEstimator;\n-import org.apache.commons.math.estimation.WeightedMeasurement;\n-\n-import junit.framework.*;\n+import java.util.HashSet;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n \n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n     }\n \n     public EstimatedParameter[] getAllParameters() {\n-      HashMap map = new HashMap();\n+      HashSet<EstimatedParameter> set = new HashSet<EstimatedParameter>();\n       for (int i = 0; i < measurements.length; ++i) {\n         EstimatedParameter[] parameters = measurements[i].getParameters();\n         for (int j = 0; j < parameters.length; ++j) {\n-          map.put(parameters[j], null);\n+          set.add(parameters[j]);\n         }\n       }\n-      Set set = map.keySet();\n       return (EstimatedParameter[]) set.toArray(new EstimatedParameter[set.size()]);\n     }\n   \n     public Circle(double cx, double cy) {\n       this.cx = new EstimatedParameter(\"cx\", cx);\n       this.cy = new EstimatedParameter(\"cy\", cy);\n-      points  = new ArrayList();\n+      points  = new ArrayList<PointModel>();\n     }\n \n     public void addPoint(double px, double py) {\n \n     public double getPartialRadiusX() {\n       double dRdX = 0;\n-      for (Iterator iterator = points.iterator(); iterator.hasNext();) {\n-        dRdX += ((PointModel) iterator.next()).getPartialDiX();\n+      for (PointModel point : points) {\n+        dRdX += point.getPartialDiX();\n       }\n       return dRdX / points.size();\n     }\n \n     public double getPartialRadiusY() {\n       double dRdY = 0;\n-      for (Iterator iterator = points.iterator(); iterator.hasNext();) {\n-        dRdY += ((PointModel) iterator.next()).getPartialDiY();\n+      for (PointModel point : points) {\n+        dRdY += point.getPartialDiY();\n       }\n       return dRdY / points.size();\n     }\n \n    public double getRadius() {\n       double r = 0;\n-      for (Iterator iterator = points.iterator(); iterator.hasNext();) {\n-        r += ((PointModel) iterator.next()).getCenterDistance();\n+      for (PointModel point : points) {\n+        r += point.getCenterDistance();\n       }\n       return r / points.size();\n     }\n \n     private EstimatedParameter cx;\n     private EstimatedParameter cy;\n-    private ArrayList points;\n-\n-  }\n-  public class QuadraticProblem extends SimpleEstimationProblem {\n+    private ArrayList<PointModel> points;\n+\n+  }\n+\n+  private static class QuadraticProblem extends SimpleEstimationProblem {\n \n       private EstimatedParameter a;\n       private EstimatedParameter b;\n--- a/src/test/org/apache/commons/math/fraction/FractionTest.java\n+++ b/src/test/org/apache/commons/math/fraction/FractionTest.java\n         Fraction nullFraction = null;\n         assertTrue( zero.equals(zero));\n         assertFalse(zero.equals(nullFraction));\n-        assertFalse(zero.equals(new Double(0)));\n+        assertFalse(zero.equals(Double.valueOf(0)));\n         Fraction zero2 = new Fraction(0,2);\n         assertTrue(zero.equals(zero2));\n         assertEquals(zero.hashCode(), zero2.hashCode());\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/geometry/FrenchVector3DFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import java.util.Locale;\n+\n+\n+public class FrenchVector3DFormatTest extends Vector3DFormatAbstractTest {\n+    \n+    protected char getDecimalCharacter() {\n+        return ',';\n+    }\n+    \n+    protected Locale getLocale() {\n+        return Locale.FRENCH;\n+    }\n+}\n--- a/src/test/org/apache/commons/math/geometry/RotationTest.java\n+++ b/src/test/org/apache/commons/math/geometry/RotationTest.java\n import org.apache.commons.math.geometry.Rotation;\n import org.apache.commons.math.geometry.RotationOrder;\n import org.apache.commons.math.geometry.Vector3D;\n+import org.apache.commons.math.util.MathUtils;\n \n import junit.framework.*;\n \n \n   public void testIdentity() {\n \n-    Rotation r = new Rotation();\n-    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);\n-    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);\n-    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);\n+    Rotation r = Rotation.IDENTITY;\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);\n     checkAngle(r.getAngle(), 0);\n \n     r = new Rotation(-1, 0, 0, 0, false);\n-    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);\n-    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);\n-    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);\n     checkAngle(r.getAngle(), 0);\n \n     r = new Rotation(42, 0, 0, 0, true);\n-    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);\n-    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);\n-    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);\n     checkAngle(r.getAngle(), 0);\n \n   }\n   public void testAxisAngle() {\n \n     Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * Math.PI / 3);\n-    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusJ);\n-    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusK);\n-    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusI);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_J);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_K);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_I);\n     double s = 1 / Math.sqrt(3);\n     checkVector(r.getAxis(), new Vector3D(s, s, s));\n     checkAngle(r.getAngle(), 2 * Math.PI / 3);\n       fail(\"unexpected exception\");\n     }\n \n-    r = new Rotation(Vector3D.plusK, 1.5 * Math.PI);\n+    r = new Rotation(Vector3D.PLUS_K, 1.5 * Math.PI);\n     checkVector(r.getAxis(), new Vector3D(0, 0, -1));\n     checkAngle(r.getAngle(), 0.5 * Math.PI);\n \n-    r = new Rotation(Vector3D.plusJ, Math.PI);\n-    checkVector(r.getAxis(), Vector3D.plusJ);\n+    r = new Rotation(Vector3D.PLUS_J, Math.PI);\n+    checkVector(r.getAxis(), Vector3D.PLUS_J);\n     checkAngle(r.getAngle(), Math.PI);\n \n-    checkVector(new Rotation().getAxis(), Vector3D.plusI);\n+    checkVector(Rotation.IDENTITY.getAxis(), Vector3D.PLUS_I);\n \n   }\n \n     checkAngle(new Rotation(u, u.negate()).getAngle(), Math.PI);\n \n     try {\n-        new Rotation(u, new Vector3D());\n+        new Rotation(u, Vector3D.ZERO);\n         fail(\"an exception should have been thrown\");\n       } catch (IllegalArgumentException e) {\n         // expected behavior\n     Vector3D v1 = new Vector3D(0, 0, 2);\n     Vector3D v2 = new Vector3D(-2, 0, 2);\n     Rotation r = new Rotation(u1, u2, v1, v2);\n-    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);\n-    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.minusI);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.MINUS_I);\n \n     r = new Rotation(u1, u2, u1.negate(), u2.negate());\n     Vector3D axis = r.getAxis();\n-    if (Vector3D.dotProduct(axis, Vector3D.plusK) > 0) {\n-      checkVector(axis, Vector3D.plusK);\n+    if (Vector3D.dotProduct(axis, Vector3D.PLUS_K) > 0) {\n+      checkVector(axis, Vector3D.PLUS_K);\n     } else {\n-      checkVector(axis, Vector3D.minusK);\n+      checkVector(axis, Vector3D.MINUS_K);\n     }\n     checkAngle(r.getAngle(), Math.PI);\n \n     double sqrt = Math.sqrt(2) / 2;\n-    r = new Rotation(Vector3D.plusI,  Vector3D.plusJ,\n+    r = new Rotation(Vector3D.PLUS_I,  Vector3D.PLUS_J,\n                      new Vector3D(0.5, 0.5,  sqrt),\n                      new Vector3D(0.5, 0.5, -sqrt));\n     checkRotation(r, sqrt, 0.5, 0.5, 0);\n     checkRotation(new Rotation(u1, u2, u1, u2), 1, 0, 0, 0);\n \n     try {\n-        new Rotation(u1, u2, new Vector3D(), v2);\n+        new Rotation(u1, u2, Vector3D.ZERO, v2);\n         fail(\"an exception should have been thrown\");\n     } catch (IllegalArgumentException e) {\n       // expected behavior\n                       { 0.0, 0.0, 1.0 },\n                       { 1.0, 0.0, 0.0 } };\n     Rotation r = new Rotation(m1, 1.0e-7);\n-    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);\n-    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusI);\n-    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusJ);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_I);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_J);\n \n     double[][] m2 = { { 0.83203, -0.55012, -0.07139 },\n                       { 0.48293,  0.78164, -0.39474 },\n       }\n     }\n \n-    checkVector(r.applyTo(Vector3D.plusI),\n+    checkVector(r.applyTo(Vector3D.PLUS_I),\n                 new Vector3D(m3[0][0], m3[1][0], m3[2][0]));\n-    checkVector(r.applyTo(Vector3D.plusJ),\n+    checkVector(r.applyTo(Vector3D.PLUS_J),\n                 new Vector3D(m3[0][1], m3[1][1], m3[2][1]));\n-    checkVector(r.applyTo(Vector3D.plusK),\n+    checkVector(r.applyTo(Vector3D.PLUS_K),\n                 new Vector3D(m3[0][2], m3[1][2], m3[2][2]));\n \n     double[][] m4 = { { 1.0,  0.0,  0.0 },\n       }\n     }\n \n-    r = new Rotation();\n+    r = Rotation.IDENTITY;\n     for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n       for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n           Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),\n       }\n     }\n \n-    r = new Rotation(Vector3D.plusK, Math.PI);\n+    r = new Rotation(Vector3D.PLUS_K, Math.PI);\n     for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n       for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n           Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),\n   }\n \n   private void checkAngle(double a1, double a2) {\n-    a2 -= 2 * Math.PI * Math.floor((a2 + Math.PI - a1) / (2 * Math.PI));\n-    assertTrue(Math.abs(a1 - a2) < 1.0e-10);\n+    assertEquals(a1, MathUtils.normalizeAngle(a2, a1), 1.0e-10);\n   }\n \n   private void checkRotation(Rotation r, double q0, double q1, double q2, double q3) {\n-    Rotation reference = new Rotation(q0, q1, q2, q3, false);\n-    assertEquals(0, r.applyInverseTo(reference).getAngle(), 1.0e-12);\n+    assertEquals(0, Rotation.distance(r, new Rotation(q0, q1, q2, q3, false)), 1.0e-12);\n   }\n \n   public static Test suite() {\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/geometry/Vector3DFormatAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.math.util.CompositeFormat;\n+\n+public abstract class Vector3DFormatAbstractTest extends TestCase {\n+ \n+    Vector3DFormat vector3DFormat = null;\n+    Vector3DFormat vector3DFormatSquare = null;\n+\n+    protected abstract Locale getLocale();\n+\n+    protected abstract char getDecimalCharacter();\n+    \n+    protected void setUp() throws Exception {\n+        vector3DFormat = Vector3DFormat.getInstance(getLocale());\n+        final NumberFormat nf = NumberFormat.getInstance(getLocale());\n+        nf.setMaximumFractionDigits(2);\n+        vector3DFormatSquare = new Vector3DFormat(\"[\", \"]\", \" : \", nf);\n+    }\n+   \n+    public void testSimpleNoDecimals() {\n+        Vector3D c = new Vector3D(1, 1, 1);\n+        String expected = \"{1; 1; 1}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testSimpleWithDecimals() {\n+        Vector3D c = new Vector3D(1.23, 1.43, 1.63);\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testSimpleWithDecimalsTrunc() {\n+        Vector3D c = new Vector3D(1.2323, 1.4343, 1.6333);\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeX() {\n+        Vector3D c = new Vector3D(-1.2323, 1.4343, 1.6333);\n+        String expected =\n+            \"{-1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeY() {\n+        Vector3D c = new Vector3D(1.2323, -1.4343, 1.6333);\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; -1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeZ() {\n+        Vector3D c = new Vector3D(1.2323, 1.4343, -1.6333);\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; -1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNonDefaultSetting() {\n+        Vector3D c = new Vector3D(1, 1, 1);\n+        String expected = \"[1 : 1 : 1]\";\n+        String actual = vector3DFormatSquare.format(c); \n+        assertEquals(expected, actual);\n+    }\n+    \n+    public void testStaticFormatVector3D() {\n+        Locale defaultLocal = Locale.getDefault();\n+        Locale.setDefault(getLocale());\n+        \n+        Vector3D c = new Vector3D(232.222, -342.33, 432.444);\n+        String expected =\n+            \"{232\"    + getDecimalCharacter() +\n+            \"22; -342\" + getDecimalCharacter() +\n+            \"33; 432\" + getDecimalCharacter() +\n+            \"44}\";\n+        String actual = Vector3DFormat.formatVector3D(c); \n+        assertEquals(expected, actual);\n+        \n+        Locale.setDefault(defaultLocal);\n+    }\n+\n+    public void testNan() {\n+        Vector3D c = Vector3D.NaN;\n+        String expected = \"{(NaN); (NaN); (NaN)}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testPositiveInfinity() {\n+        Vector3D c = Vector3D.POSITIVE_INFINITY;\n+        String expected = \"{(Infinity); (Infinity); (Infinity)}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void tesNegativeInfinity() {\n+        Vector3D c = Vector3D.NEGATIVE_INFINITY;\n+        String expected = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n+        String actual = vector3DFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testParseSimpleNoDecimals() {\n+        String source = \"{1; 1; 1}\";\n+        Vector3D expected = new Vector3D(1, 1, 1);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseIgnoredWhitespace() {\n+        Vector3D expected = new Vector3D(1, 1, 1);\n+        ParsePosition pos1 = new ParsePosition(0);\n+        String source1 = \"{1;1;1}\";\n+        assertEquals(expected, vector3DFormat.parseObject(source1, pos1));\n+        assertEquals(source1.length(), pos1.getIndex());\n+        ParsePosition pos2 = new ParsePosition(0);\n+        String source2 = \" { 1 ; 1 ; 1 } \";\n+        assertEquals(expected, vector3DFormat.parseObject(source2, pos2));\n+        assertEquals(source2.length() - 1, pos2.getIndex());\n+    }\n+\n+    public void testParseSimpleWithDecimals() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        Vector3D expected = new Vector3D(1.23, 1.43, 1.63);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseSimpleWithDecimalsTrunc() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeX() {\n+        String source =\n+            \"{-1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(-1.2323, 1.4343, 1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeY() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; -1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(1.2323, -1.4343, 1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeZ() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; -1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(1.2323, 1.4343, -1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeAll() {\n+        String source =\n+            \"{-1\" + getDecimalCharacter() +\n+            \"2323; -1\" + getDecimalCharacter() +\n+            \"4343; -1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(-1.2323, -1.4343, -1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseZeroX() {\n+        String source =\n+            \"{0\" + getDecimalCharacter() +\n+            \"0; -1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(0.0, -1.4343, 1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNonDefaultSetting() {\n+        String source =\n+            \"[1\" + getDecimalCharacter() +\n+            \"2323 : 1\" + getDecimalCharacter() +\n+            \"4343 : 1\" + getDecimalCharacter() +\n+            \"6333]\";\n+        Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormatSquare.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseNan() {\n+        String source = \"{(NaN); (NaN); (NaN)}\";\n+        try {\n+            Vector3D actual = (Vector3D) vector3DFormat.parseObject(source); \n+            assertEquals(Vector3D.NaN, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParsePositiveInfinity() {\n+        String source = \"{(Infinity); (Infinity); (Infinity)}\";\n+        try {\n+            Vector3D actual = (Vector3D)vector3DFormat.parseObject(source); \n+            assertEquals(Vector3D.POSITIVE_INFINITY, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeInfinity() {\n+        String source = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n+        try {\n+            Vector3D actual = (Vector3D)vector3DFormat.parseObject(source); \n+            assertEquals(Vector3D.NEGATIVE_INFINITY, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testConstructorSingleFormat() {\n+        NumberFormat nf = NumberFormat.getInstance();\n+        Vector3DFormat cf = new Vector3DFormat(nf);\n+        assertNotNull(cf);\n+        assertEquals(nf, cf.getFormat());\n+    }\n+    \n+    public void testFormatObject() {\n+        try {\n+            CompositeFormat cf = new Vector3DFormat();\n+            Object object = new Object();\n+            cf.format(object);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+\n+    public void testForgottenPrefix() {\n+        ParsePosition pos = new ParsePosition(0);\n+        assertNull(new Vector3DFormat().parse(\"1; 1; 1}\", pos));\n+        assertEquals(0, pos.getErrorIndex());\n+    }\n+\n+    public void testForgottenSeparator() {\n+        ParsePosition pos = new ParsePosition(0);\n+        assertNull(new Vector3DFormat().parse(\"{1; 1 1}\", pos));\n+        assertEquals(6, pos.getErrorIndex());\n+    }\n+\n+    public void testForgottenSuffix() {\n+        ParsePosition pos = new ParsePosition(0);\n+        assertNull(new Vector3DFormat().parse(\"{1; 1; 1 \", pos));\n+        assertEquals(8, pos.getErrorIndex());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/geometry/Vector3DFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import java.util.Locale;\n+\n+\n+public class Vector3DFormatTest extends Vector3DFormatAbstractTest {\n+    protected char getDecimalCharacter() {\n+        return '.';\n+    }\n+    \n+    protected Locale getLocale() {\n+        return Locale.US;\n+    }\n+}\n--- a/src/test/org/apache/commons/math/geometry/Vector3DTest.java\n+++ b/src/test/org/apache/commons/math/geometry/Vector3DTest.java\n       double r = Math.sqrt(2) /2;\n       checkVector(new Vector3D(2, new Vector3D(Math.PI / 3, -Math.PI / 4)),\n                   r, r * Math.sqrt(3), -2 * r);\n-      checkVector(new Vector3D(2, Vector3D.plusI,\n-                              -3, Vector3D.minusK),\n+      checkVector(new Vector3D(2, Vector3D.PLUS_I,\n+                              -3, Vector3D.MINUS_K),\n                   2, 0, 3);\n-      checkVector(new Vector3D(2, Vector3D.plusI,\n-                               5, Vector3D.plusJ,\n-                              -3, Vector3D.minusK),\n+      checkVector(new Vector3D(2, Vector3D.PLUS_I,\n+                               5, Vector3D.PLUS_J,\n+                              -3, Vector3D.MINUS_K),\n                   2, 5, 3);\n-      checkVector(new Vector3D(2, Vector3D.plusI,\n-                               5, Vector3D.plusJ,\n-                               5, Vector3D.minusJ,\n-                               -3, Vector3D.minusK),\n+      checkVector(new Vector3D(2, Vector3D.PLUS_I,\n+                               5, Vector3D.PLUS_J,\n+                               5, Vector3D.MINUS_J,\n+                               -3, Vector3D.MINUS_K),\n                   2, 0, 3);\n   }\n \n   }\n   \n   public void testNorm() {\n-    assertTrue(Math.abs(new Vector3D().getNorm()) < 1.0e-12);\n+    assertTrue(Math.abs(Vector3D.ZERO.getNorm()) < 1.0e-12);\n     assertTrue(Math.abs(new Vector3D(1, 2, 3).getNorm() - Math.sqrt(14))\n                < 1.0e-12);\n   }\n \n   public void testAngular() {\n \n-    assertEquals(0,           Vector3D.plusI.getAlpha(), 1.0e-10);\n-    assertEquals(0,           Vector3D.plusI.getDelta(), 1.0e-10);\n-    assertEquals(Math.PI / 2, Vector3D.plusJ.getAlpha(), 1.0e-10);\n-    assertEquals(0,           Vector3D.plusJ.getDelta(), 1.0e-10);\n-    assertEquals(0,           Vector3D.plusK.getAlpha(), 1.0e-10);\n-    assertEquals(Math.PI / 2, Vector3D.plusK.getDelta(), 1.0e-10);\n+    assertEquals(0,           Vector3D.PLUS_I.getAlpha(), 1.0e-10);\n+    assertEquals(0,           Vector3D.PLUS_I.getDelta(), 1.0e-10);\n+    assertEquals(Math.PI / 2, Vector3D.PLUS_J.getAlpha(), 1.0e-10);\n+    assertEquals(0,           Vector3D.PLUS_J.getDelta(), 1.0e-10);\n+    assertEquals(0,           Vector3D.PLUS_K.getAlpha(), 1.0e-10);\n+    assertEquals(Math.PI / 2, Vector3D.PLUS_K.getDelta(), 1.0e-10);\n \n     Vector3D u = new Vector3D(-1, 1, -1);\n     assertEquals(3 * Math.PI /4, u.getAlpha(), 1.0e-10);\n   public void testNormalize() {\n     assertEquals(1.0, new Vector3D(5, -4, 2).normalize().getNorm(), 1.0e-12);\n     try {\n-        new Vector3D().normalize();\n+        Vector3D.ZERO.normalize();\n         fail(\"an exception should have been thrown\");\n     } catch (ArithmeticException ae) {\n         // expected behavior\n                   Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(-2, -4, -6.000001)),\n                   1.0e-12);\n      try {\n-         Vector3D.angle(new Vector3D(), Vector3D.plusI);\n+         Vector3D.angle(Vector3D.ZERO, Vector3D.PLUS_I);\n          fail(\"an exception should have been thrown\");\n      } catch (ArithmeticException ae) {\n          // expected behavior\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/BiDiagonalTransformerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class BiDiagonalTransformerTest extends TestCase {\n+\n+    private double[][] testSquare = {\n+            { 24.0 / 25.0, 43.0 / 25.0 },\n+            { 57.0 / 25.0, 24.0 / 25.0 }\n+    };\n+\n+    private double[][] testNonSquare = {\n+        {  -540.0 / 625.0,  963.0 / 625.0, -216.0 / 625.0 },\n+        { -1730.0 / 625.0, -744.0 / 625.0, 1008.0 / 625.0 },\n+        {  -720.0 / 625.0, 1284.0 / 625.0, -288.0 / 625.0 },\n+        {  -360.0 / 625.0,  192.0 / 625.0, 1756.0 / 625.0 },\n+    };\n+\n+    public BiDiagonalTransformerTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testDimensions() {\n+        checkdimensions(new RealMatrixImpl(testSquare, false));\n+        checkdimensions(new RealMatrixImpl(testNonSquare, false));\n+        checkdimensions(new RealMatrixImpl(testNonSquare, false).transpose());\n+    }\n+\n+    private void checkdimensions(RealMatrix matrix) {\n+        final int m = matrix.getRowDimension();\n+        final int n = matrix.getColumnDimension();\n+        BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix);\n+        assertEquals(m, transformer.getU().getRowDimension());\n+        assertEquals(m, transformer.getU().getColumnDimension());\n+        assertEquals(m, transformer.getB().getRowDimension());\n+        assertEquals(n, transformer.getB().getColumnDimension());\n+        assertEquals(n, transformer.getV().getRowDimension());\n+        assertEquals(n, transformer.getV().getColumnDimension());\n+\n+    }\n+\n+    public void testAEqualUSVt() {\n+        checkAEqualUSVt(new RealMatrixImpl(testSquare, false));\n+        checkAEqualUSVt(new RealMatrixImpl(testNonSquare, false));\n+        checkAEqualUSVt(new RealMatrixImpl(testNonSquare, false).transpose());\n+    }\n+\n+    private void checkAEqualUSVt(RealMatrix matrix) {\n+        BiDiagonalTransformer transformer = new BiDiagonalTransformer(matrix);\n+        RealMatrix u = transformer.getU();\n+        RealMatrix b = transformer.getB();\n+        RealMatrix v = transformer.getV();\n+        double norm = u.multiply(b).multiply(v.transpose()).subtract(matrix).getNorm();\n+        assertEquals(0, norm, 1.0e-14);\n+    }\n+\n+    public void testUOrthogonal() {\n+        checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).getU());\n+        checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).getU());\n+        checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).getU());\n+    }\n+\n+    public void testVOrthogonal() {\n+        checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).getV());\n+        checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).getV());\n+        checkOrthogonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).getV());\n+    }\n+\n+    private void checkOrthogonal(RealMatrix m) {\n+        RealMatrix mTm = m.transpose().multiply(m);\n+        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());\n+        assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-14);        \n+    }\n+\n+    public void testBBiDiagonal() {\n+        checkBiDiagonal(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).getB());\n+        checkBiDiagonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).getB());\n+        checkBiDiagonal(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).getB());\n+    }\n+\n+    private void checkBiDiagonal(RealMatrix m) {\n+        final int rows = m.getRowDimension();\n+        final int cols = m.getColumnDimension();\n+        for (int i = 0; i < rows; ++i) {\n+            for (int j = 0; j < cols; ++j) {\n+                if (rows < cols) {\n+                    if ((i < j) || (i > j + 1)) {\n+                        assertEquals(0, m.getEntry(i, j), 1.0e-16);\n+                    }                    \n+                } else {\n+                    if ((i < j - 1) || (i > j)) {\n+                        assertEquals(0, m.getEntry(i, j), 1.0e-16);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public void testMatricesValues() {\n+       BiDiagonalTransformer transformer =\n+            new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false));\n+       final double s17 = Math.sqrt(17.0);\n+        RealMatrix uRef = new RealMatrixImpl(new double[][] {\n+                {  -8 / (5 * s17), 19 / (5 * s17) },\n+                { -19 / (5 * s17), -8 / (5 * s17) }\n+        });\n+        RealMatrix bRef = new RealMatrixImpl(new double[][] {\n+                { -3 * s17 / 5, 32 * s17 / 85 },\n+                {      0.0,     -5 * s17 / 17 }\n+        });\n+        RealMatrix vRef = new RealMatrixImpl(new double[][] {\n+                { 1.0,  0.0 },\n+                { 0.0, -1.0 }\n+        });\n+\n+        // check values against known references\n+        RealMatrix u = transformer.getU();\n+        assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-14);\n+        RealMatrix b = transformer.getB();\n+        assertEquals(0, b.subtract(bRef).getNorm(), 1.0e-14);\n+        RealMatrix v = transformer.getV();\n+        assertEquals(0, v.subtract(vRef).getNorm(), 1.0e-14);\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(u == transformer.getU());\n+        assertTrue(b == transformer.getB());\n+        assertTrue(v == transformer.getV());\n+        \n+    }\n+\n+    public void testUpperOrLower() {\n+        assertTrue(new BiDiagonalTransformer(new RealMatrixImpl(testSquare, false)).isUpperBiDiagonal());\n+        assertTrue(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false)).isUpperBiDiagonal());\n+        assertFalse(new BiDiagonalTransformer(new RealMatrixImpl(testNonSquare, false).transpose()).isUpperBiDiagonal());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(BiDiagonalTransformerTest.class);\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/math/linear/BigMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/BigMatrixImplTest.java\n     \n     /** test copy functions */\n     public void testCopyFunctions() {\n-        BigMatrixImpl m = new BigMatrixImpl(testData);\n-        BigMatrixImpl m2 = new BigMatrixImpl(m.getData());\n-        assertEquals(m2,m);\n+        BigMatrixImpl m1 = new BigMatrixImpl(testData);\n+        BigMatrixImpl m2 = new BigMatrixImpl(m1.getData());\n+        assertEquals(m2,m1);\n+        BigMatrixImpl m3 = new BigMatrixImpl(testData);\n+        BigMatrixImpl m4 = new BigMatrixImpl(m3.getData(), false);\n+        assertEquals(m4,m3);\n     }\n     \n     /** test constructors */\n         BigMatrix m1 = new BigMatrixImpl(testData);\n         BigMatrix m2 = new BigMatrixImpl(testDataString);\n         BigMatrix m3 = new BigMatrixImpl(asBigDecimal(testData));\n+        BigMatrix m4 = new BigMatrixImpl(asBigDecimal(testData), true);\n+        BigMatrix m5 = new BigMatrixImpl(asBigDecimal(testData), false);\n         assertClose(\"double, string\", m1, m2, Double.MIN_VALUE);\n         assertClose(\"double, BigDecimal\", m1, m3, Double.MIN_VALUE);\n         assertClose(\"string, BigDecimal\", m2, m3, Double.MIN_VALUE);\n+        assertClose(\"double, BigDecimal/true\", m1, m4, Double.MIN_VALUE);\n+        assertClose(\"double, BigDecimal/false\", m1, m5, Double.MIN_VALUE);\n         try {\n             new BigMatrixImpl(new String[][] {{\"0\", \"hello\", \"1\"}});\n             fail(\"Expecting NumberFormatException\");\n     public void testAdd() {\n         BigMatrixImpl m = new BigMatrixImpl(testData);\n         BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);\n-        BigMatrixImpl mPlusMInv = (BigMatrixImpl)m.add(mInv);\n+        BigMatrix mPlusMInv = m.add(mInv);\n         double[][] sumEntries = asDouble(mPlusMInv.getData());\n         for (int row = 0; row < m.getRowDimension(); row++) {\n             for (int col = 0; col < m.getColumnDimension(); col++) {\n         } catch (IllegalArgumentException ex) {\n             ;\n         }      \n+    }\n+\n+    /** test issue MATH-209 */\n+    public void testMath209() {\n+        BigMatrix a = new BigMatrixImpl(new BigDecimal[][] {\n+                { new BigDecimal(1), new BigDecimal(2) },\n+                { new BigDecimal(3), new BigDecimal(4) },\n+                { new BigDecimal(5), new BigDecimal(6) }\n+        }, false);\n+        BigDecimal[] b = a.operate(new BigDecimal[] { new BigDecimal(1), new BigDecimal(1) });\n+        assertEquals(a.getRowDimension(), b.length);\n+        assertEquals( 3.0, b[0].doubleValue(), 1.0e-12);\n+        assertEquals( 7.0, b[1].doubleValue(), 1.0e-12);\n+        assertEquals(11.0, b[2].doubleValue(), 1.0e-12);\n     }\n     \n     /** test transpose */\n         if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||\n                 lowerData.length != upperData.length\n                 || lowerData.length != lu.getRowDimension()) {\n-            throw new InvalidMatrixException(\"incorrect dimensions\");\n+            throw new InvalidMatrixException(\"incorrect dimensions\", null);\n         }    \n         int n = lu.getRowDimension();\n         for (int i = 0; i < n; i++) {\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class EigenDecompositionImplTest extends TestCase {\n+\n+    private double[] refValues;\n+    private RealMatrix matrix;\n+\n+    public EigenDecompositionImplTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(EigenDecompositionImplTest.class);\n+        suite.setName(\"EigenDecompositionImpl Tests\");\n+        return suite;\n+    }\n+\n+    public void testDimension1() {\n+        RealMatrix matrix =\n+            new RealMatrixImpl(new double[][] {\n+                                   { 1.5 }\n+                               }, false);\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        assertEquals(1.5, ed.getEigenvalue(0), 1.0e-15);\n+    }\n+\n+    public void testDimension2() {\n+        RealMatrix matrix =\n+            new RealMatrixImpl(new double[][] {\n+                                   {       59.0, 12.0 },\n+                                   { Double.NaN, 66.0 }\n+                               }, false);\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        assertEquals(75.0, ed.getEigenvalue(0), 1.0e-15);\n+        assertEquals(50.0, ed.getEigenvalue(1), 1.0e-15);\n+    }\n+\n+    public void testDimension3() {\n+        RealMatrix matrix =\n+            new RealMatrixImpl(new double[][] {\n+                                   {    39632.0,    -4824.0, -16560.0 },\n+                                   { Double.NaN,     8693.0,   7920.0 },\n+                                   { Double.NaN, Double.NaN,  17300.0 }\n+                               }, false);\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        assertEquals(50000.0, ed.getEigenvalue(0), 3.0e-11);\n+        assertEquals(12500.0, ed.getEigenvalue(1), 3.0e-11);\n+        assertEquals( 3125.0, ed.getEigenvalue(2), 3.0e-11);\n+    }\n+\n+    public void testDimension4WithSplit() {\n+        RealMatrix matrix =\n+            new RealMatrixImpl(new double[][] {\n+                                   {      0.784,     -0.288,       0.000,  0.000 },\n+                                   { Double.NaN,      0.616,       0.000,  0.000 },\n+                                   { Double.NaN, Double.NaN,       0.164, -0.048 },\n+                                   { Double.NaN, Double.NaN,  Double.NaN,  0.136 }\n+                               }, false);\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        assertEquals(1.0, ed.getEigenvalue(0), 1.0e-15);\n+        assertEquals(0.4, ed.getEigenvalue(1), 1.0e-15);\n+        assertEquals(0.2, ed.getEigenvalue(2), 1.0e-15);\n+        assertEquals(0.1, ed.getEigenvalue(3), 1.0e-15);\n+    }\n+\n+    public void testDimension4WithoutSplit() {\n+        RealMatrix matrix =\n+            new RealMatrixImpl(new double[][] {\n+                                   {  0.5608, -0.2016,  0.1152, -0.2976 },\n+                                   { -0.2016,  0.4432, -0.2304,  0.1152 },\n+                                   {  0.1152, -0.2304,  0.3088, -0.1344 },\n+                                   { -0.2976,  0.1152, -0.1344,  0.3872 }\n+                               }, false);\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        assertEquals(1.0, ed.getEigenvalue(0), 1.0e-15);\n+        assertEquals(0.4, ed.getEigenvalue(1), 1.0e-15);\n+        assertEquals(0.2, ed.getEigenvalue(2), 1.0e-15);\n+        assertEquals(0.1, ed.getEigenvalue(3), 1.0e-15);\n+    }\n+\n+    /** test dimensions */\n+    public void testDimensions() {\n+        final int m = matrix.getRowDimension();\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        assertEquals(m, ed.getV().getRowDimension());\n+        assertEquals(m, ed.getV().getColumnDimension());\n+        assertEquals(m, ed.getD().getColumnDimension());\n+        assertEquals(m, ed.getD().getColumnDimension());\n+        assertEquals(m, ed.getVT().getRowDimension());\n+        assertEquals(m, ed.getVT().getColumnDimension());\n+    }\n+\n+    /** test eigenvalues */\n+    public void testEigenvalues() {\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        double[] eigenValues = ed.getEigenvalues();\n+        assertEquals(refValues.length, eigenValues.length);\n+        for (int i = 0; i < refValues.length; ++i) {\n+            assertEquals(refValues[i], eigenValues[i], 3.0e-15);\n+        }\n+    }\n+\n+    /** test eigenvalues for a big matrix. */\n+    public void testBigMatrix() {\n+        Random r = new Random(17748333525117l);\n+        double[] bigValues = new double[200];\n+        for (int i = 0; i < bigValues.length; ++i) {\n+            bigValues[i] = 2 * r.nextDouble() - 1;\n+        }\n+        Arrays.sort(bigValues);\n+        EigenDecomposition ed = new EigenDecompositionImpl(createTestMatrix(r, bigValues));\n+        double[] eigenValues = ed.getEigenvalues();\n+        assertEquals(bigValues.length, eigenValues.length);\n+        for (int i = 0; i < bigValues.length; ++i) {\n+            assertEquals(bigValues[bigValues.length - i - 1], eigenValues[i], 2.0e-14);\n+        }\n+    }\n+\n+    /** test eigenvectors */\n+    public void testEigenvectors() {\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        for (int i = 0; i < matrix.getRowDimension(); ++i) {\n+            double lambda = ed.getEigenvalue(i);\n+            RealVector v  = ed.getEigenvector(i);\n+            RealVector mV = matrix.operate(v);\n+            assertEquals(0, mV.subtract(v.mapMultiplyToSelf(lambda)).getNorm(), 1.0e-13);\n+        }\n+    }\n+\n+    /** test A = VDVt */\n+    public void testAEqualVDVt() {\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        RealMatrix v  = ed.getV();\n+        RealMatrix d  = ed.getD();\n+        RealMatrix vT = ed.getVT();\n+        double norm = v.multiply(d).multiply(vT).subtract(matrix).getNorm();\n+        assertEquals(0, norm, 6.0e-13);\n+    }\n+\n+    /** test that V is orthogonal */\n+    public void testVOrthogonal() {\n+        RealMatrix v = new EigenDecompositionImpl(matrix).getV();\n+        RealMatrix vTv = v.transpose().multiply(v);\n+        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(vTv.getRowDimension());\n+        assertEquals(0, vTv.subtract(id).getNorm(), 2.0e-13);\n+    }\n+\n+    /** test solve dimension errors */\n+    public void testSolveDimensionErrors() {\n+        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n+        try {\n+            ed.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            ed.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            ed.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve */\n+    public void testSolve() {\n+        RealMatrix m = new RealMatrixImpl(new double[][] {\n+                { 91,  5, 29, 32, 40, 14 },\n+                {  5, 34, -1,  0,  2, -1 },\n+                { 29, -1, 12,  9, 21,  8 },\n+                { 32,  0,  9, 14,  9,  0 },\n+                { 40,  2, 21,  9, 51, 19 },\n+                { 14, -1,  8,  0, 19, 14 }\n+        });\n+        EigenDecomposition ed = new EigenDecompositionImpl(m);\n+        assertEquals(184041, ed.getDeterminant(), 2.0e-8);\n+        RealMatrix b = new RealMatrixImpl(new double[][] {\n+                { 1561, 269, 188 },\n+                {   69, -21,  70 },\n+                {  739, 108,  63 },\n+                {  324,  86,  59 },\n+                { 1624, 194, 107 },\n+                {  796,  69,  36 }\n+        });\n+        RealMatrix xRef = new RealMatrixImpl(new double[][] {\n+                { 1,   2, 1 },\n+                { 2,  -1, 2 },\n+                { 4,   2, 3 },\n+                { 8,  -1, 0 },\n+                { 16,  2, 0 },\n+                { 32, -1, 0 }\n+        });\n+\n+        // using RealMatrix\n+        assertEquals(0, ed.solve(b).subtract(xRef).getNorm(), 2.0e-12);\n+\n+        // using double[]\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         new RealVectorImpl(ed.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         2.0e-11);\n+        }\n+\n+        // using RealMatrixImpl\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         ed.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         2.0e-11);\n+        }\n+\n+        // using RealMatrix with an alternate implementation\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            RealVectorImplTest.RealVectorTestImpl v =\n+                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n+            assertEquals(0,\n+                         ed.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         2.0e-11);\n+        }\n+\n+    }\n+    \n+    /**\n+     * Matrix with eigenvalues {8, -1, -1}\n+     */\n+    public void testRepeatedEigenvalue() {\n+        RealMatrix repeated = new RealMatrixImpl(new double[][] {\n+                {3,  2,  4},\n+                {2,  0,  2},\n+                {4,  2,  3}\n+        }); \n+        EigenDecomposition ed = new EigenDecompositionImpl(repeated);\n+        checkEigenValues((new double[] {8, -1, -1}), ed, 1E-12);\n+        checkEigenVector((new double[] {2, 1, 2}), ed, 1E-12);\n+    }\n+    \n+    /**\n+     * Matrix with eigenvalues {2, 0, 12}\n+     */\n+    public void testDistinctEigenvalues() {\n+        RealMatrix distinct = new RealMatrixImpl(new double[][] {\n+                {3, 1, -4},  \n+                {1, 3, -4}, \n+                {-4, -4, 8}\n+        });\n+        EigenDecomposition ed = new EigenDecompositionImpl(distinct);\n+        checkEigenValues((new double[] {2, 0, 12}), ed, 1E-12);\n+        checkEigenVector((new double[] {1, -1, 0}), ed, 1E-12);\n+        checkEigenVector((new double[] {1, 1, 1}), ed, 1E-12);\n+        checkEigenVector((new double[] {-1, -1, 2}), ed, 1E-12);\n+    }\n+    \n+    /**\n+     * Verifies that the given EigenDecomposition has eigenvalues equivalent to\n+     * the targetValues, ignoring the order of the values and allowing\n+     * values to differ by tolerance.\n+     */\n+    protected void checkEigenValues(double[] targetValues,\n+            EigenDecomposition ed, double tolerance) {\n+        double[] observed = ed.getEigenvalues();\n+        for (int i = 0; i < observed.length; i++) {\n+            assertTrue(isIncludedValue(observed[i], targetValues, tolerance));\n+            assertTrue(isIncludedValue(targetValues[i], observed, tolerance));\n+        }\n+    }\n+    \n+    /**\n+     * Returns true iff there is an entry within tolerance of value in\n+     * searchArray.\n+     */\n+    private boolean isIncludedValue(double value, double[] searchArray,\n+            double tolerance) {\n+       boolean found = false;\n+       int i = 0;\n+       while (!found && i < searchArray.length) {\n+           if (Math.abs(value - searchArray[i]) < tolerance) {\n+               found = true;\n+           }\n+           i++;\n+       }\n+       return found;\n+    }\n+    \n+    /**\n+     * Returns true iff eigenVector is a scalar multiple of one of the columns\n+     * of ed.getV().  Does not try linear combinations - i.e., should only be\n+     * used to find vectors in one-dimensional eigenspaces.\n+     */\n+    protected void checkEigenVector(double[] eigenVector,\n+            EigenDecomposition ed, double tolerance) {\n+        assertTrue(isIncludedColumn(eigenVector, ed.getV(), tolerance));\n+    }\n+    \n+    /**\n+     * Returns true iff there is a column that is a scalar multiple of column\n+     * in searchMatrix (modulo tolerance)\n+     */\n+    private boolean isIncludedColumn(double[] column, RealMatrix searchMatrix,\n+            double tolerance) {\n+        boolean found = false;\n+        int i = 0;\n+        while (!found && i < searchMatrix.getColumnDimension()) {\n+            double multiplier = 1d;\n+            boolean matching = true;\n+            int j = 0;\n+            while (matching && j < searchMatrix.getRowDimension()) {\n+                double colEntry = searchMatrix.getEntry(j, i);\n+                // Use the first entry where both are non-zero as scalar\n+                if (multiplier == 1d && Math.abs(colEntry) > 1E-14\n+                        && Math.abs(column[j]) > 1e-14) {\n+                    multiplier = colEntry / column[j];\n+                } \n+                if (Math.abs(column[j] * multiplier - colEntry) > tolerance) {\n+                    matching = false;\n+                }\n+                j++;\n+            }\n+            found = matching;\n+            i++;\n+        }\n+        return found;\n+    }\n+\n+    public void setUp() {\n+        refValues = new double[] {\n+                2.003, 2.002, 2.001, 1.001, 1.000, 0.001\n+        };\n+        matrix = createTestMatrix(new Random(35992629946426l), refValues);\n+    }\n+\n+    public void tearDown() {\n+        refValues = null;\n+        matrix    = null;\n+    }\n+\n+    private RealMatrix createTestMatrix(final Random r, final double[] eigenValues) {\n+        final int n = eigenValues.length;\n+        final RealMatrix v = createOrthogonalMatrix(r, n);\n+        final RealMatrix d = createDiagonalMatrix(eigenValues, n, n);\n+        return v.multiply(d).multiply(v.transpose());\n+    }\n+\n+    public static RealMatrix createOrthogonalMatrix(final Random r, final int size) {\n+\n+        final double[][] data = new double[size][size];\n+\n+        for (int i = 0; i < size; ++i) {\n+            final double[] dataI = data[i];\n+            double norm2 = 0;\n+            do {\n+\n+                // generate randomly row I\n+                for (int j = 0; j < size; ++j) {\n+                    dataI[j] = 2 * r.nextDouble() - 1;\n+                }\n+\n+                // project the row in the subspace orthogonal to previous rows\n+                for (int k = 0; k < i; ++k) {\n+                    final double[] dataK = data[k];\n+                    double dotProduct = 0;\n+                    for (int j = 0; j < size; ++j) {\n+                        dotProduct += dataI[j] * dataK[j];\n+                    }\n+                    for (int j = 0; j < size; ++j) {\n+                        dataI[j] -= dotProduct * dataK[j];\n+                    }\n+                }\n+\n+                // normalize the row\n+                norm2 = 0;\n+                for (final double dataIJ : dataI) {\n+                    norm2 += dataIJ * dataIJ;\n+                }\n+                final double inv = 1.0 / Math.sqrt(norm2);\n+                for (int j = 0; j < size; ++j) {\n+                    dataI[j] *= inv;\n+                }\n+\n+            } while (norm2 * size < 0.01);\n+        }\n+\n+        return new RealMatrixImpl(data, false);\n+\n+    }\n+\n+    public static RealMatrix createDiagonalMatrix(final double[] diagonal,\n+                                                  final int rows, final int columns) {\n+        final double[][] dData = new double[rows][columns];\n+        for (int i = 0; i < Math.min(rows, columns); ++i) {\n+            dData[i][i] = diagonal[i];\n+        }\n+        return new RealMatrixImpl(dData, false);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/FrenchRealVectorFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Locale;\n+\n+\n+public class FrenchRealVectorFormatTest extends RealVectorFormatAbstractTest {\n+    \n+    protected char getDecimalCharacter() {\n+        return ',';\n+    }\n+    \n+    protected Locale getLocale() {\n+        return Locale.FRENCH;\n+    }\n+}\n--- a/src/test/org/apache/commons/math/linear/InvalidMatrixExceptionTest.java\n+++ b/src/test/org/apache/commons/math/linear/InvalidMatrixExceptionTest.java\n  * @version $Revision$ $Date$\n  */\n public class InvalidMatrixExceptionTest extends TestCase {\n-    /**\n-     * \n-     */\n-    public void testConstructor(){\n-        InvalidMatrixException ex = new InvalidMatrixException();\n-        assertNull(ex.getMessage());\n-    }\n     \n     /**\n      * \n      */\n     public void testConstructorMessage(){\n         String msg = \"message\";\n-        InvalidMatrixException ex = new InvalidMatrixException(msg);\n+        InvalidMatrixException ex = new InvalidMatrixException(msg, null);\n         assertEquals(msg, ex.getMessage());\n     }\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/LUDecompositionImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class LUDecompositionImplTest extends TestCase {\n+    private double[][] testData = {\n+            { 1.0, 2.0, 3.0},\n+            { 2.0, 5.0, 3.0},\n+            { 1.0, 0.0, 8.0}\n+    };\n+    private double[][] testDataMinus = {\n+            { -1.0, -2.0, -3.0},\n+            { -2.0, -5.0, -3.0},\n+            { -1.0,  0.0, -8.0}\n+    };\n+    private double[][] luData = {\n+            { 2.0, 3.0, 3.0 },\n+            { 0.0, 5.0, 7.0 },\n+            { 6.0, 9.0, 8.0 }\n+    };\n+    \n+    // singular matrices\n+    private double[][] singular = {\n+            { 2.0, 3.0 },\n+            { 2.0, 3.0 }\n+    };\n+    private double[][] bigSingular = {\n+            { 1.0, 2.0,   3.0,    4.0 },\n+            { 2.0, 5.0,   3.0,    4.0 },\n+            { 7.0, 3.0, 256.0, 1930.0 },\n+            { 3.0, 7.0,   6.0,    8.0 }\n+    }; // 4th row = 1st + 2nd\n+\n+    private static final double entryTolerance = 10e-16;\n+\n+    private static final double normTolerance = 10e-14;\n+\n+    public LUDecompositionImplTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(LUDecompositionImplTest.class);\n+        suite.setName(\"LUDecompositionImpl Tests\");\n+        return suite;\n+    }\n+\n+    /** test dimensions */\n+    public void testDimensions() {\n+        RealMatrixImpl matrix = new RealMatrixImpl(testData, false);\n+        LUDecomposition LU = new LUDecompositionImpl(matrix);\n+        assertEquals(testData.length, LU.getL().getRowDimension());\n+        assertEquals(testData.length, LU.getL().getColumnDimension());\n+        assertEquals(testData.length, LU.getU().getRowDimension());\n+        assertEquals(testData.length, LU.getU().getColumnDimension());\n+        assertEquals(testData.length, LU.getP().getRowDimension());\n+        assertEquals(testData.length, LU.getP().getColumnDimension());\n+\n+    }\n+\n+    /** test non-square matrix */\n+    public void testNonSquare() {\n+        try {\n+            new LUDecompositionImpl(new RealMatrixImpl(new double[3][2], false));\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test no call to decompose */\n+    public void testNoDecompose() {\n+        try {\n+            new LUDecompositionImpl().getPivot();\n+            fail(\"an exception should have been caught\");\n+        } catch (IllegalStateException ise) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test threshold impact */\n+    public void testThreshold() {\n+        final RealMatrix matrix = new RealMatrixImpl(new double[][] {\n+                                                       { 1.0, 2.0, 3.0},\n+                                                       { 2.0, 5.0, 3.0},\n+                                                       { 4.000001, 9.0, 9.0}\n+                                                     }, false);\n+        assertFalse(new LUDecompositionImpl(matrix, 1.0e-5).isNonSingular());\n+        assertTrue(new LUDecompositionImpl(matrix, 1.0e-10).isNonSingular());\n+    }\n+\n+    /** test PA = LU */\n+    public void testPAEqualLU() {\n+        RealMatrix matrix = new RealMatrixImpl(testData, false);\n+        LUDecomposition lu = new LUDecompositionImpl(matrix);\n+        RealMatrix l = lu.getL();\n+        RealMatrix u = lu.getU();\n+        RealMatrix p = lu.getP();\n+        double norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();\n+        assertEquals(0, norm, normTolerance);\n+\n+        matrix = new RealMatrixImpl(testDataMinus, false);\n+        lu = new LUDecompositionImpl(matrix);\n+        l = lu.getL();\n+        u = lu.getU();\n+        p = lu.getP();\n+        norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();\n+        assertEquals(0, norm, normTolerance);\n+\n+        matrix = MatrixUtils.createRealIdentityMatrix(17);\n+        lu = new LUDecompositionImpl(matrix);\n+        l = lu.getL();\n+        u = lu.getU();\n+        p = lu.getP();\n+        norm = l.multiply(u).subtract(p.multiply(matrix)).getNorm();\n+        assertEquals(0, norm, normTolerance);\n+\n+        matrix = new RealMatrixImpl(singular, false);\n+        lu = new LUDecompositionImpl(matrix);\n+        assertFalse(lu.isNonSingular());\n+        assertNull(lu.getL());\n+        assertNull(lu.getU());\n+        assertNull(lu.getP());\n+\n+        matrix = new RealMatrixImpl(bigSingular, false);\n+        lu = new LUDecompositionImpl(matrix);\n+        assertFalse(lu.isNonSingular());\n+        assertNull(lu.getL());\n+        assertNull(lu.getU());\n+        assertNull(lu.getP());\n+\n+    }\n+\n+    /** test that L is lower triangular with unit diagonal */\n+    public void testLLowerTriangular() {\n+        RealMatrixImpl matrix = new RealMatrixImpl(testData, false);\n+        RealMatrix l = new LUDecompositionImpl(matrix).getL();\n+        for (int i = 0; i < l.getRowDimension(); i++) {\n+            assertEquals(l.getEntry(i, i), 1, entryTolerance);\n+            for (int j = i + 1; j < l.getColumnDimension(); j++) {\n+                assertEquals(l.getEntry(i, j), 0, entryTolerance);\n+            }\n+        }\n+    }\n+\n+    /** test that U is upper triangular */\n+    public void testUUpperTriangular() {\n+        RealMatrixImpl matrix = new RealMatrixImpl(testData, false);\n+        RealMatrix u = new LUDecompositionImpl(matrix).getU();\n+        for (int i = 0; i < u.getRowDimension(); i++) {\n+            for (int j = 0; j < i; j++) {\n+                assertEquals(u.getEntry(i, j), 0, entryTolerance);\n+            }\n+        }\n+    }\n+\n+    /** test that P is a permutation matrix */\n+    public void testPPermutation() {\n+        RealMatrixImpl matrix = new RealMatrixImpl(testData, false);\n+        RealMatrix p   = new LUDecompositionImpl(matrix).getP();\n+\n+        RealMatrix ppT = p.multiply(p.transpose());\n+        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(p.getRowDimension());\n+        assertEquals(0, ppT.subtract(id).getNorm(), normTolerance);\n+\n+        for (int i = 0; i < p.getRowDimension(); i++) {\n+            int zeroCount  = 0;\n+            int oneCount   = 0;\n+            int otherCount = 0;\n+            for (int j = 0; j < p.getColumnDimension(); j++) {\n+                final double e = p.getEntry(i, j);\n+                if (e == 0) {\n+                    ++zeroCount;\n+                } else if (e == 1) {\n+                    ++oneCount;\n+                } else {\n+                    ++otherCount;\n+                }\n+            }\n+            assertEquals(p.getColumnDimension() - 1, zeroCount);\n+            assertEquals(1, oneCount);\n+            assertEquals(0, otherCount);\n+        }\n+\n+        for (int j = 0; j < p.getColumnDimension(); j++) {\n+            int zeroCount  = 0;\n+            int oneCount   = 0;\n+            int otherCount = 0;\n+            for (int i = 0; i < p.getRowDimension(); i++) {\n+                final double e = p.getEntry(i, j);\n+                if (e == 0) {\n+                    ++zeroCount;\n+                } else if (e == 1) {\n+                    ++oneCount;\n+                } else {\n+                    ++otherCount;\n+                }\n+            }\n+            assertEquals(p.getRowDimension() - 1, zeroCount);\n+            assertEquals(1, oneCount);\n+            assertEquals(0, otherCount);\n+        }\n+\n+    }\n+\n+\n+    /** test singular */\n+    public void testSingular() {\n+        LUDecomposition lu =\n+            new LUDecompositionImpl(new RealMatrixImpl(testData, false));\n+        assertTrue(lu.isNonSingular());\n+        lu = new LUDecompositionImpl(new RealMatrixImpl(singular, false));\n+        assertFalse(lu.isNonSingular());\n+        lu = new LUDecompositionImpl(new RealMatrixImpl(bigSingular, false));\n+        assertFalse(lu.isNonSingular());\n+    }\n+\n+    /** test solve dimension errors */\n+    public void testSolveDimensionErrors() {\n+        LUDecomposition lu =\n+            new LUDecompositionImpl(new RealMatrixImpl(testData, false));\n+        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n+        try {\n+            lu.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            lu.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            lu.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve singularity errors */\n+    public void testSolveSingularityErrors() {\n+        LUDecomposition lu =\n+            new LUDecompositionImpl(new RealMatrixImpl(singular, false));\n+        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n+        try {\n+            lu.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            lu.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            lu.solve(b.getColumnVector(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            lu.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve */\n+    public void testSolve() {\n+        LUDecomposition lu =\n+            new LUDecompositionImpl(new RealMatrixImpl(testData, false));\n+        RealMatrix b = new RealMatrixImpl(new double[][] {\n+                { 1, 0 }, { 2, -5 }, { 3, 1 }\n+        });\n+        RealMatrix xRef = new RealMatrixImpl(new double[][] {\n+                { 19, -71 }, { -6, 22 }, { -2, 9 }\n+        });\n+\n+        // using RealMatrix\n+        assertEquals(0, lu.solve(b).subtract(xRef).getNorm(), 1.0e-13);\n+\n+        // using double[]\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         new RealVectorImpl(lu.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealVectorImpl\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         lu.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealVector with an alternate implementation\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            RealVectorImplTest.RealVectorTestImpl v =\n+                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n+            assertEquals(0,\n+                         lu.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+    }\n+\n+    /** test matrices values */\n+    public void testMatricesValues1() {\n+       LUDecomposition lu =\n+            new LUDecompositionImpl(new RealMatrixImpl(testData, false));\n+        RealMatrix lRef = new RealMatrixImpl(new double[][] {\n+                { 1.0, 0.0, 0.0 },\n+                { 0.5, 1.0, 0.0 },\n+                { 0.5, 0.2, 1.0 }\n+        });\n+        RealMatrix uRef = new RealMatrixImpl(new double[][] {\n+                { 2.0,  5.0, 3.0 },\n+                { 0.0, -2.5, 6.5 },\n+                { 0.0,  0.0, 0.2 }\n+        });\n+        RealMatrix pRef = new RealMatrixImpl(new double[][] {\n+                { 0.0, 1.0, 0.0 },\n+                { 0.0, 0.0, 1.0 },\n+                { 1.0, 0.0, 0.0 }\n+        });\n+        int[] pivotRef = { 1, 2, 0 };\n+\n+        // check values against known references\n+        RealMatrix l = lu.getL();\n+        assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);\n+        RealMatrix u = lu.getU();\n+        assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);\n+        RealMatrix p = lu.getP();\n+        assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);\n+        int[] pivot = lu.getPivot();\n+        for (int i = 0; i < pivotRef.length; ++i) {\n+            assertEquals(pivotRef[i], pivot[i]);\n+        }\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(l == lu.getL());\n+        assertTrue(u == lu.getU());\n+        assertTrue(p == lu.getP());\n+        \n+    }\n+\n+    /** test matrices values */\n+    public void testMatricesValues2() {\n+       LUDecomposition lu =\n+            new LUDecompositionImpl(new RealMatrixImpl(luData, false));\n+        RealMatrix lRef = new RealMatrixImpl(new double[][] {\n+                {    1.0,    0.0, 0.0 },\n+                {    0.0,    1.0, 0.0 },\n+                { 1.0 / 3.0, 0.0, 1.0 }\n+        });\n+        RealMatrix uRef = new RealMatrixImpl(new double[][] {\n+                { 6.0, 9.0,    8.0    },\n+                { 0.0, 5.0,    7.0    },\n+                { 0.0, 0.0, 1.0 / 3.0 }\n+        });\n+        RealMatrix pRef = new RealMatrixImpl(new double[][] {\n+                { 0.0, 0.0, 1.0 },\n+                { 0.0, 1.0, 0.0 },\n+                { 1.0, 0.0, 0.0 }\n+        });\n+        int[] pivotRef = { 2, 1, 0 };\n+\n+        // check values against known references\n+        RealMatrix l = lu.getL();\n+        assertEquals(0, l.subtract(lRef).getNorm(), 1.0e-13);\n+        RealMatrix u = lu.getU();\n+        assertEquals(0, u.subtract(uRef).getNorm(), 1.0e-13);\n+        RealMatrix p = lu.getP();\n+        assertEquals(0, p.subtract(pRef).getNorm(), 1.0e-13);\n+        int[] pivot = lu.getPivot();\n+        for (int i = 0; i < pivotRef.length; ++i) {\n+            assertEquals(pivotRef[i], pivot[i]);\n+        }\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(l == lu.getL());\n+        assertTrue(u == lu.getU());\n+        assertTrue(p == lu.getP());\n+        \n+    }\n+\n+    /** test determinant */\n+    public void testDeterminant() {\n+        assertEquals(-1,\n+                     new LUDecompositionImpl(new RealMatrixImpl(testData, false)).getDeterminant(),\n+                     1.0e-15);\n+        assertEquals(-10,\n+                     new LUDecompositionImpl(new RealMatrixImpl(luData, false)).getDeterminant(),\n+                     1.0e-14);\n+        assertEquals(0,\n+                     new LUDecompositionImpl(new RealMatrixImpl(singular, false)).getDeterminant(),\n+                     1.0e-17);\n+        assertEquals(0,\n+                     new LUDecompositionImpl(new RealMatrixImpl(bigSingular, false)).getDeterminant(),\n+                     1.0e-17);\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/math/linear/MatrixIndexExceptionTest.java\n+++ b/src/test/org/apache/commons/math/linear/MatrixIndexExceptionTest.java\n      */\n     public void testConstructorMessage(){\n         String msg = \"message\";\n-        MatrixIndexException ex = new MatrixIndexException(msg);\n+        MatrixIndexException ex = new MatrixIndexException(msg, null);\n         assertEquals(msg, ex.getMessage());\n     }\n }\n--- a/src/test/org/apache/commons/math/linear/MatrixUtilsTest.java\n+++ b/src/test/org/apache/commons/math/linear/MatrixUtilsTest.java\n     public void testCreateRealMatrix() {\n         assertEquals(new RealMatrixImpl(testData), \n                 MatrixUtils.createRealMatrix(testData));\n+        assertEquals(new RealMatrixImpl(testData, false), \n+                MatrixUtils.createRealMatrix(testData, true));\n+        assertEquals(new RealMatrixImpl(testData, true), \n+                MatrixUtils.createRealMatrix(testData, false));\n         try {\n             MatrixUtils.createRealMatrix(new double[][] {{1}, {1,2}});  // ragged\n             fail(\"Expecting IllegalArgumentException\");\n     public void testCreateBigMatrix() {\n         assertEquals(new BigMatrixImpl(testData), \n                 MatrixUtils.createBigMatrix(testData));\n+        assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), true), \n+                MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), false));\n+        assertEquals(new BigMatrixImpl(BigMatrixImplTest.asBigDecimal(testData), false), \n+                MatrixUtils.createBigMatrix(BigMatrixImplTest.asBigDecimal(testData), true));\n         assertEquals(new BigMatrixImpl(bigColMatrix), \n                 MatrixUtils.createBigMatrix(bigColMatrix));\n         assertEquals(new BigMatrixImpl(stringColMatrix), \n--- a/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n \n     /** test dimensions */\n     public void testDimensions() {\n-        RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular);\n+        RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular, false);\n         QRDecomposition qr = new QRDecompositionImpl(matrix);\n         assertEquals(\"3x3 Q size\", qr.getQ().getRowDimension(), 3);\n         assertEquals(\"3x3 Q size\", qr.getQ().getColumnDimension(), 3);\n         assertEquals(\"3x3 R size\", qr.getR().getRowDimension(), 3);\n         assertEquals(\"3x3 R size\", qr.getR().getColumnDimension(), 3);\n \n-        matrix = new RealMatrixImpl(testData4x3);\n+        matrix = new RealMatrixImpl(testData4x3, false);\n         qr = new QRDecompositionImpl(matrix);\n         assertEquals(\"4x3 Q size\", qr.getQ().getRowDimension(), 4);\n         assertEquals(\"4x3 Q size\", qr.getQ().getColumnDimension(), 4);\n         assertEquals(\"4x3 R size\", qr.getR().getRowDimension(), 4);\n         assertEquals(\"4x3 R size\", qr.getR().getColumnDimension(), 3);\n \n-        matrix = new RealMatrixImpl(testData3x4);\n+        matrix = new RealMatrixImpl(testData3x4, false);\n         qr = new QRDecompositionImpl(matrix);\n         assertEquals(\"3x4 Q size\", qr.getQ().getRowDimension(), 3);\n         assertEquals(\"3x4 Q size\", qr.getQ().getColumnDimension(), 3);\n \n     /** test A = QR */\n     public void testAEqualQR() {\n-        RealMatrix A = new RealMatrixImpl(testData3x3NonSingular);\n+        RealMatrix A = new RealMatrixImpl(testData3x3NonSingular, false);\n         QRDecomposition qr = new QRDecompositionImpl(A);\n         RealMatrix Q = qr.getQ();\n         RealMatrix R = qr.getR();\n         double norm = Q.multiply(R).subtract(A).getNorm();\n         assertEquals(\"3x3 nonsingular A = QR\", 0, norm, normTolerance);\n \n-        RealMatrix matrix = new RealMatrixImpl(testData3x3Singular);\n+        RealMatrix matrix = new RealMatrixImpl(testData3x3Singular, false);\n         qr = new QRDecompositionImpl(matrix);\n         norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();\n         assertEquals(\"3x3 singular A = QR\", 0, norm, normTolerance);\n \n-        matrix = new RealMatrixImpl(testData3x4);\n+        matrix = new RealMatrixImpl(testData3x4, false);\n         qr = new QRDecompositionImpl(matrix);\n         norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();\n         assertEquals(\"3x4 A = QR\", 0, norm, normTolerance);\n \n-        matrix = new RealMatrixImpl(testData4x3);\n+        matrix = new RealMatrixImpl(testData4x3, false);\n         qr = new QRDecompositionImpl(matrix);\n         norm = qr.getQ().multiply(qr.getR()).subtract(matrix).getNorm();\n         assertEquals(\"4x3 A = QR\", 0, norm, normTolerance);\n \n     /** test the orthogonality of Q */\n     public void testQOrthogonal() {\n-        RealMatrix matrix = new RealMatrixImpl(testData3x3NonSingular);\n-        matrix = new QRDecompositionImpl(matrix).getQ();\n+        RealMatrix matrix = new RealMatrixImpl(testData3x3NonSingular, false);\n+        RealMatrix q  = new QRDecompositionImpl(matrix).getQ();\n+        RealMatrix qT = new QRDecompositionImpl(matrix).getQT();\n         RealMatrix eye = MatrixUtils.createRealIdentityMatrix(3);\n-        double norm = matrix.transpose().multiply(matrix).subtract(eye)\n-                .getNorm();\n+        double norm = qT.multiply(q).subtract(eye).getNorm();\n         assertEquals(\"3x3 nonsingular Q'Q = I\", 0, norm, normTolerance);\n \n-        matrix = new RealMatrixImpl(testData3x3Singular);\n-        matrix = new QRDecompositionImpl(matrix).getQ();\n+        matrix = new RealMatrixImpl(testData3x3Singular, false);\n+        q  = new QRDecompositionImpl(matrix).getQ();\n+        qT = new QRDecompositionImpl(matrix).getQT();\n         eye = MatrixUtils.createRealIdentityMatrix(3);\n-        norm = matrix.transpose().multiply(matrix).subtract(eye)\n-                .getNorm();\n+        norm = qT.multiply(q).subtract(eye).getNorm();\n         assertEquals(\"3x3 singular Q'Q = I\", 0, norm, normTolerance);\n \n-        matrix = new RealMatrixImpl(testData3x4);\n-        matrix = new QRDecompositionImpl(matrix).getQ();\n+        matrix = new RealMatrixImpl(testData3x4, false);\n+        q  = new QRDecompositionImpl(matrix).getQ();\n+        qT = new QRDecompositionImpl(matrix).getQT();\n         eye = MatrixUtils.createRealIdentityMatrix(3);\n-        norm = matrix.transpose().multiply(matrix).subtract(eye)\n-                .getNorm();\n+        norm = qT.multiply(q).subtract(eye).getNorm();\n         assertEquals(\"3x4 Q'Q = I\", 0, norm, normTolerance);\n \n-        matrix = new RealMatrixImpl(testData4x3);\n-        matrix = new QRDecompositionImpl(matrix).getQ();\n+        matrix = new RealMatrixImpl(testData4x3, false);\n+        q  = new QRDecompositionImpl(matrix).getQ();\n+        qT = new QRDecompositionImpl(matrix).getQT();\n         eye = MatrixUtils.createRealIdentityMatrix(4);\n-        norm = matrix.transpose().multiply(matrix).subtract(eye)\n-                .getNorm();\n+        norm = qT.multiply(q).subtract(eye).getNorm();\n         assertEquals(\"4x3 Q'Q = I\", 0, norm, normTolerance);\n     }\n \n     /** test that R is upper triangular */\n     public void testRUpperTriangular() {\n-        RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular);\n+        RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular, false);\n         RealMatrix R = new QRDecompositionImpl(matrix).getR();\n         for (int i = 0; i < R.getRowDimension(); i++)\n             for (int j = 0; j < i; j++)\n                 assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n                         entryTolerance);\n \n-        matrix = new RealMatrixImpl(testData3x4);\n+        matrix = new RealMatrixImpl(testData3x3Singular, false);\n         R = new QRDecompositionImpl(matrix).getR();\n         for (int i = 0; i < R.getRowDimension(); i++)\n             for (int j = 0; j < i; j++)\n                 assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n                         entryTolerance);\n \n-        matrix = new RealMatrixImpl(testData4x3);\n+        matrix = new RealMatrixImpl(testData3x4, false);\n         R = new QRDecompositionImpl(matrix).getR();\n         for (int i = 0; i < R.getRowDimension(); i++)\n             for (int j = 0; j < i; j++)\n                 assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n                         entryTolerance);\n-    }\n+\n+        matrix = new RealMatrixImpl(testData4x3, false);\n+        R = new QRDecompositionImpl(matrix).getR();\n+        for (int i = 0; i < R.getRowDimension(); i++)\n+            for (int j = 0; j < i; j++)\n+                assertEquals(\"R lower triangle\", R.getEntry(i, j), 0,\n+                        entryTolerance);\n+    }\n+\n+    /** test that H is trapezoidal */\n+    public void testHTrapezoidal() {\n+        RealMatrixImpl matrix = new RealMatrixImpl(testData3x3NonSingular, false);\n+        RealMatrix H = new QRDecompositionImpl(matrix).getH();\n+        for (int i = 0; i < H.getRowDimension(); i++)\n+            for (int j = i + 1; j < H.getColumnDimension(); j++)\n+                assertEquals(H.getEntry(i, j), 0, entryTolerance);\n+\n+        matrix = new RealMatrixImpl(testData3x3Singular, false);\n+        H = new QRDecompositionImpl(matrix).getH();\n+        for (int i = 0; i < H.getRowDimension(); i++)\n+            for (int j = i + 1; j < H.getColumnDimension(); j++)\n+                assertEquals(H.getEntry(i, j), 0, entryTolerance);\n+\n+        matrix = new RealMatrixImpl(testData3x4, false);\n+        H = new QRDecompositionImpl(matrix).getH();\n+        for (int i = 0; i < H.getRowDimension(); i++)\n+            for (int j = i + 1; j < H.getColumnDimension(); j++)\n+                assertEquals(H.getEntry(i, j), 0, entryTolerance);\n+\n+        matrix = new RealMatrixImpl(testData4x3, false);\n+        H = new QRDecompositionImpl(matrix).getH();\n+        for (int i = 0; i < H.getRowDimension(); i++)\n+            for (int j = i + 1; j < H.getColumnDimension(); j++)\n+                assertEquals(H.getEntry(i, j), 0, entryTolerance);\n+\n+    }\n+\n+    /** test rank */\n+    public void testRank() {\n+        QRDecomposition qr =\n+            new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));\n+        assertTrue(qr.isNonSingular());\n+\n+        qr = new QRDecompositionImpl(new RealMatrixImpl(testData3x3Singular, false));\n+        assertFalse(qr.isNonSingular());\n+\n+        qr = new QRDecompositionImpl(new RealMatrixImpl(testData3x4, false));\n+        assertFalse(qr.isNonSingular());\n+\n+        qr = new QRDecompositionImpl(new RealMatrixImpl(testData4x3, false));\n+        assertTrue(qr.isNonSingular());\n+\n+    }\n+\n+    /** test solve dimension errors */\n+    public void testSolveDimensionErrors() {\n+        QRDecomposition qr =\n+            new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));\n+        RealMatrix b = new RealMatrixImpl(new double[2][2]);\n+        try {\n+            qr.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            qr.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            qr.solve(b.getColumnVector(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve rank errors */\n+    public void testSolveRankErrors() {\n+        QRDecomposition qr =\n+            new QRDecompositionImpl(new RealMatrixImpl(testData3x3Singular, false));\n+        RealMatrix b = new RealMatrixImpl(new double[3][2]);\n+        try {\n+            qr.solve(b);\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            qr.solve(b.getColumn(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+        try {\n+            qr.solve(b.getColumnVector(0));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    /** test solve */\n+    public void testSolve() {\n+        QRDecomposition qr =\n+            new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));\n+        RealMatrix b = new RealMatrixImpl(new double[][] {\n+                { -102, 12250 }, { 544, 24500 }, { 167, -36750 }\n+        });\n+        RealMatrix xRef = new RealMatrixImpl(new double[][] {\n+                { 1, 2515 }, { 2, 422 }, { -3, 898 }\n+        });\n+\n+        // using RealMatrix\n+        assertEquals(0, qr.solve(b).subtract(xRef).getNorm(), 1.0e-13);\n+\n+        // using double[]\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         new RealVectorImpl(qr.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealVectorImpl\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            assertEquals(0,\n+                         qr.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+        // using RealVector with an alternate implementation\n+        for (int i = 0; i < b.getColumnDimension(); ++i) {\n+            RealVectorImplTest.RealVectorTestImpl v =\n+                new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n+            assertEquals(0,\n+                         qr.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         1.0e-13);\n+        }\n+\n+    }\n+\n+    /** test matrices values */\n+    public void testMatricesValues() {\n+        QRDecomposition qr =\n+            new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));\n+        RealMatrix qRef = new RealMatrixImpl(new double[][] {\n+                { -12.0 / 14.0,   69.0 / 175.0,  -58.0 / 175.0 },\n+                {  -6.0 / 14.0, -158.0 / 175.0,    6.0 / 175.0 },\n+                {   4.0 / 14.0,  -30.0 / 175.0, -165.0 / 175.0 }\n+        });\n+        RealMatrix rRef = new RealMatrixImpl(new double[][] {\n+                { -14.0,  -21.0, 14.0 },\n+                {   0.0, -175.0, 70.0 },\n+                {   0.0,    0.0, 35.0 }\n+        });\n+        RealMatrix hRef = new RealMatrixImpl(new double[][] {\n+                { 26.0 / 14.0, 0.0, 0.0 },\n+                {  6.0 / 14.0, 648.0 / 325.0, 0.0 },\n+                { -4.0 / 14.0,  36.0 / 325.0, 2.0 }\n+        });\n+\n+        // check values against known references\n+        RealMatrix q = qr.getQ();\n+        assertEquals(0, q.subtract(qRef).getNorm(), 1.0e-13);\n+        RealMatrix qT = qr.getQT();\n+        assertEquals(0, qT.subtract(qRef.transpose()).getNorm(), 1.0e-13);\n+        RealMatrix r = qr.getR();\n+        assertEquals(0, r.subtract(rRef).getNorm(), 1.0e-13);\n+        RealMatrix h = qr.getH();\n+        assertEquals(0, h.subtract(hRef).getNorm(), 1.0e-13);\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(q == qr.getQ());\n+        assertTrue(r == qr.getR());\n+        assertTrue(h == qr.getH());\n+        \n+    }\n+\n+    /** test no call to decompose */\n+    public void testNoDecompose() {\n+        try {\n+            new QRDecompositionImpl().isNonSingular();\n+            fail(\"an exception should have been caught\");\n+        } catch (IllegalStateException ise) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n }\n--- a/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n     \n     /** test copy functions */\n     public void testCopyFunctions() {\n-        RealMatrixImpl m = new RealMatrixImpl(testData);\n-        RealMatrixImpl m2 = new RealMatrixImpl(m.getData());\n-        assertEquals(m2,m);\n+        RealMatrixImpl m1 = new RealMatrixImpl(testData);\n+        RealMatrixImpl m2 = new RealMatrixImpl(m1.getData());\n+        assertEquals(m2,m1);\n+        RealMatrixImpl m3 = new RealMatrixImpl(testData);\n+        RealMatrixImpl m4 = new RealMatrixImpl(m3.getData(), false);\n+        assertEquals(m4,m3);\n     }           \n     \n     /** test add */\n     public void testAdd() {\n         RealMatrixImpl m = new RealMatrixImpl(testData);\n         RealMatrixImpl mInv = new RealMatrixImpl(testDataInv);\n-        RealMatrixImpl mPlusMInv = (RealMatrixImpl)m.add(mInv);\n+        RealMatrix mPlusMInv = m.add(mInv);\n         double[][] sumEntries = mPlusMInv.getData();\n         for (int row = 0; row < m.getRowDimension(); row++) {\n             for (int col = 0; col < m.getColumnDimension(); col++) {\n        assertClose(\"m3*m4=m5\", m3.multiply(m4), m5, entryTolerance);\n    }  \n         \n-    /** test isSingular */\n-    public void testIsSingular() {\n-        RealMatrixImpl m = new RealMatrixImpl(singular);\n-        assertTrue(\"singular\",m.isSingular());\n-        m = new RealMatrixImpl(bigSingular);\n-        assertTrue(\"big singular\",m.isSingular());\n-        m = new RealMatrixImpl(id);\n-        assertTrue(\"identity nonsingular\",!m.isSingular());\n-        m = new RealMatrixImpl(testData);\n-        assertTrue(\"testData nonsingular\",!m.isSingular());\n-    }\n-        \n-    /** test inverse */\n-    public void testInverse() {\n-        RealMatrixImpl m = new RealMatrixImpl(testData);\n-        RealMatrix mInv = new RealMatrixImpl(testDataInv);\n-        assertClose(\"inverse\",mInv,m.inverse(),normTolerance);\n-        assertClose(\"inverse^2\",m,m.inverse().inverse(),10E-12);\n-        \n-        // Not square\n-        m = new RealMatrixImpl(testData2);\n-        try {\n-            m.inverse();\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n-            // expected\n-        }\n-        \n-        // Singular\n-        m = new RealMatrixImpl(singular);\n-        try {\n-            m.inverse();\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n-            // expected\n-        }\n-    }\n-    \n-    /** test solve */\n-    public void testSolve() {\n-        RealMatrixImpl m = new RealMatrixImpl(testData);\n-        RealMatrix mInv = new RealMatrixImpl(testDataInv);\n-        // being a bit slothful here -- actually testing that X = A^-1 * B\n-        assertClose(\"inverse-operate\",mInv.operate(testVector),\n-            m.solve(testVector),normTolerance);\n-        try {\n-            m.solve(testVector2);\n-            fail(\"expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            ;\n-        }       \n-        RealMatrix bs = new RealMatrixImpl(bigSingular);\n-        try {\n-            bs.solve(bs);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n-            ;\n-        }\n-        try {\n-            m.solve(bs);\n-            fail(\"Expecting IllegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            ;\n-        }\n-        try {\n-            new RealMatrixImpl(testData2).solve(bs);\n-            fail(\"Expecting illegalArgumentException\");\n-        } catch (IllegalArgumentException ex) {\n-            ;\n-        } \n-        try {\n-            (new RealMatrixImpl(testData2)).luDecompose();\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n-            ;\n-        }  \n-    }\n-    \n-    /** test determinant */\n-    public void testDeterminant() {       \n-        RealMatrix m = new RealMatrixImpl(bigSingular);\n-        assertEquals(\"singular determinant\",0,m.getDeterminant(),0);\n-        m = new RealMatrixImpl(detData);\n-        assertEquals(\"nonsingular test\",-3d,m.getDeterminant(),normTolerance);\n-        \n-        // Examples verified against R (version 1.8.1, Red Hat Linux 9)\n-        m = new RealMatrixImpl(detData2);\n-        assertEquals(\"nonsingular R test 1\",-2d,m.getDeterminant(),normTolerance);\n-        m = new RealMatrixImpl(testData);\n-        assertEquals(\"nonsingular  R test 2\",-1d,m.getDeterminant(),normTolerance);\n-\n-        try {\n-            new RealMatrixImpl(testData2).getDeterminant();\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n-            ;\n-        }      \n-    }\n-    \n     /** test trace */\n     public void testTrace() {\n         RealMatrix m = new RealMatrixImpl(id);\n     /** test operate */\n     public void testOperate() {\n         RealMatrix m = new RealMatrixImpl(id);\n-        double[] x = m.operate(testVector);\n-        assertClose(\"identity operate\",testVector,x,entryTolerance);\n+        assertClose(\"identity operate\", testVector,\n+                    m.operate(testVector), entryTolerance);\n+        assertClose(\"identity operate\", testVector,\n+                    m.operate(new RealVectorImpl(testVector)).getData(), entryTolerance);\n         m = new RealMatrixImpl(bigSingular);\n         try {\n             m.operate(testVector);\n             ;\n         }      \n     }\n+\n+    /** test issue MATH-209 */\n+    public void testMath209() {\n+        RealMatrix a = new RealMatrixImpl(new double[][] {\n+                { 1, 2 }, { 3, 4 }, { 5, 6 }\n+        }, false);\n+        double[] b = a.operate(new double[] { 1, 1 });\n+        assertEquals(a.getRowDimension(), b.length);\n+        assertEquals( 3.0, b[0], 1.0e-12);\n+        assertEquals( 7.0, b[1], 1.0e-12);\n+        assertEquals(11.0, b[2], 1.0e-12);\n+    }\n     \n     /** test transpose */\n     public void testTranspose() {\n         RealMatrix m = new RealMatrixImpl(testData); \n-        assertClose(\"inverse-transpose\",m.inverse().transpose(),\n-            m.transpose().inverse(),normTolerance);\n+        RealMatrix mIT = new LUDecompositionImpl(m).getInverse().transpose();\n+        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getInverse();\n+        assertClose(\"inverse-transpose\", mIT, mTI, normTolerance);\n         m = new RealMatrixImpl(testData2);\n         RealMatrix mt = new RealMatrixImpl(testData2T);\n         assertClose(\"transpose\",mt,m.transpose(),normTolerance);\n     /** test preMultiply by vector */\n     public void testPremultiplyVector() {\n         RealMatrix m = new RealMatrixImpl(testData);\n-        assertClose(\"premultiply\",m.preMultiply(testVector),preMultTest,normTolerance);\n+        assertClose(\"premultiply\", m.preMultiply(testVector),\n+                    preMultTest, normTolerance);\n+        assertClose(\"premultiply\", m.preMultiply(new RealVectorImpl(testVector).getData()),\n+                    preMultTest, normTolerance);\n         m = new RealMatrixImpl(bigSingular);\n         try {\n             m.preMultiply(testVector);\n         }\n     }\n         \n-    public void testLUDecomposition() throws Exception {\n-        RealMatrixImpl m = new RealMatrixImpl(testData);\n-        RealMatrix lu = m.getLUMatrix();\n-        assertClose(\"LU decomposition\", lu, (RealMatrix) new RealMatrixImpl(testDataLU), normTolerance);\n-        verifyDecomposition(m, lu);\n-        // access LU decomposition on same object to verify caching.\n-        lu = m.getLUMatrix();\n-        assertClose(\"LU decomposition\", lu, (RealMatrix) new RealMatrixImpl(testDataLU), normTolerance);\n-        verifyDecomposition(m, lu);\n-\n-        m = new RealMatrixImpl(luData);\n-        lu = m.getLUMatrix();\n-        assertClose(\"LU decomposition\", lu, (RealMatrix) new RealMatrixImpl(luDataLUDecomposition), normTolerance);\n-        verifyDecomposition(m, lu);\n-        m = new RealMatrixImpl(testDataMinus);\n-        lu = m.getLUMatrix();\n-        verifyDecomposition(m, lu);\n-        m = new RealMatrixImpl(id);\n-        lu = m.getLUMatrix();\n-        verifyDecomposition(m, lu);\n-        try {\n-            m = new RealMatrixImpl(bigSingular); // singular\n-            lu = m.getLUMatrix();\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n-            // expected\n-        }\n-        try {\n-            m = new RealMatrixImpl(testData2);  // not square\n-            lu = m.getLUMatrix();\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n-            // expected\n-        }\n-    }\n-    \n     /** test examples in user guide */\n     public void testExamples() {\n         // Create a real matrix with two rows and three columns\n         assertEquals(2, p.getRowDimension());\n         assertEquals(2, p.getColumnDimension());\n         // Invert p\n-        RealMatrix pInverse = p.inverse(); \n+        RealMatrix pInverse = new LUDecompositionImpl(p).getInverse(); \n         assertEquals(2, pInverse.getRowDimension());\n         assertEquals(2, pInverse.getColumnDimension());\n         \n         double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};\n         RealMatrix coefficients = new RealMatrixImpl(coefficientsData);\n         double[] constants = {1, -2, 1};\n-        double[] solution = coefficients.solve(constants);\n+        double[] solution = new LUDecompositionImpl(coefficients).solve(constants);\n         assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);\n         assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);\n         assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);   \n             // expected\n         }\n     }\n+\n+    public void testGetRowVector() {\n+        RealMatrix m = new RealMatrixImpl(subTestData);\n+        RealVector mRow0 = new RealVectorImpl(subRow0[0]);\n+        RealVector mRow3 = new RealVectorImpl(subRow3[0]);\n+        assertEquals(\"Row0\", mRow0, m.getRowVector(0));\n+        assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n+        try {\n+            m.getRowVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getRowVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+   }\n+    \n+    public void testGetColumnVector() {\n+        RealMatrix m = new RealMatrixImpl(subTestData);\n+        RealVector mColumn1 = columnToVector(subColumn1);\n+        RealVector mColumn3 = columnToVector(subColumn3);\n+        assertEquals(\"Column1\", mColumn1, m.getColumnVector(1));\n+        assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n+        try {\n+            m.getColumnVector(-1);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+        try {\n+            m.getColumnVector(4);\n+            fail(\"Expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            // expected\n+        }\n+    }\n+\n+    private RealVector columnToVector(double[][] column) {\n+        double[] data = new double[column.length];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = column[i][0];\n+        }\n+        return new RealVectorImpl(data, false);\n+    }\n     \n     public void testEqualsAndHashCode() {\n         RealMatrixImpl m = new RealMatrixImpl(testData);\n         RealMatrixImpl m2 = new RealMatrixImpl();\n         try {\n             m2.setSubMatrix(testData,0,1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting IllegalStateException\");\n+        } catch (IllegalStateException e) {\n             // expected\n         }\n         try {\n             m2.setSubMatrix(testData,1,0);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting IllegalStateException\");\n+        } catch (IllegalStateException e) {\n             // expected\n         }\n         \n         if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||\n                 lowerData.length != upperData.length\n                 || lowerData.length != lu.getRowDimension()) {\n-            throw new InvalidMatrixException(\"incorrect dimensions\");\n+            throw new InvalidMatrixException(\"incorrect dimensions\", null);\n         }    \n         int n = lu.getRowDimension();\n         for (int i = 0; i < n; i++) {\n         return new RealMatrixImpl(out);\n     }\n     \n-    /** Extracts l and u matrices from lu and verifies that matrix = l times u modulo permutation */\n-    protected void verifyDecomposition(RealMatrix matrix, RealMatrix lu) throws Exception{\n-        int n = matrix.getRowDimension();\n-        double[][] lowerData = new double[n][n];\n-        double[][] upperData = new double[n][n];\n-        splitLU(lu, lowerData, upperData);\n-        RealMatrix lower =new RealMatrixImpl(lowerData);\n-        RealMatrix upper = new RealMatrixImpl(upperData);\n-        int[] permutation = ((RealMatrixImpl) matrix).getPermutation();\n-        RealMatrix permuted = permuteRows(matrix, permutation);\n-        assertClose(\"lu decomposition does not work\", permuted, lower.multiply(upper), normTolerance);\n-    }\n-      \n-    \n //    /** Useful for debugging */\n //    private void dumpMatrix(RealMatrix m) {\n //          for (int i = 0; i < m.getRowDimension(); i++) {\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/RealVectorFormatAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.math.util.CompositeFormat;\n+\n+public abstract class RealVectorFormatAbstractTest extends TestCase {\n+ \n+    RealVectorFormat realVectorFormat = null;\n+    RealVectorFormat realVectorFormatSquare = null;\n+\n+    protected abstract Locale getLocale();\n+\n+    protected abstract char getDecimalCharacter();\n+    \n+    protected void setUp() throws Exception {\n+        realVectorFormat = RealVectorFormat.getInstance(getLocale());\n+        final NumberFormat nf = NumberFormat.getInstance(getLocale());\n+        nf.setMaximumFractionDigits(2);\n+        realVectorFormatSquare = new RealVectorFormat(\"[\", \"]\", \" : \", nf);\n+    }\n+   \n+    public void testSimpleNoDecimals() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {1, 1, 1});\n+        String expected = \"{1; 1; 1}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testSimpleWithDecimals() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {1.23, 1.43, 1.63});\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testSimpleWithDecimalsTrunc() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {1.2323, 1.4343, 1.6333});\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeX() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {-1.2323, 1.4343, 1.6333});\n+        String expected =\n+            \"{-1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeY() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {1.2323, -1.4343, 1.6333});\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; -1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNegativeZ() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {1.2323, 1.4343, -1.6333});\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; -1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testNonDefaultSetting() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {1, 1, 1});\n+        String expected = \"[1 : 1 : 1]\";\n+        String actual = realVectorFormatSquare.format(c); \n+        assertEquals(expected, actual);\n+    }\n+    \n+    public void testStaticFormatRealVectorImpl() {\n+        Locale defaultLocal = Locale.getDefault();\n+        Locale.setDefault(getLocale());\n+        \n+        RealVectorImpl c = new RealVectorImpl(new double[] {232.222, -342.33, 432.444});\n+        String expected =\n+            \"{232\"    + getDecimalCharacter() +\n+            \"22; -342\" + getDecimalCharacter() +\n+            \"33; 432\" + getDecimalCharacter() +\n+            \"44}\";\n+        String actual = RealVectorFormat.formatRealVector(c); \n+        assertEquals(expected, actual);\n+        \n+        Locale.setDefault(defaultLocal);\n+    }\n+\n+    public void testNan() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {Double.NaN, Double.NaN, Double.NaN});\n+        String expected = \"{(NaN); (NaN); (NaN)}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testPositiveInfinity() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {\n+                Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY\n+        });\n+        String expected = \"{(Infinity); (Infinity); (Infinity)}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void tesNegativeInfinity() {\n+        RealVectorImpl c = new RealVectorImpl(new double[] {\n+                Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY\n+        });\n+        String expected = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n+        String actual = realVectorFormat.format(c); \n+        assertEquals(expected, actual);\n+    }\n+\n+    public void testParseSimpleNoDecimals() {\n+        String source = \"{1; 1; 1}\";\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {1, 1, 1});\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseIgnoredWhitespace() {\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {1, 1, 1});\n+        ParsePosition pos1 = new ParsePosition(0);\n+        String source1 = \"{1;1;1}\";\n+        assertEquals(expected, realVectorFormat.parseObject(source1, pos1));\n+        assertEquals(source1.length(), pos1.getIndex());\n+        ParsePosition pos2 = new ParsePosition(0);\n+        String source2 = \" { 1 ; 1 ; 1 } \";\n+        assertEquals(expected, realVectorFormat.parseObject(source2, pos2));\n+        assertEquals(source2.length() - 1, pos2.getIndex());\n+    }\n+\n+    public void testParseSimpleWithDecimals() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {1.23, 1.43, 1.63});\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseSimpleWithDecimalsTrunc() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, 1.4343, 1.6333});\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeX() {\n+        String source =\n+            \"{-1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {-1.2323, 1.4343, 1.6333});\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeY() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; -1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, -1.4343, 1.6333});\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeZ() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; -1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, 1.4343, -1.6333});\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeAll() {\n+        String source =\n+            \"{-1\" + getDecimalCharacter() +\n+            \"2323; -1\" + getDecimalCharacter() +\n+            \"4343; -1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {-1.2323, -1.4343, -1.6333});\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseZeroX() {\n+        String source =\n+            \"{0\" + getDecimalCharacter() +\n+            \"0; -1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {0.0, -1.4343, 1.6333});\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNonDefaultSetting() {\n+        String source =\n+            \"[1\" + getDecimalCharacter() +\n+            \"2323 : 1\" + getDecimalCharacter() +\n+            \"4343 : 1\" + getDecimalCharacter() +\n+            \"6333]\";\n+        RealVectorImpl expected = new RealVectorImpl(new double[] {1.2323, 1.4343, 1.6333});\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormatSquare.parseObject(source); \n+            assertEquals(expected, actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+    \n+    public void testParseNan() {\n+        String source = \"{(NaN); (NaN); (NaN)}\";\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl) realVectorFormat.parseObject(source); \n+            assertEquals(new RealVectorImpl(new double[] {Double.NaN, Double.NaN, Double.NaN}), actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParsePositiveInfinity() {\n+        String source = \"{(Infinity); (Infinity); (Infinity)}\";\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl)realVectorFormat.parseObject(source); \n+            assertEquals(new RealVectorImpl(new double[] {\n+                    Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY\n+            }), actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNegativeInfinity() {\n+        String source = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n+        try {\n+            RealVectorImpl actual = (RealVectorImpl)realVectorFormat.parseObject(source); \n+            assertEquals(new RealVectorImpl(new double[] {\n+                    Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY\n+            }), actual);\n+        } catch (ParseException ex) {\n+            fail(ex.getMessage());\n+        }\n+    }\n+\n+    public void testParseNoComponents() {\n+        try {\n+            realVectorFormat.parseObject(\"{ }\");\n+        } catch (ParseException pe) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    public void testParseManyComponents() throws ParseException {\n+        RealVectorImpl parsed =\n+            (RealVectorImpl) realVectorFormat.parseObject(\"{0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0}\");\n+        assertEquals(24, parsed.getDimension());\n+    }\n+\n+    public void testConstructorSingleFormat() {\n+        NumberFormat nf = NumberFormat.getInstance();\n+        RealVectorFormat cf = new RealVectorFormat(nf);\n+        assertNotNull(cf);\n+        assertEquals(nf, cf.getFormat());\n+    }\n+    \n+    public void testFormatObject() {\n+        try {\n+            CompositeFormat cf = new RealVectorFormat();\n+            Object object = new Object();\n+            cf.format(object);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n+    }\n+\n+    public void testForgottenPrefix() {\n+        ParsePosition pos = new ParsePosition(0);\n+        assertNull(new RealVectorFormat().parse(\"1; 1; 1}\", pos));\n+        assertEquals(0, pos.getErrorIndex());\n+    }\n+\n+    public void testForgottenSeparator() {\n+        ParsePosition pos = new ParsePosition(0);\n+        assertNull(new RealVectorFormat().parse(\"{1; 1 1}\", pos));\n+        assertEquals(6, pos.getErrorIndex());\n+    }\n+\n+    public void testForgottenSuffix() {\n+        ParsePosition pos = new ParsePosition(0);\n+        assertNull(new RealVectorFormat().parse(\"{1; 1; 1 \", pos));\n+        assertEquals(8, pos.getErrorIndex());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/RealVectorFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Locale;\n+\n+\n+public class RealVectorFormatTest extends RealVectorFormatAbstractTest {\n+    protected char getDecimalCharacter() {\n+        return '.';\n+    }\n+    \n+    protected Locale getLocale() {\n+        return Locale.US;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/RealVectorImplTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link RealVectorImpl} class.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class RealVectorImplTest extends TestCase {\n+\n+    // \n+    protected double[][] ma1 = {{1d, 2d, 3d}, {4d, 5d, 6d}, {7d, 8d, 9d}};\n+    protected double[] vec1 = {1d, 2d, 3d};\n+    protected double[] vec2 = {4d, 5d, 6d};\n+    protected double[] vec3 = {7d, 8d, 9d};\n+    protected double[] vec4 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};\n+    protected double[] vec_null = {0d, 0d, 0d};\n+    protected Double[] dvec1 = {1d, 2d, 3d, 4d, 5d, 6d, 7d, 8d, 9d};\n+    protected double[][] mat1 = {{1d, 2d, 3d}, {4d, 5d, 6d},{ 7d, 8d, 9d}};\n+\n+    // tolerances\n+    protected double entryTolerance = 10E-16;\n+    protected double normTolerance = 10E-14;\n+\n+    // Testclass to test the RealVector interface \n+    // only with enough content to support the test\n+    public static class RealVectorTestImpl implements RealVector, Serializable {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = 4715341047369582908L;\n+\n+        /** Entries of the vector. */\n+        protected double data[];\n+\n+        public RealVectorTestImpl(double[] d) {\n+            data = d.clone();\n+        }\n+\n+        private UnsupportedOperationException unsupported() {\n+            return new UnsupportedOperationException(\"Not supported, unneeded for test purposes\");\n+        }\n+\n+        public RealVector copy() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector add(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector add(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector subtract(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector subtract(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAdd(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAddToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSubtract(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSubtractToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapMultiply(double d) {\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] * d;\n+            }\n+            return new RealVectorImpl(out);\n+        }\n+\n+        public RealVector mapMultiplyToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapDivide(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapDivideToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapPow(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapPowToSelf(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExp() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExpToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExpm1() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapExpm1ToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLogToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog10() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog10ToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog1p() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapLog1pToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCosh() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCoshToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSinh() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSinhToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTanh() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTanhToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCos() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCosToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSin() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSinToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTan() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapTanToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAcos() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAcosToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAsin() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAsinToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAtan() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAtanToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapInv() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapInvToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAbs() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapAbsToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSqrt() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSqrtToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCbrt() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCbrtToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCeil() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapCeilToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapFloor() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapFloorToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapRint() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapRintToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSignum() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapSignumToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapUlp() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector mapUlpToSelf() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeMultiply(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector ebeDivide(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double[] getData() {\n+            return data.clone();\n+        }\n+\n+        public double dotProduct(RealVector v) throws IllegalArgumentException {\n+            double dot = 0;\n+            for (int i = 0; i < data.length; i++) {\n+                dot += data[i] * v.getEntry(i);\n+            }\n+            return dot;\n+        }\n+\n+        public double dotProduct(double[] v) throws IllegalArgumentException {\n+            double dot = 0;\n+            for (int i = 0; i < data.length; i++) {\n+                dot += data[i] * v[i];\n+            }\n+            return dot;\n+        }\n+\n+        public double getNorm() {\n+            throw unsupported();\n+        }\n+\n+        public double getL1Norm() {\n+            throw unsupported();\n+        }\n+\n+        public double getLInfNorm() {\n+            throw unsupported();\n+        }\n+\n+        public double getDistance(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getDistance(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getL1Distance(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getL1Distance(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getLInfDistance(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector unitVector() {\n+            throw unsupported();\n+        }\n+\n+        public void unitize() {\n+            throw unsupported();\n+        }\n+\n+        public RealVector projection(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealVector projection(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealMatrix outerProduct(RealVector v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n+            throw unsupported();\n+        }\n+\n+        public double getEntry(int index) throws MatrixIndexException {\n+            return data[index];\n+        }\n+\n+        public int getDimension() {\n+            return data.length;\n+        }\n+\n+        public RealVector append(RealVector v) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector append(double d) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector append(double[] a) {\n+            throw unsupported();\n+        }\n+\n+        public RealVector get(int index, int n) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void set(int index, double value) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void set(int index, RealVector v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void set(int index, double[] v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void set(double value) {\n+            throw unsupported();\n+        }\n+\n+        public double[] toArray() {\n+            throw unsupported();\n+        }\n+\n+        public boolean isNaN() {\n+            throw unsupported();\n+        }\n+\n+        public boolean isInfinite() {\n+            throw unsupported();\n+        }\n+\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(RealVectorImplTest.class);\n+        suite.setName(\"RealVectorImpl Tests\");\n+        return suite;\n+    }\n+\n+    public void testConstructors() {\n+\n+        RealVectorImpl v0 = new RealVectorImpl();\n+        assertEquals(\"testData len\", 0, v0.getDimension());\n+\n+        RealVectorImpl v1 = new RealVectorImpl(7);\n+        assertEquals(\"testData len\", 7, v1.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v1.getEntry(6));\n+\n+        RealVectorImpl v2 = new RealVectorImpl(5, 1.23);\n+        assertEquals(\"testData len\", 5, v2.getDimension());\n+        assertEquals(\"testData is 1.23 \", 1.23, v2.getEntry(4));\n+\n+        RealVectorImpl v3 = new RealVectorImpl(vec1);\n+        assertEquals(\"testData len\", 3, v3.getDimension());\n+        assertEquals(\"testData is 2.0 \", 2.0, v3.getEntry(1));\n+\n+        RealVectorImpl v4 = new RealVectorImpl(vec4, 3, 2);\n+        assertEquals(\"testData len\", 2, v4.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v4.getEntry(0));\n+        try {\n+            new RealVectorImpl(vec4, 8, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVector v5_i = new RealVectorImpl(dvec1);\n+        assertEquals(\"testData len\", 9, v5_i.getDimension());\n+        assertEquals(\"testData is 9.0 \", 9.0, v5_i.getEntry(8));\n+\n+        RealVectorImpl v5 = new RealVectorImpl(dvec1);\n+        assertEquals(\"testData len\", 9, v5.getDimension());\n+        assertEquals(\"testData is 9.0 \", 9.0, v5.getEntry(8));\n+\n+        RealVectorImpl v6 = new RealVectorImpl(dvec1, 3, 2);\n+        assertEquals(\"testData len\", 2, v6.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v6.getEntry(0));\n+        try {\n+            new RealVectorImpl(dvec1, 8, 3);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVectorImpl v7 = new RealVectorImpl(v1);\n+        assertEquals(\"testData len\", 7, v7.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v7.getEntry(6));\n+\n+        RealVectorTestImpl v7_i = new RealVectorTestImpl(vec1);\n+\n+        RealVectorImpl v7_2 = new RealVectorImpl(v7_i);\n+        assertEquals(\"testData len\", 3, v7_2.getDimension());\n+        assertEquals(\"testData is 0.0 \", 2.0d, v7_2.getEntry(1));\n+\n+        RealVectorImpl v8 = new RealVectorImpl(v1, true);\n+        assertEquals(\"testData len\", 7, v8.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v8.getEntry(6));\n+        assertNotSame(\"testData not same object \", v1.data, v8.data);\n+\n+        RealVectorImpl v8_2 = new RealVectorImpl(v1, false);\n+        assertEquals(\"testData len\", 7, v8_2.getDimension());\n+        assertEquals(\"testData is 0.0 \", 0.0, v8_2.getEntry(6));\n+        assertEquals(\"testData same object \", v1.data, v8_2.data);\n+\n+        RealVectorImpl v9 = new RealVectorImpl(v1, v3);\n+        assertEquals(\"testData len\", 10, v9.getDimension());\n+        assertEquals(\"testData is 1.0 \", 1.0, v9.getEntry(7));\n+\n+    }\n+\n+    public void testDataInOut() {\n+\n+        RealVectorImpl v1 = new RealVectorImpl(vec1);\n+        RealVectorImpl v2 = new RealVectorImpl(vec2);\n+        RealVectorImpl v4 = new RealVectorImpl(vec4);\n+        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2); \n+\n+        RealVector v_append_1 = v1.append(v2);\n+        assertEquals(\"testData len\", 6, v_append_1.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v_append_1.getEntry(3));\n+\n+        RealVector v_append_2 = v1.append(2.0);\n+        assertEquals(\"testData len\", 4, v_append_2.getDimension());\n+        assertEquals(\"testData is 2.0 \", 2.0, v_append_2.getEntry(3));\n+\n+        RealVector v_append_3 = v1.append(vec2);\n+        assertEquals(\"testData len\", 6, v_append_3.getDimension());\n+        assertEquals(\"testData is  \", 4.0, v_append_3.getEntry(3));\n+\n+        RealVector v_append_4 = v1.append(v2_t);\n+        assertEquals(\"testData len\", 6, v_append_4.getDimension());\n+        assertEquals(\"testData is 4.0 \", 4.0, v_append_4.getEntry(3));\n+\n+        RealVector v_copy = v1.copy();\n+        assertEquals(\"testData len\", 3, v_copy.getDimension());\n+        assertNotSame(\"testData not same object \", v1.data, v_copy.getData());\n+\n+        double[] a_double = v1.toArray();\n+        assertEquals(\"testData len\", 3, a_double.length);\n+        assertNotSame(\"testData not same object \", v1.data, a_double);\n+\n+\n+//      RealVectorImpl vout4 = (RealVectorImpl) v1.clone();\n+//      assertEquals(\"testData len\", 3, vout4.getDimension());\n+//      assertEquals(\"testData not same object \", v1.data, vout4.data);\n+\n+\n+        RealVector vout5 = v4.get(3, 3);\n+        assertEquals(\"testData len\", 3, vout5.getDimension());\n+        assertEquals(\"testData is 4.0 \", 5.0, vout5.getEntry(1));\n+        try {\n+            v4.get(3, 7);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVectorImpl v_set1 = (RealVectorImpl) v1.copy();\n+        v_set1.set(1, 11.0);\n+        assertEquals(\"testData is 11.0 \", 11.0, v_set1.getEntry(1));\n+        try {\n+            v_set1.set(3, 11.0);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVectorImpl v_set2 = (RealVectorImpl) v4.copy();\n+        v_set2.set(3, v1);\n+        assertEquals(\"testData is 1.0 \", 1.0, v_set2.getEntry(3));\n+        assertEquals(\"testData is 7.0 \", 7.0, v_set2.getEntry(6));\n+        try {\n+            v_set2.set(7, v1);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVectorImpl v_set3 = (RealVectorImpl) v1.copy();\n+        v_set3.set(13.0);\n+        assertEquals(\"testData is 13.0 \", 13.0, v_set3.getEntry(2));\n+\n+        try {\n+            v_set3.getEntry(23);\n+            fail(\"ArrayIndexOutOfBoundsException expected\");\n+        } catch (ArrayIndexOutOfBoundsException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVectorImpl v_set4 = (RealVectorImpl) v4.copy();\n+        v_set4.set(3, v2_t);\n+        assertEquals(\"testData is 1.0 \", 4.0, v_set4.getEntry(3));\n+        assertEquals(\"testData is 7.0 \", 7.0, v_set4.getEntry(6));\n+        try {\n+            v_set4.set(7, v2_t);\n+            fail(\"MatrixIndexException expected\");\n+        } catch (MatrixIndexException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+\n+        RealVectorImpl vout10 = (RealVectorImpl) v1.copy();       \n+        RealVectorImpl vout10_2 = (RealVectorImpl) v1.copy();\n+        assertEquals(vout10, vout10_2);\n+        vout10_2.set(0, 1.1);\n+        assertNotSame(vout10, vout10_2);\n+\n+    }\n+\n+    public void testMapFunctions() { \n+        RealVectorImpl v1 = new RealVectorImpl(vec1);\n+\n+        //octave =  v1 .+ 2.0\n+        RealVector v_mapAdd = v1.mapAdd(2.0d);\n+        double[] result_mapAdd = {3d, 4d, 5d};\n+        assertClose(\"compare vectors\" ,result_mapAdd,v_mapAdd.getData(),normTolerance);\n+\n+        //octave =  v1 .+ 2.0\n+        RealVector v_mapAddToSelf = v1.copy();\n+        v_mapAddToSelf.mapAddToSelf(2.0d);\n+        double[] result_mapAddToSelf = {3d, 4d, 5d};\n+        assertClose(\"compare vectors\" ,result_mapAddToSelf,v_mapAddToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .- 2.0\n+        RealVector v_mapSubtract = v1.mapSubtract(2.0d);\n+        double[] result_mapSubtract = {-1d, 0d, 1d};\n+        assertClose(\"compare vectors\" ,result_mapSubtract,v_mapSubtract.getData(),normTolerance);\n+\n+        //octave =  v1 .- 2.0\n+        RealVector v_mapSubtractToSelf = v1.copy();\n+        v_mapSubtractToSelf.mapSubtractToSelf(2.0d);\n+        double[] result_mapSubtractToSelf = {-1d, 0d, 1d};\n+        assertClose(\"compare vectors\" ,result_mapSubtractToSelf,v_mapSubtractToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .* 2.0\n+        RealVector v_mapMultiply = v1.mapMultiply(2.0d);\n+        double[] result_mapMultiply = {2d, 4d, 6d};\n+        assertClose(\"compare vectors\" ,result_mapMultiply,v_mapMultiply.getData(),normTolerance);\n+\n+        //octave =  v1 .* 2.0\n+        RealVector v_mapMultiplyToSelf = v1.copy();\n+        v_mapMultiplyToSelf.mapMultiplyToSelf(2.0d);\n+        double[] result_mapMultiplyToSelf = {2d, 4d, 6d};\n+        assertClose(\"compare vectors\" ,result_mapMultiplyToSelf,v_mapMultiplyToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 ./ 2.0\n+        RealVector v_mapDivide = v1.mapDivide(2.0d);\n+        double[] result_mapDivide = {.5d, 1d, 1.5d};\n+        assertClose(\"compare vectors\" ,result_mapDivide,v_mapDivide.getData(),normTolerance);\n+\n+        //octave =  v1 ./ 2.0\n+        RealVector v_mapDivideToSelf = v1.copy();\n+        v_mapDivideToSelf.mapDivideToSelf(2.0d);\n+        double[] result_mapDivideToSelf = {.5d, 1d, 1.5d};\n+        assertClose(\"compare vectors\" ,result_mapDivideToSelf,v_mapDivideToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .^ 2.0\n+        RealVector v_mapPow = v1.mapPow(2.0d);\n+        double[] result_mapPow = {1d, 4d, 9d};\n+        assertClose(\"compare vectors\" ,result_mapPow,v_mapPow.getData(),normTolerance);\n+\n+        //octave =  v1 .^ 2.0\n+        RealVector v_mapPowToSelf = v1.copy();\n+        v_mapPowToSelf.mapPowToSelf(2.0d);\n+        double[] result_mapPowToSelf = {1d, 4d, 9d};\n+        assertClose(\"compare vectors\" ,result_mapPowToSelf,v_mapPowToSelf.getData(),normTolerance);\n+\n+        //octave =  exp(v1)\n+        RealVector v_mapExp = v1.mapExp();\n+        double[] result_mapExp = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};\n+        assertClose(\"compare vectors\" ,result_mapExp,v_mapExp.getData(),normTolerance);\n+\n+        //octave =  exp(v1)\n+        RealVector v_mapExpToSelf = v1.copy();\n+        v_mapExpToSelf.mapExpToSelf();\n+        double[] result_mapExpToSelf = {2.718281828459045e+00d,7.389056098930650e+00d, 2.008553692318767e+01d};\n+        assertClose(\"compare vectors\" ,result_mapExpToSelf,v_mapExpToSelf.getData(),normTolerance);\n+\n+\n+        //octave =  ???\n+        RealVector v_mapExpm1 = v1.mapExpm1();\n+        double[] result_mapExpm1 = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};\n+        assertClose(\"compare vectors\" ,result_mapExpm1,v_mapExpm1.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapExpm1ToSelf = v1.copy();\n+        v_mapExpm1ToSelf.mapExpm1ToSelf();\n+        double[] result_mapExpm1ToSelf = {1.718281828459045d,6.38905609893065d, 19.085536923187668d};\n+        assertClose(\"compare vectors\" ,result_mapExpm1ToSelf,v_mapExpm1ToSelf.getData(),normTolerance);\n+\n+        //octave =  log(v1)\n+        RealVector v_mapLog = v1.mapLog();\n+        double[] result_mapLog = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};\n+        assertClose(\"compare vectors\" ,result_mapLog,v_mapLog.getData(),normTolerance);\n+\n+        //octave =  log(v1)\n+        RealVector v_mapLogToSelf = v1.copy();\n+        v_mapLogToSelf.mapLogToSelf();\n+        double[] result_mapLogToSelf = {0d,6.931471805599453e-01d, 1.098612288668110e+00d};\n+        assertClose(\"compare vectors\" ,result_mapLogToSelf,v_mapLogToSelf.getData(),normTolerance);\n+\n+        //octave =  log10(v1)\n+        RealVector v_mapLog10 = v1.mapLog10();\n+        double[] result_mapLog10 = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};\n+        assertClose(\"compare vectors\" ,result_mapLog10,v_mapLog10.getData(),normTolerance);\n+\n+        //octave =  log(v1)\n+        RealVector v_mapLog10ToSelf = v1.copy();\n+        v_mapLog10ToSelf.mapLog10ToSelf();\n+        double[] result_mapLog10ToSelf = {0d,3.010299956639812e-01d, 4.771212547196624e-01d};\n+        assertClose(\"compare vectors\" ,result_mapLog10ToSelf,v_mapLog10ToSelf.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapLog1p = v1.mapLog1p();\n+        double[] result_mapLog1p = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};\n+        assertClose(\"compare vectors\" ,result_mapLog1p,v_mapLog1p.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapLog1pToSelf = v1.copy();\n+        v_mapLog1pToSelf.mapLog1pToSelf();\n+        double[] result_mapLog1pToSelf = {0.6931471805599453d,1.0986122886681096d,1.3862943611198906d};\n+        assertClose(\"compare vectors\" ,result_mapLog1pToSelf,v_mapLog1pToSelf.getData(),normTolerance);\n+\n+        //octave =  cosh(v1)\n+        RealVector v_mapCosh = v1.mapCosh();\n+        double[] result_mapCosh = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};\n+        assertClose(\"compare vectors\" ,result_mapCosh,v_mapCosh.getData(),normTolerance);\n+\n+        //octave =  cosh(v1)\n+        RealVector v_mapCoshToSelf = v1.copy();\n+        v_mapCoshToSelf.mapCoshToSelf();\n+        double[] result_mapCoshToSelf = {1.543080634815244e+00d,3.762195691083631e+00d, 1.006766199577777e+01d};\n+        assertClose(\"compare vectors\" ,result_mapCoshToSelf,v_mapCoshToSelf.getData(),normTolerance);\n+\n+        //octave =  sinh(v1)\n+        RealVector v_mapSinh = v1.mapSinh();\n+        double[] result_mapSinh = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};\n+        assertClose(\"compare vectors\" ,result_mapSinh,v_mapSinh.getData(),normTolerance);\n+\n+        //octave =  sinh(v1)\n+        RealVector v_mapSinhToSelf = v1.copy();\n+        v_mapSinhToSelf.mapSinhToSelf();\n+        double[] result_mapSinhToSelf = {1.175201193643801e+00d,3.626860407847019e+00d, 1.001787492740990e+01d};\n+        assertClose(\"compare vectors\" ,result_mapSinhToSelf,v_mapSinhToSelf.getData(),normTolerance);\n+\n+        //octave =  tanh(v1)\n+        RealVector v_mapTanh = v1.mapTanh();\n+        double[] result_mapTanh = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTanh,v_mapTanh.getData(),normTolerance);\n+\n+        //octave =  tanh(v1)\n+        RealVector v_mapTanhToSelf = v1.copy();\n+        v_mapTanhToSelf.mapTanhToSelf();\n+        double[] result_mapTanhToSelf = {7.615941559557649e-01d,9.640275800758169e-01d,9.950547536867305e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTanhToSelf,v_mapTanhToSelf.getData(),normTolerance);\n+\n+        //octave =  cos(v1)\n+        RealVector v_mapCos = v1.mapCos();\n+        double[] result_mapCos = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};\n+        assertClose(\"compare vectors\" ,result_mapCos,v_mapCos.getData(),normTolerance);\n+\n+        //octave =  cos(v1)\n+        RealVector v_mapCosToSelf = v1.copy();\n+        v_mapCosToSelf.mapCosToSelf();\n+        double[] result_mapCosToSelf = {5.403023058681398e-01d,-4.161468365471424e-01d, -9.899924966004454e-01d};\n+        assertClose(\"compare vectors\" ,result_mapCosToSelf,v_mapCosToSelf.getData(),normTolerance);\n+\n+        //octave =  sin(v1)\n+        RealVector v_mapSin = v1.mapSin();\n+        double[] result_mapSin = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};\n+        assertClose(\"compare vectors\" ,result_mapSin,v_mapSin.getData(),normTolerance);\n+\n+        //octave =  sin(v1)\n+        RealVector v_mapSinToSelf = v1.copy();\n+        v_mapSinToSelf.mapSinToSelf();\n+        double[] result_mapSinToSelf = {8.414709848078965e-01d,9.092974268256817e-01d,1.411200080598672e-01d};\n+        assertClose(\"compare vectors\" ,result_mapSinToSelf,v_mapSinToSelf.getData(),normTolerance);\n+\n+        //octave =  tan(v1)\n+        RealVector v_mapTan = v1.mapTan();\n+        double[] result_mapTan = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTan,v_mapTan.getData(),normTolerance);\n+\n+        //octave =  tan(v1)\n+        RealVector v_mapTanToSelf = v1.copy();\n+        v_mapTanToSelf.mapTanToSelf();\n+        double[] result_mapTanToSelf = {1.557407724654902e+00d,-2.185039863261519e+00d,-1.425465430742778e-01d};\n+        assertClose(\"compare vectors\" ,result_mapTanToSelf,v_mapTanToSelf.getData(),normTolerance);\n+\n+        double[] vat_a = {0d, 0.5d, 1.0d};\n+        RealVectorImpl vat = new RealVectorImpl(vat_a);\n+\n+        //octave =  acos(vat)\n+        RealVector v_mapAcos = vat.mapAcos();\n+        double[] result_mapAcos = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};\n+        assertClose(\"compare vectors\" ,result_mapAcos,v_mapAcos.getData(),normTolerance);\n+\n+        //octave =  acos(vat)\n+        RealVector v_mapAcosToSelf = vat.copy();\n+        v_mapAcosToSelf.mapAcosToSelf();\n+        double[] result_mapAcosToSelf = {1.570796326794897e+00d,1.047197551196598e+00d, 0.0d};\n+        assertClose(\"compare vectors\" ,result_mapAcosToSelf,v_mapAcosToSelf.getData(),normTolerance);\n+\n+        //octave =  asin(vat)\n+        RealVector v_mapAsin = vat.mapAsin();\n+        double[] result_mapAsin = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};\n+        assertClose(\"compare vectors\" ,result_mapAsin,v_mapAsin.getData(),normTolerance);\n+\n+        //octave =  asin(vat)\n+        RealVector v_mapAsinToSelf = vat.copy();\n+        v_mapAsinToSelf.mapAsinToSelf();        \n+        double[] result_mapAsinToSelf = {0.0d,5.235987755982989e-01d,1.570796326794897e+00d};\n+        assertClose(\"compare vectors\" ,result_mapAsinToSelf,v_mapAsinToSelf.getData(),normTolerance);\n+\n+        //octave =  atan(vat)\n+        RealVector v_mapAtan = vat.mapAtan();\n+        double[] result_mapAtan = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};\n+        assertClose(\"compare vectors\" ,result_mapAtan,v_mapAtan.getData(),normTolerance);\n+\n+        //octave =  atan(vat)\n+        RealVector v_mapAtanToSelf = vat.copy();\n+        v_mapAtanToSelf.mapAtanToSelf();\n+        double[] result_mapAtanToSelf = {0.0d,4.636476090008061e-01d,7.853981633974483e-01d};\n+        assertClose(\"compare vectors\" ,result_mapAtanToSelf,v_mapAtanToSelf.getData(),normTolerance);\n+\n+        //octave =  v1 .^-1\n+        RealVector v_mapInv = v1.mapInv();\n+        double[] result_mapInv = {1d,0.5d,3.333333333333333e-01d};\n+        assertClose(\"compare vectors\" ,result_mapInv,v_mapInv.getData(),normTolerance);\n+\n+        //octave =  v1 .^-1\n+        RealVector v_mapInvToSelf = v1.copy();\n+        v_mapInvToSelf.mapInvToSelf();\n+        double[] result_mapInvToSelf = {1d,0.5d,3.333333333333333e-01d};\n+        assertClose(\"compare vectors\" ,result_mapInvToSelf,v_mapInvToSelf.getData(),normTolerance);\n+\n+        double[] abs_a = {-1.0d, 0.0d, 1.0d};\n+        RealVectorImpl abs_v = new RealVectorImpl(abs_a);\n+\n+        //octave =  abs(abs_v)\n+        RealVector v_mapAbs = abs_v.mapAbs();\n+        double[] result_mapAbs = {1d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapAbs,v_mapAbs.getData(),normTolerance);\n+\n+        //octave = abs(abs_v)\n+        RealVector v_mapAbsToSelf = abs_v.copy();\n+        v_mapAbsToSelf.mapAbsToSelf();\n+        double[] result_mapAbsToSelf = {1d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapAbsToSelf,v_mapAbsToSelf.getData(),normTolerance);\n+\n+        //octave =   sqrt(v1)\n+        RealVector v_mapSqrt = v1.mapSqrt();\n+        double[] result_mapSqrt = {1d,1.414213562373095e+00d,1.732050807568877e+00d};\n+        assertClose(\"compare vectors\" ,result_mapSqrt,v_mapSqrt.getData(),normTolerance);\n+\n+        //octave =  sqrt(v1)\n+        RealVector v_mapSqrtToSelf = v1.copy();\n+        v_mapSqrtToSelf.mapSqrtToSelf();\n+        double[] result_mapSqrtToSelf = {1d,1.414213562373095e+00d,1.732050807568877e+00d};\n+        assertClose(\"compare vectors\" ,result_mapSqrtToSelf,v_mapSqrtToSelf.getData(),normTolerance);\n+\n+        double[] cbrt_a = {-2.0d, 0.0d, 2.0d};\n+        RealVectorImpl cbrt_v = new RealVectorImpl(cbrt_a);\n+\n+        //octave =  ???\n+        RealVector v_mapCbrt = cbrt_v.mapCbrt();\n+        double[] result_mapCbrt = {-1.2599210498948732d,0d,1.2599210498948732d};\n+        assertClose(\"compare vectors\" ,result_mapCbrt,v_mapCbrt.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapCbrtToSelf = cbrt_v.copy();\n+        v_mapCbrtToSelf.mapCbrtToSelf();\n+        double[] result_mapCbrtToSelf =  {-1.2599210498948732d,0d,1.2599210498948732d};\n+        assertClose(\"compare vectors\" ,result_mapCbrtToSelf,v_mapCbrtToSelf.getData(),normTolerance);\n+\n+        double[] ceil_a = {-1.1d, 0.9d, 1.1d};\n+        RealVectorImpl ceil_v = new RealVectorImpl(ceil_a);\n+\n+        //octave =  ceil(ceil_v)\n+        RealVector v_mapCeil = ceil_v.mapCeil();\n+        double[] result_mapCeil = {-1d,1d,2d};\n+        assertClose(\"compare vectors\" ,result_mapCeil,v_mapCeil.getData(),normTolerance);\n+\n+        //octave = ceil(ceil_v)\n+        RealVector v_mapCeilToSelf = ceil_v.copy();\n+        v_mapCeilToSelf.mapCeilToSelf();\n+        double[] result_mapCeilToSelf =  {-1d,1d,2d};\n+        assertClose(\"compare vectors\" ,result_mapCeilToSelf,v_mapCeilToSelf.getData(),normTolerance);\n+\n+        //octave =  floor(ceil_v)\n+        RealVector v_mapFloor = ceil_v.mapFloor();\n+        double[] result_mapFloor = {-2d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapFloor,v_mapFloor.getData(),normTolerance);\n+\n+        //octave = floor(ceil_v)\n+        RealVector v_mapFloorToSelf = ceil_v.copy();\n+        v_mapFloorToSelf.mapFloorToSelf();\n+        double[] result_mapFloorToSelf =  {-2d,0d,1d};\n+        assertClose(\"compare vectors\" ,result_mapFloorToSelf,v_mapFloorToSelf.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapRint = ceil_v.mapRint();\n+        double[] result_mapRint = {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapRint,v_mapRint.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapRintToSelf = ceil_v.copy();\n+        v_mapRintToSelf.mapRintToSelf();\n+        double[] result_mapRintToSelf =  {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapRintToSelf,v_mapRintToSelf.getData(),normTolerance);\n+\n+        //octave =  ???\n+        RealVector v_mapSignum = ceil_v.mapSignum();\n+        double[] result_mapSignum = {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapSignum,v_mapSignum.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapSignumToSelf = ceil_v.copy();\n+        v_mapSignumToSelf.mapSignumToSelf();\n+        double[] result_mapSignumToSelf =  {-1d,1d,1d};\n+        assertClose(\"compare vectors\" ,result_mapSignumToSelf,v_mapSignumToSelf.getData(),normTolerance);\n+\n+\n+        // Is with the used resolutions of limited value as test\n+        //octave =  ???\n+        RealVector v_mapUlp = ceil_v.mapUlp();\n+        double[] result_mapUlp = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};\n+        assertClose(\"compare vectors\" ,result_mapUlp,v_mapUlp.getData(),normTolerance);\n+\n+        //octave = ???\n+        RealVector v_mapUlpToSelf = ceil_v.copy();\n+        v_mapUlpToSelf.mapUlpToSelf();\n+        double[] result_mapUlpToSelf = {2.220446049250313E-16d,1.1102230246251565E-16d,2.220446049250313E-16d};\n+        assertClose(\"compare vectors\" ,result_mapUlpToSelf,v_mapUlpToSelf.getData(),normTolerance);\n+\n+    }\n+\n+    public void testBasicFunctions() { \n+        RealVectorImpl v1 = new RealVectorImpl(vec1);\n+        RealVectorImpl v2 = new RealVectorImpl(vec2);\n+        RealVectorImpl v_null = new RealVectorImpl(vec_null);\n+\n+        RealVectorTestImpl v2_t = new RealVectorTestImpl(vec2); \n+\n+        //octave =  sqrt(sumsq(v1))\n+        double d_getNorm = v1.getNorm();\n+        assertEquals(\"compare values  \", 3.7416573867739413,d_getNorm);\n+\n+        double d_getL1Norm = v1.getL1Norm();\n+        assertEquals(\"compare values  \",6.0, d_getL1Norm);\n+\n+        double d_getLInfNorm = v1.getLInfNorm();\n+        assertEquals(\"compare values  \",6.0, d_getLInfNorm);\n+\n+        //octave =  sqrt(sumsq(v1-v2))\n+        double dist = v1.getDistance(v2);\n+        assertEquals(\"compare values  \",v1.subtract(v2).getNorm(), dist );\n+\n+        //octave =  sqrt(sumsq(v1-v2))\n+        double dist_2 = v1.getDistance(v2_t);\n+        assertEquals(\"compare values  \", v1.subtract(v2).getNorm(),dist_2 );\n+\n+        //octave =  ???\n+        double d_getL1Distance = v1. getL1Distance(v2);\n+        assertEquals(\"compare values  \",9d, d_getL1Distance );\n+\n+        double d_getL1Distance_2 = v1. getL1Distance(v2_t);\n+        assertEquals(\"compare values  \",9d, d_getL1Distance_2 );\n+\n+        //octave =  ???\n+        double d_getLInfDistance = v1. getLInfDistance(v2);\n+        assertEquals(\"compare values  \",3d, d_getLInfDistance );\n+\n+        double d_getLInfDistance_2 = v1. getLInfDistance(v2_t);\n+        assertEquals(\"compare values  \",3d, d_getLInfDistance_2 );\n+\n+        //octave =  v1 + v2\n+        RealVectorImpl v_add = v1.add(v2);\n+        double[] result_add = {5d, 7d, 9d};\n+        assertClose(\"compare vect\" ,v_add.getData(),result_add,normTolerance);\n+\n+        RealVectorTestImpl vt2 = new RealVectorTestImpl(vec2);\n+        RealVector v_add_i = v1.add(vt2);\n+        double[] result_add_i = {5d, 7d, 9d};\n+        assertClose(\"compare vect\" ,v_add_i.getData(),result_add_i,normTolerance);\n+\n+        //octave =  v1 - v2\n+        RealVectorImpl v_subtract = v1.subtract(v2);\n+        double[] result_subtract = {-3d, -3d, -3d};\n+        assertClose(\"compare vect\" ,v_subtract.getData(),result_subtract,normTolerance);\n+\n+        RealVector v_subtract_i = v1.subtract(vt2);\n+        double[] result_subtract_i = {-3d, -3d, -3d};\n+        assertClose(\"compare vect\" ,v_subtract_i.getData(),result_subtract_i,normTolerance);\n+\n+        // octave v1 .* v2\n+        RealVectorImpl  v_ebeMultiply = v1.ebeMultiply(v2);\n+        double[] result_ebeMultiply = {4d, 10d, 18d};\n+        assertClose(\"compare vect\" ,v_ebeMultiply.getData(),result_ebeMultiply,normTolerance);\n+\n+        RealVector  v_ebeMultiply_2 = v1.ebeMultiply(v2_t);\n+        double[] result_ebeMultiply_2 = {4d, 10d, 18d};\n+        assertClose(\"compare vect\" ,v_ebeMultiply_2.getData(),result_ebeMultiply_2,normTolerance);\n+\n+        // octave v1 ./ v2\n+        RealVectorImpl  v_ebeDivide = v1.ebeDivide(v2);\n+        double[] result_ebeDivide = {0.25d, 0.4d, 0.5d};\n+        assertClose(\"compare vect\" ,v_ebeDivide.getData(),result_ebeDivide,normTolerance);\n+\n+        RealVector  v_ebeDivide_2 = v1.ebeDivide(v2_t);\n+        double[] result_ebeDivide_2 = {0.25d, 0.4d, 0.5d};\n+        assertClose(\"compare vect\" ,v_ebeDivide_2.getData(),result_ebeDivide_2,normTolerance);\n+\n+        // octave  dot(v1,v2)\n+        double dot =  v1.dotProduct(v2);\n+        assertEquals(\"compare val \",32d, dot);\n+\n+        // octave  dot(v1,v2_t)\n+        double dot_2 =  v1.dotProduct(v2_t);\n+        assertEquals(\"compare val \",32d, dot_2);\n+\n+        RealMatrixImpl m_outerProduct = v1.outerProduct(v2);\n+        assertEquals(\"compare val \",4d, m_outerProduct.getEntry(0,0));\n+\n+        RealMatrix m_outerProduct_2 = v1.outerProduct(v2_t);\n+        assertEquals(\"compare val \",4d, m_outerProduct_2.getEntry(0,0));\n+\n+        RealVector v_unitVector = v1.unitVector();\n+        RealVector v_unitVector_2 = v1.mapDivide(v1.getNorm()); \n+        assertClose(\"compare vect\" ,v_unitVector.getData(),v_unitVector_2.getData(),normTolerance);\n+\n+        try {\n+            v_null.unitVector();\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVectorImpl v_unitize = (RealVectorImpl)v1.copy();\n+        v_unitize.unitize();\n+        assertClose(\"compare vect\" ,v_unitVector_2.getData(),v_unitize.getData(),normTolerance);\n+        try {\n+            v_null.unitize();\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+\n+        RealVectorImpl v_projection = v1.projection(v2);\n+        double[] result_projection = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n+        assertClose(\"compare vect\", v_projection.getData(), result_projection, normTolerance);\n+\n+        RealVector v_projection_2 = v1.projection(v2_t);\n+        double[] result_projection_2 = {1.662337662337662, 2.0779220779220777, 2.493506493506493};\n+        assertClose(\"compare vect\", v_projection_2.getData(), result_projection_2, normTolerance);\n+\n+    }  \n+\n+    public void testMisc() { \n+        RealVectorImpl v1 = new RealVectorImpl(vec1);\n+        RealVectorImpl v4 = new RealVectorImpl(vec4);\n+        RealVector v4_2 = new RealVectorImpl(vec4);\n+\n+        String out1 = v1.toString();\n+        assertTrue(\"some output \",  out1.length()!=0);\n+        /*    \n+         double[] dout1 = v1.copyOut();\n+        assertEquals(\"testData len\", 3, dout1.length);\n+        assertNotSame(\"testData not same object \", v1.data, dout1);   \n+         */      \n+        try {\n+            v1.checkVectorDimensions(2); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        } \n+\n+       try {\n+            v1.checkVectorDimensions(v4); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }        \n+\n+        try {\n+            v1.checkVectorDimensions(v4_2); \n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }        \n+\n+    }\n+\n+    public void testPredicates() {\n+\n+        RealVectorImpl v = new RealVectorImpl(new double[] { 0, 1, 2 });\n+\n+        assertFalse(v.isNaN());\n+        v.set(1, Double.NaN);\n+        assertTrue(v.isNaN());\n+\n+        assertFalse(v.isInfinite());\n+        v.set(0, Double.POSITIVE_INFINITY);\n+        assertFalse(v.isInfinite());\n+        v.set(1, 1);\n+        assertTrue(v.isInfinite());\n+\n+        v.set(0, 0);\n+        assertEquals(v, new RealVectorImpl(new double[] { 0, 1, 2 }));\n+        assertNotSame(v, new RealVectorImpl(new double[] { 0, 1, 2 + Math.ulp(2)}));\n+        assertNotSame(v, new RealVectorImpl(new double[] { 0, 1, 2, 3 }));\n+\n+        assertEquals(new RealVectorImpl(new double[] { Double.NaN, 1, 2 }).hashCode(),\n+                     new RealVectorImpl(new double[] { 0, Double.NaN, 2 }).hashCode());\n+\n+        assertTrue(new RealVectorImpl(new double[] { Double.NaN, 1, 2 }).hashCode() !=\n+                   new RealVectorImpl(new double[] { 0, 1, 2 }).hashCode());\n+\n+    }\n+\n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertClose(String msg, double[] m, double[] n,\n+            double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors have different lengths\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" +  i + \" elements differ\", m[i],n[i],tolerance);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/TriDiagonalTransformerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Arrays;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class TriDiagonalTransformerTest extends TestCase {\n+\n+    private double[][] testSquare5 = {\n+            { 1, 2, 3, 1, 1 },\n+            { 2, 1, 1, 3, 1 },\n+            { 3, 1, 1, 1, 2 },\n+            { 1, 3, 1, 2, 1 },\n+            { 1, 1, 2, 1, 3 }\n+    };\n+\n+    private double[][] testSquare3 = {\n+            { 1, 3, 4 },\n+            { 3, 2, 2 },\n+            { 4, 2, 0 }\n+    };\n+\n+    public TriDiagonalTransformerTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testNonSquare() {\n+        try {\n+            new TriDiagonalTransformer(new RealMatrixImpl(new double[3][2], false));\n+            fail(\"an exception should have been thrown\");\n+        } catch (InvalidMatrixException ime) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    public void testAEqualQTQt() {\n+        checkAEqualQTQt(new RealMatrixImpl(testSquare5, false));\n+        checkAEqualQTQt(new RealMatrixImpl(testSquare3, false));\n+    }\n+\n+    private void checkAEqualQTQt(RealMatrix matrix) {\n+        TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix);\n+        RealMatrix q  = transformer.getQ();\n+        RealMatrix qT = transformer.getQT();\n+        RealMatrix t  = transformer.getT();\n+        double norm = q.multiply(t).multiply(qT).subtract(matrix).getNorm();\n+        assertEquals(0, norm, 4.0e-15);\n+    }\n+\n+    public void testNoAccessBelowDiagonal() {\n+        checkNoAccessBelowDiagonal(testSquare5);\n+        checkNoAccessBelowDiagonal(testSquare3);\n+    }\n+\n+    private void checkNoAccessBelowDiagonal(double[][] data) {\n+        double[][] modifiedData = new double[data.length][];\n+        for (int i = 0; i < data.length; ++i) {\n+            modifiedData[i] = data[i].clone();\n+            Arrays.fill(modifiedData[i], 0, i, Double.NaN);\n+        }\n+        RealMatrix matrix = new RealMatrixImpl(modifiedData, false);\n+        TriDiagonalTransformer transformer = new TriDiagonalTransformer(matrix);\n+        RealMatrix q  = transformer.getQ();\n+        RealMatrix qT = transformer.getQT();\n+        RealMatrix t  = transformer.getT();\n+        double norm = q.multiply(t).multiply(qT).subtract(new RealMatrixImpl(data, false)).getNorm();\n+        assertEquals(0, norm, 4.0e-15);\n+    }\n+\n+    public void testQOrthogonal() {\n+        checkOrthogonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare5, false)).getQ());\n+        checkOrthogonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare3, false)).getQ());\n+    }\n+\n+    public void testQTOrthogonal() {\n+        checkOrthogonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare5, false)).getQT());\n+        checkOrthogonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare3, false)).getQT());\n+    }\n+\n+    private void checkOrthogonal(RealMatrix m) {\n+        RealMatrix mTm = m.transpose().multiply(m);\n+        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());\n+        assertEquals(0, mTm.subtract(id).getNorm(), 1.0e-15);        \n+    }\n+\n+    public void testTTriDiagonal() {\n+        checkTriDiagonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare5, false)).getT());\n+        checkTriDiagonal(new TriDiagonalTransformer(new RealMatrixImpl(testSquare3, false)).getT());\n+    }\n+\n+    private void checkTriDiagonal(RealMatrix m) {\n+        final int rows = m.getRowDimension();\n+        final int cols = m.getColumnDimension();\n+        for (int i = 0; i < rows; ++i) {\n+            for (int j = 0; j < cols; ++j) {\n+                if ((i < j - 1) || (i > j + 1)) {\n+                    assertEquals(0, m.getEntry(i, j), 1.0e-16);\n+                }                    \n+            }\n+        }\n+    }\n+\n+    public void testMatricesValues5() {\n+        checkMatricesValues(testSquare5,\n+                            new double[][] {\n+                                { 1.0,  0.0,                 0.0,                  0.0,                   0.0 },\n+                                { 0.0, -0.5163977794943222,  0.016748280772542083, 0.839800693771262,     0.16669620021405473 },\n+                                { 0.0, -0.7745966692414833, -0.4354553000860955,  -0.44989322880603355,  -0.08930153582895772 },\n+                                { 0.0, -0.2581988897471611,  0.6364346693566014,  -0.30263204032131164,   0.6608313651342882 },\n+                                { 0.0, -0.2581988897471611,  0.6364346693566009,  -0.027289660803112598, -0.7263191580755246 }\n+                            },\n+                            new double[] { 1, 4.4, 1.433099579242636, -0.89537362758743, 2.062274048344794 },\n+                            new double[] { -Math.sqrt(15), -3.0832882879592476, 0.6082710842351517, 1.1786086405912128 });\n+    }\n+\n+    public void testMatricesValues3() {\n+        checkMatricesValues(testSquare3,\n+                            new double[][] {\n+                                {  1.0,  0.0,  0.0 },\n+                                {  0.0, -0.6,  0.8 },\n+                                {  0.0, -0.8, -0.6 },\n+                            },\n+                            new double[] { 1, 2.64, -0.64 },\n+                            new double[] { -5, -1.52 });\n+    }\n+\n+    private void checkMatricesValues(double[][] matrix, double[][] qRef,\n+                                     double[] mainDiagnonal,\n+                                     double[] secondaryDiagonal) {\n+        TriDiagonalTransformer transformer =\n+            new TriDiagonalTransformer(new RealMatrixImpl(matrix, false));\n+\n+        // check values against known references\n+        RealMatrix q = transformer.getQ();\n+        assertEquals(0, q.subtract(new RealMatrixImpl(qRef, false)).getNorm(), 1.0e-14);\n+\n+        RealMatrix t = transformer.getT();\n+        double[][] tData = new double[mainDiagnonal.length][mainDiagnonal.length];\n+        for (int i = 0; i < mainDiagnonal.length; ++i) {\n+            tData[i][i] = mainDiagnonal[i];\n+            if (i > 0) {\n+                tData[i][i - 1] = secondaryDiagonal[i - 1];\n+            }\n+            if (i < secondaryDiagonal.length) {\n+                tData[i][i + 1] = secondaryDiagonal[i];\n+            }\n+        }\n+        assertEquals(0, t.subtract(new RealMatrixImpl(tData, false)).getNorm(), 1.0e-14);\n+\n+        // check the same cached instance is returned the second time\n+        assertTrue(q == transformer.getQ());\n+        assertTrue(t == transformer.getT());\n+        \n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(TriDiagonalTransformerTest.class);\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n+++ b/src/test/org/apache/commons/math/ode/ContinuousOutputModelTest.java\n \n import org.apache.commons.math.ode.ContinuousOutputModel;\n import org.apache.commons.math.ode.DerivativeException;\n-import org.apache.commons.math.ode.DormandPrince54Integrator;\n import org.apache.commons.math.ode.FirstOrderIntegrator;\n import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;\n+import org.apache.commons.math.ode.nonstiff.TestProblem3;\n+import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n \n public class ContinuousOutputModelTest\n   extends TestCase {\n \n   public void testBoundaries()\n     throws DerivativeException, IntegratorException {\n-    integ.setStepHandler(new ContinuousOutputModel());\n+    integ.addStepHandler(new ContinuousOutputModel());\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n-    ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandler();\n+    ContinuousOutputModel cm = (ContinuousOutputModel) integ.getStepHandlers().iterator().next();\n     cm.setInterpolatedTime(2.0 * pb.getInitialTime() - pb.getFinalTime());\n     cm.setInterpolatedTime(2.0 * pb.getFinalTime() - pb.getInitialTime());\n     cm.setInterpolatedTime(0.5 * (pb.getFinalTime() + pb.getInitialTime()));\n     throws DerivativeException, IntegratorException {\n \n     ContinuousOutputModel cm = new ContinuousOutputModel();\n-    integ.setStepHandler(cm);\n+    integ.addStepHandler(cm);\n     integ.integrate(pb,\n                     pb.getInitialTime(), pb.getInitialState(),\n                     pb.getFinalTime(), new double[pb.getDimension()]);\n       // theoretical solution: y[0] = cos(t), y[1] = sin(t)\n       FirstOrderDifferentialEquations problem =\n           new FirstOrderDifferentialEquations() {\n-          public void computeDerivatives(double t, double[] y, double[] dot)\n-          throws DerivativeException {\n-              dot[0] = -y[1];\n-              dot[1] =  y[0];\n-          }\n-          public int getDimension() {\n-              return 2;\n-          }\n-      };\n+              private static final long serialVersionUID = 2472449657345878299L;\n+              public void computeDerivatives(double t, double[] y, double[] dot)\n+                  throws DerivativeException {\n+                  dot[0] = -y[1];\n+                  dot[1] =  y[0];\n+              }\n+              public int getDimension() {\n+                  return 2;\n+              }\n+          };\n \n       // integrate backward from &pi; to 0;\n       ContinuousOutputModel cm1 = new ContinuousOutputModel();\n       FirstOrderIntegrator integ1 =\n           new DormandPrince853Integrator(0, 1.0, 1.0e-8, 1.0e-8);\n-      integ1.setStepHandler(cm1);\n+      integ1.addStepHandler(cm1);\n       integ1.integrate(problem, Math.PI, new double[] { -1.0, 0.0 },\n                        0, new double[2]);\n \n       ContinuousOutputModel cm2 = new ContinuousOutputModel();\n       FirstOrderIntegrator integ2 =\n           new DormandPrince853Integrator(0, 0.1, 1.0e-12, 1.0e-12);\n-      integ2.setStepHandler(cm2);\n+      integ2.addStepHandler(cm2);\n       integ2.integrate(problem, 2.0 * Math.PI, new double[] { 1.0, 0.0 },\n                        Math.PI, new double[2]);\n \n--- a/src/test/org/apache/commons/math/ode/FirstOrderConverterTest.java\n+++ b/src/test/org/apache/commons/math/ode/FirstOrderConverterTest.java\n \n package org.apache.commons.math.ode;\n \n-import org.apache.commons.math.ode.ClassicalRungeKuttaIntegrator;\n import org.apache.commons.math.ode.DerivativeException;\n import org.apache.commons.math.ode.FirstOrderConverter;\n import org.apache.commons.math.ode.IntegratorException;\n import org.apache.commons.math.ode.SecondOrderDifferentialEquations;\n+import org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator;\n \n import junit.framework.*;\n \n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+\n+public class AdamsBashforthIntegratorTest\n+  extends TestCase {\n+\n+  public AdamsBashforthIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testCoefficients() {\n+\n+      double[] coeffs1 = new AdamsBashforthIntegrator(1, 0.01).getCoeffs();\n+      assertEquals(1, coeffs1.length);\n+      assertEquals(1.0, coeffs1[0], 1.0e-16);\n+\n+      double[] coeffs2 = new AdamsBashforthIntegrator(2, 0.01).getCoeffs();\n+      assertEquals(2, coeffs2.length);\n+      assertEquals( 3.0 / 2.0, coeffs2[0], 1.0e-16);\n+      assertEquals(-1.0 / 2.0, coeffs2[1], 1.0e-16);\n+\n+      double[] coeffs3 = new AdamsBashforthIntegrator(3, 0.01).getCoeffs();\n+      assertEquals(3, coeffs3.length);\n+      assertEquals( 23.0 / 12.0, coeffs3[0], 1.0e-16);\n+      assertEquals(-16.0 / 12.0, coeffs3[1], 1.0e-16);\n+      assertEquals(  5.0 / 12.0, coeffs3[2], 1.0e-16);\n+\n+      double[] coeffs4 = new AdamsBashforthIntegrator(4, 0.01).getCoeffs();\n+      assertEquals(4, coeffs4.length);\n+      assertEquals( 55.0 / 24.0, coeffs4[0], 1.0e-16);\n+      assertEquals(-59.0 / 24.0, coeffs4[1], 1.0e-16);\n+      assertEquals( 37.0 / 24.0, coeffs4[2], 1.0e-16);\n+      assertEquals( -9.0 / 24.0, coeffs4[3], 1.0e-16);\n+\n+      double[] coeffs5 = new AdamsBashforthIntegrator(5, 0.01).getCoeffs();\n+      assertEquals(5, coeffs5.length);\n+      assertEquals( 1901.0 / 720.0, coeffs5[0], 1.0e-16);\n+      assertEquals(-2774.0 / 720.0, coeffs5[1], 1.0e-16);\n+      assertEquals( 2616.0 / 720.0, coeffs5[2], 1.0e-16);\n+      assertEquals(-1274.0 / 720.0, coeffs5[3], 1.0e-16);\n+      assertEquals(  251.0 / 720.0, coeffs5[4], 1.0e-16);\n+\n+      double[] coeffs6 = new AdamsBashforthIntegrator(6, 0.01).getCoeffs();\n+      assertEquals(6, coeffs6.length);\n+      assertEquals( 4277.0 / 1440.0, coeffs6[0], 1.0e-16);\n+      assertEquals(-7923.0 / 1440.0, coeffs6[1], 1.0e-16);\n+      assertEquals( 9982.0 / 1440.0, coeffs6[2], 1.0e-16);\n+      assertEquals(-7298.0 / 1440.0, coeffs6[3], 1.0e-16);\n+      assertEquals( 2877.0 / 1440.0, coeffs6[4], 1.0e-16);\n+      assertEquals( -475.0 / 1440.0, coeffs6[5], 1.0e-16);\n+\n+      double[] coeffs7 = new AdamsBashforthIntegrator(7, 0.01).getCoeffs();\n+      assertEquals(7, coeffs7.length);\n+      assertEquals( 198721.0 / 60480.0, coeffs7[0], 1.0e-16);\n+      assertEquals(-447288.0 / 60480.0, coeffs7[1], 1.0e-16);\n+      assertEquals( 705549.0 / 60480.0, coeffs7[2], 1.0e-16);\n+      assertEquals(-688256.0 / 60480.0, coeffs7[3], 1.0e-16);\n+      assertEquals( 407139.0 / 60480.0, coeffs7[4], 1.0e-16);\n+      assertEquals(-134472.0 / 60480.0, coeffs7[5], 1.0e-16);\n+      assertEquals(  19087.0 / 60480.0, coeffs7[6], 1.0e-16);\n+\n+      double[] coeffs8 = new AdamsBashforthIntegrator(8, 0.01).getCoeffs();\n+      assertEquals(8, coeffs8.length);\n+      assertEquals(  434241.0 / 120960.0, coeffs8[0], 1.0e-16);\n+      assertEquals(-1152169.0 / 120960.0, coeffs8[1], 1.0e-16);\n+      assertEquals( 2183877.0 / 120960.0, coeffs8[2], 1.0e-16);\n+      assertEquals(-2664477.0 / 120960.0, coeffs8[3], 1.0e-16);\n+      assertEquals( 2102243.0 / 120960.0, coeffs8[4], 1.0e-16);\n+      assertEquals(-1041723.0 / 120960.0, coeffs8[5], 1.0e-16);\n+      assertEquals(  295767.0 / 120960.0, coeffs8[6], 1.0e-16);\n+      assertEquals(  -36799.0 / 120960.0, coeffs8[7], 1.0e-16);\n+\n+      double[] coeffs9 = new AdamsBashforthIntegrator(9, 0.01).getCoeffs();\n+      assertEquals(9, coeffs9.length);\n+      assertEquals(  14097247.0 / 3628800.0, coeffs9[0], 1.0e-16);\n+      assertEquals( -43125206.0 / 3628800.0, coeffs9[1], 1.0e-16);\n+      assertEquals(  95476786.0 / 3628800.0, coeffs9[2], 1.0e-16);\n+      assertEquals(-139855262.0 / 3628800.0, coeffs9[3], 1.0e-16);\n+      assertEquals( 137968480.0 / 3628800.0, coeffs9[4], 1.0e-16);\n+      assertEquals( -91172642.0 / 3628800.0, coeffs9[5], 1.0e-16);\n+      assertEquals(  38833486.0 / 3628800.0, coeffs9[6], 1.0e-16);\n+      assertEquals(  -9664106.0 / 3628800.0, coeffs9[7], 1.0e-16);\n+      assertEquals(   1070017.0 / 3628800.0, coeffs9[8], 1.0e-16);\n+\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new AdamsBashforthIntegrator(3, 0.01).integrate(pb,\n+                                                      0.0, new double[pb.getDimension()+10],\n+                                                      1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 6; i < 10; ++i) {\n+\n+        TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        EventHandler[] functions = pb.getEventsHandlers();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addEventHandler(functions[l],\n+                                Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n+        }\n+        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                                          pb.getFinalTime(), new double[pb.getDimension()]);\n+        if (functions.length == 0) {\n+          assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+        }\n+\n+        double error = handler.getMaximalValueError();\n+        if (i > 6) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new AdamsBashforthIntegrator(3, step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+   assertTrue(handler.getLastError() < 2.0e-9);\n+   assertTrue(handler.getMaximalValueError() < 3.0e-8);\n+   assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);\n+   assertEquals(\"Adams-Bashforth\", integ.getName());\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new AdamsBashforthIntegrator(3, step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.05);\n+    assertTrue(handler.getMaximalValueError() > 0.1);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);\n+\n+  }\n+\n+  public void testBackward()\n+      throws DerivativeException, IntegratorException {\n+\n+      TestProblem5 pb = new TestProblem5();\n+      double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+      FirstOrderIntegrator integ = new AdamsBashforthIntegrator(5, step);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      assertTrue(handler.getLastError() < 8.0e-11);\n+      assertTrue(handler.getMaximalValueError() < 8.0e-11);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      assertEquals(\"Adams-Bashforth\", integ.getName());\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(AdamsBashforthIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+public class AdamsMoultonIntegratorTest\n+  extends TestCase {\n+\n+    public AdamsMoultonIntegratorTest(String name) {\n+        super(name);\n+    }\n+\n+    public void testPredictorCoefficients() {\n+        for (int order = 1; order < 10; ++order) {\n+            double[] moulton = new AdamsMoultonIntegrator(order, 0.01).getPredictorCoeffs();\n+            double[] bashforth  = new AdamsBashforthIntegrator(order, 0.01).getCoeffs();\n+            assertEquals(bashforth.length, moulton.length);\n+            for (int i = 0; i < moulton.length; ++i) {\n+                assertEquals(bashforth[i], moulton[i], 1.0e-16);\n+            }\n+        }\n+    }\n+\n+    public void testCorrectorCoefficients() {\n+\n+        double[] coeffs1 = new AdamsMoultonIntegrator(1, 0.01).getCorrectorCoeffs();\n+        assertEquals(2, coeffs1.length);\n+        assertEquals(1.0 / 2.0, coeffs1[0], 1.0e-16);\n+        assertEquals(1.0 / 2.0, coeffs1[1], 1.0e-16);\n+\n+        double[] coeffs2 = new AdamsMoultonIntegrator(2, 0.01).getCorrectorCoeffs();\n+        assertEquals(3, coeffs2.length);\n+        assertEquals( 5.0 / 12.0, coeffs2[0], 1.0e-16);\n+        assertEquals( 8.0 / 12.0, coeffs2[1], 1.0e-16);\n+        assertEquals(-1.0 / 12.0, coeffs2[2], 1.0e-16);\n+\n+        double[] coeffs3 = new AdamsMoultonIntegrator(3, 0.01).getCorrectorCoeffs();\n+        assertEquals(4, coeffs3.length);\n+        assertEquals( 9.0 / 24.0, coeffs3[0], 1.0e-16);\n+        assertEquals(19.0 / 24.0, coeffs3[1], 1.0e-16);\n+        assertEquals(-5.0 / 24.0, coeffs3[2], 1.0e-16);\n+        assertEquals( 1.0 / 24.0, coeffs3[3], 1.0e-16);\n+\n+        double[] coeffs4 = new AdamsMoultonIntegrator(4, 0.01).getCorrectorCoeffs();\n+        assertEquals(5, coeffs4.length);\n+        assertEquals( 251.0 / 720.0, coeffs4[0], 1.0e-16);\n+        assertEquals( 646.0 / 720.0, coeffs4[1], 1.0e-16);\n+        assertEquals(-264.0 / 720.0, coeffs4[2], 1.0e-16);\n+        assertEquals( 106.0 / 720.0, coeffs4[3], 1.0e-16);\n+        assertEquals( -19.0 / 720.0, coeffs4[4], 1.0e-16);\n+\n+        double[] coeffs5 = new AdamsMoultonIntegrator(5, 0.01).getCorrectorCoeffs();\n+        assertEquals(6, coeffs5.length);\n+        assertEquals( 475.0 / 1440.0, coeffs5[0], 1.0e-16);\n+        assertEquals(1427.0 / 1440.0, coeffs5[1], 1.0e-16);\n+        assertEquals(-798.0 / 1440.0, coeffs5[2], 1.0e-16);\n+        assertEquals( 482.0 / 1440.0, coeffs5[3], 1.0e-16);\n+        assertEquals(-173.0 / 1440.0, coeffs5[4], 1.0e-16);\n+        assertEquals(  27.0 / 1440.0, coeffs5[5], 1.0e-16);\n+\n+        double[] coeffs6 = new AdamsMoultonIntegrator(6, 0.01).getCorrectorCoeffs();\n+        assertEquals(7, coeffs6.length);\n+        assertEquals( 19087.0 / 60480.0, coeffs6[0], 1.0e-16);\n+        assertEquals( 65112.0 / 60480.0, coeffs6[1], 1.0e-16);\n+        assertEquals(-46461.0 / 60480.0, coeffs6[2], 1.0e-16);\n+        assertEquals( 37504.0 / 60480.0, coeffs6[3], 1.0e-16);\n+        assertEquals(-20211.0 / 60480.0, coeffs6[4], 1.0e-16);\n+        assertEquals(  6312.0 / 60480.0, coeffs6[5], 1.0e-16);\n+        assertEquals(  -863.0 / 60480.0, coeffs6[6], 1.0e-16);\n+\n+        double[] coeffs7 = new AdamsMoultonIntegrator(7, 0.01).getCorrectorCoeffs();\n+        assertEquals(8, coeffs7.length);\n+        assertEquals(  36799.0 / 120960.0, coeffs7[0], 1.0e-16);\n+        assertEquals( 139849.0 / 120960.0, coeffs7[1], 1.0e-16);\n+        assertEquals(-121797.0 / 120960.0, coeffs7[2], 1.0e-16);\n+        assertEquals( 123133.0 / 120960.0, coeffs7[3], 1.0e-16);\n+        assertEquals( -88547.0 / 120960.0, coeffs7[4], 1.0e-16);\n+        assertEquals(  41499.0 / 120960.0, coeffs7[5], 1.0e-16);\n+        assertEquals( -11351.0 / 120960.0, coeffs7[6], 1.0e-16);\n+        assertEquals(   1375.0 / 120960.0, coeffs7[7], 1.0e-16);\n+\n+        double[] coeffs8 = new AdamsMoultonIntegrator(8, 0.01).getCorrectorCoeffs();\n+        assertEquals(9, coeffs8.length);\n+        assertEquals( 1070017.0 / 3628800.0, coeffs8[0], 1.0e-16);\n+        assertEquals( 4467094.0 / 3628800.0, coeffs8[1], 1.0e-16);\n+        assertEquals(-4604594.0 / 3628800.0, coeffs8[2], 1.0e-16);\n+        assertEquals( 5595358.0 / 3628800.0, coeffs8[3], 1.0e-16);\n+        assertEquals(-5033120.0 / 3628800.0, coeffs8[4], 1.0e-16);\n+        assertEquals( 3146338.0 / 3628800.0, coeffs8[5], 1.0e-16);\n+        assertEquals(-1291214.0 / 3628800.0, coeffs8[6], 1.0e-16);\n+        assertEquals(  312874.0 / 3628800.0, coeffs8[7], 1.0e-16);\n+        assertEquals(  -33953.0 / 3628800.0, coeffs8[8], 1.0e-16);\n+\n+    }\n+\n+    public void testDimensionCheck() {\n+        try  {\n+            TestProblem1 pb = new TestProblem1();\n+            new AdamsMoultonIntegrator(3, 0.01).integrate(pb,\n+                    0.0, new double[pb.getDimension()+10],\n+                    1.0, new double[pb.getDimension()+10]);\n+            fail(\"an exception should have been thrown\");\n+        } catch(DerivativeException de) {\n+            fail(\"wrong exception caught\");\n+        } catch(IntegratorException ie) {\n+        }\n+    }\n+\n+    public void testDecreasingSteps()\n+        throws DerivativeException, IntegratorException {\n+\n+        TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+        for (int k = 0; k < problems.length; ++k) {\n+\n+            double previousError = Double.NaN;\n+            for (int i = 6; i < 10; ++i) {\n+\n+                TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();\n+                double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);\n+                if (pb instanceof TestProblem3) {\n+                    step /= 8;\n+                }\n+\n+                FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, step);\n+                TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+                integ.addStepHandler(handler);\n+                EventHandler[] functions = pb.getEventsHandlers();\n+                for (int l = 0; l < functions.length; ++l) {\n+                    integ.addEventHandler(functions[l],\n+                            Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n+                }\n+                double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+                if (functions.length == 0) {\n+                    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+                }\n+\n+                double error = handler.getMaximalValueError();\n+                if (i > 6) {\n+                    assertTrue(error < Math.abs(previousError));\n+                }\n+                previousError = error;\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+    public void testSmallStep()\n+        throws DerivativeException, IntegratorException {\n+\n+        TestProblem1 pb  = new TestProblem1();\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+        FirstOrderIntegrator integ = new AdamsMoultonIntegrator(3, step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb,\n+                pb.getInitialTime(), pb.getInitialState(),\n+                pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        assertTrue(handler.getLastError() < 7.0e-12);\n+        assertTrue(handler.getMaximalValueError() < 4.0e-11);\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);\n+        assertEquals(\"Adams-Moulton\", integ.getName());\n+\n+    }\n+\n+    public void testBigStep()\n+        throws DerivativeException, IntegratorException {\n+\n+        TestProblem1 pb  = new TestProblem1();\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+        FirstOrderIntegrator integ = new AdamsMoultonIntegrator(3, step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb,\n+                pb.getInitialTime(), pb.getInitialState(),\n+                pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        assertTrue(handler.getLastError() > 0.01);\n+        assertTrue(handler.getMaximalValueError() > 0.03);\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-14);\n+\n+    }\n+\n+    public void testBackward()\n+        throws DerivativeException, IntegratorException {\n+\n+        TestProblem5 pb = new TestProblem5();\n+        double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+        FirstOrderIntegrator integ = new AdamsMoultonIntegrator(5, step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+        assertTrue(handler.getLastError() < 5.0e-10);\n+        assertTrue(handler.getMaximalValueError() < 7.0e-10);\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+        assertEquals(\"Adams-Moulton\", integ.getName());\n+    }\n+\n+    public static Test suite() {\n+        return new TestSuite(AdamsMoultonIntegratorTest.class);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class ClassicalRungeKuttaIntegratorTest\n+  extends TestCase {\n+\n+  public ClassicalRungeKuttaIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testSanityChecks() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,\n+                                                        0.0, new double[pb.getDimension()+10],\n+                                                        1.0, new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+    try  {\n+        TestProblem1 pb = new TestProblem1();\n+        new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,\n+                                                          0.0, new double[pb.getDimension()],\n+                                                          1.0, new double[pb.getDimension()+10]);\n+          fail(\"an exception should have been thrown\");\n+      } catch(DerivativeException de) {\n+        fail(\"wrong exception caught\");\n+      } catch(IntegratorException ie) {\n+      }\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new ClassicalRungeKuttaIntegrator(0.01).integrate(pb,\n+                                                        0.0, new double[pb.getDimension()],\n+                                                        0.0, new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime()) * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        EventHandler[] functions = pb.getEventsHandlers();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addEventHandler(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n+        }\n+        assertEquals(functions.length, integ.getEventHandlers().size());\n+        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                                          pb.getFinalTime(), new double[pb.getDimension()]);\n+        if (functions.length == 0) {\n+            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+        }\n+\n+        double error = handler.getMaximalValueError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+        integ.clearEventHandlers();\n+        assertEquals(0, integ.getEventHandlers().size());\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-13);\n+    assertTrue(handler.getMaximalValueError() < 4.0e-12);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(\"classical Runge-Kutta\", integ.getName());\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.0004);\n+    assertTrue(handler.getMaximalValueError() > 0.005);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+  }\n+\n+  public void testBackward()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem5 pb = new TestProblem5();\n+    double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 5.0e-10);\n+    assertTrue(handler.getMaximalValueError() < 7.0e-10);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(\"classical Runge-Kutta\", integ.getName());\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+\n+    FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    integ.addStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+    private static final long serialVersionUID = 7510061424396717277L;\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double[] interpolatedY = interpolator.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        // even with more than 1000 evaluations per period,\n+        // RK4 is not able to integrate such an eccentric\n+        // orbit with a good accuracy\n+        assertTrue(maxError > 0.005);\n+      }\n+    }\n+    private double maxError = 0;\n+    private TestProblem3 pb;\n+  }\n+\n+  public void testStepSize()\n+    throws DerivativeException, IntegratorException {\n+      final double step = 1.23456;\n+      FirstOrderIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+      integ.addStepHandler(new StepHandler() {\n+          private static final long serialVersionUID = 0L;\n+          public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+              if (! isLast) {\n+                  assertEquals(step,\n+                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),\n+                               1.0e-12);\n+              }\n+          }\n+          public boolean requiresDenseOutput() {\n+              return false;\n+          }\n+          public void reset() {\n+          }          \n+      });\n+      integ.integrate(new FirstOrderDifferentialEquations() {\n+          private static final long serialVersionUID = 0L;\n+          public void computeDerivatives(double t, double[] y, double[] dot) {\n+              dot[0] = 1.0;\n+          }\n+          public int getDimension() {\n+              return 1;\n+          }\n+      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ClassicalRungeKuttaIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+public class ClassicalRungeKuttaStepInterpolatorTest\n+  extends StepInterpolatorAbstractTest {\n+\n+  public ClassicalRungeKuttaStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    checkDerivativesConsistency(integ, pb, 1.0e-10);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+    ClassicalRungeKuttaIntegrator integ = new ClassicalRungeKuttaIntegrator(step);\n+    integ.addStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n+\n+    assertTrue(bos.size () > 700000);\n+    assertTrue(bos.size () < 701000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError > 0.005);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ClassicalRungeKuttaStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince54IntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;\n+import org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+import junit.framework.*;\n+\n+public class DormandPrince54IntegratorTest\n+  extends TestCase {\n+\n+  public DormandPrince54IntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      DormandPrince54Integrator integrator = new DormandPrince54Integrator(0.0, 1.0,\n+                                                                           1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()+10],\n+                           1.0, new double[pb.getDimension()+10]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testMinStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    try {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };\n+      double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };\n+\n+      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                 vecAbsoluteTolerance,\n+                                                                 vecRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testSmallLastStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblemAbstract pb = new TestProblem5();\n+    double minStep = 1.25;\n+    double maxStep = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+    double scalAbsoluteTolerance = 6.0e-4;\n+    double scalRelativeTolerance = 6.0e-4;\n+\n+    AdaptiveStepsizeIntegrator integ =\n+      new DormandPrince54Integrator(minStep, maxStep,\n+                                    scalAbsoluteTolerance,\n+                                    scalRelativeTolerance);\n+\n+    DP54SmallLastHandler handler = new DP54SmallLastHandler(minStep);\n+    integ.addStepHandler(handler);\n+    integ.setInitialStepSize(1.7);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertTrue(handler.wasLastSeen());\n+    assertEquals(\"Dormand-Prince 5(4)\", integ.getName());\n+\n+  }\n+\n+  public void testBackward()\n+      throws DerivativeException, IntegratorException {\n+\n+      TestProblem5 pb = new TestProblem5();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-8;\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                 scalAbsoluteTolerance,\n+                                                                 scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      assertTrue(handler.getLastError() < 2.0e-7);\n+      assertTrue(handler.getMaximalValueError() < 2.0e-7);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      assertEquals(\"Dormand-Prince 5(4)\", integ.getName());\n+  }\n+\n+  private static class DP54SmallLastHandler implements StepHandler {\n+\n+    private static final long serialVersionUID = -8168590945325629799L;\n+\n+    public DP54SmallLastHandler(double minStep) {\n+      lastSeen = false;\n+      this.minStep = minStep;\n+    }\n+\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+\n+    public void reset() {\n+    }\n+\n+    public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+      if (isLast) {\n+        lastSeen = true;\n+        double h = interpolator.getCurrentTime() - interpolator.getPreviousTime();\n+        assertTrue(Math.abs(h) < minStep);\n+      }\n+    }\n+\n+    public boolean wasLastSeen() {\n+      return lastSeen;\n+    }\n+\n+    private boolean lastSeen;\n+    private double  minStep;\n+\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -2; ++i) {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = Math.pow(10.0, i);\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      EmbeddedRungeKuttaIntegrator integ =\n+          new DormandPrince54Integrator(minStep, maxStep,\n+                                        scalAbsoluteTolerance, scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.setSafety(0.8);\n+      integ.setMaxGrowth(5.0);\n+      integ.setMinReduction(0.3);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      assertEquals(0.8, integ.getSafety(), 1.0e-12);\n+      assertEquals(5.0, integ.getMaxGrowth(), 1.0e-12);\n+      assertEquals(0.3, integ.getMinReduction(), 1.0e-12);\n+\n+      // the 0.7 factor is only valid for this test\n+      // and has been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      assertTrue(handler.getMaximalValueError() < (0.7 * scalAbsoluteTolerance));\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      int calls = pb.getCalls();\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testEvents()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    EventHandler[] functions = pb.getEventsHandlers();\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addEventHandler(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+    }\n+    assertEquals(functions.length, integ.getEventHandlers().size());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalValueError() < 5.0e-6);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+    integ.clearEventHandlers();\n+    assertEquals(0, integ.getEventHandlers().size());\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    integ.addStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(pb.getCalls() < 2800);\n+\n+  }\n+\n+  public void testVariableSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    integ.addStepHandler(new VariableHandler());\n+    double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                                      pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+    private static final long serialVersionUID = -1645853847806655456L;\n+\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+\n+      ++nbSteps;\n+      for (int a = 1; a < 10; ++a) {\n+\n+        double prev   = interpolator.getPreviousTime();\n+        double curr   = interpolator.getCurrentTime();\n+        double interp = ((10 - a) * prev + a * curr) / 10;\n+        interpolator.setInterpolatedTime(interp);\n+\n+        double[] interpolatedY = interpolator.getInterpolatedState ();\n+        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n+        double dx = interpolatedY[0] - theoreticalY[0];\n+        double dy = interpolatedY[1] - theoreticalY[1];\n+        double error = dx * dx + dy * dy;\n+        if (error > maxError) {\n+          maxError = error;\n+        }\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 7.0e-10);\n+        assertTrue(nbSteps < 400);\n+      }\n+    }\n+    private int nbSteps;\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n+  private static class VariableHandler implements StepHandler {\n+    private static final long serialVersionUID = -5196650833828379228L;\n+    public VariableHandler() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double step = Math.abs(interpolator.getCurrentTime()\n+                             - interpolator.getPreviousTime());\n+      if (firstTime) {\n+        minStep   = Math.abs(step);\n+        maxStep   = minStep;\n+        firstTime = false;\n+      } else {\n+        if (step < minStep) {\n+          minStep = step;\n+        }\n+        if (step > maxStep) {\n+          maxStep = step;\n+        }\n+      }\n+\n+      if (isLast) {\n+        assertTrue(minStep < (1.0 / 450.0));\n+        assertTrue(maxStep > (1.0 / 4.2));\n+      }\n+    }  \n+    private boolean firstTime;\n+    private double  minStep;\n+    private double  maxStep;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DormandPrince54IntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class DormandPrince54StepInterpolatorTest\n+  extends StepInterpolatorAbstractTest {\n+\n+  public DormandPrince54StepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.1);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                    scalAbsoluteTolerance,\n+                                                                    scalRelativeTolerance);\n+    checkDerivativesConsistency(integ, pb, 1.0e-10);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                    scalAbsoluteTolerance,\n+                                                                    scalRelativeTolerance);\n+    integ.addStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n+\n+    assertTrue(bos.size () > 119500);\n+    assertTrue(bos.size () < 120500);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 7.0e-10);\n+\n+  }\n+\n+  public void testClone()\n+    throws DerivativeException, IntegratorException {\n+      TestProblem3 pb = new TestProblem3(0.9);\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-8;\n+      double scalRelativeTolerance = scalAbsoluteTolerance;\n+      DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                      scalAbsoluteTolerance,\n+                                                                      scalRelativeTolerance);\n+      integ.addStepHandler(new StepHandler() {\n+        private static final long serialVersionUID = -6768136169276197L;\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+          throws DerivativeException {\n+              StepInterpolator cloned = interpolator.copy();\n+              double tA = cloned.getPreviousTime();\n+              double tB = cloned.getCurrentTime();\n+              double halfStep = Math.abs(tB - tA) / 2;\n+              assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+              assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+              for (int i = 0; i < 10; ++i) {\n+                  double t = (i * tB + (9 - i) * tA) / 9;\n+                  interpolator.setInterpolatedTime(t);\n+                  assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                  cloned.setInterpolatedTime(t);\n+                  assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                  double[] referenceState = interpolator.getInterpolatedState();\n+                  double[] cloneState     = cloned.getInterpolatedState();\n+                  for (int j = 0; j < referenceState.length; ++j) {\n+                      assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                  }\n+              }\n+          }\n+          public boolean requiresDenseOutput() {\n+              return true;\n+          }\n+          public void reset() {\n+          }\n+      });\n+      integ.integrate(pb,\n+              pb.getInitialTime(), pb.getInitialState(),\n+              pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DormandPrince54StepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince853IntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;\n+import org.apache.commons.math.ode.sampling.DummyStepHandler;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+import junit.framework.*;\n+\n+public class DormandPrince853IntegratorTest\n+  extends TestCase {\n+\n+  public DormandPrince853IntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,\n+                                                                             1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()+10],\n+                           1.0, new double[pb.getDimension()+10]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testNullIntervalCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      DormandPrince853Integrator integrator = new DormandPrince853Integrator(0.0, 1.0,\n+                                                                             1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()],\n+                           0.0, new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testMinStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    try {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };\n+      double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };\n+\n+      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                  vecAbsoluteTolerance,\n+                                                                  vecRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -2; ++i) {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = Math.pow(10.0, i);\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                  scalAbsoluteTolerance,\n+                                                                  scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      // the 1.3 factor is only valid for this test\n+      // and has been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      int calls = pb.getCalls();\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testBackward()\n+      throws DerivativeException, IntegratorException {\n+\n+      TestProblem5 pb = new TestProblem5();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-8;\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                  scalAbsoluteTolerance,\n+                                                                  scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      assertTrue(handler.getLastError() < 8.0e-8);\n+      assertTrue(handler.getMaximalValueError() < 2.0e-7);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      assertEquals(\"Dormand-Prince 8 (5, 3)\", integ.getName());\n+  }\n+\n+  public void testEvents()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-9;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                scalAbsoluteTolerance,\n+                                                                scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    EventHandler[] functions = pb.getEventsHandlers();\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addEventHandler(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+    }\n+    assertEquals(functions.length, integ.getEventHandlers().size());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalValueError() < 5.0e-8);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+    integ.clearEventHandlers();\n+    assertEquals(0, integ.getEventHandlers().size());\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                scalAbsoluteTolerance,\n+                                                                scalRelativeTolerance);\n+    integ.addStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(pb.getCalls() < 3300);\n+\n+  }\n+\n+  public void testVariableSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                               scalAbsoluteTolerance,\n+                                                               scalRelativeTolerance);\n+    integ.addStepHandler(new VariableHandler());\n+    double stopTime = integ.integrate(pb,\n+                                      pb.getInitialTime(), pb.getInitialState(),\n+                                      pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+    assertEquals(\"Dormand-Prince 8 (5, 3)\", integ.getName());\n+  }\n+\n+  public void testNoDenseOutput()\n+    throws DerivativeException, IntegratorException {\n+    TestProblem1 pb1 = new TestProblem1();\n+    TestProblem1 pb2 = (TestProblem1) pb1.clone();\n+    double minStep = 0.1 * (pb1.getFinalTime() - pb1.getInitialTime());\n+    double maxStep = pb1.getFinalTime() - pb1.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-4;\n+    double scalRelativeTolerance = 1.0e-4;\n+\n+    FirstOrderIntegrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                scalAbsoluteTolerance,\n+                                                                scalRelativeTolerance);\n+    integ.addStepHandler(DummyStepHandler.getInstance());\n+    integ.integrate(pb1,\n+                    pb1.getInitialTime(), pb1.getInitialState(),\n+                    pb1.getFinalTime(), new double[pb1.getDimension()]);\n+    int callsWithoutDenseOutput = pb1.getCalls();\n+\n+    integ.addStepHandler(new InterpolatingStepHandler());\n+    integ.integrate(pb2,\n+                    pb2.getInitialTime(), pb2.getInitialState(),\n+                    pb2.getFinalTime(), new double[pb2.getDimension()]);\n+    int callsWithDenseOutput = pb2.getCalls();\n+\n+    assertTrue(callsWithDenseOutput > callsWithoutDenseOutput);\n+\n+  }\n+\n+  public void testUnstableDerivative()\n+  throws DerivativeException, IntegratorException {\n+    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n+    FirstOrderIntegrator integ =\n+      new DormandPrince853Integrator(0.1, 10, 1.0e-12, 0.0);\n+    integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);\n+    double[] y = { Double.NaN };\n+    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n+    assertEquals(8.0, y[0], 1.0e-12);\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+    private static final long serialVersionUID = -1752092987112788459L;\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+\n+      ++nbSteps;\n+      for (int a = 1; a < 10; ++a) {\n+\n+        double prev   = interpolator.getPreviousTime();\n+        double curr   = interpolator.getCurrentTime();\n+        double interp = ((10 - a) * prev + a * curr) / 10;\n+        interpolator.setInterpolatedTime(interp);\n+\n+        double[] interpolatedY = interpolator.getInterpolatedState ();\n+        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n+        double dx = interpolatedY[0] - theoreticalY[0];\n+        double dy = interpolatedY[1] - theoreticalY[1];\n+        double error = dx * dx + dy * dy;\n+        if (error > maxError) {\n+          maxError = error;\n+        }\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 2.4e-10);\n+        assertTrue(nbSteps < 150);\n+      }\n+    }\n+    private int nbSteps;\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n+  private static class VariableHandler implements StepHandler {\n+    private static final long serialVersionUID = 5542665697103383623L;\n+    public VariableHandler() {\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double step = Math.abs(interpolator.getCurrentTime()\n+                             - interpolator.getPreviousTime());\n+      if (firstTime) {\n+        minStep   = Math.abs(step);\n+        maxStep   = minStep;\n+        firstTime = false;\n+      } else {\n+        if (step < minStep) {\n+          minStep = step;\n+        }\n+        if (step > maxStep) {\n+          maxStep = step;\n+        }\n+      }\n+\n+      if (isLast) {\n+        assertTrue(minStep < (1.0 / 100.0));\n+        assertTrue(maxStep > (1.0 / 2.0));\n+      }\n+    }\n+    private boolean firstTime = true;\n+    private double  minStep = 0;\n+    private double  maxStep = 0;\n+  }\n+\n+  private static class InterpolatingStepHandler implements StepHandler {\n+    private static final long serialVersionUID = -5272695044664350727L;\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+      double prev = interpolator.getPreviousTime();\n+      double curr = interpolator.getCurrentTime();\n+      interpolator.setInterpolatedTime(0.5*(prev + curr));\n+    }\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DormandPrince853IntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class DormandPrince853StepInterpolatorTest\n+  extends StepInterpolatorAbstractTest {\n+\n+  public DormandPrince853StepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.1);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                      scalAbsoluteTolerance,\n+                                                                      scalRelativeTolerance);\n+    checkDerivativesConsistency(integ, pb, 1.0e-10);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                      scalAbsoluteTolerance,\n+                                                                      scalRelativeTolerance);\n+    integ.addStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n+\n+    assertTrue(bos.size () > 86000);\n+    assertTrue(bos.size () < 87000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 2.4e-10);\n+\n+  }\n+\n+  public void testClone()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                      scalAbsoluteTolerance,\n+                                                                      scalRelativeTolerance);\n+    integ.addStepHandler(new StepHandler() {\n+        private static final long serialVersionUID = 2209212559670665268L;\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+        throws DerivativeException {\n+            StepInterpolator cloned = interpolator.copy();\n+            double tA = cloned.getPreviousTime();\n+            double tB = cloned.getCurrentTime();\n+            double halfStep = Math.abs(tB - tA) / 2;\n+            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+            for (int i = 0; i < 10; ++i) {\n+                double t = (i * tB + (9 - i) * tA) / 9;\n+                interpolator.setInterpolatedTime(t);\n+                assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                cloned.setInterpolatedTime(t);\n+                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                double[] referenceState = interpolator.getInterpolatedState();\n+                double[] cloneState     = cloned.getInterpolatedState();\n+                for (int j = 0; j < referenceState.length; ++j) {\n+                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                }\n+            }\n+        }\n+        public boolean requiresDenseOutput() {\n+            return true;\n+        }\n+        public void reset() {\n+        }\n+    });\n+    integ.integrate(pb,\n+            pb.getInitialTime(), pb.getInitialState(),\n+            pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DormandPrince853StepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/EulerIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.EulerIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class EulerIntegratorTest\n+  extends TestCase {\n+\n+  public EulerIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new EulerIntegrator(0.01).integrate(pb,\n+                                          0.0, new double[pb.getDimension()+10],\n+                                          1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb  = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new EulerIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        EventHandler[] functions = pb.getEventsHandlers();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addEventHandler(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n+        }\n+        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                                          pb.getFinalTime(), new double[pb.getDimension()]);\n+        if (functions.length == 0) {\n+            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+        }\n+\n+        double error = handler.getMaximalValueError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new EulerIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+   assertTrue(handler.getLastError() < 2.0e-4);\n+   assertTrue(handler.getMaximalValueError() < 1.0e-3);\n+   assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+   assertEquals(\"Euler\", integ.getName());\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new EulerIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.01);\n+    assertTrue(handler.getMaximalValueError() > 0.2);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+  }\n+\n+  public void testBackward()\n+      throws DerivativeException, IntegratorException {\n+\n+      TestProblem5 pb = new TestProblem5();\n+      double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+      FirstOrderIntegrator integ = new EulerIntegrator(step);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      assertTrue(handler.getLastError() < 0.45);\n+      assertTrue(handler.getMaximalValueError() < 0.45);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      assertEquals(\"Euler\", integ.getName());\n+  }\n+\n+  public void testStepSize()\n+    throws DerivativeException, IntegratorException {\n+      final double step = 1.23456;\n+      FirstOrderIntegrator integ = new EulerIntegrator(step);\n+      integ.addStepHandler(new StepHandler() {\n+        private static final long serialVersionUID = 0L;\n+        public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+            if (! isLast) {\n+                assertEquals(step,\n+                             interpolator.getCurrentTime() - interpolator.getPreviousTime(),\n+                             1.0e-12);\n+            }\n+        }\n+        public boolean requiresDenseOutput() {\n+            return false;\n+        }\n+        public void reset() {\n+        }          \n+      });\n+      integ.integrate(new FirstOrderDifferentialEquations() {\n+                          private static final long serialVersionUID = 0L;\n+                          public void computeDerivatives(double t, double[] y, double[] dot) {\n+                              dot[0] = 1.0;\n+                          }\n+                          public int getDimension() {\n+                              return 1;\n+                          }\n+                      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(EulerIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/EulerStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+public class EulerStepInterpolatorTest\n+  extends StepInterpolatorAbstractTest {\n+\n+  public EulerStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testNoReset() {\n+\n+    double[]   y    =   { 0.0, 1.0, -2.0 };\n+    double[][] yDot = { { 1.0, 2.0, -2.0 } };\n+    EulerStepInterpolator interpolator = new EulerStepInterpolator();\n+    interpolator.reinitialize(new DummyEquations(), y, yDot, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    double[] result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  public void testInterpolationAtBounds()\n+    throws DerivativeException {\n+\n+    double   t0 = 0;\n+    double[] y0 = {0.0, 1.0, -2.0};\n+\n+    double[] y = (double[]) y0.clone();\n+    double[][] yDot = { new double[y0.length] };\n+    EulerStepInterpolator interpolator = new EulerStepInterpolator();\n+    interpolator.reinitialize(new DummyEquations(), y, yDot, true);\n+    interpolator.storeTime(t0);\n+\n+    double dt = 1.0;\n+    y[0] =  1.0;\n+    y[1] =  3.0;\n+    y[2] = -4.0;\n+    yDot[0][0] = (y[0] - y0[0]) / dt;\n+    yDot[0][1] = (y[1] - y0[1]) / dt;\n+    yDot[0][2] = (y[2] - y0[2]) / dt;\n+    interpolator.shift();\n+    interpolator.storeTime(t0 + dt);\n+\n+    interpolator.setInterpolatedTime(interpolator.getPreviousTime());\n+    double[] result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+      assertTrue(Math.abs(result[i] - y0[i]) < 1.0e-10);\n+    }\n+\n+    interpolator.setInterpolatedTime(interpolator.getCurrentTime());\n+    result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  public void testInterpolationInside()\n+  throws DerivativeException {\n+\n+    double[]   y    =   { 1.0, 3.0, -4.0 };\n+    double[][] yDot = { { 1.0, 2.0, -2.0 } };\n+    EulerStepInterpolator interpolator = new EulerStepInterpolator();\n+    interpolator.reinitialize(new DummyEquations(), y, yDot, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    interpolator.setInterpolatedTime(0.1);\n+    double[] result = interpolator.getInterpolatedState();\n+    assertTrue(Math.abs(result[0] - 0.1) < 1.0e-10);\n+    assertTrue(Math.abs(result[1] - 1.2) < 1.0e-10);\n+    assertTrue(Math.abs(result[2] + 2.2) < 1.0e-10);\n+\n+    interpolator.setInterpolatedTime(0.5);\n+    result = interpolator.getInterpolatedState();\n+    assertTrue(Math.abs(result[0] - 0.5) < 1.0e-10);\n+    assertTrue(Math.abs(result[1] - 2.0) < 1.0e-10);\n+    assertTrue(Math.abs(result[2] + 3.0) < 1.0e-10);\n+\n+  }\n+\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    EulerIntegrator integ = new EulerIntegrator(step);\n+    checkDerivativesConsistency(integ, pb, 1.0e-10);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    EulerIntegrator integ = new EulerIntegrator(step);\n+    integ.addStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n+\n+    assertTrue(bos.size () > 82000);\n+    assertTrue(bos.size () < 83000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 0.001);\n+\n+  }\n+\n+  private static class DummyEquations\n+    implements FirstOrderDifferentialEquations {\n+    private static final long serialVersionUID = 291437140744677100L;\n+    public int getDimension() {\n+      return 0;\n+    }\n+    public void computeDerivatives(double t, double[] y, double[] yDot) {\n+    }\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(EulerStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/GillIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.GillIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class GillIntegratorTest\n+  extends TestCase {\n+\n+  public GillIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new GillIntegrator(0.01).integrate(pb,\n+                                         0.0, new double[pb.getDimension()+10],\n+                                         1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 5; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new GillIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        EventHandler[] functions = pb.getEventsHandlers();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addEventHandler(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n+        }\n+        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                                          pb.getFinalTime(), new double[pb.getDimension()]);\n+        if (functions.length == 0) {\n+            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+        }\n+\n+        double error = handler.getMaximalValueError();\n+        if (i > 5) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new GillIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-13);\n+    assertTrue(handler.getMaximalValueError() < 4.0e-12);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(\"Gill\", integ.getName());\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new GillIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.0004);\n+    assertTrue(handler.getMaximalValueError() > 0.005);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+  }\n+\n+  public void testBackward()\n+      throws DerivativeException, IntegratorException {\n+\n+      TestProblem5 pb = new TestProblem5();\n+      double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+      FirstOrderIntegrator integ = new GillIntegrator(step);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      assertTrue(handler.getLastError() < 5.0e-10);\n+      assertTrue(handler.getMaximalValueError() < 7.0e-10);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      assertEquals(\"Gill\", integ.getName());\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+\n+    FirstOrderIntegrator integ = new GillIntegrator(step);\n+    integ.addStepHandler(new KeplerStepHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  public void testUnstableDerivative()\n+  throws DerivativeException, IntegratorException {\n+    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n+    FirstOrderIntegrator integ = new GillIntegrator(0.3);\n+    integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);\n+    double[] y = { Double.NaN };\n+    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n+    assertEquals(8.0, y[0], 1.0e-12);\n+  }\n+\n+  private static class KeplerStepHandler implements StepHandler {\n+    private static final long serialVersionUID = 1250933165809631538L;\n+    public KeplerStepHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double[] interpolatedY = interpolator.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        // even with more than 1000 evaluations per period,\n+        // RK4 is not able to integrate such an eccentric\n+        // orbit with a good accuracy\n+        assertTrue(maxError > 0.001);\n+      }\n+    }\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n+  public void testStepSize()\n+    throws DerivativeException, IntegratorException {\n+      final double step = 1.23456;\n+      FirstOrderIntegrator integ = new GillIntegrator(step);\n+      integ.addStepHandler(new StepHandler() {\n+          private static final long serialVersionUID = 0L;\n+          public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+              if (! isLast) {\n+                  assertEquals(step,\n+                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),\n+                               1.0e-12);\n+              }\n+          }\n+          public boolean requiresDenseOutput() {\n+              return false;\n+          }\n+          public void reset() {\n+          }          \n+      });\n+      integ.integrate(new FirstOrderDifferentialEquations() {\n+          private static final long serialVersionUID = 0L;\n+          public void computeDerivatives(double t, double[] y, double[] dot) {\n+              dot[0] = 1.0;\n+          }\n+          public int getDimension() {\n+              return 1;\n+          }\n+      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GillIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/GillStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.GillIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+public class GillStepInterpolatorTest\n+  extends StepInterpolatorAbstractTest {\n+\n+  public GillStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    GillIntegrator integ = new GillIntegrator(step);\n+    checkDerivativesConsistency(integ, pb, 1.0e-10);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+    GillIntegrator integ = new GillIntegrator(step);\n+    integ.addStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n+\n+    assertTrue(bos.size () > 700000);\n+    assertTrue(bos.size () < 701000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 0.003);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GillStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+import junit.framework.*;\n+\n+public class GraggBulirschStoerIntegratorTest\n+  extends TestCase {\n+\n+  public GraggBulirschStoerIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      AdaptiveStepsizeIntegrator integrator =\n+        new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()+10],\n+                           1.0, new double[pb.getDimension()+10]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testNullIntervalCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      GraggBulirschStoerIntegrator integrator =\n+        new GraggBulirschStoerIntegrator(0.0, 1.0, 1.0e-10, 1.0e-10);\n+      integrator.integrate(pb,\n+                           0.0, new double[pb.getDimension()],\n+                           0.0, new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+\n+  public void testMinStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    try {\n+      TestProblem5 pb  = new TestProblem5();\n+      double minStep   = 0.1 * Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep   = Math.abs(pb.getFinalTime() - pb.getInitialTime());\n+      double[] vecAbsoluteTolerance = { 1.0e-20, 1.0e-21 };\n+      double[] vecRelativeTolerance = { 1.0e-20, 1.0e-21 };\n+\n+      FirstOrderIntegrator integ =\n+        new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                         vecAbsoluteTolerance, vecRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testBackward()\n+      throws DerivativeException, IntegratorException {\n+\n+      TestProblem5 pb = new TestProblem5();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-8;\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                                                    scalAbsoluteTolerance,\n+                                                                    scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      assertTrue(handler.getLastError() < 9.0e-10);\n+      assertTrue(handler.getMaximalValueError() < 9.0e-10);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      assertEquals(\"Gragg-Bulirsch-Stoer\", integ.getName());\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -4; ++i) {\n+      TestProblem1 pb     = new TestProblem1();\n+      double minStep      = 0;\n+      double maxStep      = pb.getFinalTime() - pb.getInitialTime();\n+      double absTolerance = Math.pow(10.0, i);\n+      double relTolerance = absTolerance;\n+\n+      FirstOrderIntegrator integ =\n+        new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                         absTolerance, relTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      // the coefficients are only valid for this test\n+      // and have been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      double ratio =  handler.getMaximalValueError() / absTolerance;\n+      assertTrue(ratio < 2.4);\n+      assertTrue(ratio > 0.02);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      int calls = pb.getCalls();\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testIntegratorControls()\n+  throws DerivativeException, IntegratorException {\n+\n+    TestProblem3 pb = new TestProblem3(0.999);\n+    GraggBulirschStoerIntegrator integ =\n+        new GraggBulirschStoerIntegrator(0, pb.getFinalTime() - pb.getInitialTime(),\n+                1.0e-8, 1.0e-10);\n+\n+    double errorWithDefaultSettings = getMaxError(integ, pb);\n+\n+    // stability control\n+    integ.setStabilityCheck(true, 2, 1, 0.99);\n+    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n+    integ.setStabilityCheck(true, -1, -1, -1);\n+\n+    integ.setStepsizeControl(0.5, 0.99, 0.1, 2.5);\n+    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n+    integ.setStepsizeControl(-1, -1, -1, -1);\n+\n+    integ.setOrderControl(10, 0.7, 0.95);\n+    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n+    integ.setOrderControl(-1, -1, -1);\n+\n+    integ.setInterpolationControl(true, 3);\n+    assertTrue(errorWithDefaultSettings < getMaxError(integ, pb));\n+    integ.setInterpolationControl(true, -1);\n+\n+  }\n+\n+  private double getMaxError(FirstOrderIntegrator integrator, TestProblemAbstract pb)\n+    throws DerivativeException, IntegratorException {\n+      TestProblemHandler handler = new TestProblemHandler(pb, integrator);\n+      integrator.addStepHandler(handler);\n+      integrator.integrate(pb,\n+                           pb.getInitialTime(), pb.getInitialState(),\n+                           pb.getFinalTime(), new double[pb.getDimension()]);\n+      return handler.getMaximalValueError();\n+  }\n+\n+  public void testEvents()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-10;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                                                  scalAbsoluteTolerance,\n+                                                                  scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    EventHandler[] functions = pb.getEventsHandlers();\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addEventHandler(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+    }\n+    assertEquals(functions.length, integ.getEventHandlers().size());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalValueError() < 5.0e-8);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+    integ.clearEventHandlers();\n+    assertEquals(0, integ.getEventHandlers().size());\n+\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep        = 0;\n+    double maxStep        = pb.getFinalTime() - pb.getInitialTime();\n+    double absTolerance   = 1.0e-6;\n+    double relTolerance   = 1.0e-6;\n+\n+    FirstOrderIntegrator integ =\n+      new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                       absTolerance, relTolerance);\n+    integ.addStepHandler(new KeplerStepHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(pb.getCalls() < 2150);\n+\n+  }\n+\n+  public void testVariableSteps()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep        = 0;\n+    double maxStep        = pb.getFinalTime() - pb.getInitialTime();\n+    double absTolerance   = 1.0e-8;\n+    double relTolerance   = 1.0e-8;\n+    FirstOrderIntegrator integ =\n+      new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                       absTolerance, relTolerance);\n+    integ.addStepHandler(new VariableStepHandler());\n+    double stopTime = integ.integrate(pb,\n+                                      pb.getInitialTime(), pb.getInitialState(),\n+                                      pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+    assertEquals(\"Gragg-Bulirsch-Stoer\", integ.getName());\n+  }\n+\n+  public void testUnstableDerivative()\n+    throws DerivativeException, IntegratorException {\n+    final StepProblem stepProblem = new StepProblem(0.0, 1.0, 2.0);\n+    FirstOrderIntegrator integ =\n+      new GraggBulirschStoerIntegrator(0.1, 10, 1.0e-12, 0.0);\n+    integ.addEventHandler(stepProblem, 1.0, 1.0e-12, 1000);\n+    double[] y = { Double.NaN };\n+    integ.integrate(stepProblem, 0.0, new double[] { 0.0 }, 10.0, y);\n+    assertEquals(8.0, y[0], 1.0e-12);\n+  }\n+\n+  private static class KeplerStepHandler implements StepHandler {\n+    private static final long serialVersionUID = -8231434585284002546L;\n+    public KeplerStepHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return true;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast)\n+    throws DerivativeException {\n+\n+      ++nbSteps;\n+      for (int a = 1; a < 100; ++a) {\n+\n+        double prev   = interpolator.getPreviousTime();\n+        double curr   = interpolator.getCurrentTime();\n+        double interp = ((100 - a) * prev + a * curr) / 100;\n+        interpolator.setInterpolatedTime(interp);\n+\n+        double[] interpolatedY = interpolator.getInterpolatedState ();\n+        double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getInterpolatedTime());\n+        double dx = interpolatedY[0] - theoreticalY[0];\n+        double dy = interpolatedY[1] - theoreticalY[1];\n+        double error = dx * dx + dy * dy;\n+        if (error > maxError) {\n+          maxError = error;\n+        }\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 2.7e-6);\n+        assertTrue(nbSteps < 80);\n+      }\n+    }\n+    private int nbSteps;\n+    private double maxError;\n+    private TestProblem3 pb;\n+  }\n+\n+  public static class VariableStepHandler implements StepHandler {\n+    private static final long serialVersionUID = -5955452449048688985L;\n+    public VariableStepHandler() {\n+      reset();\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      firstTime = true;\n+      minStep = 0;\n+      maxStep = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double step = Math.abs(interpolator.getCurrentTime()\n+                             - interpolator.getPreviousTime());\n+      if (firstTime) {\n+        minStep   = Math.abs(step);\n+        maxStep   = minStep;\n+        firstTime = false;\n+      } else {\n+        if (step < minStep) {\n+          minStep = step;\n+        }\n+        if (step > maxStep) {\n+          maxStep = step;\n+        }\n+      }\n+\n+      if (isLast) {\n+        assertTrue(minStep < 8.2e-3);\n+        assertTrue(maxStep > 1.7);\n+      }\n+    }\n+    private boolean firstTime;\n+    private double  minStep;\n+    private double  maxStep;\n+  }\n+  public static Test suite() {\n+    return new TestSuite(GraggBulirschStoerIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.GraggBulirschStoerIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class GraggBulirschStoerStepInterpolatorTest\n+  extends StepInterpolatorAbstractTest {\n+\n+  public GraggBulirschStoerStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep   = 0;\n+    double maxStep   = pb.getFinalTime() - pb.getInitialTime();\n+    double absTolerance = 1.0e-8;\n+    double relTolerance = 1.0e-8;\n+\n+    GraggBulirschStoerIntegrator integ =\n+      new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                       absTolerance, relTolerance);\n+    checkDerivativesConsistency(integ, pb, 1.0e-8);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep   = 0;\n+    double maxStep   = pb.getFinalTime() - pb.getInitialTime();\n+    double absTolerance = 1.0e-8;\n+    double relTolerance = 1.0e-8;\n+\n+    GraggBulirschStoerIntegrator integ =\n+      new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                       absTolerance, relTolerance);\n+    integ.addStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n+\n+    assertTrue(bos.size () > 34000);\n+    assertTrue(bos.size () < 35000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 5.0e-11);\n+\n+  }\n+\n+  public void testClone()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    GraggBulirschStoerIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                                                          scalAbsoluteTolerance,\n+                                                                          scalRelativeTolerance);\n+    integ.addStepHandler(new StepHandler() {\n+        private static final long serialVersionUID = -5947183291381232297L;\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+        throws DerivativeException {\n+            StepInterpolator cloned = interpolator.copy();\n+            double tA = cloned.getPreviousTime();\n+            double tB = cloned.getCurrentTime();\n+            double halfStep = Math.abs(tB - tA) / 2;\n+            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+            for (int i = 0; i < 10; ++i) {\n+                double t = (i * tB + (9 - i) * tA) / 9;\n+                interpolator.setInterpolatedTime(t);\n+                assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                cloned.setInterpolatedTime(t);\n+                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                double[] referenceState = interpolator.getInterpolatedState();\n+                double[] cloneState     = cloned.getInterpolatedState();\n+                for (int j = 0; j < referenceState.length; ++j) {\n+                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                }\n+            }\n+        }\n+        public boolean requiresDenseOutput() {\n+            return true;\n+        }\n+        public void reset() {\n+        }\n+    });\n+    integ.integrate(pb,\n+            pb.getInitialTime(), pb.getInitialState(),\n+            pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(GraggBulirschStoerStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/HighamHall54IntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.HighamHall54Integrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class HighamHall54IntegratorTest\n+  extends TestCase {\n+\n+  public HighamHall54IntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testWrongDerivative() {\n+    try {\n+      HighamHall54Integrator integrator =\n+          new HighamHall54Integrator(0.0, 1.0, 1.0e-10, 1.0e-10);\n+      FirstOrderDifferentialEquations equations =\n+          new FirstOrderDifferentialEquations() {\n+            private static final long serialVersionUID = -1157081786301178032L;\n+            public void computeDerivatives(double t, double[] y, double[] dot)\n+            throws DerivativeException {\n+            if (t < -0.5) {\n+                throw new DerivativeException(\"{0}\", new String[] { \"oops\" });\n+            } else {\n+                throw new DerivativeException(new RuntimeException(\"oops\"));\n+           }\n+          }\n+          public int getDimension() {\n+              return 1;\n+          }\n+      };\n+\n+      try  {\n+        integrator.integrate(equations, -1.0, new double[1], 0.0, new double[1]);\n+        fail(\"an exception should have been thrown\");\n+      } catch(DerivativeException de) {\n+        // expected behavior\n+      }\n+\n+      try  {\n+        integrator.integrate(equations, 0.0, new double[1], 1.0, new double[1]);\n+        fail(\"an exception should have been thrown\");\n+      } catch(DerivativeException de) {\n+        // expected behavior\n+      }\n+\n+    } catch (Exception e) {\n+      fail(\"wrong exception caught: \" + e.getMessage());        \n+    }\n+  }\n+\n+  public void testMinStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    try {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0.1 * (pb.getFinalTime() - pb.getInitialTime());\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double[] vecAbsoluteTolerance = { 1.0e-15, 1.0e-16 };\n+      double[] vecRelativeTolerance = { 1.0e-15, 1.0e-16 };\n+\n+      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              vecAbsoluteTolerance,\n+                                                              vecRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+\n+  }\n+\n+  public void testIncreasingTolerance()\n+    throws DerivativeException, IntegratorException {\n+\n+    int previousCalls = Integer.MAX_VALUE;\n+    for (int i = -12; i < -2; ++i) {\n+      TestProblem1 pb = new TestProblem1();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = Math.pow(10.0, i);\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      // the 1.3 factor is only valid for this test\n+      // and has been obtained from trial and error\n+      // there is no general relation between local and global errors\n+      assertTrue(handler.getMaximalValueError() < (1.3 * scalAbsoluteTolerance));\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      int calls = pb.getCalls();\n+      assertTrue(calls <= previousCalls);\n+      previousCalls = calls;\n+\n+    }\n+\n+  }\n+\n+  public void testBackward()\n+      throws DerivativeException, IntegratorException {\n+\n+      TestProblem5 pb = new TestProblem5();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-8;\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      assertTrue(handler.getLastError() < 5.0e-7);\n+      assertTrue(handler.getMaximalValueError() < 5.0e-7);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      assertEquals(\"Higham-Hall 5(4)\", integ.getName());\n+  }\n+\n+  public void testEvents()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem4 pb = new TestProblem4();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                            scalAbsoluteTolerance,\n+                                                            scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    EventHandler[] functions = pb.getEventsHandlers();\n+    for (int l = 0; l < functions.length; ++l) {\n+      integ.addEventHandler(functions[l],\n+                                 Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+    }\n+    assertEquals(functions.length, integ.getEventHandlers().size());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getMaximalValueError() < 1.0e-7);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(12.0, handler.getLastTime(), 1.0e-8 * maxStep);\n+    integ.clearEventHandlers();\n+    assertEquals(0, integ.getEventHandlers().size());\n+\n+  }\n+\n+  public void testEventsErrors()\n+    throws DerivativeException, IntegratorException {\n+\n+      final TestProblem1 pb = new TestProblem1();\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-8;\n+      double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+      FirstOrderIntegrator integ =\n+          new HighamHall54Integrator(minStep, maxStep,\n+                                     scalAbsoluteTolerance, scalRelativeTolerance);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+\n+      integ.addEventHandler(new EventHandler() {\n+        public int eventOccurred(double t, double[] y) {\n+          return EventHandler.CONTINUE;\n+        }\n+        public double g(double t, double[] y) throws EventException {\n+          double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;\n+          double offset = t - middle;\n+          if (offset > 0) {\n+            throw new EventException(\"Evaluation failed for argument = {0}\",\n+                                      new Object[] { Double.valueOf(t) });\n+          }\n+          return offset;\n+        }\n+        public void resetState(double t, double[] y) {\n+        }\n+        private static final long serialVersionUID = 935652725339916361L;\n+      }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 1000);\n+\n+      try {\n+        integ.integrate(pb,\n+                        pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      } catch (Exception e) {\n+        fail(\"wrong exception type caught\");\n+      }\n+\n+  }\n+\n+  public void testEventsNoConvergence()\n+  throws DerivativeException, IntegratorException {\n+\n+    final TestProblem1 pb = new TestProblem1();\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = 0.01 * scalAbsoluteTolerance;\n+\n+    FirstOrderIntegrator integ =\n+        new HighamHall54Integrator(minStep, maxStep,\n+                                   scalAbsoluteTolerance, scalRelativeTolerance);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+\n+    integ.addEventHandler(new EventHandler() {\n+      public int eventOccurred(double t, double[] y) {\n+        return EventHandler.CONTINUE;\n+      }\n+      public double g(double t, double[] y) {\n+        double middle = (pb.getInitialTime() + pb.getFinalTime()) / 2;\n+        double offset = t - middle;\n+        return (offset > 0) ? (offset + 0.5) : (offset - 0.5);\n+      }\n+      public void resetState(double t, double[] y) {\n+      }\n+      private static final long serialVersionUID = 935652725339916361L;\n+    }, Double.POSITIVE_INFINITY, 1.0e-8 * maxStep, 3);\n+\n+    try {\n+      integ.integrate(pb,\n+                      pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+      fail(\"an exception should have been thrown\");\n+    } catch (IntegratorException ie) {\n+       assertTrue(ie.getCause() != null);\n+       assertTrue(ie.getCause() instanceof ConvergenceException);\n+    } catch (Exception e) {\n+      fail(\"wrong exception type caught\");\n+    }\n+\n+}\n+\n+  public void testSanityChecks() {\n+    try {\n+      final TestProblem3 pb  = new TestProblem3(0.9);\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+\n+      try {\n+        FirstOrderIntegrator integ =\n+            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);\n+        integ.integrate(pb, pb.getInitialTime(), new double[6],\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      }\n+\n+      try {\n+        FirstOrderIntegrator integ =\n+            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[6]);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      }\n+\n+      try {\n+        FirstOrderIntegrator integ =\n+            new HighamHall54Integrator(minStep, maxStep, new double[2], new double[4]);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      }\n+\n+      try {\n+        FirstOrderIntegrator integ =\n+            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[2]);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getFinalTime(), new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      }\n+\n+      try {\n+        FirstOrderIntegrator integ =\n+            new HighamHall54Integrator(minStep, maxStep, new double[4], new double[4]);\n+        integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                        pb.getInitialTime(), new double[pb.getDimension()]);\n+        fail(\"an exception should have been thrown\");\n+      } catch (IntegratorException ie) {\n+        // expected behavior\n+      }\n+\n+    } catch (Exception e) {\n+      fail(\"wrong exception caught: \" + e.getMessage());\n+    }\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double[] vecAbsoluteTolerance = { 1.0e-8, 1.0e-8, 1.0e-10, 1.0e-10 };\n+    double[] vecRelativeTolerance = { 1.0e-10, 1.0e-10, 1.0e-8, 1.0e-8 };\n+\n+    FirstOrderIntegrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                            vecAbsoluteTolerance,\n+                                                            vecRelativeTolerance);\n+    integ.addStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertEquals(\"Higham-Hall 5(4)\", integ.getName());\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+    private static final long serialVersionUID = 3200246026175251943L;\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+    public void reset() {\n+      nbSteps = 0;\n+      maxError = 0;\n+    }\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      ++nbSteps;\n+      double[] interpolatedY = interpolator.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        assertTrue(maxError < 4e-11);\n+        assertTrue(nbSteps < 670);\n+      }\n+    }\n+    private TestProblem3 pb;\n+    private int nbSteps;\n+    private double maxError;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(HighamHall54IntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+import java.util.Random;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.HighamHall54Integrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class HighamHall54StepInterpolatorTest\n+  extends StepInterpolatorAbstractTest {\n+\n+  public HighamHall54StepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.1);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+    checkDerivativesConsistency(integ, pb, 1.0e-10);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+    integ.addStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n+\n+    assertTrue(bos.size () > 158000);\n+    assertTrue(bos.size () < 159000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 1.6e-10);\n+\n+  }\n+\n+  public void testClone()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+    integ.addStepHandler(new StepHandler() {\n+        private static final long serialVersionUID = 9111679755950880352L;\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+        throws DerivativeException {\n+            StepInterpolator cloned = interpolator.copy();\n+            double tA = cloned.getPreviousTime();\n+            double tB = cloned.getCurrentTime();\n+            double halfStep = Math.abs(tB - tA) / 2;\n+            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+            for (int i = 0; i < 10; ++i) {\n+                double t = (i * tB + (9 - i) * tA) / 9;\n+                interpolator.setInterpolatedTime(t);\n+                assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                cloned.setInterpolatedTime(t);\n+                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                double[] referenceState = interpolator.getInterpolatedState();\n+                double[] cloneState     = cloned.getInterpolatedState();\n+                for (int j = 0; j < referenceState.length; ++j) {\n+                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                }\n+            }\n+        }\n+        public boolean requiresDenseOutput() {\n+            return true;\n+        }\n+        public void reset() {\n+        }\n+    });\n+    integ.integrate(pb,\n+            pb.getInitialTime(), pb.getInitialState(),\n+            pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(HighamHall54StepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/MidpointIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.MidpointIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class MidpointIntegratorTest\n+  extends TestCase {\n+\n+  public MidpointIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new MidpointIntegrator(0.01).integrate(pb,\n+                                             0.0, new double[pb.getDimension()+10],\n+                                             1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+\n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+        FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        EventHandler[] functions = pb.getEventsHandlers();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addEventHandler(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n+        }\n+        double stopTime = integ.integrate(pb,\n+                                          pb.getInitialTime(), pb.getInitialState(),\n+                                          pb.getFinalTime(), new double[pb.getDimension()]);\n+        if (functions.length == 0) {\n+            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+        }\n+\n+        double error = handler.getMaximalValueError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      }\n+\n+    }\n+\n+  }\n+\n+  public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-7);\n+    assertTrue(handler.getMaximalValueError() < 1.0e-6);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(\"midpoint\", integ.getName());\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb  = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.01);\n+    assertTrue(handler.getMaximalValueError() > 0.05);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+  }\n+\n+  public void testBackward()\n+      throws DerivativeException, IntegratorException {\n+\n+      TestProblem5 pb = new TestProblem5();\n+      double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+      FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      assertTrue(handler.getLastError() < 6.0e-4);\n+      assertTrue(handler.getMaximalValueError() < 6.0e-4);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      assertEquals(\"midpoint\", integ.getName());\n+  }\n+\n+  public void testStepSize()\n+    throws DerivativeException, IntegratorException {\n+      final double step = 1.23456;\n+      FirstOrderIntegrator integ = new MidpointIntegrator(step);\n+      integ.addStepHandler(new StepHandler() {\n+          private static final long serialVersionUID = 0L;\n+          public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+              if (! isLast) {\n+                  assertEquals(step,\n+                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),\n+                               1.0e-12);\n+              }\n+          }\n+          public boolean requiresDenseOutput() {\n+              return false;\n+          }\n+          public void reset() {\n+          }          \n+      });\n+      integ.integrate(new FirstOrderDifferentialEquations() {\n+          private static final long serialVersionUID = 0L;\n+          public void computeDerivatives(double t, double[] y, double[] dot) {\n+              dot[0] = 1.0;\n+          }\n+          public int getDimension() {\n+              return 1;\n+          }\n+      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(MidpointIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+public class MidpointStepInterpolatorTest\n+  extends StepInterpolatorAbstractTest {\n+\n+  public MidpointStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    MidpointIntegrator integ = new MidpointIntegrator(step);\n+    checkDerivativesConsistency(integ, pb, 1.0e-10);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    MidpointIntegrator integ = new MidpointIntegrator(step);\n+    integ.addStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n+\n+    assertTrue(bos.size () > 98000);\n+    assertTrue(bos.size () < 99000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError < 1.0e-6);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(MidpointStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/StepInterpolatorAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+import junit.framework.TestCase;\n+\n+public class StepInterpolatorAbstractTest extends TestCase {\n+\n+    protected StepInterpolatorAbstractTest(String name) {\n+        super(name);\n+    }\n+\n+    protected void checkDerivativesConsistency(final FirstOrderIntegrator integrator,\n+                                               final TestProblemAbstract problem,\n+                                               final double threshold)\n+        throws DerivativeException, IntegratorException {\n+        integrator.addStepHandler(new StepHandler() {\n+\n+            private static final long serialVersionUID = 2462564234755682953L;\n+\n+            public boolean requiresDenseOutput() {\n+                return true;\n+            }\n+\n+            public void handleStep(StepInterpolator interpolator, boolean isLast)\n+                throws DerivativeException {\n+\n+                final double h = 0.001 * (interpolator.getCurrentTime() - interpolator.getPreviousTime());\n+                final double t = interpolator.getCurrentTime() - 300 * h;\n+\n+                if (Math.abs(h) < 10 * Math.ulp(t)) {\n+                    return;\n+                }\n+\n+                interpolator.setInterpolatedTime(t - 4 * h);\n+                final double[] yM4h = interpolator.getInterpolatedState().clone();\n+                interpolator.setInterpolatedTime(t - 3 * h);\n+                final double[] yM3h = interpolator.getInterpolatedState().clone();\n+                interpolator.setInterpolatedTime(t - 2 * h);\n+                final double[] yM2h = interpolator.getInterpolatedState().clone();\n+                interpolator.setInterpolatedTime(t - h);\n+                final double[] yM1h = interpolator.getInterpolatedState().clone();\n+                interpolator.setInterpolatedTime(t + h);\n+                final double[] yP1h = interpolator.getInterpolatedState().clone();\n+                interpolator.setInterpolatedTime(t + 2 * h);\n+                final double[] yP2h = interpolator.getInterpolatedState().clone();\n+                interpolator.setInterpolatedTime(t + 3 * h);\n+                final double[] yP3h = interpolator.getInterpolatedState().clone();\n+                interpolator.setInterpolatedTime(t + 4 * h);\n+                final double[] yP4h = interpolator.getInterpolatedState().clone();\n+\n+                interpolator.setInterpolatedTime(t);\n+                final double[] yDot = interpolator.getInterpolatedDerivatives();\n+\n+                for (int i = 0; i < yDot.length; ++i) {\n+                    final double approYDot = ( -3 * (yP4h[i] - yM4h[i]) +\n+                                               32 * (yP3h[i] - yM3h[i]) +\n+                                             -168 * (yP2h[i] - yM2h[i]) +\n+                                              672 * (yP1h[i] - yM1h[i])) / (840 * h);\n+                    if (Math.abs(approYDot - yDot[i]) >= threshold) {\n+                        System.out.println(\"gotcha!\");\n+                    }\n+                    assertEquals(approYDot, yDot[i], threshold);\n+                }\n+\n+            }\n+\n+            public void reset() {\n+            }\n+\n+        });\n+\n+        integrator.integrate(problem,\n+                             problem.getInitialTime(), problem.getInitialState(),\n+                             problem.getFinalTime(), new double[problem.getDimension()]);\n+\n+    }\n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/StepProblem.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.events.EventHandler;\n+\n+\n+public class StepProblem\n+  implements FirstOrderDifferentialEquations, EventHandler {\n+\n+  public StepProblem(double rateBefore, double rateAfter,\n+                     double switchTime) {\n+    this.rateAfter  = rateAfter;\n+    this.switchTime = switchTime;\n+    setRate(rateBefore);\n+  }\n+\n+  public void computeDerivatives(double t, double[] y, double[] yDot) {\n+    yDot[0] = rate;\n+  }\n+\n+  public int getDimension() {\n+    return 1;\n+  }\n+\n+  public void setRate(double rate) {\n+    this.rate = rate;\n+  }\n+\n+  public int eventOccurred(double t, double[] y) {\n+    setRate(rateAfter);\n+    return RESET_DERIVATIVES;\n+  }\n+\n+  public double g(double t, double[] y) {\n+    return t - switchTime;\n+  }\n+\n+  public void resetState(double t, double[] y) {\n+  }\n+\n+  private double rate;\n+  private double rateAfter;\n+  private double switchTime;\n+\n+  private static final long serialVersionUID = 7590601995477504318L;\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblem1.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    y' = -y\n+ * </pre>\n+ * the solution of this equation is a simple exponential function :\n+ * <pre>\n+ *   y (t) = y (t0) exp (t0-t)\n+ * </pre>\n+ * </p>\n+\n+ */\n+public class TestProblem1\n+  extends TestProblemAbstract {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 1977870815289373164L;\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem1() {\n+    super();\n+    double[] y0 = { 1.0, 0.1 };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(4.0);\n+    double[] errorScale = { 1.0, 1.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem1(TestProblem1 problem) {\n+    super(problem);\n+    y = (double[]) problem.y.clone();\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new TestProblem1(this);\n+  }\n+\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+\n+    // compute the derivatives\n+    for (int i = 0; i < n; ++i)\n+      yDot[i] = -y[i];\n+\n+  }\n+\n+  public double[] computeTheoreticalState(double t) {\n+    double c = Math.exp (t0 - t);\n+    for (int i = 0; i < n; ++i) {\n+      y[i] = c * y0[i];\n+    }\n+    return y;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblem2.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    y' = t^3 - t y\n+ * </pre>\n+ * with the initial condition y (0) = 0. The solution of this equation\n+ * is the following function :\n+ * <pre>\n+ *   y (t) = t^2 + 2 (ext (- t^2 / 2) - 1)\n+ * </pre>\n+ * </p>\n+\n+ */\n+public class TestProblem2\n+  extends TestProblemAbstract {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 8330741783213512366L;\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem2() {\n+    super();\n+    double[] y0 = { 0.0 };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(1.0);\n+    double[] errorScale = { 1.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem2(TestProblem2 problem) {\n+    super(problem);\n+    y = (double[]) problem.y.clone();\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new TestProblem2(this);\n+  }\n+\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+\n+    // compute the derivatives\n+    for (int i = 0; i < n; ++i)\n+      yDot[i] = t * (t * t - y[i]);\n+\n+  }\n+\n+  public double[] computeTheoreticalState(double t) {\n+    double t2 = t * t;\n+    double c = t2 + 2 * (Math.exp (-0.5 * t2) - 1);\n+    for (int i = 0; i < n; ++i) {\n+      y[i] = c;\n+    }\n+    return y;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblem3.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    y1'' = -y1/r^3  y1 (0) = 1-e  y1' (0) = 0\n+ *    y2'' = -y2/r^3  y2 (0) = 0    y2' (0) =sqrt((1+e)/(1-e))\n+ *    r = sqrt (y1^2 + y2^2), e = 0.9\n+ * </pre>\n+ * This is a two-body problem in the plane which can be solved by\n+ * Kepler's equation\n+ * <pre>\n+ *   y1 (t) = ...\n+ * </pre>\n+ * </p>\n+\n+ */\n+public class TestProblem3\n+  extends TestProblemAbstract {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 8567328542728919999L;\n+\n+  /** Eccentricity */\n+  double e;\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /**\n+   * Simple constructor.\n+   * @param e eccentricity\n+   */\n+  public TestProblem3(double e) {\n+    super();\n+    this.e = e;\n+    double[] y0 = { 1 - e, 0, 0, Math.sqrt((1+e)/(1-e)) };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(20.0);\n+    double[] errorScale = { 1.0, 1.0, 1.0, 1.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem3() {\n+    this(0.1);\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem3(TestProblem3 problem) {\n+    super(problem);\n+    e = problem.e;\n+    y = (double[]) problem.y.clone();\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new TestProblem3(this);\n+  }\n+\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+\n+    // current radius\n+    double r2 = y[0] * y[0] + y[1] * y[1];\n+    double invR3 = 1 / (r2 * Math.sqrt(r2));\n+\n+    // compute the derivatives\n+    yDot[0] = y[2];\n+    yDot[1] = y[3];\n+    yDot[2] = -invR3  * y[0];\n+    yDot[3] = -invR3  * y[1];\n+\n+  }\n+\n+  public double[] computeTheoreticalState(double t) {\n+\n+    // solve Kepler's equation\n+    double E = t;\n+    double d = 0;\n+    double corr = 0;\n+    do {\n+      double f2  = e * Math.sin(E);\n+      double f0  = d - f2;\n+      double f1  = 1 - e * Math.cos(E);\n+      double f12 = f1 + f1;\n+      corr  = f0 * f12 / (f1 * f12 - f0 * f2);\n+      d -= corr;\n+      E = t + d;\n+    } while (Math.abs(corr) > 1.0e-12);\n+\n+    double cosE = Math.cos(E);\n+    double sinE = Math.sin(E);\n+\n+    y[0] = cosE - e;\n+    y[1] = Math.sqrt(1 - e * e) * sinE;\n+    y[2] = -sinE / (1 - e * cosE);\n+    y[3] = Math.sqrt(1 - e * e) * cosE / (1 - e * cosE);\n+\n+    return y;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblem4.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.events.EventHandler;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+\n+ * <p>This specific problem is the following differential equation :\n+ * <pre>\n+ *    x'' = -x\n+ * </pre>\n+ * And when x decreases down to 0, the state should be changed as follows :\n+ * <pre>\n+ *   x' -> -x'\n+ * </pre>\n+ * The theoretical solution of this problem is x = |sin(t+a)|\n+ * </p>\n+\n+ */\n+public class TestProblem4\n+  extends TestProblemAbstract {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -5910438521889015745L;\n+\n+  /** Time offset. */\n+  private double a;\n+\n+  /** theoretical state */\n+  private double[] y;\n+\n+  /** Simple constructor. */\n+  public TestProblem4() {\n+    super();\n+    a = 1.2;\n+    double[] y0 = { Math.sin(a), Math.cos(a) };\n+    setInitialConditions(0.0, y0);\n+    setFinalConditions(15);\n+    double[] errorScale = { 1.0, 0.0 };\n+    setErrorScale(errorScale);\n+    y = new double[y0.length];\n+  }\n+ \n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  public TestProblem4(TestProblem4 problem) {\n+    super(problem);\n+    a = problem.a;\n+    y = (double[]) problem.y.clone();\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public Object clone() {\n+    return new TestProblem4(this);\n+  }\n+\n+  public EventHandler[] getEventsHandlers() {\n+    return new EventHandler[] { new Bounce(), new Stop() };\n+  }\n+\n+  public void doComputeDerivatives(double t, double[] y, double[] yDot) {\n+    yDot[0] =  y[1];\n+    yDot[1] = -y[0];\n+  }\n+\n+  public double[] computeTheoreticalState(double t) {\n+    double sin = Math.sin(t + a);\n+    double cos = Math.cos(t + a);\n+    y[0] = Math.abs(sin);\n+    y[1] = (sin >= 0) ? cos : -cos;\n+    return y;\n+  }\n+\n+  private static class Bounce implements EventHandler {\n+\n+    private static final long serialVersionUID = 1356097180027801200L;\n+    private int sign;\n+\n+    public Bounce() {\n+      sign = +1;\n+    }\n+\n+    public double g(double t, double[] y) {\n+      return sign * y[0];\n+    }\n+\n+    public int eventOccurred(double t, double[] y) {\n+      // this sign change is needed because the state will be reset soon\n+      sign = -sign;\n+      return EventHandler.RESET_STATE;\n+    }\n+  \n+    public void resetState(double t, double[] y) {\n+      y[0] = -y[0];\n+      y[1] = -y[1];\n+    }\n+\n+  }\n+\n+  private static class Stop implements EventHandler {\n+\n+    private static final long serialVersionUID = 6975050568227951931L;\n+\n+    public Stop() {\n+    }\n+\n+    public double g(double t, double[] y) {\n+      return t - 12.0;\n+    }\n+\n+    public int eventOccurred(double t, double[] y) {\n+      return EventHandler.STOP;\n+    }\n+  \n+    public void resetState(double t, double[] y) {\n+    }\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblem5.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+ * <p>This is the same as problem 1 except integration is done\n+ * backward in time</p>\n+ */\n+public class TestProblem5\n+  extends TestProblem1 {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 7579233102411804237L;\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  public TestProblem5() {\n+    super();\n+    setFinalConditions(2 * t0 - t1);\n+  }\n+ \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblemAbstract.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.events.EventHandler;\n+\n+/**\n+ * This class is used as the base class of the problems that are\n+ * integrated during the junit tests for the ODE integrators.\n+ */\n+public abstract class TestProblemAbstract\n+  implements FirstOrderDifferentialEquations, Cloneable {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = -8521928974502839379L;\n+\n+  /** Dimension of the problem. */\n+  protected int n;\n+\n+  /** Number of functions calls. */\n+  protected int calls;\n+\n+  /** Initial time */\n+  protected double t0;\n+\n+  /** Initial state */\n+  protected double[] y0;\n+\n+  /** Final time */\n+  protected double t1;\n+\n+  /** Error scale */\n+  protected double[] errorScale;\n+\n+  /**\n+   * Simple constructor.\n+   */\n+  protected TestProblemAbstract() {\n+    n          = 0;\n+    calls      = 0;\n+    t0         = 0;\n+    y0         = null;\n+    t1         = 0;\n+    errorScale = null;\n+  }\n+\n+  /**\n+   * Copy constructor.\n+   * @param problem problem to copy\n+   */\n+  protected TestProblemAbstract(TestProblemAbstract problem) {\n+    n     = problem.n;\n+    calls = problem.calls;\n+    t0    = problem.t0;\n+    if (problem.y0 == null) {\n+      y0 = null;\n+    } else {\n+      y0 = (double[]) problem.y0.clone();\n+    }\n+    if (problem.errorScale == null) {\n+      errorScale = null;\n+    } else {\n+      errorScale = (double[]) problem.errorScale.clone();\n+    }\n+    t1 = problem.t1;\n+  }\n+\n+  /**\n+   * Clone operation.\n+   * @return a copy of the instance\n+   */\n+  public abstract Object clone();\n+\n+  /**\n+   * Set the initial conditions\n+   * @param t0 initial time\n+   * @param y0 initial state vector\n+   */\n+  protected void setInitialConditions(double t0, double[] y0) {\n+    calls     = 0;\n+    n         = y0.length;\n+    this.t0   = t0;\n+    this.y0   = (double[]) y0.clone(); \n+   }\n+\n+  /**\n+   * Set the final conditions.\n+   * @param t1 final time\n+   */\n+  protected void setFinalConditions(double t1) {\n+    this.t1 = t1;\n+  }\n+\n+  /**\n+   * Set the error scale\n+   * @param errorScale error scale\n+   */\n+  protected void setErrorScale(double[] errorScale) {\n+    this.errorScale = (double[]) errorScale.clone(); \n+  }\n+\n+  public int getDimension() {\n+    return n;\n+  }\n+\n+  /**\n+   * Get the initial time.\n+   * @return initial time\n+   */\n+  public double getInitialTime() {\n+    return t0;\n+  }\n+\n+  /**\n+   * Get the initial state vector.\n+   * @return initial state vector\n+   */\n+  public double[] getInitialState() {\n+    return y0;\n+  }\n+\n+  /**\n+   * Get the final time.\n+   * @return final time\n+   */\n+  public double getFinalTime() {\n+    return t1;\n+  }\n+\n+  /**\n+   * Get the error scale.\n+   * @return error scale\n+   */\n+  public double[] getErrorScale() {\n+    return errorScale;\n+  }\n+\n+  /**\n+   * Get the events handlers.\n+   * @return events handlers   */\n+  public EventHandler[] getEventsHandlers() {\n+    return new EventHandler[0];\n+  }\n+\n+  /**\n+   * Get the number of calls.\n+   * @return nuber of calls\n+   */\n+  public int getCalls() {\n+    return calls;\n+  }\n+\n+  public void computeDerivatives(double t, double[] y, double[] yDot) {\n+    ++calls;\n+    doComputeDerivatives(t, y, yDot);\n+  }\n+\n+  abstract public void doComputeDerivatives(double t, double[] y, double[] yDot);\n+\n+  /**\n+   * Compute the theoretical state at the specified time.\n+   * @param t time at which the state is required\n+   * @return state vector at time t\n+   */\n+  abstract public double[] computeTheoreticalState(double t);\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblemFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+/**\n+ * This class is used in the junit tests for the ODE integrators.\n+ */\n+class TestProblemFactory {\n+\n+  /** Problems pool. */\n+  private static TestProblemAbstract[] pool = {\n+    new TestProblem1(),\n+    new TestProblem2(),\n+    new TestProblem3(),\n+    new TestProblem4(),\n+    new TestProblem5()\n+  };\n+\n+  /**\n+   * Private constructor.\n+   * This is a utility class, so there are no instance at all.\n+   */\n+  private TestProblemFactory() {\n+  }\n+\n+  /**\n+   * Get the problems.\n+   * @return array of problems to solve\n+   */\n+  public static TestProblemAbstract[] getProblems() {\n+    return pool;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/TestProblemHandler.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.ODEIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class is used to handle steps for the test problems\n+ * integrated during the junit tests for the ODE integrators.\n+ */\n+class TestProblemHandler\n+  implements StepHandler {\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 3589490480549900461L;\n+\n+  /** Associated problem. */\n+  private TestProblemAbstract problem;\n+\n+  /** Maximal errors encountered during the integration. */\n+  private double maxValueError;\n+  private double maxTimeError;\n+\n+  /** Error at the end of the integration. */\n+  private double lastError;\n+\n+  /** Time at the end of integration. */\n+  private double lastTime;\n+\n+  /** ODE solver used. */\n+  private ODEIntegrator integrator;\n+\n+  /** Expected start for step. */\n+  private double expectedStepStart;\n+\n+  /**\n+   * Simple constructor.\n+   * @param problem problem for which steps should be handled\n+   * @param integrator ODE solver used\n+   */\n+  public TestProblemHandler(TestProblemAbstract problem, ODEIntegrator integrator) {\n+    this.problem = problem;\n+    this.integrator = integrator;\n+    reset();\n+  }\n+\n+  public boolean requiresDenseOutput() {\n+    return true;\n+  }\n+\n+  public void reset() {\n+    maxValueError = 0;\n+    maxTimeError  = 0;\n+    lastError     = 0;\n+    expectedStepStart = Double.NaN;\n+  }\n+\n+  public void handleStep(StepInterpolator interpolator,\n+                         boolean isLast)\n+    throws DerivativeException {\n+\n+    double start = integrator.getCurrentStepStart();\n+    if (Math.abs((start - problem.getInitialTime()) / integrator.getCurrentSignedStepsize()) > 0.001) {\n+        // multistep integrators do not handle the first steps themselves\n+        // so we have to make sure the integrator we look at has really started its work\n+        if (!Double.isNaN(expectedStepStart)) {\n+            maxTimeError = Math.max(maxTimeError, Math.abs(start - expectedStepStart));\n+        }\n+        expectedStepStart = start + integrator.getCurrentSignedStepsize();\n+    }\n+\n+    double pT = interpolator.getPreviousTime();\n+    double cT = interpolator.getCurrentTime();\n+    double[] errorScale = problem.getErrorScale();\n+\n+    // store the error at the last step\n+    if (isLast) {\n+      double[] interpolatedY = interpolator.getInterpolatedState();\n+      double[] theoreticalY  = problem.computeTheoreticalState(cT);\n+      for (int i = 0; i < interpolatedY.length; ++i) {\n+        double error = Math.abs(interpolatedY[i] - theoreticalY[i]);\n+        if (error > lastError) {\n+          lastError = error;\n+        }\n+      }\n+      lastTime = cT;\n+    }\n+\n+    // walk through the step\n+    for (int k = 0; k <= 20; ++k) {\n+\n+      double time = pT + (k * (cT - pT)) / 20;\n+      interpolator.setInterpolatedTime(time);\n+      double[] interpolatedY = interpolator.getInterpolatedState();\n+      double[] theoreticalY  = problem.computeTheoreticalState(interpolator.getInterpolatedTime());\n+\n+      // update the errors\n+      for (int i = 0; i < interpolatedY.length; ++i) {\n+        double error = errorScale[i] * Math.abs(interpolatedY[i] - theoreticalY[i]);\n+        if (error > maxValueError) {\n+          maxValueError = error;\n+        }\n+      }\n+\n+    }\n+  }\n+\n+  /**\n+   * Get the maximal value error encountered during integration.\n+   * @return maximal value error\n+   */\n+  public double getMaximalValueError() {\n+    return maxValueError;\n+  }\n+\n+  /**\n+   * Get the maximal time error encountered during integration.\n+   * @return maximal time error\n+   */\n+  public double getMaximalTimeError() {\n+    return maxTimeError;\n+  }\n+\n+  /**\n+   * Get the error at the end of the integration.\n+   * @return error at the end of the integration\n+   */\n+  public double getLastError() {\n+    return lastError;\n+  }\n+\n+  /**\n+   * Get the time at the end of the integration.\n+   * @return time at the end of the integration.\n+   */\n+  public double getLastTime() {\n+    return lastTime;\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import junit.framework.*;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.nonstiff.ThreeEighthesIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+public class ThreeEighthesIntegratorTest\n+  extends TestCase {\n+\n+  public ThreeEighthesIntegratorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDimensionCheck() {\n+    try  {\n+      TestProblem1 pb = new TestProblem1();\n+      new ThreeEighthesIntegrator(0.01).integrate(pb,\n+                                                  0.0, new double[pb.getDimension()+10],\n+                                                  1.0, new double[pb.getDimension()+10]);\n+        fail(\"an exception should have been thrown\");\n+    } catch(DerivativeException de) {\n+      fail(\"wrong exception caught\");\n+    } catch(IntegratorException ie) {\n+    }\n+  }\n+  \n+  public void testDecreasingSteps()\n+    throws DerivativeException, IntegratorException  {\n+      \n+    TestProblemAbstract[] problems = TestProblemFactory.getProblems();\n+    for (int k = 0; k < problems.length; ++k) {\n+    \n+      double previousError = Double.NaN;\n+      for (int i = 4; i < 10; ++i) {\n+\n+        TestProblemAbstract pb = (TestProblemAbstract) problems[k].clone();\n+        double step = (pb.getFinalTime() - pb.getInitialTime())\n+          * Math.pow(2.0, -i);\n+\n+        FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+        TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+        integ.addStepHandler(handler);\n+        EventHandler[] functions = pb.getEventsHandlers();\n+        for (int l = 0; l < functions.length; ++l) {\n+          integ.addEventHandler(functions[l],\n+                                     Double.POSITIVE_INFINITY, 1.0e-6 * step, 1000);\n+        }\n+        double stopTime = integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                                          pb.getFinalTime(), new double[pb.getDimension()]);\n+        if (functions.length == 0) {\n+            assertEquals(pb.getFinalTime(), stopTime, 1.0e-10);\n+        }\n+\n+        double error = handler.getMaximalValueError();\n+        if (i > 4) {\n+          assertTrue(error < Math.abs(previousError));\n+        }\n+        previousError = error;\n+        assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+      }\n+\n+    }\n+\n+  }\n+\n+ public void testSmallStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() < 2.0e-13);\n+    assertTrue(handler.getMaximalValueError() < 4.0e-12);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+    assertEquals(\"3/8\", integ.getName());\n+\n+  }\n+\n+  public void testBigStep()\n+    throws DerivativeException, IntegratorException {\n+\n+    TestProblem1 pb = new TestProblem1();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.2;\n+\n+    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+    TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+    integ.addStepHandler(handler);\n+    integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    assertTrue(handler.getLastError() > 0.0004);\n+    assertTrue(handler.getMaximalValueError() > 0.005);\n+    assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+\n+  }\n+\n+  public void testBackward()\n+      throws DerivativeException, IntegratorException {\n+\n+      TestProblem5 pb = new TestProblem5();\n+      double step = Math.abs(pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+\n+      FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+      TestProblemHandler handler = new TestProblemHandler(pb, integ);\n+      integ.addStepHandler(handler);\n+      integ.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\n+                      pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+      assertTrue(handler.getLastError() < 5.0e-10);\n+      assertTrue(handler.getMaximalValueError() < 7.0e-10);\n+      assertEquals(0, handler.getMaximalTimeError(), 1.0e-12);\n+      assertEquals(\"3/8\", integ.getName());\n+  }\n+\n+  public void testKepler()\n+    throws DerivativeException, IntegratorException {\n+\n+    final TestProblem3 pb  = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+\n+    FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+    integ.addStepHandler(new KeplerHandler(pb));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+  }\n+\n+  private static class KeplerHandler implements StepHandler {\n+\n+    private static final long serialVersionUID = 4400497468419540899L;\n+\n+    public KeplerHandler(TestProblem3 pb) {\n+      this.pb = pb;\n+      maxError = 0;\n+    }\n+\n+    public boolean requiresDenseOutput() {\n+      return false;\n+    }\n+\n+    public void reset() {\n+      maxError = 0;\n+    }\n+\n+    public void handleStep(StepInterpolator interpolator,\n+                           boolean isLast) {\n+\n+      double[] interpolatedY = interpolator.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(interpolator.getCurrentTime());\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+      if (isLast) {\n+        // even with more than 1000 evaluations per period,\n+        // RK4 is not able to integrate such an eccentric\n+        // orbit with a good accuracy\n+        assertTrue(maxError > 0.005);\n+      }\n+    }\n+\n+    private TestProblem3 pb;\n+    private double maxError = 0;\n+\n+  }\n+\n+  public void testStepSize()\n+    throws DerivativeException, IntegratorException {\n+      final double step = 1.23456;\n+      FirstOrderIntegrator integ = new ThreeEighthesIntegrator(step);\n+      integ.addStepHandler(new StepHandler() {\n+          private static final long serialVersionUID = 0L;\n+          public void handleStep(StepInterpolator interpolator, boolean isLast) {\n+              if (! isLast) {\n+                  assertEquals(step,\n+                               interpolator.getCurrentTime() - interpolator.getPreviousTime(),\n+                               1.0e-12);\n+              }\n+          }\n+          public boolean requiresDenseOutput() {\n+              return false;\n+          }\n+          public void reset() {\n+          }          \n+      });\n+      integ.integrate(new FirstOrderDifferentialEquations() {\n+          private static final long serialVersionUID = 0L;\n+          public void computeDerivatives(double t, double[] y, double[] dot) {\n+              dot[0] = 1.0;\n+          }\n+          public int getDimension() {\n+              return 1;\n+          }\n+      }, 0.0, new double[] { 0.0 }, 5.0, new double[1]);\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ThreeEighthesIntegratorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+public class ThreeEighthesStepInterpolatorTest\n+  extends StepInterpolatorAbstractTest {\n+\n+  public ThreeEighthesStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testDerivativesConsistency()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3();\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.001;\n+    ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);\n+    checkDerivativesConsistency(integ, pb, 1.0e-10);\n+  }\n+\n+  public void testSerialization()\n+    throws DerivativeException, IntegratorException,\n+           IOException, ClassNotFoundException {\n+\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double step = (pb.getFinalTime() - pb.getInitialTime()) * 0.0003;\n+    ThreeEighthesIntegrator integ = new ThreeEighthesIntegrator(step);\n+    integ.addStepHandler(new ContinuousOutputModel());\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    for (StepHandler handler : integ.getStepHandlers()) {\n+        oos.writeObject(handler);\n+    }\n+\n+    assertTrue(bos.size () > 700000);\n+    assertTrue(bos.size () < 701000);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    ContinuousOutputModel cm  = (ContinuousOutputModel) ois.readObject();\n+\n+    Random random = new Random(347588535632l);\n+    double maxError = 0.0;\n+    for (int i = 0; i < 1000; ++i) {\n+      double r = random.nextDouble();\n+      double time = r * pb.getInitialTime() + (1.0 - r) * pb.getFinalTime();\n+      cm.setInterpolatedTime(time);\n+      double[] interpolatedY = cm.getInterpolatedState ();\n+      double[] theoreticalY  = pb.computeTheoreticalState(time);\n+      double dx = interpolatedY[0] - theoreticalY[0];\n+      double dy = interpolatedY[1] - theoreticalY[1];\n+      double error = dx * dx + dy * dy;\n+      if (error > maxError) {\n+        maxError = error;\n+      }\n+    }\n+\n+    assertTrue(maxError > 0.005);\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(ThreeEighthesStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/sampling/DummyStepInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import junit.framework.*;\n+import java.io.ByteArrayOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.ObjectInputStream;\n+import java.io.IOException;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+\n+public class DummyStepInterpolatorTest\n+  extends TestCase {\n+\n+  public DummyStepInterpolatorTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testNoReset() {\n+\n+    double[]   y    =   { 0.0, 1.0, -2.0 };\n+    DummyStepInterpolator interpolator = new DummyStepInterpolator(y, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    double[] result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+      assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  public void testFixedState()\n+    throws DerivativeException {\n+\n+    double[]   y    =   { 1.0, 3.0, -4.0 };\n+    DummyStepInterpolator interpolator = new DummyStepInterpolator(y, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    interpolator.setInterpolatedTime(0.1);\n+    double[] result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+        assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+    interpolator.setInterpolatedTime(0.5);\n+    result = interpolator.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+        assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  public void testSerialization()\n+  throws DerivativeException, IntegratorException,\n+         IOException, ClassNotFoundException {\n+\n+    double[]   y    =   { 0.0, 1.0, -2.0 };\n+    DummyStepInterpolator interpolator = new DummyStepInterpolator(y, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(interpolator);\n+\n+    assertTrue(bos.size () > 150);\n+    assertTrue(bos.size () < 250);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    DummyStepInterpolator dsi = (DummyStepInterpolator) ois.readObject();\n+\n+    dsi.setInterpolatedTime(0.5);\n+    double[] result = dsi.getInterpolatedState();\n+    for (int i = 0; i < result.length; ++i) {\n+        assertTrue(Math.abs(result[i] - y[i]) < 1.0e-10);\n+    }\n+\n+  }\n+\n+  public void testImpossibleSerialization()\n+  throws DerivativeException, IntegratorException,\n+         IOException, ClassNotFoundException {\n+\n+    double[] y = { 0.0, 1.0, -2.0 };\n+    AbstractStepInterpolator interpolator = new BadStepInterpolator(y, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    try {\n+        oos.writeObject(interpolator);\n+        fail(\"an exception should have been thrown\");\n+    } catch (IOException ioe) {\n+        // expected behavior\n+        assertEquals(0, ioe.getMessage().length());\n+    } catch (Exception e) {\n+        fail(\"wrong exception caught\");\n+    }\n+\n+  }\n+\n+  private static class BadStepInterpolator extends DummyStepInterpolator {\n+      public BadStepInterpolator() {\n+          super();\n+      }\n+      public BadStepInterpolator(double[] y, boolean forward) {\n+          super(y, forward);\n+      }\n+      protected void doFinalize()\n+      throws DerivativeException {\n+          throw new DerivativeException(null);\n+      }\n+  };\n+\n+\n+  public void testSerializationError()\n+  throws DerivativeException, IntegratorException,\n+         IOException, ClassNotFoundException {\n+\n+    double[] y = { 0.0, 1.0, -2.0 };\n+    ErrorGeneratingInterpolator interpolator =\n+        new ErrorGeneratingInterpolator(y, true);\n+    interpolator.storeTime(0);\n+    interpolator.shift();\n+    interpolator.storeTime(1);\n+\n+    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+    ObjectOutputStream    oos = new ObjectOutputStream(bos);\n+    oos.writeObject(interpolator);\n+\n+    assertTrue(bos.size () > 300);\n+    assertTrue(bos.size () < 350);\n+\n+    ByteArrayInputStream  bis = new ByteArrayInputStream(bos.toByteArray());\n+    ObjectInputStream     ois = new ObjectInputStream(bis);\n+    try {\n+        ois.readObject();\n+        fail(\"an exception should have been thrown\");\n+    } catch (IOException ioe) {\n+        // expected behavior\n+        assertEquals(0, ioe.getMessage().length());\n+    } catch (Exception e) {\n+        fail(\"wrong exception caught\");\n+    }\n+\n+  }\n+\n+  private static class ErrorGeneratingInterpolator extends DummyStepInterpolator {\n+      public ErrorGeneratingInterpolator() {\n+          super();\n+      }\n+      protected ErrorGeneratingInterpolator(double[] y, boolean forward) {\n+          super(y, forward);\n+      }\n+      public void computeInterpolatedState(double theta, double oneMinusThetaH)\n+      throws DerivativeException {\n+          throw new DerivativeException(null);\n+      }\n+      private static final long serialVersionUID = 0x3f6ab636f0c93571L;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(DummyStepInterpolatorTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/ode/sampling/StepNormalizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince54Integrator;\n+import org.apache.commons.math.ode.nonstiff.TestProblem3;\n+import org.apache.commons.math.ode.sampling.FixedStepHandler;\n+import org.apache.commons.math.ode.sampling.StepNormalizer;\n+\n+import junit.framework.*;\n+\n+public class StepNormalizerTest\n+  extends TestCase {\n+\n+  public StepNormalizerTest(String name) {\n+    super(name);\n+    pb    = null;\n+    integ = null;\n+  }\n+\n+  public void testBoundaries()\n+    throws DerivativeException, IntegratorException {\n+    double range = pb.getFinalTime() - pb.getInitialTime();\n+    setLastSeen(false);\n+    integ.addStepHandler(new StepNormalizer(range / 10.0,\n+                                       new FixedStepHandler() {\n+                                        private static final long serialVersionUID = 1650337364641626444L;\n+                                        private boolean firstCall = true;\n+                                         public void handleStep(double t,\n+                                                                double[] y,\n+                                                                double[] yDot,\n+                                                                boolean isLast) {\n+                                           if (firstCall) {\n+                                             checkValue(t, pb.getInitialTime());\n+                                             firstCall = false;\n+                                           }\n+                                           if (isLast) {\n+                                             setLastSeen(true);\n+                                             checkValue(t, pb.getFinalTime());\n+                                           }\n+                                         }\n+                                       }));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertTrue(lastSeen);\n+  }\n+\n+  public void testBeforeEnd()\n+    throws DerivativeException, IntegratorException {\n+    final double range = pb.getFinalTime() - pb.getInitialTime();\n+    setLastSeen(false);\n+    integ.addStepHandler(new StepNormalizer(range / 10.5,\n+                                       new FixedStepHandler() {\n+                                        private static final long serialVersionUID = 2228457391561277298L;\n+                                        public void handleStep(double t,\n+                                                                double[] y,\n+                                                                double[] yDot,\n+                                                                boolean isLast) {\n+                                           if (isLast) {\n+                                             setLastSeen(true);\n+                                             checkValue(t,\n+                                                        pb.getFinalTime() - range / 21.0);\n+                                           }\n+                                         }\n+                                       }));\n+    integ.integrate(pb,\n+                    pb.getInitialTime(), pb.getInitialState(),\n+                    pb.getFinalTime(), new double[pb.getDimension()]);\n+    assertTrue(lastSeen);\n+  }\n+\n+  public void checkValue(double value, double reference) {\n+    assertTrue(Math.abs(value - reference) < 1.0e-10);\n+  }\n+\n+  public void setLastSeen(boolean lastSeen) {\n+    this.lastSeen = lastSeen;\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(StepNormalizerTest.class);\n+  }\n+\n+  public void setUp() {\n+    pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    integ = new DormandPrince54Integrator(minStep, maxStep, 10.e-8, 1.0e-8);\n+    lastSeen = false;\n+  }\n+\n+  public void tearDown() {\n+    pb    = null;\n+    integ = null;\n+  }\n+\n+  TestProblem3 pb;\n+  FirstOrderIntegrator integ;\n+  boolean lastSeen;\n+\n+}\n--- a/src/test/org/apache/commons/math/random/AbstractRandomGeneratorTest.java\n+++ b/src/test/org/apache/commons/math/random/AbstractRandomGeneratorTest.java\n /**\n  * Test cases for the AbstractRandomGenerator class\n  *\n- * @version $Revision:$ $Date$\n+ * @version $Revision$ $Date$\n  */\n \n public class AbstractRandomGeneratorTest extends RandomDataTest {\n--- a/src/test/org/apache/commons/math/random/CorrelatedRandomVectorGeneratorTest.java\n+++ b/src/test/org/apache/commons/math/random/CorrelatedRandomVectorGeneratorTest.java\n \n     public void testRank() {\n         assertEquals(3, generator.getRank());\n+    }\n+\n+    public void testMath226()\n+        throws DimensionMismatchException, NotPositiveDefiniteMatrixException {\n+        double[] mean = { 1, 1, 10, 1 };\n+        double[][] cov = {\n+                { 1, 3, 2, 6 },\n+                { 3, 13, 16, 2 },\n+                { 2, 16, 38, -1 },\n+                { 6, 2, -1, 197 }\n+        };\n+        RealMatrix covRM = new RealMatrixImpl(cov, false);\n+        JDKRandomGenerator jg = new JDKRandomGenerator();\n+        jg.setSeed(5322145245211l);\n+        NormalizedRandomGenerator rg = new GaussianRandomGenerator(jg);\n+        CorrelatedRandomVectorGenerator sg =\n+            new CorrelatedRandomVectorGenerator(mean, covRM, 0.00001, rg);\n+\n+        for (int i = 0; i < 10; i++) {\n+            double[] generated = sg.nextVector();\n+            assertTrue(Math.abs(generated[0] - 1) > 0.1);\n+        }\n+\n     }\n \n     public void testRootMatrix() {\n--- a/src/test/org/apache/commons/math/random/EmpiricalDistributionTest.java\n+++ b/src/test/org/apache/commons/math/random/EmpiricalDistributionTest.java\n  */\n package org.apache.commons.math.random;\n \n-import junit.framework.Test;\n-import junit.framework.TestSuite;\n-\n import java.io.BufferedReader;\n import java.io.File;\n import java.io.IOException;\n import java.io.InputStreamReader;\n import java.net.URL;\n import java.util.ArrayList;\n-import java.util.Iterator;\n-\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.RetryTestCase;\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n                 new BufferedReader(new InputStreamReader(\n                         url.openStream()));\n         String str = null;\n-        ArrayList list = new ArrayList();\n+        ArrayList<Double> list = new ArrayList<Double>();\n         while ((str = in.readLine()) != null) {\n             list.add(Double.valueOf(str));\n         }\n         \n         dataArray = new double[list.size()];\n         int i = 0;\n-        for (Iterator iter = list.iterator(); iter.hasNext();) {\n-            dataArray[i] = ((Double)iter.next()).doubleValue();\n+        for (Double data : list) {\n+            dataArray[i] = data.doubleValue();\n             i++;\n         }                 \n     }\n             empiricalDistribution.getNextValue();\n             empiricalDistribution2.getNextValue();\n             fail(\"Expecting IllegalStateException\");\n-        } catch (IllegalStateException ex) {;}\n+        } catch (IllegalStateException ex) {\n+            // expected\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n     }\n     \n     /**\n         try {\n             dist.load((double[]) null);\n             fail(\"load((double[]) null) expected RuntimeException\");\n-        }\n-        catch (RuntimeException e) {\n-            // expected\n+        } catch (MathRuntimeException e) {\n+            // expected\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n         }\n     }\n \n         try {\n             dist.load((URL) null);\n             fail(\"load((URL) null) expected NullPointerException\");\n-        }\n-        catch (NullPointerException e) {\n-            // expected\n+        } catch (NullPointerException e) {\n+            // expected\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n         }\n     }\n \n         try {\n             dist.load((File) null);\n             fail(\"load((File) null) expected NullPointerException\");\n-        }\n-        catch (NullPointerException e) {\n-            // expected\n+        } catch (NullPointerException e) {\n+            // expected\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n         }\n     }\n \n--- a/src/test/org/apache/commons/math/random/RandomAdaptorTest.java\n+++ b/src/test/org/apache/commons/math/random/RandomAdaptorTest.java\n /**\n  * Test cases for the RandomAdaptor class\n  *\n- * @version $Revision:$ $Date$\n+ * @version $Revision$ $Date$\n  */\n \n public class RandomAdaptorTest extends RandomDataTest {\n--- a/src/test/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/org/apache/commons/math/random/RandomDataTest.java\n                         f.getCount(3) + f.getCount(4) + f.getCount(5);\n         long sumFreq = f.getSumFreq();\n         double cumPct = \n-            new Double(cumFreq).doubleValue()/new Double(sumFreq).doubleValue();\n+            Double.valueOf(cumFreq).doubleValue()/Double.valueOf(sumFreq).doubleValue();\n         assertEquals(\"cum Poisson(4)\",cumPct,0.7851,0.2);\n         try {\n             randomData.nextPoisson(-1);\n        long[] observed = {0,0,0,0,0,0,0,0,0,0};\n        double[] expected = {100,100,100,100,100,100,100,100,100,100};\n        \n-       HashSet cPop = new HashSet();  //{0,1,2,3,4}\n+       HashSet<Object> cPop = new HashSet<Object>();  //{0,1,2,3,4}\n        for (int i = 0; i < 5; i++) {\n            cPop.add(Integer.toString(i));\n        }\n        \n        Object[] sets = new Object[10]; // 2-sets from 5\n        for (int i = 0; i < 10; i ++) {\n-           HashSet hs = new HashSet();\n+           HashSet<Object> hs = new HashSet<Object>();\n            hs.add(c[i][0]);\n            hs.add(c[i][1]);\n            sets[i] = hs;\n             testStatistic.chiSquare(expected,observed) < 27.88);  \n        \n        // Make sure sample of size = size of collection returns same collection\n-       HashSet hs = new HashSet();\n+       HashSet<Object> hs = new HashSet<Object>();\n        hs.add(\"one\");\n        Object[] one = randomData.nextSample(hs,1);\n        String oneString = (String) one[0];\n        \n        // Make sure we fail for empty collection\n        try {\n-           hs = new HashSet();\n+           hs = new HashSet<Object>();\n            one = randomData.nextSample(hs,0);\n            fail(\"n = k = 0, expecting IllegalArgumentException\");\n        } catch (IllegalArgumentException ex) {\n            ;\n        }\n     }\n-    \n+\n+    @SuppressWarnings(\"unchecked\")\n     private int findSample(Object[] u, Object[] samp) {\n         for (int i = 0; i < u.length; i++) {\n-            HashSet set = (HashSet) u[i];\n-            HashSet sampSet = new HashSet();\n+            HashSet<Object> set = (HashSet<Object>) u[i];\n+            HashSet<Object> sampSet = new HashSet<Object>();\n             for (int j = 0; j < samp.length; j++) {\n                 sampSet.add(samp[j]);\n             }\n                 fail(\"permutation k = n = 0, expecting IllegalArgumentException\");\n             } catch (IllegalArgumentException ex) {\n                 ;\n-            }               \n+            }  \n+            \n+            // Make sure we fail for k < n < 0\n+            try {\n+                perm = randomData.nextPermutation(-1,-3);\n+                fail(\"permutation k < n < 0, expecting IllegalArgumentException\");\n+            } catch (IllegalArgumentException ex) {\n+                ;\n+            }  \n+            \n         }       \n     }\n     \n--- a/src/test/org/apache/commons/math/random/TestRandomGenerator.java\n+++ b/src/test/org/apache/commons/math/random/TestRandomGenerator.java\n  * java.util.Random instance.  Used by AbstractRandomGeneratorTest to test\n  * default implementations in AbstractRandomGenerator.\n  *\n- * @version $Revision:$ $Date$\n+ * @version $Revision$ $Date$\n  */\n public class TestRandomGenerator extends AbstractRandomGenerator {\n \n--- a/src/test/org/apache/commons/math/stat/FrequencyTest.java\n+++ b/src/test/org/apache/commons/math/stat/FrequencyTest.java\n         assertEquals(\"zero cumulative frequency\", 0, f.getCumFreq(0));\n         assertEquals(\"one cumulative frequency\", 3,  f.getCumFreq(1));\n         assertEquals(\"two cumulative frequency\", 4,  f.getCumFreq(2));\n-        assertEquals(\"Integer argument cum freq\",4, f.getCumFreq(new Integer(2)));\n+        assertEquals(\"Integer argument cum freq\",4, f.getCumFreq(Integer.valueOf(2)));\n         assertEquals(\"five cumulative frequency\", 4,  f.getCumFreq(5));\n         assertEquals(\"foo cumulative frequency\", 0,  f.getCumFreq(\"foo\"));\n         \n         f = null;\n         Frequency f = new Frequency();\n         f.addValue(1);\n-        f.addValue(new Integer(1));\n-        f.addValue(new Long(1));\n+        f.addValue(Integer.valueOf(1));\n+        f.addValue(Long.valueOf(1));\n         f.addValue(2);\n-        f.addValue(new Integer(-1));\n+        f.addValue(Integer.valueOf(-1));\n         assertEquals(\"1 count\", 3, f.getCount(1));\n-        assertEquals(\"1 count\", 3, f.getCount(new Integer(1)));\n+        assertEquals(\"1 count\", 3, f.getCount(Integer.valueOf(1)));\n         assertEquals(\"0 cum pct\", 0.2, f.getCumPct(0), tolerance);\n-        assertEquals(\"1 pct\", 0.6, f.getPct(new Integer(1)), tolerance);\n+        assertEquals(\"1 pct\", 0.6, f.getPct(Integer.valueOf(1)), tolerance);\n         assertEquals(\"-2 cum pct\", 0, f.getCumPct(-2), tolerance);\n         assertEquals(\"10 cum pct\", 1, f.getCumPct(10), tolerance);   \n         \n         f.addValue(3);\n         f.addValue(threeI);\n         assertEquals(\"one pct\",0.25,f.getPct(1),tolerance);\n-        assertEquals(\"two pct\",0.25,f.getPct(new Long(2)),tolerance);\n+        assertEquals(\"two pct\",0.25,f.getPct(Long.valueOf(2)),tolerance);\n         assertEquals(\"three pct\",0.5,f.getPct(threeL),tolerance);\n         assertEquals(\"five pct\",0,f.getPct(5),tolerance);\n         assertEquals(\"foo pct\",0,f.getPct(\"foo\"),tolerance);\n         assertEquals(\"one cum pct\",0.25,f.getCumPct(1),tolerance);\n-        assertEquals(\"two cum pct\",0.50,f.getCumPct(new Long(2)),tolerance);\n-        assertEquals(\"Integer argument\",0.50,f.getCumPct(new Integer(2)),tolerance);\n+        assertEquals(\"two cum pct\",0.50,f.getCumPct(Long.valueOf(2)),tolerance);\n+        assertEquals(\"Integer argument\",0.50,f.getCumPct(Integer.valueOf(2)),tolerance);\n         assertEquals(\"three cum pct\",1.0,f.getCumPct(threeL),tolerance);\n         assertEquals(\"five cum pct\",1.0,f.getCumPct(5),tolerance);\n         assertEquals(\"zero cum pct\",0.0,f.getCumPct(0),tolerance);\n     public void testEmptyTable() {\n         assertEquals(\"freq sum, empty table\", 0, f.getSumFreq());\n         assertEquals(\"count, empty table\", 0, f.getCount(0));\n-        assertEquals(\"count, empty table\",0, f.getCount(new Integer(0)));\n+        assertEquals(\"count, empty table\",0, f.getCount(Integer.valueOf(0)));\n         assertEquals(\"cum freq, empty table\", 0, f.getCumFreq(0));\n         assertEquals(\"cum freq, empty table\", 0, f.getCumFreq(\"x\"));\n         assertTrue(\"pct, empty table\", Double.isNaN(f.getPct(0)));\n-        assertTrue(\"pct, empty table\", Double.isNaN(f.getPct(new Integer(0))));\n+        assertTrue(\"pct, empty table\", Double.isNaN(f.getPct(Integer.valueOf(0))));\n         assertTrue(\"cum pct, empty table\", Double.isNaN(f.getCumPct(0)));\n-        assertTrue(\"cum pct, empty table\", Double.isNaN(f.getCumPct(new Integer(0))));   \n+        assertTrue(\"cum pct, empty table\", Double.isNaN(f.getCumPct(Integer.valueOf(0))));   \n     }\n     \n     /**\n     }\n     public void testIntegerValues() {\n         Object obj1 = null;\n-        obj1 = new Integer(1);\n-        Integer int1 = new Integer(1);\n+        obj1 = Integer.valueOf(1);\n+        Integer int1 = Integer.valueOf(1);\n         f.addValue(obj1);\n         f.addValue(int1);\n         f.addValue(2);\n-        f.addValue(new Long(2));\n+        f.addValue(Long.valueOf(2));\n         assertEquals(\"Integer 1 count\", 2, f.getCount(1));\n-        assertEquals(\"Integer 1 count\", 2, f.getCount(new Integer(1)));\n-        assertEquals(\"Integer 1 count\", 2, f.getCount(new Long(1)));\n+        assertEquals(\"Integer 1 count\", 2, f.getCount(Integer.valueOf(1)));\n+        assertEquals(\"Integer 1 count\", 2, f.getCount(Long.valueOf(1)));\n         assertEquals(\"Integer 1 cumPct\", 0.5, f.getCumPct(1), tolerance);\n-        assertEquals(\"Integer 1 cumPct\", 0.5, f.getCumPct(new Long(1)), tolerance);\n-        assertEquals(\"Integer 1 cumPct\", 0.5, f.getCumPct(new Integer(1)), tolerance);\n+        assertEquals(\"Integer 1 cumPct\", 0.5, f.getCumPct(Long.valueOf(1)), tolerance);\n+        assertEquals(\"Integer 1 cumPct\", 0.5, f.getCumPct(Integer.valueOf(1)), tolerance);\n         Iterator it = f.valuesIterator();\n         while (it.hasNext()) {\n             assertTrue(it.next() instanceof Long);\n--- a/src/test/org/apache/commons/math/stat/data/CertifiedDataAbstractTest.java\n+++ b/src/test/org/apache/commons/math/stat/data/CertifiedDataAbstractTest.java\n import java.lang.reflect.Method;\n import java.net.URL;\n import java.util.HashMap;\n-import java.util.Iterator;\n import java.util.Map;\n+\n+import junit.framework.TestCase;\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n-\n-import junit.framework.TestCase;\n \n /**\n  * @version $Revision$ $Date$\n     \n     private SummaryStatistics summaries;\n     \n-    private Map certifiedValues;\n+    private Map<String, Double> certifiedValues;\n     \n     protected void setUp() throws Exception {\n         descriptives = new DescriptiveStatistics();\n         summaries = new SummaryStatistics();\n-        certifiedValues = new HashMap();\n+        certifiedValues = new HashMap<String, Double>();\n         \n         loadData();\n     }\n                         // certified value\n                         String name = line.substring(0, n).trim();\n                         String valueString = line.substring(n + 1).trim();\n-                        Double value = new Double(valueString);\n+                        Double value = Double.valueOf(valueString);\n                         certifiedValues.put(name, value);\n                     }\n                 }\n     }\n     \n     public void testCertifiedValues() {\n-        Iterator iter = certifiedValues.keySet().iterator();\n-\n-        while (iter.hasNext()) {\n-            String name = iter.next().toString();\n+        for (String name : certifiedValues.keySet()) {\n             Double expectedValue = (Double)certifiedValues.get(name);\n \n             Double summariesValue = getProperty(summaries, name);\n             if (meth.getReturnType().equals(Double.TYPE)) {\n                 return (Double) property;\n             } else if (meth.getReturnType().equals(Long.TYPE)) {\n-                return new Double(((Long) property).doubleValue());\n+                return Double.valueOf(((Long) property).doubleValue());\n             } else {\n                 fail(\"wrong type: \" + meth.getReturnType().getName());\n             }\n--- a/src/test/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsTest.java\n package org.apache.commons.math.stat.descriptive;\n \n import junit.framework.Test;\n+import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n import org.apache.commons.math.stat.descriptive.rank.Percentile;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n  * Test cases for the DescriptiveStatistics class.\n- * When DescriptiveStatisticsImpl is removed, this class should replace\n- * DescriptiveStatisticsAbstractTest\n  * \n- * @version $Revision: 592121 $ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n+ * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n  *          2007) $\n  */\n-public final class DescriptiveStatisticsTest extends DescriptiveStatisticsAbstractTest {\n+public class DescriptiveStatisticsTest extends TestCase {\n \n     public DescriptiveStatisticsTest(String name) {\n         super(name);\n         TestSuite suite = new TestSuite(DescriptiveStatisticsTest.class);\n         suite.setName(\"DescriptiveStatistics Tests\");\n         return suite;\n-    }\n-\n-    protected DescriptiveStatistics createDescriptiveStatistics() {\n-        return new DescriptiveStatistics();\n     }\n     \n     public void testSetterInjection() throws Exception {\n             // expected\n         }\n     }\n+    public void testRemoval() {\n+\n+        final DescriptiveStatistics dstat = new DescriptiveStatistics();\n+\n+        checkremoval(dstat, 1, 6.0, 0.0, Double.NaN);\n+        checkremoval(dstat, 3, 5.0, 3.0, 4.5);\n+        checkremoval(dstat, 6, 3.5, 2.5, 3.0);\n+        checkremoval(dstat, 9, 3.5, 2.5, 3.0);\n+        checkremoval(dstat, DescriptiveStatistics.INFINITE_WINDOW, 3.5, 2.5, 3.0);\n+\n+    }\n+\n+    public void checkremoval(DescriptiveStatistics dstat, int wsize,\n+                             double mean1, double mean2, double mean3) {\n+\n+        dstat.setWindowSize(wsize);\n+        dstat.clear();\n+\n+        for (int i = 1 ; i <= 6 ; ++i) {\n+            dstat.addValue(i);\n+        }\n+\n+        assertTrue(MathUtils.equals(mean1, dstat.getMean()));\n+        dstat.replaceMostRecentValue(0);\n+        assertTrue(MathUtils.equals(mean2, dstat.getMean()));\n+        dstat.removeMostRecentValue();\n+        assertTrue(MathUtils.equals(mean3, dstat.getMean()));\n+\n+    }\n     \n     // Test UnivariateStatistics impls for setter injection tests\n     \n         public double evaluate(double[] values) {\n             return 42;\n         }  \n+        public UnivariateStatistic copy() {\n+            return new deepMean();\n+        }\n     }\n     \n     /**\n         public double evaluate(double[] values) {\n             return percentile.evaluate(values);\n         }  \n+        public UnivariateStatistic copy() {\n+            goodPercentile result = new goodPercentile();\n+            result.setQuantile(percentile.getQuantile());\n+            return result;\n+        }\n     }\n     \n     /**\n             return getQuantile();\n         }  \n         private static final long serialVersionUID = 8040701391045914979L;\n+        public Percentile copy() {\n+            subPercentile result = new subPercentile();\n+            return result;\n+        }\n     }\n     \n     /**\n         }\n         public double evaluate(double[] values) {\n             return percentile.evaluate(values);\n-        }  \n+        }\n+        public UnivariateStatistic copy() {\n+            return new badPercentile();\n+        }\n+    }\n+    \n+    private void checkSameResults(DescriptiveStatistics first,\n+            DescriptiveStatistics second) throws Exception {\n+        assertEquals(first.getGeometricMean(), second.getGeometricMean(), 0);\n+        assertEquals(first.getKurtosis(), second.getKurtosis(), 0);\n+        assertEquals(first.getMax(), second.getMax(), 0);\n+        assertEquals(first.getMean(), second.getMean(), 0);\n+        assertEquals(first.getMin(), second.getMin(), 0);\n+        assertEquals(first.getN(), second.getN(), 0);\n+        assertEquals(first.getPercentile(10), second.getPercentile(10), 0);\n+        assertEquals(first.getSkewness(), second.getSkewness(), 0);\n+        assertEquals(first.getStandardDeviation(),\n+                second.getStandardDeviation(), 0);\n+        assertEquals(first.getSum(), second.getSum(), 0);\n+        assertEquals(first.getSumsq(), second.getSumsq(), 0);\n+        assertEquals(first.getVariance(), second.getVariance(), 0);\n+        assertEquals(first.eDA, second.eDA);\n+        assertEquals(first.getWindowSize(), second.getWindowSize());\n+        \n     }\n }\n--- a/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java\n      * Holds a reference to a list - GENERICs are going to make\n      * our lives easier here as we could only accept List<Number>\n      */\n-    protected List list;\n+    protected List<Object> list;\n \n     /** Number Transformer maps Objects to Number for us. */\n     protected NumberTransformer transformer;\n      * No argument Constructor\n      */\n     public ListUnivariateImpl(){\n-        this(new ArrayList());\n+        this(new ArrayList<Object>());\n     }\n     \n     /**\n      * Construct a ListUnivariate with a specific List.\n      * @param list The list that will back this DescriptiveStatistics\n      */\n-    public ListUnivariateImpl(List list) {\n+    public ListUnivariateImpl(List<Object> list) {\n         this(list, new DefaultTransformer());\n     }\n     \n      * @param list The list that will back this DescriptiveStatistics\n      * @param transformer the number transformer used to convert the list items.\n      */\n-    public ListUnivariateImpl(List list, NumberTransformer transformer) {\n+    public ListUnivariateImpl(List<Object> list, NumberTransformer transformer) {\n         super();\n         this.list = list;\n         this.transformer = transformer;\n      * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#addValue(double)\n      */\n     public void addValue(double v) {\n-        list.add(new Double(v));\n+        list.add(Double.valueOf(v));\n     }\n     \n     /**\n--- a/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImplTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImplTest.java\n     \n     /** test stats */\n     public void testStats() {\n-        List externalList = new ArrayList();\n+        List<Object> externalList = new ArrayList<Object>();\n         \n         DescriptiveStatistics u = new ListUnivariateImpl( externalList ); \n \n     }     \n     \n     public void testN0andN1Conditions() throws Exception {\n-        List list = new ArrayList();\n+        List<Object> list = new ArrayList<Object>();\n         \n         DescriptiveStatistics u = new ListUnivariateImpl( list );\n                 \n         assertTrue(\"Standard Deviation of n = 0 set should be NaN\", Double.isNaN( u.getStandardDeviation() ) );\n         assertTrue(\"Variance of n = 0 set should be NaN\", Double.isNaN(u.getVariance() ) );\n \n-        list.add( new Double(one));\n+        list.add( Double.valueOf(one));\n \n         assertTrue( \"Mean of n = 1 set should be value of single item n1\", u.getMean() == one);\n         assertTrue( \"StdDev of n = 1 set should be zero, instead it is: \" + u.getStandardDeviation(), u.getStandardDeviation() == 0);\n     }\n \n     public void testProductAndGeometricMean() throws Exception {\n-        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList());\n+        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>());\n         u.setWindowSize(10);\n                 \n         u.addValue( 1.0 );\n--- a/src/test/org/apache/commons/math/stat/descriptive/MixedListUnivariateImplTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/MixedListUnivariateImplTest.java\n \n     /** test stats */\n     public void testStats() {\n-        List externalList = new ArrayList();\n+        List<Object> externalList = new ArrayList<Object>();\n \n         DescriptiveStatistics u = new ListUnivariateImpl(externalList,transformers);\n \n     }\n \n     public void testN0andN1Conditions() throws Exception {\n-        DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList(),transformers);\n+        DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);\n \n         assertTrue(\n             \"Mean of n = 0 set should be NaN\",\n \n     public void testSkewAndKurtosis() {\n         ListUnivariateImpl u =\n-            new ListUnivariateImpl(new ArrayList(), transformers);\n+            new ListUnivariateImpl(new ArrayList<Object>(), transformers);\n \n         u.addObject(\"12.5\");\n-        u.addObject(new Integer(12));\n+        u.addObject(Integer.valueOf(12));\n         u.addObject(\"11.8\");\n         u.addObject(\"14.2\");\n         u.addObject(new Foo());\n         u.addObject(\"14.5\");\n-        u.addObject(new Long(21));\n+        u.addObject(Long.valueOf(21));\n         u.addObject(\"8.2\");\n         u.addObject(\"10.3\");\n         u.addObject(\"11.3\");\n-        u.addObject(new Float(14.1));\n+        u.addObject(Float.valueOf(14.1f));\n         u.addObject(\"9.9\");\n         u.addObject(\"12.2\");\n         u.addObject(new Bar());\n         u.addObject(\"12.1\");\n         u.addObject(\"11\");\n-        u.addObject(new Double(19.8));\n+        u.addObject(Double.valueOf(19.8));\n         u.addObject(\"11\");\n         u.addObject(\"10\");\n         u.addObject(\"8.8\");\n     }\n \n     public void testProductAndGeometricMean() throws Exception {\n-        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList(),transformers);\n+        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList<Object>(),transformers);\n         u.setWindowSize(10);\n \n         u.addValue(1.0);\n--- a/src/test/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatisticsTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatisticsTest.java\n /**\n  * Test cases for the {@link MultivariateSummaryStatistics} class.\n  *\n- * @version $Revision: 566833 $ $Date: 2007-08-16 13:36:33 -0700 (Thu, 16 Aug 2007) $\n+ * @version $Revision$ $Date$\n  */\n \n public class MultivariateSummaryStatisticsTest extends TestCase {\n         }\n         public void incrementAll(double[] values) {\n         }   \n+        public StorelessUnivariateStatistic copy() {\n+            return new sumMean();\n+        }\n     }\n \n     public void testDimension() {\n         int emptyHash = u.hashCode();\n         assertTrue(u.equals(u));\n         assertFalse(u.equals(t));\n-        assertFalse(u.equals(new Double(0)));\n+        assertFalse(u.equals(Double.valueOf(0)));\n         t = new MultivariateSummaryStatistics(2, true);\n         assertTrue(t.equals(u));\n         assertTrue(u.equals(t));\n--- a/src/test/org/apache/commons/math/stat/descriptive/StatisticalSummaryValuesTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/StatisticalSummaryValuesTest.java\n         StatisticalSummaryValues t = null;\n         assertTrue(\"reflexive\", u.equals(u));\n         assertFalse(\"non-null compared to null\", u.equals(t));\n-        assertFalse(\"wrong type\", u.equals(new Double(0)));\n+        assertFalse(\"wrong type\", u.equals(Double.valueOf(0)));\n         t = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);\n         assertTrue(\"instances with same data should be equal\", t.equals(u));\n         assertEquals(\"hash code\", u.hashCode(), t.hashCode());\n--- a/src/test/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatisticAbstractTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatisticAbstractTest.java\n     /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */\n     public abstract double expectedValue();\n     \n-    /** Verify that calling increment() in a loop over testArray results in correct state */\n+    /** \n+     *  Verifies that increment() and incrementAll work properly. \n+     */\n     public void testIncrementation() throws Exception {\n \n         StorelessUnivariateStatistic statistic =\n             (StorelessUnivariateStatistic) getUnivariateStatistic();\n-\n-        statistic.clear();\n-\n+        \n+        // Add testArray one value at a time and check result\n         for (int i = 0; i < testArray.length; i++) {\n             statistic.increment(testArray[i]);\n         }\n-\n+        \n         assertEquals(expectedValue(), statistic.getResult(), getTolerance());\n         assertEquals(testArray.length, statistic.getN());\n \n         statistic.clear();\n-\n+        \n+        // Add testArray all at once and check again\n+        statistic.incrementAll(testArray);\n+        assertEquals(expectedValue(), statistic.getResult(), getTolerance());\n+        assertEquals(testArray.length, statistic.getN());\n+        \n+        statistic.clear();\n+        \n+        // Cleared\n         assertTrue(Double.isNaN(statistic.getResult()));\n         assertEquals(0, statistic.getN());\n \n             TestUtils.assertEquals(stat.getResult(), stat.evaluate(smallSamples[i]), getTolerance());\n         }\n     }\n-\n+    \n+    /**\n+     * Verifies that copied statistics remain equal to originals when\n+     * incremented the same way.\n+     *\n+     */\n+    public void testCopyConsistency() {\n+        \n+        StorelessUnivariateStatistic master =\n+            (StorelessUnivariateStatistic) getUnivariateStatistic();\n+        \n+        StorelessUnivariateStatistic replica = null;\n+        \n+        // Randomly select a portion of testArray to load first\n+        long index = Math.round((Math.random()) * (double) testArray.length);\n+        \n+        // Put first half in master and copy master to replica\n+        master.incrementAll(testArray, 0, (int) index);\n+        replica = (StorelessUnivariateStatistic) master.copy();\n+        \n+        // Check same\n+        assertTrue(replica.equals(master));\n+        assertTrue(master.equals(replica));\n+        \n+        // Now add second part to both and check again\n+        master.incrementAll(testArray, \n+                (int) index, (int) (testArray.length - index));\n+        replica.incrementAll(testArray, \n+                (int) index, (int) (testArray.length - index));\n+        assertTrue(replica.equals(master));\n+        assertTrue(master.equals(replica));\n+    }\n+    \n }\n--- a/src/test/org/apache/commons/math/stat/descriptive/SummaryStatisticsTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/SummaryStatisticsTest.java\n \n \n import junit.framework.Test;\n+import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.stat.descriptive.moment.Mean;\n import org.apache.commons.math.stat.descriptive.summary.Sum;\n /**\n  * Test cases for the {@link SummaryStatistics} class.\n- * When SummaryStatisticsImpl is removed in math 2.0, test cases from\n- * SummaryStatisticsImplTest should be merged into this class.\n  *\n- * @version $Revision: 566833 $ $Date: 2007-08-16 13:36:33 -0700 (Thu, 16 Aug 2007) $\n+ * @version $Revision$ $Date$\n  */\n \n-public final class SummaryStatisticsTest extends SummaryStatisticsAbstractTest {\n-\n-    public SummaryStatisticsTest(String name) {\n-        super(name);\n-    }\n-    \n+public class SummaryStatisticsTest extends TestCase {\n+\n+    private double one = 1;\n+    private float twoF = 2;\n+    private long twoL = 2;\n+    private int three = 3;\n+    private double mean = 2;\n+    private double sumSq = 18;\n+    private double sum = 8;\n+    private double var = 0.666666666666666666667;\n+    private double std = Math.sqrt(var);\n+    private double n = 4;\n+    private double min = 1;\n+    private double max = 3;\n+    private double tolerance = 10E-15;\n+\n     public static Test suite() {\n         TestSuite suite = new TestSuite(SummaryStatisticsTest.class);\n         suite.setName(\"SummaryStatistics tests\");\n         return suite;\n     }\n \n+    public SummaryStatisticsTest(String name) {\n+        super(name);\n+    }\n+    \n     protected SummaryStatistics createSummaryStatistics() {\n         return new SummaryStatistics();\n     }\n+\n+    /** test stats */\n+    public void testStats() {\n+        SummaryStatistics u = createSummaryStatistics();\n+        assertEquals(\"total count\",0,u.getN(),tolerance);\n+        u.addValue(one);\n+        u.addValue(twoF);\n+        u.addValue(twoL);\n+        u.addValue(three);\n+        assertEquals(\"N\",n,u.getN(),tolerance);\n+        assertEquals(\"sum\",sum,u.getSum(),tolerance);\n+        assertEquals(\"sumsq\",sumSq,u.getSumsq(),tolerance);\n+        assertEquals(\"var\",var,u.getVariance(),tolerance);\n+        assertEquals(\"std\",std,u.getStandardDeviation(),tolerance);\n+        assertEquals(\"mean\",mean,u.getMean(),tolerance);\n+        assertEquals(\"min\",min,u.getMin(),tolerance);\n+        assertEquals(\"max\",max,u.getMax(),tolerance);\n+        u.clear();\n+        assertEquals(\"total count\",0,u.getN(),tolerance);    \n+    }     \n+\n+    public void testN0andN1Conditions() throws Exception {\n+        SummaryStatistics u = createSummaryStatistics();\n+        assertTrue(\"Mean of n = 0 set should be NaN\", \n+                Double.isNaN( u.getMean() ) );\n+        assertTrue(\"Standard Deviation of n = 0 set should be NaN\", \n+                Double.isNaN( u.getStandardDeviation() ) );\n+        assertTrue(\"Variance of n = 0 set should be NaN\", \n+                Double.isNaN(u.getVariance() ) );\n+\n+        /* n=1 */\n+        u.addValue(one);\n+        assertTrue(\"mean should be one (n = 1)\", \n+                u.getMean() == one);\n+        assertTrue(\"geometric should be one (n = 1) instead it is \" + u.getGeometricMean(), \n+                u.getGeometricMean() == one);\n+        assertTrue(\"Std should be zero (n = 1)\", \n+                u.getStandardDeviation() == 0.0);\n+        assertTrue(\"variance should be zero (n = 1)\", \n+                u.getVariance() == 0.0);\n+\n+        /* n=2 */               \n+        u.addValue(twoF);\n+        assertTrue(\"Std should not be zero (n = 2)\", \n+                u.getStandardDeviation() != 0.0);\n+        assertTrue(\"variance should not be zero (n = 2)\", \n+                u.getVariance() != 0.0);\n+\n+    }\n+\n+    public void testProductAndGeometricMean() throws Exception {\n+        SummaryStatistics u = createSummaryStatistics();\n+        u.addValue( 1.0 );\n+        u.addValue( 2.0 );\n+        u.addValue( 3.0 );\n+        u.addValue( 4.0 );\n+\n+        assertEquals( \"Geometric mean not expected\", 2.213364, \n+                u.getGeometricMean(), 0.00001 );\n+    }\n+\n+    public void testNaNContracts() {\n+        SummaryStatistics u = createSummaryStatistics();\n+        assertTrue(\"mean not NaN\",Double.isNaN(u.getMean())); \n+        assertTrue(\"min not NaN\",Double.isNaN(u.getMin())); \n+        assertTrue(\"std dev not NaN\",Double.isNaN(u.getStandardDeviation())); \n+        assertTrue(\"var not NaN\",Double.isNaN(u.getVariance())); \n+        assertTrue(\"geom mean not NaN\",Double.isNaN(u.getGeometricMean()));\n+\n+        u.addValue(1.0);\n+\n+        assertEquals( \"mean not expected\", 1.0, \n+                u.getMean(), Double.MIN_VALUE);\n+        assertEquals( \"variance not expected\", 0.0, \n+                u.getVariance(), Double.MIN_VALUE);\n+        assertEquals( \"geometric mean not expected\", 1.0, \n+                u.getGeometricMean(), Double.MIN_VALUE);\n+\n+        u.addValue(-1.0);\n+\n+        assertTrue(\"geom mean not NaN\",Double.isNaN(u.getGeometricMean()));\n+\n+        u.addValue(0.0);\n+\n+        assertTrue(\"geom mean not NaN\",Double.isNaN(u.getGeometricMean()));\n+\n+        //FiXME: test all other NaN contract specs\n+    }\n+\n+    public void testGetSummary() {\n+        SummaryStatistics u = createSummaryStatistics();\n+        StatisticalSummary summary = u.getSummary();\n+        verifySummary(u, summary);\n+        u.addValue(1d);\n+        summary = u.getSummary();\n+        verifySummary(u, summary);\n+        u.addValue(2d);\n+        summary = u.getSummary();\n+        verifySummary(u, summary);\n+        u.addValue(2d);\n+        summary = u.getSummary();\n+        verifySummary(u, summary);     \n+    }\n+\n+    public void testSerialization() {\n+        SummaryStatistics u = createSummaryStatistics();\n+        // Empty test\n+        TestUtils.checkSerializedEquality(u);\n+        SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);\n+        StatisticalSummary summary = s.getSummary();\n+        verifySummary(u, summary);\n+\n+        // Add some data\n+        u.addValue(2d);\n+        u.addValue(1d);\n+        u.addValue(3d);\n+        u.addValue(4d);\n+        u.addValue(5d);\n+\n+        // Test again\n+        TestUtils.checkSerializedEquality(u);\n+        s = (SummaryStatistics) TestUtils.serializeAndRecover(u);\n+        summary = s.getSummary();\n+        verifySummary(u, summary);\n+\n+    }\n+\n+    public void testEqualsAndHashCode() {\n+        SummaryStatistics u = createSummaryStatistics();\n+        SummaryStatistics t = null;\n+        int emptyHash = u.hashCode();\n+        assertTrue(\"reflexive\", u.equals(u));\n+        assertFalse(\"non-null compared to null\", u.equals(t));\n+        assertFalse(\"wrong type\", u.equals(Double.valueOf(0)));\n+        t = createSummaryStatistics();\n+        assertTrue(\"empty instances should be equal\", t.equals(u));\n+        assertTrue(\"empty instances should be equal\", u.equals(t));\n+        assertEquals(\"empty hash code\", emptyHash, t.hashCode());\n+\n+        // Add some data to u\n+        u.addValue(2d);\n+        u.addValue(1d);\n+        u.addValue(3d);\n+        u.addValue(4d);\n+        assertFalse(\"different n's should make instances not equal\", t.equals(u));\n+        assertFalse(\"different n's should make instances not equal\", u.equals(t));\n+        assertTrue(\"different n's should make hashcodes different\", \n+                u.hashCode() != t.hashCode());\n+\n+        //Add data in same order to t\n+        t.addValue(2d);\n+        t.addValue(1d);\n+        t.addValue(3d);\n+        t.addValue(4d);\n+        assertTrue(\"summaries based on same data should be equal\", t.equals(u));\n+        assertTrue(\"summaries based on same data should be equal\", u.equals(t));\n+        assertEquals(\"summaries based on same data should have same hashcodes\", \n+                u.hashCode(), t.hashCode());   \n+\n+        // Clear and make sure summaries are indistinguishable from empty summary\n+        u.clear();\n+        t.clear();\n+        assertTrue(\"empty instances should be equal\", t.equals(u));\n+        assertTrue(\"empty instances should be equal\", u.equals(t));\n+        assertEquals(\"empty hash code\", emptyHash, t.hashCode());\n+        assertEquals(\"empty hash code\", emptyHash, u.hashCode());\n+    }\n     \n+    public void testCopy() throws Exception {\n+        SummaryStatistics u = createSummaryStatistics();\n+        u.addValue(2d);\n+        u.addValue(1d);\n+        u.addValue(3d);\n+        u.addValue(4d);\n+        SummaryStatistics v = new SummaryStatistics(u);\n+        assertEquals(u, v);\n+        assertEquals(v, u);\n+        assertTrue(v.geoMean == v.getGeoMeanImpl());\n+        assertTrue(v.mean == v.getMeanImpl());\n+        assertTrue(v.min == v.getMinImpl());\n+        assertTrue(v.max == v.getMaxImpl());\n+        assertTrue(v.sum == v.getSumImpl());\n+        assertTrue(v.sumsq == v.getSumsqImpl());\n+        assertTrue(v.sumLog == v.getSumLogImpl());\n+        assertTrue(v.variance == v.getVarianceImpl());\n+        \n+        // Make sure both behave the same with additional values added\n+        u.addValue(7d);\n+        u.addValue(9d);\n+        u.addValue(11d);\n+        u.addValue(23d);\n+        v.addValue(7d);\n+        v.addValue(9d);\n+        v.addValue(11d);\n+        v.addValue(23d);\n+        assertEquals(u, v);\n+        assertEquals(v, u);\n+        \n+        // Check implementation pointers are preserved\n+        u.clear();\n+        u.setSumImpl(new Sum());\n+        SummaryStatistics.copy(u,v);\n+        assertEquals(u.sum, v.sum);\n+        assertEquals(u.getSumImpl(), v.getSumImpl());\n+        \n+    }\n+\n+    private void verifySummary(SummaryStatistics u, StatisticalSummary s) {\n+        assertEquals(\"N\",s.getN(),u.getN());\n+        TestUtils.assertEquals(\"sum\",s.getSum(),u.getSum(),tolerance);\n+        TestUtils.assertEquals(\"var\",s.getVariance(),u.getVariance(),tolerance);\n+        TestUtils.assertEquals(\"std\",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);\n+        TestUtils.assertEquals(\"mean\",s.getMean(),u.getMean(),tolerance);\n+        TestUtils.assertEquals(\"min\",s.getMin(),u.getMin(),tolerance);\n+        TestUtils.assertEquals(\"max\",s.getMax(),u.getMax(),tolerance);   \n+    }\n+\n     public void testSetterInjection() throws Exception {\n         SummaryStatistics u = createSummaryStatistics();\n         u.setMeanImpl(new Sum());\n--- a/src/test/org/apache/commons/math/stat/descriptive/SynchronizedDescriptiveStatisticsTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/SynchronizedDescriptiveStatisticsTest.java\n  * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n  *          2007) $\n  */\n-public final class SynchronizedDescriptiveStatisticsTest extends DescriptiveStatisticsAbstractTest {\n+public final class SynchronizedDescriptiveStatisticsTest extends DescriptiveStatisticsTest {\n \n     public SynchronizedDescriptiveStatisticsTest(String name) {\n         super(name);\n--- a/src/test/org/apache/commons/math/stat/descriptive/SynchronizedSummaryStatisticsTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/SynchronizedSummaryStatisticsTest.java\n \n /**\n  * Test cases for the {@link SynchronizedSummaryStatisticsTest} class.\n- * @version $Revision: 592121 $ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n+ * @version $Revision$ $Date: 2007-08-16 15:36:33 -0500 (Thu, 16 Aug\n  *          2007) $\n  */\n-public final class SynchronizedSummaryStatisticsTest extends SummaryStatisticsAbstractTest {\n+public final class SynchronizedSummaryStatisticsTest extends SummaryStatisticsTest {\n \n     public SynchronizedSummaryStatisticsTest(String name) {\n         super(name);\n--- a/src/test/org/apache/commons/math/stat/descriptive/UnivariateStatisticAbstractTest.java\n+++ b/src/test/org/apache/commons/math/stat/descriptive/UnivariateStatisticAbstractTest.java\n             getTolerance());\n     }\n     \n+    public void testCopy() throws Exception {\n+        UnivariateStatistic original = getUnivariateStatistic();\n+        UnivariateStatistic copy = original.copy();\n+        assertEquals(\n+                expectedValue(),\n+                copy.evaluate(testArray),\n+                getTolerance());\n+    }\n+    \n }\n--- a/src/test/org/apache/commons/math/stat/inference/OneWayAnovaTest.java\n+++ b/src/test/org/apache/commons/math/stat/inference/OneWayAnovaTest.java\n \n     protected OneWayAnova testStatistic = new OneWayAnovaImpl();\n     \n-    private char[] wrongArray = { 'a', 'b', 'c' };\n     private double[] emptyArray = {};\n \n     private double[] classA =\n \n     public void testAnovaFValue() throws Exception {\n         // Target comparison values computed using R version 2.6.0 (Linux version)\n-        List threeClasses = new ArrayList();\n+        List<double[]> threeClasses = new ArrayList<double[]>();\n         threeClasses.add(classA);\n         threeClasses.add(classB);\n         threeClasses.add(classC);\n         assertEquals(\"ANOVA F-value\",  24.67361709460624,\n                  testStatistic.anovaFValue(threeClasses), 1E-12);\n \n-        List twoClasses = new ArrayList();\n+        List<double[]> twoClasses = new ArrayList<double[]>();\n         twoClasses.add(classA);\n         twoClasses.add(classB);\n         \n         assertEquals(\"ANOVA F-value\",  0.0150579150579,\n                  testStatistic.anovaFValue(twoClasses), 1E-12);\n \n-        // now try some input hashes which should fail\n-        List wrongContents = new ArrayList();\n-        wrongContents.add(classC);\n-        wrongContents.add(wrongArray);\n-        try {\n-            testStatistic.anovaFValue(wrongContents);\n-            fail(\"non double[] hash value for key classX, IllegalArgumentException expected\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n-        }  \n-\n-        List emptyContents = new ArrayList();\n+        List<double[]> emptyContents = new ArrayList<double[]>();\n         emptyContents.add(emptyArray);\n         emptyContents.add(classC);\n         try {\n             // expected\n         }  \n \n-        List tooFew = new ArrayList();\n+        List<double[]> tooFew = new ArrayList<double[]>();\n         tooFew.add(classA);\n         try {\n             testStatistic.anovaFValue(tooFew);\n \n     public void testAnovaPValue() throws Exception {\n         // Target comparison values computed using R version 2.6.0 (Linux version)\n-        List threeClasses = new ArrayList();\n+        List<double[]> threeClasses = new ArrayList<double[]>();\n         threeClasses.add(classA);\n         threeClasses.add(classB);\n         threeClasses.add(classC);\n         assertEquals(\"ANOVA P-value\", 6.959446E-06,\n                  testStatistic.anovaPValue(threeClasses), 1E-12);\n \n-        List twoClasses = new ArrayList();\n+        List<double[]> twoClasses = new ArrayList<double[]>();\n         twoClasses.add(classA);\n         twoClasses.add(classB);\n         \n \n     public void testAnovaTest() throws Exception {\n         // Target comparison values computed using R version 2.3.1 (Linux version)\n-        List threeClasses = new ArrayList();\n+        List<double[]> threeClasses = new ArrayList<double[]>();\n         threeClasses.add(classA);\n         threeClasses.add(classB);\n         threeClasses.add(classC);\n \n         assertTrue(\"ANOVA Test P<0.01\", testStatistic.anovaTest(threeClasses, 0.01));\n \n-        List twoClasses = new ArrayList();\n+        List<double[]> twoClasses = new ArrayList<double[]>();\n         twoClasses.add(classA);\n         twoClasses.add(classB);\n         \n--- a/src/test/org/apache/commons/math/stat/inference/TestUtilsTest.java\n+++ b/src/test/org/apache/commons/math/stat/inference/TestUtilsTest.java\n     private double[] classC =\n       {110.0, 115.0, 111.0, 117.0, 128.0};\n     \n-    private List classes = new ArrayList();\n+    private List<double[]> classes = new ArrayList<double[]>();\n     private OneWayAnova oneWayAnova = new OneWayAnovaImpl();\n     \n     public void testOneWayAnovaUtils() throws Exception {\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/regression/AbstractMultipleLinearRegressionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.regression;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+\n+public abstract class AbstractMultipleLinearRegressionTest {\n+\n+    protected MultipleLinearRegression regression;\n+\n+    @Before\n+    public void setUp(){\n+        regression = createRegression();\n+    }\n+\n+    protected abstract MultipleLinearRegression createRegression();\n+    \n+    protected abstract int getNumberOfRegressors();\n+    \n+    protected abstract int getSampleSize();\n+\n+    @Test\n+    public void canEstimateRegressionParameters(){\n+        double[] beta = regression.estimateRegressionParameters();        \n+        assertEquals(getNumberOfRegressors(), beta.length);\n+    }\n+\n+    @Test\n+    public void canEstimateResiduals(){\n+        double[] e = regression.estimateResiduals();\n+        assertEquals(getSampleSize(), e.length);\n+    }\n+    \n+    @Test\n+    public void canEstimateRegressionParametersVariance(){\n+        double[][] variance = regression.estimateRegressionParametersVariance();\n+        assertEquals(getNumberOfRegressors(), variance.length);\n+    }\n+\n+    @Test\n+    public void canEstimateRegressandVariance(){\n+        if (getSampleSize() > getNumberOfRegressors()) {\n+            double variance = regression.estimateRegressandVariance();\n+            assertTrue(variance > 0.0);\n+        }\n+    }   \n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/regression/GLSMultipleLinearRegressionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.regression;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class GLSMultipleLinearRegressionTest extends AbstractMultipleLinearRegressionTest {\n+\n+    private double[] y;\n+    private double[][] x;\n+    private double[][] omega;\n+\n+    @Before\n+    public void setUp(){\n+        y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};\n+        x = new double[6][];\n+        x[0] = new double[]{1.0, 0, 0, 0, 0, 0};\n+        x[1] = new double[]{1.0, 2.0, 0, 0, 0, 0};\n+        x[2] = new double[]{1.0, 0, 3.0, 0, 0, 0};\n+        x[3] = new double[]{1.0, 0, 0, 4.0, 0, 0};\n+        x[4] = new double[]{1.0, 0, 0, 0, 5.0, 0};\n+        x[5] = new double[]{1.0, 0, 0, 0, 0, 6.0};\n+        omega = new double[6][];\n+        omega[0] = new double[]{1.0, 0, 0, 0, 0, 0};\n+        omega[1] = new double[]{0, 2.0, 0, 0, 0, 0};\n+        omega[2] = new double[]{0, 0, 3.0, 0, 0, 0};\n+        omega[3] = new double[]{0, 0, 0, 4.0, 0, 0};\n+        omega[4] = new double[]{0, 0, 0, 0, 5.0, 0};\n+        omega[5] = new double[]{0, 0, 0, 0, 0, 6.0};\n+        super.setUp();\n+    }\n+   \n+    @Test(expected=IllegalArgumentException.class)\n+    public void cannotAddXSampleData() {\n+        createRegression().newSampleData(new double[]{}, null, null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void cannotAddNullYSampleData() {\n+        createRegression().newSampleData(null, new double[][]{}, null);\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void cannotAddSampleDataWithSizeMismatch() {\n+        double[] y = new double[]{1.0, 2.0};\n+        double[][] x = new double[1][];\n+        x[0] = new double[]{1.0, 0};\n+        createRegression().newSampleData(y, x, null);\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void cannotAddNullCovarianceData() {\n+        createRegression().newSampleData(new double[]{}, new double[][]{}, null);\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void cannotAddCovarianceDataWithSampleSizeMismatch() {\n+        double[] y = new double[]{1.0, 2.0};\n+        double[][] x = new double[2][];\n+        x[0] = new double[]{1.0, 0};\n+        x[1] = new double[]{0, 1.0};\n+        double[][] omega = new double[1][];\n+        omega[0] = new double[]{1.0, 0};\n+        createRegression().newSampleData(y, x, omega);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void cannotAddCovarianceDataThatIsNotSquare() {\n+        double[] y = new double[]{1.0, 2.0};\n+        double[][] x = new double[2][];\n+        x[0] = new double[]{1.0, 0};\n+        x[1] = new double[]{0, 1.0};\n+        double[][] omega = new double[3][];\n+        omega[0] = new double[]{1.0, 0};\n+        omega[1] = new double[]{0, 1.0};\n+        omega[2] = new double[]{0, 2.0};\n+        createRegression().newSampleData(y, x, omega);\n+    }\n+\n+    protected GLSMultipleLinearRegression createRegression() {\n+        GLSMultipleLinearRegression regression = new GLSMultipleLinearRegression();\n+        regression.newSampleData(y, x, omega);\n+        return regression;\n+    }\n+\n+    protected int getNumberOfRegressors() {\n+        return x[0].length;\n+    }\n+\n+    protected int getSampleSize() {\n+        return y.length;\n+    }\n+        \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/regression/OLSMultipleLinearRegressionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.regression;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class OLSMultipleLinearRegressionTest extends AbstractMultipleLinearRegressionTest {\n+\n+    private double[] y;\n+    private double[][] x;\n+    \n+    @Before\n+    public void setUp(){\n+        y = new double[]{11.0, 12.0, 13.0, 14.0, 15.0, 16.0};\n+        x = new double[6][];\n+        x[0] = new double[]{1.0, 0, 0, 0, 0, 0};\n+        x[1] = new double[]{1.0, 2.0, 0, 0, 0, 0};\n+        x[2] = new double[]{1.0, 0, 3.0, 0, 0, 0};\n+        x[3] = new double[]{1.0, 0, 0, 4.0, 0, 0};\n+        x[4] = new double[]{1.0, 0, 0, 0, 5.0, 0};\n+        x[5] = new double[]{1.0, 0, 0, 0, 0, 6.0};\n+        super.setUp();\n+    }\n+\n+    protected OLSMultipleLinearRegression createRegression() {\n+        OLSMultipleLinearRegression regression = new OLSMultipleLinearRegression();\n+        regression.newSampleData(y, x);\n+        return regression;\n+    }\n+\n+    protected int getNumberOfRegressors() {\n+        return x[0].length;\n+    }\n+\n+    protected int getSampleSize() {\n+        return y.length;\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void cannotAddXSampleData() {\n+        createRegression().newSampleData(new double[]{}, null);\n+    }\n+\n+    @Test(expected=IllegalArgumentException.class)\n+    public void cannotAddNullYSampleData() {\n+        createRegression().newSampleData(null, new double[][]{});\n+    }\n+    \n+    @Test(expected=IllegalArgumentException.class)\n+    public void cannotAddSampleDataWithSizeMismatch() {\n+        double[] y = new double[]{1.0, 2.0};\n+        double[][] x = new double[1][];\n+        x[0] = new double[]{1.0, 0};\n+        createRegression().newSampleData(y, x);\n+    }\n+    \n+    @Test\n+    public void testPerfectFit() {\n+        double[] betaHat = regression.estimateRegressionParameters();\n+        TestUtils.assertEquals(betaHat, \n+          new double[]{11.0,0.5,0.666666666666667,0.75,0.8,0.8333333333333333},\n+                1e-12);\n+        double[] residuals = regression.estimateResiduals();\n+        TestUtils.assertEquals(residuals, new double[]{0d,0d,0d,0d,0d,0d},\n+                      1e-12);\n+        double[][] errors = regression.estimateRegressionParametersVariance();\n+        // TODO: translate this into standard error vector and check\n+    }\n+    \n+    \n+    /**\n+     * Test Longley dataset against certified values provided by NIST.\n+     * Data Source: J. Longley (1967) \"An Appraisal of Least Squares\n+     * Programs for the Electronic Computer from the Point of View of the User\"\n+     * Journal of the American Statistical Association, vol. 62. September,\n+     * pp. 819-841.\n+     * \n+     * Certified values (and data) are from NIST:\n+     * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Longley.dat\n+     */\n+    @Test\n+    public void testLongly() {\n+        // Y values are first, then independent vars\n+        // Each row is one observation\n+        double[] design = new double[] {\n+            60323,83.0,234289,2356,1590,107608,1947,\n+            61122,88.5,259426,2325,1456,108632,1948,\n+            60171,88.2,258054,3682,1616,109773,1949,\n+            61187,89.5,284599,3351,1650,110929,1950,\n+            63221,96.2,328975,2099,3099,112075,1951,\n+            63639,98.1,346999,1932,3594,113270,1952,\n+            64989,99.0,365385,1870,3547,115094,1953,\n+            63761,100.0,363112,3578,3350,116219,1954,\n+            66019,101.2,397469,2904,3048,117388,1955,\n+            67857,104.6,419180,2822,2857,118734,1956,\n+            68169,108.4,442769,2936,2798,120445,1957,\n+            66513,110.8,444546,4681,2637,121950,1958,\n+            68655,112.6,482704,3813,2552,123366,1959,\n+            69564,114.2,502601,3931,2514,125368,1960,\n+            69331,115.7,518173,4806,2572,127852,1961,\n+            70551,116.9,554894,4007,2827,130081,1962\n+        };\n+        \n+        // Transform to Y and X required by interface\n+        int nobs = 16;\n+        int nvars = 6;\n+        \n+        // Estimate the model\n+        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();\n+        model.newSampleData(design, nobs, nvars);\n+        \n+        // Check expected beta values from NIST\n+        double[] betaHat = model.estimateRegressionParameters();\n+        TestUtils.assertEquals(betaHat, \n+          new double[]{-3482258.63459582, 15.0618722713733,\n+                -0.358191792925910E-01,-2.02022980381683,\n+                -1.03322686717359,-0.511041056535807E-01,\n+                 1829.15146461355}, 1E-8); // \n+        \n+        // Check expected residuals from R\n+        double[] residuals = model.estimateResiduals();\n+        TestUtils.assertEquals(residuals, new double[]{\n+                267.340029759711,-94.0139423988359,46.28716775752924,\n+                -410.114621930906,309.7145907602313,-249.3112153297231,\n+                -164.0489563956039,-13.18035686637081,14.30477260005235,\n+                 455.394094551857,-17.26892711483297,-39.0550425226967,\n+                -155.5499735953195,-85.6713080421283,341.9315139607727,\n+                -206.7578251937366},\n+                      1E-8);\n+        \n+        // Check standard errors from NIST\n+        double[][] errors = model.estimateRegressionParametersVariance();\n+        //TODO:  translate this into std error vector and check  \n+    }\n+    \n+    /**\n+     * Test R Swiss fertility dataset against R.\n+     * Data Source: R datasets package\n+     */\n+    @Test\n+    public void testSwissFertility() {\n+        double[] design = new double[] {\n+            80.2,17.0,15,12,9.96,\n+            83.1,45.1,6,9,84.84,\n+            92.5,39.7,5,5,93.40,\n+            85.8,36.5,12,7,33.77,\n+            76.9,43.5,17,15,5.16,\n+            76.1,35.3,9,7,90.57,\n+            83.8,70.2,16,7,92.85,\n+            92.4,67.8,14,8,97.16,\n+            82.4,53.3,12,7,97.67,\n+            82.9,45.2,16,13,91.38,\n+            87.1,64.5,14,6,98.61,\n+            64.1,62.0,21,12,8.52,\n+            66.9,67.5,14,7,2.27,\n+            68.9,60.7,19,12,4.43,\n+            61.7,69.3,22,5,2.82,\n+            68.3,72.6,18,2,24.20,\n+            71.7,34.0,17,8,3.30,\n+            55.7,19.4,26,28,12.11,\n+            54.3,15.2,31,20,2.15,\n+            65.1,73.0,19,9,2.84,\n+            65.5,59.8,22,10,5.23,\n+            65.0,55.1,14,3,4.52,\n+            56.6,50.9,22,12,15.14,\n+            57.4,54.1,20,6,4.20,\n+            72.5,71.2,12,1,2.40,\n+            74.2,58.1,14,8,5.23,\n+            72.0,63.5,6,3,2.56,\n+            60.5,60.8,16,10,7.72,\n+            58.3,26.8,25,19,18.46,\n+            65.4,49.5,15,8,6.10,\n+            75.5,85.9,3,2,99.71,\n+            69.3,84.9,7,6,99.68,\n+            77.3,89.7,5,2,100.00,\n+            70.5,78.2,12,6,98.96,\n+            79.4,64.9,7,3,98.22,\n+            65.0,75.9,9,9,99.06,\n+            92.2,84.6,3,3,99.46,\n+            79.3,63.1,13,13,96.83,\n+            70.4,38.4,26,12,5.62,\n+            65.7,7.7,29,11,13.79,\n+            72.7,16.7,22,13,11.22,\n+            64.4,17.6,35,32,16.92,\n+            77.6,37.6,15,7,4.97,\n+            67.6,18.7,25,7,8.65,\n+            35.0,1.2,37,53,42.34,\n+            44.7,46.6,16,29,50.43,\n+            42.8,27.7,22,29,58.33\n+        };\n+\n+        // Transform to Y and X required by interface\n+        int nobs = 47;\n+        int nvars = 4;\n+\n+        // Estimate the model\n+        OLSMultipleLinearRegression model = new OLSMultipleLinearRegression();\n+        model.newSampleData(design, nobs, nvars);\n+\n+        // Check expected beta values from R\n+        double[] betaHat = model.estimateRegressionParameters();\n+        TestUtils.assertEquals(betaHat, \n+                new double[]{91.05542390271397,\n+                -0.22064551045715,\n+                -0.26058239824328,\n+                -0.96161238456030,\n+                 0.12441843147162}, 1E-12);\n+\n+        // Check expected residuals from R\n+        double[] residuals = model.estimateResiduals();\n+        TestUtils.assertEquals(residuals, new double[]{\n+                7.1044267859730512,1.6580347433531366,\n+                4.6944952770029644,8.4548022690166160,13.6547432343186212,\n+               -9.3586864458500774,7.5822446330520386,15.5568995563859289,\n+                0.8113090736598980,7.1186762732484308,7.4251378771228724,\n+                2.6761316873234109,0.8351584810309354,7.1769991119615177,\n+               -3.8746753206299553,-3.1337779476387251,-0.1412575244091504,\n+                1.1186809170469780,-6.3588097346816594,3.4039270429434074,\n+                2.3374058329820175,-7.9272368576900503,-7.8361010968497959,\n+               -11.2597369269357070,0.9445333697827101,6.6544245101380328,\n+               -0.9146136301118665,-4.3152449403848570,-4.3536932047009183,\n+               -3.8907885169304661,-6.3027643926302188,-7.8308982189289091,\n+               -3.1792280015332750,-6.7167298771158226,-4.8469946718041754,\n+               -10.6335664353633685,11.1031134362036958,6.0084032641811733,\n+                5.4326230830188482,-7.2375578629692230,2.1671550814448222,\n+                15.0147574652763112,4.8625103516321015,-7.1597256413907706,\n+                -0.4515205619767598,-10.2916870903837587,-15.7812984571900063},\n+                1E-12);  \n+    }\n+}\n--- a/src/test/org/apache/commons/math/stat/regression/SimpleRegressionTest.java\n+++ b/src/test/org/apache/commons/math/stat/regression/SimpleRegressionTest.java\n             {35.5, 8.8 }, {18.6, 4.9 }, {15.3, 4.5 }, {7.9, 2.5 }, {0.0, 1.1 }\n     };\n     \n+    /*\n+     * Points to remove in the remove tests\n+     */\n+    private double[][] removeSingle = {infData[1]};\n+    private double[][] removeMultiple = { infData[1], infData[2] };\n+    private double removeX = infData[0][0];\n+    private double removeY = infData[0][1];\n+    \n+            \n     /*\n      * Data with bad linear fit\n      */\n         }\n         assertTrue(reg.getSumSquaredErrors() >= 0.0);\n     } \n+    \n+    // Test remove X,Y (single observation)\n+    public void testRemoveXY() throws Exception {\n+        // Create regression with inference data then remove to test\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.addData(infData);\n+        regression.removeData(removeX, removeY);\n+        regression.addData(removeX, removeY);\n+        // Use the inference assertions to make sure that everything worked\n+        assertEquals(\"slope std err\", 0.011448491,\n+                regression.getSlopeStdErr(), 1E-10);\n+        assertEquals(\"std err intercept\", 0.286036932,\n+                regression.getInterceptStdErr(),1E-8);\n+        assertEquals(\"significance\", 4.596e-07,\n+                regression.getSignificance(),1E-8);    \n+        assertEquals(\"slope conf interval half-width\", 0.0270713794287, \n+                regression.getSlopeConfidenceInterval(),1E-8);\n+     }\n+    \n+    \n+    // Test remove single observation in array\n+    public void testRemoveSingle() throws Exception {\n+        // Create regression with inference data then remove to test\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.addData(infData);\n+        regression.removeData(removeSingle);\n+        regression.addData(removeSingle);\n+        // Use the inference assertions to make sure that everything worked\n+        assertEquals(\"slope std err\", 0.011448491,\n+                regression.getSlopeStdErr(), 1E-10);\n+        assertEquals(\"std err intercept\", 0.286036932,\n+                regression.getInterceptStdErr(),1E-8);\n+        assertEquals(\"significance\", 4.596e-07,\n+                regression.getSignificance(),1E-8);    \n+        assertEquals(\"slope conf interval half-width\", 0.0270713794287, \n+                regression.getSlopeConfidenceInterval(),1E-8);\n+     }\n+    \n+    // Test remove multiple observations\n+    public void testRemoveMultiple() throws Exception {\n+        // Create regression with inference data then remove to test\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.addData(infData);\n+        regression.removeData(removeMultiple);\n+        regression.addData(removeMultiple);\n+        // Use the inference assertions to make sure that everything worked\n+        assertEquals(\"slope std err\", 0.011448491,\n+                regression.getSlopeStdErr(), 1E-10);\n+        assertEquals(\"std err intercept\", 0.286036932,\n+                regression.getInterceptStdErr(),1E-8);\n+        assertEquals(\"significance\", 4.596e-07,\n+                regression.getSignificance(),1E-8);    \n+        assertEquals(\"slope conf interval half-width\", 0.0270713794287, \n+                regression.getSlopeConfidenceInterval(),1E-8);\n+     }\n+    \n+    // Remove observation when empty\n+    public void testRemoveObsFromEmpty() {\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.removeData(removeX, removeY);\n+        assertEquals(regression.getN(), 0);\n+    }\n+    \n+    // Remove single observation to empty\n+    public void testRemoveObsFromSingle() {\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.addData(removeX, removeY);\n+        regression.removeData(removeX, removeY);\n+        assertEquals(regression.getN(), 0);\n+    }\n+    \n+    // Remove multiple observations to empty\n+    public void testRemoveMultipleToEmpty() {\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.addData(removeMultiple);\n+        regression.removeData(removeMultiple);\n+        assertEquals(regression.getN(), 0);\n+    }\n+    \n+    // Remove multiple observations past empty (i.e. size of array > n)\n+    public void testRemoveMultiplePastEmpty() {\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.addData(removeX, removeY);\n+        regression.removeData(removeMultiple);\n+        assertEquals(regression.getN(), 0);\n+    }\n }\n--- a/src/test/org/apache/commons/math/util/DefaultTransformerTest.java\n+++ b/src/test/org/apache/commons/math/util/DefaultTransformerTest.java\n      */\n     public void testTransformDouble() throws Exception {\n         double expected = 1.0;\n-        Double input = new Double(expected);\n+        Double input = Double.valueOf(expected);\n         DefaultTransformer t = new DefaultTransformer();\n         assertEquals(expected, t.transform(input), 1.0e-4);\n     }\n      */\n     public void testTransformInteger() throws Exception {\n         double expected = 1.0;\n-        Integer input = new Integer(1);\n+        Integer input = Integer.valueOf(1);\n         DefaultTransformer t = new DefaultTransformer();\n         assertEquals(expected, t.transform(input), 1.0e-4);\n     }        \n--- a/src/test/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/org/apache/commons/math/util/MathUtilsTest.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.apache.commons.math.random.RandomDataImpl;\n import org.apache.commons.math.TestUtils;\n \n /**\n         assertFalse(MathUtils.hash(new double[] { 1d }) ==\n                     MathUtils.hash(new double[] { 1d, 1d }));\n     }\n+    \n+    /**\n+     * Make sure that permuted arrays do not hash to the same value.\n+     */\n+    public void testPermutedArrayHash() {\n+        double[] original = new double[10];\n+        double[] permuted = new double[10];\n+        RandomDataImpl random = new RandomDataImpl();\n+        \n+        // Generate 10 distinct random values\n+        for (int i = 0; i < 10; i++) {\n+            original[i] = random.nextUniform((double)i + 0.5, (double)i + 0.75);\n+        }\n+        \n+        // Generate a random permutation, making sure it is not the identity\n+        boolean isIdentity = true;\n+        do {\n+            int[] permutation = random.nextPermutation(10, 10);\n+            for (int i = 0; i < 10; i++) {\n+                if (i != permutation[i]) {\n+                    isIdentity = false;\n+                }\n+                permuted[i] = original[permutation[i]];\n+            }\n+        } while (isIdentity);\n+        \n+        // Verify that permuted array has different hash\n+        assertFalse(MathUtils.hash(original) == MathUtils.hash(permuted));\n+    }\n \n     public void testIndicatorByte() {\n         assertEquals((byte)1, MathUtils.indicator((byte)2));\n         assertEquals(0, MathUtils.nextAfter(-Double.MIN_VALUE, 1), 0);\n     }\n \n+    public void testScalb() {\n+        assertEquals( 0.0, MathUtils.scalb(0.0, 5), 1.0e-15);\n+        assertEquals(32.0, MathUtils.scalb(1.0, 5), 1.0e-15);\n+        assertEquals(1.0 / 32.0, MathUtils.scalb(1.0,  -5), 1.0e-15);\n+        assertEquals(Math.PI, MathUtils.scalb(Math.PI, 0), 1.0e-15);\n+        assertTrue(Double.isInfinite(MathUtils.scalb(Double.POSITIVE_INFINITY, 1)));\n+        assertTrue(Double.isInfinite(MathUtils.scalb(Double.NEGATIVE_INFINITY, 1)));\n+        assertTrue(Double.isNaN(MathUtils.scalb(Double.NaN, 1)));\n+    }\n+\n     public void testNormalizeAngle() {\n         for (double a = -15.0; a <= 15.0; a += 0.1) {\n             for (double b = -15.0; b <= 15.0; b += 0.2) {\n--- a/src/test/org/apache/commons/math/util/ResizableDoubleArrayTest.java\n+++ b/src/test/org/apache/commons/math/util/ResizableDoubleArrayTest.java\n             // expected\n         }\n         \n+        // Copy constructor\n+        testDa = new ResizableDoubleArray(2, 2.0f, 3.0f, \n+                ResizableDoubleArray.ADDITIVE_MODE);\n+        testDa.addElement(2.0);\n+        testDa.addElement(3.2);\n+        ResizableDoubleArray copyDa = new ResizableDoubleArray(testDa);\n+        assertEquals(copyDa, testDa);\n+        assertEquals(testDa, copyDa);   \n     }\n     \n     \n         \n         ((ResizableDoubleArray)da).discardFrontElements(5);\n         assertEquals( \"Number of elements should be 6\", 6, da.getNumElements());\n+\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        assertEquals( \"Number of elements should be 10\", 10, da.getNumElements());\n+\n+        ((ResizableDoubleArray)da).discardMostRecentElements(2);\n+        assertEquals( \"Number of elements should be 8\", 8, da.getNumElements());\n         \n         try {\n             ((ResizableDoubleArray)da).discardFrontElements(-1);\n             fail( \"Trying to discard a negative number of element is not allowed\");\n         } catch( Exception e ){\n         }\n-        \n+\n+        try {\n+            ((ResizableDoubleArray)da).discardMostRecentElements(-1);\n+            fail( \"Trying to discard a negative number of element is not allowed\");\n+        } catch( Exception e ){\n+        }\n+\n         try {\n             ((ResizableDoubleArray)da).discardFrontElements( 10000 );\n             fail( \"You can't discard more elements than the array contains\");\n         } catch( Exception e ){\n         }\n+\n+        try {\n+            ((ResizableDoubleArray)da).discardMostRecentElements( 10000 );\n+            fail( \"You can't discard more elements than the array contains\");\n+        } catch( Exception e ){\n+        }\n+\n+    }\n+\n+    public void testSubstitute() {\n+    \n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        da.addElement(2.0);\n+        assertEquals( \"Number of elements should be 11\", 11, da.getNumElements());\n+        \n+        ((ResizableDoubleArray)da).substituteMostRecentElement(24);\n+\n+        assertEquals( \"Number of elements should be 11\", 11, da.getNumElements());\n+\n+        try {\n+            ((ResizableDoubleArray)da).discardMostRecentElements(10);\n+        } catch( Exception e ){\n+            fail( \"Trying to discard a negative number of element is not allowed\");\n+        }\n+\n+        ((ResizableDoubleArray)da).substituteMostRecentElement(24);\n+\n+        assertEquals( \"Number of elements should be 1\", 1, da.getNumElements());\n+\n     }\n     \n     public void testMutators() {\n             // expected\n         }\n     }\n+    \n+    public void testEqualsAndHashCode() throws Exception {\n+        \n+        // Wrong type\n+        ResizableDoubleArray first = new ResizableDoubleArray();\n+        Double other = new Double(2);\n+        assertFalse(first.equals(other));\n+        \n+        // Null\n+        other = null;\n+        assertFalse(first.equals(other));\n+        \n+        // Reflexive\n+        assertTrue(first.equals(first));\n+        \n+        // Argumentless constructor\n+        ResizableDoubleArray second = new ResizableDoubleArray();\n+        verifyEquality(first, second);\n+        \n+        // Equals iff same data, same properties\n+        ResizableDoubleArray third = new ResizableDoubleArray(3, 2.0f, 2.0f);\n+        verifyInequality(third, first);\n+        ResizableDoubleArray fourth = new ResizableDoubleArray(3, 2.0f, 2.0f);\n+        ResizableDoubleArray fifth = new ResizableDoubleArray(2, 2.0f, 2.0f);\n+        verifyEquality(third, fourth);\n+        verifyInequality(third, fifth);\n+        third.addElement(4.1);\n+        third.addElement(4.2);\n+        third.addElement(4.3);\n+        fourth.addElement(4.1);\n+        fourth.addElement(4.2);\n+        fourth.addElement(4.3);\n+        verifyEquality(third, fourth);\n+        \n+        // expand\n+        fourth.addElement(4.4);\n+        verifyInequality(third, fourth);\n+        third.addElement(4.4);\n+        verifyEquality(third, fourth);\n+        fourth.addElement(4.4);\n+        verifyInequality(third, fourth);\n+        third.addElement(4.4);\n+        verifyEquality(third, fourth);\n+        fourth.addElementRolling(4.5);\n+        third.addElementRolling(4.5);\n+        verifyEquality(third, fourth);\n+        \n+        // discard\n+        third.discardFrontElements(1);\n+        verifyInequality(third, fourth);\n+        fourth.discardFrontElements(1);\n+        verifyEquality(third, fourth);\n+        \n+        // discard recent\n+        third.discardMostRecentElements(2);\n+        fourth.discardMostRecentElements(2);\n+        verifyEquality(third, fourth);\n+        \n+        // wrong order\n+        third.addElement(18);\n+        fourth.addElement(17);\n+        third.addElement(17);\n+        fourth.addElement(18);\n+        verifyInequality(third, fourth);\n+        \n+        // copy\n+        ResizableDoubleArray.copy(fourth, fifth);\n+        verifyEquality(fourth, fifth);\n+        \n+        // Copy constructor\n+        verifyEquality(fourth, new ResizableDoubleArray(fourth));\n+        \n+        // Instance copy\n+        verifyEquality(fourth, fourth.copy());   \n+             \n+    }\n+    \n+    private void verifyEquality(ResizableDoubleArray a, ResizableDoubleArray b) {\n+        assertTrue(b.equals(a));\n+        assertTrue(a.equals(b));\n+        assertEquals(a.hashCode(), b.hashCode());    \n+    }\n+    \n+    private void verifyInequality(ResizableDoubleArray a, ResizableDoubleArray b) {\n+        assertFalse(b.equals(a));\n+        assertFalse(a.equals(b));\n+        assertFalse(a.hashCode() == b.hashCode());\n+    }\n+    \n }\n--- a/src/test/org/apache/commons/math/util/TestBean.java\n+++ b/src/test/org/apache/commons/math/util/TestBean.java\n \n package org.apache.commons.math.util;\n \n+import org.apache.commons.math.MathRuntimeException;\n+\n /**\n  * @version $Revision$ $Date$\n  */\n public class TestBean {\n-    private Double x = new Double(1.0);\n+    private Double x = Double.valueOf(1.0);\n \n     private String y = \"1.0\";\n \n      * \n      */\n     public Double getZ() {\n-        throw new RuntimeException();\n+        throw new MathRuntimeException(\"?\", null);\n     }\n \n     /**\n--- a/src/test/org/apache/commons/math/distribution/PascalDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/PascalDistributionTest.java\n  * Extends IntegerDistributionAbstractTest.  See class javadoc for\n  * IntegerDistributionAbstractTest for details.\n  * \n- * @version $Revision:$ $Date:$\n+ * @version $Revision$ $Date$\n  */\n public class PascalDistributionTest extends IntegerDistributionAbstractTest {\n     \n--- a/src/test/org/apache/commons/math/random/AbstractRandomGeneratorTest.java\n+++ b/src/test/org/apache/commons/math/random/AbstractRandomGeneratorTest.java\n /**\n  * Test cases for the AbstractRandomGenerator class\n  *\n- * @version $Revision:$ $Date$\n+ * @version $Revision$ $Date$\n  */\n \n public class AbstractRandomGeneratorTest extends RandomDataTest {\n--- a/src/test/org/apache/commons/math/random/RandomAdaptorTest.java\n+++ b/src/test/org/apache/commons/math/random/RandomAdaptorTest.java\n /**\n  * Test cases for the RandomAdaptor class\n  *\n- * @version $Revision:$ $Date$\n+ * @version $Revision$ $Date$\n  */\n \n public class RandomAdaptorTest extends RandomDataTest {\n--- a/src/test/org/apache/commons/math/random/TestRandomGenerator.java\n+++ b/src/test/org/apache/commons/math/random/TestRandomGenerator.java\n  * java.util.Random instance.  Used by AbstractRandomGeneratorTest to test\n  * default implementations in AbstractRandomGenerator.\n  *\n- * @version $Revision:$ $Date$\n+ * @version $Revision$ $Date$\n  */\n public class TestRandomGenerator extends AbstractRandomGenerator {\n ", "timestamp": 1228184482, "metainfo": ""}