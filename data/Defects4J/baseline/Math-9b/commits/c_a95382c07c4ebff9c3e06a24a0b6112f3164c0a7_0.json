{"sha": "a95382c07c4ebff9c3e06a24a0b6112f3164c0a7", "log": "MATH-690 New \"copySign\" method.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     OUT_OF_RANGE(\"out of range\"), /* keep */\n     OUT_OF_RANGE_SIMPLE(\"{0} out of [{1}, {2}] range\"), /* keep */\n     OUTLINE_BOUNDARY_LOOP_OPEN(\"an outline boundary loop is open\"),\n+    OVERFLOW(\"overflow\"), /* keep */\n     OVERFLOW_IN_FRACTION(\"overflow in fraction {0}/{1}, cannot negate\"),\n     OVERFLOW_IN_ADDITION(\"overflow in addition: {0} + {1}\"),\n     OVERFLOW_IN_SUBTRACTION(\"overflow in subtraction: {0} - {1}\"),\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n     }\n \n     /**\n+     * Returns the first argument with the sign of the second argument.\n+     *\n+     * @param magnitude Magnitude of the returned value.\n+     * @param sign Sign of the returned value.\n+     * @return a value with magnitude equal to {@code magnitude} and with the\n+     * same sign as the {@code sign} argument.\n+     * @throws MathArithmeticException if {@code magnitude == Byte.MIN_VALUE}\n+     * and {@code sign >= 0}.\n+     */\n+    public static byte copySign(byte magnitude, byte sign) {\n+        if ((magnitude >= 0 && sign >= 0) ||\n+            (magnitude < 0 && sign < 0)) { // Sign is OK.\n+            return magnitude;\n+        } else if (sign >= 0 &&\n+                   magnitude == Byte.MIN_VALUE) {\n+            throw new MathArithmeticException(LocalizedFormats.OVERFLOW);\n+        } else {\n+            return (byte) -magnitude; // Flip sign.\n+        }\n+    }\n+\n+    /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n      * for int value {@code x}.\n      * <p>\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n             // Expected.\n         }\n     }\n+\n+    @Test\n+    public void testCopySignByte() {\n+        byte a = MathUtils.copySign(Byte.MIN_VALUE, (byte) -1);\n+        Assert.assertEquals(Byte.MIN_VALUE, a);\n+\n+        final byte minValuePlusOne = Byte.MIN_VALUE + (byte) 1;\n+        a = MathUtils.copySign(minValuePlusOne, (byte) 1);\n+        Assert.assertEquals(Byte.MAX_VALUE, a);\n+\n+        a = MathUtils.copySign(Byte.MAX_VALUE, (byte) -1);\n+        Assert.assertEquals(minValuePlusOne, a);\n+\n+        final byte one = 1;\n+        byte val = -2;\n+        a = MathUtils.copySign(val, one);\n+        Assert.assertEquals(-val, a);\n+\n+        final byte minusOne = -one;\n+        val = 2;\n+        a = MathUtils.copySign(val, minusOne);\n+        Assert.assertEquals(-val, a);\n+\n+        val = 0;\n+        a = MathUtils.copySign(val, minusOne);\n+        Assert.assertEquals(val, a);\n+\n+        val = 0;\n+        a = MathUtils.copySign(val, one);\n+        Assert.assertEquals(val, a);\n+    }\n+\n+    @Test(expected=MathArithmeticException.class)\n+    public void testCopySignByte2() {\n+        MathUtils.copySign(Byte.MIN_VALUE, (byte) 1);\n+    }\n }", "timestamp": 1318969842, "metainfo": ""}