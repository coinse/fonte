{"sha": "0a577c2f5993498b364570f1951d93160a5b010d", "log": "Tab police; also removed unnecessary trailing spaces  ", "commit": "\n--- a/src/test/java/org/apache/commons/math/util/FastMathTest.java\n+++ b/src/test/java/org/apache/commons/math/util/FastMathTest.java\n     public void testLog1pSpecialCases() {\n         double x;\n \n-    \tx = FastMath.log1p(-1.0);\n+        x = FastMath.log1p(-1.0);\n         if (x != Double.NEGATIVE_INFINITY)\n             throw new RuntimeException(\"Log1p of -1 should be -infinity\");\n     }\n         double maxerrulp = 0.0;\n \n         for (int i=0; i<10000; i++) {\n-            double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble(); \n+            double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();\n \n             double tst = FastMath.asin(x);\n             double ref = DfpMath.asin(field.newDfp(x)).toDouble();\n         double maxerrulp = 0.0;\n \n         for (int i=0; i<10000; i++) {\n-            double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble(); \n+            double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();\n \n             double tst = FastMath.acos(x);\n             double ref = DfpMath.acos(field.newDfp(x)).toDouble();\n      */\n     @Test\n     public void testAcosSpecialCases() {\n-    \tdouble x;\n-\n-    \tx = FastMath.acos(Double.NaN);\n-    \tif (x == x)\n-    \t\tthrow new RuntimeException(\"acos(NaN) should NaN\");\n-\n-    \tx = FastMath.acos(-1.1);\n-    \tif (x == x)\n-    \t\tthrow new RuntimeException(\"acos(-1.1) should NaN\");\n-    \t\n-    \tx = FastMath.acos(1.1);\n-    \tif (x == x)\n-    \t\tthrow new RuntimeException(\"acos(-1.1) should NaN\");\n-\n-    \tAssert.assertEquals(FastMath.acos(-1.0), FastMath.PI, Double.MIN_VALUE);\n-\n-    \tAssert.assertEquals(FastMath.acos(1.0), 0.0, Double.MIN_VALUE);\n-\n-    \tAssert.assertEquals(FastMath.acos(0.0), FastMath.PI / 2.0, Double.MIN_VALUE);\n+        double x;\n+\n+        x = FastMath.acos(Double.NaN);\n+        if (x == x)\n+            throw new RuntimeException(\"acos(NaN) should NaN\");\n+\n+        x = FastMath.acos(-1.1);\n+        if (x == x)\n+            throw new RuntimeException(\"acos(-1.1) should NaN\");\n+\n+        x = FastMath.acos(1.1);\n+        if (x == x)\n+            throw new RuntimeException(\"acos(-1.1) should NaN\");\n+\n+        Assert.assertEquals(FastMath.acos(-1.0), FastMath.PI, Double.MIN_VALUE);\n+\n+        Assert.assertEquals(FastMath.acos(1.0), 0.0, Double.MIN_VALUE);\n+\n+        Assert.assertEquals(FastMath.acos(0.0), FastMath.PI / 2.0, Double.MIN_VALUE);\n     }\n \n     /**\n      */\n     @Test\n     public void testAsinSpecialCases() {\n-    \tdouble x;\n-\n-    \tx = FastMath.asin(Double.NaN);\n-    \tif (x == x)\n-    \t\tthrow new RuntimeException(\"asin(NaN) should NaN\");\n-\n-    \tx = FastMath.asin(-1.1);\n-    \tif (x == x)\n-    \t\tthrow new RuntimeException(\"asin(-1.1) should NaN\");\n-    \t\n-    \tx = FastMath.asin(1.1);\n-    \tif (x == x)\n-    \t\tthrow new RuntimeException(\"asin(-1.1) should NaN\");\n-\n-    \tAssert.assertEquals(FastMath.asin(1.0), FastMath.PI / 2.0, Double.MIN_VALUE);\n-\n-    \tAssert.assertEquals(FastMath.asin(-1.0), -FastMath.PI / 2.0, Double.MIN_VALUE);\n-\n-    \tAssert.assertEquals(FastMath.asin(0.0), 0.0, Double.MIN_VALUE);\n+        double x;\n+\n+        x = FastMath.asin(Double.NaN);\n+        if (x == x)\n+            throw new RuntimeException(\"asin(NaN) should NaN\");\n+\n+        x = FastMath.asin(-1.1);\n+        if (x == x)\n+            throw new RuntimeException(\"asin(-1.1) should NaN\");\n+\n+        x = FastMath.asin(1.1);\n+        if (x == x)\n+            throw new RuntimeException(\"asin(-1.1) should NaN\");\n+\n+        Assert.assertEquals(FastMath.asin(1.0), FastMath.PI / 2.0, Double.MIN_VALUE);\n+\n+        Assert.assertEquals(FastMath.asin(-1.0), -FastMath.PI / 2.0, Double.MIN_VALUE);\n+\n+        Assert.assertEquals(FastMath.asin(0.0), 0.0, Double.MIN_VALUE);\n     }\n \n     private Dfp cosh(Dfp x) {\n         double maxerrulp = 0.0;\n \n         for (int i=0; i<10000; i++) {\n-            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble(); \n+            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble();\n \n             double tst = FastMath.sinh(x);\n             double ref = sinh(field.newDfp(x)).toDouble();\n \n             if (err != 0) {\n                 double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));\n-                double errulp = field.newDfp(tst).subtract(sinh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); \n-                //System.out.println(x+\"\\t\"+tst+\"\\t\"+ref+\"\\t\"+err+\"\\t\"+errulp); \n+                double errulp = field.newDfp(tst).subtract(sinh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();\n+                //System.out.println(x+\"\\t\"+tst+\"\\t\"+ref+\"\\t\"+err+\"\\t\"+errulp);\n                 maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n             }\n         }\n         double maxerrulp = 0.0;\n \n         for (int i=0; i<10000; i++) {\n-            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble(); \n+            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble();\n \n             double tst = FastMath.cosh(x);\n             double ref = cosh(field.newDfp(x)).toDouble();\n \n             if (err != 0) {\n                 double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));\n-                double errulp = field.newDfp(tst).subtract(cosh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); \n-                //System.out.println(x+\"\\t\"+tst+\"\\t\"+ref+\"\\t\"+err+\"\\t\"+errulp); \n+                double errulp = field.newDfp(tst).subtract(cosh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();\n+                //System.out.println(x+\"\\t\"+tst+\"\\t\"+ref+\"\\t\"+err+\"\\t\"+errulp);\n                 maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n             }\n         }\n         double maxerrulp = 0.0;\n \n         for (int i=0; i<10000; i++) {\n-            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble(); \n+            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble();\n \n             double tst = FastMath.tanh(x);\n             double ref = tanh(field.newDfp(x)).toDouble();\n \n             if (err != 0) {\n                 double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));\n-                double errulp = field.newDfp(tst).subtract(tanh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); \n-                //System.out.println(x+\"\\t\"+tst+\"\\t\"+ref+\"\\t\"+err+\"\\t\"+errulp); \n+                double errulp = field.newDfp(tst).subtract(tanh(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();\n+                //System.out.println(x+\"\\t\"+tst+\"\\t\"+ref+\"\\t\"+err+\"\\t\"+errulp);\n                 maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n             }\n         }\n         double maxerrulp = 0.0;\n \n         for (int i=0; i<10000; i++) {\n-            double x = ((generator.nextDouble() * 200.0) - 100.0) * generator.nextDouble(); \n+            double x = ((generator.nextDouble() * 200.0) - 100.0) * generator.nextDouble();\n \n             double tst = FastMath.cbrt(x);\n             double ref = cbrt(field.newDfp(x)).toDouble();\n \n             if (err != 0) {\n                 double ulp = Math.abs(ref - Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));\n-                double errulp = field.newDfp(tst).subtract(cbrt(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble(); \n-                //System.out.println(x+\"\\t\"+tst+\"\\t\"+ref+\"\\t\"+err+\"\\t\"+errulp); \n+                double errulp = field.newDfp(tst).subtract(cbrt(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();\n+                //System.out.println(x+\"\\t\"+tst+\"\\t\"+ref+\"\\t\"+err+\"\\t\"+errulp);\n                 maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n             }\n         }", "timestamp": 1315520318, "metainfo": ""}