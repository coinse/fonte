{"sha": "a004b8b230b337c5da7d2b35a4cdf0b3be859497", "log": "Added unit testing of FieldLUDecompositionImpl.Solver. This test is largely based on LUSolverTest, using Fraction instead of double. It resolves issue MATH-673.  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/FieldLUSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.fraction.Fraction;\n+import org.apache.commons.math.fraction.FractionField;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class FieldLUSolverTest {\n+    private int[][] testData = {\n+            { 1, 2, 3},\n+            { 2, 5, 3},\n+            { 1, 0, 8}\n+    };\n+    private int[][] luData = {\n+            { 2, 3, 3 },\n+            { 0, 5, 7 },\n+            { 6, 9, 8 }\n+    };\n+\n+    // singular matrices\n+    private int[][] singular = {\n+            { 2, 3 },\n+            { 2, 3 }\n+    };\n+    private int[][] bigSingular = {\n+            { 1, 2,   3,    4 },\n+            { 2, 5,   3,    4 },\n+            { 7, 3, 256, 1930 },\n+            { 3, 7,   6,    8 }\n+    }; // 4th row = 1st + 2nd\n+\n+    public static FieldMatrix<Fraction> createFractionMatrix(final int[][] data) {\n+        final int numRows = data.length;\n+        final int numCols = data[0].length;\n+        final Array2DRowFieldMatrix<Fraction> m;\n+        m = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance(),\n+                                                numRows, numCols);\n+        for (int i = 0; i < numRows; i++) {\n+            for (int j = 0; j < numCols; j++) {\n+                m.setEntry(i, j, new Fraction(data[i][j], 1));\n+            }\n+        }\n+        return m;\n+    }\n+\n+    /** test singular */\n+    @Test\n+    public void testSingular() {\n+        FieldDecompositionSolver<Fraction> solver;\n+        solver = new FieldLUDecompositionImpl<Fraction>(createFractionMatrix(testData))\n+            .getSolver();\n+        Assert.assertTrue(solver.isNonSingular());\n+        solver = new FieldLUDecompositionImpl<Fraction>(createFractionMatrix(singular))\n+            .getSolver();\n+        Assert.assertFalse(solver.isNonSingular());\n+        solver = new FieldLUDecompositionImpl<Fraction>(createFractionMatrix(bigSingular))\n+            .getSolver();\n+        Assert.assertFalse(solver.isNonSingular());\n+    }\n+\n+    /** test solve dimension errors */\n+    @Test\n+    public void testSolveDimensionErrors() {\n+        FieldDecompositionSolver<Fraction> solver;\n+        solver = new FieldLUDecompositionImpl<Fraction>(createFractionMatrix(testData))\n+            .getSolver();\n+        FieldMatrix<Fraction> b = createFractionMatrix(new int[2][2]);\n+        try {\n+            solver.solve(b);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathIllegalArgumentException iae) {\n+            // expected behavior\n+        }\n+        try {\n+            solver.solve(b.getColumnVector(0));\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathIllegalArgumentException iae) {\n+            // expected behavior\n+        }\n+    }\n+\n+    /** test solve singularity errors */\n+    @Test\n+    public void testSolveSingularityErrors() {\n+        FieldDecompositionSolver solver;\n+        solver = new FieldLUDecompositionImpl(createFractionMatrix(singular))\n+            .getSolver();\n+        FieldMatrix b = createFractionMatrix(new int[2][2]);\n+        try {\n+            solver.solve(b);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (SingularMatrixException ime) {\n+            // expected behavior\n+        }\n+        try {\n+            solver.solve(b.getColumnVector(0));\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (SingularMatrixException ime) {\n+            // expected behavior\n+        }\n+    }\n+\n+    /** test solve */\n+    @Test\n+    public void testSolve() {\n+        FieldDecompositionSolver solver;\n+        solver = new FieldLUDecompositionImpl<Fraction>(createFractionMatrix(testData))\n+            .getSolver();\n+        FieldMatrix<Fraction> b = createFractionMatrix(new int[][] {\n+                { 1, 0 }, { 2, -5 }, { 3, 1 }\n+        });\n+        FieldMatrix<Fraction> xRef = createFractionMatrix(new int[][] {\n+                { 19, -71 }, { -6, 22 }, { -2, 9 }\n+        });\n+\n+        // using FieldMatrix\n+        FieldMatrix<Fraction> x = solver.solve(b);\n+        for (int i = 0; i < x.getRowDimension(); i++){\n+            for (int j = 0; j < x.getColumnDimension(); j++){\n+                Assert.assertEquals(\"(\" + i + \", \" + j + \")\",\n+                                    xRef.getEntry(i, j), x.getEntry(i, j));\n+            }\n+        }\n+\n+        // using ArrayFieldVector\n+        for (int j = 0; j < b.getColumnDimension(); j++) {\n+            final FieldVector<Fraction> xj = solver.solve(b.getColumnVector(j));\n+            for (int i = 0; i < xj.getDimension(); i++){\n+                Assert.assertEquals(\"(\" + i + \", \" + j + \")\",\n+                                    xRef.getEntry(i, j), xj.getEntry(i));\n+            }\n+        }\n+\n+        // using SparseFieldVector\n+        for (int j = 0; j < b.getColumnDimension(); j++) {\n+            final SparseFieldVector<Fraction> bj;\n+            bj = new SparseFieldVector<Fraction>(FractionField.getInstance(),\n+                                                 b.getColumn(j));\n+            final FieldVector<Fraction> xj = solver.solve(bj);\n+            for (int i = 0; i < xj.getDimension(); i++) {\n+                Assert.assertEquals(\"(\" + i + \", \" + j + \")\",\n+                                    xRef.getEntry(i, j), xj.getEntry(i));\n+            }\n+        }\n+    }\n+\n+    /** test determinant */\n+    @Test\n+    public void testDeterminant() {\n+        Assert.assertEquals( -1, getDeterminant(createFractionMatrix(testData)), 1E-15);\n+        Assert.assertEquals(-10, getDeterminant(createFractionMatrix(luData)), 1E-14);\n+        Assert.assertEquals(  0, getDeterminant(createFractionMatrix(singular)), 1E-15);\n+        Assert.assertEquals(  0, getDeterminant(createFractionMatrix(bigSingular)), 1E-15);\n+    }\n+\n+    private double getDeterminant(final FieldMatrix<Fraction> m) {\n+        return new FieldLUDecompositionImpl<Fraction>(m).getDeterminant().doubleValue();\n+    }\n+}", "timestamp": 1316499099, "metainfo": ""}