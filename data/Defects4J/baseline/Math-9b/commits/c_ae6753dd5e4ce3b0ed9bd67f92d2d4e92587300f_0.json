{"sha": "ae6753dd5e4ce3b0ed9bd67f92d2d4e92587300f", "log": "updated general algorithms with latest interfaces definitions  ", "commit": "\n--- a/src/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n \n package org.apache.commons.math.optimization.general;\n \n+import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n+import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.linear.InvalidMatrixException;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.decomposition.LUDecompositionImpl;\n-import org.apache.commons.math.optimization.ObjectiveException;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n import org.apache.commons.math.optimization.VectorialConvergenceChecker;\n-import org.apache.commons.math.optimization.VectorialDifferentiableObjectiveFunction;\n-import org.apache.commons.math.optimization.VectorialDifferentiableOptimizer;\n+import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n \n /**\n  * @since 1.2\n  *\n  */\n-public abstract class AbstractLeastSquaresOptimizer implements VectorialDifferentiableOptimizer {\n+public abstract class AbstractLeastSquaresOptimizer implements DifferentiableMultivariateVectorialOptimizer {\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = 5413193243329026789L;\n     protected int rows;\n \n     /** Objective function. */\n-    private VectorialDifferentiableObjectiveFunction f;\n+    private DifferentiableMultivariateVectorialFunction f;\n+\n+    /** Objective function derivatives. */\n+    private MultivariateMatrixFunction jF;\n \n     /** Target value for the objective functions at optimum. */\n     protected double[] target;\n     /** Weight for the least squares cost computation. */\n     protected double[] weights;\n \n-    /** Current variables set. */\n-    protected double[] variables;\n+    /** Current point. */\n+    protected double[] point;\n \n     /** Current objective function value. */\n     protected double[] objective;\n \n     /** \n      * Update the jacobian matrix.\n-     * @exception ObjectiveException if the function jacobian\n+     * @exception FunctionEvaluationException if the function jacobian\n      * cannot be evaluated or its dimension doesn't match problem dimension\n      */\n-    protected void updateJacobian() throws ObjectiveException {\n+    protected void updateJacobian() throws FunctionEvaluationException {\n         ++jacobianEvaluations;\n-        jacobian = f.jacobian(variables, objective);\n+        jacobian = jF.value(point);\n         if (jacobian.length != rows) {\n-            throw new ObjectiveException(\"dimension mismatch {0} != {1}\",\n-                                         jacobian.length, rows);\n+            throw new FunctionEvaluationException(point, \"dimension mismatch {0} != {1}\",\n+                                                  jacobian.length, rows);\n         }\n         for (int i = 0; i < rows; i++) {\n             final double[] ji = jacobian[i];\n \n     /** \n      * Update the residuals array and cost function value.\n-     * @exception ObjectiveException if the function cannot be evaluated\n+     * @exception FunctionEvaluationException if the function cannot be evaluated\n      * or its dimension doesn't match problem dimension\n      */\n     protected void updateResidualsAndCost()\n-        throws ObjectiveException {\n+        throws FunctionEvaluationException {\n \n         ++objectiveEvaluations;\n-        objective = f.objective(variables);\n+        objective = f.value(point);\n         if (objective.length != rows) {\n-            throw new ObjectiveException(\"dimension mismatch {0} != {1}\",\n-                                         objective.length, rows);\n+            throw new FunctionEvaluationException(point, \"dimension mismatch {0} != {1}\",\n+                                                  objective.length, rows);\n         }\n         cost = 0;\n         for (int i = 0, index = 0; i < rows; i++, index += cols) {\n     /**\n      * Get the covariance matrix of optimized parameters.\n      * @return covariance matrix\n-     * @exception ObjectiveException if the function jacobian cannot\n+     * @exception FunctionEvaluationException if the function jacobian cannot\n      * be evaluated\n      * @exception OptimizationException if the covariance matrix\n      * cannot be computed (singular problem)\n      */\n     public double[][] getCovariances()\n-        throws ObjectiveException, OptimizationException {\n+        throws FunctionEvaluationException, OptimizationException {\n \n         // set up the jacobian\n         updateJacobian();\n      * Guess the errors in optimized parameters.\n      * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>\n      * @return errors in optimized parameters\n-     * @exception ObjectiveException if the function jacobian cannot b evaluated\n+     * @exception FunctionEvaluationException if the function jacobian cannot b evaluated\n      * @exception OptimizationException if the covariances matrix cannot be computed\n      * or the number of degrees of freedom is not positive (number of measurements\n      * lesser or equal to number of parameters)\n      */\n     public double[] guessParametersErrors()\n-        throws ObjectiveException, OptimizationException {\n+        throws FunctionEvaluationException, OptimizationException {\n         if (rows <= cols) {\n             throw new OptimizationException(\n                     \"no degrees of freedom ({0} measurements, {1} parameters)\",\n     }\n \n     /** {@inheritDoc} */\n-    public VectorialPointValuePair optimize(final VectorialDifferentiableObjectiveFunction f,\n+    public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f,\n                                             final double[] target, final double[] weights,\n                                             final double[] startPoint)\n-        throws ObjectiveException, OptimizationException, IllegalArgumentException {\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n \n         if (target.length != weights.length) {\n             throw new OptimizationException(\"dimension mismatch {0} != {1}\",\n \n         // store least squares problem characteristics\n         this.f         = f;\n+        jF             = f.jacobian();\n         this.target    = target.clone();\n         this.weights   = weights.clone();\n-        this.variables = startPoint.clone();\n+        this.point     = startPoint.clone();\n         this.residuals = new double[target.length];\n \n         // arrays shared with the other private methods\n         rows      = target.length;\n-        cols      = variables.length;\n+        cols      = point.length;\n         jacobian  = new double[rows][cols];\n \n         cost = Double.POSITIVE_INFINITY;\n \n     /** Perform the bulk of optimization algorithm.\n      * @return the point/value pair giving the optimal value for objective function\n-     * @exception ObjectiveException if the objective function throws one during\n+     * @exception FunctionEvaluationException if the objective function throws one during\n      * the search\n      * @exception OptimizationException if the algorithm failed to converge\n      * @exception IllegalArgumentException if the start point dimension is wrong\n      */\n     abstract protected VectorialPointValuePair doOptimize()\n-        throws ObjectiveException, OptimizationException, IllegalArgumentException;\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n \n }\n--- a/src/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n \n package org.apache.commons.math.optimization.general;\n \n+import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.linear.DenseRealMatrix;\n import org.apache.commons.math.linear.InvalidMatrixException;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.decomposition.DecompositionSolver;\n import org.apache.commons.math.linear.decomposition.LUDecompositionImpl;\n import org.apache.commons.math.linear.decomposition.QRDecompositionImpl;\n-import org.apache.commons.math.optimization.ObjectiveException;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n \n     /** {@inheritDoc} */\n     public VectorialPointValuePair doOptimize()\n-        throws ObjectiveException, OptimizationException, IllegalArgumentException {\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n \n         // iterate until convergence is reached\n         VectorialPointValuePair current = null;\n             VectorialPointValuePair previous = current;\n             updateResidualsAndCost();\n             updateJacobian();\n-            current = new VectorialPointValuePair(variables, objective);\n+            current = new VectorialPointValuePair(point, objective);\n \n             // build the linear problem\n             final double[]   b = new double[cols];\n \n                 // update the estimated parameters\n                 for (int i = 0; i < cols; ++i) {\n-                    variables[i] += dX[i];\n+                    point[i] += dX[i];\n                 }\n \n             } catch(InvalidMatrixException e) {\n--- a/src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n \n import java.util.Arrays;\n \n-import org.apache.commons.math.optimization.ObjectiveException;\n+import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n \n  * This class solves a least squares problem using the Levenberg-Marquardt algorithm.\n  *\n  * <p>This implementation <em>should</em> work even for over-determined systems\n- * (i.e. systems having more variables than equations). Over-determined systems\n- * are solved by ignoring the variables which have the smallest impact according\n+ * (i.e. systems having more point than equations). Over-determined systems\n+ * are solved by ignoring the point which have the smallest impact according\n  * to their jacobian column norm. Only the rank of the matrix and some loop bounds\n  * are changed to implement this.</p>\n  *\n     /** Serializable version identifier */\n     private static final long serialVersionUID = 8851282236194244323L;\n \n-    /** Number of solved variables. */\n+    /** Number of solved point. */\n     private int solvedCols;\n \n     /** Diagonal elements of the R matrix in the Q.R. decomposition. */\n \n     /** {@inheritDoc} */\n     protected VectorialPointValuePair doOptimize()\n-        throws ObjectiveException, OptimizationException, IllegalArgumentException {\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n \n         // arrays shared with the other private methods\n         solvedCols  = Math.min(rows, cols);\n         permutation = new int[cols];\n         lmDir       = new double[cols];\n \n-        // local variables\n+        // local point\n         double   delta   = 0, xNorm = 0;\n         double[] diag    = new double[cols];\n         double[] oldX    = new double[cols];\n \n             if (firstIteration) {\n \n-                // scale the variables according to the norms of the columns\n+                // scale the point according to the norms of the columns\n                 // of the initial jacobian\n                 xNorm = 0;\n                 for (int k = 0; k < cols; ++k) {\n                     if (dk == 0) {\n                         dk = 1.0;\n                     }\n-                    double xk = dk * variables[k];\n+                    double xk = dk * point[k];\n                     xNorm  += xk * xk;\n                     diag[k] = dk;\n                 }\n             }\n             if (maxCosine <= orthoTolerance) {\n                 // convergence has been reached\n-                return new VectorialPointValuePair(variables, objective);\n+                return new VectorialPointValuePair(point, objective);\n             }\n \n             // rescale if necessary\n                 // save the state\n                 for (int j = 0; j < solvedCols; ++j) {\n                     int pj = permutation[j];\n-                    oldX[pj] = variables[pj];\n+                    oldX[pj] = point[pj];\n                 }\n                 double previousCost = cost;\n                 double[] tmpVec = residuals;\n                 for (int j = 0; j < solvedCols; ++j) {\n                     int pj = permutation[j];\n                     lmDir[pj] = -lmDir[pj];\n-                    variables[pj] = oldX[pj] + lmDir[pj];\n+                    point[pj] = oldX[pj] + lmDir[pj];\n                     double s = diag[pj] * lmDir[pj];\n                     lmNorm  += s * s;\n                 }\n                     firstIteration = false;\n                     xNorm = 0;\n                     for (int k = 0; k < cols; ++k) {\n-                        double xK = diag[k] * variables[k];\n+                        double xK = diag[k] * point[k];\n                         xNorm    += xK * xK;\n                     }\n                     xNorm = Math.sqrt(xNorm);\n                     cost = previousCost;\n                     for (int j = 0; j < solvedCols; ++j) {\n                         int pj = permutation[j];\n-                        variables[pj] = oldX[pj];\n+                        point[pj] = oldX[pj];\n                     }\n                     tmpVec    = residuals;\n                     residuals = oldRes;\n                         (preRed <= costRelativeTolerance) &&\n                         (ratio <= 2.0)) ||\n                         (delta <= parRelativeTolerance * xNorm)) {\n-                    return new VectorialPointValuePair(variables, objective);\n+                    return new VectorialPointValuePair(point, objective);\n                 }\n \n                 // tests for termination and stringent tolerances\n--- a/src/test/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n+++ b/src/test/org/apache/commons/math/optimization/general/GaussNewtonOptimizerTest.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n+import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.linear.DenseRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.optimization.ObjectiveException;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n-import org.apache.commons.math.optimization.VectorialDifferentiableObjectiveFunction;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n \n /**\n         super(name);\n     }\n \n-    public void testTrivial() throws ObjectiveException, OptimizationException {\n+    public void testTrivial() throws FunctionEvaluationException, OptimizationException {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n         assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n     }\n \n-    public void testColumnsPermutation() throws ObjectiveException, OptimizationException {\n+    public void testColumnsPermutation() throws FunctionEvaluationException, OptimizationException {\n \n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n \n     }\n \n-    public void testNoDependency() throws ObjectiveException, OptimizationException {\n+    public void testNoDependency() throws FunctionEvaluationException, OptimizationException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 2, 0, 0, 0, 0, 0 },\n                 { 0, 2, 0, 0, 0, 0 },\n         }\n     }\n \n-    public void testOneSet() throws ObjectiveException, OptimizationException {\n+    public void testOneSet() throws FunctionEvaluationException, OptimizationException {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1,  0, 0 },\n \n     }\n \n-    public void testTwoSets() throws ObjectiveException, OptimizationException {\n+    public void testTwoSets() throws FunctionEvaluationException, OptimizationException {\n         double epsilon = 1.0e-7;\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  2,  1,   0,  4,       0, 0 },\n         }\n     }\n \n-    public void testIllConditioned() throws ObjectiveException, OptimizationException {\n+    public void testIllConditioned() throws FunctionEvaluationException, OptimizationException {\n         LinearProblem problem1 = new LinearProblem(new double[][] {\n                 { 10.0, 7.0,  8.0,  7.0 },\n                 {  7.0, 5.0,  6.0,  5.0 },\n         }\n     }\n \n-    public void testRedundantEquations() throws ObjectiveException, OptimizationException {\n+    public void testRedundantEquations() throws FunctionEvaluationException, OptimizationException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n \n     }\n \n-    public void testInconsistentEquations() throws ObjectiveException, OptimizationException {\n+    public void testInconsistentEquations() throws FunctionEvaluationException, OptimizationException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n \n     }\n \n-    public void testInconsistentSizes() throws ObjectiveException, OptimizationException {\n+    public void testInconsistentSizes() throws FunctionEvaluationException, OptimizationException {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n         GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer(true);\n                                new double[] { 1 },\n                                new double[] { 0, 0 });\n             fail(\"an exception should have been thrown\");\n-        } catch (ObjectiveException oe) {\n+        } catch (FunctionEvaluationException oe) {\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n         }\n     }\n \n-    public void testCircleFitting() throws ObjectiveException, OptimizationException {\n+    public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {\n         Circle circle = new Circle();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);\n         assertEquals(48.135167894714,   center.y, 1.0e-10);\n     }\n \n-    public void testCircleFittingBadInit() throws ObjectiveException, OptimizationException {\n+    public void testCircleFittingBadInit() throws FunctionEvaluationException, OptimizationException {\n         Circle circle = new Circle();\n         double[][] points = new double[][] {\n                 {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},\n \n     }\n \n-    private static class LinearProblem implements VectorialDifferentiableObjectiveFunction {\n-\n-        private static final long serialVersionUID = 703247177355019415L;\n+    private static class LinearProblem implements DifferentiableMultivariateVectorialFunction {\n+\n+        private static final long serialVersionUID = -8804268799379350190L;\n         final RealMatrix factors;\n         final double[] target;\n         public LinearProblem(double[][] factors, double[] target) {\n             this.target  = target;\n         }\n \n-        public double[][] jacobian(double[] variables, double[] value) {\n-            return factors.getData();\n-        }\n-\n-        public double[] objective(double[] variables) {\n+        public double[] value(double[] variables) {\n             return factors.operate(variables);\n         }\n \n-    }\n-\n-    private static class Circle implements VectorialDifferentiableObjectiveFunction {\n-\n-        private static final long serialVersionUID = -4711170319243817874L;\n-\n+        public MultivariateVectorialFunction partialDerivative(final int i) {\n+            return new MultivariateVectorialFunction() {\n+                private static final long serialVersionUID = 1037082026387842358L;\n+                public double[] value(double[] point) {\n+                    return factors.getColumn(i);\n+                }\n+            };\n+        }\n+\n+        public MultivariateVectorialFunction gradient(final int i) {\n+            return new MultivariateVectorialFunction() {\n+                private static final long serialVersionUID = -3268626996728727146L;\n+                public double[] value(double[] point) {\n+                    return factors.getRow(i);\n+                }\n+            };\n+        }\n+\n+        public MultivariateMatrixFunction jacobian() {\n+            return new MultivariateMatrixFunction() {\n+                private static final long serialVersionUID = -8387467946663627585L;\n+                public double[][] value(double[] point) {\n+                    return factors.getData();\n+                }\n+            };\n+        }\n+\n+    }\n+\n+    private static class Circle implements DifferentiableMultivariateVectorialFunction {\n+\n+        private static final long serialVersionUID = -7165774454925027042L;\n         private ArrayList<Point2D.Double> points;\n \n         public Circle() {\n             return r / points.size();\n         }\n \n-        public double[][] jacobian(double[] variables, double[] value)\n-                throws ObjectiveException, IllegalArgumentException {\n+        private double[][] jacobian(double[] variables) {\n \n             int n = points.size();\n             Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n \n         }\n \n-        public double[] objective(double[] variables)\n-                throws ObjectiveException, IllegalArgumentException {\n+        public double[] value(double[] variables) {\n \n             Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n             double radius = getRadius(center);\n \n         }\n \n+        public MultivariateVectorialFunction partialDerivative(final int i) {\n+            return new MultivariateVectorialFunction() {\n+                private static final long serialVersionUID = -2884159755283203273L;\n+                public double[] value(double[] point) {\n+                    double[][] m = jacobian(point);\n+                    double[] partial = new double[m.length];\n+                    for (int j = 0; j < partial.length; ++j) {\n+                        partial[i] = m[i][j];\n+                    }\n+                    return partial;\n+                }\n+            };\n+        }\n+\n+        public MultivariateVectorialFunction gradient(final int i) {\n+            return new MultivariateVectorialFunction() {\n+                private static final long serialVersionUID = -43357217231860547L;\n+                public double[] value(double[] point) {\n+                    return jacobian(point)[i];\n+                }\n+            };\n+        }\n+\n+        public MultivariateMatrixFunction jacobian() {\n+            return new MultivariateMatrixFunction() {\n+                private static final long serialVersionUID = -4340046230875165095L;\n+                public double[][] value(double[] point) {\n+                    return jacobian(point);\n+                }\n+            };\n+        }\n+\n     }\n \n     public static Test suite() {\n--- a/src/test/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n+++ b/src/test/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizerTest.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n+import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.linear.DenseRealMatrix;\n import org.apache.commons.math.linear.RealMatrix;\n-import org.apache.commons.math.optimization.ObjectiveException;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n-import org.apache.commons.math.optimization.VectorialDifferentiableObjectiveFunction;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n \n /**\n         super(name);\n     }\n \n-    public void testTrivial() throws ObjectiveException, OptimizationException {\n+    public void testTrivial() throws FunctionEvaluationException, OptimizationException {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n         assertEquals(3.0, optimum.getValue()[0], 1.0e-10);\n     }\n \n-    public void testQRColumnsPermutation() throws ObjectiveException, OptimizationException {\n+    public void testQRColumnsPermutation() throws FunctionEvaluationException, OptimizationException {\n \n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1.0, -1.0 }, { 0.0, 2.0 }, { 1.0, -2.0 } },\n \n     }\n \n-    public void testNoDependency() throws ObjectiveException, OptimizationException {\n+    public void testNoDependency() throws FunctionEvaluationException, OptimizationException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 2, 0, 0, 0, 0, 0 },\n                 { 0, 2, 0, 0, 0, 0 },\n         }\n     }\n \n-    public void testOneSet() throws ObjectiveException, OptimizationException {\n+    public void testOneSet() throws FunctionEvaluationException, OptimizationException {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1,  0, 0 },\n \n     }\n \n-    public void testTwoSets() throws ObjectiveException, OptimizationException {\n+    public void testTwoSets() throws FunctionEvaluationException, OptimizationException {\n         double epsilon = 1.0e-7;\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  2,  1,   0,  4,       0, 0 },\n \n     }\n \n-    public void testNonInversible() throws ObjectiveException, OptimizationException {\n+    public void testNonInversible() throws FunctionEvaluationException, OptimizationException {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 {  1, 2, -3 },\n \n     }\n \n-    public void testIllConditioned() throws ObjectiveException, OptimizationException {\n+    public void testIllConditioned() throws FunctionEvaluationException, OptimizationException {\n         LinearProblem problem1 = new LinearProblem(new double[][] {\n                 { 10.0, 7.0,  8.0,  7.0 },\n                 {  7.0, 5.0,  6.0,  5.0 },\n \n     }\n \n-    public void testMoreEstimatedParametersSimple() throws ObjectiveException, OptimizationException {\n+    public void testMoreEstimatedParametersSimple() throws FunctionEvaluationException, OptimizationException {\n \n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 3.0, 2.0,  0.0, 0.0 },\n \n     }\n \n-    public void testMoreEstimatedParametersUnsorted() throws ObjectiveException, OptimizationException {\n+    public void testMoreEstimatedParametersUnsorted() throws FunctionEvaluationException, OptimizationException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0, 1.0,  0.0,  0.0, 0.0,  0.0 },\n                 { 0.0, 0.0,  1.0,  1.0, 1.0,  0.0 },\n \n     }\n \n-    public void testRedundantEquations() throws ObjectiveException, OptimizationException {\n+    public void testRedundantEquations() throws FunctionEvaluationException, OptimizationException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n \n     }\n \n-    public void testInconsistentEquations() throws ObjectiveException, OptimizationException {\n+    public void testInconsistentEquations() throws FunctionEvaluationException, OptimizationException {\n         LinearProblem problem = new LinearProblem(new double[][] {\n                 { 1.0,  1.0 },\n                 { 1.0, -1.0 },\n \n     }\n \n-    public void testInconsistentSizes() throws ObjectiveException, OptimizationException {\n+    public void testInconsistentSizes() throws FunctionEvaluationException, OptimizationException {\n         LinearProblem problem =\n             new LinearProblem(new double[][] { { 1, 0 }, { 0, 1 } }, new double[] { -1, 1 });\n         LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\n                                new double[] { 1 },\n                                new double[] { 0, 0 });\n             fail(\"an exception should have been thrown\");\n-        } catch (ObjectiveException oe) {\n+        } catch (FunctionEvaluationException oe) {\n             // expected behavior\n         } catch (Exception e) {\n             fail(\"wrong exception caught\");\n         checkEstimate(circle, 0.1, 20, 1.0e-18, 1.0e-16, 1.0e-10, true);\n     }\n \n-    private void checkEstimate(VectorialDifferentiableObjectiveFunction problem,\n+    private void checkEstimate(DifferentiableMultivariateVectorialFunction problem,\n                                double initialStepBoundFactor, int maxCostEval,\n                                double costRelativeTolerance, double parRelativeTolerance,\n                                double orthoTolerance, boolean shouldFail) {\n             assertTrue(! shouldFail);\n         } catch (OptimizationException ee) {\n             assertTrue(shouldFail);\n-        } catch (ObjectiveException ee) {\n+        } catch (FunctionEvaluationException ee) {\n             assertTrue(shouldFail);\n         } catch (Exception e) {\n             fail(\"wrong exception type caught\");\n         }\n     }\n \n-    public void testCircleFitting() throws ObjectiveException, OptimizationException {\n+    public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {\n         Circle circle = new Circle();\n         circle.addPoint( 30.0,  68.0);\n         circle.addPoint( 50.0,  -6.0);\n \n     }\n \n-    public void testCircleFittingBadInit() throws ObjectiveException, OptimizationException {\n+    public void testCircleFittingBadInit() throws FunctionEvaluationException, OptimizationException {\n         Circle circle = new Circle();\n         double[][] points = new double[][] {\n                 {-0.312967,  0.072366}, {-0.339248,  0.132965}, {-0.379780,  0.202724},\n         assertEquals( 0.2075001, center.y,      1.0e-6);\n     }\n \n-    public void testMath199() throws ObjectiveException, OptimizationException {\n+    public void testMath199() throws FunctionEvaluationException, OptimizationException {\n         try {\n             QuadraticProblem problem = new QuadraticProblem();\n             problem.addPoint (0, -3.182591015485607);\n \n     }\n \n-    private static class LinearProblem implements VectorialDifferentiableObjectiveFunction {\n+    private static class LinearProblem implements DifferentiableMultivariateVectorialFunction {\n \n         private static final long serialVersionUID = 703247177355019415L;\n         final RealMatrix factors;\n             this.target  = target;\n         }\n \n-        public double[][] jacobian(double[] variables, double[] value) {\n-            return factors.getData();\n-        }\n-\n-        public double[] objective(double[] variables) {\n+        public double[] value(double[] variables) {\n             return factors.operate(variables);\n         }\n \n-    }\n-\n-    private static class Circle implements VectorialDifferentiableObjectiveFunction {\n+        public MultivariateVectorialFunction partialDerivative(final int i) {\n+            return new MultivariateVectorialFunction() {\n+                private static final long serialVersionUID = 4868131119285501303L;\n+                public double[] value(double[] point) {\n+                    return factors.getColumn(i);\n+                }\n+            };\n+        }\n+\n+        public MultivariateVectorialFunction gradient(final int i) {\n+            return new MultivariateVectorialFunction() {\n+                private static final long serialVersionUID = 6280336674474631774L;\n+                public double[] value(double[] point) {\n+                    return factors.getRow(i);\n+                }\n+            };\n+        }\n+\n+        public MultivariateMatrixFunction jacobian() {\n+            return new MultivariateMatrixFunction() {\n+                private static final long serialVersionUID = 556396458721526234L;\n+                public double[][] value(double[] point) {\n+                    return factors.getData();\n+                }\n+            };\n+        }\n+\n+    }\n+\n+    private static class Circle implements DifferentiableMultivariateVectorialFunction {\n \n         private static final long serialVersionUID = -4711170319243817874L;\n \n             return r / points.size();\n         }\n \n-        public double[][] jacobian(double[] variables, double[] value)\n-        throws ObjectiveException, IllegalArgumentException {\n+        private double[][] jacobian(double[] point) {\n \n             int n = points.size();\n-            Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n+            Point2D.Double center = new Point2D.Double(point[0], point[1]);\n \n             // gradient of the optimal radius\n             double dRdX = 0;\n \n         }\n \n-        public double[] objective(double[] variables)\n-        throws ObjectiveException, IllegalArgumentException {\n+        public double[] value(double[] variables)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n \n             Point2D.Double center = new Point2D.Double(variables[0], variables[1]);\n             double radius = getRadius(center);\n \n         }\n \n-    }\n-\n-    private static class QuadraticProblem implements VectorialDifferentiableObjectiveFunction {\n-\n-        private static final long serialVersionUID = -247096133023967957L;\n+        public MultivariateVectorialFunction partialDerivative(final int i) {\n+            return new MultivariateVectorialFunction() {\n+                private static final long serialVersionUID = -2884159755283203273L;\n+                public double[] value(double[] point) {\n+                    double[][] m = jacobian(point);\n+                    double[] partial = new double[m.length];\n+                    for (int j = 0; j < partial.length; ++j) {\n+                        partial[i] = m[i][j];\n+                    }\n+                    return partial;\n+                }\n+            };\n+        }\n+\n+        public MultivariateVectorialFunction gradient(final int i) {\n+            return new MultivariateVectorialFunction() {\n+                private static final long serialVersionUID = -43357217231860547L;\n+                public double[] value(double[] point) {\n+                    return jacobian(point)[i];\n+                }\n+            };\n+        }\n+\n+        public MultivariateMatrixFunction jacobian() {\n+            return new MultivariateMatrixFunction() {\n+                private static final long serialVersionUID = -4340046230875165095L;\n+                public double[][] value(double[] point) {\n+                    return jacobian(point);\n+                }\n+            };\n+        }\n+\n+    }\n+\n+    private static class QuadraticProblem implements DifferentiableMultivariateVectorialFunction {\n+\n+        private static final long serialVersionUID = 7072187082052755854L;\n         private List<Double> x;\n         private List<Double> y;\n \n             this.y.add(y);\n         }\n \n-        public double[][] jacobian(double[] variables, double[] value) {\n+        private double[][] jacobian(double[] variables) {\n             double[][] jacobian = new double[x.size()][3];\n             for (int i = 0; i < jacobian.length; ++i) {\n                 jacobian[i][0] = x.get(i) * x.get(i);\n             return jacobian;\n         }\n \n-        public double[] objective(double[] variables) {\n+        public double[] value(double[] variables) {\n             double[] values = new double[x.size()];\n             for (int i = 0; i < values.length; ++i) {\n                 values[i] = (variables[0] * x.get(i) + variables[1]) * x.get(i) + variables[2];\n             return values;\n         }\n \n+        public MultivariateVectorialFunction partialDerivative(final int i) {\n+            return new MultivariateVectorialFunction() {\n+                private static final long serialVersionUID = 2371658898687841192L;\n+                public double[] value(double[] point) {\n+                    double[][] m = jacobian(point);\n+                    double[] partial = new double[m.length];\n+                    for (int j = 0; j < partial.length; ++j) {\n+                        partial[i] = m[i][j];\n+                    }\n+                    return partial;\n+                }\n+            };\n+        }\n+\n+        public MultivariateVectorialFunction gradient(final int i) {\n+            return new MultivariateVectorialFunction() {\n+                private static final long serialVersionUID = 6863958501785879369L;\n+                public double[] value(double[] point) {\n+                    return jacobian(point)[i];\n+                }\n+            };\n+        }\n+\n+        public MultivariateMatrixFunction jacobian() {\n+            return new MultivariateMatrixFunction() {\n+                private static final long serialVersionUID = -8673650298627399464L;\n+                public double[][] value(double[] point) {\n+                    return jacobian(point);\n+                }\n+            };\n+        }\n+\n     }\n \n     public static Test suite() {\n--- a/src/test/org/apache/commons/math/optimization/general/MinpackTest.java\n+++ b/src/test/org/apache/commons/math/optimization/general/MinpackTest.java\n \n import java.util.Arrays;\n \n-import org.apache.commons.math.optimization.ObjectiveException;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n+import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.optimization.OptimizationException;\n-import org.apache.commons.math.optimization.VectorialDifferentiableObjectiveFunction;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n-\n-\n-import junit.framework.*;\n \n /**\n  * <p>Some of the unit tests are re-implementations of the MINPACK <a\n           assertTrue(function.checkTheoreticalMinParams(optimum));\n       } catch (OptimizationException lsse) {\n           assertTrue(exceptionExpected);\n-      } catch (ObjectiveException oe) {\n+      } catch (FunctionEvaluationException fe) {\n           assertTrue(exceptionExpected);\n       }\n   }\n \n   private static abstract class MinpackFunction\n-      implements VectorialDifferentiableObjectiveFunction {\n+      implements DifferentiableMultivariateVectorialFunction {\n  \n       private static final long serialVersionUID = -6209760235478794233L;\n       protected int      n;\n           return true;\n       }\n \n-      public abstract double[][] jacobian(double[] variables, double[] value);\n-\n-      public abstract double[] objective(double[] variables);\n+      public MultivariateVectorialFunction partialDerivative(final int i) {\n+          return new MultivariateVectorialFunction() {\n+            private static final long serialVersionUID = 2192585229396907068L;\n+            public double[] value(double[] point) {\n+                  double[][] m = jacobian(point);\n+                  double[] partial = new double[m.length];\n+                  for (int j = 0; j < partial.length; ++j) {\n+                      partial[i] = m[i][j];\n+                  }\n+                  return partial;\n+              }\n+          };\n+      }\n+\n+      public MultivariateVectorialFunction gradient(final int i) {\n+          return new MultivariateVectorialFunction() {\n+            private static final long serialVersionUID = -5562016064510078300L;\n+            public double[] value(double[] point) {\n+                  return jacobian(point)[i];\n+              }\n+          };\n+      }\n+\n+      public MultivariateMatrixFunction jacobian() {\n+          return new MultivariateMatrixFunction() {\n+            private static final long serialVersionUID = -2435076097232923678L;\n+            public double[][] value(double[] point) {\n+                  return jacobian(point);\n+              }\n+          };\n+      }\n+\n+      public abstract double[][] jacobian(double[] variables);\n+\n+      public abstract double[] value(double[] variables);\n \n   }\n \n             buildArray(n, -1.0));\n     }\n \n-    public double[][] jacobian(double[] variables, double[] value) {\n+    public double[][] jacobian(double[] variables) {\n       double t = 2.0 / m;\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n       return jacobian;\n     }\n \n-    public double[] objective(double[] variables) {\n+    public double[] value(double[] variables) {\n       double sum = 0;\n       for (int i = 0; i < n; ++i) {\n         sum += variables[i];\n       super(m, buildArray(n, x0), theoreticalMinCost, null);\n     }\n \n-    public double[][] jacobian(double[] variables, double[] value) {\n+    public double[][] jacobian(double[] variables) {\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         jacobian[i] = new double[n];\n       return jacobian;\n     }\n \n-    public double[] objective(double[] variables) {\n+    public double[] value(double[] variables) {\n       double[] f = new double[m];\n       double sum = 0;\n       for (int i = 0; i < n; ++i) {\n             null);\n     }\n \n-    public double[][] jacobian(double[] variables, double[] value) {\n+    public double[][] jacobian(double[] variables) {\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         jacobian[i] = new double[n];\n       return jacobian;\n     }\n \n-    public double[] objective(double[] variables) {\n+    public double[] value(double[] variables) {\n       double[] f = new double[m];\n       double sum = 0;\n       for (int i = 1; i < (n - 1); ++i) {\n       super(2, startParams, 0.0, buildArray(2, 1.0));\n     }\n \n-    public double[][] jacobian(double[] variables, double[] value) {\n+    public double[][] jacobian(double[] variables) {\n       double x1 = variables[0];\n       return new double[][] { { -20 * x1, 10 }, { -1, 0 } };\n     }\n \n-    public double[] objective(double[] variables) {\n+    public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n       return new double[] { 10 * (x2 - x1 * x1), 1 - x1 };\n       super(3, startParams, 0.0, new double[] { 1.0, 0.0, 0.0 });\n     }\n \n-    public double[][] jacobian(double[] variables, double[] value) {\n+    public double[][] jacobian(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n       double tmpSquare = x1 * x1 + x2 * x2;\n       };\n     }\n \n-    public double[] objective(double[] variables) {\n+    public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n       double x3 = variables[2];\n       super(4, startParams, 0.0, buildArray(4, 0.0));\n     }\n \n-    public double[][] jacobian(double[] variables, double[] value) {\n+    public double[][] jacobian(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n       double x3 = variables[2];\n       };\n     }\n \n-    public double[] objective(double[] variables) {\n+    public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n       double x3 = variables[2];\n             theoreticalMinParams);\n     }\n \n-    public double[][] jacobian(double[] variables, double[] value) {\n+    public double[][] jacobian(double[] variables) {\n       double x2 = variables[1];\n       return new double[][] {\n         { 1, x2 * (10 - 3 * x2) -  2 },\n       };\n     }\n \n-    public double[] objective(double[] variables) {\n+    public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n       return new double[] {\n             theoreticalMinParams);\n     }\n \n-    public double[][] jacobian(double[] variables, double[] value) {\n+    public double[][] jacobian(double[] variables) {\n       double   x2 = variables[1];\n       double   x3 = variables[2];\n       double[][] jacobian = new double[m][];\n       return jacobian;\n     }\n \n-    public double[] objective(double[] variables) {\n+    public double[] value(double[] variables) {\n       double   x1 = variables[0];\n       double   x2 = variables[1];\n       double   x3 = variables[2];\n       }\n     }\n \n-    public double[][] jacobian(double[] variables, double[] value) {\n+    public double[][] jacobian(double[] variables) {\n       double   x1 = variables[0];\n       double   x2 = variables[1];\n       double   x3 = variables[2];\n       return jacobian;\n     }\n \n-    public double[] objective(double[] variables) {\n+    public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n       double x3 = variables[2];\n       }\n     }\n \n-    public double[][] jacobian(double[] variables, double[] value) {\n+    public double[][] jacobian(double[] variables) {\n       double   x1 = variables[0];\n       double   x2 = variables[1];\n       double   x3 = variables[2];\n       return jacobian;\n     }\n \n-    public double[] objective(double[] variables) {\n+    public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n       double x3 = variables[2];\n             theoreticalMinParams);\n     }\n \n-    public double[][] jacobian(double[] variables, double[] value) {\n+    public double[][] jacobian(double[] variables) {\n \n       double[][] jacobian = new double[m][];\n \n \n     }\n \n-    public double[] objective(double[] variables) {\n+    public double[] value(double[] variables) {\n      double[] f = new double[m];\n      for (int i = 0; i < (m - 2); ++i) {\n        double div = (i + 1) / 29.0;\n             new double[] { 1.0, 10.0, 1.0 });\n    }\n \n-    public double[][] jacobian(double[] variables, double[] value) {\n+    public double[][] jacobian(double[] variables) {\n       double   x1 = variables[0];\n       double   x2 = variables[1];\n       double[][] jacobian = new double[m][];\n       return jacobian;\n     }\n \n-    public double[] objective(double[] variables) {\n+    public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n       double x3 = variables[2];\n             theoreticalMinParams);\n     }\n \n-    public double[][] jacobian(double[] variables, double[] value) {\n+    public double[][] jacobian(double[] variables) {\n       double   x1 = variables[0];\n       double   x2 = variables[1];\n       double[][] jacobian = new double[m][];\n       return jacobian;\n     }\n \n-    public double[] objective(double[] variables) {\n+    public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n       double[] f = new double[m];\n             theoreticalMinParams);\n     }\n \n-    public double[][] jacobian(double[] variables, double[] value) {\n+    public double[][] jacobian(double[] variables) {\n       double   x1 = variables[0];\n       double   x2 = variables[1];\n       double   x3 = variables[2];\n       return jacobian;\n     }\n \n-    public double[] objective(double[] variables) {\n+    public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n       double x3 = variables[2];\n             theoreticalMinParams);\n     }\n \n-    public double[][] jacobian(double[] variables, double[] value) {\n+    public double[][] jacobian(double[] variables) {\n \n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n \n     }\n \n-    public double[] objective(double[] variables) {\n+    public double[] value(double[] variables) {\n \n       double[] f = new double[m];\n \n             theoreticalMinParams);\n     }\n \n-    public double[][] jacobian(double[] variables, double[] value) {\n+    public double[][] jacobian(double[] variables) {\n       double[][] jacobian = new double[m][];\n       for (int i = 0; i < m; ++i) {\n         jacobian[i] = new double[n];\n \n     }\n \n-    public double[] objective(double[] variables) {\n+    public double[] value(double[] variables) {\n       double[] f = new double[m];\n       double sum  = -(n + 1);\n       double prod = 1;\n             theoreticalMinParams);\n     }\n \n-    public double[][] jacobian(double[] variables, double[] value) {\n+    public double[][] jacobian(double[] variables) {\n       double   x2 = variables[1];\n       double   x3 = variables[2];\n       double   x4 = variables[3];\n       return jacobian;\n     }\n \n-    public double[] objective(double[] variables) {\n+    public double[] value(double[] variables) {\n       double x1 = variables[0];\n       double x2 = variables[1];\n       double x3 = variables[2];\n             theoreticalMinParams);\n     }\n \n-    public double[][] jacobian(double[] variables, double[] value) {\n+    public double[][] jacobian(double[] variables) {\n       double   x01 = variables[0];\n       double   x02 = variables[1];\n       double   x03 = variables[2];\n       return jacobian;\n     }\n \n-    public double[] objective(double[] variables) {\n+    public double[] value(double[] variables) {\n       double x01 = variables[0];\n       double x02 = variables[1];\n       double x03 = variables[2];", "timestamp": 1237932908, "metainfo": ""}