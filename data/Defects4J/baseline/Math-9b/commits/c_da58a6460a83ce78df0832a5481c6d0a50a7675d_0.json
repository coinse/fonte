{"sha": "da58a6460a83ce78df0832a5481c6d0a50a7675d", "log": "A complete generic implementation of Binary Space Partitioning Trees (BSP trees) has been added. A few specializations of this implementation are also provided for 1D, 2D and 3D Euclidean geometry. This allows support for arbitrary intervals sets (1D), polygons sets (2D) and polyhedrons sets (3D) with all sets operations (union, intersection, symmetric difference, difference, complement), with predicates (point inside/outside/on boundary, emptiness, other region contained), with geometrical computation (barycenter, size, boundary size) and with conversions from and to boundary representation.  JIRA: MATH-576   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     CONTRACTION_CRITERIA_SMALLER_THAN_EXPANSION_FACTOR(\"contraction criteria ({0}) smaller than the expansion factor ({1}).  This would lead to a never ending loop of expansion and contraction as a newly expanded internal storage array would immediately satisfy the criteria for contraction.\"),\n     CONTRACTION_CRITERIA_SMALLER_THAN_ONE(\"contraction criteria smaller than one ({0}).  This would lead to a never ending loop of expansion and contraction as an internal storage array length equal to the number of elements would satisfy the contraction criteria.\"),\n     CONVERGENCE_FAILED(\"convergence failed\"), /* keep */\n+    CROSSING_BOUNDARY_LOOPS(\"some outline boundary loops cross each other\"),\n     CUMULATIVE_PROBABILITY_RETURNED_NAN(\"Cumulative probability function returned NaN for argument {0} p = {1}\"),\n     DIFFERENT_ROWS_LENGTHS(\"some rows have length {0} while others have length {1}\"),\n     DIGEST_NOT_INITIALIZED(\"digest not initialized\"),\n     ROBUSTNESS_ITERATIONS(\"number of robustness iterations ({0})\"),\n     START_POSITION(\"start position ({0})\"), /* keep */\n     NON_CONVERGENT_CONTINUED_FRACTION(\"Continued fraction convergents failed to converge (in less than {0} iterations) for value {1}\"),\n+    NON_INVERTIBLE_TRANSFORM(\"non-invertible affine transform collapses some lines into single points\"),\n     NON_POSITIVE_MICROSPHERE_ELEMENTS(\"number of microsphere elements must be positive, but got {0}\"),\n     NON_POSITIVE_POLYNOMIAL_DEGREE(\"polynomial degree must be positive: degree={0}\"),\n     NON_REAL_FINITE_ABSCISSA(\"all abscissae must be finite real numbers, but {0}-th is {1}\"),\n     NOT_STRICTLY_INCREASING_NUMBER_OF_POINTS(\"points {0} and {1} are not strictly increasing ({2} >= {3})\"),\n     NOT_STRICTLY_INCREASING_SEQUENCE(\"points {3} and {2} are not strictly increasing ({1} >= {0})\"), /* keep */\n     NOT_SUBTRACTION_COMPATIBLE_MATRICES(\"{0}x{1} and {2}x{3} matrices are not subtraction compatible\"),\n+    NOT_SUPPORTED_IN_DIMENSION_N(\"method not supported in dimension {0}\"),\n     NOT_SYMMETRIC_MATRIX(\"not symmetric matrix\"),\n     NON_SYMMETRIC_MATRIX(\"non symmetric matrix: the difference between entries at ({0},{1}) and ({1},{0}) is larger than {2}\"), /* keep */\n     NO_BIN_SELECTED(\"no bin selected\"),\n     OUT_OF_RANGE_ROOT_OF_UNITY_INDEX(\"out of range root of unity index {0} (must be in [{1};{2}])\"),\n     OUT_OF_RANGE(\"out of range\"), /* keep */\n     OUT_OF_RANGE_SIMPLE(\"{0} out of [{1}, {2}] range\"), /* keep */\n+    OUTLINE_BOUNDARY_LOOP_OPEN(\"an outline boundary loop is open\"),\n     OVERFLOW_IN_FRACTION(\"overflow in fraction {0}/{1}, cannot negate\"),\n     OVERFLOW_IN_ADDITION(\"overflow in addition: {0} + {1}\"),\n     OVERFLOW_IN_SUBTRACTION(\"overflow in subtraction: {0} - {1}\"),\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/oneD/Interval.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.oneD;\n+\n+\n+/** This class represents a 1D interval.\n+ * @see IntervalsSet\n+ * @version $Revision$ $Date$\n+ */\n+public class Interval {\n+\n+    /** The lower bound of the interval. */\n+    private final double lower;\n+\n+    /** The upper bound of the interval. */\n+    private final double upper;\n+\n+    /** Simple constructor.\n+     * @param lower lower bound of the interval\n+     * @param upper upper bound of the interval\n+     */\n+    public Interval(final double lower, final double upper) {\n+        this.lower = lower;\n+        this.upper = upper;\n+    }\n+\n+    /** Get the lower bound of the interval.\n+     * @return lower bound of the interval\n+     */\n+    public double getLower() {\n+        return lower;\n+    }\n+\n+    /** Get the upper bound of the interval.\n+     * @return upper bound of the interval\n+     */\n+    public double getUpper() {\n+        return upper;\n+    }\n+\n+    /** Get the length of the interval.\n+     * @return length of the interval\n+     */\n+    public double getLength() {\n+        return upper - lower;\n+    }\n+\n+    /** Get the midpoint of the interval.\n+     * @return midpoint of the interval\n+     */\n+    public double getMidPoint() {\n+        return 0.5 * (lower + upper);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/oneD/IntervalsSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.oneD;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.math.geometry.partitioning.BSPTree;\n+import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n+\n+/** This class represents a 1D region: a set of intervals.\n+ * @version $Revision$ $Date$\n+ */\n+public class IntervalsSet extends Region {\n+\n+    /** Build an intervals set representing the whole real line.\n+     */\n+    public IntervalsSet() {\n+        super();\n+    }\n+\n+    /** Build an intervals set corresponding to a single interval.\n+     * @param lower lower bound of the interval, must be lesser or equal\n+     * to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})\n+     * @param upper upper bound of the interval, must be greater or equal\n+     * to {@code lower} (may be {@code Double.POSITIVE_INFINITY})\n+     */\n+    public IntervalsSet(final double lower, final double upper) {\n+        super(buildTree(lower, upper));\n+    }\n+\n+    /** Build an intervals set from an inside/outside BSP tree.\n+     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n+     * {@code Boolean} attribute representing the inside status of\n+     * the corresponding cell (true for inside cells, false for outside\n+     * cells). In order to avoid building too many small objects, it is\n+     * recommended to use the predefined constants\n+     * {@code Boolean.TRUE} and {@code Boolean.FALSE}</p>\n+     * @param tree inside/outside BSP tree representing the intervals set\n+     */\n+    public IntervalsSet(final BSPTree tree) {\n+        super(tree);\n+    }\n+\n+    /** Build an intervals set from a Boundary REPresentation (B-rep).\n+     * <p>The boundary is provided as a collection of {@link\n+     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the\n+     * interior part of the region on its minus side and the exterior on\n+     * its plus side.</p>\n+     * <p>The boundary elements can be in any order, and can form\n+     * several non-connected sets (like for example polygons with holes\n+     * or a set of disjoints polyhedrons considered as a whole). In\n+     * fact, the elements do not even need to be connected together\n+     * (their topological connections are not used here). However, if the\n+     * boundary does not really separate an inside open from an outside\n+     * open (open having here its topological meaning), then subsequent\n+     * calls to the {@link\n+     * Region#checkPoint(org.apache.commons.math.geometry.partitioning.Point)\n+     * checkPoint} method will not be meaningful anymore.</p>\n+     * <p>If the boundary is empty, the region will represent the whole\n+     * space.</p>\n+     * @param boundary collection of boundary elements\n+     */\n+    public IntervalsSet(final Collection<SubHyperplane> boundary) {\n+        super(boundary);\n+    }\n+\n+    /** Build an inside/outside tree representing a single interval.\n+     * @param lower lower bound of the interval, must be lesser or equal\n+     * to {@code upper} (may be {@code Double.NEGATIVE_INFINITY})\n+     * @param upper upper bound of the interval, must be greater or equal\n+     * to {@code lower} (may be {@code Double.POSITIVE_INFINITY})\n+     * @return the built tree\n+     */\n+    private static BSPTree buildTree(final double lower, final double upper) {\n+        if (Double.isInfinite(lower) && (lower < 0)) {\n+            if (Double.isInfinite(upper) && (upper > 0)) {\n+                // the tree must cover the whole real line\n+                return new BSPTree(Boolean.TRUE);\n+            }\n+            // the tree must be open on the negative infinity side\n+            final SubHyperplane upperCut =\n+                new SubHyperplane(new OrientedPoint(new Point1D(upper), true));\n+            return new BSPTree(upperCut,\n+                               new BSPTree(Boolean.FALSE),\n+                               new BSPTree(Boolean.TRUE),\n+                               null);\n+        }\n+        final SubHyperplane lowerCut =\n+            new SubHyperplane(new OrientedPoint(new Point1D(lower), false));\n+        if (Double.isInfinite(upper) && (upper > 0)) {\n+            // the tree must be open on the positive infinity side\n+            return new BSPTree(lowerCut,\n+                               new BSPTree(Boolean.FALSE),\n+                               new BSPTree(Boolean.TRUE),\n+                               null);\n+        }\n+\n+        // the tree must be bounded on the two sides\n+        final SubHyperplane upperCut =\n+            new SubHyperplane(new OrientedPoint(new Point1D(upper), true));\n+        return new BSPTree(lowerCut,\n+                           new BSPTree(Boolean.FALSE),\n+                           new BSPTree(upperCut,\n+                                       new BSPTree(Boolean.FALSE),\n+                                       new BSPTree(Boolean.TRUE),\n+                                       null),\n+                                       null);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Region buildNew(final BSPTree tree) {\n+        return new IntervalsSet(tree);\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected void computeGeometricalProperties() {\n+        if (getTree(false).getCut() == null) {\n+            setBarycenter(Point1D.UNDEFINED);\n+            setSize(((Boolean) getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : 0);\n+        } else {\n+            double size = 0.0;\n+            double sum = 0.0;\n+            for (final Interval interval : asList()) {\n+                size += interval.getLength();\n+                sum  += interval.getLength() * interval.getMidPoint();\n+            }\n+            setSize(size);\n+            setBarycenter(Double.isInfinite(size) ? Point1D.UNDEFINED : new Point1D(sum / size));\n+        }\n+    }\n+\n+    /** Get the lowest value belonging to the instance.\n+     * @return lowest value belonging to the instance\n+     * ({@code Double.NEGATIVE_INFINITY} if the instance doesn't\n+     * have any low bound, {@code Double.POSITIVE_INFINITY} if the\n+     * instance is empty)\n+     */\n+    public double getInf() {\n+        BSPTree node = getTree(false);\n+        double  inf  = Double.POSITIVE_INFINITY;\n+        while (node.getCut() != null) {\n+            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n+            inf  = op.getLocation().getAbscissa();\n+            node = op.isDirect() ? node.getMinus() : node.getPlus();\n+        }\n+        return ((Boolean) node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n+    }\n+\n+    /** Get the highest value belonging to the instance.\n+     * @return highest value belonging to the instance\n+     * ({@code Double.POSITIVE_INFINITY} if the instance doesn't\n+     * have any high bound, {@code Double.NEGATIVE_INFINITY} if the\n+     * instance is empty)\n+     */\n+    public double getSup() {\n+        BSPTree node = getTree(false);\n+        double  sup  = Double.NEGATIVE_INFINITY;\n+        while (node.getCut() != null) {\n+            final OrientedPoint op = (OrientedPoint) node.getCut().getHyperplane();\n+            sup  = op.getLocation().getAbscissa();\n+            node = op.isDirect() ? node.getPlus() : node.getMinus();\n+        }\n+        return ((Boolean) node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n+    }\n+\n+    /** Build an ordered list of intervals representing the instance.\n+     * <p>This method builds this intervals set as an ordered list of\n+     * {@link Interval Interval} elements. If the intervals set has no\n+     * lower limit, the first interval will have its low bound equal to\n+     * {@code Double.NEGATIVE_INFINITY}. If the intervals set has\n+     * no upper limit, the last interval will have its upper bound equal\n+     * to {@code Double.POSITIVE_INFINITY}. An empty tree will\n+     * build an empty list while a tree representing the whole real line\n+     * will build a one element list with both bounds beeing\n+     * infinite.</p>\n+     * @return a new ordered list containing {@link Interval Interval}\n+     * elements\n+     */\n+    public List<Interval> asList() {\n+        final List<Interval> list = new ArrayList<Interval>();\n+        recurseList(getTree(false), list,\n+                    Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n+        return list;\n+    }\n+\n+    /** Update an intervals list.\n+     * @param node current node\n+     * @param list list to update\n+     * @param lower lower bound of the current convex cell\n+     * @param upper upper bound of the current convex cell\n+     */\n+    private void recurseList(final BSPTree node, final List<Interval> list,\n+                             final double lower, final double upper) {\n+\n+        if (node.getCut() == null) {\n+            if ((Boolean) node.getAttribute()) {\n+                // this leaf cell is an inside cell: an interval\n+                list.add(new Interval(lower, upper));\n+            }\n+        } else {\n+            final OrientedPoint op  = (OrientedPoint) node.getCut().getHyperplane();\n+            final Point1D       loc = op.getLocation();\n+            double        x   = loc.getAbscissa();\n+\n+            // make sure we explore the tree in increasing order\n+            final BSPTree low       = op.isDirect() ? node.getMinus() : node.getPlus();\n+            final BSPTree high      = op.isDirect() ? node.getPlus()  : node.getMinus();\n+\n+            recurseList(low, list, lower, x);\n+            if ((checkPoint(low,  loc) == Location.INSIDE) &&\n+                (checkPoint(high, loc) == Location.INSIDE)) {\n+                // merge the last interval added and the first one of the high sub-tree\n+                x = ((Interval) list.remove(list.size() - 1)).getLower();\n+            }\n+            recurseList(high, list, x, upper);\n+\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/oneD/OrientedPoint.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.oneD;\n+\n+import org.apache.commons.math.exception.MathUnsupportedOperationException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.geometry.partitioning.BSPTree;\n+import org.apache.commons.math.geometry.partitioning.Hyperplane;\n+import org.apache.commons.math.geometry.partitioning.Point;\n+import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n+import org.apache.commons.math.geometry.partitioning.SubSpace;\n+\n+/** This class represents a 1D oriented hyperplane.\n+ * <p>An hyperplane in 1D is a simple point, its orientation being a\n+ * boolean.</p>\n+ * <p>Instances of this class are guaranteed to be immutable.</p>\n+ * @version $Revision$ $Date$\n+ */\n+public class OrientedPoint implements Hyperplane {\n+\n+    /** Dummy region returned by the {@link #wholeHyperplane} method. */\n+    private static final Region DUMMY_REGION = new DummyRegion();\n+\n+    /** Point location. */\n+    private Point1D location;\n+\n+    /** Orientation. */\n+    private boolean direct;\n+\n+    /** Simple constructor.\n+     * @param location location of the hyperplane\n+     * @param direct if true, the plus side of the hyperplane is towards\n+     * abscissae greater than {@code location}\n+     */\n+    public OrientedPoint(final Point1D location, final boolean direct) {\n+        this.location = location;\n+        this.direct   = direct;\n+    }\n+\n+    /** Copy the instance.\n+     * <p>Since instances are immutable, this method directly returns\n+     * the instance.</p>\n+     * @return the instance itself\n+     */\n+    public Hyperplane copySelf() {\n+        return this;\n+    }\n+\n+    /** Get the offset (oriented distance) of a point to the hyperplane.\n+     * @param point point to check\n+     * @return offset of the point\n+     */\n+    public double getOffset(final Point point) {\n+        final double delta = ((Point1D) point).getAbscissa() - location.getAbscissa();\n+        return direct ? delta : -delta;\n+    }\n+\n+    /** Transform a space point into a sub-space point.\n+     * <p>Since this class represent zero dimension spaces which does\n+     * not have lower dimension sub-spaces, this method cannot be\n+     * supported here. It always throws a {@code RuntimeException}\n+     * when called.</p>\n+     * @param point n-dimension point of the space\n+     * @return (n-1)-dimension point of the sub-space corresponding to\n+     * the specified space point\n+     * @see #toSpace\n+     */\n+    public Point toSubSpace(final Point point) {\n+        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SUPPORTED_IN_DIMENSION_N, 1);\n+    }\n+\n+    /** Transform a sub-space point into a space point.\n+     * <p>Since this class represent zero dimension spaces which does\n+     * not have lower dimension sub-spaces, this method cannot be\n+     * supported here. It always throws a {@code RuntimeException}\n+     * when called.</p>\n+     * @param point (n-1)-dimension point of the sub-space\n+     * @return n-dimension point of the space corresponding to the\n+     * specified sub-space point\n+     * @see #toSubSpace\n+     */\n+    public Point toSpace(final Point point) {\n+        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SUPPORTED_IN_DIMENSION_N, 1);\n+    }\n+\n+    /** Build the sub-space shared by the instance and another hyperplane.\n+     * <p>Since this class represent zero dimension spaces which does\n+     * not have lower dimension sub-spaces, this method cannot be\n+     * supported here. It always throws a {@code RuntimeException}\n+     * when called.</p>\n+     * @param other other sub-space (must have the same dimension as the\n+     * instance)\n+     * @return a sub-space at the intersection of the instance and the\n+     * other sub-space (it has a dimension one unit less than the\n+     * instance)\n+     */\n+    public SubSpace intersection(final Hyperplane other) {\n+        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SUPPORTED_IN_DIMENSION_N, 1);\n+    }\n+\n+    /** Build a region covering the whole hyperplane.\n+     * <p>Since this class represent zero dimension spaces which does\n+     * not have lower dimension sub-spaces, this method returns a dummy\n+     * implementation of a {@link Region Region} (always the same\n+     * instance). This implementation is only used to allow the {@link\n+     * SubHyperplane SubHyperplane} class implementation to work\n+     * properly, it should <em>not</em> be used otherwise.</p>\n+     * @return a dummy region\n+     */\n+    public Region wholeHyperplane() {\n+        return DUMMY_REGION;\n+    }\n+\n+    /** Build a region covering the whole space.\n+     * @return a region containing the instance (really an {@link\n+     * IntervalsSet IntervalsSet} instance)\n+     */\n+    public Region wholeSpace() {\n+        return new IntervalsSet();\n+    }\n+\n+    /** Check if the instance has the same orientation as another hyperplane.\n+     * <p>This method is expected to be called on parallel hyperplanes\n+     * (i.e. when the {@link #side side} method would return {@link\n+     * org.apache.commons.math.geometry.partitioning.Hyperplane.Side#HYPER}\n+     * for some sub-hyperplane having the specified hyperplane\n+     * as its underlying hyperplane). The method should <em>not</em>\n+     * re-check for parallelism, only for orientation, typically by\n+     * testing something like the sign of the dot-products of\n+     * normals.</p>\n+     * @param other other hyperplane to check against the instance\n+     * @return true if the instance and the other hyperplane have\n+     * the same orientation\n+     */\n+    public boolean sameOrientationAs(final Hyperplane other) {\n+        return !(direct ^ ((OrientedPoint) other).direct);\n+    }\n+\n+    /** Compute the relative position of a sub-hyperplane with respect\n+     * to the instance.\n+     * @param sub sub-hyperplane to check\n+     * @return one of {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#PLUS PLUS},\n+     * {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#MINUS MINUS}\n+     * or {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#HYPER HYPER}\n+     * (in dimension 1, this method <em>never</em> returns {@link\n+     * org.apache.commons.math.geometry.partitioning.Hyperplane.Side#BOTH BOTH})\n+     *\n+     */\n+    public Side side(final SubHyperplane sub) {\n+        final double global = getOffset(((OrientedPoint) sub.getHyperplane()).location);\n+        return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n+    }\n+\n+    /** Split a sub-hyperplane in two parts by the instance.\n+     * @param sub sub-hyperplane to split\n+     * @return an object containing both the part of the sub-hyperplane\n+     * on the plus side of the instance and the part of the\n+     * sub-hyperplane on the minus side of the instance\n+     */\n+    public SplitSubHyperplane split(final SubHyperplane sub) {\n+        final double global = getOffset(((OrientedPoint) sub.getHyperplane()).location);\n+        return (global < -1.0e-10) ? new SplitSubHyperplane(null, sub) : new SplitSubHyperplane(sub, null);\n+    }\n+\n+    /** Get the hyperplane location on the real line.\n+     * @return the hyperplane location\n+     */\n+    public Point1D getLocation() {\n+        return location;\n+    }\n+\n+    /** Check if the hyperplane orientation is direct.\n+     * @return true if the plus side of the hyperplane is towards\n+     * abscissae greater than hyperplane location\n+     */\n+    public boolean isDirect() {\n+        return direct;\n+    }\n+\n+    /** Revert the instance.\n+     */\n+    public void revertSelf() {\n+        direct = !direct;\n+    }\n+\n+    /** Dummy region representing the whole set of reals. */\n+    private static class DummyRegion extends Region {\n+\n+        /** Simple constructor.\n+         */\n+        public DummyRegion() {\n+            super();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public Region buildNew(final BSPTree tree) {\n+            return this;\n+        }\n+\n+        /** {@inheritDoc} */\n+        protected void computeGeometricalProperties() {\n+            setSize(0);\n+            setBarycenter(Point1D.ZERO);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/oneD/Point1D.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.oneD;\n+\n+import org.apache.commons.math.geometry.partitioning.Point;\n+\n+/** This class represents a 1D point.\n+ * <p>Instances of this class are guaranteed to be immutable.</p>\n+ * @version $Revision$ $Date$\n+ */\n+public class Point1D implements Point {\n+\n+    /** Point at 0.0 abscissa. */\n+    public static final Point1D ZERO = new Point1D(0.0);\n+\n+    /** Point at 1.0 abscissa. */\n+    public static final Point1D ONE = new Point1D(1.0);\n+\n+    /** Point at undefined (NaN) abscissa. */\n+    public static final Point1D UNDEFINED = new Point1D(Double.NaN);\n+\n+    /** Abscissa of the point. */\n+    private double x;\n+\n+    /** Simple constructor.\n+     * @param x abscissa of the point\n+     */\n+    public Point1D(final double x) {\n+        this.x = x;\n+    }\n+\n+    /** Get the abscissa of the point.\n+     * @return abscissa of the point\n+     */\n+    public double getAbscissa() {\n+        return x;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threeD/CardanEulerSingularityException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+/** This class represents exceptions thrown while extractiong Cardan\n+ * or Euler angles from a rotation.\n+\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class CardanEulerSingularityException\n+  extends MathException {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -1360952845582206770L;\n+\n+    /**\n+     * Simple constructor.\n+     * build an exception with a default message.\n+     * @param isCardan if true, the rotation is related to Cardan angles,\n+     * if false it is related to EulerAngles\n+     */\n+    public CardanEulerSingularityException(boolean isCardan) {\n+        super(isCardan ? LocalizedFormats.CARDAN_ANGLES_SINGULARITY : LocalizedFormats.EULER_ANGLES_SINGULARITY);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threeD/Line.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+import org.apache.commons.math.geometry.euclidean.oneD.Point1D;\n+import org.apache.commons.math.geometry.partitioning.Point;\n+import org.apache.commons.math.geometry.partitioning.SubSpace;\n+import org.apache.commons.math.util.FastMath;\n+\n+/** The class represent lines in a three dimensional space.\n+\n+ * <p>Each oriented line is intrinsically associated with an abscissa\n+ * wich is a coordinate on the line. The point at abscissa 0 is the\n+ * orthogonal projection of the origin on the line, another equivalent\n+ * way to express this is to say that it is the point of the line\n+ * which is closest to the origin. Abscissa increases in the line\n+ * direction.</p>\n+\n+ * @version $Revision$ $Date$\n+ */\n+public class Line implements SubSpace {\n+\n+    /** Line direction. */\n+    private Vector3D direction;\n+\n+    /** Line point closest to the origin. */\n+    private Point3D zero;\n+\n+    /** Build a line from a point and a direction.\n+     * @param p point belonging to the line (this can be any point)\n+     * @param direction direction of the line\n+     * @exception IllegalArgumentException if the direction norm is too small\n+     */\n+    public Line(final Vector3D p, final Vector3D direction) {\n+        reset(p, direction);\n+    }\n+\n+    /** Reset the instance as if built from a point and a normal.\n+     * @param p point belonging to the line (this can be any point)\n+     * @param dir direction of the line\n+     * @exception IllegalArgumentException if the direction norm is too small\n+     */\n+    public void reset(final Vector3D p, final Vector3D dir) {\n+        final double norm = dir.getNorm();\n+        if (norm == 0.0) {\n+            throw new IllegalArgumentException(\"null norm\");\n+        }\n+        this.direction = new Vector3D(1.0 / norm, dir);\n+        zero = new Point3D(1.0, p, -Vector3D.dotProduct(p, this.direction), this.direction);\n+    }\n+\n+    /** Revert the line direction.\n+     */\n+    public void revertSelf() {\n+        direction = direction.negate();\n+    }\n+\n+    /** Get the normalized direction vector.\n+     * @return normalized direction vector\n+     */\n+    public Vector3D getDirection() {\n+        return direction;\n+    }\n+\n+    /** Get the abscissa of a point with respect to the line.\n+     * <p>The abscissa is 0 if the projection of the point and the\n+     * projection of the frame origin on the line are the same\n+     * point.</p>\n+     * @param point point to check (must be a {@link Vector3D Vector3D}\n+     * instance)\n+     * @return abscissa of the point (really a\n+     * {org.apache.commons.math.geometry.euclidean.oneD.Point1D Point1D} instance)\n+     */\n+    public Point toSubSpace(final Point point) {\n+        final double x = Vector3D.dotProduct(((Vector3D) point).subtract(zero), direction);\n+        return new Point1D(x);\n+    }\n+\n+    /** Get one point from the line.\n+     * @param point desired abscissa for the point (must be a\n+     * {org.apache.commons.math.geometry.euclidean.oneD.Point1D Point1D} instance)\n+     * @return one point belonging to the line, at specified abscissa\n+     * (really a {@link Vector3D Vector3D} instance)\n+     */\n+    public Point toSpace(final Point point) {\n+        return new Point3D(1.0, zero, ((Point1D) point).getAbscissa(), direction);\n+    }\n+\n+    /** Check if the instance is similar to another line.\n+     * <p>Lines are considered similar if they contain the same\n+     * points. This does not mean they are equal since they can have\n+     * opposite directions.</p>\n+     * @param line line to which instance should be compared\n+     * @return true if the lines are similar\n+     */\n+    public boolean isSimilarTo(final Line line) {\n+        final double angle = Vector3D.angle(direction, line.direction);\n+        return ((angle < 1.0e-10) || (angle > (FastMath.PI - 1.0e-10))) && contains(line.zero);\n+    }\n+\n+    /** Check if the instance contains a point.\n+     * @param p point to check\n+     * @return true if p belongs to the line\n+     */\n+    public boolean contains(final Vector3D p) {\n+        return distance(p) < 1.0e-10;\n+    }\n+\n+    /** Compute the distance between the instance and a point.\n+     * @param p to check\n+     * @return distance between the instance and the point\n+     */\n+    public double distance(final Vector3D p) {\n+        final Vector3D d = p.subtract(zero);\n+        final Vector3D n = new Vector3D(1.0, d, -Vector3D.dotProduct(d, direction), direction);\n+        return n.getNorm();\n+    }\n+\n+    /** Compute the shortest distance between the instance and another line.\n+     * @param line line to check agains the instance\n+     * @return shortest distance between the instance and the line\n+     */\n+    public double distance(final Line line) {\n+\n+        final Vector3D normal = Vector3D.crossProduct(direction, line.direction);\n+        if (normal.getNorm() < 1.0e-10) {\n+            // lines are parallel\n+            return distance(line.zero);\n+        }\n+\n+        // separating middle plane\n+        final Plane middle = new Plane(new Vector3D(0.5, zero, 0.5, line.zero), normal);\n+\n+        // the lines are at the same distance on either side of the plane\n+        return 2 * FastMath.abs(middle.getOffset(zero));\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threeD/NotARotationMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.exception.util.Localizable;\n+\n+/**\n+ * This class represents exceptions thrown while building rotations\n+ * from matrices.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class NotARotationMatrixException\n+  extends MathException {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 5647178478658937642L;\n+\n+    /**\n+     * Simple constructor.\n+     * Build an exception by translating and formating a message\n+     * @param specifier format specifier (to be translated)\n+     * @param parts to insert in the format (no translation)\n+     * @since 2.2\n+     */\n+    public NotARotationMatrixException(Localizable specifier, Object ... parts) {\n+        super(specifier, parts);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threeD/OutlineExtractor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+import org.apache.commons.math.geometry.euclidean.twoD.Point2D;\n+import org.apache.commons.math.geometry.euclidean.twoD.PolygonsSet;\n+import org.apache.commons.math.geometry.partitioning.BSPTree;\n+import org.apache.commons.math.geometry.partitioning.BSPTreeVisitor;\n+import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n+import org.apache.commons.math.util.FastMath;\n+\n+import java.util.ArrayList;\n+\n+/** Extractor for {@link PolygonsSet polyhedrons sets} outlines.\n+ * <p>This class extracts the 2D outlines from {{@link PolygonsSet\n+ * polyhedrons sets} in a specified projection plane.</p>\n+ * @version $Revision$ $Date$\n+ */\n+public class OutlineExtractor {\n+\n+    /** Abscissa axis of the projection plane. */\n+    private Vector3D u;\n+\n+    /** Ordinate axis of the projection plane. */\n+    private Vector3D v;\n+\n+    /** Normal of the projection plane (viewing direction). */\n+    private Vector3D w;\n+\n+    /** Build an extractor for a specific projection plane.\n+     * @param u abscissa axis of the projection point\n+     * @param v ordinate axis of the projection point\n+     */\n+    public OutlineExtractor(final Vector3D u, final Vector3D v) {\n+        this.u = u;\n+        this.v = v;\n+        w = Vector3D.crossProduct(u, v);\n+    }\n+\n+    /** Extract the outline of a polyhedrons set.\n+     * @param polyhedronsSet polyhedrons set whose outline must be extracted\n+     * @return an outline, as an array of loops.\n+     */\n+    public Point2D[][] getOutline(final PolyhedronsSet polyhedronsSet) {\n+\n+        // project all boundary facets into one polygons set\n+        final BoundaryProjector projector = new BoundaryProjector();\n+        polyhedronsSet.getTree(true).visit(projector);\n+        final PolygonsSet projected = projector.getProjected();\n+\n+        // Remove the spurious intermediate vertices from the outline\n+        final Point2D[][] outline = projected.getVertices();\n+        for (int i = 0; i < outline.length; ++i) {\n+            final Point2D[] rawLoop = outline[i];\n+            int end = rawLoop.length;\n+            int j = 0;\n+            while (j < end) {\n+                if (pointIsBetween(rawLoop, end, j)) {\n+                    // the point should be removed\n+                    for (int k = j; k < (end - 1); ++k) {\n+                        rawLoop[k] = rawLoop[k + 1];\n+                    }\n+                    --end;\n+                } else {\n+                    // the point remains in the loop\n+                    ++j;\n+                }\n+            }\n+            if (end != rawLoop.length) {\n+                // resize the array\n+                outline[i] = new Point2D[end];\n+                System.arraycopy(rawLoop, 0, outline[i], 0, end);\n+            }\n+        }\n+\n+        return outline;\n+\n+    }\n+\n+    /** Check if a point is geometrically between its neighbour in an array.\n+     * <p>The neighbours are computed considering the array is a loop\n+     * (i.e. point at index (n-1) is before point at index 0)</p>\n+     * @param loop points array\n+     * @param n number of points to consider in the array\n+     * @param i index of the point to check (must be between 0 and n-1)\n+     * @return true if the point is exactly between its neighbours\n+     */\n+    private boolean pointIsBetween(final Point2D[] loop, final int n, final int i) {\n+        final Point2D previous = loop[(i + n - 1) % n];\n+        final Point2D current  = loop[i];\n+        final Point2D next     = loop[(i + 1) % n];\n+        final double dx1       = current.x - previous.x;\n+        final double dy1       = current.y - previous.y;\n+        final double dx2       = next.x    - current.x;\n+        final double dy2       = next.y    - current.y;\n+        final double cross     = dx1 * dy2 - dx2 * dy1;\n+        final double dot       = dx1 * dx2 + dy1 * dy2;\n+        final double d1d2      = FastMath.sqrt((dx1 * dx1 + dy1 * dy1) * (dx2 * dx2 + dy2 * dy2));\n+        return (FastMath.abs(cross) <= (1.0e-6 * d1d2)) && (dot >= 0.0);\n+    }\n+\n+    /** Visitor projecting the boundary facets on a plane. */\n+    private class BoundaryProjector implements BSPTreeVisitor {\n+\n+        /** Projection of the polyhedrons set on the plane. */\n+        private PolygonsSet projected;\n+\n+        /** Simple constructor.\n+         */\n+        public BoundaryProjector() {\n+            projected = new PolygonsSet(new BSPTree(Boolean.FALSE));\n+        }\n+\n+        /** {@inheritDoc} */\n+        public Order visitOrder(final BSPTree node) {\n+            return Order.MINUS_SUB_PLUS;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void visitInternalNode(final BSPTree node) {\n+            final Region.BoundaryAttribute attribute =\n+                (Region.BoundaryAttribute) node.getAttribute();\n+            if (attribute.getPlusOutside() != null) {\n+                addContribution(attribute.getPlusOutside(), false);\n+            }\n+            if (attribute.getPlusInside() != null) {\n+                addContribution(attribute.getPlusInside(), true);\n+            }\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void visitLeafNode(final BSPTree node) {\n+        }\n+\n+        /** Add he contribution of a boundary facet.\n+         * @param facet boundary facet\n+         * @param reversed if true, the facet has the inside on its plus side\n+         */\n+        private void addContribution(final SubHyperplane facet, final boolean reversed) {\n+\n+            // extract the vertices of the facet\n+            final Plane plane    = (Plane) facet.getHyperplane();\n+            Point2D[][] vertices =\n+                ((PolygonsSet) facet.getRemainingRegion()).getVertices();\n+\n+            final double scal = Vector3D.dotProduct(plane.getNormal(), w);\n+            if (FastMath.abs(scal) > 1.0e-3) {\n+\n+                if ((scal < 0) ^ reversed) {\n+                    // the facet is seen from the inside,\n+                    // we need to invert its boundary orientation\n+                    final Point2D[][] newVertices = new Point2D[vertices.length][];\n+                    for (int i = 0; i < vertices.length; ++i) {\n+                        final Point2D[] loop = vertices[i];\n+                        final Point2D[] newLoop = new Point2D[loop.length];\n+                        if (loop[0] == null) {\n+                            newLoop[0] = null;\n+                            for (int j = 1; j < loop.length; ++j) {\n+                                newLoop[j] = loop[loop.length - j];\n+                            }\n+                        } else {\n+                            for (int j = 0; j < loop.length; ++j) {\n+                                newLoop[j] = loop[loop.length - (j + 1)];\n+                            }\n+                        }\n+                        newVertices[i] = newLoop;\n+                    }\n+\n+                    // use the reverted vertices\n+                    vertices = newVertices;\n+\n+                }\n+\n+                // compute the projection of the facet in the outline plane\n+                final ArrayList<SubHyperplane> edges = new ArrayList<SubHyperplane>();\n+                for (Point2D[] loop : vertices) {\n+                    final boolean closed = loop[0] != null;\n+                    int previous         = closed ? (loop.length - 1) : 1;\n+                    Vector3D previous3D  = (Vector3D) plane.toSpace(loop[previous]);\n+                    int current          = (previous + 1) % loop.length;\n+                    Point2D pPoint       = new Point2D(Vector3D.dotProduct(previous3D, u),\n+                                                       Vector3D.dotProduct(previous3D, v));\n+                    while (current < loop.length) {\n+\n+                        final Vector3D current3D = (Vector3D) plane.toSpace(loop[current]);\n+                        final Point2D  cPoint    = new Point2D(Vector3D.dotProduct(current3D, u),\n+                                                               Vector3D.dotProduct(current3D, v));\n+                        final org.apache.commons.math.geometry.euclidean.twoD.Line line =\n+                            new org.apache.commons.math.geometry.euclidean.twoD.Line(pPoint, cPoint);\n+                        SubHyperplane edge = new SubHyperplane(line);\n+\n+                        if (closed || (previous != 1)) {\n+                            // the previous point is a real vertex\n+                            // it defines one bounding point of the edge\n+                            final double angle = line.getAngle() + 0.5 * FastMath.PI;\n+                            final org.apache.commons.math.geometry.euclidean.twoD.Line l =\n+                                new org.apache.commons.math.geometry.euclidean.twoD.Line(pPoint, angle);\n+                            edge = l.split(edge).getPlus();\n+                        }\n+\n+                        if (closed || (current != (loop.length - 1))) {\n+                            // the current point is a real vertex\n+                            // it defines one bounding point of the edge\n+                            final double angle = line.getAngle() + 0.5 * FastMath.PI;\n+                            final org.apache.commons.math.geometry.euclidean.twoD.Line l =\n+                                new org.apache.commons.math.geometry.euclidean.twoD.Line(cPoint, angle);\n+                            edge = l.split(edge).getMinus();\n+                        }\n+\n+                        edges.add(edge);\n+\n+                        previous   = current++;\n+                        previous3D = current3D;\n+                        pPoint     = cPoint;\n+\n+                    }\n+                }\n+                final PolygonsSet projectedFacet = new PolygonsSet(edges);\n+\n+                // add the contribution of the facet to the global outline\n+                projected = (PolygonsSet) Region.union(projected, projectedFacet);\n+\n+            }\n+        }\n+\n+        /** Get the projecion of the polyhedrons set on the plane.\n+         * @return projecion of the polyhedrons set on the plane\n+         */\n+        public PolygonsSet getProjected() {\n+            return projected;\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threeD/Plane.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+import org.apache.commons.math.geometry.euclidean.oneD.Point1D;\n+import org.apache.commons.math.geometry.euclidean.twoD.Point2D;\n+import org.apache.commons.math.geometry.euclidean.twoD.PolygonsSet;\n+import org.apache.commons.math.geometry.partitioning.BSPTree;\n+import org.apache.commons.math.geometry.partitioning.Hyperplane;\n+import org.apache.commons.math.geometry.partitioning.Point;\n+import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n+import org.apache.commons.math.geometry.partitioning.SubSpace;\n+import org.apache.commons.math.util.FastMath;\n+\n+/** The class represent planes in a three dimensional space.\n+ * @version $Revision$ $Date$\n+ */\n+public class Plane implements Hyperplane {\n+\n+    /** Offset of the origin with respect to the plane. */\n+    private double originOffset;\n+\n+    /** Origin of the plane frame. */\n+    private Point3D origin;\n+\n+    /** First vector of the plane frame (in plane). */\n+    private Vector3D u;\n+\n+    /** Second vector of the plane frame (in plane). */\n+    private Vector3D v;\n+\n+    /** Third vector of the plane frame (plane normal). */\n+    private Vector3D w;\n+\n+    /** Build a plane normal to a given direction and containing the origin.\n+     * @param normal normal direction to the plane\n+     * @exception IllegalArgumentException if the normal norm is too small\n+     */\n+    public Plane(final Vector3D normal) {\n+        setNormal(normal);\n+        originOffset = 0;\n+        setFrame();\n+    }\n+\n+    /** Build a plane from a point and a normal.\n+     * @param p point belonging to the plane\n+     * @param normal normal direction to the plane\n+     * @exception IllegalArgumentException if the normal norm is too small\n+     */\n+    public Plane(final Vector3D p, final Vector3D normal) {\n+        setNormal(normal);\n+        originOffset = -Vector3D.dotProduct(p, w);\n+        setFrame();\n+    }\n+\n+    /** Build a plane from three points.\n+     * <p>The plane is oriented in the direction of\n+     * {@code (p2-p1) ^ (p3-p1)}</p>\n+     * @param p1 first point belonging to the plane\n+     * @param p2 second point belonging to the plane\n+     * @param p3 third point belonging to the plane\n+     * @exception IllegalArgumentException if the points do not constitute a plane\n+     */\n+    public Plane(final Vector3D p1, final Vector3D p2, final Vector3D p3) {\n+        this(p1, Vector3D.crossProduct(p2.subtract(p1), p3.subtract(p1)));\n+    }\n+\n+    /** Copy constructor.\n+     * <p>The instance created is completely independant of the original\n+     * one. A deep copy is used, none of the underlying object are\n+     * shared.</p>\n+     * @param plane plane to copy\n+     */\n+    public Plane(final Plane plane) {\n+        originOffset = plane.originOffset;\n+        origin = plane.origin;\n+        u      = plane.u;\n+        v      = plane.v;\n+        w      = plane.w;\n+    }\n+\n+    /** Copy the instance.\n+     * <p>The instance created is completely independant of the original\n+     * one. A deep copy is used, none of the underlying objects are\n+     * shared (except for immutable objects).</p>\n+     * @return a new hyperplane, copy of the instance\n+     */\n+    public Hyperplane copySelf() {\n+        return new Plane(this);\n+    }\n+\n+    /** Reset the instance as if built from a point and a normal.\n+     * @param p point belonging to the plane\n+     * @param normal normal direction to the plane\n+     */\n+    public void reset(final Vector3D p, final Vector3D normal) {\n+        setNormal(normal);\n+        originOffset = -Vector3D.dotProduct(p, w);\n+        setFrame();\n+    }\n+\n+    /** Reset the instance from another one.\n+     * <p>The updated instance is completely independant of the original\n+     * one. A deep reset is used none of the underlying object is\n+     * shared.</p>\n+     * @param original plane to reset from\n+     */\n+    public void reset(final Plane original) {\n+        originOffset = original.originOffset;\n+        origin       = original.origin;\n+        u            = original.u;\n+        v            = original.v;\n+        w            = original.w;\n+    }\n+\n+    /** Set the normal vactor.\n+     * @param normal normal direction to the plane (will be copied)\n+     * @exception IllegalArgumentException if the normal norm is too small\n+     */\n+    private void setNormal(final Vector3D normal) {\n+        final double norm = normal.getNorm();\n+        if (norm < 1.0e-10) {\n+            throw new IllegalArgumentException(\"null norm\");\n+        }\n+        w = new Vector3D(1.0 / norm, normal);\n+    }\n+\n+    /** Reset the plane frame.\n+     */\n+    private void setFrame() {\n+        origin = new Point3D(-originOffset, w);\n+        u = w.orthogonal();\n+        v = Vector3D.crossProduct(w, u);\n+    }\n+\n+    /** Get the origin point of the plane frame.\n+     * <p>The point returned is the orthogonal projection of the\n+     * 3D-space origin in the plane.</p>\n+     * @return the origin point of the plane frame (point closest to the\n+     * 3D-space origin)\n+     */\n+    public Point3D getOrigin() {\n+        return origin;\n+    }\n+\n+    /** Get the normalized normal vector.\n+     * <p>The frame defined by ({@link #getU getU}, {@link #getV getV},\n+     * {@link #getNormal getNormal}) is a rigth-handed orthonormalized\n+     * frame).</p>\n+     * @return normalized normal vector\n+     * @see #getU\n+     * @see #getV\n+     */\n+    public Vector3D getNormal() {\n+        return w;\n+    }\n+\n+    /** Get the plane first canonical vector.\n+     * <p>The frame defined by ({@link #getU getU}, {@link #getV getV},\n+     * {@link #getNormal getNormal}) is a rigth-handed orthonormalized\n+     * frame).</p>\n+     * @return normalized first canonical vector\n+     * @see #getV\n+     * @see #getNormal\n+     */\n+    public Vector3D getU() {\n+        return u;\n+    }\n+\n+    /** Get the plane second canonical vector.\n+     * <p>The frame defined by ({@link #getU getU}, {@link #getV getV},\n+     * {@link #getNormal getNormal}) is a rigth-handed orthonormalized\n+     * frame).</p>\n+     * @return normalized second canonical vector\n+     * @see #getU\n+     * @see #getNormal\n+     */\n+    public Vector3D getV() {\n+        return v;\n+    }\n+\n+    /** Revert the plane.\n+     * <p>Replace the instance by a similar plane with opposite orientation.</p>\n+     * <p>The new plane frame is chosen in such a way that a 3D point that had\n+     * {@code (x, y)} in-plane coordinates and {@code z} offset with\n+     * respect to the plane and is unaffected by the change will have\n+     * {@code (y, x)} in-plane coordinates and {@code -z} offset with\n+     * respect to the new plane. This means that the {@code u} and {@code v}\n+     * vectors returned by the {@link #getU} and {@link #getV} methods are exchanged,\n+     * and the {@code w} vector returned by the {@link #getNormal} method is\n+     * reversed.</p>\n+     */\n+    public void revertSelf() {\n+        final Vector3D tmp = u;\n+        u = v;\n+        v = tmp;\n+        w = w.negate();\n+        originOffset = -originOffset;\n+    }\n+\n+    /** Transform a 3D space point into an in-plane point.\n+     * @param point point of the space (must be a {@link Vector3D\n+     * Vector3D} instance)\n+     * @return in-plane point (really a {@link\n+     * org.apache.commons.math.geometry.euclidean.twoD.Point2D Point2D} instance)\n+     * @see #toSpace\n+     */\n+    public Point toSubSpace(final Point point) {\n+        final Vector3D p3D = (Vector3D) point;\n+        return new Point2D(Vector3D.dotProduct(p3D, u),\n+                           Vector3D.dotProduct(p3D, v));\n+    }\n+\n+    /** Transform an in-plane point into a 3D space point.\n+     * @param point in-plane point (must be a {@link\n+     * org.apache.commons.math.geometry.euclidean.twoD.Point2D Point2D} instance)\n+     * @return 3D space point (really a {@link Vector3D Vector3D} instance)\n+     * @see #toSubSpace\n+     */\n+    public Point toSpace(final Point point) {\n+        final Point2D p2D = (Point2D) point;\n+        return new Point3D(p2D.x, u, p2D.y, v, -originOffset, w);\n+    }\n+\n+    /** Get one point from the 3D-space.\n+     * @param inPlane desired in-plane coordinates for the point in the\n+     * plane\n+     * @param offset desired offset for the point\n+     * @return one point in the 3D-space, with given coordinates and offset\n+     * relative to the plane\n+     */\n+    public Vector3D getPointAt(final Point2D inPlane, final double offset) {\n+        return new Vector3D(inPlane.x, u, inPlane.y, v, offset - originOffset, w);\n+    }\n+\n+    /** Check if the instance is similar to another plane.\n+     * <p>Planes are considered similar if they contain the same\n+     * points. This does not mean they are equal since they can have\n+     * opposite normals.</p>\n+     * @param plane plane to which the instance is compared\n+     * @return true if the planes are similar\n+     */\n+    public boolean isSimilarTo(final Plane plane) {\n+        final double angle = Vector3D.angle(w, plane.w);\n+        return ((angle < 1.0e-10) && (FastMath.abs(originOffset - plane.originOffset) < 1.0e-10)) ||\n+               ((angle > (FastMath.PI - 1.0e-10)) && (FastMath.abs(originOffset + plane.originOffset) < 1.0e-10));\n+    }\n+\n+    /** Rotate the plane around the specified point.\n+     * <p>The instance is not modified, a new instance is created.</p>\n+     * @param center rotation center\n+     * @param rotation vectorial rotation operator\n+     * @return a new plane\n+     */\n+    public Plane rotate(final Vector3D center, final Rotation rotation) {\n+\n+        final Vector3D delta = origin.subtract(center);\n+        final Plane plane = new Plane(center.add(rotation.applyTo(delta)),\n+                                rotation.applyTo(w));\n+\n+        // make sure the frame is transformed as desired\n+        plane.u = rotation.applyTo(u);\n+        plane.v = rotation.applyTo(v);\n+\n+        return plane;\n+\n+    }\n+\n+    /** Translate the plane by the specified amount.\n+     * <p>The instance is not modified, a new instance is created.</p>\n+     * @param translation translation to apply\n+     * @return a new plane\n+     */\n+    public Plane translate(final Vector3D translation) {\n+\n+        final Plane plane = new Plane(origin.add(translation), w);\n+\n+        // make sure the frame is transformed as desired\n+        plane.u = u;\n+        plane.v = v;\n+\n+        return plane;\n+\n+    }\n+\n+    /** Get the intersection of a line with the instance.\n+     * @param line line intersecting the instance\n+     * @return intersection point between between the line and the\n+     * instance (null if the line is parallel to the instance)\n+     */\n+    public Point3D intersection(final Line line) {\n+        final Vector3D direction = line.getDirection();\n+        final double   dot       = Vector3D.dotProduct(w, direction);\n+        if (FastMath.abs(dot) < 1.0e-10) {\n+            return null;\n+        }\n+        final Vector3D point = (Vector3D) line.toSpace(Point1D.ZERO);\n+        final double   k     = -(originOffset + Vector3D.dotProduct(w, point)) / dot;\n+        return new Point3D(1.0, point, k, direction);\n+    }\n+\n+    /** Build the line shared by the instance and another plane.\n+     * @param other other plane\n+     * @return line at the intersection of the instance and the\n+     * other plane (really a {@link Line Line} instance)\n+     */\n+    public SubSpace intersection(final Hyperplane other) {\n+        final Plane otherP = (Plane) other;\n+        final Vector3D direction = Vector3D.crossProduct(w, otherP.w);\n+        if (direction.getNorm() < 1.0e-10) {\n+            return null;\n+        }\n+        return new Line(intersection(this, otherP, new Plane(direction)),\n+                        direction);\n+    }\n+\n+    /** Get the intersection point of three planes.\n+     * @param plane1 first plane1\n+     * @param plane2 second plane2\n+     * @param plane3 third plane2\n+     * @return intersection point of three planes, null if some planes are parallel\n+     */\n+    public static Vector3D intersection(final Plane plane1, final Plane plane2, final Plane plane3) {\n+\n+        // coefficients of the three planes linear equations\n+        final double a1 = plane1.w.getX();\n+        final double b1 = plane1.w.getY();\n+        final double c1 = plane1.w.getZ();\n+        final double d1 = plane1.originOffset;\n+\n+        final double a2 = plane2.w.getX();\n+        final double b2 = plane2.w.getY();\n+        final double c2 = plane2.w.getZ();\n+        final double d2 = plane2.originOffset;\n+\n+        final double a3 = plane3.w.getX();\n+        final double b3 = plane3.w.getY();\n+        final double c3 = plane3.w.getZ();\n+        final double d3 = plane3.originOffset;\n+\n+        // direct Cramer resolution of the linear system\n+        // (this is still feasible for a 3x3 system)\n+        final double a23         = b2 * c3 - b3 * c2;\n+        final double b23         = c2 * a3 - c3 * a2;\n+        final double c23         = a2 * b3 - a3 * b2;\n+        final double determinant = a1 * a23 + b1 * b23 + c1 * c23;\n+        if (FastMath.abs(determinant) < 1.0e-10) {\n+            return null;\n+        }\n+\n+        final double r = 1.0 / determinant;\n+        return new Vector3D(\n+                            (-a23 * d1 - (c1 * b3 - c3 * b1) * d2 - (c2 * b1 - c1 * b2) * d3) * r,\n+                            (-b23 * d1 - (c3 * a1 - c1 * a3) * d2 - (c1 * a2 - c2 * a1) * d3) * r,\n+                            (-c23 * d1 - (b1 * a3 - b3 * a1) * d2 - (b2 * a1 - b1 * a2) * d3) * r);\n+\n+    }\n+\n+    /** Build a region covering the whole hyperplane.\n+     * @return a region covering the whole hyperplane\n+     */\n+    public Region wholeHyperplane() {\n+        return new PolygonsSet();\n+    }\n+\n+    /** Build a region covering the whole space.\n+     * @return a region containing the instance (really a {@link\n+     * PolyhedronsSet PolyhedronsSet} instance)\n+     */\n+    public Region wholeSpace() {\n+        return new PolyhedronsSet();\n+    }\n+\n+    /** Check if the instance contains a point.\n+     * @param p point to check\n+     * @return true if p belongs to the plane\n+     */\n+    public boolean contains(final Point3D p) {\n+        return FastMath.abs(getOffset(p)) < 1.0e-10;\n+    }\n+\n+    /** Get the offset (oriented distance) of a parallel plane.\n+     * <p>This method should be called only for parallel planes otherwise\n+     * the result is not meaningful.</p>\n+     * <p>The offset is 0 if both planes are the same, it is\n+     * positive if the plane is on the plus side of the instance and\n+     * negative if it is on the minus side, according to its natural\n+     * orientation.</p>\n+     * @param plane plane to check\n+     * @return offset of the plane\n+     */\n+    public double getOffset(final Plane plane) {\n+        return originOffset + (sameOrientationAs(plane) ? -plane.originOffset : plane.originOffset);\n+    }\n+\n+    /** Get the offset (oriented distance) of a point.\n+     * <p>The offset is 0 if the point is on the underlying hyperplane,\n+     * it is positive if the point is on one particular side of the\n+     * hyperplane, and it is negative if the point is on the other side,\n+     * according to the hyperplane natural orientation.</p>\n+     * @param point point to check\n+     * @return offset of the point\n+     */\n+    public double getOffset(final Point point) {\n+        return Vector3D.dotProduct((Vector3D) point, w) + originOffset;\n+    }\n+\n+    /** Check if the instance has the same orientation as another hyperplane.\n+     * @param other other hyperplane to check against the instance\n+     * @return true if the instance and the other hyperplane have\n+     * the same orientation\n+     */\n+    public boolean sameOrientationAs(final Hyperplane other) {\n+        return Vector3D.dotProduct(((Plane) other).w, w) > 0.0;\n+    }\n+\n+    /** Compute the relative position of a sub-hyperplane with respect\n+     * to the instance.\n+     * @param sub sub-hyperplane to check\n+     * @return one of {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#PLUS PLUS},\n+     * {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#MINUS MINUS},\n+     * {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#BOTH BOTH},\n+     * {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#HYPER HYPER}\n+     */\n+    public Side side(final SubHyperplane sub) {\n+\n+        final Plane otherPlane = (Plane) sub.getHyperplane();\n+        final Line  inter      = (Line) intersection(otherPlane);\n+\n+        if (inter == null) {\n+            // the hyperplanes are parallel,\n+            // any point can be used to check their relative position\n+            final double global = getOffset(otherPlane);\n+            return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n+        }\n+\n+        // create a 2D line in the otherPlane canonical 2D frame such that:\n+        //   - the line is the crossing line of the two planes in 3D\n+        //   - the line splits the otherPlane in two half planes with an\n+        //     orientation consistent with the orientation of the instance\n+        //     (i.e. the 3D half space on the plus side (resp. minus side)\n+        //      of the instance contains the 2D half plane on the plus side\n+        //      (resp. minus side) of the 2D line\n+        Point2D p = (Point2D) otherPlane.toSubSpace(inter.toSpace(Point1D.ZERO));\n+        Point2D q = (Point2D) otherPlane.toSubSpace(inter.toSpace(Point1D.ONE));\n+        if (Vector3D.dotProduct(Vector3D.crossProduct(inter.getDirection(),\n+                                                      otherPlane.getNormal()),\n+                                                      w) < 0) {\n+            final Point2D tmp = p;\n+            p           = q;\n+            q           = tmp;\n+        }\n+        final Hyperplane line2D = new org.apache.commons.math.geometry.euclidean.twoD.Line(p, q);\n+\n+        // check the side on the 2D plane\n+        return sub.getRemainingRegion().side(line2D);\n+\n+    }\n+\n+    /** Split a sub-hyperplane in two parts by the instance.\n+     * @param sub sub-hyperplane to split\n+     * @return an object containing both the part of the sub-hyperplane\n+     * on the plus side of the instance and the part of the\n+     * sub-hyperplane on the minus side of the instance\n+     */\n+    public SplitSubHyperplane split(final SubHyperplane sub) {\n+\n+        final Plane otherPlane = (Plane) sub.getHyperplane();\n+        final Line  inter      = (Line) intersection(otherPlane);\n+\n+        if (inter == null) {\n+            // the hyperplanes are parallel\n+            final double global = getOffset(otherPlane);\n+            return (global < -1.0e-10) ? new SplitSubHyperplane(null, sub) : new SplitSubHyperplane(sub, null);\n+        }\n+\n+        // the hyperplanes do intersect\n+        Point2D p = (Point2D) otherPlane.toSubSpace(inter.toSpace(Point1D.ZERO));\n+        Point2D q = (Point2D) otherPlane.toSubSpace(inter.toSpace(Point1D.ONE));\n+        if (Vector3D.dotProduct(Vector3D.crossProduct(inter.getDirection(),\n+                                                      otherPlane.getNormal()),\n+                                                      w) < 0) {\n+            final Point2D tmp = p;\n+            p           = q;\n+            q           = tmp;\n+        }\n+        final SubHyperplane l2DMinus =\n+            new SubHyperplane(new org.apache.commons.math.geometry.euclidean.twoD.Line(p, q));\n+        final SubHyperplane l2DPlus =\n+            new SubHyperplane(new org.apache.commons.math.geometry.euclidean.twoD.Line(q, p));\n+\n+        final BSPTree splitTree =\n+            sub.getRemainingRegion().getTree(false).split(l2DMinus);\n+        final BSPTree plusTree  = Region.isEmpty(splitTree.getPlus()) ?\n+                                  new BSPTree(Boolean.FALSE) :\n+                                  new BSPTree(l2DPlus, new BSPTree(Boolean.FALSE),\n+                                              splitTree.getPlus(), null);\n+\n+        final BSPTree minusTree = Region.isEmpty(splitTree.getMinus()) ?\n+                                  new BSPTree(Boolean.FALSE) :\n+                                  new BSPTree(l2DMinus, new BSPTree(Boolean.FALSE),\n+                                              splitTree.getMinus(), null);\n+\n+        return new SplitSubHyperplane(new SubHyperplane(otherPlane.copySelf(),\n+                                                        new PolygonsSet(plusTree)),\n+                                                        new SubHyperplane(otherPlane.copySelf(),\n+                                                                          new PolygonsSet(minusTree)));\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threeD/Point3D.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+import org.apache.commons.math.geometry.partitioning.Point;\n+\n+/** This class represents a 3D point.\n+ * <p>Instances of this class are guaranteed to be immutable.</p>\n+ * @version $Revision$ $Date$\n+ */\n+public class Point3D extends Vector3D implements Point {\n+\n+    /** Point at undefined (NaN) coordinates. */\n+    public static final Point3D UNDEFINED = new Point3D(Double.NaN, Double.NaN, Double.NaN);\n+\n+    /** Serializable UID. */\n+    private static final long serialVersionUID = 9128130934224884451L;\n+\n+    /** Simple constructor.\n+     * Build a vector from its coordinates\n+     * @param x abscissa\n+     * @param y ordinate\n+     * @param z height\n+     * @see #getX()\n+     * @see #getY()\n+     * @see #getZ()\n+     */\n+    public Point3D(final double x, final double y, final double z) {\n+        super(x, y, z);\n+    }\n+\n+    /** Simple constructor.\n+     * Build a vector from its azimuthal coordinates\n+     * @param alpha azimuth (&alpha;) around Z\n+     *              (0 is +X, &pi;/2 is +Y, &pi; is -X and 3&pi;/2 is -Y)\n+     * @param delta elevation (&delta;) above (XY) plane, from -&pi;/2 to +&pi;/2\n+     * @see #getAlpha()\n+     * @see #getDelta()\n+     */\n+    public Point3D(final double alpha, final double delta) {\n+        super(alpha, delta);\n+    }\n+\n+    /** Multiplicative constructor\n+     * Build a vector from another one and a scale factor.\n+     * The vector built will be a * u\n+     * @param a scale factor\n+     * @param u base (unscaled) vector\n+     */\n+    public Point3D(final double a, final Vector3D u) {\n+        super(a, u);\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from two other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     */\n+    public Point3D(final double a1, final Vector3D u1, final double a2, final Vector3D u2) {\n+        super(a1, u1, a2, u2);\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from three other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     */\n+    public Point3D(final double a1, final Vector3D u1, final double a2, final Vector3D u2,\n+                   final double a3, final Vector3D u3) {\n+        super(a1, u1, a2, u2, a3, u3);\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from four other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     * @param a4 fourth scale factor\n+     * @param u4 fourth base (unscaled) vector\n+     */\n+    public Point3D(final double a1, final Vector3D u1, final double a2, final Vector3D u2,\n+                   final double a3, final Vector3D u3, final double a4, final Vector3D u4) {\n+        super(a1, u1, a2, u2, a3, u3, a4, u4);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threeD/PolyhedronsSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+import java.awt.geom.AffineTransform;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.apache.commons.math.geometry.euclidean.twoD.Point2D;\n+import org.apache.commons.math.geometry.partitioning.BSPTree;\n+import org.apache.commons.math.geometry.partitioning.BSPTreeVisitor;\n+import org.apache.commons.math.geometry.partitioning.Hyperplane;\n+import org.apache.commons.math.geometry.partitioning.Point;\n+import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n+import org.apache.commons.math.geometry.partitioning.Transform;\n+import org.apache.commons.math.util.FastMath;\n+\n+/** This class represents a 3D region: a set of polyhedrons.\n+ * @version $Revision$ $Date$\n+ */\n+public class PolyhedronsSet extends Region {\n+\n+    /** Build a polyhedrons set representing the whole real line.\n+     */\n+    public PolyhedronsSet() {\n+        super();\n+    }\n+\n+    /** Build a polyhedrons set from a BSP tree.\n+     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n+     * {@code Boolean} attribute representing the inside status of\n+     * the corresponding cell (true for inside cells, false for outside\n+     * cells). In order to avoid building too many small objects, it is\n+     * recommended to use the predefined constants\n+     * {@code Boolean.TRUE} and {@code Boolean.FALSE}</p>\n+     * @param tree inside/outside BSP tree representing the region\n+     */\n+    public PolyhedronsSet(final BSPTree tree) {\n+        super(tree);\n+    }\n+\n+    /** Build a polyhedrons set from a Boundary REPresentation (B-rep).\n+     * <p>The boundary is provided as a collection of {@link\n+     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the\n+     * interior part of the region on its minus side and the exterior on\n+     * its plus side.</p>\n+     * <p>The boundary elements can be in any order, and can form\n+     * several non-connected sets (like for example polyhedrons with holes\n+     * or a set of disjoints polyhedrons considered as a whole). In\n+     * fact, the elements do not even need to be connected together\n+     * (their topological connections are not used here). However, if the\n+     * boundary does not really separate an inside open from an outside\n+     * open (open having here its topological meaning), then subsequent\n+     * calls to the {@link Region#checkPoint(Point) checkPoint} method will\n+     * not be meaningful anymore.</p>\n+     * <p>If the boundary is empty, the region will represent the whole\n+     * space.</p>\n+     * @param boundary collection of boundary elements, as a\n+     * collection of {@link SubHyperplane SubHyperplane} objects\n+     */\n+    public PolyhedronsSet(final Collection<SubHyperplane> boundary) {\n+        super(boundary);\n+    }\n+\n+    /** Build a parallellepipedic box.\n+     * @param xMin low bound along the x direction\n+     * @param xMax high bound along the x direction\n+     * @param yMin low bound along the y direction\n+     * @param yMax high bound along the y direction\n+     * @param zMin low bound along the z direction\n+     * @param zMax high bound along the z direction\n+     */\n+    public PolyhedronsSet(final double xMin, final double xMax,\n+                          final double yMin, final double yMax,\n+                          final double zMin, final double zMax) {\n+        this(buildConvex(Arrays.asList(new Hyperplane[] {\n+            new Plane(new Vector3D(xMin, 0,    0),   Vector3D.MINUS_I),\n+            new Plane(new Vector3D(xMax, 0,    0),   Vector3D.PLUS_I),\n+            new Plane(new Vector3D(0,    yMin, 0),   Vector3D.MINUS_J),\n+            new Plane(new Vector3D(0,    yMax, 0),   Vector3D.PLUS_J),\n+            new Plane(new Vector3D(0,    0,   zMin), Vector3D.MINUS_K),\n+            new Plane(new Vector3D(0,    0,   zMax), Vector3D.PLUS_K)\n+        })).getTree(false));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Region buildNew(final BSPTree tree) {\n+        return new PolyhedronsSet(tree);\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected void computeGeometricalProperties() {\n+\n+        // compute the contribution of all boundary facets\n+        getTree(true).visit(new FacetsContributionVisitor());\n+\n+        if (getSize() < 0) {\n+            // the polyhedrons set as a finite outside\n+            // surrounded by an infinite inside\n+            setSize(Double.POSITIVE_INFINITY);\n+            setBarycenter(Point3D.UNDEFINED);\n+        } else {\n+            // the polyhedrons set is finite, apply the remaining scaling factors\n+            setSize(getSize() / 3.0);\n+            setBarycenter(new Point3D(1.0 / (4 * getSize()), (Vector3D) getBarycenter()));\n+        }\n+\n+    }\n+\n+    /** Visitor computing geometrical properties. */\n+    private class FacetsContributionVisitor implements BSPTreeVisitor {\n+\n+        /** Simple constructor. */\n+        public FacetsContributionVisitor() {\n+            setSize(0);\n+            setBarycenter(new Point3D(0, 0, 0));\n+        }\n+\n+        /** {@inheritDoc} */\n+        public Order visitOrder(final BSPTree node) {\n+            return Order.MINUS_SUB_PLUS;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void visitInternalNode(final BSPTree node) {\n+            final BoundaryAttribute attribute = (BoundaryAttribute) node.getAttribute();\n+            if (attribute.getPlusOutside() != null) {\n+                addContribution(attribute.getPlusOutside(), false);\n+            }\n+            if (attribute.getPlusInside() != null) {\n+                addContribution(attribute.getPlusInside(), true);\n+            }\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void visitLeafNode(final BSPTree node) {\n+        }\n+\n+        /** Add he contribution of a boundary facet.\n+         * @param facet boundary facet\n+         * @param reversed if true, the facet has the inside on its plus side\n+         */\n+        private void addContribution(final SubHyperplane facet, final boolean reversed) {\n+\n+            final Region polygon = facet.getRemainingRegion();\n+            final double area    = polygon.getSize();\n+\n+            if (Double.isInfinite(area)) {\n+                setSize(Double.POSITIVE_INFINITY);\n+                setBarycenter(Point3D.UNDEFINED);\n+            } else {\n+\n+                final Plane    plane  = (Plane) facet.getHyperplane();\n+                final Vector3D facetB = (Point3D) plane.toSpace(polygon.getBarycenter());\n+                double   scaled = area * Vector3D.dotProduct(facetB, plane.getNormal());\n+                if (reversed) {\n+                    scaled = -scaled;\n+                }\n+\n+                setSize(getSize() + scaled);\n+                setBarycenter(new Point3D(1.0, (Point3D) getBarycenter(), scaled, facetB));\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+    /** Get the first sub-hyperplane crossed by a semi-infinite line.\n+     * @param point start point of the part of the line considered\n+     * @param line line to consider (contains point)\n+     * @return the first sub-hyperplaned crossed by the line after the\n+     * given point, or null if the line does not intersect any\n+     * sub-hyperplaned\n+     */\n+    public SubHyperplane firstIntersection(final Vector3D point, final Line line) {\n+        return recurseFirstIntersection(getTree(true), point, line);\n+    }\n+\n+    /** Get the first sub-hyperplane crossed by a semi-infinite line.\n+     * @param node current node\n+     * @param point start point of the part of the line considered\n+     * @param line line to consider (contains point)\n+     * @return the first sub-hyperplaned crossed by the line after the\n+     * given point, or null if the line does not intersect any\n+     * sub-hyperplaned\n+     */\n+    private SubHyperplane recurseFirstIntersection(final BSPTree node,\n+                                                   final Vector3D point,\n+                                                   final Line line) {\n+\n+        final SubHyperplane cut = node.getCut();\n+        if (cut == null) {\n+            return null;\n+        }\n+        final BSPTree minus = node.getMinus();\n+        final BSPTree plus  = node.getPlus();\n+        final Plane   plane = (Plane) cut.getHyperplane();\n+\n+        // establish search order\n+        final double offset = plane.getOffset((Point) point);\n+        final boolean in    = FastMath.abs(offset) < 1.0e-10;\n+        final BSPTree near;\n+        final BSPTree far;\n+        if (offset < 0) {\n+            near = minus;\n+            far  = plus;\n+        } else {\n+            near = plus;\n+            far  = minus;\n+        }\n+\n+        if (in) {\n+            // search in the cut hyperplane\n+            final SubHyperplane facet = boundaryFacet(point, node);\n+            if (facet != null) {\n+                return facet;\n+            }\n+        }\n+\n+        // search in the near branch\n+        final SubHyperplane crossed = recurseFirstIntersection(near, point, line);\n+        if (crossed != null) {\n+            return crossed;\n+        }\n+\n+        if (!in) {\n+            // search in the cut hyperplane\n+            final Vector3D hit3D = plane.intersection(line);\n+            if (hit3D != null) {\n+                final SubHyperplane facet = boundaryFacet(hit3D, node);\n+                if (facet != null) {\n+                    return facet;\n+                }\n+            }\n+        }\n+\n+        // search in the far branch\n+        return recurseFirstIntersection(far, point, line);\n+\n+    }\n+\n+    /** Check if a point belongs to the boundary part of a node.\n+     * @param point point to check\n+     * @param node node containing the boundary facet to check\n+     * @return the boundary facet this points belongs to (or null if it\n+     * does not belong to any boundary facet)\n+     */\n+    private SubHyperplane boundaryFacet(final Vector3D point, final BSPTree node) {\n+        final Point point2D = node.getCut().getHyperplane().toSubSpace((Point) point);\n+        final BoundaryAttribute attribute = (BoundaryAttribute) node.getAttribute();\n+        if ((attribute.getPlusOutside() != null) &&\n+            (attribute.getPlusOutside().getRemainingRegion().checkPoint(point2D) == Location.INSIDE)) {\n+            return attribute.getPlusOutside();\n+        }\n+        if ((attribute.getPlusInside() != null) &&\n+            (attribute.getPlusInside().getRemainingRegion().checkPoint(point2D) == Location.INSIDE)) {\n+            return attribute.getPlusInside();\n+        }\n+        return null;\n+    }\n+\n+    /** Rotate the region around the specified point.\n+     * <p>The instance is not modified, a new instance is created.</p>\n+     * @param center rotation center\n+     * @param rotation vectorial rotation operator\n+     * @return a new instance representing the rotated region\n+     */\n+    public PolyhedronsSet rotate(final Vector3D center, final Rotation rotation) {\n+        return (PolyhedronsSet) applyTransform(new RotationTransform(center, rotation));\n+    }\n+\n+    /** 3D rotation as a Transform. */\n+    private static class RotationTransform implements Transform {\n+\n+        /** Center point of the rotation. */\n+        private Vector3D   center;\n+\n+        /** Vectorial rotation. */\n+        private Rotation   rotation;\n+\n+        /** Cached original hyperplane. */\n+        private Hyperplane cachedOriginal;\n+\n+        /** Cached 2D transform valid inside the cached original hyperplane. */\n+        private Transform  cachedTransform;\n+\n+        /** Build a rotation transform.\n+         * @param center center point of the rotation\n+         * @param rotation vectorial rotation\n+         */\n+        public RotationTransform(final Vector3D center, final Rotation rotation) {\n+            this.center   = center;\n+            this.rotation = rotation;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public Point apply(final Point point) {\n+            final Vector3D delta = ((Vector3D) point).subtract(center);\n+            return new Point3D(1.0, center, 1.0, rotation.applyTo(delta));\n+        }\n+\n+        /** {@inheritDoc} */\n+        public Hyperplane apply(final Hyperplane hyperplane) {\n+            return ((Plane) hyperplane).rotate(center, rotation);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public SubHyperplane apply(final SubHyperplane sub,\n+                                   final Hyperplane original, final Hyperplane transformed) {\n+            if (original != cachedOriginal) {\n+                // we have changed hyperplane, reset the in-hyperplane transform\n+\n+                final Plane    oPlane = (Plane) original;\n+                final Plane    tPlane = (Plane) transformed;\n+                final Vector3D p00    = oPlane.getOrigin();\n+                final Vector3D p10    = (Vector3D) oPlane.toSpace(new Point2D(1.0, 0.0));\n+                final Vector3D p01    = (Vector3D) oPlane.toSpace(new Point2D(0.0, 1.0));\n+                final Point2D  tP00   = (Point2D) tPlane.toSubSpace(apply((Point) p00));\n+                final Point2D  tP10   = (Point2D) tPlane.toSubSpace(apply((Point) p10));\n+                final Point2D  tP01   = (Point2D) tPlane.toSubSpace(apply((Point) p01));\n+                final AffineTransform at =\n+                    new AffineTransform(tP10.getX() - tP00.getX(), tP10.getY() - tP00.getY(),\n+                                        tP01.getX() - tP00.getX(), tP01.getY() - tP00.getY(),\n+                                        tP00.getX(), tP00.getY());\n+\n+                cachedOriginal  = original;\n+                cachedTransform = org.apache.commons.math.geometry.euclidean.twoD.Line.getTransform(at);\n+\n+            }\n+            return sub.applyTransform(cachedTransform);\n+        }\n+\n+    }\n+\n+    /** Translate the region by the specified amount.\n+     * <p>The instance is not modified, a new instance is created.</p>\n+     * @param translation translation to apply\n+     * @return a new instance representing the translated region\n+     */\n+    public PolyhedronsSet translate(final Vector3D translation) {\n+        return (PolyhedronsSet) applyTransform(new TranslationTransform(translation));\n+    }\n+\n+    /** 3D translation as a transform. */\n+    private static class TranslationTransform implements Transform {\n+\n+        /** Translation vector. */\n+        private Vector3D   translation;\n+\n+        /** Cached original hyperplane. */\n+        private Hyperplane cachedOriginal;\n+\n+        /** Cached 2D transform valid inside the cached original hyperplane. */\n+        private Transform  cachedTransform;\n+\n+        /** Build a translation transform.\n+         * @param translation translation vector\n+         */\n+        public TranslationTransform(final Vector3D translation) {\n+            this.translation = translation;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public Point apply(final Point point) {\n+            return new Point3D(1.0, (Vector3D) point, 1.0, translation);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public Hyperplane apply(final Hyperplane hyperplane) {\n+            return ((Plane) hyperplane).translate(translation);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public SubHyperplane apply(final SubHyperplane sub,\n+                                   final Hyperplane original, final Hyperplane transformed) {\n+            if (original != cachedOriginal) {\n+                // we have changed hyperplane, reset the in-hyperplane transform\n+\n+                final Plane   oPlane = (Plane) original;\n+                final Plane   tPlane = (Plane) transformed;\n+                final Point2D shift  = (Point2D) tPlane.toSubSpace(apply((Point) oPlane.getOrigin()));\n+                final AffineTransform at =\n+                    AffineTransform.getTranslateInstance(shift.getX(), shift.getY());\n+\n+                cachedOriginal  = original;\n+                cachedTransform =\n+                    org.apache.commons.math.geometry.euclidean.twoD.Line.getTransform(at);\n+\n+            }\n+\n+            return sub.applyTransform(cachedTransform);\n+\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threeD/Rotation.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * This class implements rotations in a three-dimensional space.\n+ *\n+ * <p>Rotations can be represented by several different mathematical\n+ * entities (matrices, axe and angle, Cardan or Euler angles,\n+ * quaternions). This class presents an higher level abstraction, more\n+ * user-oriented and hiding this implementation details. Well, for the\n+ * curious, we use quaternions for the internal representation. The\n+ * user can build a rotation from any of these representations, and\n+ * any of these representations can be retrieved from a\n+ * <code>Rotation</code> instance (see the various constructors and\n+ * getters). In addition, a rotation can also be built implicitly\n+ * from a set of vectors and their image.</p>\n+ * <p>This implies that this class can be used to convert from one\n+ * representation to another one. For example, converting a rotation\n+ * matrix into a set of Cardan angles from can be done using the\n+ * following single line of code:</p>\n+ * <pre>\n+ * double[] angles = new Rotation(matrix, 1.0e-10).getAngles(RotationOrder.XYZ);\n+ * </pre>\n+ * <p>Focus is oriented on what a rotation <em>do</em> rather than on its\n+ * underlying representation. Once it has been built, and regardless of its\n+ * internal representation, a rotation is an <em>operator</em> which basically\n+ * transforms three dimensional {@link Vector3D vectors} into other three\n+ * dimensional {@link Vector3D vectors}. Depending on the application, the\n+ * meaning of these vectors may vary and the semantics of the rotation also.</p>\n+ * <p>For example in an spacecraft attitude simulation tool, users will often\n+ * consider the vectors are fixed (say the Earth direction for example) and the\n+ * frames change. The rotation transforms the coordinates of the vector in inertial\n+ * frame into the coordinates of the same vector in satellite frame. In this\n+ * case, the rotation implicitly defines the relation between the two frames.</p>\n+ * <p>Another example could be a telescope control application, where the rotation\n+ * would transform the sighting direction at rest into the desired observing\n+ * direction when the telescope is pointed towards an object of interest. In this\n+ * case the rotation transforms the direction at rest in a topocentric frame\n+ * into the sighting direction in the same topocentric frame. This implies in this\n+ * case the frame is fixed and the vector moves.</p>\n+ * <p>In many case, both approaches will be combined. In our telescope example,\n+ * we will probably also need to transform the observing direction in the topocentric\n+ * frame into the observing direction in inertial frame taking into account the observatory\n+ * location and the Earth rotation, which would essentially be an application of the\n+ * first approach.</p>\n+ *\n+ * <p>These examples show that a rotation is what the user wants it to be. This\n+ * class does not push the user towards one specific definition and hence does not\n+ * provide methods like <code>projectVectorIntoDestinationFrame</code> or\n+ * <code>computeTransformedDirection</code>. It provides simpler and more generic\n+ * methods: {@link #applyTo(Vector3D) applyTo(Vector3D)} and {@link\n+ * #applyInverseTo(Vector3D) applyInverseTo(Vector3D)}.</p>\n+ *\n+ * <p>Since a rotation is basically a vectorial operator, several rotations can be\n+ * composed together and the composite operation <code>r = r<sub>1</sub> o\n+ * r<sub>2</sub></code> (which means that for each vector <code>u</code>,\n+ * <code>r(u) = r<sub>1</sub>(r<sub>2</sub>(u))</code>) is also a rotation. Hence\n+ * we can consider that in addition to vectors, a rotation can be applied to other\n+ * rotations as well (or to itself). With our previous notations, we would say we\n+ * can apply <code>r<sub>1</sub></code> to <code>r<sub>2</sub></code> and the result\n+ * we get is <code>r = r<sub>1</sub> o r<sub>2</sub></code>. For this purpose, the\n+ * class provides the methods: {@link #applyTo(Rotation) applyTo(Rotation)} and\n+ * {@link #applyInverseTo(Rotation) applyInverseTo(Rotation)}.</p>\n+ *\n+ * <p>Rotations are guaranteed to be immutable objects.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @see Vector3D\n+ * @see RotationOrder\n+ * @since 1.2\n+ */\n+\n+public class Rotation implements Serializable {\n+\n+  /** Identity rotation. */\n+  public static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false);\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -2153622329907944313L;\n+\n+  /** Scalar coordinate of the quaternion. */\n+  private final double q0;\n+\n+  /** First coordinate of the vectorial part of the quaternion. */\n+  private final double q1;\n+\n+  /** Second coordinate of the vectorial part of the quaternion. */\n+  private final double q2;\n+\n+  /** Third coordinate of the vectorial part of the quaternion. */\n+  private final double q3;\n+\n+  /** Build a rotation from the quaternion coordinates.\n+   * <p>A rotation can be built from a <em>normalized</em> quaternion,\n+   * i.e. a quaternion for which q<sub>0</sub><sup>2</sup> +\n+   * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +\n+   * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized,\n+   * the constructor can normalize it in a preprocessing step.</p>\n+   * <p>Note that some conventions put the scalar part of the quaternion\n+   * as the 4<sup>th</sup> component and the vector part as the first three\n+   * components. This is <em>not</em> our convention. We put the scalar part\n+   * as the first component.</p>\n+   * @param q0 scalar part of the quaternion\n+   * @param q1 first coordinate of the vectorial part of the quaternion\n+   * @param q2 second coordinate of the vectorial part of the quaternion\n+   * @param q3 third coordinate of the vectorial part of the quaternion\n+   * @param needsNormalization if true, the coordinates are considered\n+   * not to be normalized, a normalization preprocessing step is performed\n+   * before using them\n+   */\n+  public Rotation(double q0, double q1, double q2, double q3,\n+                  boolean needsNormalization) {\n+\n+    if (needsNormalization) {\n+      // normalization preprocessing\n+      double inv = 1.0 / FastMath.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n+      q0 *= inv;\n+      q1 *= inv;\n+      q2 *= inv;\n+      q3 *= inv;\n+    }\n+\n+    this.q0 = q0;\n+    this.q1 = q1;\n+    this.q2 = q2;\n+    this.q3 = q3;\n+\n+  }\n+\n+  /** Build a rotation from an axis and an angle.\n+   * <p>We use the convention that angles are oriented according to\n+   * the effect of the rotation on vectors around the axis. That means\n+   * that if (i, j, k) is a direct frame and if we first provide +k as\n+   * the axis and &pi;/2 as the angle to this constructor, and then\n+   * {@link #applyTo(Vector3D) apply} the instance to +i, we will get\n+   * +j.</p>\n+   * <p>Another way to represent our convention is to say that a rotation\n+   * of angle &theta; about the unit vector (x, y, z) is the same as the\n+   * rotation build from quaternion components { cos(-&theta;/2),\n+   * x * sin(-&theta;/2), y * sin(-&theta;/2), z * sin(-&theta;/2) }.\n+   * Note the minus sign on the angle!</p>\n+   * <p>On the one hand this convention is consistent with a vectorial\n+   * perspective (moving vectors in fixed frames), on the other hand it\n+   * is different from conventions with a frame perspective (fixed vectors\n+   * viewed from different frames) like the ones used for example in spacecraft\n+   * attitude community or in the graphics community.</p>\n+   * @param axis axis around which to rotate\n+   * @param angle rotation angle.\n+   * @exception ArithmeticException if the axis norm is zero\n+   */\n+  public Rotation(Vector3D axis, double angle) {\n+\n+    double norm = axis.getNorm();\n+    if (norm == 0) {\n+      throw MathRuntimeException.createArithmeticException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS);\n+    }\n+\n+    double halfAngle = -0.5 * angle;\n+    double coeff = FastMath.sin(halfAngle) / norm;\n+\n+    q0 = FastMath.cos (halfAngle);\n+    q1 = coeff * axis.getX();\n+    q2 = coeff * axis.getY();\n+    q3 = coeff * axis.getZ();\n+\n+  }\n+\n+  /** Build a rotation from a 3X3 matrix.\n+\n+   * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices\n+   * (which are matrices for which m.m<sup>T</sup> = I) with real\n+   * coefficients. The module of the determinant of unit matrices is\n+   * 1, among the orthogonal 3X3 matrices, only the ones having a\n+   * positive determinant (+1) are rotation matrices.</p>\n+\n+   * <p>When a rotation is defined by a matrix with truncated values\n+   * (typically when it is extracted from a technical sheet where only\n+   * four to five significant digits are available), the matrix is not\n+   * orthogonal anymore. This constructor handles this case\n+   * transparently by using a copy of the given matrix and applying a\n+   * correction to the copy in order to perfect its orthogonality. If\n+   * the Frobenius norm of the correction needed is above the given\n+   * threshold, then the matrix is considered to be too far from a\n+   * true rotation matrix and an exception is thrown.<p>\n+\n+   * @param m rotation matrix\n+   * @param threshold convergence threshold for the iterative\n+   * orthogonality correction (convergence is reached when the\n+   * difference between two steps of the Frobenius norm of the\n+   * correction is below this threshold)\n+\n+   * @exception NotARotationMatrixException if the matrix is not a 3X3\n+   * matrix, or if it cannot be transformed into an orthogonal matrix\n+   * with the given threshold, or if the determinant of the resulting\n+   * orthogonal matrix is negative\n+\n+   */\n+  public Rotation(double[][] m, double threshold)\n+    throws NotARotationMatrixException {\n+\n+    // dimension check\n+    if ((m.length != 3) || (m[0].length != 3) ||\n+        (m[1].length != 3) || (m[2].length != 3)) {\n+      throw new NotARotationMatrixException(\n+              LocalizedFormats.ROTATION_MATRIX_DIMENSIONS,\n+              m.length, m[0].length);\n+    }\n+\n+    // compute a \"close\" orthogonal matrix\n+    double[][] ort = orthogonalizeMatrix(m, threshold);\n+\n+    // check the sign of the determinant\n+    double det = ort[0][0] * (ort[1][1] * ort[2][2] - ort[2][1] * ort[1][2]) -\n+                 ort[1][0] * (ort[0][1] * ort[2][2] - ort[2][1] * ort[0][2]) +\n+                 ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);\n+    if (det < 0.0) {\n+      throw new NotARotationMatrixException(\n+              LocalizedFormats.CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT,\n+              det);\n+    }\n+\n+    // There are different ways to compute the quaternions elements\n+    // from the matrix. They all involve computing one element from\n+    // the diagonal of the matrix, and computing the three other ones\n+    // using a formula involving a division by the first element,\n+    // which unfortunately can be zero. Since the norm of the\n+    // quaternion is 1, we know at least one element has an absolute\n+    // value greater or equal to 0.5, so it is always possible to\n+    // select the right formula and avoid division by zero and even\n+    // numerical inaccuracy. Checking the elements in turn and using\n+    // the first one greater than 0.45 is safe (this leads to a simple\n+    // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n+    double s = ort[0][0] + ort[1][1] + ort[2][2];\n+    if (s > -0.19) {\n+      // compute q0 and deduce q1, q2 and q3\n+      q0 = 0.5 * FastMath.sqrt(s + 1.0);\n+      double inv = 0.25 / q0;\n+      q1 = inv * (ort[1][2] - ort[2][1]);\n+      q2 = inv * (ort[2][0] - ort[0][2]);\n+      q3 = inv * (ort[0][1] - ort[1][0]);\n+    } else {\n+      s = ort[0][0] - ort[1][1] - ort[2][2];\n+      if (s > -0.19) {\n+        // compute q1 and deduce q0, q2 and q3\n+        q1 = 0.5 * FastMath.sqrt(s + 1.0);\n+        double inv = 0.25 / q1;\n+        q0 = inv * (ort[1][2] - ort[2][1]);\n+        q2 = inv * (ort[0][1] + ort[1][0]);\n+        q3 = inv * (ort[0][2] + ort[2][0]);\n+      } else {\n+        s = ort[1][1] - ort[0][0] - ort[2][2];\n+        if (s > -0.19) {\n+          // compute q2 and deduce q0, q1 and q3\n+          q2 = 0.5 * FastMath.sqrt(s + 1.0);\n+          double inv = 0.25 / q2;\n+          q0 = inv * (ort[2][0] - ort[0][2]);\n+          q1 = inv * (ort[0][1] + ort[1][0]);\n+          q3 = inv * (ort[2][1] + ort[1][2]);\n+        } else {\n+          // compute q3 and deduce q0, q1 and q2\n+          s = ort[2][2] - ort[0][0] - ort[1][1];\n+          q3 = 0.5 * FastMath.sqrt(s + 1.0);\n+          double inv = 0.25 / q3;\n+          q0 = inv * (ort[0][1] - ort[1][0]);\n+          q1 = inv * (ort[0][2] + ort[2][0]);\n+          q2 = inv * (ort[2][1] + ort[1][2]);\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  /** Build the rotation that transforms a pair of vector into another pair.\n+\n+   * <p>Except for possible scale factors, if the instance were applied to\n+   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n+   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n+\n+   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n+   * not the same as the angular separation between v<sub>1</sub> and\n+   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n+   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n+   * v<sub>2</sub>) plane.</p>\n+\n+   * @param u1 first vector of the origin pair\n+   * @param u2 second vector of the origin pair\n+   * @param v1 desired image of u1 by the rotation\n+   * @param v2 desired image of u2 by the rotation\n+   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n+   */\n+  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n+\n+  // norms computation\n+  double u1u1 = Vector3D.dotProduct(u1, u1);\n+  double u2u2 = Vector3D.dotProduct(u2, u2);\n+  double v1v1 = Vector3D.dotProduct(v1, v1);\n+  double v2v2 = Vector3D.dotProduct(v2, v2);\n+  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n+    throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n+  }\n+\n+  double u1x = u1.getX();\n+  double u1y = u1.getY();\n+  double u1z = u1.getZ();\n+\n+  double u2x = u2.getX();\n+  double u2y = u2.getY();\n+  double u2z = u2.getZ();\n+\n+  // normalize v1 in order to have (v1'|v1') = (u1|u1)\n+  double coeff = FastMath.sqrt (u1u1 / v1v1);\n+  double v1x   = coeff * v1.getX();\n+  double v1y   = coeff * v1.getY();\n+  double v1z   = coeff * v1.getZ();\n+  v1 = new Vector3D(v1x, v1y, v1z);\n+\n+  // adjust v2 in order to have (u1|u2) = (v1|v2) and (v2'|v2') = (u2|u2)\n+  double u1u2   = Vector3D.dotProduct(u1, u2);\n+  double v1v2   = Vector3D.dotProduct(v1, v2);\n+  double coeffU = u1u2 / u1u1;\n+  double coeffV = v1v2 / u1u1;\n+  double beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n+  double alpha  = coeffU - beta * coeffV;\n+  double v2x    = alpha * v1x + beta * v2.getX();\n+  double v2y    = alpha * v1y + beta * v2.getY();\n+  double v2z    = alpha * v1z + beta * v2.getZ();\n+  v2 = new Vector3D(v2x, v2y, v2z);\n+\n+  // preliminary computation (we use explicit formulation instead\n+  // of relying on the Vector3D class in order to avoid building lots\n+  // of temporary objects)\n+  Vector3D uRef = u1;\n+  Vector3D vRef = v1;\n+  double dx1 = v1x - u1.getX();\n+  double dy1 = v1y - u1.getY();\n+  double dz1 = v1z - u1.getZ();\n+  double dx2 = v2x - u2.getX();\n+  double dy2 = v2y - u2.getY();\n+  double dz2 = v2z - u2.getZ();\n+  Vector3D k = new Vector3D(dy1 * dz2 - dz1 * dy2,\n+                            dz1 * dx2 - dx1 * dz2,\n+                            dx1 * dy2 - dy1 * dx2);\n+  double c = k.getX() * (u1y * u2z - u1z * u2y) +\n+             k.getY() * (u1z * u2x - u1x * u2z) +\n+             k.getZ() * (u1x * u2y - u1y * u2x);\n+\n+  if (c == 0) {\n+    // the (q1, q2, q3) vector is in the (u1, u2) plane\n+    // we try other vectors\n+    Vector3D u3 = Vector3D.crossProduct(u1, u2);\n+    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n+    double u3x  = u3.getX();\n+    double u3y  = u3.getY();\n+    double u3z  = u3.getZ();\n+    double v3x  = v3.getX();\n+    double v3y  = v3.getY();\n+    double v3z  = v3.getZ();\n+\n+    double dx3 = v3x - u3x;\n+    double dy3 = v3y - u3y;\n+    double dz3 = v3z - u3z;\n+    k = new Vector3D(dy1 * dz3 - dz1 * dy3,\n+                     dz1 * dx3 - dx1 * dz3,\n+                     dx1 * dy3 - dy1 * dx3);\n+    c = k.getX() * (u1y * u3z - u1z * u3y) +\n+        k.getY() * (u1z * u3x - u1x * u3z) +\n+        k.getZ() * (u1x * u3y - u1y * u3x);\n+\n+    if (c == 0) {\n+      // the (q1, q2, q3) vector is aligned with u1:\n+      // we try (u2, u3) and (v2, v3)\n+      k = new Vector3D(dy2 * dz3 - dz2 * dy3,\n+                       dz2 * dx3 - dx2 * dz3,\n+                       dx2 * dy3 - dy2 * dx3);\n+      c = k.getX() * (u2y * u3z - u2z * u3y) +\n+          k.getY() * (u2z * u3x - u2x * u3z) +\n+          k.getZ() * (u2x * u3y - u2y * u3x);\n+\n+      if (c == 0) {\n+        // the (q1, q2, q3) vector is aligned with everything\n+        // this is really the identity rotation\n+        q0 = 1.0;\n+        q1 = 0.0;\n+        q2 = 0.0;\n+        q3 = 0.0;\n+        return;\n+      }\n+\n+      // we will have to use u2 and v2 to compute the scalar part\n+      uRef = u2;\n+      vRef = v2;\n+\n+    }\n+\n+  }\n+\n+  // compute the vectorial part\n+  c = FastMath.sqrt(c);\n+  double inv = 1.0 / (c + c);\n+  q1 = inv * k.getX();\n+  q2 = inv * k.getY();\n+  q3 = inv * k.getZ();\n+\n+  // compute the scalar part\n+   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n+                    uRef.getZ() * q1 - uRef.getX() * q3,\n+                    uRef.getX() * q2 - uRef.getY() * q1);\n+   c = Vector3D.dotProduct(k, k);\n+  q0 = Vector3D.dotProduct(vRef, k) / (c + c);\n+\n+  }\n+\n+  /** Build one of the rotations that transform one vector into another one.\n+\n+   * <p>Except for a possible scale factor, if the instance were\n+   * applied to the vector u it will produce the vector v. There is an\n+   * infinite number of such rotations, this constructor choose the\n+   * one with the smallest associated angle (i.e. the one whose axis\n+   * is orthogonal to the (u, v) plane). If u and v are colinear, an\n+   * arbitrary rotation axis is chosen.</p>\n+\n+   * @param u origin vector\n+   * @param v desired image of u by the rotation\n+   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n+   */\n+  public Rotation(Vector3D u, Vector3D v) {\n+\n+    double normProduct = u.getNorm() * v.getNorm();\n+    if (normProduct == 0) {\n+        throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n+    }\n+\n+    double dot = Vector3D.dotProduct(u, v);\n+\n+    if (dot < ((2.0e-15 - 1.0) * normProduct)) {\n+      // special case u = -v: we select a PI angle rotation around\n+      // an arbitrary vector orthogonal to u\n+      Vector3D w = u.orthogonal();\n+      q0 = 0.0;\n+      q1 = -w.getX();\n+      q2 = -w.getY();\n+      q3 = -w.getZ();\n+    } else {\n+      // general case: (u, v) defines a plane, we select\n+      // the shortest possible rotation: axis orthogonal to this plane\n+      q0 = FastMath.sqrt(0.5 * (1.0 + dot / normProduct));\n+      double coeff = 1.0 / (2.0 * q0 * normProduct);\n+      q1 = coeff * (v.getY() * u.getZ() - v.getZ() * u.getY());\n+      q2 = coeff * (v.getZ() * u.getX() - v.getX() * u.getZ());\n+      q3 = coeff * (v.getX() * u.getY() - v.getY() * u.getX());\n+    }\n+\n+  }\n+\n+  /** Build a rotation from three Cardan or Euler elementary rotations.\n+\n+   * <p>Cardan rotations are three successive rotations around the\n+   * canonical axes X, Y and Z, each axis being used once. There are\n+   * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n+   * rotations are three successive rotations around the canonical\n+   * axes X, Y and Z, the first and last rotations being around the\n+   * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n+   * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n+   * <p>Beware that many people routinely use the term Euler angles even\n+   * for what really are Cardan angles (this confusion is especially\n+   * widespread in the aerospace business where Roll, Pitch and Yaw angles\n+   * are often wrongly tagged as Euler angles).</p>\n+\n+   * @param order order of rotations to use\n+   * @param alpha1 angle of the first elementary rotation\n+   * @param alpha2 angle of the second elementary rotation\n+   * @param alpha3 angle of the third elementary rotation\n+   */\n+  public Rotation(RotationOrder order,\n+                  double alpha1, double alpha2, double alpha3) {\n+    Rotation r1 = new Rotation(order.getA1(), alpha1);\n+    Rotation r2 = new Rotation(order.getA2(), alpha2);\n+    Rotation r3 = new Rotation(order.getA3(), alpha3);\n+    Rotation composed = r1.applyTo(r2.applyTo(r3));\n+    q0 = composed.q0;\n+    q1 = composed.q1;\n+    q2 = composed.q2;\n+    q3 = composed.q3;\n+  }\n+\n+  /** Revert a rotation.\n+   * Build a rotation which reverse the effect of another\n+   * rotation. This means that if r(u) = v, then r.revert(v) = u. The\n+   * instance is not changed.\n+   * @return a new rotation whose effect is the reverse of the effect\n+   * of the instance\n+   */\n+  public Rotation revert() {\n+    return new Rotation(-q0, q1, q2, q3, false);\n+  }\n+\n+  /** Get the scalar coordinate of the quaternion.\n+   * @return scalar coordinate of the quaternion\n+   */\n+  public double getQ0() {\n+    return q0;\n+  }\n+\n+  /** Get the first coordinate of the vectorial part of the quaternion.\n+   * @return first coordinate of the vectorial part of the quaternion\n+   */\n+  public double getQ1() {\n+    return q1;\n+  }\n+\n+  /** Get the second coordinate of the vectorial part of the quaternion.\n+   * @return second coordinate of the vectorial part of the quaternion\n+   */\n+  public double getQ2() {\n+    return q2;\n+  }\n+\n+  /** Get the third coordinate of the vectorial part of the quaternion.\n+   * @return third coordinate of the vectorial part of the quaternion\n+   */\n+  public double getQ3() {\n+    return q3;\n+  }\n+\n+  /** Get the normalized axis of the rotation.\n+   * @return normalized axis of the rotation\n+   * @see #Rotation(Vector3D, double)\n+   */\n+  public Vector3D getAxis() {\n+    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n+    if (squaredSine == 0) {\n+      return new Vector3D(1, 0, 0);\n+    } else if (q0 < 0) {\n+      double inverse = 1 / FastMath.sqrt(squaredSine);\n+      return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n+    }\n+    double inverse = -1 / FastMath.sqrt(squaredSine);\n+    return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n+  }\n+\n+  /** Get the angle of the rotation.\n+   * @return angle of the rotation (between 0 and &pi;)\n+   * @see #Rotation(Vector3D, double)\n+   */\n+  public double getAngle() {\n+    if ((q0 < -0.1) || (q0 > 0.1)) {\n+      return 2 * FastMath.asin(FastMath.sqrt(q1 * q1 + q2 * q2 + q3 * q3));\n+    } else if (q0 < 0) {\n+      return 2 * FastMath.acos(-q0);\n+    }\n+    return 2 * FastMath.acos(q0);\n+  }\n+\n+  /** Get the Cardan or Euler angles corresponding to the instance.\n+\n+   * <p>The equations show that each rotation can be defined by two\n+   * different values of the Cardan or Euler angles set. For example\n+   * if Cardan angles are used, the rotation defined by the angles\n+   * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n+   * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n+   * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n+   * the following arbitrary choices:</p>\n+   * <ul>\n+   *   <li>for Cardan angles, the chosen set is the one for which the\n+   *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n+   *   positive),</li>\n+   *   <li>for Euler angles, the chosen set is the one for which the\n+   *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n+   * </ul>\n+\n+   * <p>Cardan and Euler angle have a very disappointing drawback: all\n+   * of them have singularities. This means that if the instance is\n+   * too close to the singularities corresponding to the given\n+   * rotation order, it will be impossible to retrieve the angles. For\n+   * Cardan angles, this is often called gimbal lock. There is\n+   * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n+   * with Cardan and Euler representation (but not a problem with the\n+   * rotation itself, which is perfectly well defined). For Cardan\n+   * angles, singularities occur when the second angle is close to\n+   * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n+   * second angle is close to 0 or &pi;, this implies that the identity\n+   * rotation is always singular for Euler angles!</p>\n+\n+   * @param order rotation order to use\n+   * @return an array of three angles, in the order specified by the set\n+   * @exception CardanEulerSingularityException if the rotation is\n+   * singular with respect to the angles set specified\n+   */\n+  public double[] getAngles(RotationOrder order)\n+    throws CardanEulerSingularityException {\n+\n+    if (order == RotationOrder.XYZ) {\n+\n+      // r (Vector3D.plusK) coordinates are :\n+      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n+      // (-r) (Vector3D.plusI) coordinates are :\n+      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n+      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n+      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      return new double[] {\n+        FastMath.atan2(-(v1.getY()), v1.getZ()),\n+        FastMath.asin(v2.getZ()),\n+        FastMath.atan2(-(v2.getY()), v2.getX())\n+      };\n+\n+    } else if (order == RotationOrder.XZY) {\n+\n+      // r (Vector3D.plusJ) coordinates are :\n+      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n+      // (-r) (Vector3D.plusI) coordinates are :\n+      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n+      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n+      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      return new double[] {\n+        FastMath.atan2(v1.getZ(), v1.getY()),\n+       -FastMath.asin(v2.getY()),\n+        FastMath.atan2(v2.getZ(), v2.getX())\n+      };\n+\n+    } else if (order == RotationOrder.YXZ) {\n+\n+      // r (Vector3D.plusK) coordinates are :\n+      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n+      // (-r) (Vector3D.plusJ) coordinates are :\n+      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n+      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n+      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      return new double[] {\n+        FastMath.atan2(v1.getX(), v1.getZ()),\n+       -FastMath.asin(v2.getZ()),\n+        FastMath.atan2(v2.getX(), v2.getY())\n+      };\n+\n+    } else if (order == RotationOrder.YZX) {\n+\n+      // r (Vector3D.plusI) coordinates are :\n+      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n+      // (-r) (Vector3D.plusJ) coordinates are :\n+      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n+      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n+      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      return new double[] {\n+        FastMath.atan2(-(v1.getZ()), v1.getX()),\n+        FastMath.asin(v2.getX()),\n+        FastMath.atan2(-(v2.getZ()), v2.getY())\n+      };\n+\n+    } else if (order == RotationOrder.ZXY) {\n+\n+      // r (Vector3D.plusJ) coordinates are :\n+      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n+      // (-r) (Vector3D.plusK) coordinates are :\n+      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n+      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n+      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      return new double[] {\n+        FastMath.atan2(-(v1.getX()), v1.getY()),\n+        FastMath.asin(v2.getY()),\n+        FastMath.atan2(-(v2.getX()), v2.getZ())\n+      };\n+\n+    } else if (order == RotationOrder.ZYX) {\n+\n+      // r (Vector3D.plusI) coordinates are :\n+      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n+      // (-r) (Vector3D.plusK) coordinates are :\n+      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n+      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n+      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      return new double[] {\n+        FastMath.atan2(v1.getY(), v1.getX()),\n+       -FastMath.asin(v2.getX()),\n+        FastMath.atan2(v2.getY(), v2.getZ())\n+      };\n+\n+    } else if (order == RotationOrder.XYX) {\n+\n+      // r (Vector3D.plusI) coordinates are :\n+      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n+      // (-r) (Vector3D.plusI) coordinates are :\n+      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n+      // and we can choose to have theta in the interval [0 ; PI]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n+      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      return new double[] {\n+        FastMath.atan2(v1.getY(), -v1.getZ()),\n+        FastMath.acos(v2.getX()),\n+        FastMath.atan2(v2.getY(), v2.getZ())\n+      };\n+\n+    } else if (order == RotationOrder.XZX) {\n+\n+      // r (Vector3D.plusI) coordinates are :\n+      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n+      // (-r) (Vector3D.plusI) coordinates are :\n+      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n+      // and we can choose to have psi in the interval [0 ; PI]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n+      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      return new double[] {\n+        FastMath.atan2(v1.getZ(), v1.getY()),\n+        FastMath.acos(v2.getX()),\n+        FastMath.atan2(v2.getZ(), -v2.getY())\n+      };\n+\n+    } else if (order == RotationOrder.YXY) {\n+\n+      // r (Vector3D.plusJ) coordinates are :\n+      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n+      // (-r) (Vector3D.plusJ) coordinates are :\n+      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n+      // and we can choose to have phi in the interval [0 ; PI]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n+      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      return new double[] {\n+        FastMath.atan2(v1.getX(), v1.getZ()),\n+        FastMath.acos(v2.getY()),\n+        FastMath.atan2(v2.getX(), -v2.getZ())\n+      };\n+\n+    } else if (order == RotationOrder.YZY) {\n+\n+      // r (Vector3D.plusJ) coordinates are :\n+      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n+      // (-r) (Vector3D.plusJ) coordinates are :\n+      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n+      // and we can choose to have psi in the interval [0 ; PI]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n+      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      return new double[] {\n+        FastMath.atan2(v1.getZ(), -v1.getX()),\n+        FastMath.acos(v2.getY()),\n+        FastMath.atan2(v2.getZ(), v2.getX())\n+      };\n+\n+    } else if (order == RotationOrder.ZXZ) {\n+\n+      // r (Vector3D.plusK) coordinates are :\n+      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n+      // (-r) (Vector3D.plusK) coordinates are :\n+      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n+      // and we can choose to have phi in the interval [0 ; PI]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n+      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      return new double[] {\n+        FastMath.atan2(v1.getX(), -v1.getY()),\n+        FastMath.acos(v2.getZ()),\n+        FastMath.atan2(v2.getX(), v2.getY())\n+      };\n+\n+    } else { // last possibility is ZYZ\n+\n+      // r (Vector3D.plusK) coordinates are :\n+      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n+      // (-r) (Vector3D.plusK) coordinates are :\n+      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n+      // and we can choose to have theta in the interval [0 ; PI]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n+      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      return new double[] {\n+        FastMath.atan2(v1.getY(), v1.getX()),\n+        FastMath.acos(v2.getZ()),\n+        FastMath.atan2(v2.getY(), -v2.getX())\n+      };\n+\n+    }\n+\n+  }\n+\n+  /** Get the 3X3 matrix corresponding to the instance\n+   * @return the matrix corresponding to the instance\n+   */\n+  public double[][] getMatrix() {\n+\n+    // products\n+    double q0q0  = q0 * q0;\n+    double q0q1  = q0 * q1;\n+    double q0q2  = q0 * q2;\n+    double q0q3  = q0 * q3;\n+    double q1q1  = q1 * q1;\n+    double q1q2  = q1 * q2;\n+    double q1q3  = q1 * q3;\n+    double q2q2  = q2 * q2;\n+    double q2q3  = q2 * q3;\n+    double q3q3  = q3 * q3;\n+\n+    // create the matrix\n+    double[][] m = new double[3][];\n+    m[0] = new double[3];\n+    m[1] = new double[3];\n+    m[2] = new double[3];\n+\n+    m [0][0] = 2.0 * (q0q0 + q1q1) - 1.0;\n+    m [1][0] = 2.0 * (q1q2 - q0q3);\n+    m [2][0] = 2.0 * (q1q3 + q0q2);\n+\n+    m [0][1] = 2.0 * (q1q2 + q0q3);\n+    m [1][1] = 2.0 * (q0q0 + q2q2) - 1.0;\n+    m [2][1] = 2.0 * (q2q3 - q0q1);\n+\n+    m [0][2] = 2.0 * (q1q3 - q0q2);\n+    m [1][2] = 2.0 * (q2q3 + q0q1);\n+    m [2][2] = 2.0 * (q0q0 + q3q3) - 1.0;\n+\n+    return m;\n+\n+  }\n+\n+  /** Apply the rotation to a vector.\n+   * @param u vector to apply the rotation to\n+   * @return a new vector which is the image of u by the rotation\n+   */\n+  public Vector3D applyTo(Vector3D u) {\n+\n+    double x = u.getX();\n+    double y = u.getY();\n+    double z = u.getZ();\n+\n+    double s = q1 * x + q2 * y + q3 * z;\n+\n+    return new Vector3D(2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x,\n+                        2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y,\n+                        2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z);\n+\n+  }\n+\n+  /** Apply the inverse of the rotation to a vector.\n+   * @param u vector to apply the inverse of the rotation to\n+   * @return a new vector which such that u is its image by the rotation\n+   */\n+  public Vector3D applyInverseTo(Vector3D u) {\n+\n+    double x = u.getX();\n+    double y = u.getY();\n+    double z = u.getZ();\n+\n+    double s = q1 * x + q2 * y + q3 * z;\n+    double m0 = -q0;\n+\n+    return new Vector3D(2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x,\n+                        2 * (m0 * (y * m0 - (q3 * x - q1 * z)) + s * q2) - y,\n+                        2 * (m0 * (z * m0 - (q1 * y - q2 * x)) + s * q3) - z);\n+\n+  }\n+\n+  /** Apply the instance to another rotation.\n+   * Applying the instance to a rotation is computing the composition\n+   * in an order compliant with the following rule : let u be any\n+   * vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image\n+   * of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u),\n+   * where comp = applyTo(r).\n+   * @param r rotation to apply the rotation to\n+   * @return a new rotation which is the composition of r by the instance\n+   */\n+  public Rotation applyTo(Rotation r) {\n+    return new Rotation(r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),\n+                        r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),\n+                        r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),\n+                        r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),\n+                        false);\n+  }\n+\n+  /** Apply the inverse of the instance to another rotation.\n+   * Applying the inverse of the instance to a rotation is computing\n+   * the composition in an order compliant with the following rule :\n+   * let u be any vector and v its image by r (i.e. r.applyTo(u) = v),\n+   * let w be the inverse image of v by the instance\n+   * (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where\n+   * comp = applyInverseTo(r).\n+   * @param r rotation to apply the rotation to\n+   * @return a new rotation which is the composition of r by the inverse\n+   * of the instance\n+   */\n+  public Rotation applyInverseTo(Rotation r) {\n+    return new Rotation(-r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),\n+                        -r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),\n+                        -r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),\n+                        -r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),\n+                        false);\n+  }\n+\n+  /** Perfect orthogonality on a 3X3 matrix.\n+   * @param m initial matrix (not exactly orthogonal)\n+   * @param threshold convergence threshold for the iterative\n+   * orthogonality correction (convergence is reached when the\n+   * difference between two steps of the Frobenius norm of the\n+   * correction is below this threshold)\n+   * @return an orthogonal matrix close to m\n+   * @exception NotARotationMatrixException if the matrix cannot be\n+   * orthogonalized with the given threshold after 10 iterations\n+   */\n+  private double[][] orthogonalizeMatrix(double[][] m, double threshold)\n+    throws NotARotationMatrixException {\n+    double[] m0 = m[0];\n+    double[] m1 = m[1];\n+    double[] m2 = m[2];\n+    double x00 = m0[0];\n+    double x01 = m0[1];\n+    double x02 = m0[2];\n+    double x10 = m1[0];\n+    double x11 = m1[1];\n+    double x12 = m1[2];\n+    double x20 = m2[0];\n+    double x21 = m2[1];\n+    double x22 = m2[2];\n+    double fn = 0;\n+    double fn1;\n+\n+    double[][] o = new double[3][3];\n+    double[] o0 = o[0];\n+    double[] o1 = o[1];\n+    double[] o2 = o[2];\n+\n+    // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)\n+    int i = 0;\n+    while (++i < 11) {\n+\n+      // Mt.Xn\n+      double mx00 = m0[0] * x00 + m1[0] * x10 + m2[0] * x20;\n+      double mx10 = m0[1] * x00 + m1[1] * x10 + m2[1] * x20;\n+      double mx20 = m0[2] * x00 + m1[2] * x10 + m2[2] * x20;\n+      double mx01 = m0[0] * x01 + m1[0] * x11 + m2[0] * x21;\n+      double mx11 = m0[1] * x01 + m1[1] * x11 + m2[1] * x21;\n+      double mx21 = m0[2] * x01 + m1[2] * x11 + m2[2] * x21;\n+      double mx02 = m0[0] * x02 + m1[0] * x12 + m2[0] * x22;\n+      double mx12 = m0[1] * x02 + m1[1] * x12 + m2[1] * x22;\n+      double mx22 = m0[2] * x02 + m1[2] * x12 + m2[2] * x22;\n+\n+      // Xn+1\n+      o0[0] = x00 - 0.5 * (x00 * mx00 + x01 * mx10 + x02 * mx20 - m0[0]);\n+      o0[1] = x01 - 0.5 * (x00 * mx01 + x01 * mx11 + x02 * mx21 - m0[1]);\n+      o0[2] = x02 - 0.5 * (x00 * mx02 + x01 * mx12 + x02 * mx22 - m0[2]);\n+      o1[0] = x10 - 0.5 * (x10 * mx00 + x11 * mx10 + x12 * mx20 - m1[0]);\n+      o1[1] = x11 - 0.5 * (x10 * mx01 + x11 * mx11 + x12 * mx21 - m1[1]);\n+      o1[2] = x12 - 0.5 * (x10 * mx02 + x11 * mx12 + x12 * mx22 - m1[2]);\n+      o2[0] = x20 - 0.5 * (x20 * mx00 + x21 * mx10 + x22 * mx20 - m2[0]);\n+      o2[1] = x21 - 0.5 * (x20 * mx01 + x21 * mx11 + x22 * mx21 - m2[1]);\n+      o2[2] = x22 - 0.5 * (x20 * mx02 + x21 * mx12 + x22 * mx22 - m2[2]);\n+\n+      // correction on each elements\n+      double corr00 = o0[0] - m0[0];\n+      double corr01 = o0[1] - m0[1];\n+      double corr02 = o0[2] - m0[2];\n+      double corr10 = o1[0] - m1[0];\n+      double corr11 = o1[1] - m1[1];\n+      double corr12 = o1[2] - m1[2];\n+      double corr20 = o2[0] - m2[0];\n+      double corr21 = o2[1] - m2[1];\n+      double corr22 = o2[2] - m2[2];\n+\n+      // Frobenius norm of the correction\n+      fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 +\n+            corr10 * corr10 + corr11 * corr11 + corr12 * corr12 +\n+            corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n+\n+      // convergence test\n+      if (FastMath.abs(fn1 - fn) <= threshold)\n+        return o;\n+\n+      // prepare next iteration\n+      x00 = o0[0];\n+      x01 = o0[1];\n+      x02 = o0[2];\n+      x10 = o1[0];\n+      x11 = o1[1];\n+      x12 = o1[2];\n+      x20 = o2[0];\n+      x21 = o2[1];\n+      x22 = o2[2];\n+      fn  = fn1;\n+\n+    }\n+\n+    // the algorithm did not converge after 10 iterations\n+    throw new NotARotationMatrixException(\n+            LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX,\n+            i - 1);\n+  }\n+\n+  /** Compute the <i>distance</i> between two rotations.\n+   * <p>The <i>distance</i> is intended here as a way to check if two\n+   * rotations are almost similar (i.e. they transform vectors the same way)\n+   * or very different. It is mathematically defined as the angle of\n+   * the rotation r that prepended to one of the rotations gives the other\n+   * one:</p>\n+   * <pre>\n+   *        r<sub>1</sub>(r) = r<sub>2</sub>\n+   * </pre>\n+   * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n+   * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n+   * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n+   * reached for some v. The distance is equal to 0 if and only if the two\n+   * rotations are identical.</p>\n+   * <p>Comparing two rotations should always be done using this value rather\n+   * than for example comparing the components of the quaternions. It is much\n+   * more stable, and has a geometric meaning. Also comparing quaternions\n+   * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n+   * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n+   * their components are different (they are exact opposites).</p>\n+   * @param r1 first rotation\n+   * @param r2 second rotation\n+   * @return <i>distance</i> between r1 and r2\n+   */\n+  public static double distance(Rotation r1, Rotation r2) {\n+      return r1.applyInverseTo(r2).getAngle();\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threeD/RotationOrder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+/**\n+ * This class is a utility representing a rotation order specification\n+ * for Cardan or Euler angles specification.\n+ *\n+ * This class cannot be instanciated by the user. He can only use one\n+ * of the twelve predefined supported orders as an argument to either\n+ * the {@link Rotation#Rotation(RotationOrder,double,double,double)}\n+ * constructor or the {@link Rotation#getAngles} method.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public final class RotationOrder {\n+\n+    /** Set of Cardan angles.\n+     * this ordered set of rotations is around X, then around Y, then\n+     * around Z\n+     */\n+    public static final RotationOrder XYZ =\n+      new RotationOrder(\"XYZ\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);\n+\n+    /** Set of Cardan angles.\n+     * this ordered set of rotations is around X, then around Z, then\n+     * around Y\n+     */\n+    public static final RotationOrder XZY =\n+      new RotationOrder(\"XZY\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);\n+\n+    /** Set of Cardan angles.\n+     * this ordered set of rotations is around Y, then around X, then\n+     * around Z\n+     */\n+    public static final RotationOrder YXZ =\n+      new RotationOrder(\"YXZ\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);\n+\n+    /** Set of Cardan angles.\n+     * this ordered set of rotations is around Y, then around Z, then\n+     * around X\n+     */\n+    public static final RotationOrder YZX =\n+      new RotationOrder(\"YZX\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);\n+\n+    /** Set of Cardan angles.\n+     * this ordered set of rotations is around Z, then around X, then\n+     * around Y\n+     */\n+    public static final RotationOrder ZXY =\n+      new RotationOrder(\"ZXY\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);\n+\n+    /** Set of Cardan angles.\n+     * this ordered set of rotations is around Z, then around Y, then\n+     * around X\n+     */\n+    public static final RotationOrder ZYX =\n+      new RotationOrder(\"ZYX\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);\n+\n+    /** Set of Euler angles.\n+     * this ordered set of rotations is around X, then around Y, then\n+     * around X\n+     */\n+    public static final RotationOrder XYX =\n+      new RotationOrder(\"XYX\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);\n+\n+    /** Set of Euler angles.\n+     * this ordered set of rotations is around X, then around Z, then\n+     * around X\n+     */\n+    public static final RotationOrder XZX =\n+      new RotationOrder(\"XZX\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);\n+\n+    /** Set of Euler angles.\n+     * this ordered set of rotations is around Y, then around X, then\n+     * around Y\n+     */\n+    public static final RotationOrder YXY =\n+      new RotationOrder(\"YXY\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);\n+\n+    /** Set of Euler angles.\n+     * this ordered set of rotations is around Y, then around Z, then\n+     * around Y\n+     */\n+    public static final RotationOrder YZY =\n+      new RotationOrder(\"YZY\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);\n+\n+    /** Set of Euler angles.\n+     * this ordered set of rotations is around Z, then around X, then\n+     * around Z\n+     */\n+    public static final RotationOrder ZXZ =\n+      new RotationOrder(\"ZXZ\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);\n+\n+    /** Set of Euler angles.\n+     * this ordered set of rotations is around Z, then around Y, then\n+     * around Z\n+     */\n+    public static final RotationOrder ZYZ =\n+      new RotationOrder(\"ZYZ\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);\n+\n+    /** Name of the rotations order. */\n+    private final String name;\n+\n+    /** Axis of the first rotation. */\n+    private final Vector3D a1;\n+\n+    /** Axis of the second rotation. */\n+    private final Vector3D a2;\n+\n+    /** Axis of the third rotation. */\n+    private final Vector3D a3;\n+\n+    /** Private constructor.\n+     * This is a utility class that cannot be instantiated by the user,\n+     * so its only constructor is private.\n+     * @param name name of the rotation order\n+     * @param a1 axis of the first rotation\n+     * @param a2 axis of the second rotation\n+     * @param a3 axis of the third rotation\n+     */\n+    private RotationOrder(final String name,\n+                          final Vector3D a1, final Vector3D a2, final Vector3D a3) {\n+        this.name = name;\n+        this.a1   = a1;\n+        this.a2   = a2;\n+        this.a3   = a3;\n+    }\n+\n+    /** Get a string representation of the instance.\n+     * @return a string representation of the instance (in fact, its name)\n+     */\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /** Get the axis of the first rotation.\n+     * @return axis of the first rotation\n+     */\n+    public Vector3D getA1() {\n+        return a1;\n+    }\n+\n+    /** Get the axis of the second rotation.\n+     * @return axis of the second rotation\n+     */\n+    public Vector3D getA2() {\n+        return a2;\n+    }\n+\n+    /** Get the axis of the second rotation.\n+     * @return axis of the second rotation\n+     */\n+    public Vector3D getA3() {\n+        return a3;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threeD/Vector3D.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * This class implements vectors in a three-dimensional space.\n+ * <p>Instance of this class are guaranteed to be immutable.</p>\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class Vector3D implements Serializable {\n+  /** Null vector (coordinates: 0, 0, 0). */\n+  public static final Vector3D ZERO   = new Vector3D(0, 0, 0);\n+\n+  /** First canonical vector (coordinates: 1, 0, 0). */\n+  public static final Vector3D PLUS_I = new Vector3D(1, 0, 0);\n+\n+  /** Opposite of the first canonical vector (coordinates: -1, 0, 0). */\n+  public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);\n+\n+  /** Second canonical vector (coordinates: 0, 1, 0). */\n+  public static final Vector3D PLUS_J = new Vector3D(0, 1, 0);\n+\n+  /** Opposite of the second canonical vector (coordinates: 0, -1, 0). */\n+  public static final Vector3D MINUS_J = new Vector3D(0, -1, 0);\n+\n+  /** Third canonical vector (coordinates: 0, 0, 1). */\n+  public static final Vector3D PLUS_K = new Vector3D(0, 0, 1);\n+\n+  /** Opposite of the third canonical vector (coordinates: 0, 0, -1).  */\n+  public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);\n+\n+  // CHECKSTYLE: stop ConstantName\n+  /** A vector with all coordinates set to NaN. */\n+  public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);\n+  // CHECKSTYLE: resume ConstantName\n+\n+  /** A vector with all coordinates set to positive infinity. */\n+  public static final Vector3D POSITIVE_INFINITY =\n+      new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+\n+  /** A vector with all coordinates set to negative infinity. */\n+  public static final Vector3D NEGATIVE_INFINITY =\n+      new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n+\n+  /** Default format. */\n+  private static final Vector3DFormat DEFAULT_FORMAT =\n+      Vector3DFormat.getInstance();\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 5133268763396045979L;\n+\n+  /** Abscissa. */\n+  private final double x;\n+\n+  /** Ordinate. */\n+  private final double y;\n+\n+  /** Height. */\n+  private final double z;\n+\n+  /** Simple constructor.\n+   * Build a vector from its coordinates\n+   * @param x abscissa\n+   * @param y ordinate\n+   * @param z height\n+   * @see #getX()\n+   * @see #getY()\n+   * @see #getZ()\n+   */\n+  public Vector3D(double x, double y, double z) {\n+    this.x = x;\n+    this.y = y;\n+    this.z = z;\n+  }\n+\n+  /** Simple constructor.\n+   * Build a vector from its azimuthal coordinates\n+   * @param alpha azimuth (&alpha;) around Z\n+   *              (0 is +X, &pi;/2 is +Y, &pi; is -X and 3&pi;/2 is -Y)\n+   * @param delta elevation (&delta;) above (XY) plane, from -&pi;/2 to +&pi;/2\n+   * @see #getAlpha()\n+   * @see #getDelta()\n+   */\n+  public Vector3D(double alpha, double delta) {\n+    double cosDelta = FastMath.cos(delta);\n+    this.x = FastMath.cos(alpha) * cosDelta;\n+    this.y = FastMath.sin(alpha) * cosDelta;\n+    this.z = FastMath.sin(delta);\n+  }\n+\n+  /** Multiplicative constructor\n+   * Build a vector from another one and a scale factor.\n+   * The vector built will be a * u\n+   * @param a scale factor\n+   * @param u base (unscaled) vector\n+   */\n+  public Vector3D(double a, Vector3D u) {\n+    this.x = a * u.x;\n+    this.y = a * u.y;\n+    this.z = a * u.z;\n+  }\n+\n+  /** Linear constructor\n+   * Build a vector from two other ones and corresponding scale factors.\n+   * The vector built will be a1 * u1 + a2 * u2\n+   * @param a1 first scale factor\n+   * @param u1 first base (unscaled) vector\n+   * @param a2 second scale factor\n+   * @param u2 second base (unscaled) vector\n+   */\n+  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\n+    this.x = a1 * u1.x + a2 * u2.x;\n+    this.y = a1 * u1.y + a2 * u2.y;\n+    this.z = a1 * u1.z + a2 * u2.z;\n+  }\n+\n+  /** Linear constructor\n+   * Build a vector from three other ones and corresponding scale factors.\n+   * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n+   * @param a1 first scale factor\n+   * @param u1 first base (unscaled) vector\n+   * @param a2 second scale factor\n+   * @param u2 second base (unscaled) vector\n+   * @param a3 third scale factor\n+   * @param u3 third base (unscaled) vector\n+   */\n+  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n+                  double a3, Vector3D u3) {\n+    this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x;\n+    this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y;\n+    this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z;\n+  }\n+\n+  /** Linear constructor\n+   * Build a vector from four other ones and corresponding scale factors.\n+   * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n+   * @param a1 first scale factor\n+   * @param u1 first base (unscaled) vector\n+   * @param a2 second scale factor\n+   * @param u2 second base (unscaled) vector\n+   * @param a3 third scale factor\n+   * @param u3 third base (unscaled) vector\n+   * @param a4 fourth scale factor\n+   * @param u4 fourth base (unscaled) vector\n+   */\n+  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n+                  double a3, Vector3D u3, double a4, Vector3D u4) {\n+    this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;\n+    this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y + a4 * u4.y;\n+    this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z + a4 * u4.z;\n+  }\n+\n+  /** Get the abscissa of the vector.\n+   * @return abscissa of the vector\n+   * @see #Vector3D(double, double, double)\n+   */\n+  public double getX() {\n+    return x;\n+  }\n+\n+  /** Get the ordinate of the vector.\n+   * @return ordinate of the vector\n+   * @see #Vector3D(double, double, double)\n+   */\n+  public double getY() {\n+    return y;\n+  }\n+\n+  /** Get the height of the vector.\n+   * @return height of the vector\n+   * @see #Vector3D(double, double, double)\n+   */\n+  public double getZ() {\n+    return z;\n+  }\n+\n+  /** Get the L<sub>1</sub> norm for the vector.\n+   * @return L<sub>1</sub> norm for the vector\n+   */\n+  public double getNorm1() {\n+    return FastMath.abs(x) + FastMath.abs(y) + FastMath.abs(z);\n+  }\n+\n+  /** Get the L<sub>2</sub> norm for the vector.\n+   * @return euclidian norm for the vector\n+   */\n+  public double getNorm() {\n+    return FastMath.sqrt (x * x + y * y + z * z);\n+  }\n+\n+  /** Get the square of the norm for the vector.\n+   * @return square of the euclidian norm for the vector\n+   */\n+  public double getNormSq() {\n+    return x * x + y * y + z * z;\n+  }\n+\n+  /** Get the L<sub>&infin;</sub> norm for the vector.\n+   * @return L<sub>&infin;</sub> norm for the vector\n+   */\n+  public double getNormInf() {\n+    return FastMath.max(FastMath.max(FastMath.abs(x), FastMath.abs(y)), FastMath.abs(z));\n+  }\n+\n+  /** Get the azimuth of the vector.\n+   * @return azimuth (&alpha;) of the vector, between -&pi; and +&pi;\n+   * @see #Vector3D(double, double)\n+   */\n+  public double getAlpha() {\n+    return FastMath.atan2(y, x);\n+  }\n+\n+  /** Get the elevation of the vector.\n+   * @return elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2\n+   * @see #Vector3D(double, double)\n+   */\n+  public double getDelta() {\n+    return FastMath.asin(z / getNorm());\n+  }\n+\n+  /** Add a vector to the instance.\n+   * @param v vector to add\n+   * @return a new vector\n+   */\n+  public Vector3D add(Vector3D v) {\n+    return new Vector3D(x + v.x, y + v.y, z + v.z);\n+  }\n+\n+  /** Add a scaled vector to the instance.\n+   * @param factor scale factor to apply to v before adding it\n+   * @param v vector to add\n+   * @return a new vector\n+   */\n+  public Vector3D add(double factor, Vector3D v) {\n+    return new Vector3D(x + factor * v.x, y + factor * v.y, z + factor * v.z);\n+  }\n+\n+  /** Subtract a vector from the instance.\n+   * @param v vector to subtract\n+   * @return a new vector\n+   */\n+  public Vector3D subtract(Vector3D v) {\n+    return new Vector3D(x - v.x, y - v.y, z - v.z);\n+  }\n+\n+  /** Subtract a scaled vector from the instance.\n+   * @param factor scale factor to apply to v before subtracting it\n+   * @param v vector to subtract\n+   * @return a new vector\n+   */\n+  public Vector3D subtract(double factor, Vector3D v) {\n+    return new Vector3D(x - factor * v.x, y - factor * v.y, z - factor * v.z);\n+  }\n+\n+  /** Get a normalized vector aligned with the instance.\n+   * @return a new normalized vector\n+   * @exception ArithmeticException if the norm is zero\n+   */\n+  public Vector3D normalize() {\n+    double s = getNorm();\n+    if (s == 0) {\n+      throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n+    }\n+    return scalarMultiply(1 / s);\n+  }\n+\n+  /** Get a vector orthogonal to the instance.\n+   * <p>There are an infinite number of normalized vectors orthogonal\n+   * to the instance. This method picks up one of them almost\n+   * arbitrarily. It is useful when one needs to compute a reference\n+   * frame with one of the axes in a predefined direction. The\n+   * following example shows how to build a frame having the k axis\n+   * aligned with the known vector u :\n+   * <pre><code>\n+   *   Vector3D k = u.normalize();\n+   *   Vector3D i = k.orthogonal();\n+   *   Vector3D j = Vector3D.crossProduct(k, i);\n+   * </code></pre></p>\n+   * @return a new normalized vector orthogonal to the instance\n+   * @exception ArithmeticException if the norm of the instance is null\n+   */\n+  public Vector3D orthogonal() {\n+\n+    double threshold = 0.6 * getNorm();\n+    if (threshold == 0) {\n+      throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n+    }\n+\n+    if ((x >= -threshold) && (x <= threshold)) {\n+      double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n+      return new Vector3D(0, inverse * z, -inverse * y);\n+    } else if ((y >= -threshold) && (y <= threshold)) {\n+      double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n+      return new Vector3D(-inverse * z, 0, inverse * x);\n+    }\n+    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n+    return new Vector3D(inverse * y, -inverse * x, 0);\n+\n+  }\n+\n+  /** Compute the angular separation between two vectors.\n+   * <p>This method computes the angular separation between two\n+   * vectors using the dot product for well separated vectors and the\n+   * cross product for almost aligned vectors. This allows to have a\n+   * good accuracy in all cases, even for vectors very close to each\n+   * other.</p>\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return angular separation between v1 and v2\n+   * @exception ArithmeticException if either vector has a null norm\n+   */\n+  public static double angle(Vector3D v1, Vector3D v2) {\n+\n+    double normProduct = v1.getNorm() * v2.getNorm();\n+    if (normProduct == 0) {\n+      throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n+    }\n+\n+    double dot = dotProduct(v1, v2);\n+    double threshold = normProduct * 0.9999;\n+    if ((dot < -threshold) || (dot > threshold)) {\n+      // the vectors are almost aligned, compute using the sine\n+      Vector3D v3 = crossProduct(v1, v2);\n+      if (dot >= 0) {\n+        return FastMath.asin(v3.getNorm() / normProduct);\n+      }\n+      return FastMath.PI - FastMath.asin(v3.getNorm() / normProduct);\n+    }\n+\n+    // the vectors are sufficiently separated to use the cosine\n+    return FastMath.acos(dot / normProduct);\n+\n+  }\n+\n+  /** Get the opposite of the instance.\n+   * @return a new vector which is opposite to the instance\n+   */\n+  public Vector3D negate() {\n+    return new Vector3D(-x, -y, -z);\n+  }\n+\n+  /** Multiply the instance by a scalar\n+   * @param a scalar\n+   * @return a new vector\n+   */\n+  public Vector3D scalarMultiply(double a) {\n+    return new Vector3D(a * x, a * y, a * z);\n+  }\n+\n+  /**\n+   * Returns true if any coordinate of this vector is NaN; false otherwise\n+   * @return  true if any coordinate of this vector is NaN; false otherwise\n+   */\n+  public boolean isNaN() {\n+      return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z);\n+  }\n+\n+  /**\n+   * Returns true if any coordinate of this vector is infinite and none are NaN;\n+   * false otherwise\n+   * @return  true if any coordinate of this vector is infinite and none are NaN;\n+   * false otherwise\n+   */\n+  public boolean isInfinite() {\n+      return !isNaN() && (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z));\n+  }\n+\n+  /**\n+   * Test for the equality of two 3D vectors.\n+   * <p>\n+   * If all coordinates of two 3D vectors are exactly the same, and none are\n+   * <code>Double.NaN</code>, the two 3D vectors are considered to be equal.\n+   * </p>\n+   * <p>\n+   * <code>NaN</code> coordinates are considered to affect globally the vector\n+   * and be equals to each other - i.e, if either (or all) coordinates of the\n+   * 3D vector are equal to <code>Double.NaN</code>, the 3D vector is equal to\n+   * {@link #NaN}.\n+   * </p>\n+   *\n+   * @param other Object to test for equality to this\n+   * @return true if two 3D vector objects are equal, false if\n+   *         object is null, not an instance of Vector3D, or\n+   *         not equal to this Vector3D instance\n+   *\n+   */\n+  @Override\n+  public boolean equals(Object other) {\n+\n+    if (this == other) {\n+      return true;\n+    }\n+\n+    if (other instanceof Vector3D) {\n+      final Vector3D rhs = (Vector3D)other;\n+      if (rhs.isNaN()) {\n+          return this.isNaN();\n+      }\n+\n+      return (x == rhs.x) && (y == rhs.y) && (z == rhs.z);\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Get a hashCode for the 3D vector.\n+   * <p>\n+   * All NaN values have the same hash code.</p>\n+   *\n+   * @return a hash code value for this object\n+   */\n+  @Override\n+  public int hashCode() {\n+      if (isNaN()) {\n+          return 8;\n+      }\n+      return 31 * (23 * MathUtils.hash(x) +  19 * MathUtils.hash(y) +  MathUtils.hash(z));\n+  }\n+\n+  /** Compute the dot-product of two vectors.\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the dot product v1.v2\n+   */\n+  public static double dotProduct(Vector3D v1, Vector3D v2) {\n+    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n+  }\n+\n+  /** Compute the cross-product of two vectors.\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the cross product v1 ^ v2 as a new Vector\n+   */\n+  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n+\n+      final double n1 = v1.getNormSq();\n+      final double n2 = v2.getNormSq();\n+      if ((n1 * n2) < MathUtils.SAFE_MIN) {\n+          return ZERO;\n+      }\n+\n+      // rescale both vectors without losing precision,\n+      // to ensure their norm are the same order of magnitude\n+      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;\n+      final double x1    = FastMath.scalb(v1.x, -deltaExp);\n+      final double y1    = FastMath.scalb(v1.y, -deltaExp);\n+      final double z1    = FastMath.scalb(v1.z, -deltaExp);\n+      final double x2    = FastMath.scalb(v2.x,  deltaExp);\n+      final double y2    = FastMath.scalb(v2.y,  deltaExp);\n+      final double z2    = FastMath.scalb(v2.z,  deltaExp);\n+\n+      // we reduce cancellation errors by preconditioning,\n+      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n+      // v3 without loss of precision. See Kahan lecture\n+      // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n+      // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n+\n+      // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n+      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);\n+      final double rho   = FastMath.rint(256 * ratio) / 256;\n+\n+      final double x3 = x1 - rho * x2;\n+      final double y3 = y1 - rho * y2;\n+      final double z3 = z1 - rho * z2;\n+\n+      // compute cross product from v3 and v2 instead of v1 and v2\n+      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);\n+\n+  }\n+\n+  /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n+   * <p>Calling this method is equivalent to calling:\n+   * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n+   * vector is built</p>\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n+   */\n+  public static double distance1(Vector3D v1, Vector3D v2) {\n+    final double dx = FastMath.abs(v2.x - v1.x);\n+    final double dy = FastMath.abs(v2.y - v1.y);\n+    final double dz = FastMath.abs(v2.z - v1.z);\n+    return dx + dy + dz;\n+  }\n+\n+  /** Compute the distance between two vectors according to the L<sub>2</sub> norm.\n+   * <p>Calling this method is equivalent to calling:\n+   * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n+   * vector is built</p>\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n+   */\n+  public static double distance(Vector3D v1, Vector3D v2) {\n+    final double dx = v2.x - v1.x;\n+    final double dy = v2.y - v1.y;\n+    final double dz = v2.z - v1.z;\n+    return FastMath.sqrt(dx * dx + dy * dy + dz * dz);\n+  }\n+\n+  /** Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n+   * <p>Calling this method is equivalent to calling:\n+   * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n+   * vector is built</p>\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n+   */\n+  public static double distanceInf(Vector3D v1, Vector3D v2) {\n+    final double dx = FastMath.abs(v2.x - v1.x);\n+    final double dy = FastMath.abs(v2.y - v1.y);\n+    final double dz = FastMath.abs(v2.z - v1.z);\n+    return FastMath.max(FastMath.max(dx, dy), dz);\n+  }\n+\n+  /** Compute the square of the distance between two vectors.\n+   * <p>Calling this method is equivalent to calling:\n+   * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n+   * vector is built</p>\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the square of the distance between v1 and v2\n+   */\n+  public static double distanceSq(Vector3D v1, Vector3D v2) {\n+    final double dx = v2.x - v1.x;\n+    final double dy = v2.y - v1.y;\n+    final double dz = v2.z - v1.z;\n+    return dx * dx + dy * dy + dz * dz;\n+  }\n+\n+  /** Get a string representation of this vector.\n+   * @return a string representation of this vector\n+   */\n+  @Override\n+  public String toString() {\n+      return DEFAULT_FORMAT.format(this);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threeD/Vector3DFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.util.CompositeFormat;\n+import org.apache.commons.math.exception.MathParseException;\n+\n+/**\n+ * Formats a 3D vector in components list format \"{x; y; z}\".\n+ * <p>The prefix and suffix \"{\" and \"}\" and the separator \"; \" can be replaced by\n+ * any user-defined strings. The number format for components can be configured.</p>\n+ * <p>White space is ignored at parse time, even if it is in the prefix, suffix\n+ * or separator specifications. So even if the default separator does include a space\n+ * character that is used at format time, both input string \"{1;1;1}\" and\n+ * \" { 1 ; 1 ; 1 } \" will be parsed without error and the same vector will be\n+ * returned. In the second case, however, the parse position after parsing will be\n+ * just after the closing curly brace, i.e. just before the trailing space.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class Vector3DFormat {\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -5447606608652576301L;\n+    /** The default prefix: \"{\". */\n+    private static final String DEFAULT_PREFIX = \"{\";\n+    /** The default suffix: \"}\". */\n+    private static final String DEFAULT_SUFFIX = \"}\";\n+    /** The default separator: \", \". */\n+    private static final String DEFAULT_SEPARATOR = \"; \";\n+    /** Prefix. */\n+    private final String prefix;\n+    /** Suffix. */\n+    private final String suffix;\n+    /** Separator. */\n+    private final String separator;\n+    /** Trimmed prefix. */\n+    private final String trimmedPrefix;\n+    /** Trimmed suffix. */\n+    private final String trimmedSuffix;\n+    /** Trimmed separator. */\n+    private final String trimmedSeparator;\n+    /** The format used for components. */\n+    private final NumberFormat format;\n+\n+    /**\n+     * Create an instance with default settings.\n+     * <p>The instance uses the default prefix, suffix and separator:\n+     * \"{\", \"}\", and \"; \" and the default number format for components.</p>\n+     */\n+    public Vector3DFormat() {\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR,\n+             CompositeFormat.getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with a custom number format for components.\n+     * @param format the custom format for components.\n+     */\n+    public Vector3DFormat(final NumberFormat format) {\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix and separator.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param separator separator to use instead of the default \"; \"\n+     */\n+    public Vector3DFormat(final String prefix, final String suffix,\n+                          final String separator) {\n+        this(prefix, suffix, separator, CompositeFormat.getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix, separator and format\n+     * for components.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param separator separator to use instead of the default \"; \"\n+     * @param format the custom format for components.\n+     */\n+    public Vector3DFormat(final String prefix, final String suffix,\n+                          final String separator, final NumberFormat format) {\n+        this.prefix      = prefix;\n+        this.suffix      = suffix;\n+        this.separator   = separator;\n+        trimmedPrefix    = prefix.trim();\n+        trimmedSuffix    = suffix.trim();\n+        trimmedSeparator = separator.trim();\n+        this.format      = format;\n+    }\n+\n+    /**\n+     * Get the set of locales for which 3D vectors formats are available.\n+     * <p>This is the same set as the {@link NumberFormat} set.</p>\n+     * @return available 3D vector format locales.\n+     */\n+    public static Locale[] getAvailableLocales() {\n+        return NumberFormat.getAvailableLocales();\n+    }\n+\n+    /**\n+     * Get the format prefix.\n+     * @return format prefix.\n+     */\n+    public String getPrefix() {\n+        return prefix;\n+    }\n+\n+    /**\n+     * Get the format suffix.\n+     * @return format suffix.\n+     */\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    /**\n+     * Get the format separator between components.\n+     * @return format separator.\n+     */\n+    public String getSeparator() {\n+        return separator;\n+    }\n+\n+    /**\n+     * Get the components format.\n+     * @return components format.\n+     */\n+    public NumberFormat getFormat() {\n+        return format;\n+    }\n+\n+    /**\n+     * Returns the default 3D vector format for the current locale.\n+     * @return the default 3D vector format.\n+     */\n+    public static Vector3DFormat getInstance() {\n+        return getInstance(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Returns the default 3D vector format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the 3D vector format specific to the given locale.\n+     */\n+    public static Vector3DFormat getInstance(final Locale locale) {\n+        return new Vector3DFormat(CompositeFormat.getDefaultNumberFormat(locale));\n+    }\n+\n+    /**\n+     * This method calls {@link #format(Vector3D,StringBuffer,FieldPosition)}.\n+     *\n+     * @param v Vector3D object to format.\n+     * @return a formatted vector.\n+     */\n+    public String format(Vector3D v) {\n+        return format(v, new StringBuffer(), new FieldPosition(0)).toString();\n+    }\n+\n+    /**\n+     * Formats a {@link Vector3D} object to produce a string.\n+     * @param vector the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(Vector3D vector, StringBuffer toAppendTo,\n+                               FieldPosition pos) {\n+\n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        // format prefix\n+        toAppendTo.append(prefix);\n+\n+        // format components\n+        CompositeFormat.formatDouble(vector.getX(), format, toAppendTo, pos);\n+        toAppendTo.append(separator);\n+        CompositeFormat.formatDouble(vector.getY(), format, toAppendTo, pos);\n+        toAppendTo.append(separator);\n+        CompositeFormat.formatDouble(vector.getZ(), format, toAppendTo, pos);\n+\n+        // format suffix\n+        toAppendTo.append(suffix);\n+\n+        return toAppendTo;\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link Vector3D} object.\n+     * @param source the string to parse\n+     * @return the parsed {@link Vector3D} object.\n+     * @throws MathParseException if the beginning of the specified string\n+     * cannot be parsed.\n+     */\n+    public Vector3D parse(String source) {\n+        ParsePosition parsePosition = new ParsePosition(0);\n+        Vector3D result = parse(source, parsePosition);\n+        if (parsePosition.getIndex() == 0) {\n+            throw new MathParseException(source,\n+                                         parsePosition.getErrorIndex(),\n+                                         Vector3D.class);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link Vector3D} object.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link Vector3D} object.\n+     */\n+    public Vector3D parse(String source, ParsePosition pos) {\n+        int initialIndex = pos.getIndex();\n+\n+        // parse prefix\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        if (!CompositeFormat.parseFixedstring(source, trimmedPrefix, pos)) {\n+            return null;\n+        }\n+\n+        // parse X component\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        Number x = CompositeFormat.parseNumber(source, format, pos);\n+        if (x == null) {\n+            // invalid abscissa\n+            // set index back to initial, error index should already be set\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse Y component\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        if (!CompositeFormat.parseFixedstring(source, trimmedSeparator, pos)) {\n+            return null;\n+        }\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        Number y = CompositeFormat.parseNumber(source, format, pos);\n+        if (y == null) {\n+            // invalid ordinate\n+            // set index back to initial, error index should already be set\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse Z component\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        if (!CompositeFormat.parseFixedstring(source, trimmedSeparator, pos)) {\n+            return null;\n+        }\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        Number z = CompositeFormat.parseNumber(source, format, pos);\n+        if (z == null) {\n+            // invalid height\n+            // set index back to initial, error index should already be set\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse suffix\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        if (!CompositeFormat.parseFixedstring(source, trimmedSuffix, pos)) {\n+            return null;\n+        }\n+\n+        return new Vector3D(x.doubleValue(), y.doubleValue(), z.doubleValue());\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twoD/Line.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.twoD;\n+\n+import java.awt.geom.AffineTransform;\n+\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.geometry.euclidean.oneD.IntervalsSet;\n+import org.apache.commons.math.geometry.euclidean.oneD.OrientedPoint;\n+import org.apache.commons.math.geometry.euclidean.oneD.Point1D;\n+import org.apache.commons.math.geometry.partitioning.BSPTree;\n+import org.apache.commons.math.geometry.partitioning.Hyperplane;\n+import org.apache.commons.math.geometry.partitioning.Point;\n+import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n+import org.apache.commons.math.geometry.partitioning.SubSpace;\n+import org.apache.commons.math.geometry.partitioning.Transform;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/** This class represents an oriented line in the 2D plane.\n+\n+ * <p>An oriented line can be defined either by prolongating a line\n+ * segment between two points past these points, or by one point and\n+ * an angular direction (in trigonometric orientation).</p>\n+\n+ * <p>Since it is oriented the two half planes at its two sides are\n+ * unambiguously identified as a left half plane and a right half\n+ * plane. This can be used to identify the interior and the exterior\n+ * in a simple way by local properties only when part of a line is\n+ * used to define part of a polygon boundary.</p>\n+\n+ * <p>A line can also be used to completely define a reference frame\n+ * in the plane. It is sufficient to select one specific point in the\n+ * line (the orthogonal projection of the original reference frame on\n+ * the line) and to use the unit vector in the line direction and the\n+ * orthogonal vector oriented from left half plane to right half\n+ * plane. We define two coordinates by the process, the\n+ * <em>abscissa</em> along the line, and the <em>offset</em> across\n+ * the line. All points of the plane are uniquely identified by these\n+ * two coordinates. The line is the set of points at zero offset, the\n+ * left half plane is the set of points with negative offsets and the\n+ * right half plane is the set of points with positive offsets.</p>\n+\n+ * @version $Revision$ $Date$\n+ */\n+public class Line implements Hyperplane {\n+\n+    /** Angle with respect to the abscissa axis. */\n+    private double angle;\n+\n+    /** Cosine of the line angle. */\n+    private double cos;\n+\n+    /** Sine of the line angle. */\n+    private double sin;\n+\n+    /** Offset of the frame origin. */\n+    private double originOffset;\n+\n+    /** Build a line from two points.\n+     * <p>The line is oriented from p1 to p2</p>\n+     * @param p1 first point\n+     * @param p2 second point\n+     */\n+    public Line(final Point2D p1, final Point2D p2) {\n+        reset(p1, p2);\n+    }\n+\n+    /** Build a line from a point and an angle.\n+     * @param p point belonging to the line\n+     * @param angle angle of the line with respect to abscissa axis\n+     */\n+    public Line(final Point2D p, final double angle) {\n+        reset(p, angle);\n+    }\n+\n+    /** Build a line from its internal characteristics.\n+     * @param angle angle of the line with respect to abscissa axis\n+     * @param cos cosine of the angle\n+     * @param sin sine of the angle\n+     * @param originOffset offset of the origin\n+     */\n+    private Line(final double angle, final double cos, final double sin, final double originOffset) {\n+        this.angle        = angle;\n+        this.cos          = cos;\n+        this.sin          = sin;\n+        this.originOffset = originOffset;\n+    }\n+\n+    /** Copy constructor.\n+     * <p>The created instance is completely independant from the\n+     * original instance, it is a deep copy.</p>\n+     * @param line line to copy\n+     */\n+    public Line(final Line line) {\n+        angle        = MathUtils.normalizeAngle(line.angle, FastMath.PI);\n+        cos          = FastMath.cos(angle);\n+        sin          = FastMath.sin(angle);\n+        originOffset = line.originOffset;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Hyperplane copySelf() {\n+        return new Line(this);\n+    }\n+\n+    /** Reset the instance as if built from two points.\n+     * <p>The line is oriented from p1 to p2</p>\n+     * @param p1 first point\n+     * @param p2 second point\n+     */\n+    public void reset(final Point2D p1, final Point2D p2) {\n+        final double dx = p2.x - p1.x;\n+        final double dy = p2.y - p1.y;\n+        final double d = FastMath.hypot(dx, dy);\n+        if (d == 0.0) {\n+            angle        = 0.0;\n+            cos          = 1.0;\n+            sin          = 0.0;\n+            originOffset = p1.y;\n+        } else {\n+            angle        = FastMath.PI + FastMath.atan2(-dy, -dx);\n+            cos          = FastMath.cos(angle);\n+            sin          = FastMath.sin(angle);\n+            originOffset = (p2.x * p1.y - p1.x * p2.y) / d;\n+        }\n+    }\n+\n+    /** Reset the instance as if built from a line and an angle.\n+     * @param p point belonging to the line\n+     * @param alpha angle of the line with respect to abscissa axis\n+     */\n+    public void reset(final Point2D p, final double alpha) {\n+        this.angle   = MathUtils.normalizeAngle(alpha, FastMath.PI);\n+        cos          = FastMath.cos(this.angle);\n+        sin          = FastMath.sin(this.angle);\n+        originOffset = cos * p.y - sin * p.x;\n+    }\n+\n+    /** Revert the instance.\n+     */\n+    public void revertSelf() {\n+        if (angle < FastMath.PI) {\n+            angle += FastMath.PI;\n+        } else {\n+            angle -= FastMath.PI;\n+        }\n+        cos          = -cos;\n+        sin          = -sin;\n+        originOffset = -originOffset;\n+    }\n+\n+    /** Get the reverse of the instance.\n+     * <p>Get a line with reversed orientation with respect to the\n+     * instance. A new object is built, the instance is untouched.</p>\n+     * @return a new line, with orientation opposite to the instance orientation\n+     */\n+    public Line getReverse() {\n+        return new Line((angle < FastMath.PI) ? (angle + FastMath.PI) : (angle - FastMath.PI),\n+                        -cos, -sin, -originOffset);\n+    }\n+\n+    /** Transform a 2D space point into a line point.\n+     * @param point 2D point (must be a {@link Point2D Point2D}\n+     * instance)\n+     * @return line point corresponding to the 2D point (really a {@link\n+     * org.apache.commons.math.geometry.euclidean.oneD.Point1D Point1D} instance)\n+     * @see #toSpace\n+     */\n+    public Point toSubSpace(final Point point) {\n+        final Point2D p2D = (Point2D) point;\n+        return new Point1D(cos * p2D.x + sin * p2D.y);\n+    }\n+\n+    /** Get one point from the line.\n+     * @param point desired abscissa for the point (must be a {@link\n+     * org.apache.commons.math.geometry.euclidean.oneD.Point1D Point1D} instance)\n+     * @return line point at specified abscissa (really a {@link Point2D\n+     * Point2D} instance)\n+     */\n+    public Point toSpace(final Point point) {\n+        final double abscissa = ((Point1D) point).getAbscissa();\n+        return new Point2D(abscissa * cos - originOffset * sin,\n+                           abscissa * sin + originOffset * cos);\n+    }\n+\n+    /** Get the intersection point of the instance and another line.\n+     * @param other other line\n+     * @return intersection point of the instance and the other line\n+     * (really a {@link Point2D Point2D} instance)\n+     */\n+    public SubSpace intersection(final Hyperplane other) {\n+        final Line otherL = (Line) other;\n+        final double d = sin * otherL.cos - otherL.sin * cos;\n+        if (FastMath.abs(d) < 1.0e-10) {\n+            return null;\n+        }\n+        return new Point2D((cos * otherL.originOffset - otherL.cos * originOffset) / d,\n+                           (sin * otherL.originOffset - otherL.sin * originOffset) / d);\n+    }\n+\n+    /** Build a region covering the whole hyperplane.\n+     * @return a region covering the whole hyperplane\n+     */\n+    public Region wholeHyperplane() {\n+        return new IntervalsSet();\n+    }\n+\n+    /** Build a region covering the whole space.\n+     * @return a region containing the instance (really a {@link\n+     * PolygonsSet PolygonsSet} instance)\n+     */\n+    public Region wholeSpace() {\n+        return new PolygonsSet();\n+    }\n+\n+    /** Get the offset (oriented distance) of a parallel line.\n+     * <p>This method should be called only for parallel lines otherwise\n+     * the result is not meaningful.</p>\n+     * <p>The offset is 0 if both lines are the same, it is\n+     * positive if the line is on the right side of the instance and\n+     * negative if it is on the left side, according to its natural\n+     * orientation.</p>\n+     * @param line line to check\n+     * @return offset of the line\n+     */\n+    public double getOffset(final Line line) {\n+        return originOffset +\n+               ((cos * line.cos + sin * line.sin > 0) ? -line.originOffset : line.originOffset);\n+    }\n+\n+    /** Get the offset (oriented distance) of a point to the line.\n+     * <p>The offset is 0 if the point belongs to the line, it is\n+     * positive if the point is on the right side of the line and\n+     * negative if it is on the left side, according to its natural\n+     * orientation.</p>\n+     * @param point point to check (must be a {@link Point2D Point2D} instance)\n+     * @return offset of the point\n+     */\n+    public double getOffset(final Point point) {\n+        final Point2D p2D = (Point2D) point;\n+        return sin * p2D.x - cos * p2D.y + originOffset;\n+    }\n+\n+    /** Check if the instance has the same orientation as another hyperplane.\n+     * <p>This method is expected to be called on parallel hyperplanes\n+     * (i.e. when the {@link #side side} method would return {@link\n+     * org.apache.commons.math.geometry.partitioning.Hyperplane.Side#HYPER HYPER}\n+     * for some sub-hyperplane having the specified hyperplane\n+     * as its underlying hyperplane). The method should <em>not</em>\n+     * re-check for parallelism, only for orientation, typically by\n+     * testing something like the sign of the dot-products of\n+     * normals.</p>\n+     * @param other other hyperplane to check against the instance\n+     * @return true if the instance and the other hyperplane have\n+     * the same orientation\n+     */\n+    public boolean sameOrientationAs(final Hyperplane other) {\n+        final Line otherL = (Line) other;\n+        return (sin * otherL.sin + cos * otherL.cos) >= 0.0;\n+    }\n+\n+    /** Get one point from the plane.\n+     * @param abscissa desired abscissa for the point\n+     * @param offset desired offset for the point\n+     * @return one point in the plane, with given abscissa and offset\n+     * relative to the line\n+     */\n+    public Point2D getPointAt(final Point1D abscissa, final double offset) {\n+        final double x       = abscissa.getAbscissa();\n+        final double dOffset = offset - originOffset;\n+        return new Point2D(x * cos + dOffset * sin, x * sin - dOffset * cos);\n+    }\n+\n+    /** Check if the line contains a point.\n+     * @param p point to check\n+     * @return true if p belongs to the line\n+     */\n+    public boolean contains(final Point2D p) {\n+        return FastMath.abs(getOffset(p)) < 1.0e-10;\n+    }\n+\n+    /** Check the instance is parallel to another line.\n+     * @param line other line to check\n+     * @return true if the instance is parallel to the other line\n+     * (they can have either the same or opposite orientations)\n+     */\n+    public boolean isParallelTo(final Line line) {\n+        return FastMath.abs(sin * line.cos - cos * line.sin) < 1.0e-10;\n+    }\n+\n+    /** Translate the line to force it passing by a point.\n+     * @param p point by which the line should pass\n+     */\n+    public void translateToPoint(final Point2D p) {\n+        originOffset = cos * p.y - sin * p.x;\n+    }\n+\n+    /** Get the angle of the line.\n+     * @return the angle of the line with respect to the abscissa axis\n+     */\n+    public double getAngle() {\n+        return MathUtils.normalizeAngle(angle, FastMath.PI);\n+    }\n+\n+    /** Set the angle of the line.\n+     * @param angle new angle of the line with respect to the abscissa axis\n+     */\n+    public void setAngle(final double angle) {\n+        this.angle = MathUtils.normalizeAngle(angle, FastMath.PI);\n+        cos        = FastMath.cos(this.angle);\n+        sin        = FastMath.sin(this.angle);\n+    }\n+\n+    /** Get the offset of the origin.\n+     * @return the offset of the origin\n+     */\n+    public double getOriginOffset() {\n+        return originOffset;\n+    }\n+\n+    /** Set the offset of the origin.\n+     * @param offset offset of the origin\n+     */\n+    public void setOriginOffset(final double offset) {\n+        originOffset = offset;\n+    }\n+\n+    /** Compute the relative position of a sub-hyperplane with respect\n+     * to the instance.\n+     * @param sub sub-hyperplane to check\n+     * @return one of {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#PLUS PLUS},\n+     * {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#MINUS MINUS},\n+     * {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#BOTH BOTH},\n+     * {@link org.apache.commons.math.geometry.partitioning.Hyperplane.Side#HYPER HYPER}\n+     */\n+    public Side side(final SubHyperplane sub) {\n+\n+        final Hyperplane otherHyp = sub.getHyperplane();\n+        final Point2D    crossing = (Point2D) intersection(otherHyp);\n+\n+        if (crossing == null) {\n+            // the lines are parallel,\n+            final double global = getOffset((Line) otherHyp);\n+            return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n+        }\n+\n+        // the lines do intersect\n+        final boolean direct = FastMath.sin(((Line) otherHyp).angle - angle) < 0;\n+        final Point1D x = (Point1D) otherHyp.toSubSpace(crossing);\n+        return sub.getRemainingRegion().side(new OrientedPoint(x, direct));\n+\n+    }\n+\n+    /** Split a sub-hyperplane in two parts by the instance.\n+     * @param sub sub-hyperplane to split\n+     * @return an object containing both the part of the sub-hyperplane\n+     * on the plus side of the instance and the part of the\n+     * sub-hyperplane on the minus side of the instance\n+     */\n+    public SplitSubHyperplane split(final SubHyperplane sub) {\n+\n+        final Line    otherLine = (Line) sub.getHyperplane();\n+        final Point2D crossing  = (Point2D) intersection(otherLine);\n+\n+        if (crossing == null) {\n+            // the lines are parallel\n+            final double global = getOffset(otherLine);\n+            return (global < -1.0e-10) ?\n+                   new SplitSubHyperplane(null, sub) :\n+                   new SplitSubHyperplane(sub, null);\n+        }\n+\n+        // the lines do intersect\n+        final boolean direct = FastMath.sin(otherLine.angle - angle) < 0;\n+        final Point1D x      = (Point1D) otherLine.toSubSpace(crossing);\n+        final SubHyperplane subPlus  = new SubHyperplane(new OrientedPoint(x, !direct));\n+        final SubHyperplane subMinus = new SubHyperplane(new OrientedPoint(x, direct));\n+\n+        final BSPTree splitTree =\n+            sub.getRemainingRegion().getTree(false).split(subMinus);\n+        final BSPTree plusTree  = Region.isEmpty(splitTree.getPlus()) ?\n+                                  new BSPTree(Boolean.FALSE) :\n+                                  new BSPTree(subPlus, new BSPTree(Boolean.FALSE),\n+                                              splitTree.getPlus(), null);\n+        final BSPTree minusTree = Region.isEmpty(splitTree.getMinus()) ?\n+                                  new BSPTree(Boolean.FALSE) :\n+                                  new BSPTree(subMinus, new BSPTree(Boolean.FALSE),\n+                                              splitTree.getMinus(), null);\n+\n+        return new SplitSubHyperplane(new SubHyperplane(otherLine.copySelf(),\n+                                                        new IntervalsSet(plusTree)),\n+                                                        new SubHyperplane(otherLine.copySelf(),\n+                                                                          new IntervalsSet(minusTree)));\n+\n+    }\n+\n+    /** Get a {@link org.apache.commons.math.geometry.partitioning.Transform\n+     * Transform} embedding an affine transform.\n+     * @param transform affine transform to embed (must be inversible\n+     * otherwise the {@link\n+     * org.apache.commons.math.geometry.partitioning.Transform#apply(Hyperplane)\n+     * apply(Hyperplane)} method would work only for some lines, and\n+     * fail for other ones)\n+     * @return a new transform that can be applied to either {@link\n+     * Point2D Point2D}, {@link Line Line} or {@link\n+     * org.apache.commons.math.geometry.partitioning.SubHyperplane\n+     * SubHyperplane} instances\n+     * @exception MathIllegalArgumentException if the transform is non invertible\n+     */\n+    public static Transform getTransform(final AffineTransform transform) throws MathIllegalArgumentException {\n+        return new LineTransform(transform);\n+    }\n+\n+    /** Class embedding an affine transform.\n+     * <p>This class is used in order to apply an affine transform to a\n+     * line. Using a specific object allow to perform some computations\n+     * on the transform only once even if the same transform is to be\n+     * applied to a large number of lines (for example to a large\n+     * polygon)./<p>\n+     */\n+    private static class LineTransform implements Transform {\n+\n+        // CHECKSTYLE: stop JavadocVariable check\n+        private double cXX;\n+        private double cXY;\n+        private double cX1;\n+        private double cYX;\n+        private double cYY;\n+        private double cY1;\n+\n+        private double c1Y;\n+        private double c1X;\n+        private double c11;\n+        // CHECKSTYLE: resume JavadocVariable check\n+\n+        /** Build an affine line transform from a n {@code AffineTransform}.\n+         * @param transform transform to use (must be invertible otherwise\n+         * the {@link LineTransform#apply(Hyperplane)} method would work\n+         * only for some lines, and fail for other ones)\n+         * @exception MathIllegalArgumentException if the transform is non invertible\n+         */\n+        public LineTransform(final AffineTransform transform) throws MathIllegalArgumentException {\n+\n+            final double[] m = new double[6];\n+            transform.getMatrix(m);\n+            cXX = m[0];\n+            cXY = m[2];\n+            cX1 = m[4];\n+            cYX = m[1];\n+            cYY = m[3];\n+            cY1 = m[5];\n+\n+            c1Y = cXY * cY1 - cYY * cX1;\n+            c1X = cXX * cY1 - cYX * cX1;\n+            c11 = cXX * cYY - cYX * cXY;\n+\n+            if (FastMath.abs(c11) < 1.0e-20) {\n+                throw new MathIllegalArgumentException(LocalizedFormats.NON_INVERTIBLE_TRANSFORM);\n+            }\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public Point apply(final Point point) {\n+            final Point2D p2D = (Point2D) point;\n+            final double  x   = p2D.getX();\n+            final double  y   = p2D.getY();\n+            return new Point2D(cXX * x + cXY * y + cX1,\n+                               cYX * x + cYY * y + cY1);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public Hyperplane apply(final Hyperplane hyperplane) {\n+            final Line   line    = (Line) hyperplane;\n+            final double rOffset = c1X * line.cos + c1Y * line.sin + c11 * line.originOffset;\n+            final double rCos    = cXX * line.cos + cXY * line.sin;\n+            final double rSin    = cYX * line.cos + cYY * line.sin;\n+            final double inv     = 1.0 / FastMath.sqrt(rSin * rSin + rCos * rCos);\n+            return new Line(FastMath.PI + FastMath.atan2(-rSin, -rCos),\n+                            inv * rCos, inv * rSin,\n+                            inv * rOffset);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public SubHyperplane apply(final SubHyperplane sub,\n+                                   final Hyperplane original, final Hyperplane transformed) {\n+            final OrientedPoint op = (OrientedPoint) sub.getHyperplane();\n+            final Point1D newLoc =\n+                (Point1D) transformed.toSubSpace(apply(original.toSpace(op.getLocation())));\n+            return new SubHyperplane(new OrientedPoint(newLoc, op.isDirect()));\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twoD/NestedLoops.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.twoD;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.geometry.euclidean.oneD.OrientedPoint;\n+import org.apache.commons.math.geometry.euclidean.oneD.Point1D;\n+import org.apache.commons.math.geometry.partitioning.Hyperplane;\n+import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n+\n+/** This class represent a tree of nested 2D boundary loops.\n+\n+ * <p>This class is used during Piece instances construction.\n+ * Beams are built using the outline edges as\n+ * representative of facets, the orientation of these facets are\n+ * meaningful. However, we want to allow the user to specify its\n+ * outline loops without having to take care of this orientation. This\n+ * class is devoted to correct mis-oriented loops.<p>\n+\n+ * <p>Orientation is computed assuming the piece is finite, i.e. the\n+ * outermost loops have their exterior side facing points at infinity,\n+ * and hence are oriented counter-clockwise. The orientation of\n+ * internal loops is computed as the reverse of the orientation of\n+ * their immediate surrounding loop.</p>\n+\n+ * @version $Revision$ $Date$\n+ */\n+class NestedLoops {\n+\n+    /** Boundary loop. */\n+    private Point2D[] loop;\n+\n+    /** Surrounded loops. */\n+    private ArrayList<NestedLoops> surrounded;\n+\n+    /** Polygon enclosing a finite region. */\n+    private Region polygon;\n+\n+    /** Indicator for original loop orientation. */\n+    private boolean originalIsClockwise;\n+\n+    /** Simple Constructor.\n+     * <p>Build an empty tree of nested loops. This instance will become\n+     * the root node of a complete tree, it is not associated with any\n+     * loop by itself, the outermost loops are in the root tree child\n+     * nodes.</p>\n+     */\n+    public NestedLoops() {\n+        surrounded = new ArrayList<NestedLoops>();\n+    }\n+\n+    /** Constructor.\n+     * <p>Build a tree node with neither parent nor children</p>\n+     * @param loop boundary loop (will be reversed in place if needed)\n+     * @exception MathIllegalArgumentException if an outline has an open boundary loop\n+     */\n+    private NestedLoops(final Point2D[] loop) throws MathIllegalArgumentException {\n+\n+        if (loop[0] == null) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.OUTLINE_BOUNDARY_LOOP_OPEN);\n+        }\n+\n+        this.loop = loop;\n+        surrounded = new ArrayList<NestedLoops>();\n+\n+        // build the polygon defined by the loop\n+        final ArrayList<SubHyperplane> edges = new ArrayList<SubHyperplane>();\n+        Point2D current = loop[loop.length - 1];\n+        for (int i = 0; i < loop.length; ++i) {\n+            final Point2D previous = current;\n+            current = loop[i];\n+            final Line   line   = new Line(previous, current);\n+            final Region region =  Region.buildConvex(Arrays.asList(new Hyperplane[] {\n+                new OrientedPoint((Point1D) line.toSubSpace(previous), false),\n+                new OrientedPoint((Point1D) line.toSubSpace(current),  true)\n+            }));\n+            edges.add(new SubHyperplane(line, region));\n+        }\n+        polygon = new PolygonsSet(edges);\n+\n+        // ensure the polygon encloses a finite region of the plane\n+        if (Double.isInfinite(polygon.getSize())) {\n+            polygon = polygon.getComplement();\n+            originalIsClockwise = false;\n+        } else {\n+            originalIsClockwise = true;\n+        }\n+\n+    }\n+\n+    /** Add a loop in a tree.\n+     * @param bLoop boundary loop (will be reversed in place if needed)\n+     * @exception MathIllegalArgumentException if an outline has crossing\n+     * boundary loops or open boundary loops\n+     */\n+    public void add(final Point2D[] bLoop) throws MathIllegalArgumentException {\n+        add(new NestedLoops(bLoop));\n+    }\n+\n+    /** Add a loop in a tree.\n+     * @param node boundary loop (will be reversed in place if needed)\n+     * @exception MathIllegalArgumentException if an outline has boundary\n+     * loops that cross each other\n+     */\n+    private void add(final NestedLoops node) throws MathIllegalArgumentException {\n+\n+        // check if we can go deeper in the tree\n+        for (final NestedLoops child : surrounded) {\n+            if (child.polygon.contains(node.polygon)) {\n+                child.add(node);\n+                return;\n+            }\n+        }\n+\n+        // check if we can absorb some of the instance children\n+        for (final Iterator<NestedLoops> iterator = surrounded.iterator(); iterator.hasNext();) {\n+            final NestedLoops child = iterator.next();\n+            if (node.polygon.contains(child.polygon)) {\n+                node.surrounded.add(child);\n+                iterator.remove();\n+            }\n+        }\n+\n+        // we should be separate from the remaining children\n+        for (final NestedLoops child : surrounded) {\n+            if (!Region.intersection(node.polygon, child.polygon).isEmpty()) {\n+                throw new MathIllegalArgumentException(LocalizedFormats.CROSSING_BOUNDARY_LOOPS);\n+            }\n+        }\n+\n+        surrounded.add(node);\n+\n+    }\n+\n+    /** Correct the orientation of the loops contained in the tree.\n+     * <p>This is this method that really inverts the loops that where\n+     * provided through the {@link #add(Point2D[]) add} method if\n+     * they are mis-oriented</p>\n+     */\n+    public void correctOrientation() {\n+        for (NestedLoops child : surrounded) {\n+            child.setClockWise(true);\n+        }\n+    }\n+\n+    /** Set the loop orientation.\n+     * @param clockwise if true, the loop should be set to clockwise\n+     * orientation\n+     */\n+    private void setClockWise(final boolean clockwise) {\n+\n+        if (originalIsClockwise ^ clockwise) {\n+            // we need to inverse the original loop\n+            int min = -1;\n+            int max = loop.length;\n+            while (++min < --max) {\n+                final Point2D tmp = loop[min];\n+                loop[min] = loop[max];\n+                loop[max] = tmp;\n+            }\n+        }\n+\n+        // go deeper in the tree\n+        for (final NestedLoops child : surrounded) {\n+            child.setClockWise(!clockwise);\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twoD/Point2D.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.twoD;\n+\n+import org.apache.commons.math.geometry.partitioning.Point;\n+import org.apache.commons.math.geometry.partitioning.SubSpace;\n+\n+/** This class represents a 2D point.\n+ * <p>Instances of this class are guaranteed to be immutable.</p>\n+ * @version $Revision$ $Date$\n+ */\n+public class Point2D extends java.awt.geom.Point2D.Double implements Point, SubSpace {\n+\n+    /** Point at undefined (NaN) coordinates. */\n+    public static final Point2D UNDEFINED = new Point2D(java.lang.Double.NaN, java.lang.Double.NaN);\n+\n+    /** Serializable UID. */\n+    private static final long serialVersionUID = 8883702098988517151L;\n+\n+    /** Build a point with default coordinates.\n+     */\n+    public Point2D() {\n+    }\n+\n+    /** Build a point from its coordinates.\n+     * @param x abscissa\n+     * @param y ordinate\n+     */\n+    public Point2D(final double x, final double y) {\n+        super(x, y);\n+    }\n+\n+    /** Build a point from a java awt point.\n+     * @param point java awt point\n+     */\n+    public Point2D(final java.awt.geom.Point2D.Double point) {\n+        super(point.x, point.y);\n+    }\n+\n+    /** Transform a 2D space point into a sub-space point.\n+     * @param point 2D point of the space\n+     * @return always return null\n+     * @see #toSpace\n+     */\n+    public Point toSubSpace(final Point point) {\n+        return null;\n+    }\n+\n+    /** Transform a sub-space point into a space point.\n+     * @param point ignored parameter\n+     * @return always return the instance\n+     * @see #toSubSpace\n+     */\n+    public Point toSpace(final Point point) {\n+        return this;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twoD/PolygonsSet.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.twoD;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.math.geometry.euclidean.oneD.Point1D;\n+import org.apache.commons.math.geometry.partitioning.BSPTree;\n+import org.apache.commons.math.geometry.partitioning.Hyperplane;\n+import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n+import org.apache.commons.math.geometry.partitioning.utilities.AVLTree;\n+import org.apache.commons.math.util.FastMath;\n+\n+/** This class represents a 2D region: a set of polygons.\n+ * @version $Revision$ $Date$\n+ */\n+public class PolygonsSet extends Region {\n+\n+    /** Vertices organized as boundary loops. */\n+    private Point2D[][] vertices;\n+\n+    /** Build a polygons set representing the whole real line.\n+     */\n+    public PolygonsSet() {\n+        super();\n+    }\n+\n+    /** Build a polygons set from a BSP tree.\n+     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n+     * {@code Boolean} attribute representing the inside status of\n+     * the corresponding cell (true for inside cells, false for outside\n+     * cells). In order to avoid building too many small objects, it is\n+     * recommended to use the predefined constants\n+     * {@code Boolean.TRUE} and {@code Boolean.FALSE}</p>\n+     * @param tree inside/outside BSP tree representing the region\n+     */\n+    public PolygonsSet(final BSPTree tree) {\n+        super(tree);\n+    }\n+\n+    /** Build a polygons set from a Boundary REPresentation (B-rep).\n+     * <p>The boundary is provided as a collection of {@link\n+     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the\n+     * interior part of the region on its minus side and the exterior on\n+     * its plus side.</p>\n+     * <p>The boundary elements can be in any order, and can form\n+     * several non-connected sets (like for example polygons with holes\n+     * or a set of disjoints polyhedrons considered as a whole). In\n+     * fact, the elements do not even need to be connected together\n+     * (their topological connections are not used here). However, if the\n+     * boundary does not really separate an inside open from an outside\n+     * open (open having here its topological meaning), then subsequent\n+     * calls to the {@link\n+     * Region#checkPoint(org.apache.commons.math.geometry.partitioning.Point)\n+     * checkPoint} method will not be meaningful anymore.</p>\n+     * <p>If the boundary is empty, the region will represent the whole\n+     * space.</p>\n+     * @param boundary collection of boundary elements, as a\n+     * collection of {@link SubHyperplane SubHyperplane} objects\n+     */\n+    public PolygonsSet(final Collection<SubHyperplane> boundary) {\n+        super(boundary);\n+    }\n+\n+    /** Build a parallellepipedic box.\n+     * @param xMin low bound along the x direction\n+     * @param xMax high bound along the x direction\n+     * @param yMin low bound along the y direction\n+     * @param yMax high bound along the y direction\n+     */\n+    public PolygonsSet(final double xMin, final double xMax,\n+                       final double yMin, final double yMax) {\n+        this(buildConvex(boxBoundary(xMin, xMax, yMin, yMax)).getTree(false));\n+    }\n+\n+    /** Create a list of hyperplanes representing the boundary of a box.\n+     * @param xMin low bound along the x direction\n+     * @param xMax high bound along the x direction\n+     * @param yMin low bound along the y direction\n+     * @param yMax high bound along the y direction\n+     * @return boundary of the box\n+     */\n+    private static List<Hyperplane> boxBoundary(final double xMin, final double xMax,\n+                                                final double yMin, final double yMax) {\n+        final Point2D minMin = new Point2D(xMin, yMin);\n+        final Point2D minMax = new Point2D(xMin, yMax);\n+        final Point2D maxMin = new Point2D(xMax, yMin);\n+        final Point2D maxMax = new Point2D(xMax, yMax);\n+        return Arrays.asList(new Hyperplane[] {\n+            new Line(minMin, maxMin),\n+            new Line(maxMin, maxMax),\n+            new Line(maxMax, minMax),\n+            new Line(minMax, minMin)\n+        });\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Region buildNew(final BSPTree tree) {\n+        return new PolygonsSet(tree);\n+    }\n+\n+    /** {@inheritDoc} */\n+    protected void computeGeometricalProperties() {\n+\n+        final Point2D[][] v = getVertices();\n+\n+        if (v.length == 0) {\n+            if ((Boolean) getTree(false).getAttribute()) {\n+                setSize(Double.POSITIVE_INFINITY);\n+                setBarycenter(Point2D.UNDEFINED);\n+            } else {\n+                setSize(0);\n+                setBarycenter(new Point2D(0, 0));\n+            }\n+        } else if (v[0][0] == null) {\n+            // there is at least one open-loop: the polygon is infinite\n+            setSize(Double.POSITIVE_INFINITY);\n+            setBarycenter(Point2D.UNDEFINED);\n+        } else {\n+            // all loops are closed, we compute some integrals around the shape\n+\n+            double sum  = 0;\n+            double sumX = 0;\n+            double sumY = 0;\n+\n+            for (Point2D[] loop : v) {\n+                double x1 = loop[loop.length - 1].x;\n+                double y1 = loop[loop.length - 1].y;\n+                for (final Point2D point : loop) {\n+                    final double x0 = x1;\n+                    final double y0 = y1;\n+                    x1 = point.x;\n+                    y1 = point.y;\n+                    final double factor = x0 * y1 - y0 * x1;\n+                    sum  += factor;\n+                    sumX += factor * (x0 + x1);\n+                    sumY += factor * (y0 + y1);\n+                }\n+            }\n+\n+            if (sum < 0) {\n+                // the polygon as a finite outside surrounded by an infinite inside\n+                setSize(Double.POSITIVE_INFINITY);\n+                setBarycenter(Point2D.UNDEFINED);\n+            } else {\n+                setSize(sum / 2);\n+                setBarycenter(new Point2D(sumX / (3 * sum), sumY / (3 * sum)));\n+            }\n+\n+        }\n+\n+    }\n+\n+    /** Get the vertices of the polygon.\n+     * <p>The polygon boundary can be represented as an array of loops,\n+     * each loop being itself an array of vertices.</p>\n+     * <p>In order to identify open loops which start and end by\n+     * infinite edges, the open loops arrays start with a null point. In\n+     * this case, the first non null point and the last point of the\n+     * array do not represent real vertices, they are dummy points\n+     * intended only to get the direction of the first and last edge. An\n+     * open loop consisting of a single infinite line will therefore be\n+     * represented by a three elements array with one null point\n+     * followed by two dummy points. The open loops are always the first\n+     * ones in the loops array.</p>\n+     * <p>If the polygon has no boundary at all, a zero length loop\n+     * array will be returned.</p>\n+     * <p>All line segments in the various loops have the inside of the\n+     * region on their left side and the outside on their right side\n+     * when moving in the underlying line direction. This means that\n+     * closed loops surrounding finite areas obey the direct\n+     * trigonometric orientation.</p>\n+     * @return vertices of the polygon, organized as oriented boundary\n+     * loops with the open loops first (the returned value is guaranteed\n+     * to be non-null)\n+     */\n+    public Point2D[][] getVertices() {\n+        if (vertices == null) {\n+            if (getTree(false).getCut() == null) {\n+                vertices = new Point2D[0][];\n+            } else {\n+\n+                // sort the segmfinal ents according to their start point\n+                final SegmentsBuilder visitor = new SegmentsBuilder();\n+                getTree(true).visit(visitor);\n+                final AVLTree<Segment> sorted = visitor.getSorted();\n+\n+                // identify the loops, starting from the open ones\n+                // (their start segments final are naturally at the sorted set beginning)\n+                final ArrayList<List<Segment>> loops = new ArrayList<List<Segment>>();\n+                while (!sorted.isEmpty()) {\n+                    final AVLTree<Segment>.Node node = sorted.getSmallest();\n+                    final List<Segment> loop = followLoop(node, sorted);\n+                    if (loop != null) {\n+                        loops.add(loop);\n+                    }\n+                }\n+\n+                // tranform the loops in an array of arrays of points\n+                vertices = new Point2D[loops.size()][];\n+                int i = 0;\n+\n+                for (final List<Segment> loop : loops) {\n+                    if (loop.size() < 2) {\n+                        // sifinal ngle infinite line\n+                        final Line line = ((Segment) loop.get(0)).getLine();\n+                        vertices[i++] = new Point2D[] {\n+                            null,\n+                            (Point2D) line.toSpace(new Point1D(-Float.MAX_VALUE)),\n+                            (Point2D) line.toSpace(new Point1D(+Float.MAX_VALUE))\n+                        };\n+                    } else if (((Segment) loop.get(0)).getStart() == null) {\n+                        // open lofinal op with at least one real point\n+                        final Point2D[] array = new Point2D[loop.size() + 2];\n+                        int j = 0;\n+                        for (Segment segment : loop) {\n+\n+                            if (j == 0) {\n+                                // null point and first dummy point\n+                                double x =\n+                                    ((Point1D) segment.getLine().toSubSpace(segment.getEnd())).getAbscissa();\n+                                x -= FastMath.max(1.0, FastMath.abs(x / 2));\n+                                array[j++] = null;\n+                                array[j++] = (Point2D) segment.getLine().toSpace(new Point1D(x));\n+                            }\n+\n+                            if (j < (array.length - 1)) {\n+                                // current point\n+                                array[j++] = segment.getEnd();\n+                            }\n+\n+                            if (j == (array.length - 1)) {\n+                                // last dummy point\n+                                double x =\n+                                    ((Point1D) segment.getLine().toSubSpace(segment.getStart())).getAbscissa();\n+                                x += FastMath.max(1.0, FastMath.abs(x / 2));\n+                                array[j++] = (Point2D) segment.getLine().toSpace(new Point1D(x));\n+                            }\n+\n+                        }\n+                        vertices[i++] = array;\n+                    } else {\n+                        final Point2D[] array = new Point2D[loop.size()];\n+                        int j = 0;\n+                        for (Segment segment : loop) {\n+                            array[j++] = segment.getStart();\n+                        }\n+                        vertices[i++] = array;\n+                    }\n+                }\n+\n+            }\n+        }\n+\n+        return vertices.clone();\n+\n+    }\n+\n+    /** Follow a boundary loop.\n+     * @param node node containing the segment starting the loop\n+     * @param sorted set of segments belonging to the boundary, sorted by\n+     * start points (contains {@code node})\n+     * @return a list of connected sub-hyperplanes starting at\n+     * {@code node}\n+     */\n+    private List<Segment> followLoop(final AVLTree<Segment>.Node node,\n+                                     final AVLTree<Segment> sorted) {\n+\n+        final ArrayList<Segment> loop = new ArrayList<Segment>();\n+        Segment segment = (Segment) node.getElement();\n+        loop.add(segment);\n+        final Point2D globalStart = segment.getStart();\n+        Point2D end = segment.getEnd();\n+        node.delete();\n+\n+        // is this an open or a closed loop ?\n+        final boolean open = segment.getStart() == null;\n+\n+        while ((end != null) && (open || (globalStart.distance(end) > 1.0e-10))) {\n+\n+            // search the sub-hyperplane starting where the previous one ended\n+            AVLTree<Segment>.Node selectedNode = null;\n+            Segment       selectedSegment  = null;\n+            double        selectedDistance = Double.POSITIVE_INFINITY;\n+            final Segment lowerLeft        = new Segment(end, -1.0e-10, -1.0e-10);\n+            final Segment upperRight       = new Segment(end, +1.0e-10, +1.0e-10);\n+            for (AVLTree<Segment>.Node n = sorted.getNotSmaller(lowerLeft);\n+                 (n != null) && (n.getElement().compareTo(upperRight) <= 0);\n+                 n = n.getNext()) {\n+                segment = (Segment) n.getElement();\n+                final double distance = end.distance(segment.getStart());\n+                if (distance < selectedDistance) {\n+                    selectedNode     = n;\n+                    selectedSegment  = segment;\n+                    selectedDistance = distance;\n+                }\n+            }\n+\n+            if (selectedDistance > 1.0e-10) {\n+                // this is a degenerated loop, it probably comes from a very\n+                // tiny region with some segments smaller than the threshold, we\n+                // simply ignore it\n+                return null;\n+            }\n+\n+            end = selectedSegment.getEnd();\n+            loop.add(selectedSegment);\n+            selectedNode.delete();\n+\n+        }\n+\n+        if ((loop.size() == 2) && !open) {\n+            // this is a degenerated infinitely thin loop, we simply ignore it\n+            return null;\n+        }\n+\n+        if ((end == null) && !open) {\n+            throw new RuntimeException(\"internal error\");\n+        }\n+\n+        return loop;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twoD/Segment.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.twoD;\n+\n+import org.apache.commons.math.geometry.partitioning.utilities.OrderedTuple;\n+\n+/** This class holds segments information before they are connected.\n+ * @version $Revision$ $Date$\n+ */\n+class Segment implements Comparable<Segment> {\n+\n+    /** Start point of the segment. */\n+    private final Point2D      start;\n+\n+    /** End point of the segments. */\n+    private final Point2D      end;\n+\n+    /** Line containing the segment. */\n+    private final Line         line;\n+\n+    /** Sorting key. */\n+    private      OrderedTuple sortingKey;\n+\n+    /** Build a segment.\n+     * @param start start point of the segment\n+     * @param end end point of the segment\n+     * @param line line containing the segment\n+     */\n+    public Segment(final Point2D start, final Point2D end, final Line line) {\n+        this.start  = start;\n+        this.end    = end;\n+        this.line   = line;\n+        sortingKey = (start == null) ?\n+                     new OrderedTuple(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) :\n+                     new OrderedTuple(start.x, start.y);\n+    }\n+\n+    /** Build a dummy segment.\n+     * <p>\n+     * The object built is not a real segment, only the sorting key is used to\n+     * allow searching in the neighborhood of a point. This is an horrible hack ...\n+     * </p>\n+     * @param start start point of the segment\n+     * @param dx abscissa offset from the start point\n+     * @param dy ordinate offset from the start point\n+     */\n+    public Segment(final Point2D start, final double dx, final double dy) {\n+        this.start = null;\n+        this.end   = null;\n+        this.line  = null;\n+        sortingKey = new OrderedTuple(start.x + dx, start.y + dy);\n+    }\n+\n+    /** Get the start point of the segment.\n+     * @return start point of the segment\n+     */\n+    public Point2D getStart() {\n+        return start;\n+    }\n+\n+    /** Get the end point of the segment.\n+     * @return end point of the segment\n+     */\n+    public Point2D getEnd() {\n+        return end;\n+    }\n+\n+    /** Get the line containing the segment.\n+     * @return line containing the segment\n+     */\n+    public Line getLine() {\n+        return line;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int compareTo(final Segment o) {\n+        return sortingKey.compareTo(o.sortingKey);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean equals(final Object other) {\n+        if (this == other) {\n+            return true;\n+        } else if (other instanceof Segment) {\n+            return compareTo((Segment) other) == 0;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int hashCode() {\n+        return start.hashCode() ^ end.hashCode() ^ line.hashCode() ^ sortingKey.hashCode();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twoD/SegmentBuilder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.twoD;\n+\n+import java.util.List;\n+\n+import org.apache.commons.math.geometry.euclidean.oneD.Interval;\n+import org.apache.commons.math.geometry.euclidean.oneD.IntervalsSet;\n+import org.apache.commons.math.geometry.euclidean.oneD.Point1D;\n+import org.apache.commons.math.geometry.partitioning.BSPTree;\n+import org.apache.commons.math.geometry.partitioning.BSPTreeVisitor;\n+import org.apache.commons.math.geometry.partitioning.Region.BoundaryAttribute;\n+import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n+import org.apache.commons.math.geometry.partitioning.utilities.AVLTree;\n+\n+/** Visitor building segments.\n+ * @version $Revision$ $Date$\n+ */\n+class SegmentsBuilder implements BSPTreeVisitor {\n+\n+    /** Sorted segments. */\n+    private AVLTree<Segment> sorted;\n+\n+    /** Simple constructor. */\n+    public SegmentsBuilder() {\n+        sorted = new AVLTree<Segment>();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Order visitOrder(final BSPTree node) {\n+        return Order.MINUS_SUB_PLUS;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void visitInternalNode(final BSPTree node) {\n+        final BoundaryAttribute attribute = (BoundaryAttribute) node.getAttribute();\n+        if (attribute.getPlusOutside() != null) {\n+            addContribution(attribute.getPlusOutside(), false);\n+        }\n+        if (attribute.getPlusInside() != null) {\n+            addContribution(attribute.getPlusInside(), true);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void visitLeafNode(final BSPTree node) {\n+    }\n+\n+    /** Add he contribution of a boundary facet.\n+     * @param sub boundary facet\n+     * @param reversed if true, the facet has the inside on its plus side\n+     */\n+    private void addContribution(final SubHyperplane sub, final boolean reversed) {\n+        final Line line      = (Line) sub.getHyperplane();\n+        final List<Interval> intervals = ((IntervalsSet) sub.getRemainingRegion()).asList();\n+        for (final Interval i : intervals) {\n+            final Point2D start = Double.isInfinite(i.getLower()) ?\n+                                  null : (Point2D) line.toSpace(new Point1D(i.getLower()));\n+            final Point2D end   = Double.isInfinite(i.getUpper()) ?\n+                                  null : (Point2D) line.toSpace(new Point1D(i.getUpper()));\n+            if (reversed) {\n+                sorted.insert(new Segment(end, start, line.getReverse()));\n+            } else {\n+                sorted.insert(new Segment(start, end, line));\n+            }\n+        }\n+    }\n+\n+    /** Get the sorted segments.\n+     * @return sorted segments\n+     */\n+    public AVLTree<Segment> getSorted() {\n+        return sorted;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/BSPTree.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.partitioning;\n+\n+import org.apache.commons.math.geometry.partitioning.Hyperplane.Side;\n+import org.apache.commons.math.util.FastMath;\n+\n+/** This class represent a Binary Space Partition tree.\n+\n+ * <p>BSP trees are an efficient way to represent space partitions and\n+ * to associate attributes with each cell. Each node in a BSP tree\n+ * represents a convex region which is partitioned in two convex\n+ * sub-regions at each side of a cut hyperplane. The root tree\n+ * contains the complete space.</p>\n+\n+ * <p>The main use of such partitions is to use a boolean attribute to\n+ * define an inside/outside property, hence representing arbitrary\n+ * polytopes (line segments in 1D, polygons in 2D and polyhedrons in\n+ * 3D) and to operate on them.</p>\n+\n+ * <p>Another example would be to represent Voronoi tesselations, the\n+ * attribute of each cell holding the defining point of the cell.</p>\n+\n+ * <p>The application-defined attributes are shared among copied\n+ * instances and propagated to split parts. These attributes are not\n+ * used by the BSP-tree algorithms themselves, so the application can\n+ * use them for any purpose. Since the tree visiting method holds\n+ * internal and leaf nodes differently, it is possible to use\n+ * different classes for internal nodes attributes and leaf nodes\n+ * attributes. This should be used with care, though, because if the\n+ * tree is modified in any way after attributes have been set, some\n+ * internal nodes may become leaf nodes and some leaf nodes may become\n+ * internal nodes.</p>\n+\n+ * <p>One of the main sources for the development of this package was\n+ * Bruce Naylor, John Amanatides and William Thibault paper <a\n+ * href=\"http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf\">Merging\n+ * BSP Trees Yields Polyhedral Set Operations</a> Proc. Siggraph '90,\n+ * Computer Graphics 24(4), August 1990, pp 115-124, published by the\n+ * Association for Computing Machinery (ACM).</p>\n+\n+ * @version $Revision$ $Date$\n+ */\n+public class BSPTree {\n+\n+    /** Cut sub-hyperplane. */\n+    private SubHyperplane cut;\n+\n+    /** Tree at the plus side of the cut hyperplane. */\n+    private BSPTree plus;\n+\n+    /** Tree at the minus side of the cut hyperplane. */\n+    private BSPTree minus;\n+\n+    /** Parent tree. */\n+    private BSPTree parent;\n+\n+    /** Application-defined attribute. */\n+    private Object attribute;\n+\n+    /** Build a tree having only one root cell representing the whole space.\n+     */\n+    public BSPTree() {\n+        cut       = null;\n+        plus      = null;\n+        minus     = null;\n+        parent    = null;\n+        attribute = null;\n+    }\n+\n+    /** Build a tree having only one root cell representing the whole space.\n+     * @param attribute attribute of the tree (may be null)\n+     */\n+    public BSPTree(final Object attribute) {\n+        cut    = null;\n+        plus   = null;\n+        minus  = null;\n+        parent = null;\n+        this.attribute = attribute;\n+    }\n+\n+    /** Build a BSPTree from its underlying elements.\n+     * <p>This method does <em>not</em> perform any verification on\n+     * consistency of its arguments, it should therefore be used only\n+     * when then caller knows what it is doing.</p>\n+     * <p>This method is mainly useful kto build trees\n+     * bottom-up. Building trees top-down is realized with the help of\n+     * method {@link #insertCut insertCut}.</p>\n+     * @param cut cut sub-hyperplane for the tree\n+     * @param plus plus side sub-tree\n+     * @param minus minus side sub-tree\n+     * @param attribute attribute associated with the node (may be null)\n+     * @see #insertCut\n+     */\n+    public BSPTree(final SubHyperplane cut, final BSPTree plus, final BSPTree minus,\n+                   final Object attribute) {\n+        this.cut       = cut;\n+        this.plus      = plus;\n+        this.minus     = minus;\n+        this.parent    = null;\n+        this.attribute = attribute;\n+        plus.parent    = this;\n+        minus.parent   = this;\n+    }\n+\n+    /** Insert a cut sub-hyperplane in a node.\n+     * <p>The sub-tree starting at this node will be completely\n+     * overwritten. The new cut sub-hyperplane will be built from the\n+     * intersection of the provided hyperplane with the cell. If the\n+     * hyperplane does intersect the cell, the cell will have two\n+     * children cells with {@code null} attributes on each side of\n+     * the inserted cut sub-hyperplane. If the hyperplane does not\n+     * intersect the cell then <em>no</em> cut hyperplane will be\n+     * inserted and the cell will be changed to a leaf cell. The\n+     * attribute of the node is never changed.</p>\n+     * <p>This method is mainly useful when called on leaf nodes\n+     * (i.e. nodes for which {@link #getCut getCut} returns\n+     * {@code null}), in this case it provides a way to build a\n+     * tree top-down (whereas the {@link #BSPTree(SubHyperplane,\n+     * BSPTree, BSPTree, Object) 4 arguments constructor} is devoted to\n+     * build trees bottom-up).</p>\n+     * @param hyperplane hyperplane to insert, it will be chopped in\n+     * order to fit in the cell defined by the parent nodes of the\n+     * instance\n+     * @return true if a cut sub-hyperplane has been inserted (i.e. if\n+     * the cell now has two leaf child nodes)\n+     * @see #BSPTree(SubHyperplane, BSPTree, BSPTree, Object)\n+     */\n+    public boolean insertCut(final Hyperplane hyperplane) {\n+\n+        if (cut != null) {\n+            plus.parent  = null;\n+            minus.parent = null;\n+        }\n+\n+        final SubHyperplane chopped = fitToCell(new SubHyperplane(hyperplane));\n+        if (chopped.getRemainingRegion().isEmpty()) {\n+            cut          = null;\n+            plus         = null;\n+            minus        = null;\n+            return false;\n+        }\n+\n+        cut          = chopped;\n+        plus         = new BSPTree();\n+        plus.parent  = this;\n+        minus        = new BSPTree();\n+        minus.parent = this;\n+        return true;\n+\n+    }\n+\n+    /** Copy the instance.\n+     * <p>The instance created is completely independant of the original\n+     * one. A deep copy is used, none of the underlying objects are\n+     * shared (except for the nodes attributes and immutable\n+     * objects).</p>\n+     * @return a new tree, copy of the instance\n+     */\n+    public BSPTree copySelf() {\n+\n+        if (cut == null) {\n+            return new BSPTree(attribute);\n+        }\n+\n+        return new BSPTree(cut.copySelf(), plus.copySelf(), minus.copySelf(),\n+                           attribute);\n+\n+    }\n+\n+    /** Get the cut sub-hyperplane.\n+     * @return cut sub-hyperplane, null if this is a leaf tree\n+     */\n+    public SubHyperplane getCut() {\n+        return cut;\n+    }\n+\n+    /** Get the tree on the plus side of the cut hyperplane.\n+     * @return tree on the plus side of the cut hyperplane, null if this\n+     * is a leaf tree\n+     */\n+    public BSPTree getPlus() {\n+        return plus;\n+    }\n+\n+    /** Get the tree on the minus side of the cut hyperplane.\n+     * @return tree on the minus side of the cut hyperplane, null if this\n+     * is a leaf tree\n+     */\n+    public BSPTree getMinus() {\n+        return minus;\n+    }\n+\n+    /** Get the parent node.\n+     * @return parent node, null if the node has no parents\n+     */\n+    public BSPTree getParent() {\n+        return parent;\n+    }\n+\n+    /** Associate an attribute with the instance.\n+     * @param attribute attribute to associate with the node\n+     * @see #getAttribute\n+     */\n+    public void setAttribute(final Object attribute) {\n+        this.attribute = attribute;\n+    }\n+\n+    /** Get the attribute associated with the instance.\n+     * @return attribute associated with the node or null if no\n+     * attribute has been explicitly set using the {@link #setAttribute\n+     * setAttribute} method\n+     * @see #setAttribute\n+     */\n+    public Object getAttribute() {\n+        return attribute;\n+    }\n+\n+    /** Visit the BSP tree nodes.\n+     * @param visitor object visiting the tree nodes\n+     */\n+    public void visit(final BSPTreeVisitor visitor) {\n+        if (cut == null) {\n+            visitor.visitLeafNode(this);\n+        } else {\n+            switch (visitor.visitOrder(this)) {\n+            case PLUS_MINUS_SUB:\n+                plus.visit(visitor);\n+                minus.visit(visitor);\n+                visitor.visitInternalNode(this);\n+                break;\n+            case PLUS_SUB_MINUS:\n+                plus.visit(visitor);\n+                visitor.visitInternalNode(this);\n+                minus.visit(visitor);\n+                break;\n+            case MINUS_PLUS_SUB:\n+                minus.visit(visitor);\n+                plus.visit(visitor);\n+                visitor.visitInternalNode(this);\n+                break;\n+            case MINUS_SUB_PLUS:\n+                minus.visit(visitor);\n+                visitor.visitInternalNode(this);\n+                plus.visit(visitor);\n+                break;\n+            case SUB_PLUS_MINUS:\n+                visitor.visitInternalNode(this);\n+                plus.visit(visitor);\n+                minus.visit(visitor);\n+                break;\n+            case SUB_MINUS_PLUS:\n+                visitor.visitInternalNode(this);\n+                minus.visit(visitor);\n+                plus.visit(visitor);\n+                break;\n+            default:\n+                throw new RuntimeException(\"internal error\");\n+            }\n+\n+        }\n+    }\n+\n+    /** Fit a sub-hyperplane inside the cell defined by the instance.\n+     * <p>Fitting is done by chopping off the parts of the\n+     * sub-hyperplane that lie outside of the cell using the\n+     * cut-hyperplanes of the parent nodes of the instance.</p>\n+     * @param sub sub-hyperplane to fit\n+     * @return a new sub-hyperplane, gueranteed to have no part outside\n+     * of the instance cell\n+     */\n+    private SubHyperplane fitToCell(final SubHyperplane sub) {\n+        SubHyperplane s = sub;\n+        for (BSPTree tree = this; tree.parent != null; tree = tree.parent) {\n+            if (tree == tree.parent.plus) {\n+                s = tree.parent.cut.getHyperplane().split(s).getPlus();\n+            } else {\n+                s = tree.parent.cut.getHyperplane().split(s).getMinus();\n+            }\n+        }\n+        return s;\n+    }\n+\n+    /** Get the cell to which a point belongs.\n+     * <p>If the returned cell is a leaf node the points belongs to the\n+     * interior of the node, if the cell is an internal node the points\n+     * belongs to the node cut sub-hyperplane.</p>\n+     * @param point point to check\n+     * @return the tree cell to which the point belongs (can be\n+     */\n+    public BSPTree getCell(final Point point) {\n+\n+        if (cut == null) {\n+            return this;\n+        }\n+\n+        // position of the point with respect to the cut hyperplane\n+        final double offset = cut.getHyperplane().getOffset(point);\n+\n+        if (FastMath.abs(offset) < 1.0e-10) {\n+            return this;\n+        } else if (offset <= 0) {\n+            // point is on the minus side of the cut hyperplane\n+            return minus.getCell(point);\n+        } else {\n+            // point is on the plus side of the cut hyperplane\n+            return plus.getCell(point);\n+        }\n+\n+    }\n+\n+    /** Perform condensation on a tree.\n+     * <p>The condensation operation is not recursive, it must be called\n+     * explicitely from leaves to root.</p>\n+     */\n+    private void condense() {\n+        if ((cut != null) && (plus.cut == null) && (minus.cut == null) &&\n+            (((plus.attribute == null) && (minus.attribute == null)) ||\n+             ((plus.attribute != null) && plus.attribute.equals(minus.attribute)))) {\n+            attribute = (plus.attribute == null) ? minus.attribute : plus.attribute;\n+            cut       = null;\n+            plus      = null;\n+            minus     = null;\n+        }\n+    }\n+\n+    /** Merge a BSP tree with the instance.\n+     * <p>All trees are modified (parts of them are reused in the new\n+     * tree), it is the responsibility of the caller to ensure a copy\n+     * has been done before if any of the former tree should be\n+     * preserved, <em>no</em> such copy is done here!</p>\n+     * <p>The algorithm used here is directly derived from the one\n+     * described in the Naylor, Amanatides and Thibault paper (section\n+     * III, Binary Partitioning of a BSP Tree).</p>\n+     * @param tree other tree to merge with the instance (will be\n+     * <em>unusable</em> after the operation, as well as the\n+     * instance itself)\n+     * @param leafMerger object implementing the final merging phase\n+     * (this is where the semantic of the operation occurs, generally\n+     * depending on the attribute of the leaf node)\n+     * @return a new tree, result of <code>instance &lt;op&gt;\n+     * tree</code>, this value can be ignored if parentTree is not null\n+     * since all connections have already been established\n+     */\n+    public BSPTree merge(final BSPTree tree, final LeafMerger leafMerger) {\n+        return merge(tree, leafMerger, null, false);\n+    }\n+\n+    /** Merge a BSP tree with the instance.\n+     * @param tree other tree to merge with the instance (will be\n+     * <em>unusable</em> after the operation, as well as the\n+     * instance itself)\n+     * @param leafMerger object implementing the final merging phase\n+     * (this is where the semantic of the operation occurs, generally\n+     * depending on the attribute of the leaf node)\n+     * @param parentTree parent tree to connect to (may be null)\n+     * @param isPlusChild if true and if parentTree is not null, the\n+     * resulting tree should be the plus child of its parent, ignored if\n+     * parentTree is null\n+     * @return a new tree, result of <code>instance &lt;op&gt;\n+     * tree</code>, this value can be ignored if parentTree is not null\n+     * since all connections have already been established\n+     */\n+    private BSPTree merge(final BSPTree tree, final LeafMerger leafMerger,\n+                          final BSPTree parentTree, final boolean isPlusChild) {\n+        if (cut == null) {\n+            // cell/tree operation\n+            return leafMerger.merge(this, tree, parentTree, isPlusChild, true);\n+        } else if (tree.cut == null) {\n+            // tree/cell operation\n+            return leafMerger.merge(tree, this, parentTree, isPlusChild, false);\n+        } else {\n+            // tree/tree operation\n+            final BSPTree merged = tree.split(cut);\n+            if (parentTree != null) {\n+                merged.parent = parentTree;\n+                if (isPlusChild) {\n+                    parentTree.plus = merged;\n+                } else {\n+                    parentTree.minus = merged;\n+                }\n+            }\n+\n+            // merging phase\n+            plus.merge(merged.plus, leafMerger, merged, true);\n+            minus.merge(merged.minus, leafMerger, merged, false);\n+            merged.condense();\n+            if (merged.cut != null) {\n+                merged.cut =\n+                    merged.fitToCell(new SubHyperplane(merged.cut.getHyperplane()));\n+            }\n+\n+            return merged;\n+\n+        }\n+    }\n+\n+    /** This interface gather the merging operations between a BSP tree\n+     * leaf and another BSP tree.\n+     * <p>As explained in Bruce Naylor, John Amanatides and William\n+     * Thibault paper <a\n+     * href=\"http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf\">Merging\n+     * BSP Trees Yields Polyhedral Set Operations</a>,\n+     * the operations on {@link BSPTree BSP trees} can be expressed as a\n+     * generic recursive merging operation where only the final part,\n+     * when one of the operand is a leaf, is specific to the real\n+     * operation semantics. For example, a tree representing a region\n+     * using a boolean attribute to identify inside cells and outside\n+     * cells would use four different objects to implement the final\n+     * merging phase of the four set operations union, intersection,\n+     * difference and symmetric difference (exclusive or).</p>\n+     * @version $Revision$ $Date$\n+     */\n+    public static interface LeafMerger {\n+\n+        /** Merge a leaf node and a tree node.\n+         * <p>This method is called at the end of a recursive merging\n+         * resulting from a {@code tree1.merge(tree2, leafMerger)}\n+         * call, when one of the sub-trees involved is a leaf (i.e. when\n+         * its cut-hyperplane is null). This is the only place where the\n+         * precise semantics of the operation are required. For all upper\n+         * level nodes in the tree, the merging operation is only a\n+         * generic partitioning algorithm.</p>\n+         * <p>Since the final operation may be non-commutative, it is\n+         * important to know if the leaf node comes from the instance tree\n+         * ({@code tree1}) or the argument tree\n+         * ({@code tree2}). The third argument of the method is\n+         * devoted to this. It can be ignored for commutative\n+         * operations.</p>\n+         * <p>The {@link BSPTree#insertInTree BSPTree.insertInTree} method\n+         * may be useful to implement this method.</p>\n+         * @param leaf leaf node (its cut hyperplane is guaranteed to be\n+         * null)\n+         * @param tree tree node (its cut hyperplane may be null or not)\n+         * @param parentTree parent tree to connect to (may be null)\n+         * @param isPlusChild if true and if parentTree is not null, the\n+         * resulting tree should be the plus child of its parent, ignored if\n+         * parentTree is null\n+         * @param leafFromInstance if true, the leaf node comes from the\n+         * instance tree ({@code tree1}) and the tree node comes from\n+         * the argument tree ({@code tree2})\n+         * @return the BSP tree resulting from the merging (may be one of\n+         * the arguments)\n+         */\n+        BSPTree merge(BSPTree leaf, BSPTree tree,\n+                      BSPTree parentTree, boolean isPlusChild,\n+                      boolean leafFromInstance);\n+\n+    }\n+\n+    /** Split a BSP tree by an external sub-hyperplane.\n+     * <p>Split a tree in two halves, on each side of the\n+     * sub-hyperplane. The instance is not modified.</p>\n+     * <p>The tree returned is not upward-consistent: despite all of its\n+     * sub-trees cut sub-hyperplanes (including its own cut\n+     * sub-hyperplane) are bounded to the current cell, it is <em>not</em>\n+     * attached to any parent tree yet. This tree is intended to be\n+     * later inserted into an higher level tree.</p>\n+     * <p>The algorithm used here is the one given in Naylor, Amanatides\n+     * and Thibault paper (section III, Binary Partitioning of a BSP\n+     * Tree).</p>\n+     * @param sub partitioning sub-hyperplane, must be already clipped\n+     * to the convex region represented by the instance, will be used as\n+     * the cut sub-hyperplane of the returned tree\n+     * @return a tree having the specified sub-hyperplane as its cut\n+     * sub-hyperplane, the two parts of the split instance as its two\n+     * sub-trees and a null parent\n+     */\n+    public BSPTree split(final SubHyperplane sub) {\n+\n+        if (cut == null) {\n+            return new BSPTree(sub, copySelf(), new BSPTree(attribute), null);\n+        }\n+\n+        final Hyperplane cHyperplane = cut.getHyperplane();\n+        final Hyperplane sHyperplane = sub.getHyperplane();\n+        switch (cHyperplane.side(sub)) {\n+        case PLUS :\n+        { // the partitioning sub-hyperplane is entirely in the plus sub-tree\n+            final BSPTree split = plus.split(sub);\n+            if (sHyperplane.side(cut) == Side.PLUS) {\n+                split.plus = new BSPTree(cut.copySelf(),\n+                                         split.plus, minus.copySelf(), attribute);\n+                split.plus.condense();\n+                split.plus.parent = split;\n+            } else {\n+                split.minus = new BSPTree(cut.copySelf(),\n+                                          split.minus, minus.copySelf(), attribute);\n+                split.minus.condense();\n+                split.minus.parent = split;\n+            }\n+            return split;\n+        }\n+        case MINUS :\n+        { // the partitioning sub-hyperplane is entirely in the minus sub-tree\n+            final BSPTree split = minus.split(sub);\n+            if (sHyperplane.side(cut) == Side.PLUS) {\n+                split.plus = new BSPTree(cut.copySelf(),\n+                                         plus.copySelf(), split.plus, attribute);\n+                split.plus.condense();\n+                split.plus.parent = split;\n+            } else {\n+                split.minus = new BSPTree(cut.copySelf(),\n+                                          plus.copySelf(), split.minus, attribute);\n+                split.minus.condense();\n+                split.minus.parent = split;\n+            }\n+            return split;\n+        }\n+        case BOTH :\n+        {\n+            final Hyperplane.SplitSubHyperplane cutParts = sHyperplane.split(cut);\n+            final Hyperplane.SplitSubHyperplane subParts = cHyperplane.split(sub);\n+            final BSPTree split = new BSPTree(sub,\n+                                              plus.split(subParts.getPlus()),\n+                                              minus.split(subParts.getMinus()),\n+                                              null);\n+            split.plus.cut          = cutParts.getPlus();\n+            split.minus.cut         = cutParts.getMinus();\n+            final BSPTree tmp       = split.plus.minus;\n+            split.plus.minus        = split.minus.plus;\n+            split.plus.minus.parent = split.plus;\n+            split.minus.plus        = tmp;\n+            split.minus.plus.parent = split.minus;\n+            split.plus.condense();\n+            split.minus.condense();\n+            return split;\n+        }\n+        default :\n+            return cHyperplane.sameOrientationAs(sHyperplane) ?\n+                    new BSPTree(sub, plus.copySelf(), minus.copySelf(), attribute) :\n+                        new BSPTree(sub, minus.copySelf(), plus.copySelf(), attribute);\n+        }\n+\n+    }\n+\n+    /** Insert the instance into another tree.\n+     * <p>The instance itself is modified so its former parent should\n+     * not be used anymore.</p>\n+     * @param parentTree parent tree to connect to (may be null)\n+     * @param isPlusChild if true and if parentTree is not null, the\n+     * resulting tree should be the plus child of its parent, ignored if\n+     * parentTree is null\n+     * @see LeafMerger\n+     */\n+    public void insertInTree(final BSPTree parentTree, final boolean isPlusChild) {\n+\n+        // set up parent/child links\n+        parent = parentTree;\n+        if (parentTree != null) {\n+            if (isPlusChild) {\n+                parentTree.plus = this;\n+            } else {\n+                parentTree.minus = this;\n+            }\n+        }\n+\n+        // make sure the inserted tree lies in the cell defined by its parent nodes\n+        if (cut != null) {\n+\n+            // explore the parent nodes from here towards tree root\n+            for (BSPTree tree = this; tree.parent != null; tree = tree.parent) {\n+\n+                // this is an hyperplane of some parent node\n+                final Hyperplane hyperplane = tree.parent.cut.getHyperplane();\n+\n+                // chop off the parts of the inserted tree that extend\n+                // on the wrong side of this parent hyperplane\n+                if (tree == tree.parent.plus) {\n+                    cut = hyperplane.split(cut).getPlus();\n+                    plus.chopOffMinus(hyperplane);\n+                    minus.chopOffMinus(hyperplane);\n+                } else {\n+                    cut = hyperplane.split(cut).getMinus();\n+                    plus.chopOffPlus(hyperplane);\n+                    minus.chopOffPlus(hyperplane);\n+                }\n+\n+            }\n+\n+            // since we may have drop some parts of the inserted tree,\n+            // perform a condensation pass to keep the tree structure simple\n+            condense();\n+\n+        }\n+\n+    }\n+\n+    /** Chop off parts of the tree.\n+     * <p>The instance is modified in place, all the parts that are on\n+     * the minus side of the chopping hyperplane are disgarded, only the\n+     * parts on the plus side remain.</p>\n+     * @param hyperplane chopping hyperplane\n+     */\n+    private void chopOffMinus(final Hyperplane hyperplane) {\n+        if (cut != null) {\n+            cut = hyperplane.split(cut).getPlus();\n+            plus.chopOffMinus(hyperplane);\n+            minus.chopOffMinus(hyperplane);\n+        }\n+    }\n+\n+    /** Chop off parts of the tree.\n+     * <p>The instance is modified in place, all the parts that are on\n+     * the plus side of the chopping hyperplane are disgarded, only the\n+     * parts on the minus side remain.</p>\n+     * @param hyperplane chopping hyperplane\n+     */\n+    private void chopOffPlus(final Hyperplane hyperplane) {\n+        if (cut != null) {\n+            cut = hyperplane.split(cut).getMinus();\n+            plus.chopOffPlus(hyperplane);\n+            minus.chopOffPlus(hyperplane);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/BSPTreeVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.partitioning;\n+\n+/** This interface is used to visit {@link BSPTree BSP tree} nodes.\n+\n+ * <p>Navigation through {@link BSPTree BSP trees} can be done using\n+ * two different point of views:</p>\n+ * <ul>\n+ *   <li>\n+ *     the first one is in a node-oriented way using the {@link\n+ *     BSPTree#getPlus}, {@link BSPTree#getMinus} and {@link\n+ *     BSPTree#getParent} methods. Terminal nodes without associated\n+ *     {@link SubHyperplane sub-hyperplanes} can be visited this way,\n+ *     there is no constraint in the visit order, and it is possible\n+ *     to visit either all nodes or only a subset of the nodes\n+ *   </li>\n+ *   <li>\n+ *     the second one is in a sub-hyperplane-oriented way using\n+ *     classes implementing this interface which obeys the visitor\n+ *     design pattern. The visit order is provided by the visitor as\n+ *     each node is first encountered. Each node is visited exactly\n+ *     once.\n+ *   </li>\n+ * </ul>\n+\n+ * @see BSPTree\n+ * @see SubHyperplane\n+\n+ * @version $Revision$ $Date$\n+ */\n+public interface BSPTreeVisitor {\n+\n+    /** Enumerate for visit order with respect to plus sub-tree, minus sub-tree and cut sub-hyperplane. */\n+    enum Order {\n+        /** Indicator for visit order plus sub-tree, then minus sub-tree,\n+         * and last cut sub-hyperplane.\n+         */\n+        PLUS_MINUS_SUB,\n+\n+        /** Indicator for visit order plus sub-tree, then cut sub-hyperplane,\n+         * and last minus sub-tree.\n+         */\n+        PLUS_SUB_MINUS,\n+\n+        /** Indicator for visit order minus sub-tree, then plus sub-tree,\n+         * and last cut sub-hyperplane.\n+         */\n+        MINUS_PLUS_SUB,\n+\n+        /** Indicator for visit order minus sub-tree, then cut sub-hyperplane,\n+         * and last plus sub-tree.\n+         */\n+        MINUS_SUB_PLUS,\n+\n+        /** Indicator for visit order cut sub-hyperplane, then plus sub-tree,\n+         * and last minus sub-tree.\n+         */\n+        SUB_PLUS_MINUS,\n+\n+        /** Indicator for visit order cut sub-hyperplane, then minus sub-tree,\n+         * and last plus sub-tree.\n+         */\n+        SUB_MINUS_PLUS;\n+    }\n+\n+    /** Determine the visit order for this node.\n+     * <p>Before attempting to visit an internal node, this method is\n+     * called to determine the desired ordering of the visit. It is\n+     * guaranteed that this method will be called before {@link\n+     * #visitInternalNode visitInternalNode} for a given node, it will be\n+     * called exactly once for each internal node.</p>\n+     * @param node BSP node guaranteed to have a non null cut sub-hyperplane\n+     * @return desired visit order, must be one of\n+     * {@link Order#PLUS_MINUS_SUB}, {@link Order#PLUS_SUB_MINUS},\n+     * {@link Order#MINUS_PLUS_SUB}, {@link Order#MINUS_SUB_PLUS},\n+     * {@link Order#SUB_PLUS_MINUS}, {@link Order#SUB_MINUS_PLUS}\n+     */\n+    Order visitOrder(BSPTree node);\n+\n+    /** Visit a BSP tree node node having a non-null sub-hyperplane.\n+     * <p>It is guaranteed that this method will be called after {@link\n+     * #visitOrder visitOrder} has been called for a given node,\n+     * it wil be called exactly once for each internal node.</p>\n+     * @param node BSP node guaranteed to have a non null cut sub-hyperplane\n+     * @see #visitLeafNode\n+     */\n+    void visitInternalNode(BSPTree node);\n+\n+    /** Visit a leaf BSP tree node node having a null sub-hyperplane.\n+     * @param node leaf BSP node having a null sub-hyperplane\n+     * @see #visitInternalNode\n+     */\n+    void visitLeafNode(BSPTree node);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/Characterization.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.partitioning;\n+\n+/** Characterization of a sub-hyperplane.\n+ * @version $Revision$ $Date$\n+ */\n+class Characterization {\n+\n+    /** Parts of the sub-hyperplane that have inside cells on the tested side. */\n+    private SubHyperplane in;\n+\n+    /** Parts of the sub-hyperplane that have outside cells on the tested side. */\n+    private SubHyperplane out;\n+\n+    /** Create an empty characterization of a sub-hyperplane.\n+     */\n+    public Characterization() {\n+        in  = null;\n+        out = null;\n+    }\n+\n+    /** Check if the sub-hyperplane that have inside cells on the tested side.\n+     * @return true if the sub-hyperplane that have inside cells on the tested side\n+     */\n+    public boolean hasIn() {\n+        return (in != null) && (!in.getRemainingRegion().isEmpty());\n+    }\n+\n+    /** Get the parts of the sub-hyperplane that have inside cells on the tested side.\n+     * @return parts of the sub-hyperplane that have inside cells on the tested side\n+     */\n+    public SubHyperplane getIn() {\n+        return in;\n+    }\n+\n+    /** Check if the sub-hyperplane that have outside cells on the tested side.\n+     * @return true if the sub-hyperplane that have outside cells on the tested side\n+     */\n+    public boolean hasOut() {\n+        return (out != null) && (!out.getRemainingRegion().isEmpty());\n+    }\n+\n+    /** Get the parts of the sub-hyperplane that have outside cells on the tested side.\n+     * @return parts of the sub-hyperplane that have outside cells on the tested side\n+     */\n+    public SubHyperplane getOut() {\n+        return out;\n+    }\n+\n+    /** Add a part of the sub-hyperplane known to have inside or outside cell on the tested side.\n+     * @param sub part of the sub-hyperplane to add\n+     * @param inside if true, the part added as an inside cell on the tested side, otherwise\n+     * it has an outside cell on the tested side\n+     */\n+    public void add(final SubHyperplane sub, final boolean inside) {\n+        if (inside) {\n+            if (in == null) {\n+                in = sub;\n+            } else {\n+                in = new SubHyperplane(in.getHyperplane(),\n+                                       Region.union(in.getRemainingRegion(),\n+                                                    sub.getRemainingRegion()));\n+            }\n+        } else {\n+            if (out == null) {\n+                out = sub;\n+            } else {\n+                out = new SubHyperplane(out.getHyperplane(),\n+                                        Region.union(out.getRemainingRegion(),\n+                                                     sub.getRemainingRegion()));\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/Hyperplane.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.partitioning;\n+\n+/** This interface represents an hyperplane of a space.\n+\n+ * <p>The most prominent place where hyperplane appears in space\n+ * partitioning is as cutters. Each partitioning node in a {@link\n+ * BSPTree BSP tree} has a cut {@link SubHyperplane sub-hyperplane}\n+ * which is either an hyperplane or a part of an hyperplane. In an\n+ * n-dimensions euclidean space, an hyperplane is an (n-1)-dimensions\n+ * hyperplane (for example a traditional plane in the 3D euclidean\n+ * space). They can be more exotic objects in specific fields, for\n+ * example a circle on the surface of the unit sphere.</p>\n+\n+ * @version $Revision$ $Date$\n+ */\n+public interface Hyperplane extends SubSpace {\n+\n+    /** Enumerate for specifying sides of the hyperplane. */\n+    enum Side {\n+\n+        /** Code for the plus side of the hyperplane. */\n+        PLUS,\n+\n+        /** Code for the minus side of the hyperplane. */\n+        MINUS,\n+\n+        /** Code for elements crossing the hyperplane from plus to minus side. */\n+        BOTH,\n+\n+        /** Code for the hyperplane itself. */\n+        HYPER;\n+\n+    }\n+\n+    /** Copy the instance.\n+     * <p>The instance created is completely independant of the original\n+     * one. A deep copy is used, none of the underlying objects are\n+     * shared (except for immutable objects).</p>\n+     * @return a new hyperplane, copy of the instance\n+     */\n+    Hyperplane copySelf();\n+\n+    /** Get the offset (oriented distance) of a point.\n+     * <p>The offset is 0 if the point is on the underlying hyperplane,\n+     * it is positive if the point is on one particular side of the\n+     * hyperplane, and it is negative if the point is on the other side,\n+     * according to the hyperplane natural orientation.</p>\n+     * @param point point to check\n+     * @return offset of the point\n+     */\n+    double getOffset(Point point);\n+\n+    /** Check if the instance has the same orientation as another hyperplane.\n+     * <p>This method is expected to be called on parallel hyperplanes\n+     * (i.e. when the {@link #side side} method would return {@link\n+     * Side#HYPER} for some sub-hyperplane having the specified hyperplane\n+     * as its underlying hyperplane). The method should <em>not</em>\n+     * re-check for parallelism, only for orientation, typically by\n+     * testing something like the sign of the dot-products of\n+     * normals.</p>\n+     * @param other other hyperplane to check against the instance\n+     * @return true if the instance and the other hyperplane have\n+     * the same orientation\n+     */\n+    boolean sameOrientationAs(Hyperplane other);\n+\n+    /** Build the sub-space shared by the instance and another hyperplane.\n+     * @param other other hyperplane\n+     * @return a sub-space at the intersection of the instance and the\n+     * other sub-space (it has a dimension one unit less than the\n+     * instance)\n+     */\n+    SubSpace intersection(Hyperplane other);\n+\n+    /** Build a region covering the whole hyperplane.\n+     * <p>The region build is restricted to the sub-space defined by the\n+     * hyperplane. This means that the regions points are consistent\n+     * with the argument of the {@link SubSpace#toSpace toSpace} method\n+     * and with the return value of the {@link SubSpace#toSubSpace\n+     * toSubSpace} method.<p>\n+     * @return a region covering the whole hyperplane\n+     */\n+    Region wholeHyperplane();\n+\n+    /** Build a region covering the whole space.\n+     * @return a region containing the instance\n+     */\n+    Region wholeSpace();\n+\n+    /** Compute the relative position of a sub-hyperplane with respect\n+     * to the instance.\n+     * @param sub sub-hyperplane to check\n+     * @return one of {@link Side#PLUS}, {@link Side#MINUS}, {@link Side#BOTH},\n+     * {@link Side#HYPER}\n+     */\n+    Side side(SubHyperplane sub);\n+\n+    /** Split a sub-hyperplane in two parts by the instance.\n+     * @param sub sub-hyperplane to split\n+     * @return an object containing both the part of the sub-hyperplane\n+     * on the plus side of the instance and the part of the\n+     * sub-hyperplane on the minus side of the instance\n+     */\n+    SplitSubHyperplane split(SubHyperplane sub);\n+\n+    /** Class holding the results of the {@link Hyperplane#split Hyperplane.split}\n+     * method. */\n+    class SplitSubHyperplane {\n+\n+        /** Part of the sub-hyperplane on the plus side of the splitting hyperplane. */\n+        private final SubHyperplane plus;\n+\n+        /** Part of the sub-hyperplane on the minus side of the splitting hyperplane. */\n+        private final SubHyperplane minus;\n+\n+        /** Build a SplitSubHyperplane from its parts.\n+         * @param plus part of the sub-hyperplane on the plus side of the\n+         * splitting hyperplane\n+         * @param minus part of the sub-hyperplane on the minus side of the\n+         * splitting hyperplane\n+         */\n+        public SplitSubHyperplane(final SubHyperplane plus, final SubHyperplane minus) {\n+            this.plus  = plus;\n+            this.minus = minus;\n+        }\n+\n+        /** Get the part of the sub-hyperplane on the plus side of the splitting hyperplane.\n+         * @return part of the sub-hyperplane on the plus side of the splitting hyperplane\n+         */\n+        public SubHyperplane getPlus() {\n+            return plus;\n+        }\n+\n+        /** Get the part of the sub-hyperplane on the minus side of the splitting hyperplane.\n+         * @return part of the sub-hyperplane on the minus side of the splitting hyperplane\n+         */\n+        public SubHyperplane getMinus() {\n+            return minus;\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/Point.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.partitioning;\n+\n+/** This interface represents a generic point to be used in a space partition.\n+ * <p>Points are completely virtual entities with no specification at\n+ * all, so this class is essentially a marker interface with no\n+ * methods. This allows to perform partition in traditional euclidean\n+ * n-dimensions spaces, but also in more exotic universes like for\n+ * example the surface of the unit sphere.</p>\n+ * @version $Revision$ $Date$\n+ */\n+public interface Point {\n+    // nothing here, this is only a marker interface\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/Region.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.partitioning;\n+\n+import java.util.Collection;\n+import java.util.TreeSet;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.ArrayList;\n+\n+/** This class represent a region of a space as a partition.\n+\n+ * <p>Region are subsets of a space, they can be infinite (whole\n+ * space, half space, infinite stripe ...) or finite (polygons in 2D,\n+ * polyhedrons in 3D ...). Their main characteristic is to separate\n+ * points that are considered to be <em>inside</em> the region from\n+ * points considered to be <em>outside</em> of it. In between, there\n+ * may be points on the <em>boundary</em> of the region.</p>\n+\n+ * <p>This implementation is limited to regions for which the boundary\n+ * is composed of several {@link SubHyperplane sub-hyperplanes},\n+ * including regions with no boundary at all: the whole space and the\n+ * empty region. They are not necessarily finite and not necessarily\n+ * path-connected. They can contain holes.</p>\n+\n+ * <p>Regions can be combined using the traditional sets operations :\n+ * union, intersection, difference and symetric difference (exclusive\n+ * or) for the binary operations, complement for the unary\n+ * operation.</p>\n+\n+ * @version $Revision$ $Date$\n+ */\n+public abstract class Region {\n+\n+    /** Enumerate for the location of a point with respect to the region. */\n+    public static enum Location {\n+        /** Code for points inside the partition. */\n+        INSIDE,\n+\n+        /** Code for points outside of the partition. */\n+        OUTSIDE,\n+\n+        /** Code for points on the partition boundary. */\n+        BOUNDARY;\n+    }\n+\n+    /** Inside/Outside BSP tree. */\n+    private BSPTree tree;\n+\n+    /** Size of the instance. */\n+    private double size;\n+\n+    /** Barycenter. */\n+    private Point barycenter;\n+\n+    /** Build a region representing the whole space.\n+     */\n+    protected Region() {\n+        tree = new BSPTree(Boolean.TRUE);\n+    }\n+\n+    /** Build a region from an inside/outside BSP tree.\n+     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n+     * {@code Boolean} attribute representing the inside status of\n+     * the corresponding cell (true for inside cells, false for outside\n+     * cells). In order to avoid building too many small objects, it is\n+     * recommended to use the predefined constants\n+     * {@code Boolean.TRUE} and {@code Boolean.FALSE}. The\n+     * tree also <em>must</em> have either null internal nodes or\n+     * internal nodes representing the boundary as specified in the\n+     * {@link #getTree getTree} method).</p>\n+     * @param tree inside/outside BSP tree representing the region\n+     */\n+    protected Region(final BSPTree tree) {\n+        this.tree = tree;\n+    }\n+\n+    /** Build a Region from a Boundary REPresentation (B-rep).\n+     * <p>The boundary is provided as a collection of {@link\n+     * SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the\n+     * interior part of the region on its minus side and the exterior on\n+     * its plus side.</p>\n+     * <p>The boundary elements can be in any order, and can form\n+     * several non-connected sets (like for example polygons with holes\n+     * or a set of disjoints polyhedrons considered as a whole). In\n+     * fact, the elements do not even need to be connected together\n+     * (their topological connections are not used here). However, if the\n+     * boundary does not really separate an inside open from an outside\n+     * open (open having here its topological meaning), then subsequent\n+     * calls to the {@link #checkPoint(Point) checkPoint} method will not be\n+     * meaningful anymore.</p>\n+     * <p>If the boundary is empty, the region will represent the whole\n+     * space.</p>\n+     * @param boundary collection of boundary elements, as a\n+     * collection of {@link SubHyperplane SubHyperplane} objects\n+     */\n+    protected Region(final Collection<SubHyperplane> boundary) {\n+\n+        if (boundary.size() == 0) {\n+\n+            // the tree represents the whole space\n+            tree = new BSPTree(Boolean.TRUE);\n+\n+        } else {\n+\n+            // sort the boundary elements in decreasing size order\n+            // (we don't want equal size elements to be removed, so\n+            // we use a trick to fool the TreeSet)\n+            final TreeSet<SubHyperplane> ordered = new TreeSet<SubHyperplane>(new Comparator<SubHyperplane>() {\n+                public int compare(final SubHyperplane o1, final SubHyperplane o2) {\n+                    final double size1 = o1.getRemainingRegion().getSize();\n+                    final double size2 = o2.getRemainingRegion().getSize();\n+                    return (size2 < size1) ? -1 : ((o1 == o2) ? 0 : +1);\n+                }\n+            });\n+            ordered.addAll(boundary);\n+\n+            // build the tree top-down\n+            tree = new BSPTree();\n+            insertCuts(tree, ordered);\n+\n+            // set up the inside/outside flags\n+            tree.visit(new BSPTreeVisitor() {\n+\n+                /** {@inheritDoc} */\n+                public Order visitOrder(final BSPTree node) {\n+                    return Order.PLUS_SUB_MINUS;\n+                }\n+\n+                /** {@inheritDoc} */\n+                public void visitInternalNode(final BSPTree node) {\n+                }\n+\n+                /** {@inheritDoc} */\n+                public void visitLeafNode(final BSPTree node) {\n+                    node.setAttribute((node == node.getParent().getPlus()) ?\n+                                                                            Boolean.FALSE : Boolean.TRUE);\n+                }\n+            });\n+\n+        }\n+\n+    }\n+\n+    /** Build a region using the instance as a prototype.\n+     * <p>This method allow to create new instances without knowing\n+     * exactly the type of the region. It is an application of the\n+     * prototype design pattern.</p>\n+     * <p>The leaf nodes of the BSP tree <em>must</em> have a\n+     * {@code Boolean} attribute representing the inside status of\n+     * the corresponding cell (true for inside cells, false for outside\n+     * cells). In order to avoid building too many small objects, it is\n+     * recommended to use the predefined constants\n+     * {@code Boolean.TRUE} and {@code Boolean.FALSE}. The\n+     * tree also <em>must</em> have either null internal nodes or\n+     * internal nodes representing the boundary as specified in the\n+     * {@link #getTree getTree} method).</p>\n+     * @param newTree inside/outside BSP tree representing the new region\n+     * @return the built region\n+     */\n+    public abstract Region buildNew(BSPTree newTree);\n+\n+    /** Recursively build a tree by inserting cut sub-hyperplanes.\n+     * @param node current tree node (it is a leaf node at the beginning\n+     * of the call)\n+     * @param boundary collection of edges belonging to the cell defined\n+     * by the node\n+     */\n+    private void insertCuts(final BSPTree node, final Collection<SubHyperplane> boundary) {\n+\n+        final Iterator<SubHyperplane> iterator = boundary.iterator();\n+\n+        // build the current level\n+        Hyperplane inserted = null;\n+        while ((inserted == null) && iterator.hasNext()) {\n+            inserted = iterator.next().getHyperplane();\n+            if (!node.insertCut(inserted.copySelf())) {\n+                inserted = null;\n+            }\n+        }\n+\n+        if (!iterator.hasNext()) {\n+            return;\n+        }\n+\n+        // distribute the remaining edges in the two sub-trees\n+        final ArrayList<SubHyperplane> plusList  = new ArrayList<SubHyperplane>();\n+        final ArrayList<SubHyperplane> minusList = new ArrayList<SubHyperplane>();\n+        while (iterator.hasNext()) {\n+            final SubHyperplane other = iterator.next();\n+            switch (inserted.side(other)) {\n+            case PLUS:\n+                plusList.add(other);\n+                break;\n+            case MINUS:\n+                minusList.add(other);\n+                break;\n+            case BOTH:\n+                final Hyperplane.SplitSubHyperplane split = inserted.split(other);\n+                plusList.add(split.getPlus());\n+                minusList.add(split.getMinus());\n+                break;\n+            default:\n+                // ignore the sub-hyperplanes belonging to the cut hyperplane\n+            }\n+        }\n+\n+        // recurse through lower levels\n+        insertCuts(node.getPlus(),  plusList);\n+        insertCuts(node.getMinus(), minusList);\n+\n+    }\n+\n+    /** Build a convex region from a collection of bounding hyperplanes.\n+     * @param hyperplanes collection of bounding hyperplanes\n+     * @return a new convex region, or null if the collection is empty\n+     */\n+    public static Region buildConvex(final Collection<Hyperplane> hyperplanes) {\n+        if (hyperplanes.isEmpty()) {\n+            return null;\n+        }\n+\n+        // use the first hyperplane to build the right class\n+        final Region region = hyperplanes.iterator().next().wholeSpace();\n+\n+        // chop off parts of the space\n+        BSPTree node = region.tree;\n+        node.setAttribute(Boolean.TRUE);\n+        for (final Hyperplane hyperplane : hyperplanes) {\n+            if (node.insertCut(hyperplane)) {\n+                node.setAttribute(null);\n+                node.getPlus().setAttribute(Boolean.FALSE);\n+                node = node.getMinus();\n+                node.setAttribute(Boolean.TRUE);\n+            }\n+        }\n+\n+        return region;\n+\n+    }\n+\n+    /** Copy the instance.\n+     * <p>The instance created is completely independant of the original\n+     * one. A deep copy is used, none of the underlying objects are\n+     * shared (except for the underlying tree {@code Boolean}\n+     * attributes and immutable objects).</p>\n+     * @return a new region, copy of the instance\n+     */\n+    public Region copySelf() {\n+        return buildNew(tree.copySelf());\n+    }\n+\n+    /** Check if the instance is empty.\n+     * @return true if the instance is empty\n+     */\n+    public boolean isEmpty() {\n+        return isEmpty(tree);\n+    }\n+\n+    /** Check if the sub-tree starting at a given node is empty.\n+     * @param node root node of the sub-tree (<em>must</em> have {@link\n+     * Region Region} tree semantics, i.e. the leaf nodes must have\n+     * {@code Boolean} attributes representing an inside/outside\n+     * property)\n+     * @return true if the sub-tree starting at the given node is empty\n+     */\n+    public static boolean isEmpty(final BSPTree node) {\n+\n+        // we use a recursive function rather than the BSPTreeVisitor\n+        // interface because we can stop visiting the tree as soon as we\n+        // have found an inside cell\n+\n+        if (node.getCut() == null) {\n+            // if we find an inside node, the region is not empty\n+            return !isInside(node);\n+        }\n+\n+        // check both sides of the sub-tree\n+        return isEmpty(node.getMinus()) && isEmpty(node.getPlus());\n+\n+    }\n+\n+    /** Check a leaf node inside attribute.\n+     * @param node leaf node to check\n+     * @return true if the leaf node is an inside node\n+     */\n+    private static boolean isInside(final BSPTree node) {\n+        return (Boolean) node.getAttribute();\n+    }\n+\n+    /** Check if the instance entirely contains another region.\n+     * @param region region to check against the instance\n+     * @return true if the instance contains the specified tree\n+     */\n+    public boolean contains(final Region region) {\n+        return difference(region, this).isEmpty();\n+    }\n+\n+    /** Check a point with respect to the region.\n+     * @param point point to check\n+     * @return a code representing the point status: either {@link\n+     * Location#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}\n+     */\n+    public Location checkPoint(final Point point) {\n+        return checkPoint(tree, point);\n+    }\n+\n+    /** Check a point with respect to the region starting at a given node.\n+     * @param node root node of the region\n+     * @param point point to check\n+     * @return a code representing the point status: either {@link\n+     * Location#INSIDE}, {@link Location#OUTSIDE} or {@link Location#BOUNDARY}\n+     */\n+    protected Location checkPoint(final BSPTree node, final Point point) {\n+        final BSPTree cell = node.getCell(point);\n+        if (cell.getCut() == null) {\n+            // the point is in the interior of a cell, just check the attribute\n+            return isInside(cell) ? Location.INSIDE : Location.OUTSIDE;\n+        }\n+\n+        // the point is on a cut-sub-hyperplane, is it on a boundary ?\n+        final Location minusCode = checkPoint(cell.getMinus(), point);\n+        final Location plusCode  = checkPoint(cell.getPlus(),  point);\n+        return (minusCode == plusCode) ? minusCode : Location.BOUNDARY;\n+\n+    }\n+\n+    /** Get the complement of the region (exchanged interior/exterior).\n+     * <p>The instance is not modified, a new region is built.</p>\n+     * @return a new region, complement of the instance\n+     */\n+    public Region getComplement() {\n+        return buildNew(recurseComplement(tree));\n+    }\n+\n+    /** Recursively build the complement of a BSP tree.\n+     * @param node current node of the original tree\n+     * @return new tree, complement of the node\n+     */\n+    private static BSPTree recurseComplement(final BSPTree node) {\n+        if (node.getCut() == null) {\n+            return new BSPTree(isInside(node) ? Boolean.FALSE : Boolean.TRUE);\n+        }\n+\n+        BoundaryAttribute attribute = (BoundaryAttribute) node.getAttribute();\n+        if (attribute != null) {\n+            final SubHyperplane plusOutside =\n+                (attribute.plusInside == null) ? null : attribute.plusInside.copySelf();\n+            final SubHyperplane plusInside  =\n+                (attribute.plusOutside == null) ? null : attribute.plusOutside.copySelf();\n+            attribute = new BoundaryAttribute(plusOutside, plusInside);\n+        }\n+\n+        return new BSPTree(node.getCut().copySelf(),\n+                           recurseComplement(node.getPlus()),\n+                           recurseComplement(node.getMinus()),\n+                           attribute);\n+\n+    }\n+\n+    /** Get the underlying BSP tree.\n+\n+     * <p>Regions are represented by an underlying inside/outside BSP\n+     * tree whose leaf attributes are {@code Boolean} instances\n+     * representing inside leaf cells if the attribute value is\n+     * {@code true} and outside leaf cells if the attribute is\n+     * {@code false}. These leaf attributes are always present and\n+     * guaranteed to be non null.</p>\n+\n+     * <p>In addition to the leaf attributes, the internal nodes which\n+     * correspond to cells split by cut sub-hyperplanes may contain\n+     * {@link BoundaryAttribute BoundaryAttribute} objects representing\n+     * the parts of the corresponding cut sub-hyperplane that belong to\n+     * the boundary. When the boundary attributes have been computed,\n+     * all internal nodes are guaranteed to have non-null\n+     * attributes, however some {@link BoundaryAttribute\n+     * BoundaryAttribute} instances may have their {@link\n+     * BoundaryAttribute#plusInside plusInside} and {@link\n+     * BoundaryAttribute#plusOutside plusOutside} fields both null if\n+     * the corresponding cut sub-hyperplane does not have any parts\n+     * belonging to the boundary.</p>\n+\n+     * <p>Since computing the boundary is not always required and can be\n+     * time-consuming for large trees, these internal nodes attributes\n+     * are computed using lazy evaluation only when required by setting\n+     * the {@code includeBoundaryAttributes} argument to\n+     * {@code true}. Once computed, these attributes remain in the\n+     * tree, which implies that in this case, further calls to the\n+     * method for the same region will always include these attributes\n+     * regardless of the value of the\n+     * {@code includeBoundaryAttributes} argument.</p>\n+\n+     * @param includeBoundaryAttributes if true, the boundary attributes\n+     * at internal nodes are guaranteed to be included (they may be\n+     * included even if the argument is false, if they have already been\n+     * computed due to a previous call)\n+     * @return underlying BSP tree\n+     * @see BoundaryAttribute\n+     */\n+    public BSPTree getTree(final boolean includeBoundaryAttributes) {\n+        if (includeBoundaryAttributes && (tree.getCut() != null) && (tree.getAttribute() == null)) {\n+            // we need to compute the boundary attributes\n+            recurseBuildBoundary(tree);\n+        }\n+        return tree;\n+    }\n+\n+    /** Class holding boundary attributes.\n+     * <p>This class is used for the attributes associated with the\n+     * nodes of region boundary shell trees returned by the {@link\n+     * Region#getTree Region.getTree}. It contains the\n+     * parts of the node cut sub-hyperplane that belong to the\n+     * boundary.</p>\n+     * <p>This class is a simple placeholder, it does not provide any\n+     * processing methods.</p>\n+     * @see Region#getTree\n+     */\n+    public static class BoundaryAttribute {\n+\n+        /** Part of the node cut sub-hyperplane that belongs to the\n+         * boundary and has the outside of the region on the plus side of\n+         * its underlying hyperplane (may be null).\n+         */\n+        private final SubHyperplane plusOutside;\n+\n+        /** Part of the node cut sub-hyperplane that belongs to the\n+         * boundary and has the inside of the region on the plus side of\n+         * its underlying hyperplane (may be null).\n+         */\n+        private final SubHyperplane plusInside;\n+\n+        /** Simple constructor.\n+         * @param plusOutside part of the node cut sub-hyperplane that\n+         * belongs to the boundary and has the outside of the region on\n+         * the plus side of its underlying hyperplane (may be null)\n+         * @param plusInside part of the node cut sub-hyperplane that\n+         * belongs to the boundary and has the inside of the region on the\n+         * plus side of its underlying hyperplane (may be null)\n+         */\n+        public BoundaryAttribute(final SubHyperplane plusOutside,\n+                                 final SubHyperplane plusInside) {\n+            this.plusOutside = plusOutside;\n+            this.plusInside  = plusInside;\n+        }\n+\n+        /** Get the part of the node cut sub-hyperplane that belongs to the\n+         * boundary and has the outside of the region on the plus side of\n+         * its underlying hyperplane.\n+         * @return part of the node cut sub-hyperplane that belongs to the\n+         * boundary and has the outside of the region on the plus side of\n+         * its underlying hyperplane\n+         */\n+        public SubHyperplane getPlusOutside() {\n+            return plusOutside;\n+        }\n+\n+        /** Get the part of the node cut sub-hyperplane that belongs to the\n+         * boundary and has the inside of the region on the plus side of\n+         * its underlying hyperplane.\n+         * @return part of the node cut sub-hyperplane that belongs to the\n+         * boundary and has the inside of the region on the plus side of\n+         * its underlying hyperplane\n+         */\n+        public SubHyperplane getPlusInside() {\n+            return plusInside;\n+        }\n+\n+\n+    }\n+\n+    /** Recursively build the boundary shell tree.\n+     * @param node current node in the inout tree\n+     */\n+    private void recurseBuildBoundary(final BSPTree node) {\n+        if (node.getCut() != null) {\n+\n+            SubHyperplane plusOutside = null;\n+            SubHyperplane plusInside  = null;\n+\n+            // characterize the cut sub-hyperplane,\n+            // first with respect to the plus sub-tree\n+            final Characterization plusChar = new Characterization();\n+            characterize(node.getPlus(), node.getCut().copySelf(), plusChar);\n+\n+            if (plusChar.hasOut()) {\n+                // plusChar.out corresponds to a subset of the cut\n+                // sub-hyperplane known to have outside cells on its plus\n+                // side, we want to check if parts of this subset do have\n+                // inside cells on their minus side\n+                final Characterization minusChar = new Characterization();\n+                characterize(node.getMinus(), plusChar.getOut(), minusChar);\n+                if (minusChar.hasIn()) {\n+                    plusOutside = minusChar.getIn();\n+                }\n+            }\n+\n+            if (plusChar.hasIn()) {\n+                // plusChar.in corresponds to a subset of the cut\n+                // sub-hyperplane known to have inside cells on its plus\n+                // side, we want to check if parts of this subset do have\n+                // outside cells on their minus side\n+                final Characterization minusChar = new Characterization();\n+                characterize(node.getMinus(), plusChar.getIn(), minusChar);\n+                if (minusChar.hasOut()) {\n+                    plusInside = minusChar.getOut();\n+                }\n+            }\n+\n+            node.setAttribute(new BoundaryAttribute(plusOutside, plusInside));\n+            recurseBuildBoundary(node.getPlus());\n+            recurseBuildBoundary(node.getMinus());\n+\n+        }\n+    }\n+\n+    /** Filter the parts of an hyperplane belonging to the boundary.\n+     * <p>The filtering consist in splitting the specified\n+     * sub-hyperplane into several parts lying in inside and outside\n+     * cells of the tree. The principle is to call this method twice for\n+     * each cut sub-hyperplane in the tree, once one the plus node and\n+     * once on the minus node. The parts that have the same flag\n+     * (inside/inside or outside/outside) do not belong to the boundary\n+     * while parts that have different flags (inside/outside or\n+     * outside/inside) do belong to the boundary.</p>\n+     * @param node current BSP tree node\n+     * @param sub sub-hyperplane to characterize\n+     * @param characterization placeholder where to put the characterized parts\n+     */\n+    private static void characterize(final BSPTree node, final SubHyperplane sub,\n+                                     final Characterization characterization) {\n+        if (node.getCut() == null) {\n+            // we have reached a leaf node\n+            final boolean inside = (Boolean) node.getAttribute();\n+            characterization.add(sub, inside);\n+        } else {\n+            final Hyperplane hyperplane = node.getCut().getHyperplane();\n+            switch (hyperplane.side(sub)) {\n+            case PLUS:\n+                characterize(node.getPlus(), sub, characterization);\n+                break;\n+            case MINUS:\n+                characterize(node.getMinus(), sub, characterization);\n+                break;\n+            case BOTH:\n+                final Hyperplane.SplitSubHyperplane split = hyperplane.split(sub);\n+                characterize(node.getPlus(),  split.getPlus(),  characterization);\n+                characterize(node.getMinus(), split.getMinus(), characterization);\n+                break;\n+            default:\n+                // this should not happen\n+                throw new RuntimeException(\"internal error\");\n+            }\n+        }\n+    }\n+\n+    /** Get the size of the boundary.\n+     * @return the size of the boundary (this is 0 in 1D, a length in\n+     * 2D, an area in 3D ...)\n+     */\n+    public double getBoundarySize() {\n+        final BoundarySizeVisitor visitor = new BoundarySizeVisitor();\n+        getTree(true).visit(visitor);\n+        return visitor.getSize();\n+    }\n+\n+    /** Visitor computing the boundary size. */\n+    private static class BoundarySizeVisitor implements BSPTreeVisitor {\n+\n+        /** Size of the boundary. */\n+        private double boundarySize;\n+\n+        /** Simple constructor.\n+         */\n+        public BoundarySizeVisitor() {\n+            boundarySize = 0;\n+        }\n+\n+        /** {@inheritDoc}*/\n+        public Order visitOrder(final BSPTree node) {\n+            return Order.MINUS_SUB_PLUS;\n+        }\n+\n+        /** {@inheritDoc}*/\n+        public void visitInternalNode(final BSPTree node) {\n+            final BoundaryAttribute attribute = (BoundaryAttribute) node.getAttribute();\n+            if (attribute.plusOutside != null) {\n+                boundarySize += attribute.plusOutside.getRemainingRegion().getSize();\n+            }\n+            if (attribute.plusInside != null) {\n+                boundarySize += attribute.plusInside.getRemainingRegion().getSize();\n+            }\n+        }\n+\n+        /** {@inheritDoc}*/\n+        public void visitLeafNode(final BSPTree node) {\n+        }\n+\n+        /** Get the size of the boundary.\n+         * @return size of the boundary\n+         */\n+        public double getSize() {\n+            return boundarySize;\n+        }\n+\n+    }\n+\n+    /** Get the size of the instance.\n+     * @return the size of the instance (this is a length in 1D, an area\n+     * in 2D, a volume in 3D ...)\n+     */\n+    public double getSize() {\n+        if (barycenter == null) {\n+            computeGeometricalProperties();\n+        }\n+        return size;\n+    }\n+\n+    /** Set the size of the instance.\n+     * @param size size of the instance\n+     */\n+    protected void setSize(final double size) {\n+        this.size = size;\n+    }\n+\n+    /** Get the barycenter of the instance.\n+     * @return an object representing the barycenter\n+     */\n+    public Point getBarycenter() {\n+        if (barycenter == null) {\n+            computeGeometricalProperties();\n+        }\n+        return barycenter;\n+    }\n+\n+    /** Set the barycenter of the instance.\n+     * @param barycenter barycenter of the instance\n+     */\n+    protected void setBarycenter(final Point barycenter) {\n+        this.barycenter = barycenter;\n+    }\n+\n+    /** Compute some geometrical properties.\n+     * <p>The properties to compute are the barycenter and the size.</p>\n+     */\n+    protected abstract void computeGeometricalProperties();\n+\n+    /** Transform a region.\n+     * <p>Applying a transform to a region consist in applying the\n+     * transform to all the hyperplanes of the underlying BSP tree and\n+     * of the boundary (and also to the sub-hyperplanes embedded in\n+     * these hyperplanes) and to the barycenter. The instance is not\n+     * modified, a new instance is built.</p>\n+     * @param transform transform to apply\n+     * @return a new region, resulting from the application of the\n+     * transform to the instance\n+     */\n+    public Region applyTransform(final Transform transform) {\n+\n+        // transform the BSP tree\n+        final Region tRegion = buildNew(recurseTransform(tree, transform));\n+\n+        // transform the barycenter\n+        if (barycenter != null) {\n+            tRegion.size = size;\n+            tRegion.barycenter = transform.apply(barycenter);\n+        }\n+\n+        return tRegion;\n+\n+    }\n+\n+    /** Recursively transform an inside/outside BSP-tree.\n+     * @param node current BSP tree node\n+     * @param transform transform to apply\n+     * @return a new tree\n+     */\n+    private BSPTree recurseTransform(final BSPTree node, final Transform transform) {\n+\n+        if (node.getCut() == null) {\n+            return new BSPTree(node.getAttribute());\n+        }\n+\n+        final SubHyperplane  sub = node.getCut();\n+        final SubHyperplane tSub = sub.applyTransform(transform);\n+        BoundaryAttribute attribute = (BoundaryAttribute) node.getAttribute();\n+        if (attribute != null) {\n+            final SubHyperplane tPO =\n+                (attribute.getPlusOutside() == null) ? null : attribute.getPlusOutside().applyTransform(transform);\n+            final SubHyperplane tPI =\n+                (attribute.getPlusInside()  == null) ? null  : attribute.getPlusInside().applyTransform(transform);\n+            attribute = new BoundaryAttribute(tPO, tPI);\n+        }\n+\n+        return new BSPTree(tSub,\n+                           recurseTransform(node.getPlus(),  transform),\n+                           recurseTransform(node.getMinus(), transform),\n+                           attribute);\n+\n+    }\n+\n+    /** Compute the relative position of the instance with respect to an\n+     * hyperplane.\n+     * @param hyperplane reference hyperplane\n+     * @return one of {@link Hyperplane.Side#PLUS Hyperplane.Side.PLUS}, {@link\n+     * Hyperplane.Side#MINUS Hyperplane.Side.MINUS}, {@link Hyperplane.Side#BOTH\n+     * Hyperplane.Side.BOTH} or {@link Hyperplane.Side#HYPER Hyperplane.Side.HYPER}\n+     * (the latter result can occur only if the tree contains only one\n+     * cut hyperplane)\n+     */\n+    public Hyperplane.Side side(final Hyperplane hyperplane) {\n+        final Sides sides = new Sides();\n+        recurseSides(tree, new SubHyperplane(hyperplane), sides);\n+        return sides.plusFound() ?\n+              (sides.minusFound() ? Hyperplane.Side.BOTH  : Hyperplane.Side.PLUS) :\n+              (sides.minusFound() ? Hyperplane.Side.MINUS : Hyperplane.Side.HYPER);\n+    }\n+\n+    /** Search recursively for inside leaf nodes on each side of the given hyperplane.\n+\n+     * <p>The algorithm used here is directly derived from the one\n+     * described in section III (<i>Binary Partitioning of a BSP\n+     * Tree</i>) of the Bruce Naylor, John Amanatides and William\n+     * Thibault paper <a\n+     * href=\"http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf\">Merging\n+     * BSP Trees Yields Polyhedral Set Operations</a> Proc. Siggraph\n+     * '90, Computer Graphics 24(4), August 1990, pp 115-124, published\n+     * by the Association for Computing Machinery (ACM)..</p>\n+\n+     * @param node current BSP tree node\n+     * @param sub sub-hyperplane\n+     * @param sides object holding the sides found\n+     */\n+    private void recurseSides(final BSPTree node, final SubHyperplane sub, final Sides sides) {\n+\n+        if (node.getCut() == null) {\n+            if (isInside(node)) {\n+                // this is an inside cell expanding across the hyperplane\n+                sides.rememberPlusFound();\n+                sides.rememberMinusFound();\n+            }\n+            return;\n+        }\n+\n+        final Hyperplane hyperplane = node.getCut().getHyperplane();\n+        switch (hyperplane.side(sub)) {\n+        case PLUS :\n+            // the sub-hyperplane is entirely in the plus sub-tree\n+            if (sub.getHyperplane().side(node.getCut()) == Hyperplane.Side.PLUS) {\n+                if (!isEmpty(node.getMinus())) {\n+                    sides.rememberPlusFound();\n+                }\n+            } else {\n+                if (!isEmpty(node.getMinus())) {\n+                    sides.rememberMinusFound();\n+                }\n+            }\n+            if (!(sides.plusFound() && sides.minusFound())) {\n+                recurseSides(node.getPlus(), sub, sides);\n+            }\n+            break;\n+        case MINUS :\n+            // the sub-hyperplane is entirely in the minus sub-tree\n+            if (sub.getHyperplane().side(node.getCut()) == Hyperplane.Side.PLUS) {\n+                if (!isEmpty(node.getPlus())) {\n+                    sides.rememberPlusFound();\n+                }\n+            } else {\n+                if (!isEmpty(node.getPlus())) {\n+                    sides.rememberMinusFound();\n+                }\n+            }\n+            if (!(sides.plusFound() && sides.minusFound())) {\n+                recurseSides(node.getMinus(), sub, sides);\n+            }\n+            break;\n+        case BOTH :\n+            // the sub-hyperplane extends in both sub-trees\n+            final Hyperplane.SplitSubHyperplane split = hyperplane.split(sub);\n+\n+            // explore first the plus sub-tree\n+            recurseSides(node.getPlus(), split.getPlus(), sides);\n+\n+            // if needed, explore the minus sub-tree\n+            if (!(sides.plusFound() && sides.minusFound())) {\n+                recurseSides(node.getMinus(), split.getMinus(), sides);\n+            }\n+            break;\n+        default :\n+            // the sub-hyperplane and the cut sub-hyperplane share the same hyperplane\n+            if (node.getCut().getHyperplane().sameOrientationAs(sub.getHyperplane())) {\n+                if ((node.getPlus().getCut() != null) || isInside(node.getPlus())) {\n+                    sides.rememberPlusFound();\n+                }\n+                if ((node.getMinus().getCut() != null) || isInside(node.getMinus())) {\n+                    sides.rememberMinusFound();\n+                }\n+            } else {\n+                if ((node.getPlus().getCut() != null) || isInside(node.getPlus())) {\n+                    sides.rememberMinusFound();\n+                }\n+                if ((node.getMinus().getCut() != null) || isInside(node.getMinus())) {\n+                    sides.rememberPlusFound();\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    /** Utility class holding the already found sides. */\n+    private static final class Sides {\n+\n+        /** Indicator of inside leaf nodes found on the plus side. */\n+        private boolean plusFound;\n+\n+        /** Indicator of inside leaf nodes found on the plus side. */\n+        private boolean minusFound;\n+\n+        /** Simple constructor.\n+         */\n+        public Sides() {\n+            plusFound  = false;\n+            minusFound = false;\n+        }\n+\n+        /** Remember the fact that inside leaf nodes have been found on the plus side.\n+         */\n+        public void rememberPlusFound() {\n+            plusFound = true;\n+        }\n+\n+        /** Check if inside leaf nodes have been found on the plus side.\n+         * @return true if inside leaf nodes have been found on the plus side\n+         */\n+        public boolean plusFound() {\n+            return plusFound;\n+        }\n+\n+        /** Remember the fact that inside leaf nodes have been found on the minus side.\n+         */\n+        public void rememberMinusFound() {\n+            minusFound = true;\n+        }\n+\n+        /** Check if inside leaf nodes have been found on the minus side.\n+         * @return true if inside leaf nodes have been found on the minus side\n+         */\n+        public boolean minusFound() {\n+            return minusFound;\n+        }\n+\n+    }\n+\n+    /** Get the parts of a sub-hyperplane that are contained in the region.\n+     * <p>The parts of the sub-hyperplane that belong to the boundary are\n+     * <em>not</em> included in the resulting parts.</p>\n+     * @param sub sub-hyperplane traversing the region\n+     * @return filtered sub-hyperplane\n+     */\n+    public SubHyperplane intersection(final SubHyperplane sub) {\n+        return recurseIntersection(tree, sub);\n+    }\n+\n+    /** Recursively compute the parts of a sub-hyperplane that are\n+     * contained in the region.\n+     * @param node current BSP tree node\n+     * @param sub sub-hyperplane traversing the region\n+     * @return filtered sub-hyperplane\n+     */\n+    private SubHyperplane recurseIntersection(final BSPTree node, final SubHyperplane sub) {\n+\n+        if (node.getCut() == null) {\n+            return isInside(node) ? sub.copySelf() : null;\n+        }\n+\n+        final Hyperplane hyperplane = node.getCut().getHyperplane();\n+        switch (hyperplane.side(sub)) {\n+        case PLUS :\n+            return recurseIntersection(node.getPlus(), sub);\n+        case MINUS :\n+            return recurseIntersection(node.getMinus(), sub);\n+        case BOTH :\n+            final Hyperplane.SplitSubHyperplane split = hyperplane.split(sub);\n+            final SubHyperplane plus  = recurseIntersection(node.getPlus(),  split.getPlus());\n+            final SubHyperplane minus = recurseIntersection(node.getMinus(), split.getMinus());\n+            if (plus == null) {\n+                return minus;\n+            } else if (minus == null) {\n+                return plus;\n+            } else {\n+                return new SubHyperplane(plus.getHyperplane(),\n+                                         Region.union(plus.getRemainingRegion(),\n+                                                      minus.getRemainingRegion()));\n+            }\n+        default :\n+            return recurseIntersection(node.getPlus(),\n+                                       recurseIntersection(node.getMinus(), sub));\n+        }\n+\n+    }\n+\n+    /** Compute the union of two regions.\n+     * @param region1 first region (will be unusable after the operation as\n+     * parts of it will be reused in the new region)\n+     * @param region2 second region (will be unusable after the operation as\n+     * parts of it will be reused in the new region)\n+     * @return a new region, result of {@code region1 union region2}\n+     */\n+    public static Region union(final Region region1, final Region region2) {\n+        final BSPTree tree = region1.tree.merge(region2.tree, new UnionMerger());\n+        tree.visit(new InternalNodesCleaner());\n+        return region1.buildNew(tree);\n+    }\n+\n+    /** Compute the intersection of two regions.\n+     * @param region1 first region (will be unusable after the operation as\n+     * parts of it will be reused in the new region)\n+     * @param region2 second region (will be unusable after the operation as\n+     * parts of it will be reused in the new region)\n+     * @return a new region, result of {@code region1 intersection region2}\n+     */\n+    public static Region intersection(final Region region1, final Region region2) {\n+        final BSPTree tree = region1.tree.merge(region2.tree, new IntersectionMerger());\n+        tree.visit(new InternalNodesCleaner());\n+        return region1.buildNew(tree);\n+    }\n+\n+    /** Compute the symmetric difference (exclusive or) of two regions.\n+     * @param region1 first region (will be unusable after the operation as\n+     * parts of it will be reused in the new region)\n+     * @param region2 second region (will be unusable after the operation as\n+     * parts of it will be reused in the new region)\n+     * @return a new region, result of {@code region1 xor region2}\n+     */\n+    public static Region xor(final Region region1, final Region region2) {\n+        final BSPTree tree = region1.tree.merge(region2.tree, new XORMerger());\n+        tree.visit(new InternalNodesCleaner());\n+        return region1.buildNew(tree);\n+    }\n+\n+    /** Compute the difference of two regions.\n+     * @param region1 first region (will be unusable after the operation as\n+     * parts of it will be reused in the new region)\n+     * @param region2 second region (will be unusable after the operation as\n+     * parts of it will be reused in the new region)\n+     * @return a new region, result of {@code region1 minus region2}\n+     */\n+    public static Region difference(final Region region1, final Region region2) {\n+        final BSPTree tree = region1.tree.merge(region2.tree, new DifferenceMerger());\n+        tree.visit(new InternalNodesCleaner());\n+        return region1.buildNew(tree);\n+    }\n+\n+    /** Leaf node / tree merger for union operation. */\n+    private static final class UnionMerger implements BSPTree.LeafMerger {\n+        /** {@inheritDoc} */\n+        public BSPTree merge(final BSPTree leaf, final BSPTree tree,\n+                             final BSPTree parentTree, final boolean isPlusChild,\n+                             final boolean leafFromInstance) {\n+            if (isInside(leaf)) {\n+                // the leaf node represents an inside cell\n+                leaf.insertInTree(parentTree, isPlusChild);\n+                return leaf;\n+            }\n+            // the leaf node represents an outside cell\n+            tree.insertInTree(parentTree, isPlusChild);\n+            return tree;\n+        }\n+    };\n+\n+    /** Leaf node / tree merger for intersection operation. */\n+    private static final class IntersectionMerger implements BSPTree.LeafMerger {\n+        /** {@inheritDoc} */\n+        public BSPTree merge(final BSPTree leaf, final BSPTree tree,\n+                             final BSPTree parentTree, final boolean isPlusChild,\n+                             final boolean leafFromInstance) {\n+            if (isInside(leaf)) {\n+                // the leaf node represents an inside cell\n+                tree.insertInTree(parentTree, isPlusChild);\n+                return tree;\n+            }\n+            // the leaf node represents an outside cell\n+            leaf.insertInTree(parentTree, isPlusChild);\n+            return leaf;\n+        }\n+    };\n+\n+    /** Leaf node / tree merger for xor operation. */\n+    private static final class XORMerger implements BSPTree.LeafMerger {\n+        /** {@inheritDoc} */\n+        public BSPTree merge(final BSPTree leaf, final BSPTree tree,\n+                             final BSPTree parentTree, final boolean isPlusChild,\n+                             final boolean leafFromInstance) {\n+            BSPTree t = tree;\n+            if (isInside(leaf)) {\n+                // the leaf node represents an inside cell\n+                t = recurseComplement(t);\n+            }\n+            t.insertInTree(parentTree, isPlusChild);\n+            return t;\n+        }\n+    };\n+\n+    /** Leaf node / tree merger for difference operation.\n+     * <p>The algorithm used here is directly derived from the one\n+     * described in section III (<i>Binary Partitioning of a BSP\n+     * Tree</i>) of the Naylor, Amanatides and Thibault paper. An error\n+     * was detected and corrected in the figure 5.1 of the article for\n+     * merging leaf nodes with complete trees. Contrary to what is said\n+     * in the figure, the {@code ELSE} part of if is not the same\n+     * as the first part with {@code T1} and {@codeT2}\n+     * swapped. {@code T1} and {@codeT2} must be swapped\n+     * everywhere <em>except</em> in the {@code RETURN} part of the\n+     * {@code DIFFERENCE} operation: if {@codeT2} is an\n+     * in-cell, we must return {@code Complement_Bspt(T2)}, not\n+     * {@code Complement_Bspt(T1)}, and if {@codeT2} is an\n+     * out-cell, we must return {@code T1}, not {@codeT2}</p>\n+     */\n+    private static final class DifferenceMerger implements BSPTree.LeafMerger {\n+        /** {@inheritDoc} */\n+        public BSPTree merge(final BSPTree leaf, final BSPTree tree,\n+                             final BSPTree parentTree, final boolean isPlusChild,\n+                             final boolean leafFromInstance) {\n+            if (isInside(leaf)) {\n+                // the leaf node represents an inside cell\n+                final BSPTree argTree = recurseComplement(leafFromInstance ? tree : leaf);\n+                argTree.insertInTree(parentTree, isPlusChild);\n+                return argTree;\n+            }\n+            // the leaf node represents an outside cell\n+            final BSPTree instanceTree = leafFromInstance ? leaf : tree;\n+            instanceTree.insertInTree(parentTree, isPlusChild);\n+            return instanceTree;\n+        }\n+    };\n+\n+    /** Visitor removing internal nodes attributes. */\n+    private static final class InternalNodesCleaner implements BSPTreeVisitor {\n+\n+        /** {@inheritDoc} */\n+        public Order visitOrder(final BSPTree node) {\n+            return Order.PLUS_SUB_MINUS;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void visitInternalNode(final BSPTree node) {\n+            node.setAttribute(null);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void visitLeafNode(final BSPTree node) {\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/SubHyperplane.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.partitioning;\n+\n+/** This interface represents the remaining parts of an hyperplane after\n+ * other parts have been chopped off.\n+\n+ * <p>sub-hyperplanes are obtained when parts of an {@link\n+ * Hyperplane hyperplane} are chopped off by other hyperplanes that\n+ * intersect it. The remaining part is a convex region. Such objects\n+ * appear in {@link BSPTree BSP trees} as the intersection of a cut\n+ * hyperplane with the convex region which it splits, the chopping\n+ * hyperplanes are the cut hyperplanes closer to the tree root.</p>\n+\n+ * @version $Revision$ $Date$\n+ */\n+public class SubHyperplane {\n+\n+    /** Underlying hyperplane. */\n+    private final Hyperplane hyperplane;\n+\n+    /** Remaining region of the hyperplane. */\n+    private final Region remainingRegion;\n+\n+    /** Build a chopped hyperplane that is not chopped at all.\n+     * @param hyperplane underlying hyperplane\n+     */\n+    public SubHyperplane(final Hyperplane hyperplane) {\n+        this.hyperplane = hyperplane;\n+        remainingRegion = hyperplane.wholeHyperplane();\n+    }\n+\n+    /** Build a sub-hyperplane from an hyperplane and a region.\n+     * @param hyperplane underlying hyperplane\n+     * @param remainingRegion remaining region of the hyperplane\n+     */\n+    public SubHyperplane(final Hyperplane hyperplane, final Region remainingRegion) {\n+        this.hyperplane      = hyperplane;\n+        this.remainingRegion = remainingRegion;\n+    }\n+\n+    /** Copy the instance.\n+     * <p>The instance created is completely independant of the original\n+     * one. A deep copy is used, none of the underlying objects are\n+     * shared (except for the nodes attributes and immutable\n+     * objects).</p>\n+     * @return a new sub-hyperplane, copy of the instance\n+     */\n+    public SubHyperplane copySelf() {\n+        return new SubHyperplane(hyperplane.copySelf(), remainingRegion.copySelf());\n+    }\n+\n+    /** Get the underlying hyperplane.\n+     * @return underlying hyperplane\n+     */\n+    public Hyperplane getHyperplane() {\n+        return hyperplane;\n+    }\n+\n+    /** Get the remaining region of the hyperplane.\n+     * <p>The returned region is expressed in the canonical hyperplane\n+     * frame and has the hyperplane dimension. For example a chopped\n+     * hyperplane in the 3D euclidean is a 2D plane and the\n+     * corresponding region is a convex 2D polygon.</p>\n+     * @return remaining region of the hyperplane\n+     */\n+    public Region getRemainingRegion() {\n+        return remainingRegion;\n+    }\n+\n+    /** Apply a transform to the instance.\n+     * <p>The instance must be a (D-1)-dimension sub-hyperplane with\n+     * respect to the transform <em>not</em> a (D-2)-dimension\n+     * sub-hyperplane the transform knows how to transform by\n+     * itself. The transform will consist in transforming first the\n+     * hyperplane and then the all region using the various methods\n+     * provided by the transform.</p>\n+     * @param transform D-dimension transform to apply\n+     * @return the transformed instance\n+     */\n+    public SubHyperplane applyTransform(final Transform transform) {\n+        final Hyperplane tHyperplane = transform.apply(hyperplane);\n+        final BSPTree tTree =\n+            recurseTransform(remainingRegion.getTree(false), tHyperplane, transform);\n+        return new SubHyperplane(tHyperplane, remainingRegion.buildNew(tTree));\n+    }\n+\n+    /** Recursively transform a BSP-tree from a sub-hyperplane.\n+     * @param node current BSP tree node\n+     * @param transformed image of the instance hyperplane by the transform\n+     * @param transform transform to apply\n+     * @return a new tree\n+     */\n+    private BSPTree recurseTransform(final BSPTree node, final Hyperplane transformed,\n+                                     final Transform transform) {\n+        if (node.getCut() == null) {\n+            return new BSPTree(node.getAttribute());\n+        }\n+\n+        Region.BoundaryAttribute attribute =\n+            (Region.BoundaryAttribute) node.getAttribute();\n+        if (attribute != null) {\n+            final SubHyperplane tPO = (attribute.getPlusOutside() == null) ?\n+                                      null :\n+                                      transform.apply(attribute.getPlusOutside(),\n+                                                      hyperplane, transformed);\n+            final SubHyperplane tPI = (attribute.getPlusInside() == null) ?\n+                                      null :\n+                                      transform.apply(attribute.getPlusInside(),\n+                                                      hyperplane, transformed);\n+            attribute = new Region.BoundaryAttribute(tPO, tPI);\n+        }\n+\n+        return new BSPTree(transform.apply(node.getCut(),\n+                                           hyperplane, transformed),\n+                                           recurseTransform(node.getPlus(), transformed,\n+                                                            transform),\n+                                                            recurseTransform(node.getMinus(), transformed,\n+                                                                             transform),\n+                                                                             attribute);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/SubSpace.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.partitioning;\n+\n+\n+/** This interface represents a sub-space of a space.\n+\n+ * <p>Sub-spaces are the lower dimensions subsets of a n-dimensions\n+ * space. The (n-1)-dimension sub-spaces are specific sub-spaces known\n+ * as {@link Hyperplane hyperplanes}.</p>\n+\n+ * <p>In the 3D euclidean space, hyperplanes are 2D planes, and the 1D\n+ * sub-spaces are lines.</p>\n+\n+ * @see Hyperplane\n+ * @version $Revision$ $Date$\n+ */\n+public interface SubSpace {\n+\n+    /** Transform a space point into a sub-space point.\n+     * @param point n-dimension point of the space\n+     * @return (n-1)-dimension point of the sub-space corresponding to\n+     * the specified space point\n+     * @see #toSpace\n+     */\n+    Point toSubSpace(Point point);\n+\n+    /** Transform a sub-space point into a space point.\n+     * @param point (n-1)-dimension point of the sub-space\n+     * @return n-dimension point of the space corresponding to the\n+     * specified sub-space point\n+     * @see #toSubSpace\n+     */\n+    Point toSpace(Point point);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/Transform.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.partitioning;\n+\n+\n+/** This interface represents an inversible affine transform in a space.\n+ * <p>Inversible affine transform include for example scalings,\n+ * translations, rotations.</p>\n+\n+ * <p>Transforms are dimension-specific. The consistency rules between\n+ * the three {@code apply} methods are the following ones for a\n+ * transformed defined for dimension D:</p>\n+ * <ul>\n+ *   <li>\n+ *     the transform can be applied to a point in the\n+ *     D-dimension space using its {@link #apply(Point)}\n+ *     method\n+ *   </li>\n+ *   <li>\n+ *     the transform can be applied to a (D-1)-dimension\n+ *     hyperplane in the D-dimension space using its\n+ *     {@link #apply(Hyperplane)} method\n+ *   </li>\n+ *   <li>\n+ *     the transform can be applied to a (D-2)-dimension\n+ *     sub-hyperplane in a (D-1)-dimension hyperplane using\n+ *     its {@link #apply(SubHyperplane, Hyperplane, Hyperplane)}\n+ *     method\n+ *   </li>\n+ * </ul>\n+\n+ * @version $Revision$ $Date$\n+ */\n+public interface Transform {\n+\n+    /** Transform a point of a space.\n+     * @param point point to transform\n+     * @return a new object representing the transformed point\n+     */\n+    Point apply(Point point);\n+\n+    /** Transform an hyperplane of a space.\n+     * @param hyperplane hyperplane to transform\n+     * @return a new object representing the transformed hyperplane\n+     */\n+    Hyperplane apply(Hyperplane hyperplane);\n+\n+    /** Transform a sub-hyperplane embedded in an hyperplane.\n+     * @param sub sub-hyperplane to transform\n+     * @param original hyperplane in which the sub-hyperplane is\n+     * defined (this is the original hyperplane, the transform has\n+     * <em>not</em> been applied to it)\n+     * @param transformed hyperplane in which the sub-hyperplane is\n+     * defined (this is the transformed hyperplane, the transform\n+     * <em>has</em> been applied to it)\n+     * @return a new object representing the transformed sub-hyperplane\n+     */\n+    SubHyperplane apply(SubHyperplane sub, Hyperplane original, Hyperplane transformed);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/utilities/AVLTree.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.partitioning.utilities;\n+\n+/** This class implements AVL trees.\n+\n+ * <p>The purpose of this class is to sort elements while allowing\n+ * duplicate elements (i.e. such that {@code a.equals(b)} is\n+ * true). The {@code SortedSet} interface does not allow this, so\n+ * a specific class is needed. Null elements are not allowed.</p>\n+\n+ * <p>Since the {@code equals} method is not sufficient to\n+ * differentiate elements, the {@link #delete delete} method is\n+ * implemented using the equality operator.</p>\n+\n+ * <p>In order to clearly mark the methods provided here do not have\n+ * the same semantics as the ones specified in the\n+ * {@code SortedSet} interface, different names are used\n+ * ({@code add} has been replaced by {@link #insert insert} and\n+ * {@code remove} has been replaced by {@link #delete\n+ * delete}).</p>\n+\n+ * <p>This class is based on the C implementation Georg Kraml has put\n+ * in the public domain. Unfortunately, his <a\n+ * href=\"www.purists.org/georg/avltree/index.html\">page</a> seems not\n+ * to exist any more.</p>\n+\n+ * @param <T> the type of the elements\n+\n+ * @version $Revision$ $Date$\n+ */\n+public class AVLTree<T extends Comparable<T>> {\n+\n+    /** Top level node. */\n+    private Node top;\n+\n+    /** Build an empty tree.\n+     */\n+    public AVLTree() {\n+        top = null;\n+    }\n+\n+    /** Insert an element in the tree.\n+     * @param element element to insert (silently ignored if null)\n+     */\n+    public void insert(final T element) {\n+        if (element != null) {\n+            if (top == null) {\n+                top = new Node(element, null);\n+            } else {\n+                top.insert(element);\n+            }\n+        }\n+    }\n+\n+    /** Delete an element from the tree.\n+     * <p>The element is deleted only if there is a node {@code n}\n+     * containing exactly the element instance specified, i.e. for which\n+     * {@code n.getElement() == element}. This is purposely\n+     * <em>different</em> from the specification of the\n+     * {@code java.util.Set} {@code remove} method (in fact,\n+     * this is the reason why a specific class has been developed).</p>\n+     * @param element element to delete (silently ignored if null)\n+     * @return true if the element was deleted from the tree\n+     */\n+    public boolean delete(final T element) {\n+        if (element != null) {\n+            for (Node node = getNotSmaller(element); node != null; node = node.getNext()) {\n+                // loop over all elements neither smaller nor larger\n+                // than the specified one\n+                if (node.element == element) {\n+                    node.delete();\n+                    return true;\n+                } else if (node.element.compareTo(element) > 0) {\n+                    // all the remaining elements are known to be larger,\n+                    // the element is not in the tree\n+                    return false;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /** Check if the tree is empty.\n+     * @return true if the tree is empty\n+     */\n+    public boolean isEmpty() {\n+        return top == null;\n+    }\n+\n+\n+    /** Get the number of elements of the tree.\n+     * @return number of elements contained in the tree\n+     */\n+    public int size() {\n+        return (top == null) ? 0 : top.size();\n+    }\n+\n+    /** Get the node whose element is the smallest one in the tree.\n+     * @return the tree node containing the smallest element in the tree\n+     * or null if the tree is empty\n+     * @see #getLargest\n+     * @see #getNotSmaller\n+     * @see #getNotLarger\n+     * @see Node#getPrevious\n+     * @see Node#getNext\n+     */\n+    public Node getSmallest() {\n+        return (top == null) ? null : top.getSmallest();\n+    }\n+\n+    /** Get the node whose element is the largest one in the tree.\n+     * @return the tree node containing the largest element in the tree\n+     * or null if the tree is empty\n+     * @see #getSmallest\n+     * @see #getNotSmaller\n+     * @see #getNotLarger\n+     * @see Node#getPrevious\n+     * @see Node#getNext\n+     */\n+    public Node getLargest() {\n+        return (top == null) ? null : top.getLargest();\n+    }\n+\n+    /** Get the node whose element is not smaller than the reference object.\n+     * @param reference reference object (may not be in the tree)\n+     * @return the tree node containing the smallest element not smaller\n+     * than the reference object or null if either the tree is empty or\n+     * all its elements are smaller than the reference object\n+     * @see #getSmallest\n+     * @see #getLargest\n+     * @see #getNotLarger\n+     * @see Node#getPrevious\n+     * @see Node#getNext\n+     */\n+    public Node getNotSmaller(final T reference) {\n+        Node candidate = null;\n+        for (Node node = top; node != null;) {\n+            if (node.element.compareTo(reference) < 0) {\n+                if (node.right == null) {\n+                    return candidate;\n+                }\n+                node = node.right;\n+            } else {\n+                candidate = node;\n+                if (node.left == null) {\n+                    return candidate;\n+                }\n+                node = node.left;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /** Get the node whose element is not larger than the reference object.\n+     * @param reference reference object (may not be in the tree)\n+     * @return the tree node containing the largest element not larger\n+     * than the reference object (in which case the node is guaranteed\n+     * not to be empty) or null if either the tree is empty or all its\n+     * elements are larger than the reference object\n+     * @see #getSmallest\n+     * @see #getLargest\n+     * @see #getNotSmaller\n+     * @see Node#getPrevious\n+     * @see Node#getNext\n+     */\n+    public Node getNotLarger(final T reference) {\n+        Node candidate = null;\n+        for (Node node = top; node != null;) {\n+            if (node.element.compareTo(reference) > 0) {\n+                if (node.left == null) {\n+                    return candidate;\n+                }\n+                node = node.left;\n+            } else {\n+                candidate = node;\n+                if (node.right == null) {\n+                    return candidate;\n+                }\n+                node = node.right;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /** Enum for tree skew factor. */\n+    private static enum Skew {\n+        /** Code for left high trees. */\n+        LEFT_HIGH,\n+\n+        /** Code for right high trees. */\n+        RIGHT_HIGH,\n+\n+        /** Code for Skew.BALANCED trees. */\n+        BALANCED;\n+    }\n+\n+    /** This class implements AVL trees nodes.\n+     * <p>AVL tree nodes implement all the logical structure of the\n+     * tree. Nodes are created by the {@link AVLTree AVLTree} class.</p>\n+     * <p>The nodes are not independant from each other but must obey\n+     * specific balancing constraints and the tree structure is\n+     * rearranged as elements are inserted or deleted from the tree. The\n+     * creation, modification and tree-related navigation methods have\n+     * therefore restricted access. Only the order-related navigation,\n+     * reading and delete methods are public.</p>\n+     * @see AVLTree\n+     */\n+    public class Node {\n+\n+        /** Element contained in the current node. */\n+        private T element;\n+\n+        /** Left sub-tree. */\n+        private Node left;\n+\n+        /** Right sub-tree. */\n+        private Node right;\n+\n+        /** Parent tree. */\n+        private Node parent;\n+\n+        /** Skew factor. */\n+        private Skew skew;\n+\n+        /** Build a node for a specified element.\n+         * @param element element\n+         * @param parent parent node\n+         */\n+        Node(final T element, final Node parent) {\n+            this.element = element;\n+            left         = null;\n+            right        = null;\n+            this.parent  = parent;\n+            skew         = Skew.BALANCED;\n+        }\n+\n+        /** Get the contained element.\n+         * @return element contained in the node\n+         */\n+        public T getElement() {\n+            return element;\n+        }\n+\n+        /** Get the number of elements of the tree rooted at this node.\n+         * @return number of elements contained in the tree rooted at this node\n+         */\n+        int size() {\n+            return 1 + ((left  == null) ? 0 : left.size()) + ((right == null) ? 0 : right.size());\n+        }\n+\n+        /** Get the node whose element is the smallest one in the tree\n+         * rooted at this node.\n+         * @return the tree node containing the smallest element in the\n+         * tree rooted at this node or null if the tree is empty\n+         * @see #getLargest\n+         */\n+        Node getSmallest() {\n+            Node node = this;\n+            while (node.left != null) {\n+                node = node.left;\n+            }\n+            return node;\n+        }\n+\n+        /** Get the node whose element is the largest one in the tree\n+         * rooted at this node.\n+         * @return the tree node containing the largest element in the\n+         * tree rooted at this node or null if the tree is empty\n+         * @see #getSmallest\n+         */\n+        Node getLargest() {\n+            Node node = this;\n+            while (node.right != null) {\n+                node = node.right;\n+            }\n+            return node;\n+        }\n+\n+        /** Get the node containing the next smaller or equal element.\n+         * @return node containing the next smaller or equal element or\n+         * null if there is no smaller or equal element in the tree\n+         * @see #getNext\n+         */\n+        public Node getPrevious() {\n+\n+            if (left != null) {\n+                final Node node = left.getLargest();\n+                if (node != null) {\n+                    return node;\n+                }\n+            }\n+\n+            for (Node node = this; node.parent != null; node = node.parent) {\n+                if (node != node.parent.left) {\n+                    return node.parent;\n+                }\n+            }\n+\n+            return null;\n+\n+        }\n+\n+        /** Get the node containing the next larger or equal element.\n+         * @return node containing the next larger or equal element (in\n+         * which case the node is guaranteed not to be empty) or null if\n+         * there is no larger or equal element in the tree\n+         * @see #getPrevious\n+         */\n+        public Node getNext() {\n+\n+            if (right != null) {\n+                final Node node = right.getSmallest();\n+                if (node != null) {\n+                    return node;\n+                }\n+            }\n+\n+            for (Node node = this; node.parent != null; node = node.parent) {\n+                if (node != node.parent.right) {\n+                    return node.parent;\n+                }\n+            }\n+\n+            return null;\n+\n+        }\n+\n+        /** Insert an element in a sub-tree.\n+         * @param newElement element to insert\n+         * @return true if the parent tree should be re-Skew.BALANCED\n+         */\n+        boolean insert(final T newElement) {\n+            if (newElement.compareTo(this.element) < 0) {\n+                // the inserted element is smaller than the node\n+                if (left == null) {\n+                    left = new Node(newElement, this);\n+                    return rebalanceLeftGrown();\n+                }\n+                return left.insert(newElement) ? rebalanceLeftGrown() : false;\n+            }\n+\n+            // the inserted element is equal to or greater than the node\n+            if (right == null) {\n+                right = new Node(newElement, this);\n+                return rebalanceRightGrown();\n+            }\n+            return right.insert(newElement) ? rebalanceRightGrown() : false;\n+\n+        }\n+\n+        /** Delete the node from the tree.\n+         */\n+        public void delete() {\n+            if ((parent == null) && (left == null) && (right == null)) {\n+                // this was the last node, the tree is now empty\n+                element = null;\n+                top     = null;\n+            } else {\n+\n+                Node node;\n+                Node child;\n+                boolean leftShrunk;\n+                if ((left == null) && (right == null)) {\n+                    node       = this;\n+                    element    = null;\n+                    leftShrunk = node == node.parent.left;\n+                    child      = null;\n+                } else {\n+                    node       = (left != null) ? left.getLargest() : right.getSmallest();\n+                    element    = node.element;\n+                    leftShrunk = node == node.parent.left;\n+                    child      = (node.left != null) ? node.left : node.right;\n+                }\n+\n+                node = node.parent;\n+                if (leftShrunk) {\n+                    node.left = child;\n+                } else {\n+                    node.right = child;\n+                }\n+                if (child != null) {\n+                    child.parent = node;\n+                }\n+\n+                while (leftShrunk ? node.rebalanceLeftShrunk() : node.rebalanceRightShrunk()) {\n+                    if (node.parent == null) {\n+                        return;\n+                    }\n+                    leftShrunk = node == node.parent.left;\n+                    node = node.parent;\n+                }\n+\n+            }\n+        }\n+\n+        /** Re-balance the instance as left sub-tree has grown.\n+         * @return true if the parent tree should be reSkew.BALANCED too\n+         */\n+        private boolean rebalanceLeftGrown() {\n+            switch (skew) {\n+            case LEFT_HIGH:\n+                if (left.skew == Skew.LEFT_HIGH) {\n+                    rotateCW();\n+                    skew       = Skew.BALANCED;\n+                    right.skew = Skew.BALANCED;\n+                } else {\n+                    final Skew s = left.right.skew;\n+                    left.rotateCCW();\n+                    rotateCW();\n+                    switch(s) {\n+                    case LEFT_HIGH:\n+                        left.skew  = Skew.BALANCED;\n+                        right.skew = Skew.RIGHT_HIGH;\n+                        break;\n+                    case RIGHT_HIGH:\n+                        left.skew  = Skew.LEFT_HIGH;\n+                        right.skew = Skew.BALANCED;\n+                        break;\n+                    default:\n+                        left.skew  = Skew.BALANCED;\n+                        right.skew = Skew.BALANCED;\n+                    }\n+                    skew = Skew.BALANCED;\n+                }\n+                return false;\n+            case RIGHT_HIGH:\n+                skew = Skew.BALANCED;\n+                return false;\n+            default:\n+                skew = Skew.LEFT_HIGH;\n+                return true;\n+            }\n+        }\n+\n+        /** Re-balance the instance as right sub-tree has grown.\n+         * @return true if the parent tree should be reSkew.BALANCED too\n+         */\n+        private boolean rebalanceRightGrown() {\n+            switch (skew) {\n+            case LEFT_HIGH:\n+                skew = Skew.BALANCED;\n+                return false;\n+            case RIGHT_HIGH:\n+                if (right.skew == Skew.RIGHT_HIGH) {\n+                    rotateCCW();\n+                    skew      = Skew.BALANCED;\n+                    left.skew = Skew.BALANCED;\n+                } else {\n+                    final Skew s = right.left.skew;\n+                    right.rotateCW();\n+                    rotateCCW();\n+                    switch (s) {\n+                    case LEFT_HIGH:\n+                        left.skew  = Skew.BALANCED;\n+                        right.skew = Skew.RIGHT_HIGH;\n+                        break;\n+                    case RIGHT_HIGH:\n+                        left.skew  = Skew.LEFT_HIGH;\n+                        right.skew = Skew.BALANCED;\n+                        break;\n+                    default:\n+                        left.skew  = Skew.BALANCED;\n+                        right.skew = Skew.BALANCED;\n+                    }\n+                    skew = Skew.BALANCED;\n+                }\n+                return false;\n+            default:\n+                skew = Skew.RIGHT_HIGH;\n+                return true;\n+            }\n+        }\n+\n+        /** Re-balance the instance as left sub-tree has shrunk.\n+         * @return true if the parent tree should be reSkew.BALANCED too\n+         */\n+        private boolean rebalanceLeftShrunk() {\n+            switch (skew) {\n+            case LEFT_HIGH:\n+                skew = Skew.BALANCED;\n+                return true;\n+            case RIGHT_HIGH:\n+                if (right.skew == Skew.RIGHT_HIGH) {\n+                    rotateCCW();\n+                    skew      = Skew.BALANCED;\n+                    left.skew = Skew.BALANCED;\n+                    return true;\n+                } else if (right.skew == Skew.BALANCED) {\n+                    rotateCCW();\n+                    skew      = Skew.LEFT_HIGH;\n+                    left.skew = Skew.RIGHT_HIGH;\n+                    return false;\n+                } else {\n+                    final Skew s = right.left.skew;\n+                    right.rotateCW();\n+                    rotateCCW();\n+                    switch (s) {\n+                    case LEFT_HIGH:\n+                        left.skew  = Skew.BALANCED;\n+                        right.skew = Skew.RIGHT_HIGH;\n+                        break;\n+                    case RIGHT_HIGH:\n+                        left.skew  = Skew.LEFT_HIGH;\n+                        right.skew = Skew.BALANCED;\n+                        break;\n+                    default:\n+                        left.skew  = Skew.BALANCED;\n+                        right.skew = Skew.BALANCED;\n+                    }\n+                    skew = Skew.BALANCED;\n+                    return true;\n+                }\n+            default:\n+                skew = Skew.RIGHT_HIGH;\n+                return false;\n+            }\n+        }\n+\n+        /** Re-balance the instance as right sub-tree has shrunk.\n+         * @return true if the parent tree should be reSkew.BALANCED too\n+         */\n+        private boolean rebalanceRightShrunk() {\n+            switch (skew) {\n+            case RIGHT_HIGH:\n+                skew = Skew.BALANCED;\n+                return true;\n+            case LEFT_HIGH:\n+                if (left.skew == Skew.LEFT_HIGH) {\n+                    rotateCW();\n+                    skew       = Skew.BALANCED;\n+                    right.skew = Skew.BALANCED;\n+                    return true;\n+                } else if (left.skew == Skew.BALANCED) {\n+                    rotateCW();\n+                    skew       = Skew.RIGHT_HIGH;\n+                    right.skew = Skew.LEFT_HIGH;\n+                    return false;\n+                } else {\n+                    final Skew s = left.right.skew;\n+                    left.rotateCCW();\n+                    rotateCW();\n+                    switch (s) {\n+                    case LEFT_HIGH:\n+                        left.skew  = Skew.BALANCED;\n+                        right.skew = Skew.RIGHT_HIGH;\n+                        break;\n+                    case RIGHT_HIGH:\n+                        left.skew  = Skew.LEFT_HIGH;\n+                        right.skew = Skew.BALANCED;\n+                        break;\n+                    default:\n+                        left.skew  = Skew.BALANCED;\n+                        right.skew = Skew.BALANCED;\n+                    }\n+                    skew = Skew.BALANCED;\n+                    return true;\n+                }\n+            default:\n+                skew = Skew.LEFT_HIGH;\n+                return false;\n+            }\n+        }\n+\n+        /** Perform a clockwise rotation rooted at the instance.\n+         * <p>The skew factor are not updated by this method, they\n+         * <em>must</em> be updated by the caller</p>\n+         */\n+        private void rotateCW() {\n+\n+            final T tmpElt       = element;\n+            element              = left.element;\n+            left.element         = tmpElt;\n+\n+            final Node tmpNode   = left;\n+            left                 = tmpNode.left;\n+            tmpNode.left         = tmpNode.right;\n+            tmpNode.right        = right;\n+            right                = tmpNode;\n+\n+            if (left != null) {\n+                left.parent = this;\n+            }\n+            if (right.right != null) {\n+                right.right.parent = right;\n+            }\n+\n+        }\n+\n+        /** Perform a counter-clockwise rotation rooted at the instance.\n+         * <p>The skew factor are not updated by this method, they\n+         * <em>must</em> be updated by the caller</p>\n+         */\n+        private void rotateCCW() {\n+\n+            final T tmpElt        = element;\n+            element               = right.element;\n+            right.element         = tmpElt;\n+\n+            final Node tmpNode    = right;\n+            right                 = tmpNode.right;\n+            tmpNode.right         = tmpNode.left;\n+            tmpNode.left          = left;\n+            left                  = tmpNode;\n+\n+            if (right != null) {\n+                right.parent = this;\n+            }\n+            if (left.left != null) {\n+                left.left.parent = left;\n+            }\n+\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/utilities/OrderedTuple.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.partitioning.utilities;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.util.FastMath;\n+\n+/** This class implements an ordering operation for T-uples.\n+\n+ * <p>Ordering is done by encoding all components of the T-uple into a\n+ * single scalar value and using this value as the sorting\n+ * key. Encoding is performed using the method invented by Georg\n+ * Cantor in 1877 when he proved it was possible to establish a\n+ * bijection between a line and a plane. The binary representations of\n+ * the components of the T-uple are mixed together to form a single\n+ * scalar. This means that the 2<sup>k</sup> bit of component 0 is\n+ * followed by the 2<sup>k</sup> bit of component 1, then by the\n+ * 2<sup>k</sup> bit of component 2 up to the 2<sup>k</sup> bit of\n+ * component {@code t}, which is followed by the 2<sup>k-1</sup>\n+ * bit of component 0, followed by the 2<sup>k-1</sup> bit of\n+ * component 1 ... The binary representations are extended as needed\n+ * to handle numbers with different scales and a suitable\n+ * 2<sup>p</sup> offset is added to the components in order to avoid\n+ * negative numbers (this offset is adjusted as needed during the\n+ * comparison operations).</p>\n+\n+ * <p>The more interesting property of the encoding method for our\n+ * purpose is that it allows to select all the points that are in a\n+ * given range. This is depicted in dimension 2 by the following\n+ * picure:</p>\n+\n+ * <img src=\"doc-files/OrderedTuple.png\" />\n+\n+ * <p>This picture shows a set of 100000 random 2-D pairs having their\n+ * first component between -50 and +150 and their second component\n+ * between -350 and +50. We wanted to extract all pairs having their\n+ * first component between +30 and +70 and their second component\n+ * between -120 and -30. We built the lower left point at coordinates\n+ * (30, -120) and the upper right point at coordinates (70, -30). All\n+ * points smaller than the lower left point are drawn in red and all\n+ * points larger than the upper right point are drawn in blue. The\n+ * green points are between the two limits. This picture shows that\n+ * all the desired points are selected, along with spurious points. In\n+ * this case, we get 15790 points, 4420 of which really belonging to\n+ * the desired rectangle. It is possible to extract very small\n+ * subsets. As an example extracting from the same 100000 points set\n+ * the points having their first component between +30 and +31 and\n+ * their second component between -91 and -90, we get a subset of 11\n+ * points, 2 of which really belonging to the desired rectangle.</p>\n+\n+ * <p>the previous selection technique can be applied in all\n+ * dimensions, still using two points to define the interval. The\n+ * first point will have all its components set to their lower bounds\n+ * while the second point will have all its components set to their\n+ * upper bounds.</p>\n+\n+ * <p>T-uples with negative infinite or positive infinite components\n+ * are sorted logically.</p>\n+\n+ * <p>Since the specification of the {@code Comparator} interface\n+ * allows only {@code ClassCastException} errors, some arbitrary\n+ * choices have been made to handle specific cases. The rationale for\n+ * these choices is to keep <em>regular</em> and consistent T-uples\n+ * together.</p>\n+ * <ul>\n+ * <li>instances with different dimensions are sorted according to\n+ * their dimension regardless of their components values</li>\n+ * <li>instances with {@code Double.NaN} components are sorted\n+ * after all other ones (even after instances with positive infinite\n+ * components</li>\n+ * <li>instances with both positive and negative infinite components\n+ * are considered as if they had {@code Double.NaN}\n+ * components</li>\n+ * </ul>\n+\n+ * @version $Revision$ $Date$\n+ */\n+public class OrderedTuple implements Comparable<OrderedTuple> {\n+\n+    /** Sign bit mask. */\n+    private static final long SIGN_MASK     = 0x8000000000000000L;\n+\n+    /** Exponent bits mask. */\n+    private static final long EXPONENT_MASK = 0x7ff0000000000000L;\n+\n+    /** Mantissa bits mask. */\n+    private static final long MANTISSA_MASK = 0x000fffffffffffffL;\n+\n+    /** Implicit MSB for normalized numbers. */\n+    private static final long IMPLICIT_ONE  = 0x0010000000000000L;\n+\n+    /** Double components of the T-uple. */\n+    private double[] components;\n+\n+    /** Offset scale. */\n+    private int offset;\n+\n+    /** Least Significant Bit scale. */\n+    private int lsb;\n+\n+    /** Ordering encoding of the double components. */\n+    private long[] encoding;\n+\n+    /** Positive infinity marker. */\n+    private boolean posInf;\n+\n+    /** Negative infinity marker. */\n+    private boolean negInf;\n+\n+    /** Not A Number marker. */\n+    private boolean nan;\n+\n+    /** Build an ordered T-uple from its components.\n+     * @param components double components of the T-uple\n+     */\n+    public OrderedTuple(final double ... components) {\n+        this.components = components.clone();\n+        int msb = Integer.MIN_VALUE;\n+        lsb     = Integer.MAX_VALUE;\n+        posInf  = false;\n+        negInf  = false;\n+        nan     = false;\n+        for (int i = 0; i < components.length; ++i) {\n+            if (Double.isInfinite(components[i])) {\n+                if (components[i] < 0) {\n+                    negInf = true;\n+                } else {\n+                    posInf = true;\n+                }\n+            } else if (Double.isNaN(components[i])) {\n+                nan = true;\n+            } else {\n+                final long b = Double.doubleToLongBits(components[i]);\n+                final long m = mantissa(b);\n+                if (m != 0) {\n+                    final int e = exponent(b);\n+                    msb = FastMath.max(msb, e + computeMSB(m));\n+                    lsb = FastMath.min(lsb, e + computeLSB(m));\n+                }\n+            }\n+        }\n+\n+        if (posInf && negInf) {\n+            // instance cannot be sorted logically\n+            posInf = false;\n+            negInf = false;\n+            nan    = true;\n+        }\n+\n+        if (lsb <= msb) {\n+            // encode the T-upple with the specified offset\n+            encode(msb + 16);\n+        } else {\n+            encoding = new long[] {\n+                0x0L\n+            };\n+        }\n+\n+    }\n+\n+    /** Encode the T-uple with a given offset.\n+     * @param minOffset minimal scale of the offset to add to all\n+     * components (must be greater than the MSBs of all components)\n+     */\n+    private void encode(final int minOffset) {\n+\n+        // choose an offset with some margins\n+        offset  = minOffset + 31;\n+        offset -= offset % 32;\n+\n+        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n+            // the components are all zeroes\n+            return;\n+        }\n+\n+        // allocate an integer array to encode the components (we use only\n+        // 63 bits per element because there is no unsigned long in Java)\n+        final int neededBits  = offset + 1 - lsb;\n+        final int neededLongs = (neededBits + 62) / 63;\n+        encoding = new long[components.length * neededLongs];\n+\n+        // mix the bits from all components\n+        int  eIndex = 0;\n+        int  shift  = 62;\n+        long word   = 0x0L;\n+        for (int k = offset; eIndex < encoding.length; --k) {\n+            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n+                if (getBit(vIndex, k) != 0) {\n+                    word |= 0x1L << shift;\n+                }\n+                if (shift-- == 0) {\n+                    encoding[eIndex++] = word;\n+                    word  = 0x0L;\n+                    shift = 62;\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    /** Compares this ordered T-uple with the specified object.\n+\n+     * <p>The ordering method is detailed in the general description of\n+     * the class. Its main property is to be consistent with distance:\n+     * geometrically close T-uples stay close to each other when stored\n+     * in a sorted collection using this comparison method.</p>\n+\n+     * <p>T-uples with negative infinite, positive infinite are sorted\n+     * logically.</p>\n+\n+     * <p>Some arbitrary choices have been made to handle specific\n+     * cases. The rationale for these choices is to keep\n+     * <em>normal</em> and consistent T-uples together.</p>\n+     * <ul>\n+     * <li>instances with different dimensions are sorted according to\n+     * their dimension regardless of their components values</li>\n+     * <li>instances with {@code Double.NaN} components are sorted\n+     * after all other ones (evan after instances with positive infinite\n+     * components</li>\n+     * <li>instances with both positive and negative infinite components\n+     * are considered as if they had {@code Double.NaN}\n+     * components</li>\n+     * </ul>\n+\n+     * @param ot T-uple to compare instance with\n+     * @return a negative integer if the instance is less than the\n+     * object, zero if they are equal, or a positive integer if the\n+     * instance is greater than the object\n+\n+     */\n+    public int compareTo(final OrderedTuple ot) {\n+        if (components.length == ot.components.length) {\n+            if (nan) {\n+                return +1;\n+            } else if (ot.nan) {\n+                return -1;\n+            } else if (negInf || ot.posInf) {\n+                return -1;\n+            } else if (posInf || ot.negInf) {\n+                return +1;\n+            } else {\n+\n+                if (offset < ot.offset) {\n+                    encode(ot.offset);\n+                } else if (offset > ot.offset) {\n+                    ot.encode(offset);\n+                }\n+\n+                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n+                for (int i = 0; i < limit; ++i) {\n+                    if (encoding[i] < ot.encoding[i]) {\n+                        return -1;\n+                    } else if (encoding[i] > ot.encoding[i]) {\n+                        return +1;\n+                    }\n+                }\n+\n+                if (encoding.length < ot.encoding.length) {\n+                    return -1;\n+                } else if (encoding.length > ot.encoding.length) {\n+                    return +1;\n+                } else {\n+                    return 0;\n+                }\n+\n+            }\n+        }\n+\n+        return components.length - ot.components.length;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean equals(final Object other) {\n+        if (this == other) {\n+            return true;\n+        } else if (other instanceof OrderedTuple) {\n+            return compareTo((OrderedTuple) other) == 0;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int hashCode() {\n+        return Arrays.hashCode(components)   ^\n+               ((Integer) offset).hashCode() ^\n+               ((Integer) lsb).hashCode()    ^\n+               ((Boolean) posInf).hashCode() ^\n+               ((Boolean) negInf).hashCode() ^\n+               ((Boolean) nan).hashCode();\n+    }\n+\n+    /** Get the components array.\n+     * @return array containing the T-uple components\n+     */\n+    public double[] getComponents() {\n+        return components.clone();\n+    }\n+\n+    /** Extract the sign from the bits of a double.\n+     * @param bits binary representation of the double\n+     * @return sign bit (zero if positive, non zero if negative)\n+     */\n+    private static long sign(final long bits) {\n+        return bits & SIGN_MASK;\n+    }\n+\n+    /** Extract the exponent from the bits of a double.\n+     * @param bits binary representation of the double\n+     * @return exponent\n+     */\n+    private static int exponent(final long bits) {\n+        return ((int) ((bits & EXPONENT_MASK) >> 52)) - 1075;\n+    }\n+\n+    /** Extract the mantissa from the bits of a double.\n+     * @param bits binary representation of the double\n+     * @return mantissa\n+     */\n+    private static long mantissa(final long bits) {\n+        return ((bits & EXPONENT_MASK) == 0) ?\n+               ((bits & MANTISSA_MASK) << 1) :          // subnormal number\n+               (IMPLICIT_ONE | (bits & MANTISSA_MASK)); // normal number\n+    }\n+\n+    /** Compute the most significant bit of a long.\n+     * @param l long from which the most significant bit is requested\n+     * @return scale of the most significant bit of {@code l},\n+     * or 0 if {@code l} is zero\n+     * @see #computeLSB\n+     */\n+    private static int computeMSB(final long l) {\n+\n+        long ll = l;\n+        long mask  = 0xffffffffL;\n+        int  scale = 32;\n+        int  msb   = 0;\n+\n+        while (scale != 0) {\n+            if ((ll & mask) != ll) {\n+                msb |= scale;\n+                ll = ll >> scale;\n+            }\n+            scale = scale >> 1;\n+            mask  = mask >> scale;\n+        }\n+\n+        return msb;\n+\n+    }\n+\n+    /** Compute the least significant bit of a long.\n+     * @param l long from which the least significant bit is requested\n+     * @return scale of the least significant bit of {@code l},\n+     * or 63 if {@code l} is zero\n+     * @see #computeMSB\n+     */\n+    private static int computeLSB(final long l) {\n+\n+        long ll = l;\n+        long mask  = 0xffffffff00000000L;\n+        int  scale = 32;\n+        int  lsb   = 0;\n+\n+        while (scale != 0) {\n+            if ((ll & mask) == ll) {\n+                lsb |= scale;\n+                ll = ll >> scale;\n+            }\n+            scale = scale >> 1;\n+            mask  = mask >> scale;\n+        }\n+\n+        return lsb;\n+\n+    }\n+\n+    /** Get a bit from the mantissa of a double.\n+     * @param i index of the component\n+     * @param k scale of the requested bit\n+     * @return the specified bit (either 0 or 1), after the offset has\n+     * been added to the double\n+     */\n+    private int getBit(final int i, final int k) {\n+        final long bits = Double.doubleToLongBits(components[i]);\n+        final int e = exponent(bits);\n+        if ((k < e) || (k > offset)) {\n+            return 0;\n+        } else if (k == offset) {\n+            return (sign(bits) == 0L) ? 1 : 0;\n+        } else if (k > (e + 52)) {\n+            return (sign(bits) == 0L) ? 0 : 1;\n+        } else {\n+            final long m = (sign(bits) == 0L) ? mantissa(bits) : -mantissa(bits);\n+            return (int) ((m >> (k - e)) & 0x1L);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/oneD/IntervalsSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.oneD;\n+\n+import java.util.List;\n+\n+import org.apache.commons.math.geometry.euclidean.oneD.Interval;\n+import org.apache.commons.math.geometry.euclidean.oneD.IntervalsSet;\n+import org.apache.commons.math.geometry.euclidean.oneD.Point1D;\n+import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class IntervalsSetTest {\n+\n+    @Test\n+    public void testInterval() {\n+        IntervalsSet set = new IntervalsSet(2.3, 5.7);\n+        Assert.assertEquals(3.4, set.getSize(), 1.0e-10);\n+        Assert.assertEquals(4.0, ((Point1D) set.getBarycenter()).getAbscissa(), 1.0e-10);\n+        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Point1D(2.3)));\n+        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Point1D(5.7)));\n+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Point1D(1.2)));\n+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Point1D(8.7)));\n+        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Point1D(3.0)));\n+        Assert.assertEquals(2.3, set.getInf(), 1.0e-10);\n+        Assert.assertEquals(5.7, set.getSup(), 1.0e-10);\n+    }\n+\n+    @Test\n+    public void testInfinite() {\n+        IntervalsSet set = new IntervalsSet(9.0, Double.POSITIVE_INFINITY);\n+        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Point1D(9.0)));\n+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Point1D(8.4)));\n+        for (double e = 1.0; e <= 6.0; e += 1.0) {\n+            Assert.assertEquals(Region.Location.INSIDE,\n+                                set.checkPoint(new Point1D(FastMath.pow(10.0, e))));\n+        }\n+        Assert.assertTrue(Double.isInfinite(set.getSize()));\n+        Assert.assertEquals(9.0, set.getInf(), 1.0e-10);\n+        Assert.assertTrue(Double.isInfinite(set.getSup()));\n+\n+        set = (IntervalsSet) set.getComplement();\n+        Assert.assertEquals(9.0, set.getSup(), 1.0e-10);\n+        Assert.assertTrue(Double.isInfinite(set.getInf()));\n+\n+    }\n+\n+    @Test\n+    public void testMultiple() {\n+        IntervalsSet set = (IntervalsSet)\n+        Region.intersection(Region.union(Region.difference(new IntervalsSet(1.0, 6.0),\n+                                                           new IntervalsSet(3.0, 5.0)),\n+                                                           new IntervalsSet(9.0, Double.POSITIVE_INFINITY)),\n+                                                           new IntervalsSet(Double.NEGATIVE_INFINITY, 11.0));\n+        Assert.assertEquals(5.0, set.getSize(), 1.0e-10);\n+        Assert.assertEquals(5.9, ((Point1D) set.getBarycenter()).getAbscissa(), 1.0e-10);\n+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Point1D(0.0)));\n+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Point1D(4.0)));\n+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Point1D(8.0)));\n+        Assert.assertEquals(Region.Location.OUTSIDE,  set.checkPoint(new Point1D(12.0)));\n+        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Point1D(1.2)));\n+        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Point1D(5.9)));\n+        Assert.assertEquals(Region.Location.INSIDE,   set.checkPoint(new Point1D(9.01)));\n+        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Point1D(5.0)));\n+        Assert.assertEquals(Region.Location.BOUNDARY, set.checkPoint(new Point1D(11.0)));\n+        Assert.assertEquals( 1.0, set.getInf(), 1.0e-10);\n+        Assert.assertEquals(11.0, set.getSup(), 1.0e-10);\n+\n+        List<Interval> list = set.asList();\n+        Assert.assertEquals(3, list.size());\n+        Assert.assertEquals( 1.0, list.get(0).getLower(), 1.0e-10);\n+        Assert.assertEquals( 3.0, list.get(0).getUpper(), 1.0e-10);\n+        Assert.assertEquals( 5.0, list.get(1).getLower(), 1.0e-10);\n+        Assert.assertEquals( 6.0, list.get(1).getUpper(), 1.0e-10);\n+        Assert.assertEquals( 9.0, list.get(2).getLower(), 1.0e-10);\n+        Assert.assertEquals(11.0, list.get(2).getUpper(), 1.0e-10);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/threeD/FrenchVector3DFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+import java.util.Locale;\n+\n+\n+public class FrenchVector3DFormatTest extends Vector3DFormatAbstractTest {\n+\n+    @Override\n+    protected char getDecimalCharacter() {\n+        return ',';\n+    }\n+\n+    @Override\n+    protected Locale getLocale() {\n+        return Locale.FRENCH;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/threeD/LineTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+import org.apache.commons.math.geometry.euclidean.threeD.Line;\n+import org.apache.commons.math.geometry.euclidean.threeD.Vector3D;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class LineTest {\n+\n+    @Test\n+    public void testContains() {\n+        Vector3D p1 = new Vector3D(0, 0, 1);\n+        Line l = new Line(p1, new Vector3D(0, 0, 1));\n+        Assert.assertTrue(l.contains(p1));\n+        Assert.assertTrue(l.contains(new Vector3D(1.0, p1, 0.3, l.getDirection())));\n+        Vector3D u = l.getDirection().orthogonal();\n+        Vector3D v = Vector3D.crossProduct(l.getDirection(), u);\n+        for (double alpha = 0; alpha < 2 * FastMath.PI; alpha += 0.3) {\n+            Assert.assertTrue(! l.contains(p1.add(new Vector3D(FastMath.cos(alpha), u,\n+                                                               FastMath.sin(alpha), v))));\n+        }\n+    }\n+\n+    @Test\n+    public void testSimilar() {\n+        Vector3D p1  = new Vector3D (1.2, 3.4, -5.8);\n+        Vector3D p2  = new Vector3D (3.4, -5.8, 1.2);\n+        Line     lA  = new Line(p1, p2.subtract(p1));\n+        Line     lB  = new Line(p2, p1.subtract(p2));\n+        Assert.assertTrue(lA.isSimilarTo(lB));\n+        Assert.assertTrue(! lA.isSimilarTo(new Line(p1, lA.getDirection().orthogonal())));\n+    }\n+\n+    @Test\n+    public void testPointDistance() {\n+        Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 1, 1));\n+        Assert.assertEquals(FastMath.sqrt(3.0 / 2.0), l.distance(new Vector3D(1, 0, 1)), 1.0e-10);\n+        Assert.assertEquals(0, l.distance(new Vector3D(0, -4, -4)), 1.0e-10);\n+    }\n+\n+    @Test\n+    public void testLineDistance() {\n+        Line l = new Line(new Vector3D(0, 1, 1), new Vector3D(0, 1, 1));\n+        Assert.assertEquals(1.0,\n+                            l.distance(new Line(new Vector3D(1, 0, 1), Vector3D.PLUS_K)),\n+                            1.0e-10);\n+        Assert.assertEquals(0.5,\n+                            l.distance(new Line(new Vector3D(-0.5, 0, 0), new Vector3D(0, -1, -1))),\n+                            1.0e-10);\n+        Assert.assertEquals(0.0,\n+                            l.distance(l),\n+                            1.0e-10);\n+        Assert.assertEquals(0.0,\n+                            l.distance(new Line(new Vector3D(0, -4, -4), new Vector3D(0, -1, -1))),\n+                            1.0e-10);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/threeD/PlaneTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+import org.apache.commons.math.geometry.euclidean.threeD.Line;\n+import org.apache.commons.math.geometry.euclidean.threeD.Plane;\n+import org.apache.commons.math.geometry.euclidean.threeD.Point3D;\n+import org.apache.commons.math.geometry.euclidean.threeD.Rotation;\n+import org.apache.commons.math.geometry.euclidean.threeD.Vector3D;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class PlaneTest {\n+\n+    @Test\n+    public void testContains() {\n+        Plane p = new Plane(new Vector3D(0, 0, 1), new Vector3D(0, 0, 1));\n+        Assert.assertTrue(p.contains(new Point3D(0, 0, 1)));\n+        Assert.assertTrue(p.contains(new Point3D(17, -32, 1)));\n+        Assert.assertTrue(! p.contains(new Point3D(17, -32, 1.001)));\n+    }\n+\n+    @Test\n+    public void testOffset() {\n+        Vector3D p1 = new Vector3D(1, 1, 1);\n+        Plane p = new Plane(p1, new Vector3D(0.2, 0, 0));\n+        Assert.assertEquals(-5.0, p.getOffset(new Point3D(-4, 0, 0)), 1.0e-10);\n+        Assert.assertEquals(+5.0, p.getOffset(new Point3D(6, 10, -12)), 1.0e-10);\n+        Assert.assertEquals(0.3,\n+                            p.getOffset(new Point3D(1.0, p1, 0.3, p.getNormal())),\n+                            1.0e-10);\n+        Assert.assertEquals(-0.3,\n+                            p.getOffset(new Point3D(1.0, p1, -0.3, p.getNormal())),\n+                            1.0e-10);\n+    }\n+\n+    @Test\n+    public void testPoint() {\n+        Plane p = new Plane(new Vector3D(2, -3, 1), new Vector3D(1, 4, 9));\n+        Assert.assertTrue(p.contains(p.getOrigin()));\n+    }\n+\n+    @Test\n+    public void testThreePoints() {\n+        Point3D p1 = new Point3D(1.2, 3.4, -5.8);\n+        Point3D p2 = new Point3D(3.4, -5.8, 1.2);\n+        Point3D p3 = new Point3D(-2.0, 4.3, 0.7);\n+        Plane    p  = new Plane(p1, p2, p3);\n+        Assert.assertTrue(p.contains(p1));\n+        Assert.assertTrue(p.contains(p2));\n+        Assert.assertTrue(p.contains(p3));\n+    }\n+\n+    @Test\n+    public void testRotate() {\n+        Point3D p1 = new Point3D(1.2, 3.4, -5.8);\n+        Point3D p2 = new Point3D(3.4, -5.8, 1.2);\n+        Point3D p3 = new Point3D(-2.0, 4.3, 0.7);\n+        Plane    p  = new Plane(p1, p2, p3);\n+        Vector3D oldNormal = p.getNormal();\n+\n+        p = p.rotate(p2, new Rotation(p2.subtract(p1), 1.7));\n+        Assert.assertTrue(p.contains(p1));\n+        Assert.assertTrue(p.contains(p2));\n+        Assert.assertTrue(! p.contains(p3));\n+\n+        p = p.rotate(p2, new Rotation(oldNormal, 0.1));\n+        Assert.assertTrue(! p.contains(p1));\n+        Assert.assertTrue(p.contains(p2));\n+        Assert.assertTrue(! p.contains(p3));\n+\n+        p = p.rotate(p1, new Rotation(oldNormal, 0.1));\n+        Assert.assertTrue(! p.contains(p1));\n+        Assert.assertTrue(! p.contains(p2));\n+        Assert.assertTrue(! p.contains(p3));\n+\n+    }\n+\n+    @Test\n+    public void testTranslate() {\n+        Point3D p1 = new Point3D(1.2, 3.4, -5.8);\n+        Point3D p2 = new Point3D(3.4, -5.8, 1.2);\n+        Point3D p3 = new Point3D(-2.0, 4.3, 0.7);\n+        Plane    p  = new Plane(p1, p2, p3);\n+\n+        p = p.translate(new Vector3D(2.0, p.getU(), -1.5, p.getV()));\n+        Assert.assertTrue(p.contains(p1));\n+        Assert.assertTrue(p.contains(p2));\n+        Assert.assertTrue(p.contains(p3));\n+\n+        p = p.translate(new Vector3D(-1.2, p.getNormal()));\n+        Assert.assertTrue(! p.contains(p1));\n+        Assert.assertTrue(! p.contains(p2));\n+        Assert.assertTrue(! p.contains(p3));\n+\n+        p = p.translate(new Vector3D(+1.2, p.getNormal()));\n+        Assert.assertTrue(p.contains(p1));\n+        Assert.assertTrue(p.contains(p2));\n+        Assert.assertTrue(p.contains(p3));\n+\n+    }\n+\n+    @Test\n+    public void testIntersection() {\n+        Plane p = new Plane(new Vector3D(1, 2, 3), new Vector3D(-4, 1, -5));\n+        Line  l = new Line(new Vector3D(0.2, -3.5, 0.7), new Vector3D(1, 1, -1));\n+        Point3D point = p.intersection(l);\n+        Assert.assertTrue(p.contains(point));\n+        Assert.assertTrue(l.contains(point));\n+        Assert.assertNull(p.intersection(new Line(new Vector3D(10, 10, 10),\n+                                                  p.getNormal().orthogonal())));\n+    }\n+\n+    @Test\n+    public void testIntersection2() {\n+        Vector3D p1  = new Vector3D (1.2, 3.4, -5.8);\n+        Vector3D p2  = new Vector3D (3.4, -5.8, 1.2);\n+        Plane    pA  = new Plane(p1, p2, new Vector3D (-2.0, 4.3, 0.7));\n+        Plane    pB  = new Plane(p1, new Vector3D (11.4, -3.8, 5.1), p2);\n+        Line     l   = (Line) pA.intersection(pB);\n+        Assert.assertTrue(l.contains(p1));\n+        Assert.assertTrue(l.contains(p2));\n+        Assert.assertNull(pA.intersection(pA));\n+    }\n+\n+    @Test\n+    public void testIntersection3() {\n+        Vector3D reference = new Vector3D (1.2, 3.4, -5.8);\n+        Plane p1 = new Plane(reference, new Vector3D(1, 3, 3));\n+        Plane p2 = new Plane(reference, new Vector3D(-2, 4, 0));\n+        Plane p3 = new Plane(reference, new Vector3D(7, 0, -4));\n+        Vector3D p = Plane.intersection(p1, p2, p3);\n+        Assert.assertEquals(reference.getX(), p.getX(), 1.0e-10);\n+        Assert.assertEquals(reference.getY(), p.getY(), 1.0e-10);\n+        Assert.assertEquals(reference.getZ(), p.getZ(), 1.0e-10);\n+    }\n+\n+    @Test\n+    public void testSimilar() {\n+        Vector3D p1  = new Vector3D (1.2, 3.4, -5.8);\n+        Vector3D p2  = new Vector3D (3.4, -5.8, 1.2);\n+        Vector3D p3  = new Vector3D (-2.0, 4.3, 0.7);\n+        Plane    pA  = new Plane(p1, p2, p3);\n+        Plane    pB  = new Plane(p1, new Vector3D (11.4, -3.8, 5.1), p2);\n+        Assert.assertTrue(! pA.isSimilarTo(pB));\n+        Assert.assertTrue(pA.isSimilarTo(pA));\n+        Assert.assertTrue(pA.isSimilarTo(new Plane(p1, p3, p2)));\n+        Vector3D shift = new Vector3D(0.3, pA.getNormal());\n+        Assert.assertTrue(! pA.isSimilarTo(new Plane(p1.add(shift),\n+                                                     p3.add(shift),\n+                                                     p2.add(shift))));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/threeD/PolyhedronsSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.geometry.euclidean.threeD.Plane;\n+import org.apache.commons.math.geometry.euclidean.threeD.Point3D;\n+import org.apache.commons.math.geometry.euclidean.threeD.PolyhedronsSet;\n+import org.apache.commons.math.geometry.euclidean.threeD.Rotation;\n+import org.apache.commons.math.geometry.euclidean.threeD.Vector3D;\n+import org.apache.commons.math.geometry.euclidean.twoD.Point2D;\n+import org.apache.commons.math.geometry.euclidean.twoD.PolygonsSet;\n+import org.apache.commons.math.geometry.partitioning.BSPTree;\n+import org.apache.commons.math.geometry.partitioning.BSPTreeVisitor;\n+import org.apache.commons.math.geometry.partitioning.Hyperplane;\n+import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class PolyhedronsSetTest {\n+\n+    @Test\n+    public void testBox() {\n+        PolyhedronsSet tree = new PolyhedronsSet(0, 1, 0, 1, 0, 1);\n+        Assert.assertEquals(1.0, tree.getSize(), 1.0e-10);\n+        Assert.assertEquals(6.0, tree.getBoundarySize(), 1.0e-10);\n+        Vector3D barycenter = (Vector3D) tree.getBarycenter();\n+        Assert.assertEquals(0.5, barycenter.getX(), 1.0e-10);\n+        Assert.assertEquals(0.5, barycenter.getY(), 1.0e-10);\n+        Assert.assertEquals(0.5, barycenter.getZ(), 1.0e-10);\n+        for (double x = -0.25; x < 1.25; x += 0.1) {\n+            boolean xOK = (x >= 0.0) && (x <= 1.0);\n+            for (double y = -0.25; y < 1.25; y += 0.1) {\n+                boolean yOK = (y >= 0.0) && (y <= 1.0);\n+                for (double z = -0.25; z < 1.25; z += 0.1) {\n+                    boolean zOK = (z >= 0.0) && (z <= 1.0);\n+                    Region.Location expected =\n+                        (xOK && yOK && zOK) ? Region.Location.INSIDE : Region.Location.OUTSIDE;\n+                    Assert.assertEquals(expected, tree.checkPoint(new Point3D(x, y, z)));\n+                }\n+            }\n+        }\n+        checkPoints(Region.Location.BOUNDARY, tree, new Point3D[] {\n+            new Point3D(0.0, 0.5, 0.5),\n+            new Point3D(1.0, 0.5, 0.5),\n+            new Point3D(0.5, 0.0, 0.5),\n+            new Point3D(0.5, 1.0, 0.5),\n+            new Point3D(0.5, 0.5, 0.0),\n+            new Point3D(0.5, 0.5, 1.0)\n+        });\n+        checkPoints(Region.Location.OUTSIDE, tree, new Point3D[] {\n+            new Point3D(0.0, 1.2, 1.2),\n+            new Point3D(1.0, 1.2, 1.2),\n+            new Point3D(1.2, 0.0, 1.2),\n+            new Point3D(1.2, 1.0, 1.2),\n+            new Point3D(1.2, 1.2, 0.0),\n+            new Point3D(1.2, 1.2, 1.0)\n+        });\n+    }\n+\n+    @Test\n+    public void testTetrahedron() {\n+        Point3D vertex1 = new Point3D(1, 2, 3);\n+        Point3D vertex2 = new Point3D(2, 2, 4);\n+        Point3D vertex3 = new Point3D(2, 3, 3);\n+        Point3D vertex4 = new Point3D(1, 3, 4);\n+        PolyhedronsSet tree =\n+            (PolyhedronsSet) Region.buildConvex(Arrays.asList(new Hyperplane[] {\n+                new Plane(vertex3, vertex2, vertex1),\n+                new Plane(vertex2, vertex3, vertex4),\n+                new Plane(vertex4, vertex3, vertex1),\n+                new Plane(vertex1, vertex2, vertex4)\n+            }));\n+        Assert.assertEquals(1.0 / 3.0, tree.getSize(), 1.0e-10);\n+        Assert.assertEquals(2.0 * FastMath.sqrt(3.0), tree.getBoundarySize(), 1.0e-10);\n+        Vector3D barycenter = (Vector3D) tree.getBarycenter();\n+        Assert.assertEquals(1.5, barycenter.getX(), 1.0e-10);\n+        Assert.assertEquals(2.5, barycenter.getY(), 1.0e-10);\n+        Assert.assertEquals(3.5, barycenter.getZ(), 1.0e-10);\n+        double third = 1.0 / 3.0;\n+        checkPoints(Region.Location.BOUNDARY, tree, new Point3D[] {\n+            vertex1, vertex2, vertex3, vertex4,\n+            new Point3D(third, vertex1, third, vertex2, third, vertex3),\n+            new Point3D(third, vertex2, third, vertex3, third, vertex4),\n+            new Point3D(third, vertex3, third, vertex4, third, vertex1),\n+            new Point3D(third, vertex4, third, vertex1, third, vertex2)\n+        });\n+        checkPoints(Region.Location.OUTSIDE, tree, new Point3D[] {\n+            new Point3D(1, 2, 4),\n+            new Point3D(2, 2, 3),\n+            new Point3D(2, 3, 4),\n+            new Point3D(1, 3, 3)\n+        });\n+    }\n+\n+    @Test\n+    public void testIsometry() {\n+        Vector3D vertex1 = new Vector3D(1.1, 2.2, 3.3);\n+        Vector3D vertex2 = new Vector3D(2.0, 2.4, 4.2);\n+        Vector3D vertex3 = new Vector3D(2.8, 3.3, 3.7);\n+        Vector3D vertex4 = new Vector3D(1.0, 3.6, 4.5);\n+        PolyhedronsSet tree =\n+            (PolyhedronsSet) Region.buildConvex(Arrays.asList(new Hyperplane[] {\n+                new Plane(vertex3, vertex2, vertex1),\n+                new Plane(vertex2, vertex3, vertex4),\n+                new Plane(vertex4, vertex3, vertex1),\n+                new Plane(vertex1, vertex2, vertex4)\n+            }));\n+        Vector3D barycenter = (Vector3D) tree.getBarycenter();\n+        Vector3D s = new Vector3D(10.2, 4.3, -6.7);\n+        Vector3D c = new Vector3D(-0.2, 2.1, -3.2);\n+        Rotation r = new Rotation(new Vector3D(6.2, -4.4, 2.1), 0.12);\n+\n+        tree = tree.rotate(c, r).translate(s);\n+\n+        Vector3D newB =\n+            new Vector3D(1.0, s,\n+                         1.0, c,\n+                         1.0, r.applyTo(barycenter.subtract(c)));\n+        Assert.assertEquals(0.0,\n+                            newB.subtract((Vector3D) tree.getBarycenter()).getNorm(),\n+                            1.0e-10);\n+\n+        final Vector3D[] expectedV = new Vector3D[] {\n+            new Vector3D(1.0, s,\n+                         1.0, c,\n+                         1.0, r.applyTo(vertex1.subtract(c))),\n+                         new Vector3D(1.0, s,\n+                                      1.0, c,\n+                                      1.0, r.applyTo(vertex2.subtract(c))),\n+                                      new Vector3D(1.0, s,\n+                                                   1.0, c,\n+                                                   1.0, r.applyTo(vertex3.subtract(c))),\n+                                                   new Vector3D(1.0, s,\n+                                                                1.0, c,\n+                                                                1.0, r.applyTo(vertex4.subtract(c)))\n+        };\n+        tree.getTree(true).visit(new BSPTreeVisitor() {\n+\n+            public Order visitOrder(BSPTree node) {\n+                return Order.MINUS_SUB_PLUS;\n+            }\n+\n+            public void visitInternalNode(BSPTree node) {\n+                Region.BoundaryAttribute attribute =\n+                    (Region.BoundaryAttribute) node.getAttribute();\n+                if (attribute.getPlusOutside() != null) {\n+                    checkFacet(attribute.getPlusOutside());\n+                }\n+                if (attribute.getPlusInside() != null) {\n+                    checkFacet(attribute.getPlusInside());\n+                }\n+            }\n+\n+            public void visitLeafNode(BSPTree node) {\n+            }\n+\n+            private void checkFacet(SubHyperplane facet) {\n+                Plane plane = (Plane) facet.getHyperplane();\n+                Point2D[][] vertices =\n+                    ((PolygonsSet) facet.getRemainingRegion()).getVertices();\n+                Assert.assertEquals(1, vertices.length);\n+                for (int i = 0; i < vertices[0].length; ++i) {\n+                    Vector3D v = (Vector3D) plane.toSpace(vertices[0][i]);\n+                    double d = Double.POSITIVE_INFINITY;\n+                    for (int k = 0; k < expectedV.length; ++k) {\n+                        d = FastMath.min(d, v.subtract(expectedV[k]).getNorm());\n+                    }\n+                    Assert.assertEquals(0, d, 1.0e-10);\n+                }\n+            }\n+\n+        });\n+\n+    }\n+\n+    @Test\n+    public void testBuildBox() {\n+        double x = 1.0;\n+        double y = 2.0;\n+        double z = 3.0;\n+        double w = 0.1;\n+        double l = 1.0;\n+        PolyhedronsSet tree =\n+            new PolyhedronsSet(x - l, x + l, y - w, y + w, z - w, z + w);\n+        Vector3D barycenter = (Vector3D) tree.getBarycenter();\n+        Assert.assertEquals(x, barycenter.getX(), 1.0e-10);\n+        Assert.assertEquals(y, barycenter.getY(), 1.0e-10);\n+        Assert.assertEquals(z, barycenter.getZ(), 1.0e-10);\n+        Assert.assertEquals(8 * l * w * w, tree.getSize(), 1.0e-10);\n+        Assert.assertEquals(8 * w * (2 * l + w), tree.getBoundarySize(), 1.0e-10);\n+    }\n+\n+    @Test\n+    public void testCross() {\n+\n+        double x = 1.0;\n+        double y = 2.0;\n+        double z = 3.0;\n+        double w = 0.1;\n+        double l = 1.0;\n+        PolyhedronsSet xBeam =\n+            new PolyhedronsSet(x - l, x + l, y - w, y + w, z - w, z + w);\n+        PolyhedronsSet yBeam =\n+            new PolyhedronsSet(x - w, x + w, y - l, y + l, z - w, z + w);\n+        PolyhedronsSet zBeam =\n+            new PolyhedronsSet(x - w, x + w, y - w, y + w, z - l, z + l);\n+        PolyhedronsSet tree =\n+            (PolyhedronsSet) Region.union(xBeam, Region.union(yBeam, zBeam));\n+        Vector3D barycenter = (Vector3D) tree.getBarycenter();\n+\n+        Assert.assertEquals(x, barycenter.getX(), 1.0e-10);\n+        Assert.assertEquals(y, barycenter.getY(), 1.0e-10);\n+        Assert.assertEquals(z, barycenter.getZ(), 1.0e-10);\n+        Assert.assertEquals(8 * w * w * (3 * l - 2 * w), tree.getSize(), 1.0e-10);\n+        Assert.assertEquals(24 * w * (2 * l - w), tree.getBoundarySize(), 1.0e-10);\n+\n+    }\n+\n+    private void checkPoints(Region.Location expected, PolyhedronsSet tree, Point3D[] points) {\n+        for (int i = 0; i < points.length; ++i) {\n+            Assert.assertEquals(expected, tree.checkPoint(points[i]));\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/threeD/RotationOrderTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+import java.lang.reflect.Field;\n+\n+import org.apache.commons.math.geometry.euclidean.threeD.RotationOrder;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+public class RotationOrderTest {\n+\n+  @Test\n+  public void testName() {\n+\n+    RotationOrder[] orders = {\n+      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,\n+      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX,\n+      RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,\n+      RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ\n+    };\n+\n+    for (int i = 0; i < orders.length; ++i) {\n+      Assert.assertEquals(getFieldName(orders[i]), orders[i].toString());\n+    }\n+\n+  }\n+\n+  private String getFieldName(RotationOrder order) {\n+    try {\n+      Field[] fields = RotationOrder.class.getFields();\n+      for (int i = 0; i < fields.length; ++i) {\n+        if (fields[i].get(null) == order) {\n+          return fields[i].getName();\n+        }\n+      }\n+    } catch (IllegalAccessException iae) {\n+      // ignored\n+    }\n+    return \"unknown\";\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/threeD/RotationTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+import org.apache.commons.math.geometry.euclidean.threeD.CardanEulerSingularityException;\n+import org.apache.commons.math.geometry.euclidean.threeD.NotARotationMatrixException;\n+import org.apache.commons.math.geometry.euclidean.threeD.Rotation;\n+import org.apache.commons.math.geometry.euclidean.threeD.RotationOrder;\n+import org.apache.commons.math.geometry.euclidean.threeD.Vector3D;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+public class RotationTest {\n+\n+  @Test\n+  public void testIdentity() {\n+\n+    Rotation r = Rotation.IDENTITY;\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);\n+    checkAngle(r.getAngle(), 0);\n+\n+    r = new Rotation(-1, 0, 0, 0, false);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);\n+    checkAngle(r.getAngle(), 0);\n+\n+    r = new Rotation(42, 0, 0, 0, true);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);\n+    checkAngle(r.getAngle(), 0);\n+\n+  }\n+\n+  @Test\n+  public void testAxisAngle() {\n+\n+    Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * FastMath.PI / 3);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_J);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_K);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_I);\n+    double s = 1 / FastMath.sqrt(3);\n+    checkVector(r.getAxis(), new Vector3D(s, s, s));\n+    checkAngle(r.getAngle(), 2 * FastMath.PI / 3);\n+\n+    try {\n+      new Rotation(new Vector3D(0, 0, 0), 2 * FastMath.PI / 3);\n+      Assert.fail(\"an exception should have been thrown\");\n+    } catch (ArithmeticException e) {\n+    }\n+\n+    r = new Rotation(Vector3D.PLUS_K, 1.5 * FastMath.PI);\n+    checkVector(r.getAxis(), new Vector3D(0, 0, -1));\n+    checkAngle(r.getAngle(), 0.5 * FastMath.PI);\n+\n+    r = new Rotation(Vector3D.PLUS_J, FastMath.PI);\n+    checkVector(r.getAxis(), Vector3D.PLUS_J);\n+    checkAngle(r.getAngle(), FastMath.PI);\n+\n+    checkVector(Rotation.IDENTITY.getAxis(), Vector3D.PLUS_I);\n+\n+  }\n+\n+  @Test\n+  public void testRevert() {\n+    Rotation r = new Rotation(0.001, 0.36, 0.48, 0.8, true);\n+    Rotation reverted = r.revert();\n+    checkRotation(r.applyTo(reverted), 1, 0, 0, 0);\n+    checkRotation(reverted.applyTo(r), 1, 0, 0, 0);\n+    Assert.assertEquals(r.getAngle(), reverted.getAngle(), 1.0e-12);\n+    Assert.assertEquals(-1, Vector3D.dotProduct(r.getAxis(), reverted.getAxis()), 1.0e-12);\n+  }\n+\n+  @Test\n+  public void testVectorOnePair() {\n+\n+    Vector3D u = new Vector3D(3, 2, 1);\n+    Vector3D v = new Vector3D(-4, 2, 2);\n+    Rotation r = new Rotation(u, v);\n+    checkVector(r.applyTo(u.scalarMultiply(v.getNorm())), v.scalarMultiply(u.getNorm()));\n+\n+    checkAngle(new Rotation(u, u.negate()).getAngle(), FastMath.PI);\n+\n+    try {\n+        new Rotation(u, Vector3D.ZERO);\n+        Assert.fail(\"an exception should have been thrown\");\n+    } catch (IllegalArgumentException e) {\n+        // expected behavior\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testVectorTwoPairs() {\n+\n+    Vector3D u1 = new Vector3D(3, 0, 0);\n+    Vector3D u2 = new Vector3D(0, 5, 0);\n+    Vector3D v1 = new Vector3D(0, 0, 2);\n+    Vector3D v2 = new Vector3D(-2, 0, 2);\n+    Rotation r = new Rotation(u1, u2, v1, v2);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.MINUS_I);\n+\n+    r = new Rotation(u1, u2, u1.negate(), u2.negate());\n+    Vector3D axis = r.getAxis();\n+    if (Vector3D.dotProduct(axis, Vector3D.PLUS_K) > 0) {\n+      checkVector(axis, Vector3D.PLUS_K);\n+    } else {\n+      checkVector(axis, Vector3D.MINUS_K);\n+    }\n+    checkAngle(r.getAngle(), FastMath.PI);\n+\n+    double sqrt = FastMath.sqrt(2) / 2;\n+    r = new Rotation(Vector3D.PLUS_I,  Vector3D.PLUS_J,\n+                     new Vector3D(0.5, 0.5,  sqrt),\n+                     new Vector3D(0.5, 0.5, -sqrt));\n+    checkRotation(r, sqrt, 0.5, 0.5, 0);\n+\n+    r = new Rotation(u1, u2, u1, Vector3D.crossProduct(u1, u2));\n+    checkRotation(r, sqrt, -sqrt, 0, 0);\n+\n+    checkRotation(new Rotation(u1, u2, u1, u2), 1, 0, 0, 0);\n+\n+    try {\n+        new Rotation(u1, u2, Vector3D.ZERO, v2);\n+        Assert.fail(\"an exception should have been thrown\");\n+    } catch (IllegalArgumentException e) {\n+      // expected behavior\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testMatrix()\n+    throws NotARotationMatrixException {\n+\n+    try {\n+      new Rotation(new double[][] {\n+                     { 0.0, 1.0, 0.0 },\n+                     { 1.0, 0.0, 0.0 }\n+                   }, 1.0e-7);\n+      Assert.fail(\"Expecting NotARotationMatrixException\");\n+    } catch (NotARotationMatrixException nrme) {\n+      // expected behavior\n+    }\n+\n+    try {\n+      new Rotation(new double[][] {\n+                     {  0.445888,  0.797184, -0.407040 },\n+                     {  0.821760, -0.184320,  0.539200 },\n+                     { -0.354816,  0.574912,  0.737280 }\n+                   }, 1.0e-7);\n+      Assert.fail(\"Expecting NotARotationMatrixException\");\n+    } catch (NotARotationMatrixException nrme) {\n+      // expected behavior\n+    }\n+\n+    try {\n+        new Rotation(new double[][] {\n+                       {  0.4,  0.8, -0.4 },\n+                       { -0.4,  0.6,  0.7 },\n+                       {  0.8, -0.2,  0.5 }\n+                     }, 1.0e-15);\n+        Assert.fail(\"Expecting NotARotationMatrixException\");\n+      } catch (NotARotationMatrixException nrme) {\n+        // expected behavior\n+      }\n+\n+    checkRotation(new Rotation(new double[][] {\n+                                 {  0.445888,  0.797184, -0.407040 },\n+                                 { -0.354816,  0.574912,  0.737280 },\n+                                 {  0.821760, -0.184320,  0.539200 }\n+                               }, 1.0e-10),\n+                  0.8, 0.288, 0.384, 0.36);\n+\n+    checkRotation(new Rotation(new double[][] {\n+                                 {  0.539200,  0.737280,  0.407040 },\n+                                 {  0.184320, -0.574912,  0.797184 },\n+                                 {  0.821760, -0.354816, -0.445888 }\n+                              }, 1.0e-10),\n+                  0.36, 0.8, 0.288, 0.384);\n+\n+    checkRotation(new Rotation(new double[][] {\n+                                 { -0.445888,  0.797184, -0.407040 },\n+                                 {  0.354816,  0.574912,  0.737280 },\n+                                 {  0.821760,  0.184320, -0.539200 }\n+                               }, 1.0e-10),\n+                  0.384, 0.36, 0.8, 0.288);\n+\n+    checkRotation(new Rotation(new double[][] {\n+                                 { -0.539200,  0.737280,  0.407040 },\n+                                 { -0.184320, -0.574912,  0.797184 },\n+                                 {  0.821760,  0.354816,  0.445888 }\n+                               }, 1.0e-10),\n+                  0.288, 0.384, 0.36, 0.8);\n+\n+    double[][] m1 = { { 0.0, 1.0, 0.0 },\n+                      { 0.0, 0.0, 1.0 },\n+                      { 1.0, 0.0, 0.0 } };\n+    Rotation r = new Rotation(m1, 1.0e-7);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_I);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_J);\n+\n+    double[][] m2 = { { 0.83203, -0.55012, -0.07139 },\n+                      { 0.48293,  0.78164, -0.39474 },\n+                      { 0.27296,  0.29396,  0.91602 } };\n+    r = new Rotation(m2, 1.0e-12);\n+\n+    double[][] m3 = r.getMatrix();\n+    double d00 = m2[0][0] - m3[0][0];\n+    double d01 = m2[0][1] - m3[0][1];\n+    double d02 = m2[0][2] - m3[0][2];\n+    double d10 = m2[1][0] - m3[1][0];\n+    double d11 = m2[1][1] - m3[1][1];\n+    double d12 = m2[1][2] - m3[1][2];\n+    double d20 = m2[2][0] - m3[2][0];\n+    double d21 = m2[2][1] - m3[2][1];\n+    double d22 = m2[2][2] - m3[2][2];\n+\n+    Assert.assertTrue(FastMath.abs(d00) < 6.0e-6);\n+    Assert.assertTrue(FastMath.abs(d01) < 6.0e-6);\n+    Assert.assertTrue(FastMath.abs(d02) < 6.0e-6);\n+    Assert.assertTrue(FastMath.abs(d10) < 6.0e-6);\n+    Assert.assertTrue(FastMath.abs(d11) < 6.0e-6);\n+    Assert.assertTrue(FastMath.abs(d12) < 6.0e-6);\n+    Assert.assertTrue(FastMath.abs(d20) < 6.0e-6);\n+    Assert.assertTrue(FastMath.abs(d21) < 6.0e-6);\n+    Assert.assertTrue(FastMath.abs(d22) < 6.0e-6);\n+\n+    Assert.assertTrue(FastMath.abs(d00) > 4.0e-7);\n+    Assert.assertTrue(FastMath.abs(d01) > 4.0e-7);\n+    Assert.assertTrue(FastMath.abs(d02) > 4.0e-7);\n+    Assert.assertTrue(FastMath.abs(d10) > 4.0e-7);\n+    Assert.assertTrue(FastMath.abs(d11) > 4.0e-7);\n+    Assert.assertTrue(FastMath.abs(d12) > 4.0e-7);\n+    Assert.assertTrue(FastMath.abs(d20) > 4.0e-7);\n+    Assert.assertTrue(FastMath.abs(d21) > 4.0e-7);\n+    Assert.assertTrue(FastMath.abs(d22) > 4.0e-7);\n+\n+    for (int i = 0; i < 3; ++i) {\n+      for (int j = 0; j < 3; ++j) {\n+        double m3tm3 = m3[i][0] * m3[j][0]\n+                     + m3[i][1] * m3[j][1]\n+                     + m3[i][2] * m3[j][2];\n+        if (i == j) {\n+          Assert.assertTrue(FastMath.abs(m3tm3 - 1.0) < 1.0e-10);\n+        } else {\n+          Assert.assertTrue(FastMath.abs(m3tm3) < 1.0e-10);\n+        }\n+      }\n+    }\n+\n+    checkVector(r.applyTo(Vector3D.PLUS_I),\n+                new Vector3D(m3[0][0], m3[1][0], m3[2][0]));\n+    checkVector(r.applyTo(Vector3D.PLUS_J),\n+                new Vector3D(m3[0][1], m3[1][1], m3[2][1]));\n+    checkVector(r.applyTo(Vector3D.PLUS_K),\n+                new Vector3D(m3[0][2], m3[1][2], m3[2][2]));\n+\n+    double[][] m4 = { { 1.0,  0.0,  0.0 },\n+                      { 0.0, -1.0,  0.0 },\n+                      { 0.0,  0.0, -1.0 } };\n+    r = new Rotation(m4, 1.0e-7);\n+    checkAngle(r.getAngle(), FastMath.PI);\n+\n+    try {\n+      double[][] m5 = { { 0.0, 0.0, 1.0 },\n+                        { 0.0, 1.0, 0.0 },\n+                        { 1.0, 0.0, 0.0 } };\n+      r = new Rotation(m5, 1.0e-7);\n+      Assert.fail(\"got \" + r + \", should have caught an exception\");\n+    } catch (NotARotationMatrixException e) {\n+      // expected\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testAngles()\n+    throws CardanEulerSingularityException {\n+\n+    RotationOrder[] CardanOrders = {\n+      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,\n+      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX\n+    };\n+\n+    for (int i = 0; i < CardanOrders.length; ++i) {\n+      for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {\n+        for (double alpha2 = -1.55; alpha2 < 1.55; alpha2 += 0.3) {\n+          for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {\n+            Rotation r = new Rotation(CardanOrders[i], alpha1, alpha2, alpha3);\n+            double[] angles = r.getAngles(CardanOrders[i]);\n+            checkAngle(angles[0], alpha1);\n+            checkAngle(angles[1], alpha2);\n+            checkAngle(angles[2], alpha3);\n+          }\n+        }\n+      }\n+    }\n+\n+    RotationOrder[] EulerOrders = {\n+            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,\n+            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ\n+          };\n+\n+    for (int i = 0; i < EulerOrders.length; ++i) {\n+      for (double alpha1 = 0.1; alpha1 < 6.2; alpha1 += 0.3) {\n+        for (double alpha2 = 0.05; alpha2 < 3.1; alpha2 += 0.3) {\n+          for (double alpha3 = 0.1; alpha3 < 6.2; alpha3 += 0.3) {\n+            Rotation r = new Rotation(EulerOrders[i],\n+                                      alpha1, alpha2, alpha3);\n+            double[] angles = r.getAngles(EulerOrders[i]);\n+            checkAngle(angles[0], alpha1);\n+            checkAngle(angles[1], alpha2);\n+            checkAngle(angles[2], alpha3);\n+          }\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testSingularities() {\n+\n+    RotationOrder[] CardanOrders = {\n+      RotationOrder.XYZ, RotationOrder.XZY, RotationOrder.YXZ,\n+      RotationOrder.YZX, RotationOrder.ZXY, RotationOrder.ZYX\n+    };\n+\n+    double[] singularCardanAngle = { FastMath.PI / 2, -FastMath.PI / 2 };\n+    for (int i = 0; i < CardanOrders.length; ++i) {\n+      for (int j = 0; j < singularCardanAngle.length; ++j) {\n+        Rotation r = new Rotation(CardanOrders[i], 0.1, singularCardanAngle[j], 0.3);\n+        try {\n+          r.getAngles(CardanOrders[i]);\n+          Assert.fail(\"an exception should have been caught\");\n+        } catch (CardanEulerSingularityException cese) {\n+          // expected behavior\n+        }\n+      }\n+    }\n+\n+    RotationOrder[] EulerOrders = {\n+            RotationOrder.XYX, RotationOrder.XZX, RotationOrder.YXY,\n+            RotationOrder.YZY, RotationOrder.ZXZ, RotationOrder.ZYZ\n+          };\n+\n+    double[] singularEulerAngle = { 0, FastMath.PI };\n+    for (int i = 0; i < EulerOrders.length; ++i) {\n+      for (int j = 0; j < singularEulerAngle.length; ++j) {\n+        Rotation r = new Rotation(EulerOrders[i], 0.1, singularEulerAngle[j], 0.3);\n+        try {\n+          r.getAngles(EulerOrders[i]);\n+          Assert.fail(\"an exception should have been caught\");\n+        } catch (CardanEulerSingularityException cese) {\n+          // expected behavior\n+        }\n+      }\n+    }\n+\n+\n+  }\n+\n+  @Test\n+  public void testQuaternion() {\n+\n+    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);\n+    double n = 23.5;\n+    Rotation r2 = new Rotation(n * r1.getQ0(), n * r1.getQ1(),\n+                               n * r1.getQ2(), n * r1.getQ3(),\n+                               true);\n+    for (double x = -0.9; x < 0.9; x += 0.2) {\n+      for (double y = -0.9; y < 0.9; y += 0.2) {\n+        for (double z = -0.9; z < 0.9; z += 0.2) {\n+          Vector3D u = new Vector3D(x, y, z);\n+          checkVector(r2.applyTo(u), r1.applyTo(u));\n+        }\n+      }\n+    }\n+\n+    r1 = new Rotation( 0.288,  0.384,  0.36,  0.8, false);\n+    checkRotation(r1, -r1.getQ0(), -r1.getQ1(), -r1.getQ2(), -r1.getQ3());\n+\n+  }\n+\n+  @Test\n+  public void testCompose() {\n+\n+    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);\n+    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);\n+    Rotation r3 = r2.applyTo(r1);\n+\n+    for (double x = -0.9; x < 0.9; x += 0.2) {\n+      for (double y = -0.9; y < 0.9; y += 0.2) {\n+        for (double z = -0.9; z < 0.9; z += 0.2) {\n+          Vector3D u = new Vector3D(x, y, z);\n+          checkVector(r2.applyTo(r1.applyTo(u)), r3.applyTo(u));\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testComposeInverse() {\n+\n+    Rotation r1 = new Rotation(new Vector3D(2, -3, 5), 1.7);\n+    Rotation r2 = new Rotation(new Vector3D(-1, 3, 2), 0.3);\n+    Rotation r3 = r2.applyInverseTo(r1);\n+\n+    for (double x = -0.9; x < 0.9; x += 0.2) {\n+      for (double y = -0.9; y < 0.9; y += 0.2) {\n+        for (double z = -0.9; z < 0.9; z += 0.2) {\n+          Vector3D u = new Vector3D(x, y, z);\n+          checkVector(r2.applyInverseTo(r1.applyTo(u)), r3.applyTo(u));\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  @Test\n+  public void testApplyInverseTo() {\n+\n+    Rotation r = new Rotation(new Vector3D(2, -3, 5), 1.7);\n+    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+      for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+          Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi),\n+                                    FastMath.sin(lambda) * FastMath.cos(phi),\n+                                    FastMath.sin(phi));\n+          r.applyInverseTo(r.applyTo(u));\n+          checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+          checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+      }\n+    }\n+\n+    r = Rotation.IDENTITY;\n+    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+      for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+          Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi),\n+                                    FastMath.sin(lambda) * FastMath.cos(phi),\n+                                    FastMath.sin(phi));\n+          checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+          checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+      }\n+    }\n+\n+    r = new Rotation(Vector3D.PLUS_K, FastMath.PI);\n+    for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n+      for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n+          Vector3D u = new Vector3D(FastMath.cos(lambda) * FastMath.cos(phi),\n+                                    FastMath.sin(lambda) * FastMath.cos(phi),\n+                                    FastMath.sin(phi));\n+          checkVector(u, r.applyInverseTo(r.applyTo(u)));\n+          checkVector(u, r.applyTo(r.applyInverseTo(u)));\n+      }\n+    }\n+\n+  }\n+\n+  private void checkVector(Vector3D v1, Vector3D v2) {\n+    Assert.assertTrue(v1.subtract(v2).getNorm() < 1.0e-10);\n+  }\n+\n+  private void checkAngle(double a1, double a2) {\n+    Assert.assertEquals(a1, MathUtils.normalizeAngle(a2, a1), 1.0e-10);\n+  }\n+\n+  private void checkRotation(Rotation r, double q0, double q1, double q2, double q3) {\n+    Assert.assertEquals(0, Rotation.distance(r, new Rotation(q0, q1, q2, q3, false)), 1.0e-12);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/threeD/Vector3DFormatAbstractTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.geometry.euclidean.threeD.Vector3D;\n+import org.apache.commons.math.geometry.euclidean.threeD.Vector3DFormat;\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n+public abstract class Vector3DFormatAbstractTest {\n+\n+    Vector3DFormat vector3DFormat = null;\n+    Vector3DFormat vector3DFormatSquare = null;\n+\n+    protected abstract Locale getLocale();\n+\n+    protected abstract char getDecimalCharacter();\n+\n+    protected Vector3DFormatAbstractTest() {\n+        vector3DFormat = Vector3DFormat.getInstance(getLocale());\n+        final NumberFormat nf = NumberFormat.getInstance(getLocale());\n+        nf.setMaximumFractionDigits(2);\n+        vector3DFormatSquare = new Vector3DFormat(\"[\", \"]\", \" : \", nf);\n+    }\n+\n+    @Test\n+    public void testSimpleNoDecimals() {\n+        Vector3D c = new Vector3D(1, 1, 1);\n+        String expected = \"{1; 1; 1}\";\n+        String actual = vector3DFormat.format(c);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testSimpleWithDecimals() {\n+        Vector3D c = new Vector3D(1.23, 1.43, 1.63);\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testSimpleWithDecimalsTrunc() {\n+        Vector3D c = new Vector3D(1.2323, 1.4343, 1.6333);\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testNegativeX() {\n+        Vector3D c = new Vector3D(-1.2323, 1.4343, 1.6333);\n+        String expected =\n+            \"{-1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testNegativeY() {\n+        Vector3D c = new Vector3D(1.2323, -1.4343, 1.6333);\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; -1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testNegativeZ() {\n+        Vector3D c = new Vector3D(1.2323, 1.4343, -1.6333);\n+        String expected =\n+            \"{1\"    + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; -1\" + getDecimalCharacter() +\n+            \"63}\";\n+        String actual = vector3DFormat.format(c);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testNonDefaultSetting() {\n+        Vector3D c = new Vector3D(1, 1, 1);\n+        String expected = \"[1 : 1 : 1]\";\n+        String actual = vector3DFormatSquare.format(c);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testDefaultFormatVector3D() {\n+        Locale defaultLocal = Locale.getDefault();\n+        Locale.setDefault(getLocale());\n+\n+        Vector3D c = new Vector3D(232.222, -342.33, 432.444);\n+        String expected =\n+            \"{232\"    + getDecimalCharacter() +\n+            \"22; -342\" + getDecimalCharacter() +\n+            \"33; 432\" + getDecimalCharacter() +\n+            \"44}\";\n+        String actual = (new Vector3DFormat()).format(c);\n+        Assert.assertEquals(expected, actual);\n+\n+        Locale.setDefault(defaultLocal);\n+    }\n+\n+    @Test\n+    public void testNan() {\n+        Vector3D c = Vector3D.NaN;\n+        String expected = \"{(NaN); (NaN); (NaN)}\";\n+        String actual = vector3DFormat.format(c);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testPositiveInfinity() {\n+        Vector3D c = Vector3D.POSITIVE_INFINITY;\n+        String expected = \"{(Infinity); (Infinity); (Infinity)}\";\n+        String actual = vector3DFormat.format(c);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void tesNegativeInfinity() {\n+        Vector3D c = Vector3D.NEGATIVE_INFINITY;\n+        String expected = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n+        String actual = vector3DFormat.format(c);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseSimpleNoDecimals() {\n+        String source = \"{1; 1; 1}\";\n+        Vector3D expected = new Vector3D(1, 1, 1);\n+        Vector3D actual = vector3DFormat.parse(source);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseIgnoredWhitespace() {\n+        Vector3D expected = new Vector3D(1, 1, 1);\n+        ParsePosition pos1 = new ParsePosition(0);\n+        String source1 = \"{1;1;1}\";\n+        Assert.assertEquals(expected, vector3DFormat.parse(source1, pos1));\n+        Assert.assertEquals(source1.length(), pos1.getIndex());\n+        ParsePosition pos2 = new ParsePosition(0);\n+        String source2 = \" { 1 ; 1 ; 1 } \";\n+        Assert.assertEquals(expected, vector3DFormat.parse(source2, pos2));\n+        Assert.assertEquals(source2.length() - 1, pos2.getIndex());\n+    }\n+\n+    @Test\n+    public void testParseSimpleWithDecimals() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"23; 1\" + getDecimalCharacter() +\n+            \"43; 1\" + getDecimalCharacter() +\n+            \"63}\";\n+        Vector3D expected = new Vector3D(1.23, 1.43, 1.63);\n+        Vector3D actual = vector3DFormat.parse(source);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseSimpleWithDecimalsTrunc() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);\n+        Vector3D actual = vector3DFormat.parse(source);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseNegativeX() {\n+        String source =\n+            \"{-1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(-1.2323, 1.4343, 1.6333);\n+        Vector3D actual = vector3DFormat.parse(source);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseNegativeY() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; -1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(1.2323, -1.4343, 1.6333);\n+        Vector3D actual = vector3DFormat.parse(source);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseNegativeZ() {\n+        String source =\n+            \"{1\" + getDecimalCharacter() +\n+            \"2323; 1\" + getDecimalCharacter() +\n+            \"4343; -1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(1.2323, 1.4343, -1.6333);\n+        Vector3D actual = vector3DFormat.parse(source);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseNegativeAll() {\n+        String source =\n+            \"{-1\" + getDecimalCharacter() +\n+            \"2323; -1\" + getDecimalCharacter() +\n+            \"4343; -1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(-1.2323, -1.4343, -1.6333);\n+        Vector3D actual = vector3DFormat.parse(source);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseZeroX() {\n+        String source =\n+            \"{0\" + getDecimalCharacter() +\n+            \"0; -1\" + getDecimalCharacter() +\n+            \"4343; 1\" + getDecimalCharacter() +\n+            \"6333}\";\n+        Vector3D expected = new Vector3D(0.0, -1.4343, 1.6333);\n+        Vector3D actual = vector3DFormat.parse(source);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseNonDefaultSetting() {\n+        String source =\n+            \"[1\" + getDecimalCharacter() +\n+            \"2323 : 1\" + getDecimalCharacter() +\n+            \"4343 : 1\" + getDecimalCharacter() +\n+            \"6333]\";\n+        Vector3D expected = new Vector3D(1.2323, 1.4343, 1.6333);\n+        Vector3D actual = vector3DFormatSquare.parse(source);\n+        Assert.assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void testParseNan() {\n+        String source = \"{(NaN); (NaN); (NaN)}\";\n+        Vector3D actual = vector3DFormat.parse(source);\n+        Assert.assertEquals(Vector3D.NaN, actual);\n+    }\n+\n+    @Test\n+    public void testParsePositiveInfinity() {\n+        String source = \"{(Infinity); (Infinity); (Infinity)}\";\n+        Vector3D actual = vector3DFormat.parse(source);\n+        Assert.assertEquals(Vector3D.POSITIVE_INFINITY, actual);\n+    }\n+\n+    @Test\n+    public void testParseNegativeInfinity() {\n+        String source = \"{(-Infinity); (-Infinity); (-Infinity)}\";\n+        Vector3D actual = vector3DFormat.parse(source);\n+        Assert.assertEquals(Vector3D.NEGATIVE_INFINITY, actual);\n+    }\n+\n+    @Test\n+    public void testConstructorSingleFormat() {\n+        NumberFormat nf = NumberFormat.getInstance();\n+        Vector3DFormat cf = new Vector3DFormat(nf);\n+        Assert.assertNotNull(cf);\n+        Assert.assertEquals(nf, cf.getFormat());\n+    }\n+\n+    @Test\n+    public void testForgottenPrefix() {\n+        ParsePosition pos = new ParsePosition(0);\n+        Assert.assertNull(new Vector3DFormat().parse(\"1; 1; 1}\", pos));\n+        Assert.assertEquals(0, pos.getErrorIndex());\n+    }\n+\n+    @Test\n+    public void testForgottenSeparator() {\n+        ParsePosition pos = new ParsePosition(0);\n+        Assert.assertNull(new Vector3DFormat().parse(\"{1; 1 1}\", pos));\n+        Assert.assertEquals(6, pos.getErrorIndex());\n+    }\n+\n+    @Test\n+    public void testForgottenSuffix() {\n+        ParsePosition pos = new ParsePosition(0);\n+        Assert.assertNull(new Vector3DFormat().parse(\"{1; 1; 1 \", pos));\n+        Assert.assertEquals(8, pos.getErrorIndex());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/threeD/Vector3DFormatTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+import java.util.Locale;\n+\n+\n+public class Vector3DFormatTest extends Vector3DFormatAbstractTest {\n+\n+    @Override\n+    protected char getDecimalCharacter() {\n+        return '.';\n+    }\n+\n+    @Override\n+    protected Locale getLocale() {\n+        return Locale.US;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/threeD/Vector3DTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry.euclidean.threeD;\n+\n+import org.apache.commons.math.geometry.euclidean.threeD.Vector3D;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.MathArithmeticException;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class Vector3DTest {\n+    @Test\n+    public void testConstructors() {\n+        double r = FastMath.sqrt(2) /2;\n+        checkVector(new Vector3D(2, new Vector3D(FastMath.PI / 3, -FastMath.PI / 4)),\n+                    r, r * FastMath.sqrt(3), -2 * r);\n+        checkVector(new Vector3D(2, Vector3D.PLUS_I,\n+                                 -3, Vector3D.MINUS_K),\n+                    2, 0, 3);\n+        checkVector(new Vector3D(2, Vector3D.PLUS_I,\n+                                 5, Vector3D.PLUS_J,\n+                                 -3, Vector3D.MINUS_K),\n+                    2, 5, 3);\n+        checkVector(new Vector3D(2, Vector3D.PLUS_I,\n+                                 5, Vector3D.PLUS_J,\n+                                 5, Vector3D.MINUS_J,\n+                                 -3, Vector3D.MINUS_K),\n+                    2, 0, 3);\n+    }\n+\n+    @Test\n+    public void testCoordinates() {\n+        Vector3D v = new Vector3D(1, 2, 3);\n+        Assert.assertTrue(FastMath.abs(v.getX() - 1) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(v.getY() - 2) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(v.getZ() - 3) < 1.0e-12);\n+    }\n+\n+    @Test\n+    public void testNorm1() {\n+        Assert.assertEquals(0.0, Vector3D.ZERO.getNorm1(), 0);\n+        Assert.assertEquals(6.0, new Vector3D(1, -2, 3).getNorm1(), 0);\n+    }\n+\n+    @Test\n+    public void testNorm() {\n+        Assert.assertEquals(0.0, Vector3D.ZERO.getNorm(), 0);\n+        Assert.assertEquals(FastMath.sqrt(14), new Vector3D(1, 2, 3).getNorm(), 1.0e-12);\n+    }\n+\n+    @Test\n+    public void testNormInf() {\n+        Assert.assertEquals(0.0, Vector3D.ZERO.getNormInf(), 0);\n+        Assert.assertEquals(3.0, new Vector3D(1, -2, 3).getNormInf(), 0);\n+    }\n+\n+    @Test\n+    public void testDistance1() {\n+        Vector3D v1 = new Vector3D(1, -2, 3);\n+        Vector3D v2 = new Vector3D(-4, 2, 0);\n+        Assert.assertEquals(0.0, Vector3D.distance1(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);\n+        Assert.assertEquals(12.0, Vector3D.distance1(v1, v2), 1.0e-12);\n+        Assert.assertEquals(v1.subtract(v2).getNorm1(), Vector3D.distance1(v1, v2), 1.0e-12);\n+    }\n+\n+    @Test\n+    public void testDistance() {\n+        Vector3D v1 = new Vector3D(1, -2, 3);\n+        Vector3D v2 = new Vector3D(-4, 2, 0);\n+        Assert.assertEquals(0.0, Vector3D.distance(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);\n+        Assert.assertEquals(FastMath.sqrt(50), Vector3D.distance(v1, v2), 1.0e-12);\n+        Assert.assertEquals(v1.subtract(v2).getNorm(), Vector3D.distance(v1, v2), 1.0e-12);\n+    }\n+\n+    @Test\n+    public void testDistanceSq() {\n+        Vector3D v1 = new Vector3D(1, -2, 3);\n+        Vector3D v2 = new Vector3D(-4, 2, 0);\n+        Assert.assertEquals(0.0, Vector3D.distanceSq(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);\n+        Assert.assertEquals(50.0, Vector3D.distanceSq(v1, v2), 1.0e-12);\n+        Assert.assertEquals(Vector3D.distance(v1, v2) * Vector3D.distance(v1, v2),\n+                            Vector3D.distanceSq(v1, v2), 1.0e-12);\n+  }\n+\n+    @Test\n+    public void testDistanceInf() {\n+        Vector3D v1 = new Vector3D(1, -2, 3);\n+        Vector3D v2 = new Vector3D(-4, 2, 0);\n+        Assert.assertEquals(0.0, Vector3D.distanceInf(Vector3D.MINUS_I, Vector3D.MINUS_I), 0);\n+        Assert.assertEquals(5.0, Vector3D.distanceInf(v1, v2), 1.0e-12);\n+        Assert.assertEquals(v1.subtract(v2).getNormInf(), Vector3D.distanceInf(v1, v2), 1.0e-12);\n+    }\n+\n+    @Test\n+    public void testSubtract() {\n+        Vector3D v1 = new Vector3D(1, 2, 3);\n+        Vector3D v2 = new Vector3D(-3, -2, -1);\n+        v1 = v1.subtract(v2);\n+        checkVector(v1, 4, 4, 4);\n+\n+        checkVector(v2.subtract(v1), -7, -6, -5);\n+        checkVector(v2.subtract(3, v1), -15, -14, -13);\n+    }\n+\n+    @Test\n+    public void testAdd() {\n+        Vector3D v1 = new Vector3D(1, 2, 3);\n+        Vector3D v2 = new Vector3D(-3, -2, -1);\n+        v1 = v1.add(v2);\n+        checkVector(v1, -2, 0, 2);\n+\n+        checkVector(v2.add(v1), -5, -2, 1);\n+        checkVector(v2.add(3, v1), -9, -2, 5);\n+    }\n+\n+    @Test\n+    public void testScalarProduct() {\n+        Vector3D v = new Vector3D(1, 2, 3);\n+        v = v.scalarMultiply(3);\n+        checkVector(v, 3, 6, 9);\n+\n+        checkVector(v.scalarMultiply(0.5), 1.5, 3, 4.5);\n+    }\n+\n+    @Test\n+    public void testVectorialProducts() {\n+        Vector3D v1 = new Vector3D(2, 1, -4);\n+        Vector3D v2 = new Vector3D(3, 1, -1);\n+\n+        Assert.assertTrue(FastMath.abs(Vector3D.dotProduct(v1, v2) - 11) < 1.0e-12);\n+\n+        Vector3D v3 = Vector3D.crossProduct(v1, v2);\n+        checkVector(v3, 3, -10, -1);\n+\n+        Assert.assertTrue(FastMath.abs(Vector3D.dotProduct(v1, v3)) < 1.0e-12);\n+        Assert.assertTrue(FastMath.abs(Vector3D.dotProduct(v2, v3)) < 1.0e-12);\n+    }\n+\n+    @Test\n+    public void testCrossProductCancellation() {\n+        Vector3D v1 = new Vector3D(9070467121.0, 4535233560.0, 1);\n+        Vector3D v2 = new Vector3D(9070467123.0, 4535233561.0, 1);\n+        checkVector(Vector3D.crossProduct(v1, v2), -1, 2, 1);\n+\n+        double scale    = FastMath.scalb(1.0, 100);\n+        Vector3D big1   = new Vector3D(scale, v1);\n+        Vector3D small2 = new Vector3D(1 / scale, v2);\n+        checkVector(Vector3D.crossProduct(big1, small2), -1, 2, 1);\n+\n+    }\n+\n+    @Test\n+    public void testAngular() {\n+        Assert.assertEquals(0,           Vector3D.PLUS_I.getAlpha(), 1.0e-10);\n+        Assert.assertEquals(0,           Vector3D.PLUS_I.getDelta(), 1.0e-10);\n+        Assert.assertEquals(FastMath.PI / 2, Vector3D.PLUS_J.getAlpha(), 1.0e-10);\n+        Assert.assertEquals(0,           Vector3D.PLUS_J.getDelta(), 1.0e-10);\n+        Assert.assertEquals(0,           Vector3D.PLUS_K.getAlpha(), 1.0e-10);\n+        Assert.assertEquals(FastMath.PI / 2, Vector3D.PLUS_K.getDelta(), 1.0e-10);\n+      \n+        Vector3D u = new Vector3D(-1, 1, -1);\n+        Assert.assertEquals(3 * FastMath.PI /4, u.getAlpha(), 1.0e-10);\n+        Assert.assertEquals(-1.0 / FastMath.sqrt(3), FastMath.sin(u.getDelta()), 1.0e-10);\n+    }\n+\n+    @Test\n+    public void testAngularSeparation() {\n+        Vector3D v1 = new Vector3D(2, -1, 4);\n+\n+        Vector3D  k = v1.normalize();\n+        Vector3D  i = k.orthogonal();\n+        Vector3D v2 = k.scalarMultiply(FastMath.cos(1.2)).add(i.scalarMultiply(FastMath.sin(1.2)));\n+\n+        Assert.assertTrue(FastMath.abs(Vector3D.angle(v1, v2) - 1.2) < 1.0e-12);\n+  }\n+\n+    @Test\n+    public void testNormalize() {\n+        Assert.assertEquals(1.0, new Vector3D(5, -4, 2).normalize().getNorm(), 1.0e-12);\n+        try {\n+            Vector3D.ZERO.normalize();\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathArithmeticException ae) {\n+            // expected behavior\n+        }\n+    }\n+\n+    @Test\n+    public void testOrthogonal() {\n+        Vector3D v1 = new Vector3D(0.1, 2.5, 1.3);\n+        Assert.assertEquals(0.0, Vector3D.dotProduct(v1, v1.orthogonal()), 1.0e-12);\n+        Vector3D v2 = new Vector3D(2.3, -0.003, 7.6);\n+        Assert.assertEquals(0.0, Vector3D.dotProduct(v2, v2.orthogonal()), 1.0e-12);\n+        Vector3D v3 = new Vector3D(-1.7, 1.4, 0.2);\n+        Assert.assertEquals(0.0, Vector3D.dotProduct(v3, v3.orthogonal()), 1.0e-12);\n+        try {\n+            new Vector3D(0, 0, 0).orthogonal();\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathArithmeticException ae) {\n+            // expected behavior\n+        }\n+    }\n+\n+    @Test\n+    public void testAngle() {\n+        Assert.assertEquals(0.22572612855273393616,\n+                            Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(4, 5, 6)),\n+                            1.0e-12);\n+        Assert.assertEquals(7.98595620686106654517199e-8,\n+                            Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(2, 4, 6.000001)),\n+                            1.0e-12);\n+        Assert.assertEquals(3.14159257373023116985197793156,\n+                            Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(-2, -4, -6.000001)),\n+                            1.0e-12);\n+        try {\n+            Vector3D.angle(Vector3D.ZERO, Vector3D.PLUS_I);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (MathArithmeticException ae) {\n+            // expected behavior\n+        }\n+    }\n+\n+    private void checkVector(Vector3D v, double x, double y, double z) {\n+        Assert.assertEquals(x, v.getX(), 1.0e-12);\n+        Assert.assertEquals(y, v.getY(), 1.0e-12);\n+        Assert.assertEquals(z, v.getZ(), 1.0e-12);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/twoD/LineTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.twoD;\n+\n+import org.apache.commons.math.geometry.euclidean.oneD.Point1D;\n+import org.apache.commons.math.geometry.euclidean.twoD.Line;\n+import org.apache.commons.math.geometry.euclidean.twoD.Point2D;\n+import org.apache.commons.math.geometry.partitioning.Transform;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.awt.geom.AffineTransform;\n+\n+public class LineTest {\n+\n+    @Test\n+    public void testContains() {\n+        Line l = new Line(new Point2D(0, 1), new Point2D(1, 2));\n+        Assert.assertTrue(l.contains(new Point2D(0, 1)));\n+        Assert.assertTrue(l.contains(new Point2D(1, 2)));\n+        Assert.assertTrue(l.contains(new Point2D(7, 8)));\n+        Assert.assertTrue(! l.contains(new Point2D(8, 7)));\n+    }\n+\n+    @Test\n+    public void testAbscissa() {\n+        Line l = new Line(new Point2D(2, 1), new Point2D(-2, -2));\n+        Assert.assertEquals(0.0,\n+                            ((Point1D) l.toSubSpace(new Point2D(-3,  4))).getAbscissa(),\n+                            1.0e-10);\n+        Assert.assertEquals(0.0,\n+                            ((Point1D) l.toSubSpace(new Point2D( 3, -4))).getAbscissa(),\n+                            1.0e-10);\n+        Assert.assertEquals(-5.0,\n+                            ((Point1D) l.toSubSpace(new Point2D( 7, -1))).getAbscissa(),\n+                            1.0e-10);\n+        Assert.assertEquals( 5.0,\n+                             ((Point1D) l.toSubSpace(new Point2D(-1, -7))).getAbscissa(),\n+                             1.0e-10);\n+    }\n+\n+    @Test\n+    public void testOffset() {\n+        Line l = new Line(new Point2D(2, 1), new Point2D(-2, -2));\n+        Assert.assertEquals(-5.0, l.getOffset(new Point2D(5, -3)), 1.0e-10);\n+        Assert.assertEquals(+5.0, l.getOffset(new Point2D(-5, 2)), 1.0e-10);\n+    }\n+\n+    @Test\n+    public void testPointAt() {\n+        Line l = new Line(new Point2D(2, 1), new Point2D(-2, -2));\n+        for (double a = -2.0; a < 2.0; a += 0.2) {\n+            Point1D pA = new Point1D(a);\n+            Point2D point = (Point2D) l.toSpace(pA);\n+            Assert.assertEquals(a, ((Point1D) l.toSubSpace(point)).getAbscissa(), 1.0e-10);\n+            Assert.assertEquals(0.0, l.getOffset(point),   1.0e-10);\n+            for (double o = -2.0; o < 2.0; o += 0.2) {\n+                point = l.getPointAt(pA, o);\n+                Assert.assertEquals(a, ((Point1D) l.toSubSpace(point)).getAbscissa(), 1.0e-10);\n+                Assert.assertEquals(o, l.getOffset(point),   1.0e-10);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testOriginOffset() {\n+        Line l1 = new Line(new Point2D(0, 1), new Point2D(1, 2));\n+        Assert.assertEquals(FastMath.sqrt(0.5), l1.getOriginOffset(), 1.0e-10);\n+        Line l2 = new Line(new Point2D(1, 2), new Point2D(0, 1));\n+        Assert.assertEquals(-FastMath.sqrt(0.5), l2.getOriginOffset(), 1.0e-10);\n+    }\n+\n+    @Test\n+    public void testParallel() {\n+        Line l1 = new Line(new Point2D(0, 1), new Point2D(1, 2));\n+        Line l2 = new Line(new Point2D(2, 2), new Point2D(3, 3));\n+        Assert.assertTrue(l1.isParallelTo(l2));\n+        Line l3 = new Line(new Point2D(1, 0), new Point2D(0.5, -0.5));\n+        Assert.assertTrue(l1.isParallelTo(l3));\n+        Line l4 = new Line(new Point2D(1, 0), new Point2D(0.5, -0.51));\n+        Assert.assertTrue(! l1.isParallelTo(l4));\n+    }\n+\n+    @Test\n+    public void testTransform() {\n+\n+        Line l1 = new Line(new Point2D(1.0 ,1.0), new Point2D(4.0 ,1.0));\n+        Transform t1 = Line.getTransform(new AffineTransform(0.0, 0.5,\n+                                                             -1.0, 0.0,\n+                                                             1.0, 1.5));\n+        Assert.assertEquals(0.5 * FastMath.PI,\n+                            ((Line) t1.apply(l1)).getAngle(),\n+                            1.0e-10);\n+\n+        Line l2 = new Line(new Point2D(0.0, 0.0), new Point2D(1.0, 1.0));\n+        Transform t2 = Line.getTransform(new AffineTransform(0.0, 0.5,\n+                                                             -1.0, 0.0,\n+                                                             1.0, 1.5));\n+        Assert.assertEquals(FastMath.atan2(1.0, -2.0),\n+                            ((Line) t2.apply(l2)).getAngle(),\n+                            1.0e-10);\n+\n+    }\n+\n+    @Test\n+    public void testIntersection() {\n+        Line    l1 = new Line(new Point2D( 0, 1), new Point2D(1, 2));\n+        Line    l2 = new Line(new Point2D(-1, 2), new Point2D(2, 1));\n+        Point2D p  = (Point2D) l1.intersection(l2);\n+        Assert.assertEquals(0.5, p.x, 1.0e-10);\n+        Assert.assertEquals(1.5, p.y, 1.0e-10);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/euclidean/twoD/PolygonsSetTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.twoD;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.geometry.euclidean.oneD.Interval;\n+import org.apache.commons.math.geometry.euclidean.oneD.IntervalsSet;\n+import org.apache.commons.math.geometry.euclidean.oneD.Point1D;\n+import org.apache.commons.math.geometry.euclidean.twoD.Line;\n+import org.apache.commons.math.geometry.euclidean.twoD.Point2D;\n+import org.apache.commons.math.geometry.euclidean.twoD.PolygonsSet;\n+import org.apache.commons.math.geometry.partitioning.BSPTree;\n+import org.apache.commons.math.geometry.partitioning.Region;\n+import org.apache.commons.math.geometry.partitioning.SubHyperplane;\n+import org.apache.commons.math.util.FastMath;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class PolygonsSetTest {\n+\n+    @Test\n+    public void testSimplyConnected() {\n+        Point2D[][] vertices = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D(36.0, 22.0),\n+                new Point2D(39.0, 32.0),\n+                new Point2D(19.0, 32.0),\n+                new Point2D( 6.0, 16.0),\n+                new Point2D(31.0, 10.0),\n+                new Point2D(42.0, 16.0),\n+                new Point2D(34.0, 20.0),\n+                new Point2D(29.0, 19.0),\n+                new Point2D(23.0, 22.0),\n+                new Point2D(33.0, 25.0)\n+            }\n+        };\n+        PolygonsSet set = buildSet(vertices);\n+        Assert.assertEquals(Region.Location.OUTSIDE, set.checkPoint(new Point2D(50.0, 30.0)));\n+        checkPoints(Region.Location.INSIDE, set, new Point2D[] {\n+            new Point2D(30.0, 15.0),\n+            new Point2D(15.0, 20.0),\n+            new Point2D(24.0, 25.0),\n+            new Point2D(35.0, 30.0),\n+            new Point2D(19.0, 17.0)\n+        });\n+        checkPoints(Region.Location.OUTSIDE, set, new Point2D[] {\n+            new Point2D(50.0, 30.0),\n+            new Point2D(30.0, 35.0),\n+            new Point2D(10.0, 25.0),\n+            new Point2D(10.0, 10.0),\n+            new Point2D(40.0, 10.0),\n+            new Point2D(50.0, 15.0),\n+            new Point2D(30.0, 22.0)\n+        });\n+        checkPoints(Region.Location.BOUNDARY, set, new Point2D[] {\n+            new Point2D(30.0, 32.0),\n+            new Point2D(34.0, 20.0)\n+        });\n+        checkVertices(set.getVertices(), vertices);\n+    }\n+\n+    @Test\n+    public void testStair() {\n+        Point2D[][] vertices = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D( 0.0, 0.0),\n+                new Point2D( 0.0, 2.0),\n+                new Point2D(-0.1, 2.0),\n+                new Point2D(-0.1, 1.0),\n+                new Point2D(-0.3, 1.0),\n+                new Point2D(-0.3, 1.5),\n+                new Point2D(-1.3, 1.5),\n+                new Point2D(-1.3, 2.0),\n+                new Point2D(-1.8, 2.0),\n+                new Point2D(-1.8 - 1.0 / FastMath.sqrt(2.0),\n+                            2.0 - 1.0 / FastMath.sqrt(2.0))\n+            }\n+        };\n+\n+        PolygonsSet set = buildSet(vertices);\n+        checkVertices(set.getVertices(), vertices);\n+\n+        Assert.assertEquals(1.1 + 0.95 * FastMath.sqrt(2.0), set.getSize(), 1.0e-10);\n+\n+    }\n+\n+    @Test\n+    public void testHole() {\n+        Point2D[][] vertices = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D(0.0, 0.0),\n+                new Point2D(3.0, 0.0),\n+                new Point2D(3.0, 3.0),\n+                new Point2D(0.0, 3.0)\n+            }, new Point2D[] {\n+                new Point2D(1.0, 2.0),\n+                new Point2D(2.0, 2.0),\n+                new Point2D(2.0, 1.0),\n+                new Point2D(1.0, 1.0)\n+            }\n+        };\n+        PolygonsSet set = buildSet(vertices);\n+        checkPoints(Region.Location.INSIDE, set, new Point2D[] {\n+            new Point2D(0.5, 0.5),\n+            new Point2D(1.5, 0.5),\n+            new Point2D(2.5, 0.5),\n+            new Point2D(0.5, 1.5),\n+            new Point2D(2.5, 1.5),\n+            new Point2D(0.5, 2.5),\n+            new Point2D(1.5, 2.5),\n+            new Point2D(2.5, 2.5),\n+            new Point2D(0.5, 1.0)\n+        });\n+        checkPoints(Region.Location.OUTSIDE, set, new Point2D[] {\n+            new Point2D(1.5, 1.5),\n+            new Point2D(3.5, 1.0),\n+            new Point2D(4.0, 1.5),\n+            new Point2D(6.0, 6.0)\n+        });\n+        checkPoints(Region.Location.BOUNDARY, set, new Point2D[] {\n+            new Point2D(1.0, 1.0),\n+            new Point2D(1.5, 0.0),\n+            new Point2D(1.5, 1.0),\n+            new Point2D(1.5, 2.0),\n+            new Point2D(1.5, 3.0),\n+            new Point2D(3.0, 3.0)\n+        });\n+        checkVertices(set.getVertices(), vertices);\n+    }\n+\n+    @Test\n+    public void testDisjointPolygons() {\n+        Point2D[][] vertices = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D(0.0, 1.0),\n+                new Point2D(2.0, 1.0),\n+                new Point2D(1.0, 2.0)\n+            }, new Point2D[] {\n+                new Point2D(4.0, 0.0),\n+                new Point2D(5.0, 1.0),\n+                new Point2D(3.0, 1.0)\n+            }\n+        };\n+        PolygonsSet set = buildSet(vertices);\n+        Assert.assertEquals(Region.Location.INSIDE, set.checkPoint(new Point2D(1.0, 1.5)));\n+        checkPoints(Region.Location.INSIDE, set, new Point2D[] {\n+            new Point2D(1.0, 1.5),\n+            new Point2D(4.5, 0.8)\n+        });\n+        checkPoints(Region.Location.OUTSIDE, set, new Point2D[] {\n+            new Point2D(1.0, 0.0),\n+            new Point2D(3.5, 1.2),\n+            new Point2D(2.5, 1.0),\n+            new Point2D(3.0, 4.0)\n+        });\n+        checkPoints(Region.Location.BOUNDARY, set, new Point2D[] {\n+            new Point2D(1.0, 1.0),\n+            new Point2D(3.5, 0.5),\n+            new Point2D(0.0, 1.0)\n+        });\n+        checkVertices(set.getVertices(), vertices);\n+    }\n+\n+    @Test\n+    public void testOppositeHyperplanes() {\n+        Point2D[][] vertices = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D(1.0, 0.0),\n+                new Point2D(2.0, 1.0),\n+                new Point2D(3.0, 1.0),\n+                new Point2D(2.0, 2.0),\n+                new Point2D(1.0, 1.0),\n+                new Point2D(0.0, 1.0)\n+            }\n+        };\n+        PolygonsSet set = buildSet(vertices);\n+        checkVertices(set.getVertices(), vertices);\n+    }\n+\n+    @Test\n+    public void testSingularPoint() {\n+        Point2D[][] vertices = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D( 0.0,  0.0),\n+                new Point2D( 1.0,  0.0),\n+                new Point2D( 1.0,  1.0),\n+                new Point2D( 0.0,  1.0),\n+                new Point2D( 0.0,  0.0),\n+                new Point2D(-1.0,  0.0),\n+                new Point2D(-1.0, -1.0),\n+                new Point2D( 0.0, -1.0)\n+            }\n+        };\n+        PolygonsSet set = buildSet(vertices);\n+        checkVertices(set.getVertices(), vertices);\n+    }\n+\n+    @Test\n+    public void testLineIntersection() {\n+        Point2D[][] vertices = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D( 0.0,  0.0),\n+                new Point2D( 2.0,  0.0),\n+                new Point2D( 2.0,  1.0),\n+                new Point2D( 3.0,  1.0),\n+                new Point2D( 3.0,  3.0),\n+                new Point2D( 1.0,  3.0),\n+                new Point2D( 1.0,  2.0),\n+                new Point2D( 0.0,  2.0)\n+            }\n+        };\n+        PolygonsSet set = buildSet(vertices);\n+\n+        Line l1 = new Line(new Point2D(-1.5, 0.0), FastMath.PI / 4);\n+        SubHyperplane s1 = set.intersection(new SubHyperplane(l1));\n+        List<Interval> i1 = ((IntervalsSet) s1.getRemainingRegion()).asList();\n+        Assert.assertEquals(2, i1.size());\n+        Interval v10 = (Interval) i1.get(0);\n+        Point2D p10Lower = (Point2D) l1.toSpace(new Point1D(v10.getLower()));\n+        Assert.assertEquals(0.0, p10Lower.getX(), 1.0e-10);\n+        Assert.assertEquals(1.5, p10Lower.getY(), 1.0e-10);\n+        Point2D p10Upper = (Point2D) l1.toSpace(new Point1D(v10.getUpper()));\n+        Assert.assertEquals(0.5, p10Upper.getX(), 1.0e-10);\n+        Assert.assertEquals(2.0, p10Upper.getY(), 1.0e-10);\n+        Interval v11 = (Interval) i1.get(1);\n+        Point2D p11Lower = (Point2D) l1.toSpace(new Point1D(v11.getLower()));\n+        Assert.assertEquals(1.0, p11Lower.getX(), 1.0e-10);\n+        Assert.assertEquals(2.5, p11Lower.getY(), 1.0e-10);\n+        Point2D p11Upper = (Point2D) l1.toSpace(new Point1D(v11.getUpper()));\n+        Assert.assertEquals(1.5, p11Upper.getX(), 1.0e-10);\n+        Assert.assertEquals(3.0, p11Upper.getY(), 1.0e-10);\n+\n+        Line l2 = new Line(new Point2D(-1.0, 2.0), 0);\n+        SubHyperplane s2 = set.intersection(new SubHyperplane(l2));\n+        List<Interval> i2 = ((IntervalsSet) s2.getRemainingRegion()).asList();\n+        Assert.assertEquals(1, i2.size());\n+        Interval v20 = (Interval) i2.get(0);\n+        Point2D p20Lower = (Point2D) l2.toSpace(new Point1D(v20.getLower()));\n+        Assert.assertEquals(1.0, p20Lower.getX(), 1.0e-10);\n+        Assert.assertEquals(2.0, p20Lower.getY(), 1.0e-10);\n+        Point2D p20Upper = (Point2D) l2.toSpace(new Point1D(v20.getUpper()));\n+        Assert.assertEquals(3.0, p20Upper.getX(), 1.0e-10);\n+        Assert.assertEquals(2.0, p20Upper.getY(), 1.0e-10);\n+\n+    }\n+\n+    @Test\n+    public void testUnlimitedSubHyperplane() {\n+        Point2D[][] vertices1 = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D(0.0, 0.0),\n+                new Point2D(4.0, 0.0),\n+                new Point2D(1.4, 1.5),\n+                new Point2D(0.0, 3.5)\n+            }\n+        };\n+        PolygonsSet set1 = buildSet(vertices1);\n+        Point2D[][] vertices2 = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D(1.4,  0.2),\n+                new Point2D(2.8, -1.2),\n+                new Point2D(2.5,  0.6)\n+            }\n+        };\n+        PolygonsSet set2 = buildSet(vertices2);\n+\n+        PolygonsSet set = (PolygonsSet) Region.union(set1.copySelf(),\n+                                                     set2.copySelf());\n+        checkVertices(set1.getVertices(), vertices1);\n+        checkVertices(set2.getVertices(), vertices2);\n+        checkVertices(set.getVertices(), new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D(0.0,  0.0),\n+                new Point2D(1.6,  0.0),\n+                new Point2D(2.8, -1.2),\n+                new Point2D(2.6,  0.0),\n+                new Point2D(4.0,  0.0),\n+                new Point2D(1.4,  1.5),\n+                new Point2D(0.0,  3.5)\n+            }\n+        });\n+\n+    }\n+\n+    @Test\n+    public void testUnion() {\n+        Point2D[][] vertices1 = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D( 0.0,  0.0),\n+                new Point2D( 2.0,  0.0),\n+                new Point2D( 2.0,  2.0),\n+                new Point2D( 0.0,  2.0)\n+            }\n+        };\n+        PolygonsSet set1 = buildSet(vertices1);\n+        Point2D[][] vertices2 = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D( 1.0,  1.0),\n+                new Point2D( 3.0,  1.0),\n+                new Point2D( 3.0,  3.0),\n+                new Point2D( 1.0,  3.0)\n+            }\n+        };\n+        PolygonsSet set2 = buildSet(vertices2);\n+        PolygonsSet set  = (PolygonsSet) Region.union(set1.copySelf(),\n+                                                      set2.copySelf());\n+        checkVertices(set1.getVertices(), vertices1);\n+        checkVertices(set2.getVertices(), vertices2);\n+        checkVertices(set.getVertices(), new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D( 0.0,  0.0),\n+                new Point2D( 2.0,  0.0),\n+                new Point2D( 2.0,  1.0),\n+                new Point2D( 3.0,  1.0),\n+                new Point2D( 3.0,  3.0),\n+                new Point2D( 1.0,  3.0),\n+                new Point2D( 1.0,  2.0),\n+                new Point2D( 0.0,  2.0)\n+            }\n+        });\n+        checkPoints(Region.Location.INSIDE, set, new Point2D[] {\n+            new Point2D(1.0, 1.0),\n+            new Point2D(0.5, 0.5),\n+            new Point2D(2.0, 2.0),\n+            new Point2D(2.5, 2.5),\n+            new Point2D(0.5, 1.5),\n+            new Point2D(1.5, 1.5),\n+            new Point2D(1.5, 0.5),\n+            new Point2D(1.5, 2.5),\n+            new Point2D(2.5, 1.5),\n+            new Point2D(2.5, 2.5)\n+        });\n+        checkPoints(Region.Location.OUTSIDE, set, new Point2D[] {\n+            new Point2D(-0.5, 0.5),\n+            new Point2D( 0.5, 2.5),\n+            new Point2D( 2.5, 0.5),\n+            new Point2D( 3.5, 2.5)\n+        });\n+        checkPoints(Region.Location.BOUNDARY, set, new Point2D[] {\n+            new Point2D(0.0, 0.0),\n+            new Point2D(0.5, 2.0),\n+            new Point2D(2.0, 0.5),\n+            new Point2D(2.5, 1.0),\n+            new Point2D(3.0, 2.5)\n+        });\n+\n+    }\n+\n+    @Test\n+    public void testIntersection() {\n+        Point2D[][] vertices1 = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D( 0.0,  0.0),\n+                new Point2D( 2.0,  0.0),\n+                new Point2D( 2.0,  2.0),\n+                new Point2D( 0.0,  2.0)\n+            }\n+        };\n+        PolygonsSet set1 = buildSet(vertices1);\n+        Point2D[][] vertices2 = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D( 1.0,  1.0),\n+                new Point2D( 3.0,  1.0),\n+                new Point2D( 3.0,  3.0),\n+                new Point2D( 1.0,  3.0)\n+            }\n+        };\n+        PolygonsSet set2 = buildSet(vertices2);\n+        PolygonsSet set  = (PolygonsSet) Region.intersection(set1.copySelf(),\n+                                                             set2.copySelf());\n+        checkVertices(set1.getVertices(), vertices1);\n+        checkVertices(set2.getVertices(), vertices2);\n+        checkVertices(set.getVertices(), new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D( 1.0,  1.0),\n+                new Point2D( 2.0,  1.0),\n+                new Point2D( 2.0,  2.0),\n+                new Point2D( 1.0,  2.0)\n+            }\n+        });\n+        checkPoints(Region.Location.INSIDE, set, new Point2D[] {\n+            new Point2D(1.5, 1.5)\n+        });\n+        checkPoints(Region.Location.OUTSIDE, set, new Point2D[] {\n+            new Point2D(0.5, 1.5),\n+            new Point2D(2.5, 1.5),\n+            new Point2D(1.5, 0.5),\n+            new Point2D(0.5, 0.5)\n+        });\n+        checkPoints(Region.Location.BOUNDARY, set, new Point2D[] {\n+            new Point2D(1.0, 1.0),\n+            new Point2D(2.0, 2.0),\n+            new Point2D(1.0, 1.5),\n+            new Point2D(1.5, 2.0)\n+        });\n+    }\n+\n+    @Test\n+    public void testXor() {\n+        Point2D[][] vertices1 = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D( 0.0,  0.0),\n+                new Point2D( 2.0,  0.0),\n+                new Point2D( 2.0,  2.0),\n+                new Point2D( 0.0,  2.0)\n+            }\n+        };\n+        PolygonsSet set1 = buildSet(vertices1);\n+        Point2D[][] vertices2 = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D( 1.0,  1.0),\n+                new Point2D( 3.0,  1.0),\n+                new Point2D( 3.0,  3.0),\n+                new Point2D( 1.0,  3.0)\n+            }\n+        };\n+        PolygonsSet set2 = buildSet(vertices2);\n+        PolygonsSet set  = (PolygonsSet) Region.xor(set1.copySelf(),\n+                                                    set2.copySelf());\n+        checkVertices(set1.getVertices(), vertices1);\n+        checkVertices(set2.getVertices(), vertices2);\n+        checkVertices(set.getVertices(), new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D( 0.0,  0.0),\n+                new Point2D( 2.0,  0.0),\n+                new Point2D( 2.0,  1.0),\n+                new Point2D( 3.0,  1.0),\n+                new Point2D( 3.0,  3.0),\n+                new Point2D( 1.0,  3.0),\n+                new Point2D( 1.0,  2.0),\n+                new Point2D( 0.0,  2.0)\n+            },\n+            new Point2D[] {\n+                new Point2D( 1.0,  1.0),\n+                new Point2D( 1.0,  2.0),\n+                new Point2D( 2.0,  2.0),\n+                new Point2D( 2.0,  1.0)\n+            }\n+        });\n+        checkPoints(Region.Location.INSIDE, set, new Point2D[] {\n+            new Point2D(0.5, 0.5),\n+            new Point2D(2.5, 2.5),\n+            new Point2D(0.5, 1.5),\n+            new Point2D(1.5, 0.5),\n+            new Point2D(1.5, 2.5),\n+            new Point2D(2.5, 1.5),\n+            new Point2D(2.5, 2.5)\n+        });\n+        checkPoints(Region.Location.OUTSIDE, set, new Point2D[] {\n+            new Point2D(-0.5, 0.5),\n+            new Point2D( 0.5, 2.5),\n+            new Point2D( 2.5, 0.5),\n+            new Point2D( 1.5, 1.5),\n+            new Point2D( 3.5, 2.5)\n+        });\n+        checkPoints(Region.Location.BOUNDARY, set, new Point2D[] {\n+            new Point2D(1.0, 1.0),\n+            new Point2D(2.0, 2.0),\n+            new Point2D(1.5, 1.0),\n+            new Point2D(2.0, 1.5),\n+            new Point2D(0.0, 0.0),\n+            new Point2D(0.5, 2.0),\n+            new Point2D(2.0, 0.5),\n+            new Point2D(2.5, 1.0),\n+            new Point2D(3.0, 2.5)\n+        });\n+    }\n+\n+    @Test\n+    public void testDifference() {\n+        Point2D[][] vertices1 = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D( 0.0,  0.0),\n+                new Point2D( 2.0,  0.0),\n+                new Point2D( 2.0,  2.0),\n+                new Point2D( 0.0,  2.0)\n+            }\n+        };\n+        PolygonsSet set1 = buildSet(vertices1);\n+        Point2D[][] vertices2 = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D( 1.0,  1.0),\n+                new Point2D( 3.0,  1.0),\n+                new Point2D( 3.0,  3.0),\n+                new Point2D( 1.0,  3.0)\n+            }\n+        };\n+        PolygonsSet set2 = buildSet(vertices2);\n+        PolygonsSet set  = (PolygonsSet) Region.difference(set1.copySelf(),\n+                                                           set2.copySelf());\n+        checkVertices(set1.getVertices(), vertices1);\n+        checkVertices(set2.getVertices(), vertices2);\n+        checkVertices(set.getVertices(), new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D( 0.0,  0.0),\n+                new Point2D( 2.0,  0.0),\n+                new Point2D( 2.0,  1.0),\n+                new Point2D( 1.0,  1.0),\n+                new Point2D( 1.0,  2.0),\n+                new Point2D( 0.0,  2.0)\n+            }\n+        });\n+        checkPoints(Region.Location.INSIDE, set, new Point2D[] {\n+            new Point2D(0.5, 0.5),\n+            new Point2D(0.5, 1.5),\n+            new Point2D(1.5, 0.5)\n+        });\n+        checkPoints(Region.Location.OUTSIDE, set, new Point2D[] {\n+            new Point2D( 2.5, 2.5),\n+            new Point2D(-0.5, 0.5),\n+            new Point2D( 0.5, 2.5),\n+            new Point2D( 2.5, 0.5),\n+            new Point2D( 1.5, 1.5),\n+            new Point2D( 3.5, 2.5),\n+            new Point2D( 1.5, 2.5),\n+            new Point2D( 2.5, 1.5),\n+            new Point2D( 2.0, 1.5),\n+            new Point2D( 2.0, 2.0),\n+            new Point2D( 2.5, 1.0),\n+            new Point2D( 2.5, 2.5),\n+            new Point2D( 3.0, 2.5)\n+        });\n+        checkPoints(Region.Location.BOUNDARY, set, new Point2D[] {\n+            new Point2D(1.0, 1.0),\n+            new Point2D(1.5, 1.0),\n+            new Point2D(0.0, 0.0),\n+            new Point2D(0.5, 2.0),\n+            new Point2D(2.0, 0.5)\n+        });\n+    }\n+\n+    @Test\n+    public void testEmptyDifference() {\n+        Point2D[][] vertices1 = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D( 0.5, 3.5),\n+                new Point2D( 0.5, 4.5),\n+                new Point2D(-0.5, 4.5),\n+                new Point2D(-0.5, 3.5)\n+            }\n+        };\n+        PolygonsSet set1 = buildSet(vertices1);\n+        Point2D[][] vertices2 = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D( 1.0, 2.0),\n+                new Point2D( 1.0, 8.0),\n+                new Point2D(-1.0, 8.0),\n+                new Point2D(-1.0, 2.0)\n+            }\n+        };\n+        PolygonsSet set2 = buildSet(vertices2);\n+        Assert.assertTrue(Region.difference(set1.copySelf(), set2.copySelf()).isEmpty());\n+    }\n+\n+    @Test\n+    public void testChoppedHexagon() {\n+        double pi6   = FastMath.PI / 6.0;\n+        double sqrt3 = FastMath.sqrt(3.0);\n+        SubHyperplane[] hyp = {\n+            new SubHyperplane(new Line(new Point2D(   0.0, 1.0),  5 * pi6)),\n+            new SubHyperplane(new Line(new Point2D(-sqrt3, 1.0),  7 * pi6)),\n+            new SubHyperplane(new Line(new Point2D(-sqrt3, 1.0),  9 * pi6)),\n+            new SubHyperplane(new Line(new Point2D(-sqrt3, 0.0), 11 * pi6)),\n+            new SubHyperplane(new Line(new Point2D(   0.0, 0.0), 13 * pi6)),\n+            new SubHyperplane(new Line(new Point2D(   0.0, 1.0),  3 * pi6)),\n+            new SubHyperplane(new Line(new Point2D(-5.0 * sqrt3 / 6.0, 0.0), 9 * pi6))\n+        };\n+        hyp[1] =                              hyp[0].getHyperplane().split(hyp[1]).getMinus();\n+        hyp[2] =                              hyp[1].getHyperplane().split(hyp[2]).getMinus();\n+        hyp[3] =                              hyp[2].getHyperplane().split(hyp[3]).getMinus();\n+        hyp[4] = hyp[0].getHyperplane().split(hyp[3].getHyperplane().split(hyp[4]).getMinus()).getMinus();\n+        hyp[5] = hyp[0].getHyperplane().split(hyp[4].getHyperplane().split(hyp[5]).getMinus()).getMinus();\n+        hyp[6] = hyp[1].getHyperplane().split(hyp[3].getHyperplane().split(hyp[6]).getMinus()).getMinus();\n+        BSPTree tree = new BSPTree(Boolean.TRUE);\n+        for (int i = hyp.length - 1; i >= 0; --i) {\n+            tree = new BSPTree(hyp[i], new BSPTree(Boolean.FALSE), tree, null);\n+        }\n+        PolygonsSet set = new PolygonsSet(tree);\n+        SubHyperplane splitter =\n+            new SubHyperplane(new Line(new Point2D(-2.0 * sqrt3 / 3.0, 0.0), 9 * pi6));\n+        PolygonsSet slice =\n+            new PolygonsSet(new BSPTree(splitter,\n+                                        set.getTree(false).split(splitter).getPlus(),\n+                                        new BSPTree(Boolean.FALSE), null));\n+        Assert.assertEquals(Region.Location.OUTSIDE,\n+                            slice.checkPoint(new Point2D(0.1, 0.5)));\n+        Assert.assertEquals(11.0 / 3.0, slice.getBoundarySize(), 1.0e-10);\n+\n+    }\n+\n+    @Test\n+    public void testConcentric() {\n+        double h = FastMath.sqrt(3.0) / 2.0;\n+        Point2D[][] vertices1 = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D( 0.00, 0.1 * h),\n+                new Point2D( 0.05, 0.1 * h),\n+                new Point2D( 0.10, 0.2 * h),\n+                new Point2D( 0.05, 0.3 * h),\n+                new Point2D(-0.05, 0.3 * h),\n+                new Point2D(-0.10, 0.2 * h),\n+                new Point2D(-0.05, 0.1 * h)\n+            }\n+        };\n+        PolygonsSet set1 = buildSet(vertices1);\n+        Point2D[][] vertices2 = new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D( 0.00, 0.0 * h),\n+                new Point2D( 0.10, 0.0 * h),\n+                new Point2D( 0.20, 0.2 * h),\n+                new Point2D( 0.10, 0.4 * h),\n+                new Point2D(-0.10, 0.4 * h),\n+                new Point2D(-0.20, 0.2 * h),\n+                new Point2D(-0.10, 0.0 * h)\n+            }\n+        };\n+        PolygonsSet set2 = buildSet(vertices2);\n+        Assert.assertTrue(set2.contains(set1));\n+    }\n+\n+    @Test\n+    public void testBug20040520() {\n+        BSPTree a0 = new BSPTree(buildSegment(new Point2D(0.85, -0.05),\n+                                              new Point2D(0.90, -0.10)),\n+                                              new BSPTree(Boolean.FALSE),\n+                                              new BSPTree(Boolean.TRUE),\n+                                              null);\n+        BSPTree a1 = new BSPTree(buildSegment(new Point2D(0.85, -0.10),\n+                                              new Point2D(0.90, -0.10)),\n+                                              new BSPTree(Boolean.FALSE), a0, null);\n+        BSPTree a2 = new BSPTree(buildSegment(new Point2D(0.90, -0.05),\n+                                              new Point2D(0.85, -0.05)),\n+                                              new BSPTree(Boolean.FALSE), a1, null);\n+        BSPTree a3 = new BSPTree(buildSegment(new Point2D(0.82, -0.05),\n+                                              new Point2D(0.82, -0.08)),\n+                                              new BSPTree(Boolean.FALSE),\n+                                              new BSPTree(Boolean.TRUE),\n+                                              null);\n+        BSPTree a4 = new BSPTree(buildHalfLine(new Point2D(0.85, -0.05),\n+                                               new Point2D(0.80, -0.05),\n+                                               false),\n+                                               new BSPTree(Boolean.FALSE), a3, null);\n+        BSPTree a5 = new BSPTree(buildSegment(new Point2D(0.82, -0.08),\n+                                              new Point2D(0.82, -0.18)),\n+                                              new BSPTree(Boolean.FALSE),\n+                                              new BSPTree(Boolean.TRUE),\n+                                              null);\n+        BSPTree a6 = new BSPTree(buildHalfLine(new Point2D(0.82, -0.18),\n+                                               new Point2D(0.85, -0.15),\n+                                               true),\n+                                               new BSPTree(Boolean.FALSE), a5, null);\n+        BSPTree a7 = new BSPTree(buildHalfLine(new Point2D(0.85, -0.05),\n+                                               new Point2D(0.82, -0.08),\n+                                               false),\n+                                               a4, a6, null);\n+        BSPTree a8 = new BSPTree(buildLine(new Point2D(0.85, -0.25),\n+                                           new Point2D(0.85,  0.05)),\n+                                           a2, a7, null);\n+        BSPTree a9 = new BSPTree(buildLine(new Point2D(0.90,  0.05),\n+                                           new Point2D(0.90, -0.50)),\n+                                           a8, new BSPTree(Boolean.FALSE), null);\n+\n+        BSPTree b0 = new BSPTree(buildSegment(new Point2D(0.92, -0.12),\n+                                              new Point2D(0.92, -0.08)),\n+                                              new BSPTree(Boolean.FALSE), new BSPTree(Boolean.TRUE),\n+                                              null);\n+        BSPTree b1 = new BSPTree(buildHalfLine(new Point2D(0.92, -0.08),\n+                                               new Point2D(0.90, -0.10),\n+                                               true),\n+                                               new BSPTree(Boolean.FALSE), b0, null);\n+        BSPTree b2 = new BSPTree(buildSegment(new Point2D(0.92, -0.18),\n+                                              new Point2D(0.92, -0.12)),\n+                                              new BSPTree(Boolean.FALSE), new BSPTree(Boolean.TRUE),\n+                                              null);\n+        BSPTree b3 = new BSPTree(buildSegment(new Point2D(0.85, -0.15),\n+                                              new Point2D(0.90, -0.20)),\n+                                              new BSPTree(Boolean.FALSE), b2, null);\n+        BSPTree b4 = new BSPTree(buildSegment(new Point2D(0.95, -0.15),\n+                                              new Point2D(0.85, -0.05)),\n+                                              b1, b3, null);\n+        BSPTree b5 = new BSPTree(buildHalfLine(new Point2D(0.85, -0.05),\n+                                               new Point2D(0.85, -0.25),\n+                                               true),\n+                                               new BSPTree(Boolean.FALSE), b4, null);\n+        BSPTree b6 = new BSPTree(buildLine(new Point2D(0.0, -1.10),\n+                                           new Point2D(1.0, -0.10)),\n+                                           new BSPTree(Boolean.FALSE), b5, null);\n+\n+        PolygonsSet c = (PolygonsSet) Region.union(new PolygonsSet(a9),\n+                                                   new PolygonsSet(b6));\n+\n+        checkPoints(Region.Location.INSIDE, c, new Point2D[] {\n+            new Point2D(0.83, -0.06),\n+            new Point2D(0.83, -0.15),\n+            new Point2D(0.88, -0.15),\n+            new Point2D(0.88, -0.09),\n+            new Point2D(0.88, -0.07),\n+            new Point2D(0.91, -0.18),\n+            new Point2D(0.91, -0.10)\n+        });\n+\n+        checkPoints(Region.Location.OUTSIDE, c, new Point2D[] {\n+            new Point2D(0.80, -0.10),\n+            new Point2D(0.83, -0.50),\n+            new Point2D(0.83, -0.20),\n+            new Point2D(0.83, -0.02),\n+            new Point2D(0.87, -0.50),\n+            new Point2D(0.87, -0.20),\n+            new Point2D(0.87, -0.02),\n+            new Point2D(0.91, -0.20),\n+            new Point2D(0.91, -0.08),\n+            new Point2D(0.93, -0.15)\n+        });\n+\n+        checkVertices(c.getVertices(),\n+                      new Point2D[][] {\n+            new Point2D[] {\n+                new Point2D(0.85, -0.15),\n+                new Point2D(0.90, -0.20),\n+                new Point2D(0.92, -0.18),\n+                new Point2D(0.92, -0.08),\n+                new Point2D(0.90, -0.10),\n+                new Point2D(0.90, -0.05),\n+                new Point2D(0.82, -0.05),\n+                new Point2D(0.82, -0.18),\n+            }\n+        });\n+\n+    }\n+\n+    @Test\n+    public void testBug20041003() {\n+\n+        Line[] l = {\n+            new Line(new Point2D(0.0, 0.625000007541172),\n+                     new Point2D(1.0, 0.625000007541172)),\n+                     new Line(new Point2D(-0.19204433621902645, 0.0),\n+                              new Point2D(-0.19204433621902645, 1.0)),\n+                              new Line(new Point2D(-0.40303524786887,  0.4248364535319128),\n+                                       new Point2D(-1.12851149797877, -0.2634107480798909)),\n+                                       new Line(new Point2D(0.0, 2.0),\n+                                                new Point2D(1.0, 2.0))\n+        };\n+\n+        BSPTree node1 =\n+            new BSPTree(new SubHyperplane(l[0],\n+                                          new IntervalsSet(intersectionAbscissa(l[0], l[1]),\n+                                                           intersectionAbscissa(l[0], l[2]))),\n+                                                           new BSPTree(Boolean.TRUE), new BSPTree(Boolean.FALSE),\n+                                                           null);\n+        BSPTree node2 =\n+            new BSPTree(new SubHyperplane(l[1],\n+                                          new IntervalsSet(intersectionAbscissa(l[1], l[2]),\n+                                                           intersectionAbscissa(l[1], l[3]))),\n+                                                           node1, new BSPTree(Boolean.FALSE), null);\n+        BSPTree node3 =\n+            new BSPTree(new SubHyperplane(l[2],\n+                                          new IntervalsSet(intersectionAbscissa(l[2], l[3]),\n+                                                           Double.POSITIVE_INFINITY)),\n+                                                           node2, new BSPTree(Boolean.FALSE), null);\n+        BSPTree node4 =\n+            new BSPTree(new SubHyperplane(l[3]),\n+                        node3, new BSPTree(Boolean.FALSE), null);\n+\n+        PolygonsSet set = new PolygonsSet(node4);\n+        Assert.assertEquals(0, set.getVertices().length);\n+\n+    }\n+\n+    private PolygonsSet buildSet(Point2D[][] vertices) {\n+        ArrayList<SubHyperplane> edges = new ArrayList<SubHyperplane>();\n+        for (int i = 0; i < vertices.length; ++i) {\n+            int l = vertices[i].length;\n+            for (int j = 0; j < l; ++j) {\n+                edges.add(buildSegment(vertices[i][j], vertices[i][(j + 1) % l]));\n+            }\n+        }\n+        return new PolygonsSet(edges);\n+    }\n+\n+    private SubHyperplane buildLine(Point2D start, Point2D end) {\n+        return new SubHyperplane(new Line(start, end));\n+    }\n+\n+    private double intersectionAbscissa(Line l0, Line l1) {\n+        Point2D p = (Point2D) l0.intersection(l1);\n+        return ((Point1D) l0.toSubSpace(p)).getAbscissa();\n+    }\n+\n+    private SubHyperplane buildHalfLine(Point2D start, Point2D end,\n+                                        boolean startIsVirtual) {\n+        Line   line  = new Line(start, end);\n+        double lower = startIsVirtual\n+        ? Double.NEGATIVE_INFINITY\n+        : ((Point1D) line.toSubSpace(start)).getAbscissa();\n+        double upper = startIsVirtual\n+        ? ((Point1D) line.toSubSpace(end)).getAbscissa()\n+        : Double.POSITIVE_INFINITY;\n+        return new SubHyperplane(line, new IntervalsSet(lower, upper));\n+    }\n+\n+    private SubHyperplane buildSegment(Point2D start, Point2D end) {\n+        Line   line  = new Line(start, end);\n+        double lower = ((Point1D) line.toSubSpace(start)).getAbscissa();\n+        double upper = ((Point1D) line.toSubSpace(end)).getAbscissa();\n+        return new SubHyperplane(line, new IntervalsSet(lower, upper));\n+    }\n+\n+    private void checkPoints(Region.Location expected, PolygonsSet set,\n+                             Point2D[] points) {\n+        for (int i = 0; i < points.length; ++i) {\n+            Assert.assertEquals(expected, set.checkPoint(points[i]));\n+        }\n+    }\n+\n+    private boolean checkInSegment(Point2D p,\n+                                   Point2D p1, Point2D p2,\n+                                   double tolerance) {\n+        Line line = new Line(p1, p2);\n+        if (line.getOffset(p) < tolerance) {\n+            double x  = ((Point1D) line.toSubSpace(p)).getAbscissa();\n+            double x1 = ((Point1D) line.toSubSpace(p1)).getAbscissa();\n+            double x2 = ((Point1D) line.toSubSpace(p2)).getAbscissa();\n+            return (((x - x1) * (x - x2) <= 0.0)\n+                    || (p1.distance(p) < tolerance)\n+                    || (p2.distance(p) < tolerance));\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private void checkVertices(Point2D[][] rebuiltVertices,\n+                               Point2D[][] vertices) {\n+\n+        // each rebuilt vertex should be in a segment joining two original vertices\n+        for (int i = 0; i < rebuiltVertices.length; ++i) {\n+            for (int j = 0; j < rebuiltVertices[i].length; ++j) {\n+                boolean inSegment = false;\n+                Point2D p = rebuiltVertices[i][j];\n+                for (int k = 0; k < vertices.length; ++k) {\n+                    Point2D[] loop = vertices[k];\n+                    int length = loop.length;\n+                    for (int l = 0; (! inSegment) && (l < length); ++l) {\n+                        inSegment = checkInSegment(p, loop[l], loop[(l + 1) % length], 1.0e-10);\n+                    }\n+                }\n+                Assert.assertTrue(inSegment);\n+            }\n+        }\n+\n+        // each original vertex should have a corresponding rebuilt vertex\n+        for (int k = 0; k < vertices.length; ++k) {\n+            for (int l = 0; l < vertices[k].length; ++l) {\n+                double min = Double.POSITIVE_INFINITY;\n+                for (int i = 0; i < rebuiltVertices.length; ++i) {\n+                    for (int j = 0; j < rebuiltVertices[i].length; ++j) {\n+                        min = FastMath.min(vertices[k][l].distance(rebuiltVertices[i][j]),\n+                                       min);\n+                    }\n+                }\n+                Assert.assertEquals(0.0, min, 1.0e-10);\n+            }\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/geometry/partitioning/utilities/AVLTreeTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.partitioning.utilities;\n+\n+import org.apache.commons.math.geometry.partitioning.utilities.AVLTree;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class AVLTreeTest {\n+\n+    @Test\n+    public void testInsert() {\n+        // this array in this order allows to pass in all branches\n+        // of the insertion algorithm\n+        int[] array = { 16, 13, 15, 14,  2,  0, 12,  9,  8,  5,\n+            11, 18, 19, 17,  4,  7,  1,  3,  6, 10 };\n+        AVLTree<Integer> tree = buildTree(array);\n+\n+        Assert.assertEquals(array.length, tree.size());\n+\n+        for (int i = 0; i < array.length; ++i) {\n+            Assert.assertEquals(array[i], value(tree.getNotSmaller(new Integer(array[i]))));\n+        }\n+\n+        checkOrder(tree);\n+\n+    }\n+\n+    @Test\n+    public void testDelete1() {\n+        int[][][] arrays = {\n+            { { 16, 13, 15, 14, 2, 0, 12, 9, 8, 5, 11, 18, 19, 17, 4, 7, 1, 3, 6, 10 },\n+                { 11, 10, 9, 12, 16, 15, 13, 18, 5, 0, 3, 2, 14, 6, 19, 17, 8, 4, 7, 1 } },\n+                { { 16, 13, 15, 14, 2, 0, 12, 9, 8, 5, 11, 18, 19, 17, 4, 7, 1, 3, 6, 10 },\n+                    { 0, 17, 14, 15, 16, 18,  6 } },\n+                    { { 6, 2, 7, 8, 1, 4, 3, 5 }, { 8 } },\n+                    { { 6, 2, 7, 8, 1, 4, 5 }, { 8 } },\n+                    { { 3, 7, 2, 1, 5, 8, 4 }, { 1 } },\n+                    { { 3, 7, 2, 1, 5, 8, 6 }, { 1 } }\n+        };\n+        for (int i = 0; i < arrays.length; ++i) {\n+            AVLTree<Integer> tree = buildTree(arrays[i][0]);\n+            Assert.assertTrue(! tree.delete(new Integer(-2000)));\n+            for (int j = 0; j < arrays[i][1].length; ++j) {\n+                Assert.assertTrue(tree.delete(tree.getNotSmaller(new Integer(arrays[i][1][j])).getElement()));\n+                Assert.assertEquals(arrays[i][0].length - j - 1, tree.size());\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testNavigation() {\n+        int[] array = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+        AVLTree<Integer> tree = buildTree(array);\n+\n+        AVLTree<Integer>.Node node = tree.getSmallest();\n+        Assert.assertEquals(array[0], value(node));\n+        for (int i = 0; i < array.length; ++i) {\n+            Assert.assertEquals(array[i], value(node));\n+            node = node.getNext();\n+        }\n+        Assert.assertNull(node);\n+\n+        node = tree.getLargest();\n+        Assert.assertEquals(array[array.length - 1], value(node));\n+        for (int i = array.length - 1; i >= 0; --i) {\n+            Assert.assertEquals(array[i], value(node));\n+            node = node.getPrevious();\n+        }\n+        Assert.assertNull(node);\n+\n+        checkOrder(tree);\n+\n+    }\n+\n+    @Test\n+    public void testSearch() {\n+        int[] array = { 2, 4, 6, 8, 10, 12, 14 };\n+        AVLTree<Integer> tree = buildTree(array);\n+\n+        Assert.assertNull(tree.getNotLarger(new Integer(array[0] - 1)));\n+        Assert.assertNull(tree.getNotSmaller(new Integer(array[array.length - 1] + 1)));\n+\n+        for (int i = 0; i < array.length; ++i) {\n+            Assert.assertEquals(array[i],\n+                                value(tree.getNotSmaller(new Integer(array[i] - 1))));\n+            Assert.assertEquals(array[i],\n+                                value(tree.getNotLarger(new Integer(array[i] + 1))));\n+        }\n+\n+        checkOrder(tree);\n+\n+    }\n+\n+    @Test\n+    public void testRepetition() {\n+        int[] array = { 1, 1, 3, 3, 4, 5, 6, 7, 7, 7, 7, 7 };\n+        AVLTree<Integer> tree = buildTree(array);\n+        Assert.assertEquals(array.length, tree.size());\n+\n+        AVLTree<Integer>.Node node = tree.getNotSmaller(new Integer(3));\n+        Assert.assertEquals(3, value(node));\n+        Assert.assertEquals(1, value(node.getPrevious()));\n+        Assert.assertEquals(3, value(node.getNext()));\n+        Assert.assertEquals(4, value(node.getNext().getNext()));\n+\n+        node = tree.getNotLarger(new Integer(2));\n+        Assert.assertEquals(1, value(node));\n+        Assert.assertEquals(1, value(node.getPrevious()));\n+        Assert.assertEquals(3, value(node.getNext()));\n+        Assert.assertNull(node.getPrevious().getPrevious());\n+\n+        AVLTree<Integer>.Node otherNode = tree.getNotSmaller(new Integer(1));\n+        Assert.assertTrue(node != otherNode);\n+        Assert.assertEquals(1, value(otherNode));\n+        Assert.assertNull(otherNode.getPrevious());\n+\n+        node = tree.getNotLarger(new Integer(10));\n+        Assert.assertEquals(7, value(node));\n+        Assert.assertNull(node.getNext());\n+        node = node.getPrevious();\n+        Assert.assertEquals(7, value(node));\n+        node = node.getPrevious();\n+        Assert.assertEquals(7, value(node));\n+        node = node.getPrevious();\n+        Assert.assertEquals(7, value(node));\n+        node = node.getPrevious();\n+        Assert.assertEquals(7, value(node));\n+        node = node.getPrevious();\n+        Assert.assertEquals(6, value(node));\n+\n+        checkOrder(tree);\n+\n+    }\n+\n+    private AVLTree<Integer> buildTree(int[] array) {\n+        AVLTree<Integer> tree = new AVLTree<Integer>();\n+        for (int i = 0; i < array.length; ++i) {\n+            tree.insert(new Integer(array[i]));\n+            tree.insert(null);\n+        }\n+        return tree;\n+    }\n+\n+    private int value(AVLTree<Integer>.Node node) {\n+        return ((Integer) node.getElement()).intValue();\n+    }\n+\n+    private void checkOrder(AVLTree<Integer> tree) {\n+        AVLTree<Integer>.Node next = null;\n+        for (AVLTree<Integer>.Node node = tree.getSmallest();\n+        node != null;\n+        node = next) {\n+            next = node.getNext();\n+            if (next != null) {\n+                Assert.assertTrue(node.getElement().compareTo(next.getElement()) <= 0);\n+            }\n+        }\n+    }\n+\n+}", "timestamp": 1305475325, "metainfo": ""}