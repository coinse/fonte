{"sha": "e6275ff1701d45b9743a02c39206652f3be04034", "log": "Replaced the misused clone method in step interpolators by a dedicated copy method that handles steps finalization automatically and hence may trigger DerivativeException. This should simplify usage and avoid nasty errors caused by forgotten finalization  ", "commit": "\n--- a/src/java/org/apache/commons/math/ode/AbstractStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/AbstractStepInterpolator.java\n  */\n \n public abstract class AbstractStepInterpolator\n-  implements StepInterpolator, Cloneable {\n+  implements StepInterpolator {\n \n   /** previous time */\n   protected double previousTime;\n   }\n \n   /** Copy the instance.\n-\n-  * <p>The copied interpolator should have been finalized before the\n-  * copy, otherwise the copy will not be able to perform correctly any\n-  * interpolation and will throw a {@link NullPointerException}\n-  * later. Since we don't want this constructor to throw the\n-  * exceptions finalization may involve and since we don't want this\n-  * method to modify the state of the copied interpolator,\n-  * finalization is <strong>not</strong> done automatically, it\n-  * remains under user control.</p>\n-\n-  * <p>The copy is a deep copy: its arrays are separated from the\n-  * original arrays of the instance.</p>\n-\n-  * <p>This method has been redeclared as public instead of protected.</p>\n-\n-  * @return a copy of the instance.\n-\n-  */\n-  public Object clone() {\n-    try {\n-      return super.clone();\n-    } catch (CloneNotSupportedException cnse) {\n-      // should never happen\n-      return null;\n-    }\n-  }\n+   * <p>The copied instance is guaranteed to be independent from the\n+   * original one. Both can be used with different settings for\n+   * interpolated time without any side effect.</p>\n+   * @return a deep copy of the instance, which can be used independently.\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   * @see #setInterpolatedTime(double)\n+   */\n+   public StepInterpolator copy() throws DerivativeException {\n+\n+     // finalize the step before performing copy\n+     finalizeStep();\n+\n+     // create the new independent instance\n+     return doCopy();\n+\n+   }\n+\n+   /** Really copy the finalized instance.\n+    * <p>This method is called by {@link #copy()} after the\n+    * step has been finalized. It must perform a deep copy\n+    * to have an new instance completely independent for the\n+    * original instance.\n+    */\n+   protected abstract StepInterpolator doCopy();\n \n   /** Shift one step forward.\n    * Copy the current time into the previous time, hence preparing the\n--- a/src/java/org/apache/commons/math/ode/ClassicalRungeKuttaStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/ClassicalRungeKuttaStepInterpolator.java\n     super(interpolator);\n   }\n \n-  /**\n-   * Clone the instance.\n-   * the copy is a deep copy: its arrays are separated from the\n-   * original arrays of the instance\n-   * @return a copy of the instance\n+  /** Really copy the finalized instance.\n    */\n-  public Object clone() {\n+  protected StepInterpolator doCopy() {\n     return new ClassicalRungeKuttaStepInterpolator(this);\n   }\n \n--- a/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n+++ b/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n \n   /** Append another model at the end of the instance.\n    * @param model model to add at the end of the instance\n+   * @exception DerivativeException if some step interpolators from\n+   * the appended model cannot be copied\n    * @exception IllegalArgumentException if the model to append is not\n    * compatible with the instance (dimension of the state vector,\n    * propagation direction, hole between the dates)\n    */\n-  public void append(ContinuousOutputModel model) {\n+  public void append(ContinuousOutputModel model)\n+    throws DerivativeException {\n \n     if (model.steps.size() == 0) {\n       return;\n     }\n \n     for (Iterator iter = model.steps.iterator(); iter.hasNext(); ) {\n-      AbstractStepInterpolator ai = (AbstractStepInterpolator) iter.next();\n-      steps.add(ai.clone());\n+      steps.add(((AbstractStepInterpolator) iter.next()).copy());\n     }\n \n     index = steps.size() - 1;\n       forward     = interpolator.isForward();\n     }\n \n-    ai.finalizeStep();\n-    steps.add(ai.clone());\n+    steps.add(ai.copy());\n \n     if (isLast) {\n       finalTime = ai.getCurrentTime();\n--- a/src/java/org/apache/commons/math/ode/DormandPrince54StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/DormandPrince54StepInterpolator.java\n \n   }\n \n-  /**\n-   * Clone the instance.\n-   * the copy is a deep copy: its arrays are separated from the\n-   * original arrays of the instance\n-   * @return a copy of the instance\n+  /** Really copy the finalized instance.\n    */\n-  public Object clone() {\n+  protected StepInterpolator doCopy() {\n     return new DormandPrince54StepInterpolator(this);\n   }\n+\n \n   /** Reinitialize the instance\n    * @param equations set of differential equations being integrated\n--- a/src/java/org/apache/commons/math/ode/DormandPrince853StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/DormandPrince853StepInterpolator.java\n   public DormandPrince853StepInterpolator() {\n     super();\n     yDotKLast = null;\n-    yTmp      = null;\n     v         = null;\n     vectorsInitialized = false;\n   }\n \n     }\n \n-    // the step has been finalized, we don't need this anymore\n-    yTmp = null;\n-\n-  }\n-\n-  /**\n-   * Clone the instance.\n-   * the copy is a deep copy: its arrays are separated from the\n-   * original arrays of the instance\n-   * @return a copy of the instance\n-   */\n-  public Object clone() {\n+  }\n+\n+  /** Really copy the finalized instance.\n+   */\n+  protected StepInterpolator doCopy() {\n     return new DormandPrince853StepInterpolator(this);\n   }\n \n       yDotKLast[k] = new double[dimension];\n     }\n \n-    yTmp = new double[dimension];\n-\n     v = new double[7][];\n     for (int k = 0; k < v.length; ++k) {\n       v[k]  = new double[dimension];\n   protected void doFinalize()\n     throws DerivativeException {\n \n+    if (currentState == null) {\n+      // we are finalizing an uninitialized instance\n+      return;\n+    }\n+\n     double s;\n+    double[] yTmp = new double[currentState.length];\n \n     // k14\n     for (int j = 0; j < currentState.length; ++j) {\n \n   /** Last evaluations. */\n   private double[][] yDotKLast;\n-\n-  /** Temporary state vector. */\n-  private double[] yTmp;\n \n   /** Vectors for interpolation. */\n   private double[][] v;\n \n   };\n \n-  private static final long serialVersionUID = 4165537490327432186L;\n+  private static final long serialVersionUID = 7152276390558450974L;\n \n }\n--- a/src/java/org/apache/commons/math/ode/DummyStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/DummyStepInterpolator.java\n     super(y, forward);\n   }\n \n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public DummyStepInterpolator(DummyStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** Really copy the finalized instance.\n+   */\n+  protected StepInterpolator doCopy() {\n+    return new DummyStepInterpolator(this);\n+  }\n+\n   /** Compute the state at the interpolated time.\n    * In this class, this method does nothing: the interpolated state\n    * is always the state at the end of the current step.\n--- a/src/java/org/apache/commons/math/ode/EulerStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/EulerStepInterpolator.java\n     super(interpolator);\n   }\n \n-  /**\n-   * Clone the instance.\n-   * the copy is a deep copy: its arrays are separated from the\n-   * original arrays of the instance\n-   * @return a copy of the instance\n+  /** Really copy the finalized instance.\n    */\n-  public Object clone() {\n+  protected StepInterpolator doCopy() {\n     return new EulerStepInterpolator(this);\n   }\n+\n \n   /** Compute the state at the interpolated time.\n    * This is the main processing method that should be implemented by\n--- a/src/java/org/apache/commons/math/ode/GillStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/GillStepInterpolator.java\n     super(interpolator);\n   }\n \n-  /**\n-   * Clone the instance.\n-   * the copy is a deep copy: its arrays are separated from the\n-   * original arrays of the instance\n-   * @return a copy of the instance\n+  /** Really copy the finalized instance.\n    */\n-  public Object clone() {\n+  protected StepInterpolator doCopy() {\n     return new GillStepInterpolator(this);\n   }\n+\n \n   /** Compute the state at the interpolated time.\n    * This is the main processing method that should be implemented by\n--- a/src/java/org/apache/commons/math/ode/GraggBulirschStoerStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/GraggBulirschStoerStepInterpolator.java\n \n   }\n \n-  /**\n-   * Clone the instance.\n-   * the copy is a deep copy: its arrays are separated from the\n-   * original arrays of the instance\n-   * @return a copy of the instance\n-   */\n-  public Object clone() {\n+  /** Really copy the finalized instance.\n+   */\n+  protected StepInterpolator doCopy() {\n     return new GraggBulirschStoerStepInterpolator(this);\n   }\n+\n \n   /** Compute the interpolation coefficients for dense output.\n    * @param mu degree of the interpolation polynom\n--- a/src/java/org/apache/commons/math/ode/HighamHall54StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/HighamHall54StepInterpolator.java\n     super(interpolator);\n   }\n \n-  /**\n-   * Clone the instance.\n-   * the copy is a deep copy: its arrays are separated from the\n-   * original arrays of the instance\n-   * @return a copy of the instance\n+  /** Really copy the finalized instance.\n    */\n-  public Object clone() {\n+  protected StepInterpolator doCopy() {\n     return new HighamHall54StepInterpolator(this);\n   }\n+\n \n   /** Compute the state at the interpolated time.\n    * @param theta normalized interpolation abscissa within the step\n--- a/src/java/org/apache/commons/math/ode/MidpointStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/MidpointStepInterpolator.java\n     super(interpolator);\n   }\n \n-  /**\n-   * Clone the instance.\n-   * the copy is a deep copy: its arrays are separated from the\n-   * original arrays of the instance\n-   * @return a copy of the instance\n+  /** Really copy the finalized instance.\n    */\n-  public Object clone() {\n+  protected StepInterpolator doCopy() {\n     return new MidpointStepInterpolator(this);\n   }\n+\n \n   /** Compute the state at the interpolated time.\n    * This is the main processing method that should be implemented by\n--- a/src/java/org/apache/commons/math/ode/RungeKuttaFehlbergIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/RungeKuttaFehlbergIntegrator.java\n     // set up an interpolator sharing the integrator arrays\n     AbstractStepInterpolator interpolator;\n     if (handler.requiresDenseOutput() || (! switchesHandler.isEmpty())) {\n-      RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.clone();\n+      RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n       rki.reinitialize(equations, yTmp, yDotK, forward);\n       interpolator = rki;\n     } else {\n--- a/src/java/org/apache/commons/math/ode/RungeKuttaIntegrator.java\n+++ b/src/java/org/apache/commons/math/ode/RungeKuttaIntegrator.java\n     // set up an interpolator sharing the integrator arrays\n     AbstractStepInterpolator interpolator;\n     if (handler.requiresDenseOutput() || (! switchesHandler.isEmpty())) {\n-      RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.clone();\n+      RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n       rki.reinitialize(equations, yTmp, yDotK, forward);\n       interpolator = rki;\n     } else {\n--- a/src/java/org/apache/commons/math/ode/StepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/StepInterpolator.java\n     \n   /**\n    * Set the time of the interpolated point.\n-   * <p>Setting the time outside of the current step is now allowed\n-   * (it was not allowed up to version 5.4 of Mantissa), but should be\n-   * used with care since the accuracy of the interpolator will\n+   * <p>Setting the time outside of the current step is now allowed, but\n+   * should be used with care since the accuracy of the interpolator will\n    * probably be very poor far from this step. This allowance has been\n    * added to simplify implementation of search algorithms near the\n    * step endpoints.</p>\n+   * <p>Setting the time changes the instance internal state. If a\n+   * specific state must be preserved, a copy of the instance must be\n+   * created using {@link #copy()}.</p>\n    * @param time time of the interpolated point\n    * @throws DerivativeException if this call induces an automatic\n    * step finalization that throws one\n    */\n   public boolean isForward();\n \n+  /** Copy the instance.\n+   * <p>The copied instance is guaranteed to be independent from the\n+   * original one. Both can be used with different settings for\n+   * interpolated time without any side effect.</p>\n+   * @return a deep copy of the instance, which can be used independently.\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   * @see #setInterpolatedTime(double)\n+   */\n+   public StepInterpolator copy() throws DerivativeException;\n+\n }\n--- a/src/java/org/apache/commons/math/ode/ThreeEighthesStepInterpolator.java\n+++ b/src/java/org/apache/commons/math/ode/ThreeEighthesStepInterpolator.java\n     super(interpolator);\n   }\n \n-  /**\n-   * Clone the instance.\n-   * the copy is a deep copy: its arrays are separated from the\n-   * original arrays of the instance\n-   * @return a copy of the instance\n+  /** Really copy the finalized instance.\n    */\n-  public Object clone() {\n+  protected StepInterpolator doCopy() {\n     return new ThreeEighthesStepInterpolator(this);\n   }\n+\n \n   /** Compute the state at the interpolated time.\n    * This is the main processing method that should be implemented by\n--- a/src/test/org/apache/commons/math/ode/DormandPrince54StepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/DormandPrince54StepInterpolatorTest.java\n \n   }\n \n+  public void testClone()\n+    throws DerivativeException, IntegratorException {\n+      TestProblem3 pb = new TestProblem3(0.9);\n+      double minStep = 0;\n+      double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+      double scalAbsoluteTolerance = 1.0e-8;\n+      double scalRelativeTolerance = scalAbsoluteTolerance;\n+      DormandPrince54Integrator integ = new DormandPrince54Integrator(minStep, maxStep,\n+                                                                      scalAbsoluteTolerance,\n+                                                                      scalRelativeTolerance);\n+      integ.setStepHandler(new StepHandler() {\n+          public void handleStep(StepInterpolator interpolator, boolean isLast)\n+          throws DerivativeException {\n+              StepInterpolator cloned = interpolator.copy();\n+              double tA = cloned.getPreviousTime();\n+              double tB = cloned.getCurrentTime();\n+              double halfStep = Math.abs(tB - tA) / 2;\n+              assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+              assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+              for (int i = 0; i < 10; ++i) {\n+                  double t = (i * tB + (9 - i) * tA) / 9;\n+                  interpolator.setInterpolatedTime(t);\n+                  assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                  cloned.setInterpolatedTime(t);\n+                  assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                  double[] referenceState = interpolator.getInterpolatedState();\n+                  double[] cloneState     = cloned.getInterpolatedState();\n+                  for (int j = 0; j < referenceState.length; ++j) {\n+                      assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                  }\n+              }\n+          }\n+          public boolean requiresDenseOutput() {\n+              return true;\n+          }\n+          public void reset() {\n+          }\n+      });\n+      integ.integrate(pb,\n+              pb.getInitialTime(), pb.getInitialState(),\n+              pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+  }\n+\n   public static Test suite() {\n     return new TestSuite(DormandPrince54StepInterpolatorTest.class);\n   }\n--- a/src/test/org/apache/commons/math/ode/DormandPrince853StepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/DormandPrince853StepInterpolatorTest.java\n \n   }\n \n+  public void testClone()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    DormandPrince853Integrator integ = new DormandPrince853Integrator(minStep, maxStep,\n+                                                                      scalAbsoluteTolerance,\n+                                                                      scalRelativeTolerance);\n+    integ.setStepHandler(new StepHandler() {\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+        throws DerivativeException {\n+            StepInterpolator cloned = interpolator.copy();\n+            double tA = cloned.getPreviousTime();\n+            double tB = cloned.getCurrentTime();\n+            double halfStep = Math.abs(tB - tA) / 2;\n+            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+            for (int i = 0; i < 10; ++i) {\n+                double t = (i * tB + (9 - i) * tA) / 9;\n+                interpolator.setInterpolatedTime(t);\n+                assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                cloned.setInterpolatedTime(t);\n+                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                double[] referenceState = interpolator.getInterpolatedState();\n+                double[] cloneState     = cloned.getInterpolatedState();\n+                for (int j = 0; j < referenceState.length; ++j) {\n+                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                }\n+            }\n+        }\n+        public boolean requiresDenseOutput() {\n+            return true;\n+        }\n+        public void reset() {\n+        }\n+    });\n+    integ.integrate(pb,\n+            pb.getInitialTime(), pb.getInitialState(),\n+            pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+  }\n+\n   public static Test suite() {\n     return new TestSuite(DormandPrince853StepInterpolatorTest.class);\n   }\n--- a/src/test/org/apache/commons/math/ode/GraggBulirschStoerStepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/GraggBulirschStoerStepInterpolatorTest.java\n \n   }\n \n+  public void testClone()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    GraggBulirschStoerIntegrator integ = new GraggBulirschStoerIntegrator(minStep, maxStep,\n+                                                                          scalAbsoluteTolerance,\n+                                                                          scalRelativeTolerance);\n+    integ.setStepHandler(new StepHandler() {\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+        throws DerivativeException {\n+            StepInterpolator cloned = interpolator.copy();\n+            double tA = cloned.getPreviousTime();\n+            double tB = cloned.getCurrentTime();\n+            double halfStep = Math.abs(tB - tA) / 2;\n+            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+            for (int i = 0; i < 10; ++i) {\n+                double t = (i * tB + (9 - i) * tA) / 9;\n+                interpolator.setInterpolatedTime(t);\n+                assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                cloned.setInterpolatedTime(t);\n+                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                double[] referenceState = interpolator.getInterpolatedState();\n+                double[] cloneState     = cloned.getInterpolatedState();\n+                for (int j = 0; j < referenceState.length; ++j) {\n+                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                }\n+            }\n+        }\n+        public boolean requiresDenseOutput() {\n+            return true;\n+        }\n+        public void reset() {\n+        }\n+    });\n+    integ.integrate(pb,\n+            pb.getInitialTime(), pb.getInitialState(),\n+            pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+  }\n+\n   public static Test suite() {\n     return new TestSuite(GraggBulirschStoerStepInterpolatorTest.class);\n   }\n--- a/src/test/org/apache/commons/math/ode/HighamHall54StepInterpolatorTest.java\n+++ b/src/test/org/apache/commons/math/ode/HighamHall54StepInterpolatorTest.java\n \n   }\n \n+  public void testClone()\n+  throws DerivativeException, IntegratorException {\n+    TestProblem3 pb = new TestProblem3(0.9);\n+    double minStep = 0;\n+    double maxStep = pb.getFinalTime() - pb.getInitialTime();\n+    double scalAbsoluteTolerance = 1.0e-8;\n+    double scalRelativeTolerance = scalAbsoluteTolerance;\n+    HighamHall54Integrator integ = new HighamHall54Integrator(minStep, maxStep,\n+                                                              scalAbsoluteTolerance,\n+                                                              scalRelativeTolerance);\n+    integ.setStepHandler(new StepHandler() {\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+        throws DerivativeException {\n+            StepInterpolator cloned = interpolator.copy();\n+            double tA = cloned.getPreviousTime();\n+            double tB = cloned.getCurrentTime();\n+            double halfStep = Math.abs(tB - tA) / 2;\n+            assertEquals(interpolator.getPreviousTime(), tA, 1.0e-12);\n+            assertEquals(interpolator.getCurrentTime(), tB, 1.0e-12);\n+            for (int i = 0; i < 10; ++i) {\n+                double t = (i * tB + (9 - i) * tA) / 9;\n+                interpolator.setInterpolatedTime(t);\n+                assertTrue(Math.abs(cloned.getInterpolatedTime() - t) > (halfStep / 10));\n+                cloned.setInterpolatedTime(t);\n+                assertEquals(t, cloned.getInterpolatedTime(), 1.0e-12);\n+                double[] referenceState = interpolator.getInterpolatedState();\n+                double[] cloneState     = cloned.getInterpolatedState();\n+                for (int j = 0; j < referenceState.length; ++j) {\n+                    assertEquals(referenceState[j], cloneState[j], 1.0e-12);\n+                }\n+            }\n+        }\n+        public boolean requiresDenseOutput() {\n+            return true;\n+        }\n+        public void reset() {\n+        }\n+    });\n+    integ.integrate(pb,\n+            pb.getInitialTime(), pb.getInitialState(),\n+            pb.getFinalTime(), new double[pb.getDimension()]);\n+\n+  }\n+\n   public static Test suite() {\n     return new TestSuite(HighamHall54StepInterpolatorTest.class);\n   }", "timestamp": 1193836592, "metainfo": ""}