{"sha": "0221dccf153d57cc8fccc7f40f377f2118ff52b8", "log": "MATH-795: in RealVectorAbstractTest, created an array of specific entry values to be tested. Generalized its use in some unit tests.   ", "commit": "\n--- a/src/test/java/org/apache/commons/math3/linear/RealVectorAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math3/linear/RealVectorAbstractTest.java\n     };\n \n     /**\n+     * <p>\n+     * This is an attempt at covering most particular cases of combining two\n+     * values. Here {@code x} is the value returned by\n+     * {@link #getPreferredEntryValue()}, while {@code y} and {@code z} are two\n+     * \"normal\" values.\n+     * </p>\n+     * <ol>\n+     *   <li>\n+     *     Addition: the following cases should be covered\n+     *     <ul>\n+     *       <li>{@code (2 * x) + (-x)}</li>\n+     *       <li>{@code (-x) + 2 * x}</li>\n+     *       <li>{@code x + y}</li>\n+     *       <li>{@code y + x}</li>\n+     *       <li>{@code y + z}</li>\n+     *       <li>{@code y + (x - y)}</li>\n+     *       <li>{@code (y - x) + x}</li>\n+     *     </ul>\n+     *     The values to be considered are:\n+     *     {@code x, y, z, 2 * x, -x, x - y, y - x}.\n+     *   </li>\n+     *   <li>\n+     *     Subtraction: the following cases should be covered\n+     *     <ul>\n+     *       <li>{@code (2 * x) - x}</li>\n+     *       <li>{@code x - y}</li>\n+     *       <li>{@code y - x}</li>\n+     *       <li>{@code y - z}</li>\n+     *       <li>{@code y - (y - x)}</li>\n+     *       <li>{@code (y + x) - y}</li>\n+     *     </ul>\n+     *     The values to be considered are: {@code x, y, z, x + y, y - x}.\n+     *   </li>\n+     *   <li>\n+     *     Multiplication\n+     *     <ul>\n+     *       <li>{@code (x * x) * (1 / x)}</li>\n+     *       <li>{@code (1 / x) * (x * x)}</li>\n+     *       <li>{@code x * y}</li>\n+     *       <li>{@code y * x}</li>\n+     *       <li>{@code y * z}</li>\n+     *     </ul>\n+     *     The values to be considered are: {@code x, y, z, 1 / x, x * x}.\n+     *   </li>\n+     *   <li>\n+     *     Division\n+     *     <ul>\n+     *       <li>{@code (x * x) / x}</li>\n+     *       <li>{@code x / y}</li>\n+     *       <li>{@code y / x}</li>\n+     *       <li>{@code y / z}</li>\n+     *     </ul>\n+     *     The values to be considered are: {@code x, y, z, x * x}.\n+     *   </li>\n+     * </ol>\n+     * Also to be considered {@code NaN}, {@code POSITIVE_INFINITY},\n+     * {@code NEGATIVE_INFINITY}, {@code +0.0}, {@code -0.0}.\n+     */\n+    private final double[] values;\n+\n+    /**\n      * Creates a new instance of {@link RealVector}, with specified entries.\n      * The returned vector must be of the type currently tested. It should be\n      * noted that some tests assume that no references to the specified\n         final double x = getPreferredEntryValue();\n         data1 = new double[] {x, 1d, 2d, x, x};\n         data2 = new double[] {x, x, 3d, x, 4d, x};\n+        /*\n+         * Make sure that x, y, z are three different values. Also, x is the\n+         * preferred value (e.g. the value which is not stored in sparse\n+         * implementations).\n+         */\n+        final double y = x + 1d;\n+        final double z = y + 1d;\n+\n+        values =\n+            new double[] {\n+                Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY,\n+                0d, -0d, x, y, z, 2 * x, -x, 1 / x, x * x, x + y, x - y, y - x\n+            };\n     }\n \n     // tolerances\n     }\n \n     private void doTestEbeBinaryOperation(final BinaryOperation op, final boolean mixed) {\n-        /*\n-         * Make sure that x, y, z are three different values. Also, x is the\n-         * preferred value (e.g. the value which is not stored in sparse\n-         * implementations).\n-         */\n-        final double x = getPreferredEntryValue();\n-        final double y = x + 1d;\n-        final double z = y + 1d;\n-\n-        /*\n-         * This is an attempt at covering most particular cases of combining\n-         * two values.\n-         *\n-         * 1. Addition\n-         *    --------\n-         * The following cases should be covered\n-         * (2 * x) + (-x)\n-         * (-x) + 2 * x\n-         * x + y\n-         * y + x\n-         * y + z\n-         * y + (x - y)\n-         * (y - x) + x\n-         *\n-         * The values to be considered are: x, y, z, 2 * x, -x, x - y, y - x.\n-         *\n-         * 2. Subtraction\n-         *    -----------\n-         * The following cases should be covered\n-         * (2 * x) - x\n-         * x - y\n-         * y - x\n-         * y - z\n-         * y - (y - x)\n-         * (y + x) - y\n-         *\n-         * The values to be considered are: x, y, z, x + y, y - x.\n-         *\n-         * 3. Multiplication\n-         *    --------------\n-         * (x * x) * (1 / x)\n-         * (1 / x) * (x * x)\n-         * x * y\n-         * y * x\n-         * y * z\n-         *\n-         * The values to be considered are: x, y, z, 1 / x, x * x.\n-         *\n-         * 4. Division\n-         *    --------\n-         * (x * x) / x\n-         * x / y\n-         * y / x\n-         * y / z\n-         *\n-         * The values to be considered are: x, y, z, x * x.\n-         *\n-         * Also to be considered NaN, POSITIVE_INFINITY, NEGATIVE_INFINITY,\n-         * +0.0, -0.0.\n-         */\n-        final double[] values =\n-            {\n-                Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY,\n-                0d, -0d, x, y, z, 2 * x, -x, 1 / x, x * x, x + y, x - y, y - x\n-            };\n         final double[] data1 = new double[values.length * values.length];\n         final double[] data2 = new double[values.length * values.length];\n         int k = 0;\n     }\n \n     private void doTestMapBinaryOperation(final BinaryOperation op, final boolean inPlace) {\n-        final double x = getPreferredEntryValue();\n-        final double y = x + 1d;\n-        final double z = y + 1d;\n-        final double[] data =\n-            {\n-                Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY,\n-                0d, -0d, x, y, z, 2 * x, -x, 1 / x, x * x, x + y, x - y, y - x\n-            };\n-        final double[] expected = new double[data.length];\n-        for (int i = 0; i < data.length; i++) {\n-            final double d = data[i];\n+        final double[] expected = new double[values.length];\n+        for (int i = 0; i < values.length; i++) {\n+            final double d = values[i];\n             for (int j = 0; j < expected.length; j++) {\n                 switch (op) {\n                     case ADD:\n-                        expected[j] = data[j] + d;\n+                        expected[j] = values[j] + d;\n                         break;\n                     case SUB:\n-                        expected[j] = data[j] - d;\n+                        expected[j] = values[j] - d;\n                         break;\n                     case MUL:\n-                        expected[j] = data[j] * d;\n+                        expected[j] = values[j] * d;\n                         break;\n                     case DIV:\n-                        expected[j] = data[j] / d;\n+                        expected[j] = values[j] / d;\n                         break;\n                     default:\n                         throw new AssertionError(\"unexpected value\");\n                 }\n             }\n-            final RealVector v = create(data);\n+            final RealVector v = create(values);\n             final RealVector actual;\n             if (inPlace) {\n                 switch (op) {\n \n     private void doTestMapFunction(final UnivariateFunction f,\n         final boolean inPlace) {\n-        final double x = getPreferredEntryValue();\n-        final double y = x + 1d;\n-        final double z = y + 1d;\n-        final double[] data =\n-            {\n-                Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY,\n-                0d, -0d, x, y, z, 2 * x, -x, 1 / x, x * x, x + y, x - y, y - x,\n-                0.5 * FastMath.PI, -0.5 * FastMath.PI, FastMath.E, -FastMath.E,\n-                1.0, -1.0\n-            };\n+        final double[] data = new double[values.length + 6];\n+        System.arraycopy(values, 0, data, 0, values.length);\n+        data[values.length + 0] = 0.5 * FastMath.PI;\n+        data[values.length + 1] = -0.5 * FastMath.PI;\n+        data[values.length + 2] = FastMath.E;\n+        data[values.length + 3] = -FastMath.E;\n+        data[values.length + 4] = 1.0;\n+        data[values.length + 5] = -1.0;\n         final double[] expected = new double[data.length];\n         for (int i = 0; i < data.length; i++) {\n             expected[i] = f.value(data[i]);", "timestamp": 1340775475, "metainfo": ""}