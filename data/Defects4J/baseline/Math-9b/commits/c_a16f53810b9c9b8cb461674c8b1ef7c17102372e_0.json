{"sha": "a16f53810b9c9b8cb461674c8b1ef7c17102372e", "log": "Introduced \"MatrixDimensionMismatchException\" to replace \"InvalidMatrixException\" whenever it was used to signal a row or column dimension mismatch. \"MessageFactory\": Fixed wrong order of appearance of general and specific messages.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/exception/DimensionMismatchException.java\n+++ b/src/main/java/org/apache/commons/math/exception/DimensionMismatchException.java\n      */\n     public DimensionMismatchException(int wrong,\n                                       int expected) {\n-        super(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE, wrong, expected);\n+        super(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n+              LocalizedFormats.DIMENSIONS_MISMATCH,\n+              wrong, expected);\n         dimension = expected;\n     }\n \n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/exception/MatrixDimensionMismatchException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception;\n+\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+/**\n+ * Exception to be thrown when either the number of rows or the number of\n+ * columns of a matrix do not match the expected values.\n+ *\n+ * @since 3.0\n+ * @version $Revision$ $Date$\n+ */\n+public class MatrixDimensionMismatchException extends MultiDimensionMismatchException {\n+    /** Serializable version Id. */\n+    private static final long serialVersionUID = -8415396756375798143L;\n+\n+    /**\n+     * Construct an exception from the mismatched dimensions.\n+     *\n+     * @param wrongRowDim Wrong row dimension.\n+     * @param wrongColDim Wrong column dimension.\n+     * @param expectedRowDim Expected row dimension.\n+     * @param expectedColDim Expected column dimension.\n+     */\n+    public MatrixDimensionMismatchException(int wrongRowDim,\n+                                            int wrongColDim,\n+                                            int expectedRowDim,\n+                                            int expectedColDim) {\n+        super(LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n+              new Integer[] { wrongRowDim, wrongColDim },\n+              new Integer[] { expectedRowDim, expectedColDim });\n+    }\n+\n+    /**\n+     * @return the expected row dimension.\n+     */\n+    public int getWrongRowDimension() {\n+        return getWrongDimensions()[0];\n+    }\n+    /**\n+     * @return the expected row dimension.\n+     */\n+    public int getExpectedRowDimension() {\n+        return getExpectedDimensions()[0];\n+    }\n+    /**\n+     * @return the wrong column dimension.\n+     */\n+    public int getWrongColumnDimension() {\n+        return getWrongDimensions()[1];\n+    }\n+    /**\n+     * @return the expected column dimension.\n+     */\n+    public int getExpectedColumnDimension() {\n+        return getExpectedDimensions()[1];\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/exception/MultiDimensionMismatchException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception;\n+\n+import org.apache.commons.math.exception.util.Localizable;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+\n+/**\n+ * Exception to be thrown when two sets of dimensions differ.\n+ *\n+ * @since 3.0\n+ * @version $Revision$ $Date$\n+ */\n+public class MultiDimensionMismatchException extends MathIllegalArgumentException {\n+    /** Serializable version Id. */\n+    private static final long serialVersionUID = -8415396756375798143L;\n+\n+    /** Wrong dimensions. */\n+    private final Integer[] wrong;\n+    /** Correct dimensions. */\n+    private final Integer[] expected;\n+\n+    /**\n+     * Construct an exception from the mismatched dimensions.\n+     *\n+     * @param wrong Wrong dimensionq.\n+     * @param expected Expected dimensionq.\n+     */\n+    public MultiDimensionMismatchException(Integer[] wrong,\n+                                           Integer[] expected) {\n+        this(null, wrong, expected);\n+    }\n+\n+    /**\n+     * Construct an exception from the mismatched dimensions.\n+     *\n+     * @param specific Message pattern providing the specific context of\n+     * the error.\n+     * @param wrong Wrong dimensions.\n+     * @param expected Expected dimensions.\n+     */\n+    public MultiDimensionMismatchException(Localizable specific,\n+                                           Integer[] wrong,\n+                                           Integer[] expected) {\n+        super(specific, LocalizedFormats.DIMENSIONS_MISMATCH, wrong, expected);\n+        this.wrong = wrong.clone();\n+        this.expected = expected.clone();\n+    }\n+\n+    /**\n+     * @return a reference to the array containing the wrong dimensions.\n+     */\n+    public Integer[] getWrongDimensions() {\n+        return wrong;\n+    }\n+    /**\n+     * @return a reference to the array containing the expected dimensions.\n+     */\n+    public Integer[] getExpectedDimensions() {\n+        return expected;\n+    }\n+}\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     CUMULATIVE_PROBABILITY_RETURNED_NAN(\"Cumulative probability function returned NaN for argument {0} p = {1}\"),\n     DIFFERENT_ROWS_LENGTHS(\"some rows have length {0} while others have length {1}\"),\n     DIGEST_NOT_INITIALIZED(\"digest not initialized\"),\n-    DIMENSIONS_MISMATCH_2x2(\"dimensions mismatch: got {0}x{1} but expected {2}x{3}\"),\n-    DIMENSIONS_MISMATCH_SIMPLE(\"dimensions mismatch {0} != {1}\"), /* keep */\n+    DIMENSIONS_MISMATCH_2x2(\"got {0}x{1} but expected {2}x{3}\"), /* keep */\n+    DIMENSIONS_MISMATCH_SIMPLE(\"{0} != {1}\"), /* keep */\n+    DIMENSIONS_MISMATCH(\"dimensions mismatch\"), /* keep */\n     DISCRETE_CUMULATIVE_PROBABILITY_RETURNED_NAN(\"Discrete cumulative probability function returned NaN for argument {0}\"),\n     DISTRIBUTION_NOT_LOADED(\"distribution not loaded\"),\n     DUPLICATED_ABSCISSA(\"Abscissa {0} is duplicated at both indices {1} and {2}\"),\n--- a/src/main/java/org/apache/commons/math/exception/util/MessageFactory.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/MessageFactory.java\n                                       Object ... arguments) {\n         final StringBuilder sb = new StringBuilder();\n         MessageFormat fmt = null;\n+        fmt = new MessageFormat(general.getLocalizedString(locale), locale);\n+        sb.append(fmt.format(arguments));\n         if (specific != null) {\n+            sb.append(\": \");\n             fmt = new MessageFormat(specific.getLocalizedString(locale), locale);\n             sb.append(fmt.format(arguments));\n-            sb.append(\": \");\n         }\n-        fmt = new MessageFormat(general.getLocalizedString(locale), locale);\n-        sb.append(fmt.format(arguments));\n \n         return sb.toString();\n     }\n--- a/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n     }\n \n     /** {@inheritDoc} */\n-    public void setRowMatrix(final int row, final FieldMatrix<T> matrix)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    public void setRowMatrix(final int row, final FieldMatrix<T> matrix) {\n         checkRowIndex(row);\n         final int nCols = getColumnDimension();\n         if ((matrix.getRowDimension() != 1) ||\n             (matrix.getColumnDimension() != nCols)) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);\n+            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),\n+                                                       matrix.getColumnDimension(),\n+                                                       1, nCols);\n         }\n         for (int i = 0; i < nCols; ++i) {\n             setEntry(row, i, matrix.getEntry(0, i));\n     }\n \n     /** {@inheritDoc} */\n-    public void setColumnMatrix(final int column, final FieldMatrix<T> matrix)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    public void setColumnMatrix(final int column, final FieldMatrix<T> matrix) {\n         checkColumnIndex(column);\n         final int nRows = getRowDimension();\n         if ((matrix.getRowDimension() != nRows) ||\n             (matrix.getColumnDimension() != 1)) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);\n+            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),\n+                                                       matrix.getColumnDimension(),\n+                                                       nRows, 1);\n         }\n         for (int i = 0; i < nRows; ++i) {\n             setEntry(i, column, matrix.getEntry(i, 0));\n     }\n \n     /** {@inheritDoc} */\n-    public void setRowVector(final int row, final FieldVector<T> vector)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    public void setRowVector(final int row, final FieldVector<T> vector) {\n         checkRowIndex(row);\n         final int nCols = getColumnDimension();\n         if (vector.getDimension() != nCols) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    1, vector.getDimension(), 1, nCols);\n+            throw new MatrixDimensionMismatchException(1, vector.getDimension(),\n+                                                       1, nCols);\n         }\n         for (int i = 0; i < nCols; ++i) {\n             setEntry(row, i, vector.getEntry(i));\n     }\n \n     /** {@inheritDoc} */\n-    public void setColumnVector(final int column, final FieldVector<T> vector)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    public void setColumnVector(final int column, final FieldVector<T> vector) {\n         checkColumnIndex(column);\n         final int nRows = getRowDimension();\n         if (vector.getDimension() != nRows) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    vector.getDimension(), 1, nRows, 1);\n+            throw new MatrixDimensionMismatchException(vector.getDimension(), 1,\n+                                                       nRows, 1);\n         }\n         for (int i = 0; i < nRows; ++i) {\n             setEntry(i, column, vector.getEntry(i));\n     }\n \n     /** {@inheritDoc} */\n-    public void setRow(final int row, final T[] array)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    public void setRow(final int row, final T[] array) {\n         checkRowIndex(row);\n         final int nCols = getColumnDimension();\n         if (array.length != nCols) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    1, array.length, 1, nCols);\n+            throw new MatrixDimensionMismatchException(1, array.length, 1, nCols);\n         }\n         for (int i = 0; i < nCols; ++i) {\n             setEntry(row, i, array[i]);\n     }\n \n     /** {@inheritDoc} */\n-    public void setColumn(final int column, final T[] array)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    public void setColumn(final int column, final T[] array) {\n         checkColumnIndex(column);\n         final int nRows = getRowDimension();\n         if (array.length != nRows) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    array.length, 1, nRows, 1);\n+            throw new MatrixDimensionMismatchException(array.length, 1, nRows, 1);\n         }\n         for (int i = 0; i < nRows; ++i) {\n             setEntry(i, column, array[i]);\n         }\n-\n     }\n \n     /** {@inheritDoc} */\n \n     /** {@inheritDoc} */\n     public FieldMatrix<T> transpose() {\n-\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         final FieldMatrix<T> out = createMatrix(nCols, nRows);\n         walkInOptimizedOrder(new DefaultFieldMatrixPreservingVisitor<T>(field.getZero()) {\n-\n             /** {@inheritDoc} */\n             @Override\n             public void visit(final int row, final int column, final T value) {\n                 out.setEntry(column, row, value);\n             }\n-\n         });\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n             }\n \n             return new ArrayFieldVector<T>(out);\n-\n         }\n     }\n \n \n         res.append(\"}\");\n         return res.toString();\n-\n     }\n \n     /**\n             throw new MatrixIndexException(LocalizedFormats.INITIAL_COLUMN_AFTER_FINAL_COLUMN,\n                                            startColumn, endColumn);\n         }\n-\n-\n     }\n \n     /**\n                     m.getRowDimension(), m.getColumnDimension());\n         }\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n \n package org.apache.commons.math.linear;\n \n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NoDataException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n      *\n      * @param rowDimension  the number of rows in the new matrix\n      * @param columnDimension  the number of columns in the new matrix\n-     * @throws IllegalArgumentException if row or column dimension is not positive\n+     * @throws NotStrictlyPositiveException if row or column dimension is not positive\n      */\n-    protected AbstractRealMatrix(final int rowDimension, final int columnDimension)\n-        throws IllegalArgumentException {\n-        if (rowDimension < 1 ) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.INSUFFICIENT_DIMENSION, rowDimension, 1);\n-        }\n-        if (columnDimension <= 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.INSUFFICIENT_DIMENSION, columnDimension, 1);\n+    protected AbstractRealMatrix(final int rowDimension, final int columnDimension) {\n+        if (rowDimension < 1) {\n+            throw new NotStrictlyPositiveException(rowDimension);\n+        }\n+        if (columnDimension < 1) {\n+            throw new NotStrictlyPositiveException(columnDimension);\n         }\n         lu = null;\n     }\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return data;\n-\n     }\n \n     /** {@inheritDoc} */\n             public double end() {\n                 return maxColSum;\n             }\n-\n         });\n     }\n \n             public double end() {\n                 return FastMath.sqrt(sum);\n             }\n-\n         });\n     }\n \n         }\n \n         return subMatrix;\n-\n     }\n \n     /** {@inheritDoc} */\n         });\n \n         return subMatrix;\n-\n     }\n \n     /** {@inheritDoc} */\n         final int rowsCount    = endRow + 1 - startRow;\n         final int columnsCount = endColumn + 1 - startColumn;\n         if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    destination.length, destination[0].length,\n-                    rowsCount, columnsCount);\n+            throw new MatrixDimensionMismatchException(destination.length, destination[0].length,\n+                                                       rowsCount, columnsCount);\n         }\n \n         // copy entries\n             }\n \n         }, startRow, endRow, startColumn, endColumn);\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination)\n-        throws MatrixIndexException, IllegalArgumentException {\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) {\n \n         // safety checks\n         MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);\n         if ((destination.length < selectedRows.length) ||\n             (destination[0].length < selectedColumns.length)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    destination.length, destination[0].length,\n-                    selectedRows.length, selectedColumns.length);\n+            throw new MatrixDimensionMismatchException(destination.length, destination[0].length,\n+                                                       selectedRows.length, selectedColumns.length);\n         }\n \n         // copy entries\n                 destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);\n             }\n         }\n-\n     }\n \n     /** {@inheritDoc} */\n \n         final int nRows = subMatrix.length;\n         if (nRows == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);\n+            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n         }\n \n         final int nCols = subMatrix[0].length;\n         if (nCols == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n+            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n         }\n \n         for (int r = 1; r < nRows; ++r) {\n             if (subMatrix[r].length != nCols) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n-                        nCols, subMatrix[r].length);\n+                throw new DimensionMismatchException(nCols, subMatrix[r].length);\n             }\n         }\n \n         }\n \n         lu = null;\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return out;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setRowMatrix(final int row, final RealMatrix matrix)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setRowMatrix(final int row, final RealMatrix matrix) {\n         MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         if ((matrix.getRowDimension() != 1) ||\n             (matrix.getColumnDimension() != nCols)) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);\n+            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),\n+                                                       matrix.getColumnDimension(),\n+                                                       1, nCols);\n         }\n         for (int i = 0; i < nCols; ++i) {\n             setEntry(row, i, matrix.getEntry(0, i));\n         }\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return out;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setColumnMatrix(final int column, final RealMatrix matrix)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setColumnMatrix(final int column, final RealMatrix matrix) {\n         MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         if ((matrix.getRowDimension() != nRows) ||\n             (matrix.getColumnDimension() != 1)) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);\n+            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),\n+                                                       matrix.getColumnDimension(),\n+                                                       nRows, 1);\n         }\n         for (int i = 0; i < nRows; ++i) {\n             setEntry(i, column, matrix.getEntry(i, 0));\n         }\n-\n     }\n \n     /** {@inheritDoc} */\n     }\n \n     /** {@inheritDoc} */\n-    public void setRowVector(final int row, final RealVector vector)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    public void setRowVector(final int row, final RealVector vector) {\n         MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         if (vector.getDimension() != nCols) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    1, vector.getDimension(), 1, nCols);\n+            throw new MatrixDimensionMismatchException(1, vector.getDimension(),\n+                                                       1, nCols);\n         }\n         for (int i = 0; i < nCols; ++i) {\n             setEntry(row, i, vector.getEntry(i));\n         }\n-\n     }\n \n     /** {@inheritDoc} */\n     }\n \n     /** {@inheritDoc} */\n-    public void setColumnVector(final int column, final RealVector vector)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    public void setColumnVector(final int column, final RealVector vector) {\n         MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         if (vector.getDimension() != nRows) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    vector.getDimension(), 1, nRows, 1);\n+            throw new MatrixDimensionMismatchException(vector.getDimension(), 1,\n+                                                       nRows, 1);\n         }\n         for (int i = 0; i < nRows; ++i) {\n             setEntry(i, column, vector.getEntry(i));\n         }\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return out;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setRow(final int row, final double[] array)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setRow(final int row, final double[] array) {\n         MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         if (array.length != nCols) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    1, array.length, 1, nCols);\n+            throw new MatrixDimensionMismatchException(1, array.length, 1, nCols);\n         }\n         for (int i = 0; i < nCols; ++i) {\n             setEntry(row, i, array[i]);\n         }\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return out;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void setColumn(final int column, final double[] array)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setColumn(final int column, final double[] array) {\n         MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         if (array.length != nRows) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    array.length, 1, nRows, 1);\n+            throw new MatrixDimensionMismatchException(array.length, 1, nRows, 1);\n         }\n         for (int i = 0; i < nRows; ++i) {\n             setEntry(i, column, array[i]);\n         }\n-\n     }\n \n     /** {@inheritDoc} */\n         });\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         if (v.length != nCols) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                    v.length, nCols);\n+            throw new DimensionMismatchException(v.length, nCols);\n         }\n \n         final double[] out = new double[nRows];\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n             final int nRows = getRowDimension();\n             final int nCols = getColumnDimension();\n             if (v.getDimension() != nCols) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                        v.getDimension(), nCols);\n+                throw new DimensionMismatchException(v.getDimension(), nCols);\n             }\n \n             final double[] out = new double[nRows];\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         if (v.length != nRows) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                    v.length, nRows);\n+            throw new DimensionMismatchException(v.length, nRows);\n         }\n \n         final double[] out = new double[nCols];\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n             final int nRows = getRowDimension();\n             final int nCols = getColumnDimension();\n             if (v.getDimension() != nRows) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                        v.getDimension(), nRows);\n+                throw new DimensionMismatchException(v.getDimension(), nRows);\n             }\n \n             final double[] out = new double[nCols];\n             }\n \n             return new ArrayRealVector(out);\n-\n         }\n     }\n \n \n         res.append(\"}\");\n         return res.toString();\n-\n     }\n \n     /**\n         }\n         return ret;\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n \n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NoDataException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n \n             final int iHeight = blockHeight(iBlock);\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                 if (blockData[index].length != iHeight * blockWidth(jBlock)) {\n-                    throw MathRuntimeException.createIllegalArgumentException(\n-                            LocalizedFormats.WRONG_BLOCK_LENGTH,\n-                            blockData[index].length, iHeight * blockWidth(jBlock));\n+                    throw new DimensionMismatchException(blockData[index].length,\n+                                                         iHeight * blockWidth(jBlock));\n                 }\n                 if (copyArray) {\n                     blocks[index] = blockData[index].clone();\n         for (int i = 0; i < rawData.length; ++i) {\n             final int length = rawData[i].length;\n             if (length != columns) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n-                        columns, length);\n+                throw new DimensionMismatchException(columns, length);\n             }\n         }\n \n \n         // safety checks\n         final int refLength = subMatrix[0].length;\n-        if (refLength < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n+        if (refLength == 0) {\n+            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n         }\n         final int endRow    = row + subMatrix.length - 1;\n         final int endColumn = column + refLength - 1;\n         checkSubMatrixIndex(row, endRow, column, endColumn);\n         for (final T[] subRow : subMatrix) {\n             if (subRow.length != refLength) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n-                        refLength, subRow.length);\n+                throw new DimensionMismatchException(refLength, subRow.length);\n             }\n         }\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public void setRowMatrix(final int row, final FieldMatrix<T> matrix)\n-        throws MatrixIndexException, InvalidMatrixException {\n+    public void setRowMatrix(final int row, final FieldMatrix<T> matrix) {\n         try {\n             setRowMatrix(row, (BlockFieldMatrix<T>) matrix);\n         } catch (ClassCastException cce) {\n      * @param matrix row matrix (must have one row and the same number of columns\n      * as the instance)\n      * @throws MatrixIndexException if the specified row index is invalid\n-     * @throws InvalidMatrixException if the matrix dimensions do not match one\n+     * @throws MatrixDimensionMismatchException if the matrix dimensions do not match one\n      * instance row\n      */\n-    public void setRowMatrix(final int row, final BlockFieldMatrix<T> matrix)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    public void setRowMatrix(final int row, final BlockFieldMatrix<T> matrix) {\n         checkRowIndex(row);\n         final int nCols = getColumnDimension();\n         if ((matrix.getRowDimension() != 1) ||\n             (matrix.getColumnDimension() != nCols)) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    matrix.getRowDimension(), matrix.getColumnDimension(),\n-                    1, nCols);\n+            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),\n+                                                       matrix.getColumnDimension(),\n+                                                       1, nCols);\n         }\n \n         // perform copy block-wise, to ensure good cache behavior\n \n     /** {@inheritDoc} */\n     @Override\n-    public void setColumnMatrix(final int column, final FieldMatrix<T> matrix)\n-        throws MatrixIndexException, InvalidMatrixException {\n+    public void setColumnMatrix(final int column, final FieldMatrix<T> matrix) {\n         try {\n             setColumnMatrix(column, (BlockFieldMatrix<T>) matrix);\n         } catch (ClassCastException cce) {\n      * @param matrix column matrix (must have one column and the same number of rows\n      * as the instance)\n      * @throws MatrixIndexException if the specified column index is invalid\n-     * @throws InvalidMatrixException if the matrix dimensions do not match one\n+     * @throws MatrixDimensionMismatchException if the matrix dimensions do not match one\n      * instance column\n      */\n-    void setColumnMatrix(final int column, final BlockFieldMatrix<T> matrix)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    void setColumnMatrix(final int column, final BlockFieldMatrix<T> matrix) {\n         checkColumnIndex(column);\n         final int nRows = getRowDimension();\n         if ((matrix.getRowDimension() != nRows) ||\n             (matrix.getColumnDimension() != 1)) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    matrix.getRowDimension(), matrix.getColumnDimension(),\n-                    nRows, 1);\n+            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),\n+                                                       matrix.getColumnDimension(),\n+                                                       nRows, 1);\n         }\n \n         // perform copy block-wise, to ensure good cache behavior\n                 block[i * jWidth + jColumn] = mBlock[mIndex++];\n             }\n         }\n-\n     }\n \n     /** {@inheritDoc} */\n \n     /** {@inheritDoc} */\n     @Override\n-    public void setRowVector(final int row, final FieldVector<T> vector)\n-        throws MatrixIndexException, InvalidMatrixException {\n+    public void setRowVector(final int row, final FieldVector<T> vector) {\n         try {\n             setRow(row, ((ArrayFieldVector<T>) vector).getDataRef());\n         } catch (ClassCastException cce) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public void setColumnVector(final int column, final FieldVector<T> vector)\n-        throws MatrixIndexException, InvalidMatrixException {\n+    public void setColumnVector(final int column, final FieldVector<T> vector) {\n         try {\n             setColumn(column, ((ArrayFieldVector<T>) vector).getDataRef());\n         } catch (ClassCastException cce) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public void setRow(final int row, final T[] array)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    public void setRow(final int row, final T[] array) {\n         checkRowIndex(row);\n         final int nCols = getColumnDimension();\n         if (array.length != nCols) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    1, array.length, 1, nCols);\n+            throw new MatrixDimensionMismatchException(1, array.length, 1, nCols);\n         }\n \n         // perform copy block-wise, to ensure good cache behavior\n             System.arraycopy(array, outIndex, block, iRow * jWidth, jWidth);\n             outIndex += jWidth;\n         }\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return out;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void setColumn(final int column, final T[] array)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setColumn(final int column, final T[] array) {\n         checkColumnIndex(column);\n         final int nRows = getRowDimension();\n         if (array.length != nRows) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    array.length, 1, nRows, 1);\n+            throw new MatrixDimensionMismatchException(array.length, 1, nRows, 1);\n         }\n \n         // perform copy block-wise, to ensure good cache behavior\n                 block[i * jWidth + jColumn] = array[outIndex++];\n             }\n         }\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n         throws IllegalArgumentException {\n \n         if (v.length != columns) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                    v.length, columns);\n+            throw new DimensionMismatchException(v.length, columns);\n         }\n         final T[] out = buildArray(getField(), rows);\n         final T zero = getField().getZero();\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n         throws IllegalArgumentException {\n \n         if (v.length != rows) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                    v.length, rows);\n+            throw new DimensionMismatchException(v.length, rows);\n         }\n         final T[] out = buildArray(getField(), columns);\n         final T zero = getField().getZero();\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n     private int blockWidth(final int blockColumn) {\n         return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java\n import java.io.Serializable;\n import java.util.Arrays;\n \n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NoDataException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.util.FastMath;\n \n             final int iHeight = blockHeight(iBlock);\n             for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                 if (blockData[index].length != iHeight * blockWidth(jBlock)) {\n-                    throw MathRuntimeException.createIllegalArgumentException(\n-                            LocalizedFormats.WRONG_BLOCK_LENGTH,\n-                            blockData[index].length, iHeight * blockWidth(jBlock));\n+                    throw new DimensionMismatchException(blockData[index].length,\n+                                                         iHeight * blockWidth(jBlock));\n                 }\n                 if (copyArray) {\n                     blocks[index] = blockData[index].clone();\n                 }\n             }\n         }\n-\n     }\n \n     /**\n         for (int i = 0; i < rawData.length; ++i) {\n             final int length = rawData[i].length;\n             if (length != columns) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n-                        columns, length);\n+                throw new DimensionMismatchException(columns, length);\n             }\n         }\n \n         }\n \n         return blocks;\n-\n     }\n \n     /**\n         }\n \n         return blocks;\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return copied;\n-\n     }\n \n     /** {@inheritDoc} */\n             }\n \n             return out;\n-\n         }\n     }\n \n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n             }\n \n             return out;\n-\n         }\n     }\n \n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n             }\n \n             return out;\n-\n         }\n     }\n \n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return data;\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return out;\n-\n     }\n \n     /**\n \n         // safety checks\n         final int refLength = subMatrix[0].length;\n-        if (refLength < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n+        if (refLength == 0) {\n+            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n         }\n         final int endRow    = row + subMatrix.length - 1;\n         final int endColumn = column + refLength - 1;\n         MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);\n         for (final double[] subRow : subMatrix) {\n             if (subRow.length != refLength) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n-                        refLength, subRow.length);\n+                throw new DimensionMismatchException(refLength, subRow.length);\n             }\n         }\n \n         }\n \n         return out;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void setRowMatrix(final int row, final RealMatrix matrix)\n-        throws MatrixIndexException, InvalidMatrixException {\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setRowMatrix(final int row, final RealMatrix matrix) {\n         try {\n             setRowMatrix(row, (BlockRealMatrix) matrix);\n         } catch (ClassCastException cce) {\n      * @param matrix row matrix (must have one row and the same number of columns\n      * as the instance)\n      * @throws MatrixIndexException if the specified row index is invalid\n-     * @throws InvalidMatrixException if the matrix dimensions do not match one\n+     * @throws MatrixDimensionMismatchException if the matrix dimensions do not match one\n      * instance row\n      */\n-    public void setRowMatrix(final int row, final BlockRealMatrix matrix)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    public void setRowMatrix(final int row, final BlockRealMatrix matrix) {\n         MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         if ((matrix.getRowDimension() != 1) ||\n             (matrix.getColumnDimension() != nCols)) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    matrix.getRowDimension(), matrix.getColumnDimension(),\n-                    1, nCols);\n+            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),\n+                                                       matrix.getColumnDimension(),\n+                                                       1, nCols);\n         }\n \n         // perform copy block-wise, to ensure good cache behavior\n                 mIndex += jWidth;\n            }\n         }\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return out;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void setColumnMatrix(final int column, final RealMatrix matrix)\n-        throws MatrixIndexException, InvalidMatrixException {\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setColumnMatrix(final int column, final RealMatrix matrix) {\n         try {\n             setColumnMatrix(column, (BlockRealMatrix) matrix);\n         } catch (ClassCastException cce) {\n      * @param matrix column matrix (must have one column and the same number of rows\n      * as the instance)\n      * @throws MatrixIndexException if the specified column index is invalid\n-     * @throws InvalidMatrixException if the matrix dimensions do not match one\n+     * @throws MatrixDimensionMismatchException if the matrix dimensions do not match one\n      * instance column\n      */\n-    void setColumnMatrix(final int column, final BlockRealMatrix matrix)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    void setColumnMatrix(final int column, final BlockRealMatrix matrix) {\n         MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         if ((matrix.getRowDimension() != nRows) ||\n             (matrix.getColumnDimension() != 1)) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    matrix.getRowDimension(), matrix.getColumnDimension(),\n-                    nRows, 1);\n+            throw new MatrixDimensionMismatchException(matrix.getRowDimension(),\n+                                                       matrix.getColumnDimension(),\n+                                                       nRows, 1);\n         }\n \n         // perform copy block-wise, to ensure good cache behavior\n                 block[i * jWidth + jColumn] = mBlock[mIndex++];\n             }\n         }\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return new ArrayRealVector(outData, false);\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void setRowVector(final int row, final RealVector vector)\n-        throws MatrixIndexException, InvalidMatrixException {\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setRowVector(final int row, final RealVector vector) {\n         try {\n             setRow(row, ((ArrayRealVector) vector).getDataRef());\n         } catch (ClassCastException cce) {\n         }\n \n         return new ArrayRealVector(outData, false);\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void setColumnVector(final int column, final RealVector vector)\n-        throws MatrixIndexException, InvalidMatrixException {\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setColumnVector(final int column, final RealVector vector) {\n         try {\n             setColumn(column, ((ArrayRealVector) vector).getDataRef());\n         } catch (ClassCastException cce) {\n         }\n \n         return out;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void setRow(final int row, final double[] array)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setRow(final int row, final double[] array) {\n         MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         if (array.length != nCols) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    1, array.length, 1, nCols);\n+            throw new MatrixDimensionMismatchException(1, array.length, 1, nCols);\n         }\n \n         // perform copy block-wise, to ensure good cache behavior\n             System.arraycopy(array, outIndex, block, iRow * jWidth, jWidth);\n             outIndex += jWidth;\n         }\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return out;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void setColumn(final int column, final double[] array)\n-        throws MatrixIndexException, InvalidMatrixException {\n-\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setColumn(final int column, final double[] array) {\n         MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         if (array.length != nRows) {\n-            throw new InvalidMatrixException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    array.length, 1, nRows, 1);\n+            throw new MatrixDimensionMismatchException(array.length, 1, nRows, 1);\n         }\n \n         // perform copy block-wise, to ensure good cache behavior\n                 block[i * jWidth + jColumn] = array[outIndex++];\n             }\n         }\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n         throws IllegalArgumentException {\n \n         if (v.length != columns) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                    v.length, columns);\n+            throw new DimensionMismatchException(v.length, columns);\n         }\n         final double[] out = new double[rows];\n \n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n         throws IllegalArgumentException {\n \n         if (v.length != rows) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                    v.length, rows);\n+            throw new DimensionMismatchException(v.length, rows);\n         }\n         final double[] out = new double[columns];\n \n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n     private int blockWidth(final int blockColumn) {\n         return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n      * @return     this + m\n      * @throws  IllegalArgumentException if m is not the same size as this\n      */\n-    FieldMatrix<T> add(FieldMatrix<T> m) throws IllegalArgumentException;\n+    FieldMatrix<T> add(FieldMatrix<T> m);\n \n     /**\n      * Compute this minus m.\n      * @return     this + m\n      * @throws  IllegalArgumentException if m is not the same size as this\n      */\n-    FieldMatrix<T> subtract(FieldMatrix<T> m) throws IllegalArgumentException;\n+    FieldMatrix<T> subtract(FieldMatrix<T> m);\n \n      /**\n      * Returns the result of adding d to each entry of this.\n      * @throws     IllegalArgumentException\n      *             if columnDimension(this) != rowDimension(m)\n      */\n-    FieldMatrix<T> multiply(FieldMatrix<T> m) throws IllegalArgumentException;\n+    FieldMatrix<T> multiply(FieldMatrix<T> m);\n \n     /**\n      * Returns the result premultiplying this by <code>m</code>.\n      * @throws     IllegalArgumentException\n      *             if rowDimension(this) != columnDimension(m)\n      */\n-    FieldMatrix<T> preMultiply(FieldMatrix<T> m) throws IllegalArgumentException;\n+    FieldMatrix<T> preMultiply(FieldMatrix<T> m);\n \n     /**\n      * Returns matrix entries as a two-dimensional array.\n      *         specified rows and columns\n      * @exception MatrixIndexException  if the indices are not valid\n      */\n-   FieldMatrix<T> getSubMatrix(int startRow, int endRow, int startColumn, int endColumn)\n-       throws MatrixIndexException;\n+   FieldMatrix<T> getSubMatrix(int startRow, int endRow, int startColumn, int endColumn);\n \n    /**\n     * Gets a submatrix. Rows and columns are indicated\n     *         specified rows and columns\n     * @exception MatrixIndexException if row or column selections are not valid\n     */\n-   FieldMatrix<T> getSubMatrix(int[] selectedRows, int[] selectedColumns)\n-       throws MatrixIndexException;\n+   FieldMatrix<T> getSubMatrix(int[] selectedRows, int[] selectedColumns);\n \n    /**\n     * Copy a submatrix. Rows and columns are indicated\n     * @exception IllegalArgumentException if the destination array is too small\n     */\n   void copySubMatrix(int startRow, int endRow, int startColumn, int endColumn,\n-                     T[][] destination)\n-      throws MatrixIndexException, IllegalArgumentException;\n+                     T[][] destination);\n \n   /**\n    * Copy a submatrix. Rows and columns are indicated\n    * @exception MatrixIndexException if the indices are not valid\n    * @exception IllegalArgumentException if the destination array is too small\n    */\n-  void copySubMatrix(int[] selectedRows, int[] selectedColumns, T[][] destination)\n-      throws MatrixIndexException, IllegalArgumentException;\n+  void copySubMatrix(int[] selectedRows, int[] selectedColumns, T[][] destination);\n \n    /**\n     * Replace the submatrix starting at <code>row, column</code> using data in\n     * @throws NullPointerException if <code>subMatrix</code> is null\n     * @since 2.0\n     */\n-   void setSubMatrix(T[][] subMatrix, int row, int column)\n-       throws MatrixIndexException;\n+  void setSubMatrix(T[][] subMatrix, int row, int column);\n \n    /**\n     * Returns the entries in row number <code>row</code>\n     * @return row matrix\n     * @throws MatrixIndexException if the specified row index is invalid\n     */\n-   FieldMatrix<T> getRowMatrix(int row) throws MatrixIndexException;\n+   FieldMatrix<T> getRowMatrix(int row);\n \n    /**\n     * Sets the entries in row number <code>row</code>\n     * @param matrix row matrix (must have one row and the same number of columns\n     * as the instance)\n     * @throws MatrixIndexException if the specified row index is invalid\n-    * @throws InvalidMatrixException if the matrix dimensions do not match one\n-    * instance row\n-    */\n-   void setRowMatrix(int row, FieldMatrix<T> matrix)\n-       throws MatrixIndexException, InvalidMatrixException;\n+    * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+    * if the matrix dimensions do not match one instance row.\n+    */\n+   void setRowMatrix(int row, FieldMatrix<T> matrix);\n \n    /**\n     * Returns the entries in column number <code>column</code>\n     * @return column matrix\n     * @throws MatrixIndexException if the specified column index is invalid\n     */\n-   FieldMatrix<T> getColumnMatrix(int column) throws MatrixIndexException;\n+   FieldMatrix<T> getColumnMatrix(int column);\n \n    /**\n     * Sets the entries in column number <code>column</code>\n     * @param matrix column matrix (must have one column and the same number of rows\n     * as the instance)\n     * @throws MatrixIndexException if the specified column index is invalid\n-    * @throws InvalidMatrixException if the matrix dimensions do not match one\n-    * instance column\n-    */\n-   void setColumnMatrix(int column, FieldMatrix<T> matrix)\n-       throws MatrixIndexException, InvalidMatrixException;\n+    * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+    * if the matrix dimensions do not match one instance column.\n+    */\n+   void setColumnMatrix(int column, FieldMatrix<T> matrix);\n \n    /**\n     * Returns the entries in row number <code>row</code>\n     * @return row vector\n     * @throws MatrixIndexException if the specified row index is invalid\n     */\n-   FieldVector<T> getRowVector(int row) throws MatrixIndexException;\n+   FieldVector<T> getRowVector(int row);\n \n    /**\n     * Sets the entries in row number <code>row</code>\n     * @param vector row vector (must have the same number of columns\n     * as the instance)\n     * @throws MatrixIndexException if the specified row index is invalid\n-    * @throws InvalidMatrixException if the vector dimension does not match one\n-    * instance row\n-    */\n-   void setRowVector(int row, FieldVector<T> vector)\n-       throws MatrixIndexException, InvalidMatrixException;\n+    * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+    * if the vector dimension does not match one instance row.\n+    */\n+   void setRowVector(int row, FieldVector<T> vector);\n \n    /**\n     * Returns the entries in column number <code>column</code>\n     * @return column vector\n     * @throws MatrixIndexException if the specified column index is invalid\n     */\n-   FieldVector<T> getColumnVector(int column) throws MatrixIndexException;\n+   FieldVector<T> getColumnVector(int column);\n \n    /**\n     * Sets the entries in column number <code>column</code>\n     * @param column the column to be set\n     * @param vector column vector (must have the same number of rows as the instance)\n     * @throws MatrixIndexException if the specified column index is invalid\n-    * @throws InvalidMatrixException if the vector dimension does not match one\n-    * instance column\n-    */\n-   void setColumnVector(int column, FieldVector<T> vector)\n-       throws MatrixIndexException, InvalidMatrixException;\n+    * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+    * if the vector dimension does not match one instance column.\n+    */\n+   void setColumnVector(int column, FieldVector<T> vector);\n \n     /**\n      * Returns the entries in row number <code>row</code> as an array.\n      * <p>\n      * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown\n-     * unless <code>0 <= row < rowDimension.</code></p>\n+     * unless {@code 0 <= row < rowDimension}.</p>\n      *\n      * @param row the row to be fetched\n      * @return array of entries in the row\n      * @throws MatrixIndexException if the specified row index is not valid\n      */\n-    T[] getRow(int row) throws MatrixIndexException;\n+    T[] getRow(int row);\n \n     /**\n      * Sets the entries in row number <code>row</code>\n      * @param row the row to be set\n      * @param array row matrix (must have the same number of columns as the instance)\n      * @throws MatrixIndexException if the specified row index is invalid\n-     * @throws InvalidMatrixException if the array size does not match one\n-     * instance row\n-     */\n-    void setRow(int row, T[] array)\n-        throws MatrixIndexException, InvalidMatrixException;\n+     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * if the array size does not match one instance row.\n+     */\n+    void setRow(int row, T[] array);\n \n     /**\n      * Returns the entries in column number <code>col</code> as an array.\n      * <p>\n      * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown\n-     * unless <code>0 <= column < columnDimension.</code></p>\n+     * unless {@code 0 <= column < columnDimension}.</p>\n      *\n      * @param column the column to be fetched\n      * @return array of entries in the column\n      * @throws MatrixIndexException if the specified column index is not valid\n      */\n-    T[] getColumn(int column) throws MatrixIndexException;\n+    T[] getColumn(int column);\n \n     /**\n      * Sets the entries in column number <code>column</code>\n      * @param column the column to be set\n      * @param array column array (must have the same number of rows as the instance)\n      * @throws MatrixIndexException if the specified column index is invalid\n-     * @throws InvalidMatrixException if the array size does not match one\n-     * instance column\n-     */\n-    void setColumn(int column, T[] array)\n-        throws MatrixIndexException, InvalidMatrixException;\n+     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * if the array size does not match one instance column.\n+     */\n+    void setColumn(int column, T[] array);\n \n     /**\n      * Returns the entry in the specified row and column.\n      * <p>\n      * Row and column indices start at 0 and must satisfy\n      * <ul>\n-     * <li><code>0 <= row < rowDimension</code></li>\n-     * <li><code> 0 <= column < columnDimension</code></li>\n+     * <li>{@code 0 <= row < rowDimension}</li>\n+     * <li>{@code 0 <= column < columnDimension}</li>\n      * </ul>\n      * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n      *\n      * @return matrix entry in row,column\n      * @throws MatrixIndexException if the row or column index is not valid\n      */\n-    T getEntry(int row, int column) throws MatrixIndexException;\n+    T getEntry(int row, int column);\n \n     /**\n      * Set the entry in the specified row and column.\n      * <p>\n      * Row and column indices start at 0 and must satisfy\n      * <ul>\n-     * <li><code>0 <= row < rowDimension</code></li>\n-     * <li><code> 0 <= column < columnDimension</code></li>\n+     * <li>{@code 0 <= row < rowDimension}</li>\n+     * <li>{@code 0 <= column < columnDimension}</li>\n      * </ul>\n      * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n      *\n      * @throws MatrixIndexException if the row or column index is not valid\n      * @since 2.0\n      */\n-    void setEntry(int row, int column, T value) throws MatrixIndexException;\n+    void setEntry(int row, int column, T value);\n \n     /**\n      * Change an entry in the specified row and column.\n      * <p>\n      * Row and column indices start at 0 and must satisfy\n      * <ul>\n-     * <li><code>0 <= row < rowDimension</code></li>\n-     * <li><code> 0 <= column < columnDimension</code></li>\n+     * <li>{@code 0 <= row < rowDimension}</li>\n+     * <li>{@code 0 <= column < columnDimension}</li>\n      * </ul>\n      * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n      *\n      * <p>\n      * Row and column indices start at 0 and must satisfy\n      * <ul>\n-     * <li><code>0 <= row < rowDimension</code></li>\n-     * <li><code> 0 <= column < columnDimension</code></li>\n+     * <li>{@code 0 <= row < rowDimension}</li>\n+     * <li>{@code 0 <= column < columnDimension}</li>\n      * </ul>\n      * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n      *\n      * @throws MatrixIndexException if the row or column index is not valid\n      * @since 2.0\n      */\n-    void multiplyEntry(int row, int column, T factor) throws MatrixIndexException;\n+    void multiplyEntry(int row, int column, T factor);\n \n     /**\n      * Returns the transpose of this matrix.\n      * @return trace\n      * @throws NonSquareMatrixException if the matrix is not square\n      */\n-    T getTrace() throws NonSquareMatrixException;\n+    T getTrace();\n \n     /**\n      * Returns the result of multiplying this by the vector <code>v</code>.\n      * @return this*v\n      * @throws IllegalArgumentException if columnDimension != v.size()\n      */\n-    T[] operate(T[] v) throws IllegalArgumentException;\n+    T[] operate(T[] v);\n \n     /**\n      * Returns the result of multiplying this by the vector <code>v</code>.\n      * @return this*v\n      * @throws IllegalArgumentException if columnDimension != v.size()\n      */\n-    FieldVector<T> operate(FieldVector<T> v) throws IllegalArgumentException;\n+    FieldVector<T> operate(FieldVector<T> v);\n \n     /**\n      * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n      * @return v*this\n      * @throws IllegalArgumentException if rowDimension != v.size()\n      */\n-    T[] preMultiply(T[] v) throws IllegalArgumentException;\n+    T[] preMultiply(T[] v);\n \n     /**\n      * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n      * @return v*this\n      * @throws IllegalArgumentException if rowDimension != v.size()\n      */\n-    FieldVector<T> preMultiply(FieldVector<T> v) throws IllegalArgumentException;\n+    FieldVector<T> preMultiply(FieldVector<T> v);\n \n     /**\n      * Visit (and possibly change) all matrix entries in row order.\n      * @return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\n      * of the walk\n      */\n-    T walkInRowOrder(FieldMatrixChangingVisitor<T> visitor)\n-        throws MatrixVisitorException;\n+    T walkInRowOrder(FieldMatrixChangingVisitor<T> visitor);\n \n     /**\n      * Visit (but don't change) all matrix entries in row order.\n      * @return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\n      * of the walk\n      */\n-    T walkInRowOrder(FieldMatrixPreservingVisitor<T> visitor)\n-        throws MatrixVisitorException;\n+    T walkInRowOrder(FieldMatrixPreservingVisitor<T> visitor);\n \n     /**\n      * Visit (and possibly change) some matrix entries in row order.\n      * of the walk\n      */\n     T walkInRowOrder(FieldMatrixChangingVisitor<T> visitor,\n-                          int startRow, int endRow, int startColumn, int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException;\n+                     int startRow, int endRow, int startColumn, int endColumn);\n \n     /**\n      * Visit (but don't change) some matrix entries in row order.\n      * of the walk\n      */\n     T walkInRowOrder(FieldMatrixPreservingVisitor<T> visitor,\n-                          int startRow, int endRow, int startColumn, int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException;\n+                     int startRow, int endRow, int startColumn, int endColumn);\n \n     /**\n      * Visit (and possibly change) all matrix entries in column order.\n      * @return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\n      * of the walk\n      */\n-    T walkInColumnOrder(FieldMatrixChangingVisitor<T> visitor)\n-        throws MatrixVisitorException;\n+    T walkInColumnOrder(FieldMatrixChangingVisitor<T> visitor);\n \n     /**\n      * Visit (but don't change) all matrix entries in column order.\n      * @return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\n      * of the walk\n      */\n-    T walkInColumnOrder(FieldMatrixPreservingVisitor<T> visitor)\n-        throws MatrixVisitorException;\n+    T walkInColumnOrder(FieldMatrixPreservingVisitor<T> visitor);\n \n     /**\n      * Visit (and possibly change) some matrix entries in column order.\n      * of the walk\n      */\n     T walkInColumnOrder(FieldMatrixChangingVisitor<T> visitor,\n-                             int startRow, int endRow, int startColumn, int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException;\n+                        int startRow, int endRow, int startColumn, int endColumn);\n \n     /**\n      * Visit (but don't change) some matrix entries in column order.\n      * of the walk\n      */\n     T walkInColumnOrder(FieldMatrixPreservingVisitor<T> visitor,\n-                             int startRow, int endRow, int startColumn, int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException;\n+                        int startRow, int endRow, int startColumn, int endColumn);\n \n     /**\n      * Visit (and possibly change) all matrix entries using the fastest possible order.\n      * @return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\n      * of the walk\n      */\n-    T walkInOptimizedOrder(FieldMatrixChangingVisitor<T> visitor)\n-        throws MatrixVisitorException;\n+    T walkInOptimizedOrder(FieldMatrixChangingVisitor<T> visitor);\n \n     /**\n      * Visit (but don't change) all matrix entries using the fastest possible order.\n      * @return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\n      * of the walk\n      */\n-    T walkInOptimizedOrder(FieldMatrixPreservingVisitor<T> visitor)\n-        throws MatrixVisitorException;\n+    T walkInOptimizedOrder(FieldMatrixPreservingVisitor<T> visitor);\n \n     /**\n      * Visit (and possibly change) some matrix entries using the fastest possible order.\n      * of the walk\n      */\n     T walkInOptimizedOrder(FieldMatrixChangingVisitor<T> visitor,\n-                                int startRow, int endRow, int startColumn, int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException;\n+                           int startRow, int endRow, int startColumn, int endColumn);\n \n     /**\n      * Visit (but don't change) some matrix entries using the fastest possible order.\n      * of the walk\n      */\n     T walkInOptimizedOrder(FieldMatrixPreservingVisitor<T> visitor,\n-                                int startRow, int endRow, int startColumn, int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException;\n-\n+                           int startRow, int endRow, int startColumn, int endColumn);\n }\n--- a/src/main/java/org/apache/commons/math/linear/InvalidMatrixException.java\n+++ b/src/main/java/org/apache/commons/math/linear/InvalidMatrixException.java\n  * that matrix does not satisfy the preconditions for the\n  * aforementioned operation.\n  * @version $Revision$ $Date$\n+ * @deprecated since 2.2. Please use the classes in the\n+ * {@link org.apache.commons.math.exception} package.\n  */\n public class InvalidMatrixException extends MathRuntimeException {\n \n--- a/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n      * @param rowDimension  the number of rows in the new matrix\n      * @param columnDimension  the number of columns in the new matrix\n      * @return a new matrix of the same type as the instance\n-     * @throws IllegalArgumentException if row or column dimension is not positive\n+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n+     * if row or column dimension is not positive.\n      * @since 2.0\n      */\n     RealMatrix createMatrix(final int rowDimension, final int columnDimension);\n      * @return     this + m\n      * @throws  IllegalArgumentException if m is not the same size as this\n      */\n-    RealMatrix add(RealMatrix m) throws IllegalArgumentException;\n+    RealMatrix add(RealMatrix m);\n \n     /**\n      * Compute this minus m.\n      * @return     this - m\n      * @throws  IllegalArgumentException if m is not the same size as this\n      */\n-    RealMatrix subtract(RealMatrix m) throws IllegalArgumentException;\n+    RealMatrix subtract(RealMatrix m);\n \n      /**\n      * Returns the result of adding d to each entry of this.\n      * @throws     IllegalArgumentException\n      *             if columnDimension(this) != rowDimension(m)\n      */\n-    RealMatrix multiply(RealMatrix m) throws IllegalArgumentException;\n+    RealMatrix multiply(RealMatrix m);\n \n     /**\n      * Returns the result premultiplying this by <code>m</code>.\n      * @throws     IllegalArgumentException\n      *             if rowDimension(this) != columnDimension(m)\n      */\n-    RealMatrix preMultiply(RealMatrix m) throws IllegalArgumentException;\n+    RealMatrix preMultiply(RealMatrix m);\n \n     /**\n      * Returns matrix entries as a two-dimensional array.\n      *         specified rows and columns\n      * @exception MatrixIndexException  if the indices are not valid\n      */\n-   RealMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn)\n-       throws MatrixIndexException;\n+    RealMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn);\n \n    /**\n     * Gets a submatrix. Rows and columns are indicated\n     *         specified rows and columns\n     * @exception MatrixIndexException if row or column selections are not valid\n     */\n-   RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n-       throws MatrixIndexException;\n+    RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns);\n \n    /**\n     * Copy a submatrix. Rows and columns are indicated\n     * @exception IllegalArgumentException if the destination array is too small\n     */\n   void copySubMatrix(int startRow, int endRow, int startColumn, int endColumn,\n-                     double[][] destination)\n-      throws MatrixIndexException, IllegalArgumentException;\n-\n+                     double[][] destination);\n   /**\n    * Copy a submatrix. Rows and columns are indicated\n    * counting from 0 to n-1.\n    * @exception MatrixIndexException if the indices are not valid\n    * @exception IllegalArgumentException if the destination array is too small\n    */\n-  void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination)\n-      throws MatrixIndexException, IllegalArgumentException;\n+    void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination);\n \n    /**\n     * Replace the submatrix starting at <code>row, column</code> using data in\n     * @throws NullPointerException if <code>subMatrix</code> is null\n     * @since 2.0\n     */\n-   void setSubMatrix(double[][] subMatrix, int row, int column)\n-       throws MatrixIndexException;\n+    void setSubMatrix(double[][] subMatrix, int row, int column);\n \n    /**\n     * Returns the entries in row number <code>row</code>\n     * @return row matrix\n     * @throws MatrixIndexException if the specified row index is invalid\n     */\n-   RealMatrix getRowMatrix(int row) throws MatrixIndexException;\n+   RealMatrix getRowMatrix(int row);\n \n    /**\n     * Sets the entries in row number <code>row</code>\n     * @param matrix row matrix (must have one row and the same number of columns\n     * as the instance)\n     * @throws MatrixIndexException if the specified row index is invalid\n-    * @throws InvalidMatrixException if the matrix dimensions do not match one\n-    * instance row\n-    */\n-   void setRowMatrix(int row, RealMatrix matrix)\n-       throws MatrixIndexException, InvalidMatrixException;\n+    * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+    * if the matrix dimensions do not match one instance row.\n+    */\n+    void setRowMatrix(int row, RealMatrix matrix);\n \n    /**\n     * Returns the entries in column number <code>column</code>\n     * @return column matrix\n     * @throws MatrixIndexException if the specified column index is invalid\n     */\n-   RealMatrix getColumnMatrix(int column) throws MatrixIndexException;\n+   RealMatrix getColumnMatrix(int column);\n \n    /**\n     * Sets the entries in column number <code>column</code>\n     * @param matrix column matrix (must have one column and the same number of rows\n     * as the instance)\n     * @throws MatrixIndexException if the specified column index is invalid\n-    * @throws InvalidMatrixException if the matrix dimensions do not match one\n-    * instance column\n-    */\n-   void setColumnMatrix(int column, RealMatrix matrix)\n-       throws MatrixIndexException, InvalidMatrixException;\n+    * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+    * if the matrix dimensions do not match one instance column.\n+    */\n+    void setColumnMatrix(int column, RealMatrix matrix);\n \n    /**\n     * Returns the entries in row number <code>row</code>\n     * @return row vector\n     * @throws MatrixIndexException if the specified row index is invalid\n     */\n-   RealVector getRowVector(int row) throws MatrixIndexException;\n+   RealVector getRowVector(int row);\n \n    /**\n     * Sets the entries in row number <code>row</code>\n     * @param vector row vector (must have the same number of columns\n     * as the instance)\n     * @throws MatrixIndexException if the specified row index is invalid\n-    * @throws InvalidMatrixException if the vector dimension does not match one\n-    * instance row\n-    */\n-   void setRowVector(int row, RealVector vector)\n-       throws MatrixIndexException, InvalidMatrixException;\n+    * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+    * if the vector dimension does not match one instance row.\n+    */\n+    void setRowVector(int row, RealVector vector);\n \n    /**\n     * Returns the entries in column number <code>column</code>\n     * @return column vector\n     * @throws MatrixIndexException if the specified column index is invalid\n     */\n-   RealVector getColumnVector(int column) throws MatrixIndexException;\n+   RealVector getColumnVector(int column);\n \n    /**\n     * Sets the entries in column number <code>column</code>\n     * @param column the column to be set\n     * @param vector column vector (must have the same number of rows as the instance)\n     * @throws MatrixIndexException if the specified column index is invalid\n-    * @throws InvalidMatrixException if the vector dimension does not match one\n-    * instance column\n-    */\n-   void setColumnVector(int column, RealVector vector)\n-       throws MatrixIndexException, InvalidMatrixException;\n+    * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+    * if the vector dimension does not match one instance column.\n+    */\n+    void setColumnVector(int column, RealVector vector);\n \n     /**\n      * Returns the entries in row number <code>row</code> as an array.\n      * <p>\n      * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown\n-     * unless <code>0 <= row < rowDimension.</code></p>\n+     * unless {@code 0 <= row < rowDimension}.</p>\n      *\n      * @param row the row to be fetched\n      * @return array of entries in the row\n      * @throws MatrixIndexException if the specified row index is not valid\n      */\n-    double[] getRow(int row) throws MatrixIndexException;\n+    double[] getRow(int row);\n \n     /**\n      * Sets the entries in row number <code>row</code>\n      * @param row the row to be set\n      * @param array row matrix (must have the same number of columns as the instance)\n      * @throws MatrixIndexException if the specified row index is invalid\n-     * @throws InvalidMatrixException if the array size does not match one\n-     * instance row\n-     */\n-    void setRow(int row, double[] array)\n-        throws MatrixIndexException, InvalidMatrixException;\n+     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * if the array size does not match one instance row.\n+     */\n+    void setRow(int row, double[] array);\n \n     /**\n      * Returns the entries in column number <code>col</code> as an array.\n      * <p>\n      * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown\n-     * unless <code>0 <= column < columnDimension.</code></p>\n+     * unless {@code 0 <= column < columnDimension}.</p>\n      *\n      * @param column the column to be fetched\n      * @return array of entries in the column\n      * @throws MatrixIndexException if the specified column index is not valid\n      */\n-    double[] getColumn(int column) throws MatrixIndexException;\n+    double[] getColumn(int column);\n \n     /**\n      * Sets the entries in column number <code>column</code>\n      * @param column the column to be set\n      * @param array column array (must have the same number of rows as the instance)\n      * @throws MatrixIndexException if the specified column index is invalid\n-     * @throws InvalidMatrixException if the array size does not match one\n-     * instance column\n-     */\n-    void setColumn(int column, double[] array)\n-        throws MatrixIndexException, InvalidMatrixException;\n+     * @throws org.apache.commons.math.exception.MatrixDimensionMismatchException\n+     * if the array size does not match one instance column.\n+     */\n+    void setColumn(int column, double[] array);\n \n     /**\n      * Returns the entry in the specified row and column.\n      * <p>\n      * Row and column indices start at 0 and must satisfy\n      * <ul>\n-     * <li><code>0 <= row < rowDimension</code></li>\n-     * <li><code> 0 <= column < columnDimension</code></li>\n+     * <li>{@code 0 <= row < rowDimension}</li>\n+     * <li>{@code 0 <= column < columnDimension}</li>\n      * </ul>\n      * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n      *\n      * @return matrix entry in row,column\n      * @throws MatrixIndexException if the row or column index is not valid\n      */\n-    double getEntry(int row, int column) throws MatrixIndexException;\n+    double getEntry(int row, int column);\n \n     /**\n      * Set the entry in the specified row and column.\n      * <p>\n      * Row and column indices start at 0 and must satisfy\n      * <ul>\n-     * <li><code>0 <= row < rowDimension</code></li>\n-     * <li><code> 0 <= column < columnDimension</code></li>\n+     * <li>{@code 0 <= row < rowDimension}</li>\n+     * <li>{@code 0 <= column < columnDimension}</li>\n      * </ul>\n      * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n      *\n      * @throws MatrixIndexException if the row or column index is not valid\n      * @since 2.0\n      */\n-    void setEntry(int row, int column, double value) throws MatrixIndexException;\n+    void setEntry(int row, int column, double value);\n \n     /**\n      * Change an entry in the specified row and column.\n      * <p>\n      * Row and column indices start at 0 and must satisfy\n      * <ul>\n-     * <li><code>0 <= row < rowDimension</code></li>\n-     * <li><code> 0 <= column < columnDimension</code></li>\n+     * <li>{@code 0 <= row < rowDimension}</li>\n+     * <li>{@code 0 <= column < columnDimension}</li>\n      * </ul>\n      * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n      *\n      * @throws MatrixIndexException if the row or column index is not valid\n      * @since 2.0\n      */\n-    void addToEntry(int row, int column, double increment) throws MatrixIndexException;\n+    void addToEntry(int row, int column, double increment);\n \n     /**\n      * Change an entry in the specified row and column.\n      * <p>\n      * Row and column indices start at 0 and must satisfy\n      * <ul>\n-     * <li><code>0 <= row < rowDimension</code></li>\n-     * <li><code> 0 <= column < columnDimension</code></li>\n+     * <li>{@code 0 <= row < rowDimension}</li>\n+     * <li>{@code 0 <= column < columnDimension}</li>\n      * </ul>\n      * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n      *\n      * @throws MatrixIndexException if the row or column index is not valid\n      * @since 2.0\n      */\n-    void multiplyEntry(int row, int column, double factor) throws MatrixIndexException;\n+    void multiplyEntry(int row, int column, double factor);\n \n     /**\n      * Returns the transpose of this matrix.\n      * Returns the inverse of this matrix.\n      *\n      * @return inverse matrix\n-     * @throws InvalidMatrixException if  this is not invertible\n+     * @throws InvalidMatrixException if this is not invertible\n      * @deprecated as of release 2.0, replaced by <code>\n      * {@link LUDecompositionImpl#LUDecompositionImpl(RealMatrix)\n      * new LUDecompositionImpl(m)}.{@link LUDecomposition#getSolver()\n      * getInverse()}</code>\n      */\n     @Deprecated\n-    RealMatrix inverse() throws InvalidMatrixException;\n+        RealMatrix inverse();\n \n     /**\n      * Returns the determinant of this matrix.\n      * @return trace\n      * @throws NonSquareMatrixException if the matrix is not square\n      */\n-    double getTrace() throws NonSquareMatrixException;\n+    double getTrace();\n \n     /**\n      * Returns the result of multiplying this by the vector <code>v</code>.\n      * @return this*v\n      * @throws IllegalArgumentException if columnDimension != v.size()\n      */\n-    double[] operate(double[] v) throws IllegalArgumentException;\n+    double[] operate(double[] v);\n \n     /**\n      * Returns the result of multiplying this by the vector <code>v</code>.\n      * @return this*v\n      * @throws IllegalArgumentException if columnDimension != v.size()\n      */\n-    RealVector operate(RealVector v) throws IllegalArgumentException;\n+    RealVector operate(RealVector v);\n \n     /**\n      * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n      * @return v*this\n      * @throws IllegalArgumentException if rowDimension != v.size()\n      */\n-    double[] preMultiply(double[] v) throws IllegalArgumentException;\n+    double[] preMultiply(double[] v);\n \n     /**\n      * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n      * @return v*this\n      * @throws IllegalArgumentException if rowDimension != v.size()\n      */\n-    RealVector preMultiply(RealVector v) throws IllegalArgumentException;\n+    RealVector preMultiply(RealVector v);\n \n     /**\n      * Visit (and possibly change) all matrix entries in row order.\n      * @return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\n      * of the walk\n      */\n-    double walkInRowOrder(RealMatrixChangingVisitor visitor)\n-        throws MatrixVisitorException;\n+    double walkInRowOrder(RealMatrixChangingVisitor visitor);\n \n     /**\n      * Visit (but don't change) all matrix entries in row order.\n      * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n      * of the walk\n      */\n-    double walkInRowOrder(RealMatrixPreservingVisitor visitor)\n-        throws MatrixVisitorException;\n+    double walkInRowOrder(RealMatrixPreservingVisitor visitor);\n \n     /**\n      * Visit (and possibly change) some matrix entries in row order.\n      * of the walk\n      */\n     double walkInRowOrder(RealMatrixChangingVisitor visitor,\n-                          int startRow, int endRow, int startColumn, int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException;\n+                          int startRow, int endRow, int startColumn, int endColumn);\n \n     /**\n      * Visit (but don't change) some matrix entries in row order.\n      * of the walk\n      */\n     double walkInRowOrder(RealMatrixPreservingVisitor visitor,\n-                          int startRow, int endRow, int startColumn, int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException;\n+                          int startRow, int endRow, int startColumn, int endColumn);\n \n     /**\n      * Visit (and possibly change) all matrix entries in column order.\n      * @return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\n      * of the walk\n      */\n-    double walkInColumnOrder(RealMatrixChangingVisitor visitor)\n-        throws MatrixVisitorException;\n+    double walkInColumnOrder(RealMatrixChangingVisitor visitor);\n \n     /**\n      * Visit (but don't change) all matrix entries in column order.\n      * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n      * of the walk\n      */\n-    double walkInColumnOrder(RealMatrixPreservingVisitor visitor)\n-        throws MatrixVisitorException;\n+    double walkInColumnOrder(RealMatrixPreservingVisitor visitor);\n \n     /**\n      * Visit (and possibly change) some matrix entries in column order.\n      * of the walk\n      */\n     double walkInColumnOrder(RealMatrixChangingVisitor visitor,\n-                             int startRow, int endRow, int startColumn, int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException;\n+                             int startRow, int endRow, int startColumn, int endColumn);\n \n     /**\n      * Visit (but don't change) some matrix entries in column order.\n      * of the walk\n      */\n     double walkInColumnOrder(RealMatrixPreservingVisitor visitor,\n-                             int startRow, int endRow, int startColumn, int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException;\n+                             int startRow, int endRow, int startColumn, int endColumn);\n \n     /**\n      * Visit (and possibly change) all matrix entries using the fastest possible order.\n      * @return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\n      * of the walk\n      */\n-    double walkInOptimizedOrder(RealMatrixChangingVisitor visitor)\n-        throws MatrixVisitorException;\n+    double walkInOptimizedOrder(RealMatrixChangingVisitor visitor);\n \n     /**\n      * Visit (but don't change) all matrix entries using the fastest possible order.\n      * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n      * of the walk\n      */\n-    double walkInOptimizedOrder(RealMatrixPreservingVisitor visitor)\n-        throws MatrixVisitorException;\n+    double walkInOptimizedOrder(RealMatrixPreservingVisitor visitor);\n \n     /**\n      * Visit (and possibly change) some matrix entries using the fastest possible order.\n      * of the walk\n      */\n     double walkInOptimizedOrder(RealMatrixChangingVisitor visitor,\n-                                int startRow, int endRow, int startColumn, int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException;\n+                                int startRow, int endRow, int startColumn, int endColumn);\n \n     /**\n      * Visit (but don't change) some matrix entries using the fastest possible order.\n      * of the walk\n      */\n     double walkInOptimizedOrder(RealMatrixPreservingVisitor visitor,\n-                                int startRow, int endRow, int startColumn, int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException;\n+                                int startRow, int endRow, int startColumn, int endColumn);\n \n     /**\n      * Returns the solution vector for a linear system with coefficient\n      * @deprecated as of release 2.0, replaced by {@link DecompositionSolver#solve(double[])}\n      */\n     @Deprecated\n-    double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException;\n+    double[] solve(double[] b);\n \n     /**\n      * Returns a matrix of (column) solution vectors for linear systems with\n      * @deprecated as of release 2.0, replaced by {@link DecompositionSolver#solve(RealMatrix)}\n      */\n     @Deprecated\n-    RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException;\n-\n+    RealMatrix solve(RealMatrix b);\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/exception/MatrixDimensionMismatchExceptionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.exception;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test for {@link MatrixDimensionMismatchException}.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public class MatrixDimensionMismatchExceptionTest {\n+    @Test\n+    public void testAccessors() {\n+        final MatrixDimensionMismatchException e\n+            = new MatrixDimensionMismatchException(1, 2, 3, 4);\n+        Assert.assertEquals(1, e.getWrongRowDimension());\n+        Assert.assertEquals(2, e.getWrongColumnDimension());\n+        Assert.assertEquals(3, e.getExpectedRowDimension());\n+        Assert.assertEquals(4, e.getExpectedColumnDimension());\n+    }\n+}\n--- a/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/Array2DRowRealMatrixTest.java\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n \n /**\n  * Test cases for the {@link Array2DRowRealMatrix} class.\n         }\n         try {\n             m.setRowMatrix(0, m);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setColumnMatrix(0, m);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setRowVector(0, new ArrayRealVector(5));\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setColumnVector(0, new ArrayRealVector(5));\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setRow(0, new double[5]);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setColumn(0, new double[5]);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n     //--------------- -----------------Protected methods\n \n     /** extracts the l  and u matrices from compact lu representation */\n-    protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) throws InvalidMatrixException {\n-        if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||\n-                lowerData.length != upperData.length\n-                || lowerData.length != lu.getRowDimension()) {\n-            throw new InvalidMatrixException(\"incorrect dimensions\");\n+    protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) {\n+        if (!lu.isSquare() ||\n+            lowerData.length != lowerData[0].length ||\n+            upperData.length != upperData[0].length ||\n+            lowerData.length != upperData.length ||\n+            lowerData.length != lu.getRowDimension()) {\n+            throw new IllegalArgumentException(\"incorrect dimensions\");\n         }\n         int n = lu.getRowDimension();\n         for (int i = 0; i < n; i++) {\n //              System.out.println(os);\n //          }\n //    }\n-\n }\n \n--- a/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.fraction.FractionField;\n+import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n \n /**\n  * Test cases for the {@link BlockFieldMatrix} class.\n         }\n         try {\n             m.setRowMatrix(0, m);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setColumnMatrix(0, m);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setRowVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setColumnVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setRow(0, new Fraction[5]);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setColumn(0, new Fraction[5]);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockRealMatrixTest.java\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n \n /**\n  * Test cases for the {@link BlockRealMatrix} class.\n         }\n         try {\n             m.setRowMatrix(0, m);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setColumnMatrix(0, m);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setRowVector(0, new ArrayRealVector(5));\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setColumnVector(0, new ArrayRealVector(5));\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setRow(0, new double[5]);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setColumn(0, new double[5]);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n--- a/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.fraction.FractionField;\n+import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n \n /**\n  * Test cases for the {@link Array2DRowFieldMatrix} class.\n         }\n         try {\n             m.setRowMatrix(0, m);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setColumnMatrix(0, m);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setRowVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setColumnVector(0, new ArrayFieldVector<Fraction>(FractionField.getInstance(), 5));\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setRow(0, new Fraction[5]);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setColumn(0, new Fraction[5]);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n     /** extracts the l  and u matrices from compact lu representation */\n     protected void splitLU(FieldMatrix<Fraction> lu,\n                            Fraction[][] lowerData,\n-                           Fraction[][] upperData)\n-        throws InvalidMatrixException {\n+                           Fraction[][] upperData) {\n         if (!lu.isSquare() ||\n             lowerData.length != lowerData[0].length ||\n             upperData.length != upperData[0].length ||\n             lowerData.length != upperData.length ||\n             lowerData.length != lu.getRowDimension()) {\n-            throw new InvalidMatrixException(\"incorrect dimensions\");\n+            throw new IllegalArgumentException(\"incorrect dimensions\");\n         }\n         int n = lu.getRowDimension();\n         for (int i = 0; i < n; i++) {\n         }\n         return new Array2DRowFieldMatrix<Fraction>(out);\n     }\n-\n }\n-\n--- a/src/test/java/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/RealMatrixImplTest.java\n \n import org.apache.commons.math.TestUtils;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n \n /**\n  * Test cases for the {@link RealMatrixImpl} class.\n         }\n         try {\n             m.setRowMatrix(0, m);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setColumnMatrix(0, m);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setRowVector(0, new ArrayRealVector(5));\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setColumnVector(0, new ArrayRealVector(5));\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setRow(0, new double[5]);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n         }\n         try {\n             m.setColumn(0, new double[5]);\n-            fail(\"Expecting InvalidMatrixException\");\n-        } catch (InvalidMatrixException ex) {\n+            fail(\"Expecting MatrixDimensionMismatchException\");\n+        } catch (MatrixDimensionMismatchException ex) {\n             // expected\n         }\n     }\n     //--------------- -----------------Protected methods\n \n     /** extracts the l  and u matrices from compact lu representation */\n-    protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData) throws InvalidMatrixException {\n-        if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||\n-                lowerData.length != upperData.length\n-                || lowerData.length != lu.getRowDimension()) {\n-            throw new InvalidMatrixException(\"incorrect dimensions\");\n+    protected void splitLU(RealMatrix lu, double[][] lowerData, double[][] upperData)  {\n+        if (!lu.isSquare() ||\n+            lowerData.length != lowerData[0].length ||\n+            upperData.length != upperData[0].length ||\n+            lowerData.length != upperData.length ||\n+            lowerData.length != lu.getRowDimension()) {\n+            throw new IllegalArgumentException(\"incorrect dimensions\");\n         }\n         int n = lu.getRowDimension();\n         for (int i = 0; i < n; i++) {\n //              System.out.println(os);\n //          }\n //    }\n-\n }\n ", "timestamp": 1285369954, "metainfo": ""}