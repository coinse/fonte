{"sha": "de9ff4e1116050d24e96a2a429167309074c88c0", "log": "added copySubmatrix methods use matrix visitors to implement some existing methods more efficiently  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n+    public RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns)\n         throws MatrixIndexException {\n \n+        // safety checks\n         checkSubMatrixIndex(selectedRows, selectedColumns);\n \n+        // copy entries\n         final RealMatrix subMatrix =\n             createMatrix(selectedRows.length, selectedColumns.length);\n+        subMatrix.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = 4572851009041214720L;\n+\n+            /** {@inheritDoc} */\n+            public double visit(final int row, final int column, final double value) {\n+                return getEntry(selectedRows[row], selectedColumns[column]);\n+            }\n+\n+        });\n+\n+        return subMatrix;\n+\n+    } \n+\n+    /** {@inheritDoc} */\n+    public void copySubMatrix(final int startRow, final int endRow,\n+                              final int startColumn, final int endColumn,\n+                              final double[][] destination)\n+        throws MatrixIndexException, IllegalArgumentException {\n+\n+        // safety checks\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        final int rowsCount    = endRow + 1 - startRow;\n+        final int columnsCount = endColumn + 1 - startColumn;\n+        if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    new Object[] {\n+                        destination.length, destination[0].length,\n+                        rowsCount, columnsCount\n+                    });\n+        }\n+\n+        // copy entries\n+        walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = -6302162622577015104L;\n+\n+            /** Initial row index. */\n+            private int startRow;\n+\n+            /** Initial column index. */\n+            private int startColumn;\n+\n+            /** {@inheritDoc} */\n+            public void start(final int rows, final int columns,\n+                              final int startRow, final int endRow,\n+                              final int startColumn, final int endColumn) {\n+                this.startRow    = startRow;\n+                this.startColumn = startColumn;\n+            }\n+\n+            /** {@inheritDoc} */\n+            public void visit(final int row, final int column, final double value) {\n+                destination[row - startRow][column - startColumn] = value;\n+            }\n+\n+        }, startRow, endRow, startColumn, endColumn);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination)\n+        throws MatrixIndexException, IllegalArgumentException {\n+\n+        // safety checks\n+        checkSubMatrixIndex(selectedRows, selectedColumns);\n+        if ((destination.length < selectedRows.length) ||\n+            (destination[0].length < selectedColumns.length)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    new Object[] {\n+                        destination.length, destination[0].length,\n+                        selectedRows.length, selectedColumns.length\n+                    });\n+        }\n+\n+        // copy entries\n         for (int i = 0; i < selectedRows.length; i++) {\n+            final double[] destinationI = destination[i];\n             for (int j = 0; j < selectedColumns.length; j++) {\n-                subMatrix.setEntry(i, j, getEntry(selectedRows[i], selectedColumns[j]));\n-            }\n-        }\n-\n-        return subMatrix;\n-\n-    } \n+                destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);\n+            }\n+        }\n+\n+    }\n \n     /** {@inheritDoc} */\n     public void setSubMatrix(final double[][] subMatrix, final int row, final int column) \n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         final RealMatrix out = createMatrix(nCols, nRows);\n-        walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\n-\n-            /** Serializable version identifier */\n-            private static final long serialVersionUID = 3807296710038754174L;\n-\n-            /** {@inheritDoc} */\n-            public void start(final int rows, final int columns,\n-                              final int startRow, final int endRow,\n-                              final int startColumn, final int endColumn) {\n-            }\n+        walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = 2482589609486637597L;\n \n             /** {@inheritDoc} */\n             public void visit(final int row, final int column, final double value) {\n                 out.setEntry(column, row, value);\n-            }\n-\n-            /** {@inheritDoc} */\n-            public double end() {\n-                return 0;\n             }\n \n         });\n--- a/src/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrix.java\n      *         specified rows and columns\n      * @exception MatrixIndexException  if the indices are not valid\n      */\n-   RealMatrix getSubMatrix(int startRow, int endRow, int startColumn,\n-            int endColumn) throws MatrixIndexException;\n+   RealMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn)\n+       throws MatrixIndexException;\n    \n    /**\n     * Gets a submatrix. Rows and columns are indicated\n     * @exception MatrixIndexException if row or column selections are not valid\n     */\n    RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n-   throws MatrixIndexException;\n-\n+       throws MatrixIndexException;\n+\n+   /**\n+    * Copy a submatrix. Rows and columns are indicated\n+    * counting from 0 to n-1.\n+    *\n+    * @param startRow Initial row index\n+    * @param endRow Final row index (inclusive)\n+    * @param startColumn Initial column index\n+    * @param endColumn Final column index (inclusive)\n+    * @param destination The arrays where the submatrix data should be copied\n+    * (if larger than rows/columns counts, only the upper-left part will be used)\n+    * @exception MatrixIndexException if the indices are not valid\n+    * @exception IllegalArgumentException if the destination array is too small\n+    */\n+  void copySubMatrix(int startRow, int endRow, int startColumn, int endColumn,\n+                     double[][] destination)\n+      throws MatrixIndexException, IllegalArgumentException;\n+  \n+  /**\n+   * Copy a submatrix. Rows and columns are indicated\n+   * counting from 0 to n-1.\n+   *\n+    * @param selectedRows Array of row indices.\n+    * @param selectedColumns Array of column indices.\n+   * @param destination The arrays where the submatrix data should be copied\n+   * (if larger than rows/columns counts, only the upper-left part will be used)\n+   * @exception MatrixIndexException if the indices are not valid\n+   * @exception IllegalArgumentException if the destination array is too small\n+   */\n+  void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination)\n+      throws MatrixIndexException, IllegalArgumentException;\n+ \n    /**\n     * Replace the submatrix starting at <code>row, column</code> using data in\n     * the input <code>subMatrix</code> array. Indexes are 0-based.", "timestamp": 1231070863, "metainfo": ""}