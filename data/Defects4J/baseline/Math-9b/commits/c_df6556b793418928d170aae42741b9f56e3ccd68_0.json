{"sha": "df6556b793418928d170aae42741b9f56e3ccd68", "log": "PR: http://nagoya.apache.org/bugzilla/show_bug.cgi?id=20766 Submitted by:\tbrent@worden.org   ", "commit": "\n--- a/src/java/org/apache/commons/math/distribution/TDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/TDistributionImpl.java\n      * @return CDF evaluted at <code>x</code>. \n      */\n     public double cummulativeProbability(double x) {\n-        double t = Beta.regularizedBeta(\n-            getDegreesOfFreedom() / (getDegreesOfFreedom() + (x * x)),\n-            0.5 * getDegreesOfFreedom(), 0.5);\n-            \n         double ret;\n-        if(x < 0.0){\n-            ret = 0.5 * t;\n-        } else if(x > 0.0){\n-            ret = 1.0 - 0.5 * t;\n+        if(x == 0.0){\n+            ret = 0.5;\n         } else {\n-            ret = 0.5;\n+            double t = Beta.regularizedBeta(\n+                getDegreesOfFreedom() / (getDegreesOfFreedom() + (x * x)),\n+                0.5 * getDegreesOfFreedom(), 0.5);\n+                \n+            if(x < 0.0){\n+                ret = 0.5 * t;\n+            } else {\n+                ret = 1.0 - 0.5 * t;\n+            }\n         }\n+        \n         return ret;\n     }\n         \n--- a/src/java/org/apache/commons/math/special/Beta.java\n+++ b/src/java/org/apache/commons/math/special/Beta.java\n     public static double regularizedBeta(double x, final double a, final double b, double epsilon, int maxIterations) {\n         double ret;\n \n-        if (a <= 0.0) {\n-            throw new IllegalArgumentException(\"a must be positive\");\n-        } else if (b <= 0.0) {\n-            throw new IllegalArgumentException(\"b must be positive\");\n-        } else if (x < 0.0 || x > 1.0) {\n-            throw new IllegalArgumentException(\n-                \"x must be between 0.0 and 1.0, inclusive\");\n-        } else if(x == 0.0){\n-            ret = 0.0;\n-        } else if(x == 1.0){\n-            ret = 1.0;\n+        if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || (x < 0)\n+                || (x > 1) || (a <= 0.0) || (b <= 0.0)) {\n+            ret = Double.NaN;\n         } else {\n             ContinuedFraction fraction = new ContinuedFraction() {\n                 protected double getB(int n, double x) {\n     public static double logBeta(double a, double b, double epsilon, int maxIterations) {\n         double ret;\n \n-        if (a <= 0.0) {\n-            throw new IllegalArgumentException(\"a must be positive\");\n-        } else if (b <= 0.0) {\n-            throw new IllegalArgumentException(\"b must be positive\");\n+        if (Double.isNaN(a) || Double.isNaN(b) || (a <= 0.0) || (b <= 0.0)) {\n+            ret = Double.NaN;\n         } else {\n             ret = Gamma.logGamma(a, epsilon, maxIterations) + Gamma.logGamma(b, epsilon, maxIterations)\n                 - Gamma.logGamma(a + b, epsilon, maxIterations);\n--- a/src/java/org/apache/commons/math/stat/UnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/UnivariateImpl.java\n  * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n  * @author <a href=\"mailto:mdiggory@apache.org\">Mark Diggory</a>\n  * @author Brent Worden\n- * @version $Revision: 1.3 $ $Date: 2003/06/04 12:23:44 $\n+ * @version $Revision: 1.4 $ $Date: 2003/06/14 04:17:49 $\n  * \n */\n public class UnivariateImpl implements Univariate, Serializable {\n     /** running sum of squares that have been added */\n     private double sumsq = 0.0;\n \n-\t/** running sum of 3rd powers that have been added */\n-\tprivate double sumCube = 0.0;\n-\t\n-\t/** running sum of 4th powers that have been added */\n-\tprivate double sumQuad = 0.0;\n-\t\n+    /** running sum of 3rd powers that have been added */\n+    private double sumCube = 0.0;\n+    \n+    /** running sum of 4th powers that have been added */\n+    private double sumQuad = 0.0;\n+    \n     /** count of values that have been added */\n     private int n = 0;\n \n \n      \n     /**\n-\t * @see org.apache.commons.math.stat.Univariate#addValue(double)\n-\t */\n-\tpublic void addValue(double v) {\n+     * @see org.apache.commons.math.stat.Univariate#addValue(double)\n+     */\n+    public void addValue(double v) {\n         insertValue(v);\n     }\n \n     \n     /**\n-\t * @see org.apache.commons.math.stat.Univariate#getMean()\n-\t */\n-\tpublic double getMean() {\n+     * @see org.apache.commons.math.stat.Univariate#getMean()\n+     */\n+    public double getMean() {\n         if (n == 0) {\n             return Double.NaN;\n         } else {\n \n      \n     /**\n-\t * @see org.apache.commons.math.stat.Univariate#getGeometricMean()\n-\t */\n-\tpublic double getGeometricMean() {\n+     * @see org.apache.commons.math.stat.Univariate#getGeometricMean()\n+     */\n+    public double getGeometricMean() {\n         if ((product <= 0.0) || (n == 0)) {\n             return Double.NaN; \n         } else {\n-            return Math.pow(product,( 1.0/(double)n ) );\n-        }\n-    }\n-\n-    /**\n-\t * @see org.apache.commons.math.stat.Univariate#getProduct()\n-\t */\n-\tpublic double getProduct() {\n+            return Math.pow(product,( 1.0 / (double) n ) );\n+        }\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.Univariate#getProduct()\n+     */\n+    public double getProduct() {\n         return product;\n     }\n \n-\t/**\n-\t * @see org.apache.commons.math.stat.Univariate#getStandardDeviation()\n-\t */\n-\tpublic double getStandardDeviation() {\n-\t\tdouble variance = getVariance();\n-\t\tif ((variance == 0.0) || (variance == Double.NaN)) {\n-\t\t\treturn variance;\n-\t\t} else {\n-\t\t\treturn Math.sqrt(variance);\n-\t\t}\n-\t}\n-\t\n-\t/**\n-\t * Returns the variance of the values that have been added as described by\n-\t * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (5) for k-Statistics</a>.\n-\t * \n-\t * @return The variance of a set of values.  Double.NaN is returned for\n-\t *         an empty set of values and 0.0 is returned for a &lt;= 1 value set.\n-\t */\n-\tpublic double getVariance() {\n-\t\tdouble variance = Double.NaN;\n-\n-\t\tif( n == 1 ) {\n-\t\t\tvariance = 0.0;\n-\t\t} else if( n > 1 ) {\n-\t\t\tvariance = (((double)n)*sumsq - (sum * sum)) / (double) (n * (n - 1));\t\n-\t\t}\n-\n-\t\treturn variance < 0 ? 0.0 : variance;\n-\t}\n+    /**\n+     * @see org.apache.commons.math.stat.Univariate#getStandardDeviation()\n+     */\n+    public double getStandardDeviation() {\n+        double variance = getVariance();\n+        if ((variance == 0.0) || (variance == Double.NaN)) {\n+            return variance;\n+        } else {\n+            return Math.sqrt(variance);\n+        }\n+    }\n+    \n+    /**\n+     * Returns the variance of the values that have been added as described by\n+     * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (5) for k-Statistics</a>.\n+     * \n+     * @return The variance of a set of values.  Double.NaN is returned for\n+     *         an empty set of values and 0.0 is returned for a &lt;= 1 value set.\n+     */\n+    public double getVariance() {\n+        double variance = Double.NaN;\n+\n+        if( n == 1 ) {\n+            variance = 0.0;\n+        } else if( n > 1 ) {\n+            variance = (((double) n) * sumsq - (sum * sum)) / (double) (n * (n - 1));    \n+        }\n+\n+        return variance < 0 ? 0.0 : variance;\n+    }\n      \n-\t/**\n-\t * Returns the skewness of the values that have been added as described by\n+    /**\n+     * Returns the skewness of the values that have been added as described by\n      * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (6) for k-Statistics</a>.\n      * \n-\t * @return The skew of a set of values.  Double.NaN is returned for\n-\t *         an empty set of values and 0.0 is returned for a &lt;= 2 value set.\n-\t */\n-\tpublic double getSkewness() {\n-\t\t\n-\t\tif( n < 1) return Double.NaN;\n-\t\tif( n <= 2 ) return 0.0;                  \n-\t\t\t\n-\t\treturn ( 2*Math.pow(sum,3) - 3*sum*sumsq + ((double)(n*n))*sumCube ) / \n-\t\t\t   ( (double)(n*(n-1)*(n-2)) ) ;  \n-\t}\n-\t\n-\t/**\n-\t * Returns the kurtosis of the values that have been added as described by\n+     * @return The skew of a set of values.  Double.NaN is returned for\n+     *         an empty set of values and 0.0 is returned for a &lt;= 2 value set.\n+     */\n+    public double getSkewness() {\n+        \n+        if( n < 1) return Double.NaN;\n+        if( n <= 2 ) return 0.0;                  \n+            \n+        return ( 2 * Math.pow(sum, 3) - 3 * sum * sumsq + ((double) (n * n)) * sumCube ) / \n+               ( (double) (n * (n - 1) * (n - 2)) ) ;  \n+    }\n+    \n+    /**\n+     * Returns the kurtosis of the values that have been added as described by\n      * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (7) for k-Statistics</a>.\n      * \n-\t * @return The kurtosis of a set of values.  Double.NaN is returned for\n-\t *         an empty set of values and 0.0 is returned for a &lt;= 3 value set.\n-\t */\n-\tpublic double getKurtosis() {\n-\t\t\n-\t\tif( n < 1) return Double.NaN;\n-\t\tif( n <= 3 ) return 0.0;\n-\t\t\n-\t\tdouble x1 = -6*Math.pow(sum,4);\n-\t\tdouble x2 = 12*((double)n)*Math.pow(sum,2)*sumsq;\n-\t\tdouble x3 = -3*((double)(n*(n-1)))*Math.pow(sumsq,2);\n-\t\tdouble x4 = -4*((double)(n*(n+1)))*sum*sumCube;\n-\t\tdouble x5 = Math.pow(((double)n),2)*((double)(n+1))*sumQuad;\n-\t\t\n-\t\treturn (x1 + x2 + x3 + x4 + x5) / \n-\t\t\t   ( (double)(n*(n-1)*(n-2)*(n-3)) );\n-\t} \n-\t\n+     * @return The kurtosis of a set of values.  Double.NaN is returned for\n+     *         an empty set of values and 0.0 is returned for a &lt;= 3 value set.\n+     */\n+    public double getKurtosis() {\n+        \n+        if( n < 1) return Double.NaN;\n+        if( n <= 3 ) return 0.0;\n+        \n+        double x1 = -6 * Math.pow(sum, 4);\n+        double x2 = 12 * ((double) n) * Math.pow(sum, 2) * sumsq;\n+        double x3 = -3 * ((double) (n * (n - 1))) * Math.pow(sumsq,2);\n+        double x4 = -4 * ((double) (n * (n + 1))) * sum * sumCube;\n+        double x5 = Math.pow(((double) n),2) * ((double) (n+1)) * sumQuad;\n+        \n+        return (x1 + x2 + x3 + x4 + x5) / \n+               ( (double) (n * (n - 1) * (n - 2) * (n - 3)) );\n+    } \n+    \n     /**\n      * Called in \"addValue\" to insert a new value into the statistic.\n-\t * @param v The value to be added.\n-\t */\n-\tprivate void insertValue(double v) {\n+     * @param v The value to be added.\n+     */\n+    private void insertValue(double v) {\n \n         // The default value of product is NaN, if you\n         // try to retrieve the product for a univariate with\n                 // Remove the influence of the discarded\n                 sum -= discarded;\n                 sumsq -= discarded * discarded;\n-\t\t\t\tsumCube -= Math.pow(discarded,3);\n-\t\t\t\tsumQuad -= Math.pow(discarded,4); \n-\t\t\t\t\n+                sumCube -= Math.pow(discarded, 3);\n+                sumQuad -= Math.pow(discarded, 4); \n+                \n                 if(discarded == min) {\n                     min = doubleArray.getMin();\n-                } else {\n-                    if(discarded == max){\n+                } else if(discarded == max){\n                     max = doubleArray.getMax();\n-                    }\n                 } \n                 \n                 if(product != 0.0){\n                     // can safely remove discarded value\n-                    product *= v/discarded;\n+                    product *=  v / discarded;\n                 } else if(discarded == 0.0){\n                     // need to recompute product\n                     product = 1.0;\n                     double[] elements = doubleArray.getElements();\n                     for( int i = 0; i < elements.length; i++ ) {\n-                    \tproduct *= elements[i];\n+                        product *= elements[i];\n                     }\n                 } // else product = 0 and will still be 0 after discard\n \n             } else {\n-                doubleArray.addElement( v );        \t\n+                doubleArray.addElement( v );            \n                 n += 1.0;\n-                if (v < min) min = v;\n-                if (v > max) max = v;\n+                if (v < min) {\n+                    min = v;\n+                }\n+                if (v > max) {\n+                    max = v;\n+                }\n                 product *= v;\n             }\n         } else {\n             // worry about storing any values.  We don't need to discard the\n             // influence of any single item.\n             n += 1.0;\n-            if (v < min) min = v;\n-            if (v > max) max = v;\n+            if (v < min) {\n+                min = v;\n+            } \n+            if (v > max) {\n+                max = v;\n+            } \n             product *= v;\n         }\n         \n-\t\tsum += v;\n-\t\tsumsq += v*v;\n-\t\tsumCube += Math.pow(v,3);\n-\t\tsumQuad += Math.pow(v,4);\n+        sum += v;\n+        sumsq += v * v;\n+        sumCube += Math.pow(v,3);\n+        sumQuad += Math.pow(v,4);\n     }\n \n     /** Getter for property max.\n         return sumsq;\n     }\n \n-\t/** Getter for property sumCube.\n-\t * @return Value of property sumCube.\n-\t */\n-\tpublic double getSumCube() {\n-\t\treturn sumCube;\n-\t}\n-\t\n-\t/** Getter for property sumQuad.\n-\t * @return Value of property sumQuad.\n-\t */\n-\tpublic double getSumQuad() {\n-\t\treturn sumQuad;\n-\t}\n-\t\n+    /** Getter for property sumCube.\n+     * @return Value of property sumCube.\n+     */\n+    public double getSumCube() {\n+        return sumCube;\n+    }\n+    \n+    /** Getter for property sumQuad.\n+     * @return Value of property sumQuad.\n+     */\n+    public double getSumQuad() {\n+        return sumQuad;\n+    }\n+    \n     /**\n      * Generates a text report displaying \n      * univariate statistics from values that\n         outBuffer.append(\"max: \" + max + \"\\n\");\n         outBuffer.append(\"mean: \" + getMean() + \"\\n\");\n         outBuffer.append(\"std dev: \" + getStandardDeviation() + \"\\n\");\n-\t\toutBuffer.append(\"skewness: \" + getSkewness() + \"\\n\");\n-\t\toutBuffer.append(\"kurtosis: \" + getKurtosis() + \"\\n\");\n+        outBuffer.append(\"skewness: \" + getSkewness() + \"\\n\");\n+        outBuffer.append(\"kurtosis: \" + getKurtosis() + \"\\n\");\n         return outBuffer.toString();\n     }\n     \n--- a/src/test/org/apache/commons/math/distribution/TDistributionTest.java\n+++ b/src/test/org/apache/commons/math/distribution/TDistributionTest.java\n         super.tearDown();\n     }\n \n-    public void testLowerTailProbability(){\n+    public void testInverseCummulativeProbability001() {\n+        testValue(-5.893, .001);\n+    }\n+    \n+    public void testInverseCumulativeProbability010() {\n+        testValue(-3.365, .010);\n+    }\n+    \n+    public void testInverseCumulativeProbability025() {\n+        testValue(-2.571, .025);\n+    }\n+\n+    public void testInverseCumulativeProbability050() {\n+        testValue(-2.015, .050);\n+    }\n+    \n+    public void testInverseCumulativeProbability100() {\n+        testValue(-1.476, .100);\n+    }\n+\n+    public void testInverseCummulativeProbability999() {\n+        testValue(5.893, .999);\n+    }\n+    \n+    public void testInverseCumulativeProbability990() {\n+        testValue(3.365, .990);\n+    }\n+    \n+    public void testInverseCumulativeProbability975() {\n+        testValue(2.571, .975);\n+    }\n+\n+    public void testInverseCumulativeProbability950() {\n+        testValue(2.015, .950);\n+    }\n+    \n+    public void testInverseCumulativeProbability900() {\n+        testValue(1.476, .900);\n+    }\n+\n+    public void testCummulativeProbability001() {\n         testProbability(-5.893, .001);\n+    }\n+    \n+    public void testCumulativeProbability010() {\n         testProbability(-3.365, .010);\n+    }\n+    \n+    public void testCumulativeProbability025() {\n         testProbability(-2.571, .025);\n+    }\n+\n+    public void testCumulativeProbability050() {\n         testProbability(-2.015, .050);\n+    }\n+    \n+    public void testCumulativeProbability100() {\n         testProbability(-1.476, .100);\n     }\n \n-    public void testUpperTailProbability(){\n+    public void testCummulativeProbability999() {\n         testProbability(5.893, .999);\n-        testProbability(3.365, .990);\n-        testProbability(2.571, .975);\n-        testProbability(2.015, .950);\n-        testProbability(1.476, .900);\n     }\n     \n-    public void testLowerTailValues(){\n-        testValue(-5.893, .001);\n-        testValue(-3.365, .010);\n-        testValue(-2.571, .025);\n-        testValue(-2.015, .050);\n-        testValue(-1.476, .100);\n+    public void testCumulativeProbability990() {\n+        testProbability(3.365, .990);\n     }\n     \n-    public void testUpperTailValues(){\n-        testValue(5.893, .999);\n-        testValue(3.365, .990);\n-        testValue(2.571, .975);\n-        testValue(2.015, .950);\n-        testValue(1.476, .900);\n+    public void testCumulativeProbability975() {\n+        testProbability(2.571, .975);\n+    }\n+\n+    public void testCumulativeProbability950() {\n+        testProbability(2.015, .950);\n+    }\n+    \n+    public void testCumulativeProbability900() {\n+        testProbability(1.476, .900);\n     }\n     \n     private void testProbability(double x, double expected){\n         double actual = t.cummulativeProbability(x);\n-        assertEquals(\"probability for \" + x, expected, actual, 10e-4);\n+        assertEquals(expected, actual, 10e-4);\n     }\n     \n     private void testValue(double expected, double p){\n         double actual = t.inverseCummulativeProbability(p);\n-        assertEquals(\"value for \" + p, expected, actual, 10e-4);\n+        assertEquals(expected, actual, 10e-4);\n     }\n }\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/special/BetaTest.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.special;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @author Brent Worden\n+ */\n+public class BetaTest extends TestCase {\n+    /**\n+     * Constructor for BetaTest.\n+     * @param name\n+     */\n+    public BetaTest(String name) {\n+        super(name);\n+    }\n+\n+    private void testRegularizedBeta(double expected, double x, double a, double b) {\n+        double actual = Beta.regularizedBeta(x, a, b);\n+        if (Double.isNaN(expected)) {\n+            assertTrue(Double.isNaN(actual));\n+        } else {\n+            assertEquals(expected, actual, 10e-5);\n+        }\n+    }\n+\n+    private void testLogBeta(double expected, double a, double b) {\n+        double actual = Beta.logBeta(a, b);\n+        if (Double.isNaN(expected)) {\n+            assertTrue(Double.isNaN(actual));\n+        } else {\n+            assertEquals(expected, actual, 10e-5);\n+        }\n+    }\n+\n+    public void testRegularizedBetaNanPositivePositive() {\n+        testRegularizedBeta(Double.NaN, Double.NaN, 1.0, 1.0);\n+    }\n+\n+    public void testRegularizedBetaPositiveNanPositive() {\n+        testRegularizedBeta(Double.NaN, 0.5, Double.NaN, 1.0);\n+    }\n+\n+    public void testRegularizedBetaPositivePositiveNan() {\n+        testRegularizedBeta(Double.NaN, 0.5, 1.0, Double.NaN);\n+    }\n+    \n+    public void testRegularizedBetaNegativePositivePositive() {\n+        testRegularizedBeta(Double.NaN, -0.5, 1.0, 2.0);\n+    }\n+    \n+    public void testRegularizedBetaPositiveNegativePositive() {\n+        testRegularizedBeta(Double.NaN, 0.5, -1.0, 2.0);\n+    }\n+    \n+    public void testRegularizedBetaPositivePositiveNegative() {\n+        testRegularizedBeta(Double.NaN, 0.5, 1.0, -2.0);\n+    }\n+    \n+    public void testRegularizedBetaZeroPositivePositive() {\n+        testRegularizedBeta(0.0, 0.0, 1.0, 2.0);\n+    }\n+    \n+    public void testRegularizedBetaPositiveZeroPositive() {\n+        testRegularizedBeta(Double.NaN, 0.5, 0.0, 2.0);\n+    }\n+    \n+    public void testRegularizedBetaPositivePositiveZero() {\n+        testRegularizedBeta(Double.NaN, 0.5, 1.0, 0.0);\n+    }\n+    \n+    public void testRegularizedBetaPositivePositivePositive() {\n+        testRegularizedBeta(0.75, 0.5, 1.0, 2.0);\n+    }\n+    \n+    public void testLogBetaNanPositive() {\n+        testLogBeta(Double.NaN, Double.NaN, 2.0);\n+    }\n+    \n+    public void testLogBetaPositiveNan() {\n+        testLogBeta(Double.NaN, 1.0, Double.NaN);\n+    }\n+    \n+    public void testLogBetaNegativePositive() {\n+        testLogBeta(Double.NaN, -1.0, 2.0);\n+    }\n+    \n+    public void testLogBetaPositiveNegative() {\n+        testLogBeta(Double.NaN, 1.0, -2.0);\n+    }\n+    \n+    public void testLogBetaZeroPositive() {\n+        testLogBeta(Double.NaN, 0.0, 2.0);\n+    }\n+    \n+    public void testLogBetaPositiveZero() {\n+        testLogBeta(Double.NaN, 1.0, 0.0);\n+    }\n+    \n+    public void testLogBetaPositivePositive() {\n+        testLogBeta(-0.693147, 1.0, 2.0);\n+    }\n+}", "timestamp": 1055564269, "metainfo": ""}