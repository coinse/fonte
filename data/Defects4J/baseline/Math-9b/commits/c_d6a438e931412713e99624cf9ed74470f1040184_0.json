{"sha": "d6a438e931412713e99624cf9ed74470f1040184", "log": "moved main java directory for compliance with maven standard directory layout  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ArgumentOutsideDomainException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math;\n+\n+/**\n+ * Error thrown when a method is called with an out of bounds argument.\n+ *\n+ * @since 1.2\n+ * @version $Revision$ $Date$\n+ */\n+public class ArgumentOutsideDomainException extends FunctionEvaluationException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -4965972841162580234L;\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param argument  the failing function argument \n+     * @param lower lower bound of the domain\n+     * @param upper upper bound of the domain\n+     */\n+    public ArgumentOutsideDomainException(double argument, double lower, double upper) {\n+        super(argument,\n+              \"Argument {0} outside domain [{1} ; {2}]\", argument, lower, upper);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ConvergenceException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math;\n+\n+/**\n+ * Error thrown when a numerical computation can not be performed because the\n+ * numerical result failed to converge to a finite value.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class ConvergenceException extends MathException {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 4883703247677159141L;\n+\n+    /**\n+     * Default constructor.\n+     */\n+    public ConvergenceException() {\n+        super(\"Convergence failed\");\n+    }\n+    \n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 1.2\n+     */\n+    public ConvergenceException(String pattern, Object ... arguments) {\n+        super(pattern, arguments);\n+    }\n+\n+    /**\n+     * Create an exception with a given root cause.\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     */\n+    public ConvergenceException(Throwable cause) {\n+        super(cause);\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message and root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 1.2\n+     */\n+    public ConvergenceException(Throwable cause, String pattern, Object ... arguments) {\n+        super(cause, pattern, arguments);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ConvergingAlgorithm.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math;\n+\n+\n+/**\n+ * Interface for algorithms handling convergence settings.\n+ * <p>\n+ * This interface only deals with convergence parameters setting, not\n+ * execution of the algorithms per se.\n+ * </p>\n+ * @see ConvergenceException\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface ConvergingAlgorithm {\n+\n+    /**\n+     * Set the upper limit for the number of iterations.\n+     * <p>\n+     * Usually a high iteration count indicates convergence problems. However,\n+     * the \"reasonable value\" varies widely for different algorithms. Users are\n+     * advised to use the default value supplied by the algorithm.</p>\n+     * <p>\n+     * A {@link ConvergenceException} will be thrown if this number\n+     * is exceeded.</p>\n+     *  \n+     * @param count maximum number of iterations\n+     */\n+    public abstract void setMaximalIterationCount(int count);\n+\n+    /**\n+     * Get the upper limit for the number of iterations.\n+     * \n+     * @return the actual upper limit\n+     */\n+    public abstract int getMaximalIterationCount();\n+\n+    /**\n+     * Reset the upper limit for the number of iterations to the default.\n+     * <p>\n+     * The default value is supplied by the algorithm implementation.</p>\n+     * \n+     * @see #setMaximalIterationCount(int)\n+     */\n+    public abstract void resetMaximalIterationCount();\n+\n+    /**\n+     * Set the absolute accuracy.\n+     * <p>\n+     * The default is usually chosen so that results in the interval\n+     * -10..-0.1 and +0.1..+10 can be found with a reasonable accuracy. If the\n+     * expected absolute value of your results is of much smaller magnitude, set\n+     * this to a smaller value.</p>\n+     * <p>\n+     * Algorithms are advised to do a plausibility check with the relative\n+     * accuracy, but clients should not rely on this.</p>\n+     *  \n+     * @param accuracy the accuracy.\n+     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+     * the solver or is otherwise deemed unreasonable. \n+     */\n+    public abstract void setAbsoluteAccuracy(double accuracy);\n+\n+    /**\n+     * Get the actual absolute accuracy.\n+     * \n+     * @return the accuracy\n+     */\n+    public abstract double getAbsoluteAccuracy();\n+\n+    /**\n+     * Reset the absolute accuracy to the default.\n+     * <p>\n+     * The default value is provided by the algorithm implementation.</p>\n+     */\n+    public abstract void resetAbsoluteAccuracy();\n+\n+    /**\n+     * Set the relative accuracy.\n+     * <p>\n+     * This is used to stop iterations if the absolute accuracy can't be\n+     * achieved due to large values or short mantissa length.</p>\n+     * <p>\n+     * If this should be the primary criterion for convergence rather then a\n+     * safety measure, set the absolute accuracy to a ridiculously small value,\n+     * like {@link org.apache.commons.math.util.MathUtils#SAFE_MIN MathUtils.SAFE_MIN}.</p>\n+     * \n+     * @param accuracy the relative accuracy.\n+     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+     *  the algorithm or is otherwise deemed unreasonable. \n+     */\n+    public abstract void setRelativeAccuracy(double accuracy);\n+\n+    /**\n+     * Get the actual relative accuracy.\n+     * @return the accuracy\n+     */\n+    public abstract double getRelativeAccuracy();\n+\n+    /**\n+     * Reset the relative accuracy to the default.\n+     * The default value is provided by the algorithm implementation.\n+     */\n+    public abstract void resetRelativeAccuracy();\n+\n+    /**\n+     * Get the number of iterations in the last run of the algorithm.\n+     * <p>\n+     * This is mainly meant for testing purposes. It may occasionally\n+     * help track down performance problems: if the iteration count\n+     * is notoriously high, check whether the problem is evaluated\n+     * properly, and whether another algorithm is more amenable to the\n+     * problem.</p>\n+     * \n+     * @return the last iteration count.\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed.\n+     */\n+    public abstract int getIterationCount();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ConvergingAlgorithmImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math;\n+\n+\n+/**\n+ * Provide a default implementation for several functions useful to generic\n+ * converging algorithms.\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class ConvergingAlgorithmImpl implements ConvergingAlgorithm{\n+\n+    /** Maximum absolute error. */\n+    protected double absoluteAccuracy;\n+\n+    /** Maximum relative error. */\n+    protected double relativeAccuracy;\n+\n+    /** Maximum number of iterations. */\n+    protected int maximalIterationCount;\n+\n+    /** Default maximum absolute error. */\n+    protected double defaultAbsoluteAccuracy;\n+\n+    /** Default maximum relative error. */\n+    protected double defaultRelativeAccuracy;\n+\n+    /** Default maximum number of iterations. */\n+    protected int defaultMaximalIterationCount;\n+\n+    // Mainly for test framework.\n+    /** The last iteration count. */\n+    protected int iterationCount;\n+\n+    /**\n+     * Construct an algorithm with given iteration count and accuracy.\n+     * \n+     * @param defaultAbsoluteAccuracy maximum absolute error\n+     * @param defaultMaximalIterationCount maximum number of iterations\n+     * @throws IllegalArgumentException if f is null or the \n+     * defaultAbsoluteAccuracy is not valid\n+     */\n+    protected ConvergingAlgorithmImpl(final int defaultMaximalIterationCount,\n+                                      final double defaultAbsoluteAccuracy) {\n+        this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\n+        this.defaultRelativeAccuracy = 1.0e-14;\n+        this.absoluteAccuracy = defaultAbsoluteAccuracy;\n+        this.relativeAccuracy = defaultRelativeAccuracy;\n+        this.defaultMaximalIterationCount = defaultMaximalIterationCount;\n+        this.maximalIterationCount = defaultMaximalIterationCount;\n+        this.iterationCount = 0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterationCount() {\n+        return iterationCount;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setAbsoluteAccuracy(double accuracy) {\n+        absoluteAccuracy = accuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getAbsoluteAccuracy() {\n+        return absoluteAccuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void resetAbsoluteAccuracy() {\n+        absoluteAccuracy = defaultAbsoluteAccuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaximalIterationCount(int count) {\n+        maximalIterationCount = count;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaximalIterationCount() {\n+        return maximalIterationCount;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void resetMaximalIterationCount() {\n+        maximalIterationCount = defaultMaximalIterationCount;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setRelativeAccuracy(double accuracy) {\n+        relativeAccuracy = accuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getRelativeAccuracy() {\n+        return relativeAccuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void resetRelativeAccuracy() {\n+        relativeAccuracy = defaultRelativeAccuracy;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/DimensionMismatchException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math;\n+\n+/**\n+ * Error thrown when two dimensions differ.\n+ * \n+ * @since 1.2\n+ * @version $Revision$ $Date$\n+ */\n+public class DimensionMismatchException extends MathException {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -1316089546353786411L;\n+\n+    /**\n+     * Construct an exception from the mismatched dimensions\n+     * @param dimension1 first dimension\n+     * @param dimension2 second dimension\n+     */\n+    public DimensionMismatchException(int dimension1, int dimension2) {\n+        super(\"dimension mismatch {0} != {1}\", dimension1, dimension2);\n+        this.dimension1 = dimension1;\n+        this.dimension2 = dimension2;\n+    }\n+\n+    /**\n+     * Get the first dimension\n+     * @return first dimension\n+     */\n+    public int getDimension1() {\n+        return dimension1;\n+    }\n+    \n+    /**\n+     * Get the second dimension\n+     * @return second dimension\n+     */\n+    public int getDimension2() {\n+        return dimension2;\n+    }\n+\n+    /** First dimension. */\n+    private int dimension1;\n+    \n+    /** Second dimension. */\n+    private int dimension2;\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/DuplicateSampleAbscissaException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math;\n+\n+/**\n+ * Exeption thrown when a sample contains several entries at the same abscissa.\n+ * \n+ * @since 1.2\n+ * @version $Revision$ $Date$\n+ */\n+public class DuplicateSampleAbscissaException extends MathException  {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -2271007547170169872L;\n+\n+    /**\n+     * Construct an exception indicating the duplicate abscissa.\n+     * @param abscissa duplicate abscissa\n+     * @param i1 index of one entry having the duplicate abscissa\n+     * @param i2 index of another entry having the duplicate abscissa\n+     */\n+    public DuplicateSampleAbscissaException(double abscissa, int i1, int i2) {\n+        super(\"Abscissa {0} is duplicated at both indices {1} and {2}\",\n+              abscissa, i1, i2);\n+    }\n+\n+    /**\n+     * Get the duplicate abscissa.\n+     * @return duplicate abscissa\n+     */\n+    public double getDuplicateAbscissa() {\n+        return ((Double) getArguments()[0]).doubleValue();\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/Field.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math;\n+\n+/**\n+ * Interface representing a <a href=\"http://mathworld.wolfram.com/Field.html\">field</a>.\n+ * <p>\n+ * Classes implementing this interface will often be singletons.\n+ * </p>\n+ * @param <T> the type of the field elements\n+ * @see FieldElement\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface Field<T> {\n+\n+    /** Get the additive identity of the field.\n+     * <p>\n+     * The additive identity is the element e<sub>0</sub> of the field such that\n+     * for all elements a of the field, the equalities a + e<sub>0</sub> =\n+     * e<sub>0</sub> + a = a hold.\n+     * </p>\n+     * @return additive identity of the field\n+     */\n+    T getZero();\n+\n+    /** Get the multiplicative identity of the field.\n+     * <p>\n+     * The multiplicative identity is the element e<sub>1</sub> of the field such that\n+     * for all elements a of the field, the equalities a &times; e<sub>1</sub> =\n+     * e<sub>1</sub> &times; a = a hold.\n+     * </p>\n+     * @return multiplicative identity of the field\n+     */\n+    T getOne();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/FieldElement.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math;\n+\n+\n+/**\n+ * Interface representing <a href=\"http://mathworld.wolfram.com/Field.html\">field</a> elements.\n+ * @param <T> the type of the field elements\n+ * @see Field\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface FieldElement<T> {\n+\n+    /** Compute this + a.\n+     * @param a element to add\n+     * @return a new element representing this + a\n+     */\n+    T add(T a);\n+\n+    /** Compute this - a.\n+     * @param a element to subtract\n+     * @return a new element representing this - a\n+     */\n+    T subtract(T a);\n+\n+    /** Compute this &times; a.\n+     * @param a element to multiply\n+     * @return a new element representing this &times; a\n+     */\n+    T multiply(T a);\n+\n+    /** Compute this &divide; a.\n+     * @param a element to add\n+     * @return a new element representing this &divide; a\n+     * @exception ArithmeticException if a is the zero of the\n+     * additive operation (i.e. additive identity)\n+     */\n+    T divide(T a) throws ArithmeticException;\n+\n+    /** Get the {@link Field} to which the instance belongs.\n+     * @return {@link Field} to which the instance belongs\n+     */\n+    Field<T> getField();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/FunctionEvaluationException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math;\n+\n+import org.apache.commons.math.linear.ArrayRealVector;\n+\n+/**\n+ * Exception thrown when an error occurs evaluating a function.\n+ * <p>\n+ * Maintains an <code>argument</code> property holding the input value that\n+ * caused the function evaluation to fail.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class FunctionEvaluationException extends MathException  {\n+    \n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -4305020489115478365L;\n+\n+    /** Argument causing function evaluation failure */\n+    private double[] argument;\n+    \n+    /**\n+     * Construct an exception indicating the argument value\n+     * that caused the function evaluation to fail.\n+     * \n+     * @param argument  the failing function argument \n+     */\n+    public FunctionEvaluationException(double argument) {\n+        super(\"evaluation failed for argument = {0}\", argument);\n+        this.argument = new double[] { argument };\n+    }\n+    \n+    /**\n+     * Construct an exception indicating the argument value\n+     * that caused the function evaluation to fail.\n+     * \n+     * @param argument  the failing function argument \n+     * @since 2.0\n+     */\n+    public FunctionEvaluationException(double[] argument) {\n+        super(\"evaluation failed for argument = {0}\", new ArrayRealVector(argument));\n+        this.argument = argument.clone();\n+    }\n+    \n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param argument  the failing function argument \n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 1.2\n+     */\n+    public FunctionEvaluationException(double argument,\n+                                       String pattern, Object ... arguments) {\n+        super(pattern, arguments);\n+        this.argument = new double[] { argument };\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param argument  the failing function argument \n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.0\n+     */\n+    public FunctionEvaluationException(double[] argument,\n+                                       String pattern, Object ... arguments) {\n+        super(pattern, arguments);\n+        this.argument = argument.clone();\n+    }\n+\n+    /**\n+     * Constructs an exception with specified root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     * @param argument  the failing function argument \n+     * @since 1.2\n+     */\n+    public FunctionEvaluationException(Throwable cause, double argument) {\n+        super(cause);\n+        this.argument = new double[] { argument };\n+    }\n+\n+    /**\n+     * Constructs an exception with specified root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     * @param argument  the failing function argument \n+     * @since 2.0\n+     */\n+    public FunctionEvaluationException(Throwable cause, double[] argument) {\n+        super(cause);\n+        this.argument = argument.clone();\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message and root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     * @param argument  the failing function argument \n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 1.2\n+     */\n+    public FunctionEvaluationException(Throwable cause,\n+                                       double argument, String pattern,\n+                                       Object ... arguments) {\n+        super(cause, pattern, arguments);\n+        this.argument = new double[] { argument };\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message and root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     * @param argument  the failing function argument \n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.0\n+     */\n+    public FunctionEvaluationException(Throwable cause,\n+                                       double[] argument, String pattern,\n+                                       Object ... arguments) {\n+        super(cause, pattern, arguments);\n+        this.argument = argument.clone();\n+    }\n+\n+    /**\n+     * Returns the function argument that caused this exception.\n+     * \n+     * @return  argument that caused function evaluation to fail\n+     */\n+    public double[] getArgument() {\n+        return argument.clone();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/MathConfigurationException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Signals a configuration problem with any of the factory methods.\n+ * @version $Revision$ $Date$\n+ */\n+public class MathConfigurationException extends MathException implements Serializable{\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 5261476508226103366L;\n+\n+    /**\n+     * Default constructor.\n+     */\n+    public MathConfigurationException() {\n+        super();\n+    }\n+    \n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 1.2\n+     */\n+    public MathConfigurationException(String pattern, Object ... arguments) {\n+        super(pattern, arguments);\n+    }\n+\n+    /**\n+     * Create an exception with a given root cause.\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     */\n+    public MathConfigurationException(Throwable cause) {\n+        super(cause);\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message and root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 1.2\n+     */\n+    public MathConfigurationException(Throwable cause, String pattern, Object ... arguments) {\n+        super(cause, pattern, arguments);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/MathException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math;\n+\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.text.MessageFormat;\n+import java.util.Locale;\n+import java.util.MissingResourceException;\n+import java.util.ResourceBundle;\n+\n+\n+/**\n+* Base class for commons-math checked exceptions.\n+* <p>\n+* Supports nesting, emulating JDK 1.4 behavior if necessary.</p>\n+* <p>\n+* Adapted from <a href=\"http://commons.apache.org/collections/api-release/org/apache/commons/collections/FunctorException.html\"/>.</p>\n+* \n+* @version $Revision$ $Date$\n+*/\n+public class MathException extends Exception {\n+    \n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -9004610152740737812L;\n+\n+    /**\n+     * Pattern used to build the message.\n+     */\n+    private final String pattern;\n+\n+    /**\n+     * Arguments used to build the message.\n+     */\n+    private final Object[] arguments;\n+\n+    /**\n+     * Translate a string to a given locale.\n+     * @param s string to translate\n+     * @param locale locale into which to translate the string\n+     * @return translated string or original string\n+     * for unsupported locales or unknown strings\n+     */\n+    private static String translate(String s, Locale locale) {\n+        try {\n+            ResourceBundle bundle =\n+                    ResourceBundle.getBundle(\"org.apache.commons.math.MessagesResources\", locale);\n+            if (bundle.getLocale().getLanguage().equals(locale.getLanguage())) {\n+                // the value of the resource is the translated string\n+                return bundle.getString(s);\n+            }\n+            \n+        } catch (MissingResourceException mre) {\n+            // do nothing here\n+        }\n+\n+        // the locale is not supported or the resource is unknown\n+        // don't translate and fall back to using the string as is\n+        return s;\n+\n+    }\n+\n+    /**\n+     * Builds a message string by from a pattern and its arguments.\n+     * @param locale Locale in which the message should be translated\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return a message string\n+     */\n+    private static String buildMessage(Locale locale, String pattern, Object ... arguments) {\n+        return (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);        \n+    }\n+\n+    /**\n+     * Constructs a new <code>MathException</code> with no\n+     * detail message.\n+     */\n+    public MathException() {\n+        super();\n+        this.pattern   = null;\n+        this.arguments = new Object[0];\n+    }\n+    \n+    /**\n+     * Constructs a new <code>MathException</code> with specified\n+     * formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public MathException(String pattern, Object ... arguments) {\n+      super(buildMessage(Locale.US, pattern, arguments));\n+      this.pattern   = pattern;\n+      this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n+    }\n+\n+    /**\n+     * Constructs a new <code>MathException</code> with specified\n+     * nested <code>Throwable</code> root cause.\n+     *\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public MathException(Throwable rootCause) {\n+        super(rootCause);\n+        this.pattern   = getMessage();\n+        this.arguments = new Object[0];\n+    }\n+    \n+    /**\n+     * Constructs a new <code>MathException</code> with specified\n+     * formatted detail message and nested <code>Throwable</code> root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param rootCause the exception or error that caused this exception\n+     * to be thrown.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 1.2\n+     */\n+    public MathException(Throwable rootCause, String pattern, Object ... arguments) {\n+      super(buildMessage(Locale.US, pattern, arguments), rootCause);\n+      this.pattern   = pattern;\n+      this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n+    }\n+\n+    /** Gets the pattern used to build the message of this throwable.\n+     *\n+     * @return the pattern used to build the message of this throwable\n+     * @since 1.2\n+     */\n+    public String getPattern() {\n+        return pattern;\n+    }\n+\n+    /** Gets the arguments used to build the message of this throwable.\n+     *\n+     * @return the arguments used to build the message of this throwable\n+     * @since 1.2\n+     */\n+    public Object[] getArguments() {\n+        return arguments.clone();\n+    }\n+\n+    /** Gets the message in a specified locale.\n+     *\n+     * @param locale Locale in which the message should be translated\n+     * \n+     * @return localized message\n+     * @since 1.2\n+     */\n+    public String getMessage(Locale locale) {\n+        return buildMessage(locale, pattern, arguments);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public String getLocalizedMessage() {\n+        return getMessage(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Prints the stack trace of this exception to the standard error stream.\n+     */\n+    @Override\n+    public void printStackTrace() {\n+        printStackTrace(System.err);\n+    }\n+    \n+    /**\n+     * Prints the stack trace of this exception to the specified stream.\n+     *\n+     * @param out  the <code>PrintStream</code> to use for output\n+     */\n+    @Override\n+    public void printStackTrace(PrintStream out) {\n+        synchronized (out) {\n+            PrintWriter pw = new PrintWriter(out, false);\n+            printStackTrace(pw);\n+            // Flush the PrintWriter before it's GC'ed.\n+            pw.flush();\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/MathRuntimeException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math;\n+\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+import java.text.MessageFormat;\n+import java.text.ParseException;\n+import java.util.ConcurrentModificationException;\n+import java.util.Locale;\n+import java.util.MissingResourceException;\n+import java.util.NoSuchElementException;\n+import java.util.ResourceBundle;\n+\n+/**\n+* Base class for commons-math unchecked exceptions.\n+* \n+* @version $Revision$ $Date$\n+* @since 2.0\n+*/\n+public class MathRuntimeException extends RuntimeException {\n+    \n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -5128983364075381060L;\n+\n+    /**\n+     * Pattern used to build the message.\n+     */\n+    private final String pattern;\n+\n+    /**\n+     * Arguments used to build the message.\n+     */\n+    private final Object[] arguments;\n+\n+    /**\n+     * Translate a string to a given locale.\n+     * @param s string to translate\n+     * @param locale locale into which to translate the string\n+     * @return translated string or original string\n+     * for unsupported locales or unknown strings\n+     */\n+    private static String translate(final String s, final Locale locale) {\n+        try {\n+            ResourceBundle bundle =\n+                    ResourceBundle.getBundle(\"org.apache.commons.math.MessagesResources\", locale);\n+            if (bundle.getLocale().getLanguage().equals(locale.getLanguage())) {\n+                // the value of the resource is the translated string\n+                return bundle.getString(s);\n+            }\n+            \n+        } catch (MissingResourceException mre) {\n+            // do nothing here\n+        }\n+\n+        // the locale is not supported or the resource is unknown\n+        // don't translate and fall back to using the string as is\n+        return s;\n+\n+    }\n+\n+    /**\n+     * Builds a message string by from a pattern and its arguments.\n+     * @param locale Locale in which the message should be translated\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return a message string\n+     */\n+    private static String buildMessage(final Locale locale, final String pattern,\n+                                       final Object ... arguments) {\n+        return (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);        \n+    }\n+\n+    /**\n+     * Constructs a new <code>MathRuntimeException</code> with specified\n+     * formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public MathRuntimeException(final String pattern, final Object ... arguments) {\n+      super(buildMessage(Locale.US, pattern, arguments));\n+      this.pattern   = pattern;\n+      this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n+    }\n+\n+    /**\n+     * Constructs a new <code>MathRuntimeException</code> with specified\n+     * nested <code>Throwable</code> root cause.\n+     *\n+     * @param rootCause  the exception or error that caused this exception\n+     *                   to be thrown.\n+     */\n+    public MathRuntimeException(final Throwable rootCause) {\n+        super(rootCause);\n+        this.pattern   = getMessage();\n+        this.arguments = new Object[0];\n+    }\n+    \n+    /**\n+     * Constructs a new <code>MathRuntimeException</code> with specified\n+     * formatted detail message and nested <code>Throwable</code> root cause.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param rootCause the exception or error that caused this exception\n+     * to be thrown.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public MathRuntimeException(final Throwable rootCause,\n+                                final String pattern, final Object ... arguments) {\n+      super(buildMessage(Locale.US, pattern, arguments), rootCause);\n+      this.pattern   = pattern;\n+      this.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n+    }\n+\n+    /** Gets the pattern used to build the message of this throwable.\n+     *\n+     * @return the pattern used to build the message of this throwable\n+     */\n+    public String getPattern() {\n+        return pattern;\n+    }\n+\n+    /** Gets the arguments used to build the message of this throwable.\n+     *\n+     * @return the arguments used to build the message of this throwable\n+     */\n+    public Object[] getArguments() {\n+        return arguments.clone();\n+    }\n+\n+    /** Gets the message in a specified locale.\n+     *\n+     * @param locale Locale in which the message should be translated\n+     * \n+     * @return localized message\n+     */\n+    public String getMessage(final Locale locale) {\n+        return buildMessage(locale, pattern, arguments);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public String getLocalizedMessage() {\n+        return getMessage(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Prints the stack trace of this exception to the standard error stream.\n+     */\n+    @Override\n+    public void printStackTrace() {\n+        printStackTrace(System.err);\n+    }\n+    \n+    /**\n+     * Prints the stack trace of this exception to the specified stream.\n+     *\n+     * @param out  the <code>PrintStream</code> to use for output\n+     */\n+    @Override\n+    public void printStackTrace(final PrintStream out) {\n+        synchronized (out) {\n+            PrintWriter pw = new PrintWriter(out, false);\n+            printStackTrace(pw);\n+            // Flush the PrintWriter before it's GC'ed.\n+            pw.flush();\n+        }\n+    }\n+\n+    /**\n+     * Constructs a new <code>ArithmeticException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     */\n+    public static ArithmeticException createArithmeticException(final String pattern,\n+                                                                final Object ... arguments) {\n+        return new ArithmeticException(buildMessage(Locale.US, pattern, arguments)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = 7705628723242533939L;\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public String getLocalizedMessage() {\n+                return buildMessage(Locale.getDefault(), pattern, arguments);\n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     * Constructs a new <code>ArrayIndexOutOfBoundsException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     */\n+    public static ArrayIndexOutOfBoundsException createArrayIndexOutOfBoundsException(final String pattern,\n+                                                                                      final Object ... arguments) {\n+        return new ArrayIndexOutOfBoundsException(buildMessage(Locale.US, pattern, arguments)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = -3394748305449283486L;\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public String getLocalizedMessage() {\n+                return buildMessage(Locale.getDefault(), pattern, arguments);\n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     * Constructs a new <code>EOFException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     */\n+    public static EOFException createEOFException(final String pattern,\n+                                                  final Object ... arguments) {\n+        return new EOFException(buildMessage(Locale.US, pattern, arguments)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = 279461544586092584L;\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public String getLocalizedMessage() {\n+                return buildMessage(Locale.getDefault(), pattern, arguments);\n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     * Constructs a new <code>IOException</code> with specified nested\n+     * <code>Throwable</code> root cause.\n+     * <p>This factory method allows chaining of other exceptions within an\n+     * <code>IOException</code> even for Java 5. The constructor for\n+     * <code>IOException</code> with a cause parameter was introduced only\n+     * with Java 6.</p>\n+     * @param rootCause the exception or error that caused this exception\n+     * to be thrown.\n+     * @return built exception\n+     */\n+    public static IOException createIOException(final Throwable rootCause) {\n+        IOException ioe = new IOException(rootCause.getLocalizedMessage());\n+        ioe.initCause(rootCause);\n+        return ioe;\n+    }\n+\n+    /**\n+     * Constructs a new <code>IllegalArgumentException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     */\n+    public static IllegalArgumentException createIllegalArgumentException(final String pattern,\n+                                                                          final Object ... arguments) {\n+        return new IllegalArgumentException(buildMessage(Locale.US, pattern, arguments)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = -6555453980658317913L;\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public String getLocalizedMessage() {\n+                return buildMessage(Locale.getDefault(), pattern, arguments);\n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     * Constructs a new <code>IllegalArgumentException</code> with specified nested\n+     * <code>Throwable</code> root cause.\n+     * @param rootCause the exception or error that caused this exception\n+     * to be thrown.\n+     * @return built exception\n+     */\n+    public static IllegalArgumentException createIllegalArgumentException(final Throwable rootCause) {\n+        IllegalArgumentException iae = new IllegalArgumentException(rootCause.getLocalizedMessage());\n+        iae.initCause(rootCause);\n+        return iae;\n+    }\n+\n+    /**\n+     * Constructs a new <code>IllegalStateException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     */\n+    public static IllegalStateException createIllegalStateException(final String pattern,\n+                                                                    final Object ... arguments) {\n+        return new IllegalStateException(buildMessage(Locale.US, pattern, arguments)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = -95247648156277208L;\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public String getLocalizedMessage() {\n+                return buildMessage(Locale.getDefault(), pattern, arguments);\n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     * Constructs a new <code>ConcurrentModificationException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     */\n+    public static ConcurrentModificationException createConcurrentModificationException(final String pattern,\n+                                                                                        final Object ... arguments) {\n+        return new ConcurrentModificationException(buildMessage(Locale.US, pattern, arguments)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = 6134247282754009421L;\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public String getLocalizedMessage() {\n+                return buildMessage(Locale.getDefault(), pattern, arguments);\n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     * Constructs a new <code>NoSuchElementException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     */\n+    public static NoSuchElementException createNoSuchElementException(final String pattern,\n+                                                                      final Object ... arguments) {\n+        return new NoSuchElementException(buildMessage(Locale.US, pattern, arguments)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = 7304273322489425799L;\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public String getLocalizedMessage() {\n+                return buildMessage(Locale.getDefault(), pattern, arguments);\n+            }\n+\n+        };\n+    }\n+\n+    /**\n+     * Constructs a new <code>NullPointerException</code> with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     */\n+    public static NullPointerException createNullPointerException(final String pattern,\n+                                                                  final Object ... arguments) {\n+        return new NullPointerException(buildMessage(Locale.US, pattern, arguments)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = -3075660477939965216L;\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public String getLocalizedMessage() {\n+                return buildMessage(Locale.getDefault(), pattern, arguments);\n+            }\n+\n+        };\n+    }\n+\n+   /**\n+     * Constructs a new <code>ParseException</code> with specified\n+     * formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param offset offset at which error occurred\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @return built exception\n+     */\n+    public static ParseException createParseException(final int offset,\n+                                                      final String pattern,\n+                                                      final Object ... arguments) {\n+        return new ParseException(buildMessage(Locale.US, pattern, arguments), offset) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = -1103502177342465975L;\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public String getLocalizedMessage() {\n+                return buildMessage(Locale.getDefault(), pattern, arguments);\n+            }\n+\n+        };\n+    }\n+\n+    /** Create an {@link java.lang.RuntimeException} for an internal error.\n+     * @param cause underlying cause\n+     * @return an {@link java.lang.RuntimeException} for an internal error\n+     */\n+    public static RuntimeException createInternalError(final Throwable cause) {\n+\n+        final String pattern  = \"internal error, please fill a bug report at {0}\";\n+        final String argument = \"https://issues.apache.org/jira/browse/MATH\";\n+\n+        return new RuntimeException(buildMessage(Locale.US, pattern, argument)) {\n+\n+            /** Serializable version identifier. */\n+            private static final long serialVersionUID = -201865440834027016L;\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public String getLocalizedMessage() {\n+                return buildMessage(Locale.getDefault(), pattern, argument);\n+            }\n+\n+        };\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/MaxEvaluationsExceededException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math;\n+\n+import org.apache.commons.math.ConvergenceException;\n+\n+/**\n+ * Error thrown when a numerical computation exceeds its allowed\n+ * number of functions evaluations.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class MaxEvaluationsExceededException extends ConvergenceException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -5921271447220129118L;\n+\n+    /** Maximal number of evaluations allowed. */\n+    private final int maxEvaluations;\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param maxEvaluations maximal number of evaluations allowed\n+     */\n+    public MaxEvaluationsExceededException(final int maxEvaluations) {\n+        super(\"Maximal number of evaluations ({0}) exceeded\", maxEvaluations);\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param maxEvaluations the exceeded maximal number of evaluations\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public MaxEvaluationsExceededException(final int maxEvaluations,\n+                                          final String pattern, final Object ... arguments) {\n+        super(pattern, arguments);\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** Get the maximal number of evaluations allowed.\n+     * @return maximal number of evaluations allowed\n+     */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/MaxIterationsExceededException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math;\n+\n+import org.apache.commons.math.ConvergenceException;\n+\n+/**\n+ * Error thrown when a numerical computation exceeds its allowed\n+ * number of iterations.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class MaxIterationsExceededException extends ConvergenceException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -7821226672760574694L;\n+\n+    /** Maximal number of iterations allowed. */\n+    private final int maxIterations;\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param maxIterations maximal number of iterations allowed\n+     */\n+    public MaxIterationsExceededException(final int maxIterations) {\n+        super(\"Maximal number of iterations ({0}) exceeded\", maxIterations);\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param maxIterations the exceeded maximal number of iterations\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public MaxIterationsExceededException(final int maxIterations,\n+                                          final String pattern, final Object ... arguments) {\n+        super(pattern, arguments);\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /** Get the maximal number of iterations allowed.\n+     * @return maximal number of iterations allowed\n+     */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math;\n+\n+import java.util.ListResourceBundle;\n+\n+/** \n+ * French localization message resources for the commons-math library.\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class MessagesResources_fr\n+  extends ListResourceBundle {\n+\n+  /** \n+   * Simple constructor.\n+   */\n+  public MessagesResources_fr() {\n+  }\n+\n+  /** \n+   * Get the non-translated/translated messages arrays from this resource bundle.\n+   * @return non-translated/translated messages arrays\n+   */\n+  @Override\n+  public Object[][] getContents() {\n+    return contents.clone();\n+  }\n+\n+  /** Non-translated/translated messages arrays. */\n+  private static final Object[][] contents = {\n+\n+    // org.apache.commons.math.util.MathUtils\n+    { \"must have n >= k for binomial coefficient (n,k), got n = {0}, k = {1}\",\n+      \"n doit \\u00eatre sup\\u00e9rieur ou \\u00e9gal \\u00e0 k \" +\n+      \"pour le coefficient du bin\\u00f4me (n,k), or n = {0}, k = {1}\" },\n+    { \"must have n >= 0 for binomial coefficient (n,k), got n = {0}\",\n+      \"n doit \\u00eatre positif pour le coefficient du bin\\u00f4me (n,k), or n = {0}\" },\n+    { \"must have n >= 0 for n!, got n = {0}\",\n+      \"n doit \\u00eatre positif pour le calcul de n!, or n = {0}\" },\n+    { \"overflow: gcd({0}, {1}) is 2^31\",\n+      \"d\\u00e9passement de capacit\\u00e9 : le PGCD de {0} et {1} vaut 2^31\" },\n+    { \"cannot raise an integral value to a negative power ({0}^{1})\",\n+      \"impossible d''\\u00e9lever une valeur enti\\u00e8re \" +\n+      \"\\u00e0 une puissance n\\u00e9gative ({0}^{1})\" },\n+    { \"invalid rounding method {0}, valid methods: {1} ({2}), {3} ({4}),\" +\n+       \" {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})\",\n+      \"m\\u00e9thode d''arondi {0} invalide, m\\u00e9thodes valides : {1} ({2}), {3} ({4}),\" +\n+       \" {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})\" },\n+\n+    // org.apache.commons.math.FunctionEvaluationException\n+    { \"evaluation failed for argument = {0}\",\n+      \"erreur d''\\u00e9valuation pour l''argument {0}\" },\n+\n+    // org.apache.commons.math.DuplicateSampleAbscissaException\n+    { \"Abscissa {0} is duplicated at both indices {1} and {2}\",\n+      \"Abscisse {0} dupliqu\\u00e9e aux indices {1} et {2}\" },\n+\n+    // org.apache.commons.math.ConvergenceException\n+    { \"Convergence failed\",\n+      \"\\u00c9chec de convergence\" },\n+\n+    // org.apache.commons.math.ArgumentOutsideDomainException\n+    { \"Argument {0} outside domain [{1} ; {2}]\",\n+      \"Argument {0} hors du domaine [{1} ; {2}]\" },\n+\n+    // org.apache.commons.math.MaxIterationsExceededException\n+    { \"Maximal number of iterations ({0}) exceeded\",\n+      \"Nombre maximal d''it\\u00e9rations ({0}) d\\u00e9pass\\u00e9\" },\n+\n+    // org.apache.commons.math.MaxEvaluationsExceededException\n+    { \"Maximal number of evaluations ({0}) exceeded\",\n+      \"Nombre maximal d''\\u00e9valuations ({0}) d\\u00e9pass\\u00e9\" },\n+\n+    // org.apache.commons.math.analysis.interpolation.SplineInterpolator\n+    // org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm\n+    // org.apache.commons.math.DimensionMismatchException\n+    // org.apache.commons.math.optimization.LeastSquaresConverter\n+    // org.apache.commons.math.optimization.direct.DirectSearchOptimizer\n+    // org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer\n+    // org.apache.commons.math.ode.ContinuousOutputModel\n+    // org.apache.commons.math.random.UncorrelatedRandomVectorGenerator\n+    // org.apache.commons.math.stat.regression.AbstractMultipleLinearRegression\n+    // org.apache.commons.math.stat.inference.ChiSquareTestImpl\n+    { \"dimension mismatch {0} != {1}\",\n+      \"dimensions incompatibles {0} != {1}\" },\n+\n+    // org.apache.commons.math.linear.decomposition.NotPositiveDefiniteMatrixException\n+    { \"not positive definite matrix\",\n+      \"matrice non d\\u00e9finie positive\" },\n+\n+    // org.apache.commons.math.linear.decomposition.NotSymmetricMatrixException\n+    { \"not symmetric matrix\",\n+      \"matrice non symm\\u00e9trique\" },\n+\n+    // org.apache.commons.math.fraction.FractionConversionException\n+    { \"Unable to convert {0} to fraction after {1} iterations\",\n+      \"Impossible de convertir {0} en fraction apr\\u00e8s {1} it\\u00e9rations\" },\n+    { \"Overflow trying to convert {0} to fraction ({1}/{2})\",\n+      \"D\\u00e9passement de capacit\\u00e9 lors de la conversion de {0} en fraction ({1}/{2})\" },\n+\n+    // org.apache.commons.math.fraction.BigFraction\n+    { \"numerator is null\",\n+      \"le num\\u00e9rateur est null\" },\n+    { \"denimonator is null\",\n+      \"le d\\u00e9nominateur est null\" },\n+    { \"denominator must be different from 0\",\n+      \"le d\\u00e9nominateur doit \\u00eatre diff\\u00e9rent de 0\" },\n+    { \"cannot convert NaN value\",\n+      \"les valeurs NaN ne peuvent \\u00eatre converties\" },\n+    { \"cannot convert infinite value\",\n+      \"les valeurs infinies ne peuvent \\u00eatre converties\" },\n+\n+    // org.apache.commons.math.fraction.AbstractFormat\n+    { \"denominator format can not be null\",\n+      \"le format du d\\u00e9nominateur ne doit pas \\u00eatre nul\" },\n+    { \"numerator format can not be null\",\n+      \"le format du num\\u00e9rateur ne doit pas \\u00eatre nul\" },\n+\n+    // org.apache.commons.math.fraction.FractionFormat\n+    { \"cannot convert given object to a fraction number: {0}\",\n+      \"impossible de convertir l''objet sous forme d''un nombre rationnel : {0}\" },\n+\n+    // org.apache.commons.math.fraction.FractionFormat\n+    // org.apache.commons.math.fraction.BigFractionFormat\n+    { \"unparseable fraction number: \\\"{0}\\\"\",\n+      \"\\u00e9chec d''analyse du nombre rationnel \\\"{0}\\\"\" },\n+    { \"cannot format given object as a fraction number\",\n+      \"impossible de formater l''objet sous forme d''un nombre rationnel\" },\n+\n+    // org.apache.commons.math.fraction.ProperFractionFormat\n+    // org.apache.commons.math.fraction.ProperBigFractionFormat\n+    { \"whole format can not be null\",\n+      \"le format complet ne doit pas \\u00eatre nul\" },\n+\n+    // org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils\n+    { \"function is null\",\n+      \"la fonction est nulle\" },\n+    { \"bad value for maximum iterations number: {0}\",\n+      \"valeur invalide pour le nombre maximal d''it\\u00e9rations : {0}\" },\n+    { \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n+      \"param\\u00e8tres d''encadrement invalides : borne inf\\u00e9rieure = {0}, valeur initiale = {1}, borne sup\\u00e9rieure = {2}\" },\n+    { \"number of iterations={0}, maximum iterations={1}, initial={2}, lower bound={3}, upper bound={4},\" +\n+        \" final a value={5}, final b value={6}, f(a)={7}, f(b)={8}\",\n+      \"nombre d''it\\u00e9rations = {0}, it\\u00e9rations maximum = {1}, valeur initiale = {2},\" +\n+        \" borne inf\\u00e9rieure = {3}, borne sup\\u00e9rieure = {4},\" +\n+        \" valeur a finale = {5}, valeur b finale = {6}, f(a) = {7}, f(b) = {8}\" },\n+\n+    // org.apache.commons.math.analysis.solvers.LaguerreSolver\n+    { \"polynomial degree must be positive: degree={0}\",\n+      \"le polyn\\u00f4me doit \\u00eatre de degr\\u00e9 positif : degr\\u00e9 = {0}\" },\n+\n+    // org.apache.commons.math.analysis.solvers.SecantSolver\n+    { \"function values at endpoints do not have different signs, endpoints: [{0}, {1}], values: [{2}, {3}]\",\n+      \"les valeurs de la fonctions aux bornes sont de m\\u00eame signe, bornes : [{0}, {1}], valeurs : [{2}, {3}]\" },\n+\n+    // org.apache.commons.math.analysis.interpolation.SplineInterpolator\n+    // org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm\n+    { \"{0} points are required, got only {1}\",\n+      \"{0} sont n\\u00e9cessaires, seuls {1} ont \\u00e9t\\u00e9 fournis\" },\n+\n+    // org.apache.commons.math.analysis.interpolation.SplineInterpolator\n+    { \"points {0} and {1} are not strictly increasing ({2} >= {3})\",\n+      \"les points {0} et {1} ne sont pas strictements croissants ({2} >= {3})\" },\n+\n+    // org.apache.commons.math.analysis.interpolation.LoessInterpolator\n+    { \"bandwidth must be in the interval [0,1], but got {0}\",\n+      \"la largeur de bande doit \\u00eatre dans l''intervalle [0, 1], alors qu'elle vaut {0}\" },\n+    { \"the number of robustness iterations must be non-negative, but got {0}\",\n+      \"le nombre d''it\\u00e9rations robuste ne peut \\u00eatre n\\u00e9gatif, alors qu''il est de {0}\" },\n+    { \"Loess expects the abscissa and ordinate arrays to be of the same size, \" +\n+      \"but got {0} abscisssae and {1} ordinatae\",\n+      \"la r\\u00e9gression Loess n\\u00e9cessite autant d''abscisses que d''ordonn\\u00e9es, \" +\n+      \"mais {0} abscisses et {1} ordonn\\u00e9es ont \\u00e9t\\u00e9 fournies\" },\n+    { \"Loess expects at least 1 point\",\n+      \"la r\\u00e9gression Loess n\\u00e9cessite au moins un point\" },\n+    { \"the bandwidth must be large enough to accomodate at least 2 points. There are {0} \" +\n+      \" data points, and bandwidth must be at least {1}  but it is only {2}\",\n+      \"la largeur de bande doit \\u00eatre assez grande pour supporter au moins 2 points. Il y a {0}\" +\n+      \"donn\\u00e9es et la largeur de bande doit \\u00eatre au moins de {1}, or elle est seulement de {2}\" },\n+    { \"all abscissae must be finite real numbers, but {0}-th is {1}\",\n+      \"toutes les abscisses doivent \\u00eatre des nombres r\\u00e9els finis, mais l''abscisse {0} vaut {1}\" },\n+    { \"all ordinatae must be finite real numbers, but {0}-th is {1}\",\n+      \"toutes les ordonn\\u00e9es doivent \\u00eatre des nombres r\\u00e9els finis, mais l''ordonn\\u00e9e {0} vaut {1}\" },\n+    { \"the abscissae array must be sorted in a strictly increasing order, \" +\n+      \"but the {0}-th element is {1} whereas {2}-th is {3}\",\n+      \"les abscisses doivent \\u00eatre en ordre strictement croissant, \" +\n+      \"mais l''\\u00e9l\\u00e9ment {0} vaut {1} alors que l''\\u00e9l\\u00e9ment {2} vaut {3}\" },\n+\n+    // org.apache.commons.math.util.ContinuedFraction\n+    { \"Continued fraction convergents diverged to +/- infinity for value {0}\",\n+      \"Divergence de fraction continue \\u00e0 l''infini pour la valeur {0}\" },\n+    { \"Continued fraction convergents failed to converge for value {0}\",\n+      \"\\u00c9chec de convergence de fraction continue pour la valeur {0}\" },\n+\n+    // org.apache.commons.math.util.DefaultTransformer\n+    { \"Conversion Exception in Transformation, Object is null\",\n+      \"Exception de conversion dans une transformation, l''objet est nul\" },\n+    { \"Conversion Exception in Transformation: {0}\",\n+      \"Exception de conversion dans une transformation : {0}\" },\n+\n+    // org.apache.commons.math.optimization.MultiStartOptimizer\n+    { \"no optimum computed yet\",\n+      \"aucun optimum n''a encore \\u00e9t\\u00e9 calcul\\u00e9\" },\n+\n+    // org.apache.commons.math.optimization.direct.DirectSearchOptimizer\n+    { \"simplex must contain at least one point\",\n+      \"le simplex doit contenir au moins un point\" },\n+    { \"equals vertices {0} and {1} in simplex configuration\",\n+      \"sommets {0} et {1} \\u00e9gaux dans la configuration du simplex\" },\n+\n+    // org.apache.commons.math.estimation.AbstractEstimation\n+    { \"maximal number of evaluations exceeded ({0})\",\n+      \"nombre maximal d''\\u00e9valuations d\\u00e9pass\\u00e9 ({0})\" },\n+\n+    // org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer\n+    { \"unable to compute covariances: singular problem\",\n+      \"impossible de calculer les covariances : probl\\u00e8me singulier\"},\n+    { \"no degrees of freedom ({0} measurements, {1} parameters)\",\n+      \"aucun degr\\u00e9 de libert\\u00e9 ({0} mesures, {1} param\\u00e8tres)\" },\n+\n+    // org.apache.commons.math.optimization.general.GaussNewtonOptimizer\n+    { \"unable to solve: singular problem\",\n+      \"r\\u00e9solution impossible : probl\\u00e8me singulier\" },\n+\n+    // org.apache.commons.math.optimization.general.LevenbergMarquardtEstimator\n+    { \"cost relative tolerance is too small ({0}), no further reduction in the sum of squares is possible\",\n+      \"trop petite tol\\u00e9rance relative sur le co\\u00fbt ({0}), aucune r\\u00e9duction de la somme des carr\\u00e9s n''est possible\" },\n+    { \"parameters relative tolerance is too small ({0}), no further improvement in the approximate solution is possible\",\n+      \"trop petite tol\\u00e9rance relative sur les param\\u00e8tres ({0}), aucune am\\u00e9lioration de la solution approximative n''est possible\" },\n+    { \"orthogonality tolerance is too small ({0}), solution is orthogonal to the jacobian\",\n+      \"trop petite tol\\u00e9rance sur l''orthogonalit\\u00e9 ({0}), la solution est orthogonale \\u00e0 la jacobienne\" },\n+    { \"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\",\n+      \"impossible de calculer la factorisation Q.R de la matrice jacobienne {0}x{1}\" },\n+\n+    // org.apache.commons.math.optimization.general.NonLinearConjugateGradientOptimizer\n+    { \"unable to bracket optimum in line search\",\n+      \"impossible d''encadrer l''optimum lors de la recherche lin\\u00e9aire\" },\n+\n+    // org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser\n+    { \"unable to first guess the harmonic coefficients\",\n+      \"impossible de faire une premi\\u00e8re estimation des coefficients harmoniques\" },\n+\n+    // org.apache.commons.math.optimization.fitting.HarmonicCoefficientsGuesser\n+    { \"sample contains {0} observed points, at least {1} are required\",\n+      \"l''\\u00e9chantillon ne contient que {0} points alors qu''au moins {1} sont n\\u00e9cessaires\" },\n+\n+    // org.apache.commons.math.optimization.linear.NoFeasibleSolutionException\n+    { \"no feasible solution\",\n+      \"aucune solution r\\u00e9alisable\" },\n+\n+    // org.apache.commons.math.optimization.linear.UnboundedSolutionException\n+    { \"unbounded solution\",\n+      \"solution non born\\u00e9e\" },\n+\n+    // org.apache.commons.math.geometry.CardanEulerSingularityException\n+    { \"Cardan angles singularity\",\n+      \"singularit\\u00e9 d''angles de Cardan\" },\n+    { \"Euler angles singularity\",\n+      \"singularit\\u00e9 d''angles d''Euler\" },\n+\n+    // org.apache.commons.math.geometry.Rotation\n+    { \"a {0}x{1} matrix cannot be a rotation matrix\",\n+      \"une matrice {0}x{1} ne peut pas \\u00eatre une matrice de rotation\" },\n+    { \"the closest orthogonal matrix has a negative determinant {0}\",\n+      \"la matrice orthogonale la plus proche a un d\\u00e9terminant n\\u00e9gatif {0}\" },\n+    { \"unable to orthogonalize matrix in {0} iterations\",\n+      \"impossible de rendre la matrice orthogonale en {0} it\\u00e9rations\" },\n+\n+    // org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator\n+    { \"minimal step size ({0}) reached, integration needs {1}\",\n+      \"pas minimal ({0}) atteint, l''int\\u00e9gration n\\u00e9cessite {1}\" },\n+    { \"dimensions mismatch: state vector has dimension {0},\" +\n+      \" absolute tolerance vector has dimension {1}\",\n+      \"incompatibilit\\u00e9 de dimensions entre le vecteur d''\\u00e9tat ({0}),\" +\n+      \" et le vecteur de tol\\u00e9rance absolue ({1})\" },\n+    { \"dimensions mismatch: state vector has dimension {0},\" +\n+      \" relative tolerance vector has dimension {1}\",\n+      \"incompatibilit\\u00e9 de dimensions entre le vecteur d''\\u00e9tat ({0}),\" +\n+      \" et le vecteur de tol\\u00e9rance relative ({1})\" },\n+\n+    // org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator,\n+    // org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator\n+    { \"dimensions mismatch: ODE problem has dimension {0},\" +\n+      \" initial state vector has dimension {1}\",\n+      \"incompatibilit\\u00e9 de dimensions entre le probl\\u00e8me ODE ({0}),\" +\n+      \" et le vecteur d''\\u00e9tat initial ({1})\" },\n+    { \"dimensions mismatch: ODE problem has dimension {0},\" +\n+      \" final state vector has dimension {1}\",\n+      \"incompatibilit\\u00e9 de dimensions entre le probl\\u00e8me ODE ({0}),\" +\n+      \" et le vecteur d''\\u00e9tat final ({1})\" },\n+    { \"too small integration interval: length = {0}\",\n+      \"intervalle d''int\\u00e9gration trop petit : {0}\" },\n+\n+    // org.apache.commons.math.ode.MultistepIntegrator\n+    { \"{0} method needs at least one previous point\",\n+      \"la m\\u00e9thode {0} n\\u00e9cessite au moins un point pr\\u00e9c\\u00e9dent\" },\n+\n+    // org.apache.commons.math.ode.ContinuousOutputModel\n+    // org.apache.commons.math.optimization.direct.DirectSearchOptimizer\n+    { \"unexpected exception caught\",\n+      \"exception inattendue lev\\u00e9e\" },\n+    { \"propagation direction mismatch\",\n+      \"directions de propagation incoh\\u00e9rentes\" },\n+    { \"{0} wide hole between models time ranges\",\n+      \"trou de longueur {0} entre les domaines temporels des mod\\u00e8les\" },\n+\n+    // org.apache.commons.math.optimization.direct.DirectSearchOptimizer\n+    { \"none of the {0} start points lead to convergence\",\n+      \"aucun des {0} points de d\\u00e9part n''aboutit \\u00e0 une convergence\"  },\n+\n+    // org.apache.commons.math.random.ValueServer\n+    { \"unknown mode {0}, known modes: {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}) and {11} ({12})\",\n+      \"mode {0} inconnu, modes connus : {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}) et {11} ({12})\" },\n+    { \"digest not initialized\",\n+      \"mod\\u00e8le empirique non initialis\\u00e9\" },\n+\n+    // org.apache.commons.math.random.EmpiricalDistributionImpl\n+    { \"distribution not loaded\",\n+      \"aucune distribution n''a \\u00e9t\\u00e9 charg\\u00e9e\" },\n+    { \"no bin selected\",\n+      \"aucun compartiment s\\u00e9lectionn\\u00e9\" },\n+    { \"input data comes from unsupported datasource: {0}, supported sources: {1}, {2}\",\n+      \"les donn\\u00e9es d''entr\\u00e9e proviennent \" +\n+      \"d''une source non support\\u00e9e : {0}, sources support\\u00e9es : {1}, {2}\" },\n+\n+    // org.apache.commons.math.random.EmpiricalDistributionImpl\n+    // org.apache.commons.math.random.ValueServer\n+    { \"URL {0} contains no data\",\n+      \"l''adresse {0} ne contient aucune donn\\u00e9e\" },\n+\n+    // org.apache.commons.math.random.AbstractRandomGenerator\n+    // org.apache.commons.math.random.BitsStreamGenerator\n+    { \"upper bound must be positive ({0})\",\n+      \"la borne sup\\u00e9rieure doit \\u00eatre positive ({0})\" },\n+\n+    // org.apache.commons.math.random.RandomDataImpl\n+    { \"length must be positive ({0})\",\n+      \"la longueur doit \\u00eatre positive ({0})\" },\n+    { \"upper bound ({0}) must be greater than lower bound ({1})\",\n+      \"la borne sup\\u00e9rieure ({0}) doit \\u00eatre sup\\u00e9rieure\" +\n+      \" \\u00e0 la borne inf\\u00e9rieure ({1})\" },\n+    { \"permutation k ({0}) exceeds n ({1})\",\n+      \"la permutation k ({0}) d\\u00e9passe n ({1})\" },\n+    { \"permutation k ({0}) must be positive\",\n+      \"la permutation k ({0}) doit \\u00eatre positive\" },\n+    { \"sample size ({0}) exceeds collection size ({1})\",\n+      \"la taille de l''\\u00e9chantillon ({0}) d\\u00e9passe la taille de la collection ({1})\" },\n+\n+    // org.apache.commons.math.linear.decomposition.EigenDecompositionImpl\n+    { \"cannot solve degree {0} equation\",\n+      \"impossible de r\\u00e9soudre une \\u00e9quation de degr\\u00e9 {0}\" },\n+    { \"eigen decomposition of assymetric matrices not supported yet\",\n+      \"la d\\u00e9composition en valeurs/vecteurs propres de matrices \" +\n+      \"non sym\\u00e9triques n''est pas encore disponible\" },\n+\n+    // org.apache.commons.math.linear.decomposition.NonSquareMatrixException\n+    // org.apache.commons.math.stat.regression.AbstractMultipleLinearRegression\n+    { \"a {0}x{1} matrix was provided instead of a square matrix\",\n+      \"une matrice {0}x{1} a \\u00e9t\\u00e9 fournie \\u00e0 la place d''une matrice carr\\u00e9e\" },\n+\n+    // org.apache.commons.math.linear.decomposition.SingularMatrixException\n+    { \"matrix is singular\",\n+      \"matrice singuli\\u00e8re\" },\n+\n+    // org.apache.commons.math.linear.decomposition.SingularValueDecompositionImpl\n+    { \"cutoff singular value is {0}, should be at most {1}\",\n+      \"la valeur singuli\\u00e8re de coupure vaut {0}, elle ne devrait pas d\\u00e9passer {1}\" },\n+\n+    // org.apache.commons.math.linear.decomposition.CholeskyDecompositionImpl\n+    // org.apache.commons.math.linear.decomposition.EigenDecompositionImpl\n+    // org.apache.commons.math.linear.decomposition.LUDecompositionImpl\n+    // org.apache.commons.math.linear.decomposition.QRDecompositionImpl\n+    // org.apache.commons.math.linear.decomposition.SingularValueDecompositionImpl\n+    { \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+      \"dimensions erronn\\u00e9es : {0}x{1} \\u00e0 la place de {2}x{3}\" },\n+\n+    // org.apache.commons.math.linear.decomposition.CholeskyDecompositionImpl\n+    // org.apache.commons.math.linear.decomposition.EigenDecompositionImpl\n+    // org.apache.commons.math.linear.decomposition.LUDecompositionImpl\n+    // org.apache.commons.math.linear.decomposition.QRDecompositionImpl\n+    // org.apache.commons.math.linear.decomposition.SingularValueDecompositionImpl\n+    // org.apache.commons.math.linear.ArrayRealVector\n+    // org.apache.commons.math.linear.SparseRealVector\n+    { \"vector length mismatch: got {0} but expected {1}\",\n+      \"dimension de vecteur erronn\\u00e9e : {0} \\u00e0 la place de {1}\" },\n+      \n+    // org.apache.commons.math.linear.ArrayRealVector\n+    // org.apache.commons.math.linear.ArrayFieldVector\n+    // org.apache.commons.math.linear.SparseRealVector\n+    { \"index {0} out of allowed range [{1}, {2}]\",\n+      \"index {0} hors de la plage autoris\\u00e9e [{1}, {2}]\" },\n+    { \"vector must have at least one element\",\n+      \"un vecteur doit comporter au moins un \\u00e9l\\u00e9ment\" },\n+    { \"position {0} and size {1} don't fit to the size of the input array {2}\",\n+      \"la position {0} et la taille {1} sont incompatibles avec la taille du tableau d''entr\\u00e9e {2}\"},\n+\n+    // org.apache.commons.math.linear.AbstractRealMatrix\n+    // org.apache.commons.math.linear.AbstractFieldMatrix\n+    { \"invalid row dimension: {0} (must be positive)\",\n+      \"nombre de lignes invalide : {0} (doit \\u00eatre positif)\" },\n+    { \"invalid column dimension: {0} (must be positive)\",\n+      \"nombre de colonnes invalide : {0} (doit \\u00eatre positif)\" },\n+    { \"vector length mismatch: got {0} but expected {1}\",\n+      \"taille de vecteur invalide : {0} au lieu de {1} attendue\" },\n+    { \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+      \"dimensions incoh\\u00e9rentes : {0}x{1} \\u00e0 la place de {2}x{3}\" },\n+    { \"matrix must have at least one row\",\n+      \"une matrice doit comporter au moins une ligne\" },\n+    { \"matrix must have at least one column\",\n+      \"une matrice doit comporter au moins une colonne\" },\n+\n+    // org.apache.commons.math.linear.AbstractRealMatrix\n+    // org.apache.commons.math.linear.AbstractFieldMatrix\n+    // org.apache.commons.math.stat.inference.ChiSquareTestImpl      \n+    { \"some rows have length {0} while others have length {1}\",\n+      \"certaines lignes ont une longueur de {0} alors que d''autres ont une longueur de {1}\" },\n+\n+    // org.apache.commons.math.linear.MatrixUtils\n+    { \"row index {0} out of allowed range [{1}, {2}]\",\n+      \"index de ligne {0} hors de la plage autoris\\u00e9e [{1}, {2}]\" },\n+    { \"column index {0} out of allowed range [{1}, {2}]\",\n+      \"index de colonne {0} hors de la plage autoris\\u00e9e [{1}, {2}]\" },\n+    { \"initial row {0} after final row {1}\",\n+      \"ligne initiale {0} apr\\u00e8s la ligne finale {1}\" },\n+    { \"initial column {0} after final column {1}\",\n+      \"colonne initiale {0} apr\\u00e8s la colonne finale {1}\" },\n+    { \"empty selected row index array\",\n+      \"tableau des indices de lignes s\\u00e9lectionn\\u00e9es vide\" },\n+    { \"empty selected column index array\",\n+      \"tableau des indices de colonnes s\\u00e9lectionn\\u00e9es vide\" },\n+    { \"{0}x{1} and {2}x{3} matrices are not addition compatible\",\n+      \"les dimensions {0}x{1} et {2}x{3} sont incompatibles pour l'addition matricielle\" },\n+    { \"{0}x{1} and {2}x{3} matrices are not subtraction compatible\",\n+      \"les dimensions {0}x{1} et {2}x{3} sont incompatibles pour la soustraction matricielle\" },\n+    { \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n+      \"les dimensions {0}x{1} et {2}x{3} sont incompatibles pour la multiplication matricielle\" },\n+\n+    // org.apache.commons.math.linear.BlockRealMatrix\n+    { \"wrong array shape (block length = {0}, expected {1})\",\n+      \"forme de tableau erron\\u00e9e (bloc de longueur {0} au lieu des {1} attendus)\" },\n+\n+    // org.apache.commons.math.complex.Complex\n+    { \"cannot compute nth root for null or negative n: {0}\",\n+     \"impossible de calculer la racine ni\\u00e8me pour n n\\u00e9gatif ou nul : {0}\" },\n+\n+   // org.apache.commons.math.complex.ComplexFormat\n+   { \"unparseable complex number: \\\"{0}\\\"\",\n+     \"\\u00e9chec d''analyse du nombre complexe \\\"{0}\\\"\" },\n+   { \"cannot format a {0} instance as a complex number\",\n+     \"impossible de formater une instance de {0} comme un nombre complexe\" },\n+   { \"empty string for imaginary character\",\n+     \"cha\\u00eene vide pour le caract\\u00e8 imaginaire\" },\n+   { \"null imaginary format\",\n+     \"format imaginaire nul\" },\n+   { \"null real format\",\n+     \"format r\\u00e9el nul\" },\n+\n+   // org.apache.commons.math.complex.ComplexUtils\n+   { \"negative complex module {0}\",\n+     \"module n\\u00e9gatif ({0}) pour un nombre complexe\" },\n+\n+   // org.apache.commons.math.geometry.Vector3DFormat\n+   { \"unparseable 3D vector: \\\"{0}\\\"\",\n+     \"\\u00e9chec d''analyse du vecteur de dimension 3 \\\"{0}\\\"\" },\n+   { \"cannot format a {0} instance as a 3D vector\",\n+     \"impossible de formater une instance de {0} comme un vecteur de dimension 3\" },\n+\n+   // org.apache.commons.math.linear.RealVectorFormat\n+   { \"unparseable real vector: \\\"{0}\\\"\",\n+     \"\\u00e9chec d''analyse du vecteur r\\u00e9el \\\"{0}\\\"\" },\n+   { \"cannot format a {0} instance as a real vector\",\n+     \"impossible de formater une instance de {0} comme un vecteur r\\u00e9el\" },\n+\n+   // org.apache.commons.math.util.ResizableDoubleArray\n+   { \"the index specified: {0} is larger than the current maximal index {1}\",\n+     \"l''index sp\\u00e9cifi\\u00e9 ({0}) d\\u00e9passe l''index maximal courant ({1})\" },\n+   { \"elements cannot be retrieved from a negative array index {0}\",\n+     \"impossible d''extraire un \\u00e9l\\u00e9ment \\u00e0 un index n\\u00e9gatif ({0})\" },\n+   { \"cannot set an element at a negative index {0}\",\n+     \"impossible de mettre un \\u00e9l\\u00e9ment \\u00e0 un index n\\u00e9gatif ({0})\" },\n+   { \"cannot substitute an element from an empty array\",\n+     \"impossible de substituer un \\u00e9l\\u00e9ment dans un tableau vide\" },\n+   { \"contraction criteria ({0}) smaller than the expansion factor ({1}).  This would \" +\n+     \"lead to a never ending loop of expansion and contraction as a newly expanded \" +\n+     \"internal storage array would immediately satisfy the criteria for contraction.\",\n+     \"crit\\u00e8re de contraction ({0}) inf\\u00e9rieur au facteur d''extension. Ceci \" +\n+     \"induit une boucle infinie d''extensions/contractions car tout tableau de stockage \" +\n+     \"fra\\u00eechement \\u00e9tendu respecte imm\\u00e9diatement le crit\\u00e8re de contraction.\"},\n+   { \"contraction criteria smaller than one ({0}).  This would lead to a never ending \" +\n+     \"loop of expansion and contraction as an internal storage array length equal \" +\n+     \"to the number of elements would satisfy the contraction criteria.\",\n+     \"crit\\u00e8re de contraction inf\\u00e9rieur \\u00e0 un ({0}). Ceci induit une boucle \" +\n+     \"infinie d''extensions/contractions car tout tableau de stockage de longueur \\u00e9gale \" +\n+     \"au nombre d''\\u00e9l\\u00e9ments respecte le crit\\u00e8re de contraction.\" },\n+   { \"expansion factor smaller than one ({0})\",\n+     \"facteur d''extension inf\\u00e9rieur \\u00e0 un ({0})\"},\n+   { \"cannot discard {0} elements from a {1} elements array\",\n+     \"impossible d''enlever {0} \\u00e9l\\u00e9ments d''un tableau en contenant {1}\"},\n+   { \"cannot discard a negative number of elements ({0})\",\n+     \"impossible d''enlever un nombre d''\\u00e9l\\u00e9ments{0} n\\u00e9gatif\"},\n+   { \"unsupported expansion mode {0}, supported modes are {1} ({2}) and {3} ({4})\",\n+     \"mode d''extension {0} no support\\u00e9, les modes support\\u00e9s sont {1} ({2}) et {3} ({4})\" },\n+   { \"initial capacity ({0}) is not positive\",\n+     \"la capacit\\u00e9 initiale ({0}) n''est pas positive\" },\n+   { \"index ({0}) is not positive\",\n+     \"l''indice ({0}) n''est pas positif\" },\n+\n+   // org.apache.commons.math.analysis.polynomials.PolynomialFunction\n+   // org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm\n+   { \"empty polynomials coefficients array\",\n+     \"tableau de coefficients polyn\\u00f4miaux vide\" },\n+\n+   // org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm\n+   { \"array sizes should have difference 1 ({0} != {1} + 1)\",\n+     \"les tableaux devraient avoir une diff\\u00e9rence de taille de 1 ({0} != {1} + 1)\" },\n+\n+   // org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm\n+   { \"identical abscissas x[{0}] == x[{1}] == {2} cause division by zero\",\n+     \"division par z\\u00e9ro caus\\u00e9e par les abscisses identiques x[{0}] == x[{1}] == {2}\" },\n+\n+   // org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction\n+   { \"spline partition must have at least {0} points, got {1}\",\n+     \"une partiction spline n\\u00e9cessite au moins {0} points, seuls {1} ont \\u00e9t\\u00e9 fournis\" },\n+   { \"knot values must be strictly increasing\",\n+     \"les n\\u0153uds d''interpolation doivent \\u00eatre strictement croissants\" },\n+   { \"number of polynomial interpolants must match the number of segments ({0} != {1} - 1)\",\n+     \"le nombre d''interpolants polyn\\u00f4miaux doit correspondre au nombre de segments ({0} != {1} - 1)\" },\n+\n+   // org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl\n+   { \"function to solve cannot be null\",\n+     \"la fonction \\u00e0 r\\u00e9soudre ne peux pas \\u00eatre nulle\" },\n+   { \"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",\n+     \"param\\u00e8tres de l''intervalle initial invalides : borne inf = {0}, valeur initiale = {1}, borne sup = {2}\" },\n+\n+   // org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl\n+   // org.apache.commons.math.analysis.solvers.BrentSolver\n+   { \"function values at endpoints do not have different signs.  Endpoints: [{0}, {1}], Values: [{2}, {3}]\",\n+     \"les valeurs de la fonction aux bornes n''ont pas des signes diff\\u00e9rents. Bornes : [{0}, {1}], valeurs : [{2}, {3}]\" },\n+\n+   // org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl\n+   // org.apache.commons.math.analysis.integration.UnivariateRealIntegratorImpl\n+   // org.apache.commons.math.transform.FastFourierTransformer\n+   { \"endpoints do not specify an interval: [{0}, {1}]\",\n+     \"les extr\\u00e9mit\\u00e9s ne constituent pas un intervalle : [{0}, {1}]\" },\n+\n+   // org.apache.commons.math.analysis.solvers.LaguerreSolver\n+   { \"function is not polynomial\",\n+     \"la fonction n''est pas p\\u00f4lynomiale\" },\n+\n+   // org.apache.commons.math.analysis.solvers.NewtonSolver\n+   { \"function is not differentiable\",\n+     \"la fonction n''est pas diff\\u00e9rentiable\" },\n+\n+   // org.apache.commons.math.analysis.integration.UnivariateRealIntegratorImpl\n+   { \"invalid iteration limits: min={0}, max={1}\",\n+     \"limites d''it\\u00e9rations invalides : min = {0}, max = {1}\" },\n+\n+   // org.apache.commons.math.analysis.integration.LegendreGaussIntegrator\n+   { \"{0} points Legendre-Gauss integrator not supported,\" +\n+     \" number of points must be in the {1}-{2} range\",\n+     \"int\\u00e9grateur de Legendre-Gauss non support\\u00e9 en {0} points, \" +\n+     \"le nombre de points doit \\u00eatre entre {1} et {2}\" },\n+\n+   // org.apache.commons.math.fraction.Fraction\n+   { \"zero denominator in fraction {0}/{1}\",\n+     \"d\\u00e9nominateur null dans le nombre rationnel {0}/{1}\" },\n+   { \"overflow in fraction {0}/{1}, cannot negate\",\n+     \"d\\u00e9passement de capacit\\u00e9 pour la fraction {0}/{1}, son signe ne peut \\u00eatre chang\\u00e9\" },\n+   { \"overflow, numerator too large after multiply: {0}\",\n+     \"d\\u00e9passement de capacit\\u00e9 pour le num\\u00e9rateur apr\\u00e8s multiplication : {0}\" },\n+   { \"the fraction to divide by must not be zero: {0}/{1}\",\n+     \"division par un nombre rationnel nul : {0}/{1}\" },\n+   { \"null fraction\",\n+     \"fraction nulle\" },\n+\n+   // org.apache.commons.math.geometry.Rotation\n+   { \"zero norm for rotation axis\",\n+     \"norme nulle pour un axe de rotation\" },\n+   { \"zero norm for rotation defining vector\",\n+     \"norme nulle pour un axe de d\\u00e9finition de rotation\" },\n+\n+   // org.apache.commons.math.geometry.Vector3D\n+   // org.apache.commons.math.linear.ArrayRealVector\n+   { \"cannot normalize a zero norm vector\",\n+     \"impossible de normer un vecteur de norme nulle\" },\n+   { \"zero norm\",\n+     \"norme nulle\" },\n+\n+   // org.apache.commons.math.ConvergingAlgorithmImpl\n+   { \"no result available\",\n+     \"aucun r\\u00e9sultat n''est disponible\" },\n+\n+   // org.apache.commons.math.linear.BigMatrixImpl\n+   { \"first {0} rows are not initialized yet\",\n+     \"les {0} premi\\u00e8res lignes ne sont pas encore initialis\\u00e9es\" },\n+   { \"first {0} columns are not initialized yet\",\n+     \"les {0} premi\\u00e8res colonnes ne sont pas encore initialis\\u00e9es\" },\n+\n+   // org.apache.commons.math.stat.Frequency\n+   { \"class ({0}) does not implement Comparable\",\n+     \"la classe ({0}) n''implante pas l''interface Comparable\" },\n+   { \"instance of class {0} not comparable to existing values\",\n+     \"l''instance de la classe {0} n''est pas comparable aux valeurs existantes\" },\n+\n+   // org.apache.commons.math.stat.StatUtils\n+   { \"input arrays must have the same positive length ({0} and {1})\",\n+     \"les tableaux d''entr\\u00e9e doivent avoir la m\\u00eame taille positive ({0} et {1})\" },\n+   { \"input arrays must have the same length and at least two elements ({0} and {1})\",\n+     \"les tableaux d''entr\\u00e9e doivent avoir la m\\u00eame taille\" +\n+     \" et au moins deux \\u00e9l\\u00e9ments ({0} et {1})\" },\n+\n+   // org.apache.commons.math.stat.correlation.Covariance\n+   { \"arrays must have the same length and both must have at \" +\n+     \"least two elements. xArray has size {0}, yArray has {1} elements\",\n+     \"les tableaux doivent avoir la m\\u00eame taille \" +\n+     \"et comporter au moins deux \\u00e9l\\u00e9ments. \" +\n+     \"xArray a une taille de {0}, yArray a {1} \\u00e9l\\u00e9ments\"},\n+   { \"insufficient data: only {0} rows and {1} columns.\",\n+     \"donn\\u00e9es insuffisantes : seulement {0} lignes et {1} colonnes.\" },\n+\n+   // org.apache.commons.math.stat.correlation.PearsonsCorrelation\n+   { \"covariance matrix is null\",\n+     \"la matrice de covariance est nulle\" },\n+   { \"invalid array dimensions. xArray has size {0}; yArray has {1} elements\",\n+     \"dimensions de tableaux invalides. xArray a une taille de {0}, \" +\n+     \"yArray a {1} \\u00e9l\\u00e9ments\" },\n+\n+   // org.apache.commons.math.stat.descriptive.DescriptiveStatistics\n+   { \"window size must be positive ({0})\",\n+     \"la taille de la fen\\u00eatre doit \\u00eatre positive ({0})\" },\n+   { \"percentile implementation {0} does not support setQuantile\",\n+     \"l''implantation de pourcentage {0} ne dispose pas de la m\\u00e9thode setQuantile\" },\n+   { \"cannot access setQuantile method in percentile implementation {0}\",\n+     \"acc\\u00e8s impossible \\u00e0 la m\\u00e9thode setQuantile\" +\n+     \" dans l''implantation de pourcentage {0}\" },\n+   { \"out of bounds quantile value: {0}, must be in (0, 100]\",\n+     \"valeur de quantile {0} hors bornes, doit \\u00eatre dans l''intervalle ]0, 100]\" },\n+\n+   // org.apache.commons.math.stat.descriptive.moment.Variance\n+   // org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic\n+   // org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic\n+   { \"input values array is null\",\n+     \"le tableau des valeurs d''entr\\u00e9es est nul\" },\n+\n+   // org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic\n+   { \"start position cannot be negative ({0})\",\n+     \"la position de d\\u00e9part ne peut pas \\u00eatre n\\u00e9gative\" },\n+   { \"length cannot be negative ({0})\",\n+     \"la longueur ne peut pas \\u00eatre n\\u00e9gative\" },\n+   { \"subarray ends after array end\",\n+     \"le sous-tableau se termine apr\\u00e8s la fin du tableau\" },\n+\n+   // org.apache.commons.math.stat.descriptive.moment.GeometricMean\n+   // org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics\n+   // org.apache.commons.math.stat.descriptive.SummaryStatistics\n+   { \"{0} values have been added before statistic is configured\",\n+     \"{0} valeurs ont \\u00e9t\\u00e9 ajout\\u00e9es \" +\n+     \"avant que la statistique ne soit configur\\u00e9e\" },\n+\n+   // org.apache.commons.math.stat.descriptive.moment.Kurtosis\n+   { \"statistics constructed from external moments cannot be incremented\",\n+     \"les statistiques bas\\u00e9es sur des moments externes \" +\n+     \"ne peuvent pas \\u00eatre incr\\u00e9ment\\u00e9es\" },\n+   { \"statistics constructed from external moments cannot be cleared\",\n+     \"les statistiques bas\\u00e9es sur des moments externes \" +\n+     \"ne peuvent pas \\u00eatre remises \\u00e0 z\\u00e9ro\" },\n+\n+   // org.apache.commons.math.stat.inference.ChiSquareTestImpl\n+   { \"expected array length = {0}, must be at least 2\",\n+     \"le tableau des valeurs attendues a une longueur de {0}, elle devrait \\u00eatre au moins de 2\" },\n+   { \"observed array length = {0}, must be at least 2\",\n+     \"le tableau des valeurs observ\\u00e9es a une longueur de {0}, elle devrait \\u00eatre au moins de 2\" },\n+   { \"observed counts are all 0 in first observed array\",\n+     \"aucune occurrence dans le premier tableau des observations\" },\n+   { \"observed counts are all 0 in second observed array\",\n+     \"aucune occurrence dans le second tableau des observations\" },\n+   { \"observed counts are both zero for entry {0}\",\n+     \"les occurrences observ\\u00e9es sont toutes deux nulles pour l'entr\\u00e9e {0}\" },\n+   { \"invalid row dimension: {0} (must be at least 2)\",\n+     \"nombre de lignes invalide : {0} (doit \\u00eatre au moins de 2)\" },\n+   { \"invalid column dimension: {0} (must be at least 2)\",\n+     \"nombre de colonnes invalide : {0} (doit \\u00eatre au moins de 2)\" },\n+   { \"element {0} is not positive: {1}\",\n+     \"l''\\u00e9l\\u00e9ment {0} n''est pas positif : {1}\" },\n+   { \"element {0} is negative: {1}\",\n+     \"l''\\u00e9l\\u00e9ment {0} est n\\u00e9gatif : {1}\" },\n+   { \"element ({0}, {1}) is negative: {2}\",\n+     \"l''\\u00e9l\\u00e9ment ({0}, {1}) est n\\u00e9gatif : {2}\" },\n+\n+   // org.apache.commons.math.stat.inference.OneWayAnovaImpl\n+   { \"two or more categories required, got {0}\",\n+     \"deux cat\\u00e9gories ou plus sont n\\u00e9cessaires, il y en a {0}\" },\n+   { \"two or more values required in each category, one has {0}\",\n+     \"deux valeurs ou plus sont n\\u00e9cessaires pour chaque cat\\u00e9gorie, une cat\\u00e9gorie en a {0}\" },\n+\n+   // org.apache.commons.math.stat.inference.TTestImpl\n+   { \"insufficient data for t statistic, needs at least 2, got {0}\",\n+     \"deux valeurs ou plus sont n\\u00e9cessaires pour la statistique t, il y en a {0}\" },\n+\n+   // org.apache.commons.math.stat.inference.ChiSquareTestImpl\n+   // org.apache.commons.math.stat.inference.TTestImpl\n+   // org.apache.commons.math.stat.inference.OneWayAnovaImpl\n+   // org.apache.commons.math.stat.Regression\n+   { \"out of bounds significance level {0}, must be between {1} and {2}\",\n+     \"niveau de signification {0} hors domaine, doit \\u00eatre entre {1} et {2}\" },\n+\n+   // org.apache.commons.math.stat.regression.OLSMultipleLinearRegression\n+   { \"matrix is not upper-triangular, entry ({0}, {1}) = {2} is too large\",\n+     \"matrice non triangulaire sup\\u00e9rieure, l''\\u00e9l\\u00e9ment ({0}, {1}) = {2} est trop grand\" },\n+\n+   // org.apache.commons.math.stat.regression.AbstractMultipleLinearRegression\n+   { \"not enough data ({0} rows) for this many predictors ({1} predictors)\",\n+     \"pas assez de donn\\u00e9es ({0} lignes) pour {1} pr\\u00e9dicteurs\" },\n+\n+   // org.apache.commons.math.distribution.AbstractContinuousDistribution\n+   // org.apache.commons.math.distribution.AbstractIntegerDistribution\n+   // org.apache.commons.math.distribution.ExponentialDistributionImpl\n+   // org.apache.commons.math.distribution.BinomialDistributionImpl\n+   // org.apache.commons.math.distribution.CauchyDistributionImpl\n+   // org.apache.commons.math.distribution.PascalDistributionImpl\n+   // org.apache.commons.math.distribution.WeibullDistributionImpl\n+   { \"{0} out of [{1}, {2}] range\",\n+     \"{0} hors du domaine [{1}, {2}]\" },\n+\n+   // org.apache.commons.math.distribution.AbstractDistribution\n+   // org.apache.commons.math.distribution.AbstractIntegerDistribution\n+   { \"lower endpoint ({0}) must be less than or equal to upper endpoint ({1})\",\n+     \"la borne inf\\u00e9rieure ({0}) devrait \\u00eatre inf\\u00e9rieure \" +\n+     \"ou \\u00e9gale \\u00e0 la borne sup\\u00e9rieure ({1})\" },\n+\n+   // org.apache.commons.math.distribution.BinomialDistributionImpl\n+   { \"number of trials must be non-negative ({0})\",\n+     \"le nombre d''essais ne doit pas \\u00eatre n\\u00e9gatif ({0})\" },\n+\n+   // org.apache.commons.math.distribution.ExponentialDistributionImpl\n+   // org.apache.commons.math.random.RandomDataImpl\n+   { \"mean must be positive ({0})\",\n+     \"la moyenne doit \\u00eatre positive ({0})\" },\n+\n+   // org.apache.commons.math.distribution.FDistributionImpl\n+   // org.apache.commons.math.distribution.TDistributionImpl\n+   { \"degrees of freedom must be positive ({0})\",\n+     \"les degr\\u00e9s de libert\\u00e9 doivent \\u00eatre positifs ({0})\" },\n+\n+   // org.apache.commons.math.distribution.GammaDistributionImpl\n+   { \"alpha must be positive ({0})\",\n+     \"alpha doit \\u00eatre positif ({0})\" },\n+   { \"beta must be positive ({0})\",\n+     \"beta doit \\u00eatre positif ({0})\" },\n+\n+   // org.apache.commons.math.distribution.HypergeometricDistributionImpl\n+   { \"number of successes ({0}) must be less than or equal to population size ({1})\",\n+     \"le nombre de succ\\u00e8s doit \\u00eatre inf\\u00e9rieur \" +\n+     \"ou \\u00e9gal \\u00e0 la taille de la population ({1})\" },\n+   { \"sample size ({0}) must be less than or equal to population size ({1})\",\n+     \"la taille de l''\\u00e9chantillon doit \\u00eatre inf\\u00e9rieure \" +\n+     \"ou \\u00e9gale \\u00e0 la taille de la population ({1})\" },\n+   { \"population size must be positive ({0})\",\n+     \"la taille de la population doit \\u00eatre positive ({0})\" },\n+\n+   // org.apache.commons.math.distribution.HypergeometricDistributionImpl\n+   // org.apache.commons.math.random.RandomDataImpl\n+   { \"sample size must be positive ({0})\",\n+     \"la taille de l''\\u00e9chantillon doit \\u00eatre positive ({0})\" },\n+\n+   // org.apache.commons.math.distribution.HypergeometricDistributionImpl\n+   // org.apache.commons.math.distribution.PascalDistributionImpl\n+   { \"number of successes must be non-negative ({0})\",\n+     \"le nombre de succ\\u00e8s ne doit pas \\u00eatre n\\u00e9gatif ({0})\" },\n+\n+   // org.apache.commons.math.distribution.NormalDistributionImpl\n+   // org.apache.commons.math.random.RandomDataImpl\n+   { \"standard deviation must be positive ({0})\",\n+     \"l''\\u00e9cart type doit \\u00eatre positif ({0})\" },\n+\n+   // org.apache.commons.math.distribution.PoissonDistributionImpl\n+   // org.apache.commons.math.random.RandomDataImpl\n+   { \"the Poisson mean must be positive ({0})\",\n+     \"la moyenne de Poisson doit \\u00eatre positive ({0})\" },\n+\n+   // org.apache.commons.math.distribution.WeibullDistributionImpl\n+   { \"shape must be positive ({0})\",\n+     \"le facteur de forme doit \\u00eatre positif ({0})\" },\n+\n+   // org.apache.commons.math.distribution.WeibullDistributionImpl\n+   // org.apache.commons.math.distribution.CauchyDistributionImpl\n+   { \"scale must be positive ({0})\",\n+     \"l''\\u00e9chelle doit \\u00eatre positive ({0})\" },\n+\n+   // org.apache.commons.math.distribution.ZipfDistributionImpl\n+   { \"invalid number of elements {0} (must be positive)\",\n+     \"nombre d''\\u00e9l\\u00e9ments {0} invalide (doit \\u00eatre positif)\" },\n+   { \"invalid exponent {0} (must be positive)\",\n+     \"exposant {0} invalide (doit \\u00eatre positif)\" },\n+\n+   // org.apache.commons.math.transform.FastHadamardTransformer\n+   { \"{0} is not a power of 2\",\n+     \"{0} n''est pas une puissance de 2\" },\n+\n+   // org.apache.commons.math.transform.FastFourierTransformer\n+   { \"cannot compute 0-th root of unity, indefinite result\",\n+     \"impossible de calculer la racine z\\u00e9roi\\u00e8me de l''unit\\u00e9, \" +\n+     \"r\\u00e9sultat ind\\u00e9fini\" },\n+   { \"roots of unity have not been computed yet\",\n+     \"les racines de l''unit\\u00e9 n''ont pas encore \\u00e9t\\u00e9 calcul\\u00e9es\" },\n+   { \"out of range root of unity index {0} (must be in [{1};{2}])\",\n+     \"index de racine de l''unit\\u00e9 hors domaine (devrait \\u00eatre dans [{1}; {2}])\" },\n+   { \"number of sample is not positive: {0}\",\n+     \"le nombre d''\\u00e9chantillons n''est pas positif : {0}\" },\n+   { \"{0} is not a power of 2, consider padding for fix\",\n+     \"{0} n''est pas une puissance de 2, ajoutez des \\u00e9l\\u00e9ments pour corriger\" },\n+   { \"some dimensions don't match: {0} != {1}\",\n+     \"certaines dimensions sont incoh\\u00e9rentes : {0} != {1}\" },\n+\n+   // org.apache.commons.math.transform.FastCosineTransformer\n+   { \"{0} is not a power of 2 plus one\",\n+     \"{0} n''est pas une puissance de 2 plus un\" },\n+\n+   // org.apache.commons.math.transform.FastSineTransformer\n+   { \"first element is not 0: {0}\",\n+     \"le premier \\u00e9l\\u00e9ment n''est pas nul : {0}\" },\n+\n+   // org.apache.commons.math.util.OpenIntToDoubleHashMap\n+   { \"map has been modified while iterating\",\n+     \"la table d''adressage a \\u00e9t\\u00e9 modifi\\u00e9e pendant l''it\\u00e9ration\" },\n+   { \"iterator exhausted\",\n+     \"it\\u00e9ration achev\\u00e9e\" },\n+\n+   // org.apache.commons.math.MathRuntimeException\n+   { \"internal error, please fill a bug report at {0}\",\n+     \"erreur interne, veuillez signaler l''erreur \\u00e0 {0}\" }\n+\n+  };\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/DifferentiableMultivariateRealFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis;\n+\n+/** \n+ * Extension of {@link MultivariateRealFunction} representing a differentiable\n+ * multivariate real function.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface DifferentiableMultivariateRealFunction extends MultivariateRealFunction {\n+\n+    /**\n+     * Returns the partial derivative of the function with respect to a point coordinate.\n+     * <p>\n+     * The partial derivative is defined with respect to point coordinate\n+     * x<sub>k</sub>. If the partial derivatives with respect to all coordinates are\n+     * needed, it may be more efficient to use the {@link #gradient()} method which will\n+     * compute them all at once.\n+     * </p>\n+     * @param k index of the coordinate with respect to which the partial\n+     * derivative is computed\n+     * @return the partial derivative function with respect to k<sup>th</sup> point coordinate\n+     */\n+    MultivariateRealFunction partialDerivative(int k);\n+\n+    /**\n+     * Returns the gradient function.\n+     * <p>If only one partial derivative with respect to a specific coordinate is\n+     * needed, it may be more efficient to use the {@link #partialDerivative(int)} method\n+     * which will compute only the specified component.</p>\n+     * @return the gradient function\n+     */\n+    MultivariateVectorialFunction gradient();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/DifferentiableMultivariateVectorialFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis;\n+\n+\n+/** \n+ * Extension of {@link MultivariateVectorialFunction} representing a differentiable\n+ * multivariate vectorial function.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface DifferentiableMultivariateVectorialFunction\n+    extends MultivariateVectorialFunction {\n+\n+    /**\n+     * Returns the jacobian function.\n+     * @return the jacobian function\n+     */\n+    MultivariateMatrixFunction jacobian();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/DifferentiableUnivariateMatrixFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+/**\n+ * Extension of {@link UnivariateMatrixFunction} representing a differentiable univariate matrix function.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface DifferentiableUnivariateMatrixFunction\n+    extends UnivariateMatrixFunction {\n+ \n+    /**\n+     * Returns the derivative of the function\n+     * \n+     * @return  the derivative function\n+     */\n+    public UnivariateMatrixFunction derivative();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/DifferentiableUnivariateRealFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+/**\n+ * Extension of {@link UnivariateRealFunction} representing a differentiable univariate real function.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public interface DifferentiableUnivariateRealFunction\n+    extends UnivariateRealFunction {\n+ \n+    /**\n+     * Returns the derivative of the function\n+     * \n+     * @return  the derivative function\n+     */\n+    public UnivariateRealFunction derivative();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/DifferentiableUnivariateVectorialFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+/**\n+ * Extension of {@link UnivariateVectorialFunction} representing a differentiable univariate vectorial function.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface DifferentiableUnivariateVectorialFunction\n+    extends UnivariateVectorialFunction {\n+ \n+    /**\n+     * Returns the derivative of the function\n+     * \n+     * @return  the derivative function\n+     */\n+    public UnivariateVectorialFunction derivative();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/MultivariateMatrixFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis;\n+\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/** \n+ * An interface representing a multivariate matrix function.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface MultivariateMatrixFunction {\n+\n+    /** \n+     * Compute the value for the function at the given point.\n+     * @param point point at which the function must be evaluated\n+     * @return function value for the given point\n+     * @exception FunctionEvaluationException if the function evaluation fails\n+     * @exception IllegalArgumentException if points dimension is wrong\n+     */\n+    double[][] value(double[] point)\n+        throws FunctionEvaluationException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/MultivariateRealFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/** \n+ * An interface representing a multivariate real function.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface MultivariateRealFunction {\n+\n+    /** \n+     * Compute the value for the function at the given point.\n+     * @param point point at which the function must be evaluated\n+     * @return function value for the given point\n+     * @exception FunctionEvaluationException if the function evaluation fails\n+     * @exception IllegalArgumentException if points dimension is wrong\n+     */\n+    double value(double[] point)\n+        throws FunctionEvaluationException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/MultivariateVectorialFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/** \n+ * An interface representing a multivariate vectorial function.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface MultivariateVectorialFunction {\n+\n+    /** \n+     * Compute the value for the function at the given point.\n+     * @param point point at which the function must be evaluated\n+     * @return function value for the given point\n+     * @exception FunctionEvaluationException if the function evaluation fails\n+     * @exception IllegalArgumentException if points dimension is wrong\n+     */\n+    double[] value(double[] point)\n+        throws FunctionEvaluationException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/UnivariateMatrixFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * An interface representing a univariate matrix function.\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface UnivariateMatrixFunction {\n+    /**\n+     * Compute the value for the function.\n+     * @param x the point for which the function value should be computed\n+     * @return the value\n+     * @throws FunctionEvaluationException if the function evaluation fails\n+     */\n+    public double[][] value(double x) throws FunctionEvaluationException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/UnivariateRealFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * An interface representing a univariate real function.\n+ *  \n+ * @version $Revision$ $Date$\n+ */\n+public interface UnivariateRealFunction {\n+    /**\n+     * Compute the value for the function.\n+     * @param x the point for which the function value should be computed\n+     * @return the value\n+     * @throws FunctionEvaluationException if the function evaluation fails\n+     */\n+    public double value(double x) throws FunctionEvaluationException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/UnivariateVectorialFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * An interface representing a univariate vectorial function.\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface UnivariateVectorialFunction {\n+    /**\n+     * Compute the value for the function.\n+     * @param x the point for which the function value should be computed\n+     * @return the value\n+     * @throws FunctionEvaluationException if the function evaluation fails\n+     */\n+    public double[] value(double x) throws FunctionEvaluationException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/LegendreGaussIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/Legendre-GaussQuadrature.html\">\n+ * Legendre-Gauss</a> quadrature formula.\n+ * <p>\n+ * Legendre-Gauss integrators are efficient integrators that can\n+ * accurately integrate functions with few functions evaluations. A\n+ * Legendre-Gauss integrator using an n-points quadrature formula can\n+ * integrate exactly 2n-1 degree polynomialss.\n+ * </p>\n+ * <p>\n+ * These integrators evaluate the function on n carefully chosen\n+ * abscissas in each step interval (mapped to the canonical [-1  1] interval).\n+ * The evaluation abscissas are not evenly spaced and none of them are\n+ * at the interval endpoints. This implies the function integrated can be\n+ * undefined at integration interval endpoints.\n+ * </p>\n+ * <p>\n+ * The evaluation abscissas x<sub>i</sub> are the roots of the degree n\n+ * Legendre polynomial. The weights a<sub>i</sub> of the quadrature formula\n+ * integrals from -1 to +1 &int; Li<sup>2</sup> where Li (x) =\n+ * &prod; (x-x<sub>k</sub>)/(x<sub>i</sub>-x<sub>k</sub>) for k != i.\n+ * </p>\n+ * <p>\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class LegendreGaussIntegrator extends UnivariateRealIntegratorImpl {\n+\n+    /** Abscissas for the 2 points method. */\n+    private static final double[] ABSCISSAS_2 = {\n+        -1.0 / Math.sqrt(3.0),\n+         1.0 / Math.sqrt(3.0)\n+    };\n+\n+    /** Weights for the 2 points method. */\n+    private static final double[] WEIGHTS_2 = {\n+        1.0,\n+        1.0\n+    };\n+\n+    /** Abscissas for the 3 points method. */\n+    private static final double[] ABSCISSAS_3 = {\n+        -Math.sqrt(0.6),\n+         0.0,\n+         Math.sqrt(0.6)\n+    };\n+\n+    /** Weights for the 3 points method. */\n+    private static final double[] WEIGHTS_3 = {\n+        5.0 / 9.0,\n+        8.0 / 9.0,\n+        5.0 / 9.0\n+    };\n+\n+    /** Abscissas for the 4 points method. */\n+    private static final double[] ABSCISSAS_4 = {\n+        -Math.sqrt((15.0 + 2.0 * Math.sqrt(30.0)) / 35.0),\n+        -Math.sqrt((15.0 - 2.0 * Math.sqrt(30.0)) / 35.0),\n+         Math.sqrt((15.0 - 2.0 * Math.sqrt(30.0)) / 35.0),\n+         Math.sqrt((15.0 + 2.0 * Math.sqrt(30.0)) / 35.0)\n+    };\n+\n+    /** Weights for the 4 points method. */\n+    private static final double[] WEIGHTS_4 = {\n+        (90.0 - 5.0 * Math.sqrt(30.0)) / 180.0,\n+        (90.0 + 5.0 * Math.sqrt(30.0)) / 180.0,\n+        (90.0 + 5.0 * Math.sqrt(30.0)) / 180.0,\n+        (90.0 - 5.0 * Math.sqrt(30.0)) / 180.0\n+    };\n+\n+    /** Abscissas for the 5 points method. */\n+    private static final double[] ABSCISSAS_5 = {\n+        -Math.sqrt((35.0 + 2.0 * Math.sqrt(70.0)) / 63.0),\n+        -Math.sqrt((35.0 - 2.0 * Math.sqrt(70.0)) / 63.0),\n+         0.0,\n+         Math.sqrt((35.0 - 2.0 * Math.sqrt(70.0)) / 63.0),\n+         Math.sqrt((35.0 + 2.0 * Math.sqrt(70.0)) / 63.0)\n+    };\n+\n+    /** Weights for the 5 points method. */\n+    private static final double[] WEIGHTS_5 = {\n+        (322.0 - 13.0 * Math.sqrt(70.0)) / 900.0,\n+        (322.0 + 13.0 * Math.sqrt(70.0)) / 900.0,\n+        128.0 / 225.0,\n+        (322.0 + 13.0 * Math.sqrt(70.0)) / 900.0,\n+        (322.0 - 13.0 * Math.sqrt(70.0)) / 900.0\n+    };\n+\n+    /** Abscissas for the current method. */\n+    private final double[] abscissas;\n+\n+    /** Weights for the current method. */\n+    private final double[] weights;\n+\n+    /** Build a Legendre-Gauss integrator.\n+     * @param n number of points desired (must be between 2 and 5 inclusive)\n+     * @param defaultMaximalIterationCount maximum number of iterations\n+     * @exception IllegalArgumentException if the number of points is not\n+     * in the supported range\n+     */\n+    public LegendreGaussIntegrator(final int n, final int defaultMaximalIterationCount)\n+        throws IllegalArgumentException {\n+        super(defaultMaximalIterationCount);\n+        switch(n) {\n+        case 2 :\n+            abscissas = ABSCISSAS_2;\n+            weights   = WEIGHTS_2;\n+            break;\n+        case 3 :\n+            abscissas = ABSCISSAS_3;\n+            weights   = WEIGHTS_3;\n+            break;\n+        case 4 :\n+            abscissas = ABSCISSAS_4;\n+            weights   = WEIGHTS_4;\n+            break;\n+        case 5 :\n+            abscissas = ABSCISSAS_5;\n+            weights   = WEIGHTS_5;\n+            break;\n+        default :\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0} points Legendre-Gauss integrator not supported, \" +\n+                    \"number of points must be in the {1}-{2} range\",\n+                    n, 2, 5);\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double integrate(final double min, final double max)\n+        throws ConvergenceException,  FunctionEvaluationException, IllegalArgumentException {\n+        return integrate(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double integrate(final UnivariateRealFunction f,\n+            final double min, final double max)\n+        throws ConvergenceException,  FunctionEvaluationException, IllegalArgumentException {\n+        \n+        clearResult();\n+        verifyInterval(min, max);\n+        verifyIterationCount();\n+\n+        // compute first estimate with a single step\n+        double oldt = stage(f, min, max, 1);\n+\n+        int n = 2;\n+        for (int i = 0; i < maximalIterationCount; ++i) {\n+\n+            // improve integral with a larger number of steps\n+            final double t = stage(f, min, max, n);\n+\n+            // estimate error\n+            final double delta = Math.abs(t - oldt);\n+            final double limit =\n+                Math.max(absoluteAccuracy,\n+                         relativeAccuracy * (Math.abs(oldt) + Math.abs(t)) * 0.5);\n+\n+            // check convergence\n+            if ((i + 1 >= minimalIterationCount) && (delta <= limit)) {\n+                setResult(t, i);\n+                return result;\n+            }\n+\n+            // prepare next iteration\n+            double ratio = Math.min(4, Math.pow(delta / limit, 0.5 / abscissas.length));\n+            n = Math.max((int) (ratio * n), n + 1);\n+            oldt = t;\n+\n+        }\n+\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+\n+    }\n+\n+    /**\n+     * Compute the n-th stage integral.\n+     * @param f the integrand function\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n number of steps\n+     * @return the value of n-th stage integral\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     */\n+    private double stage(final UnivariateRealFunction f,\n+                         final double min, final double max, final int n)\n+        throws FunctionEvaluationException {\n+\n+        // set up the step for the current stage\n+        final double step     = (max - min) / n;\n+        final double halfStep = step / 2.0;\n+\n+        // integrate over all elementary steps\n+        double midPoint = min + halfStep;\n+        double sum = 0.0;\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < abscissas.length; ++j) {\n+                sum += weights[j] * f.value(midPoint + halfStep * abscissas[j]);\n+            }\n+            midPoint += step;\n+        }\n+\n+        return halfStep * sum;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/RombergIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/RombergIntegration.html\">\n+ * Romberg Algorithm</a> for integration of real univariate functions. For\n+ * reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,\n+ * chapter 3.\n+ * <p>\n+ * Romberg integration employs k successive refinements of the trapezoid\n+ * rule to remove error terms less than order O(N^(-2k)). Simpson's rule\n+ * is a special case of k = 2.</p>\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class RombergIntegrator extends UnivariateRealIntegratorImpl {\n+\n+    /**\n+     * Construct an integrator for the given function.\n+     * \n+     * @param f function to integrate\n+     * @deprecated as of 2.0 the integrand function is passed as an argument\n+     * to the {@link #integrate(UnivariateRealFunction, double, double)}method.\n+     */\n+    @Deprecated\n+    public RombergIntegrator(UnivariateRealFunction f) {\n+        super(f, 32);\n+    }\n+\n+    /**\n+     * Construct an integrator.\n+     */\n+    public RombergIntegrator() {\n+        super(32);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double integrate(final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException, IllegalArgumentException {\n+        return integrate(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double integrate(final UnivariateRealFunction f,\n+                            final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException, IllegalArgumentException {\n+        \n+        int i = 1, j, m = maximalIterationCount + 1;\n+        // Array structure here can be improved for better space\n+        // efficiency because only the lower triangle is used.\n+        double r, t[][] = new double[m][m], s, olds;\n+\n+        clearResult();\n+        verifyInterval(min, max);\n+        verifyIterationCount();\n+\n+        TrapezoidIntegrator qtrap = new TrapezoidIntegrator();\n+        t[0][0] = qtrap.stage(f, min, max, 0);\n+        olds = t[0][0];\n+        while (i <= maximalIterationCount) {\n+            t[i][0] = qtrap.stage(f, min, max, i);\n+            for (j = 1; j <= i; j++) {\n+                // Richardson extrapolation coefficient\n+                r = (1L << (2 * j)) -1;\n+                t[i][j] = t[i][j-1] + (t[i][j-1] - t[i-1][j-1]) / r;\n+            }\n+            s = t[i][i];\n+            if (i >= minimalIterationCount) {\n+                final double delta = Math.abs(s - olds);\n+                final double rLimit =\n+                    relativeAccuracy * (Math.abs(olds) + Math.abs(s)) * 0.5; \n+                if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n+                    setResult(s, i);\n+                    return result;\n+                }\n+            }\n+            olds = s;\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected void verifyIterationCount() throws IllegalArgumentException {\n+        super.verifyIterationCount();\n+        // at most 32 bisection refinements due to higher order divider\n+        if (maximalIterationCount > 32) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid iteration limits: min={0}, max={1}\",\n+                    0, 32);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/SimpsonIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/SimpsonsRule.html\">\n+ * Simpson's Rule</a> for integration of real univariate functions. For\n+ * reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,\n+ * chapter 3.\n+ * <p>\n+ * This implementation employs basic trapezoid rule as building blocks to\n+ * calculate the Simpson's rule of alternating 2/3 and 4/3.</p>\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class SimpsonIntegrator extends UnivariateRealIntegratorImpl {\n+\n+    /**\n+     * Construct an integrator for the given function.\n+     * \n+     * @param f function to integrate\n+     * @deprecated as of 2.0 the integrand function is passed as an argument\n+     * to the {@link #integrate(UnivariateRealFunction, double, double)}method.\n+     */\n+    @Deprecated\n+    public SimpsonIntegrator(UnivariateRealFunction f) {\n+        super(f, 64);\n+    }\n+\n+    /**\n+     * Construct an integrator.\n+     */\n+    public SimpsonIntegrator() {\n+        super(64);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double integrate(final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException, IllegalArgumentException {\n+        return integrate(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double integrate(final UnivariateRealFunction f,\n+                            final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException, IllegalArgumentException {\n+        \n+        int i = 1;\n+        double s, olds, t, oldt;\n+        \n+        clearResult();\n+        verifyInterval(min, max);\n+        verifyIterationCount();\n+\n+        TrapezoidIntegrator qtrap = new TrapezoidIntegrator();\n+        if (minimalIterationCount == 1) {\n+            s = (4 * qtrap.stage(f, min, max, 1) - qtrap.stage(f, min, max, 0)) / 3.0;\n+            setResult(s, 1);\n+            return result;\n+        }\n+        // Simpson's rule requires at least two trapezoid stages.\n+        olds = 0;\n+        oldt = qtrap.stage(f, min, max, 0);\n+        while (i <= maximalIterationCount) {\n+            t = qtrap.stage(f, min, max, i);\n+            s = (4 * t - oldt) / 3.0;\n+            if (i >= minimalIterationCount) {\n+                final double delta = Math.abs(s - olds);\n+                final double rLimit =\n+                    relativeAccuracy * (Math.abs(olds) + Math.abs(s)) * 0.5; \n+                if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n+                    setResult(s, i);\n+                    return result;\n+                }\n+            }\n+            olds = s;\n+            oldt = t;\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected void verifyIterationCount() throws IllegalArgumentException {\n+        super.verifyIterationCount();\n+        // at most 64 bisection refinements\n+        if (maximalIterationCount > 64) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid iteration limits: min={0}, max={1}\",\n+                    0, 64);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/TrapezoidIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/TrapezoidalRule.html\">\n+ * Trapezoidal Rule</a> for integration of real univariate functions. For\n+ * reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,\n+ * chapter 3.\n+ * <p>\n+ * The function should be integrable.</p>\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class TrapezoidIntegrator extends UnivariateRealIntegratorImpl {\n+\n+    /** Intermediate result. */\n+    private double s;\n+\n+    /**\n+     * Construct an integrator for the given function.\n+     * \n+     * @param f function to integrate\n+     * @deprecated as of 2.0 the integrand function is passed as an argument\n+     * to the {@link #integrate(UnivariateRealFunction, double, double)}method.\n+     */\n+    @Deprecated\n+    public TrapezoidIntegrator(UnivariateRealFunction f) {\n+        super(f, 64);\n+    }\n+\n+    /**\n+     * Construct an integrator.\n+     */\n+    public TrapezoidIntegrator() {\n+        super(64);\n+    }\n+\n+    /**\n+     * Compute the n-th stage integral of trapezoid rule. This function\n+     * should only be called by API <code>integrate()</code> in the package.\n+     * To save time it does not verify arguments - caller does.\n+     * <p>\n+     * The interval is divided equally into 2^n sections rather than an\n+     * arbitrary m sections because this configuration can best utilize the\n+     * alrealy computed values.</p>\n+     *\n+     * @param f the integrand function\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the stage of 1/2 refinement, n = 0 is no refinement\n+     * @return the value of n-th stage integral\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     */\n+    double stage(final UnivariateRealFunction f,\n+                 final double min, final double max, final int n)\n+        throws FunctionEvaluationException {\n+        \n+        long i, np;\n+        double x, spacing, sum = 0;\n+        \n+        if (n == 0) {\n+            s = 0.5 * (max - min) * (f.value(min) + f.value(max));\n+            return s;\n+        } else {\n+            np = 1L << (n-1);           // number of new points in this stage\n+            spacing = (max - min) / np; // spacing between adjacent new points\n+            x = min + 0.5 * spacing;    // the first new point\n+            for (i = 0; i < np; i++) {\n+                sum += f.value(x);\n+                x += spacing;\n+            }\n+            // add the new sum to previously calculated result\n+            s = 0.5 * (s + sum * spacing);\n+            return s;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double integrate(final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException, IllegalArgumentException {\n+        return integrate(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double integrate(final UnivariateRealFunction f,\n+                            final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException, IllegalArgumentException {\n+        \n+        int i = 1;\n+        double t, oldt;\n+        \n+        clearResult();\n+        verifyInterval(min, max);\n+        verifyIterationCount();\n+\n+        oldt = stage(f, min, max, 0);\n+        while (i <= maximalIterationCount) {\n+            t = stage(f, min, max, i);\n+            if (i >= minimalIterationCount) {\n+                final double delta = Math.abs(t - oldt);\n+                final double rLimit =\n+                    relativeAccuracy * (Math.abs(oldt) + Math.abs(t)) * 0.5; \n+                if ((delta <= rLimit) || (delta <= absoluteAccuracy)) {\n+                    setResult(t, i);\n+                    return result;\n+                }\n+            }\n+            oldt = t;\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected void verifyIterationCount() throws IllegalArgumentException {\n+        super.verifyIterationCount();\n+        // at most 64 bisection refinements\n+        if (maximalIterationCount > 64) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid iteration limits: min={0}, max={1}\",\n+                    0, 64);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.ConvergingAlgorithm;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Interface for univariate real integration algorithms.\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public interface UnivariateRealIntegrator extends ConvergingAlgorithm {\n+\n+   /**\n+     * Set the lower limit for the number of iterations.\n+     * <p>\n+     * Minimal iteration is needed to avoid false early convergence, e.g.\n+     * the sample points happen to be zeroes of the function. Users can\n+     * use the default value or choose one that they see as appropriate.</p>\n+     * <p>\n+     * A <code>ConvergenceException</code> will be thrown if this number\n+     * is not met.</p>\n+     *\n+     * @param count minimum number of iterations\n+     */\n+    void setMinimalIterationCount(int count);\n+\n+    /**\n+     * Get the lower limit for the number of iterations.\n+     * \n+     * @return the actual lower limit\n+     */\n+    int getMinimalIterationCount();\n+\n+    /**\n+     * Reset the lower limit for the number of iterations to the default.\n+     * <p>\n+     * The default value is supplied by the implementation.</p>\n+     * \n+     * @see #setMinimalIterationCount(int)\n+     */\n+    void resetMinimalIterationCount();\n+\n+    /**\n+     * Integrate the function in the given interval.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the value of integral\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the integrator detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the endpoints do not\n+     * satisfy the requirements specified by the integrator\n+     * @deprecated replaced by {@link #integrate(UnivariateRealFunction, double, double)}\n+     * since 2.0\n+     */\n+    @Deprecated\n+    double integrate(double min, double max) throws ConvergenceException, \n+        FunctionEvaluationException, IllegalArgumentException;\n+\n+    /**\n+     * Integrate the function in the given interval.\n+     * \n+     * @param f the integrand function\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the value of integral\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the integrator detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the endpoints do not\n+     * satisfy the requirements specified by the integrator\n+     */\n+    double integrate(UnivariateRealFunction f, double min, double max) throws ConvergenceException, \n+        FunctionEvaluationException, IllegalArgumentException;\n+\n+    /**\n+     * Get the result of the last run of the integrator.\n+     * \n+     * @return the last result\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed\n+     */\n+    double getResult() throws IllegalStateException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/integration/UnivariateRealIntegratorImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import org.apache.commons.math.ConvergingAlgorithmImpl;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Provide a default implementation for several generic functions.\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public abstract class UnivariateRealIntegratorImpl\n+    extends ConvergingAlgorithmImpl implements UnivariateRealIntegrator {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 6248808456637441533L;\n+\n+    /** minimum number of iterations */\n+    protected int minimalIterationCount;\n+\n+    /** default minimum number of iterations */\n+    protected int defaultMinimalIterationCount;\n+\n+    /** indicates whether an integral has been computed */\n+    protected boolean resultComputed = false;\n+\n+    /** the last computed integral */\n+    protected double result;\n+\n+    /** The integrand functione.\n+     * @deprecated as of 2.0 the integrand function is passed as an argument\n+     * to the {@link #integrate(UnivariateRealFunction, double, double)}method. */\n+    @Deprecated\n+    protected UnivariateRealFunction f;\n+\n+    /**\n+     * Construct an integrator with given iteration count and accuracy.\n+     * \n+     * @param f the integrand function\n+     * @param defaultMaximalIterationCount maximum number of iterations\n+     * @throws IllegalArgumentException if f is null or the iteration\n+     * limits are not valid\n+     * @deprecated as of 2.0 the integrand function is passed as an argument\n+     * to the {@link #integrate(UnivariateRealFunction, double, double)}method.\n+     */\n+    @Deprecated\n+    protected UnivariateRealIntegratorImpl(final UnivariateRealFunction f,\n+                                           final int defaultMaximalIterationCount)\n+        throws IllegalArgumentException {\n+        super(defaultMaximalIterationCount, 1.0e-15);\n+        if (f == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n+        }\n+\n+        this.f = f;\n+\n+        // parameters that are problem specific\n+        setRelativeAccuracy(1.0e-6);\n+        this.defaultMinimalIterationCount = 3;\n+        this.minimalIterationCount = defaultMinimalIterationCount;\n+        \n+        verifyIterationCount();\n+    }\n+\n+    /**\n+     * Construct an integrator with given iteration count and accuracy.\n+     * \n+     * @param defaultMaximalIterationCount maximum number of iterations\n+     * @throws IllegalArgumentException if f is null or the iteration\n+     * limits are not valid\n+     */\n+    protected UnivariateRealIntegratorImpl(final int defaultMaximalIterationCount)\n+        throws IllegalArgumentException {\n+        super(defaultMaximalIterationCount, 1.0e-15);\n+\n+        // parameters that are problem specific\n+        setRelativeAccuracy(1.0e-6);\n+        this.defaultMinimalIterationCount = 3;\n+        this.minimalIterationCount = defaultMinimalIterationCount;\n+        \n+        verifyIterationCount();\n+    }\n+\n+    /**\n+     * Access the last computed integral.\n+     * \n+     * @return the last computed integral\n+     * @throws IllegalStateException if no integral has been computed\n+     */\n+    public double getResult() throws IllegalStateException {\n+        if (resultComputed) {\n+            return result;\n+        } else {\n+            throw MathRuntimeException.createIllegalStateException(\"no result available\");\n+        }\n+    }\n+\n+    /**\n+     * Convenience function for implementations.\n+     * \n+     * @param result the result to set\n+     * @param iterationCount the iteration count to set\n+     */\n+    protected final void setResult(double result, int iterationCount) {\n+        this.result = result;\n+        this.iterationCount = iterationCount;\n+        this.resultComputed = true;\n+    }\n+\n+    /**\n+     * Convenience function for implementations.\n+     */\n+    protected final void clearResult() {\n+        this.iterationCount = 0;\n+        this.resultComputed = false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMinimalIterationCount(int count) {\n+        minimalIterationCount = count;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMinimalIterationCount() {\n+        return minimalIterationCount;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void resetMinimalIterationCount() {\n+        minimalIterationCount = defaultMinimalIterationCount;\n+    }\n+\n+    /**\n+     * Verifies that the endpoints specify an interval.\n+     * \n+     * @param lower lower endpoint\n+     * @param upper upper endpoint\n+     * @throws IllegalArgumentException if not interval\n+     */\n+    protected void verifyInterval(double lower, double upper) throws\n+        IllegalArgumentException {\n+        if (lower >= upper) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"endpoints do not specify an interval: [{0}, {1}]\",\n+                    lower, upper);\n+        }       \n+    }\n+\n+    /**\n+     * Verifies that the upper and lower limits of iterations are valid.\n+     * \n+     * @throws IllegalArgumentException if not valid\n+     */\n+    protected void verifyIterationCount() throws IllegalArgumentException {\n+        if ((minimalIterationCount <= 0) || (maximalIterationCount <= minimalIterationCount)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid iteration limits: min={0}, max={1}\",\n+                    minimalIterationCount, maximalIterationCount);\n+        }       \n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.DuplicateSampleAbscissaException;\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm;\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunctionNewtonForm;\n+\n+/**\n+ * Implements the <a href=\"\n+ * \"http://mathworld.wolfram.com/NewtonsDividedDifferenceInterpolationFormula.html\">\n+ * Divided Difference Algorithm</a> for interpolation of real univariate\n+ * functions. For reference, see <b>Introduction to Numerical Analysis</b>,\n+ * ISBN 038795452X, chapter 2.\n+ * <p>\n+ * The actual code of Neville's evaluation is in PolynomialFunctionLagrangeForm,\n+ * this class provides an easy-to-use interface to it.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class DividedDifferenceInterpolator implements UnivariateRealInterpolator,\n+    Serializable {\n+\n+    /** serializable version identifier */\n+    private static final long serialVersionUID = 107049519551235069L;\n+\n+    /**\n+     * Computes an interpolating function for the data set.\n+     *\n+     * @param x the interpolating points array\n+     * @param y the interpolating values array\n+     * @return a function which interpolates the data set\n+     * @throws DuplicateSampleAbscissaException if arguments are invalid\n+     */\n+    public PolynomialFunctionNewtonForm interpolate(double x[], double y[]) throws\n+        DuplicateSampleAbscissaException {\n+\n+        /**\n+         * a[] and c[] are defined in the general formula of Newton form:\n+         * p(x) = a[0] + a[1](x-c[0]) + a[2](x-c[0])(x-c[1]) + ... +\n+         *        a[n](x-c[0])(x-c[1])...(x-c[n-1])\n+         */\n+        double a[], c[];\n+\n+        PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y);\n+\n+        /**\n+         * When used for interpolation, the Newton form formula becomes\n+         * p(x) = f[x0] + f[x0,x1](x-x0) + f[x0,x1,x2](x-x0)(x-x1) + ... +\n+         *        f[x0,x1,...,x[n-1]](x-x0)(x-x1)...(x-x[n-2])\n+         * Therefore, a[k] = f[x0,x1,...,xk], c[k] = x[k].\n+         * <p>\n+         * Note x[], y[], a[] have the same length but c[]'s size is one less.</p>\n+         */\n+        c = new double[x.length-1];\n+        for (int i = 0; i < c.length; i++) {\n+            c[i] = x[i];\n+        }\n+        a = computeDividedDifference(x, y);\n+\n+        return new PolynomialFunctionNewtonForm(a, c);\n+\n+    }\n+\n+    /**\n+     * Returns a copy of the divided difference array.\n+     * <p> \n+     * The divided difference array is defined recursively by <pre>\n+     * f[x0] = f(x0)\n+     * f[x0,x1,...,xk] = (f(x1,...,xk) - f(x0,...,x[k-1])) / (xk - x0)\n+     * </pre></p>\n+     * <p>\n+     * The computational complexity is O(N^2).</p>\n+     *\n+     * @param x the interpolating points array\n+     * @param y the interpolating values array\n+     * @return a fresh copy of the divided difference array\n+     * @throws DuplicateSampleAbscissaException if any abscissas coincide\n+     */\n+    protected static double[] computeDividedDifference(double x[], double y[])\n+        throws DuplicateSampleAbscissaException {\n+\n+        int i, j, n;\n+        double divdiff[], a[], denominator;\n+\n+        PolynomialFunctionLagrangeForm.verifyInterpolationArray(x, y);\n+\n+        n = x.length;\n+        divdiff = new double[n];\n+        for (i = 0; i < n; i++) {\n+            divdiff[i] = y[i];      // initialization\n+        }\n+\n+        a = new double [n];\n+        a[0] = divdiff[0];\n+        for (i = 1; i < n; i++) {\n+            for (j = 0; j < n-i; j++) {\n+                denominator = x[j+i] - x[j];\n+                if (denominator == 0.0) {\n+                    // This happens only when two abscissas are identical.\n+                    throw new DuplicateSampleAbscissaException(x[j], j, j+i);\n+                }\n+                divdiff[j] = (divdiff[j+1] - divdiff[j]) / denominator;\n+            }\n+            a[i] = divdiff[0];\n+        }\n+\n+        return a;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/LoessInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n+\n+/**\n+ * Implements the <a href=\"http://en.wikipedia.org/wiki/Local_regression\">\n+ * Local Regression Algorithm</a> (also Loess, Lowess) for interpolation of\n+ * real univariate functions.\n+ * <p/>\n+ * For reference, see\n+ * <a href=\"http://www.math.tau.ac.il/~yekutiel/MA seminar/Cleveland 1979.pdf\">\n+ * William S. Cleveland - Robust Locally Weighted Regression and Smoothing\n+ * Scatterplots</a>\n+ * <p/>\n+ * This class implements both the loess method and serves as an interpolation\n+ * adapter to it, allowing to build a spline on the obtained loess fit.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class LoessInterpolator\n+        implements UnivariateRealInterpolator, Serializable {\n+\n+    /** serializable version identifier. */\n+    private static final long serialVersionUID = 5204927143605193821L;\n+\n+    /**\n+     * Default value of the bandwidth parameter.\n+     */\n+    public static final double DEFAULT_BANDWIDTH = 0.3;\n+    /**\n+     * Default value of the number of robustness iterations.\n+     */\n+    public static final int DEFAULT_ROBUSTNESS_ITERS = 2;\n+\n+    /**\n+     * The bandwidth parameter: when computing the loess fit at\n+     * a particular point, this fraction of source points closest\n+     * to the current point is taken into account for computing\n+     * a least-squares regression.\n+     * <p/>\n+     * A sensible value is usually 0.25 to 0.5.\n+     */\n+    private final double bandwidth;\n+\n+    /**\n+     * The number of robustness iterations parameter: this many\n+     * robustness iterations are done.\n+     * <p/>\n+     * A sensible value is usually 0 (just the initial fit without any\n+     * robustness iterations) to 4.\n+     */\n+    private final int robustnessIters;\n+\n+    /**\n+     * Constructs a new {@link LoessInterpolator}\n+     * with a bandwidth of {@link #DEFAULT_BANDWIDTH} and\n+     * {@link #DEFAULT_ROBUSTNESS_ITERS} robustness iterations.\n+     * See {@link #LoessInterpolator(double, int)} for an explanation of\n+     * the parameters.\n+     */\n+    public LoessInterpolator() {\n+        this.bandwidth = DEFAULT_BANDWIDTH;\n+        this.robustnessIters = DEFAULT_ROBUSTNESS_ITERS;\n+    }\n+\n+    /**\n+     * Constructs a new {@link LoessInterpolator}\n+     * with given bandwidth and number of robustness iterations.\n+     *\n+     * @param bandwidth  when computing the loess fit at\n+     * a particular point, this fraction of source points closest\n+     * to the current point is taken into account for computing\n+     * a least-squares regression.</br>\n+     * A sensible value is usually 0.25 to 0.5, the default value is\n+     * {@link #DEFAULT_BANDWIDTH}.\n+     * @param robustnessIters This many robustness iterations are done.</br>\n+     * A sensible value is usually 0 (just the initial fit without any\n+     * robustness iterations) to 4, the default value is\n+     * {@link #DEFAULT_ROBUSTNESS_ITERS}.\n+     * @throws MathException if bandwidth does not lie in the interval [0,1]\n+     * or if robustnessIters is negative.\n+     */\n+    public LoessInterpolator(double bandwidth, int robustnessIters) throws MathException {\n+        if (bandwidth < 0 || bandwidth > 1) {\n+            throw new MathException(\"bandwidth must be in the interval [0,1], but got {0}\",\n+                                    bandwidth);\n+        }\n+        this.bandwidth = bandwidth;\n+        if (robustnessIters < 0) {\n+            throw new MathException(\"the number of robustness iterations must \" +\n+                                    \"be non-negative, but got {0}\",\n+                                    robustnessIters);\n+        }\n+        this.robustnessIters = robustnessIters;\n+    }\n+\n+    /**\n+     * Compute an interpolating function by performing a loess fit\n+     * on the data at the original abscissae and then building a cubic spline\n+     * with a\n+     * {@link org.apache.commons.math.analysis.interpolation.SplineInterpolator}\n+     * on the resulting fit.\n+     *\n+     * @param xval the arguments for the interpolation points\n+     * @param yval the values for the interpolation points\n+     * @return A cubic spline built upon a loess fit to the data at the original abscissae\n+     * @throws MathException  if some of the following conditions are false:\n+     * <ul>\n+     * <li> Arguments and values are of the same size that is greater than zero</li>\n+     * <li> The arguments are in a strictly increasing order</li>\n+     * <li> All arguments and values are finite real numbers</li>\n+     * </ul>\n+     */\n+    public final PolynomialSplineFunction interpolate(\n+            final double[] xval, final double[] yval) throws MathException {\n+        return new SplineInterpolator().interpolate(xval, smooth(xval, yval));\n+    }\n+\n+    /**\n+     * Compute a loess fit on the data at the original abscissae.\n+     *\n+     * @param xval the arguments for the interpolation points\n+     * @param yval the values for the interpolation points\n+     * @return values of the loess fit at corresponding original abscissae\n+     * @throws MathException if some of the following conditions are false:\n+     * <ul>\n+     * <li> Arguments and values are of the same size that is greater than zero</li>\n+     * <li> The arguments are in a strictly increasing order</li>\n+     * <li> All arguments and values are finite real numbers</li>\n+     * </ul>\n+     */\n+    public final double[] smooth(final double[] xval, final double[] yval)\n+            throws MathException {\n+        if (xval.length != yval.length) {\n+            throw new MathException(\n+                    \"Loess expects the abscissa and ordinate arrays \" +\n+                    \"to be of the same size, \" +\n+                    \"but got {0} abscisssae and {1} ordinatae\",\n+                    xval.length, yval.length);\n+        }\n+\n+        final int n = xval.length;\n+\n+        if (n == 0) {\n+            throw new MathException(\"Loess expects at least 1 point\");\n+        }\n+\n+        checkAllFiniteReal(xval, true);\n+        checkAllFiniteReal(yval, false);\n+\n+        checkStrictlyIncreasing(xval);\n+\n+        if (n == 1) {\n+            return new double[]{yval[0]};\n+        }\n+\n+        if (n == 2) {\n+            return new double[]{yval[0], yval[1]};\n+        }\n+\n+        int bandwidthInPoints = (int) (bandwidth * n);\n+\n+        if (bandwidthInPoints < 2) {\n+            throw new MathException(\n+                    \"the bandwidth must be large enough to \" +\n+                    \"accomodate at least 2 points. There are {0} \" +\n+                    \" data points, and bandwidth must be at least {1} \" +\n+                    \" but it is only {2}\",\n+                    n, 2.0 / n, bandwidth);\n+        }\n+\n+        final double[] res = new double[n];\n+\n+        final double[] residuals = new double[n];\n+        final double[] sortedResiduals = new double[n];\n+\n+        final double[] robustnessWeights = new double[n];\n+\n+        // Do an initial fit and 'robustnessIters' robustness iterations.\n+        // This is equivalent to doing 'robustnessIters+1' robustness iterations\n+        // starting with all robustness weights set to 1.\n+        Arrays.fill(robustnessWeights, 1);\n+\n+        for (int iter = 0; iter <= robustnessIters; ++iter) {\n+            final int[] bandwidthInterval = {0, bandwidthInPoints - 1};\n+            // At each x, compute a local weighted linear regression\n+            for (int i = 0; i < n; ++i) {\n+                final double x = xval[i];\n+\n+                // Find out the interval of source points on which\n+                // a regression is to be made.\n+                if (i > 0) {\n+                    updateBandwidthInterval(xval, i, bandwidthInterval);\n+                }\n+\n+                final int ileft = bandwidthInterval[0];\n+                final int iright = bandwidthInterval[1];\n+\n+                // Compute the point of the bandwidth interval that is\n+                // farthest from x\n+                final int edge;\n+                if (xval[i] - xval[ileft] > xval[iright] - xval[i]) {\n+                    edge = ileft;\n+                } else {\n+                    edge = iright;\n+                }\n+\n+                // Compute a least-squares linear fit weighted by\n+                // the product of robustness weights and the tricube\n+                // weight function.\n+                // See http://en.wikipedia.org/wiki/Linear_regression\n+                // (section \"Univariate linear case\")\n+                // and http://en.wikipedia.org/wiki/Weighted_least_squares\n+                // (section \"Weighted least squares\")\n+                double sumWeights = 0;\n+                double sumX = 0, sumXSquared = 0, sumY = 0, sumXY = 0;\n+                double denom = Math.abs(1.0 / (xval[edge] - x));\n+                for (int k = ileft; k <= iright; ++k) {\n+                    final double xk = xval[k];\n+                    final double yk = yval[k];\n+                    double dist;\n+                    if (k < i) {\n+                        dist = (x - xk);\n+                    } else {\n+                        dist = (xk - x);\n+                    }\n+                    final double w = tricube(dist * denom) * robustnessWeights[k];\n+                    final double xkw = xk * w;\n+                    sumWeights += w;\n+                    sumX += xkw;\n+                    sumXSquared += xk * xkw;\n+                    sumY += yk * w;\n+                    sumXY += yk * xkw;\n+                }\n+\n+                final double meanX = sumX / sumWeights;\n+                final double meanY = sumY / sumWeights;\n+                final double meanXY = sumXY / sumWeights;\n+                final double meanXSquared = sumXSquared / sumWeights;\n+\n+                final double beta;\n+                if (meanXSquared == meanX * meanX) {\n+                    beta = 0;\n+                } else {\n+                    beta = (meanXY - meanX * meanY) / (meanXSquared - meanX * meanX);\n+                }\n+\n+                final double alpha = meanY - beta * meanX;\n+\n+                res[i] = beta * x + alpha;\n+                residuals[i] = Math.abs(yval[i] - res[i]);\n+            }\n+\n+            // No need to recompute the robustness weights at the last\n+            // iteration, they won't be needed anymore\n+            if (iter == robustnessIters) {\n+                break;\n+            }\n+\n+            // Recompute the robustness weights.\n+\n+            // Find the median residual.\n+            // An arraycopy and a sort are completely tractable here, \n+            // because the preceding loop is a lot more expensive\n+            System.arraycopy(residuals, 0, sortedResiduals, 0, n);\n+            Arrays.sort(sortedResiduals);\n+            final double medianResidual = sortedResiduals[n / 2];\n+\n+            if (medianResidual == 0) {\n+                break;\n+            }\n+\n+            for (int i = 0; i < n; ++i) {\n+                final double arg = residuals[i] / (6 * medianResidual);\n+                robustnessWeights[i] = (arg >= 1) ? 0 : Math.pow(1 - arg * arg, 2);\n+            }\n+        }\n+\n+        return res;\n+    }\n+\n+    /**\n+     * Given an index interval into xval that embraces a certain number of\n+     * points closest to xval[i-1], update the interval so that it embraces\n+     * the same number of points closest to xval[i]\n+     *\n+     * @param xval arguments array\n+     * @param i the index around which the new interval should be computed\n+     * @param bandwidthInterval a two-element array {left, right} such that: <p/>\n+     * <tt>(left==0 or xval[i] - xval[left-1] > xval[right] - xval[i])</tt>\n+     * <p/> and also <p/>\n+     * <tt>(right==xval.length-1 or xval[right+1] - xval[i] > xval[i] - xval[left])</tt>.\n+     * The array will be updated.\n+     */\n+    private static void updateBandwidthInterval(final double[] xval, final int i,\n+                                                final int[] bandwidthInterval) {\n+        final int left = bandwidthInterval[0];\n+        final int right = bandwidthInterval[1];\n+\n+        // The right edge should be adjusted if the next point to the right\n+        // is closer to xval[i] than the leftmost point of the current interval\n+        if (right < xval.length - 1 &&\n+           xval[right+1] - xval[i] < xval[i] - xval[left]) {\n+            bandwidthInterval[0]++;\n+            bandwidthInterval[1]++;\n+        }\n+    }\n+\n+    /**\n+     * Compute the \n+     * <a href=\"http://en.wikipedia.org/wiki/Local_regression#Weight_function\">tricube</a>\n+     * weight function\n+     *\n+     * @param x the argument\n+     * @return (1-|x|^3)^3\n+     */\n+    private static double tricube(final double x) {\n+        final double tmp = 1 - x * x * x;\n+        return tmp * tmp * tmp;\n+    }\n+\n+    /**\n+     * Check that all elements of an array are finite real numbers.\n+     *\n+     * @param values the values array\n+     * @param isAbscissae if true, elements are abscissae otherwise they are ordinatae\n+     * @throws MathException if one of the values is not\n+     *         a finite real number\n+     */\n+    private static void checkAllFiniteReal(final double[] values, final boolean isAbscissae)\n+        throws MathException {\n+        for (int i = 0; i < values.length; i++) {\n+            final double x = values[i];\n+            if (Double.isInfinite(x) || Double.isNaN(x)) {\n+                final String pattern = isAbscissae ?\n+                        \"all abscissae must be finite real numbers, but {0}-th is {1}\" :\n+                        \"all ordinatae must be finite real numbers, but {0}-th is {1}\";\n+                throw new MathException(pattern, i, x);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Check that elements of the abscissae array are in a strictly\n+     * increasing order.\n+     *\n+     * @param xval the abscissae array\n+     * @throws MathException if the abscissae array\n+     * is not in a strictly increasing order\n+     */\n+    private static void checkStrictlyIncreasing(final double[] xval)\n+        throws MathException {\n+        for (int i = 0; i < xval.length; ++i) {\n+            if (i >= 1 && xval[i - 1] >= xval[i]) {\n+                throw new MathException(\n+                        \"the abscissae array must be sorted in a strictly \" +\n+                        \"increasing order, but the {0}-th element is {1} \" +\n+                        \"whereas {2}-th is {3}\",\n+                        i - 1, xval[i - 1], i, xval[i]);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/NevilleInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunctionLagrangeForm;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/NevillesAlgorithm.html\">\n+ * Neville's Algorithm</a> for interpolation of real univariate functions. For\n+ * reference, see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X,\n+ * chapter 2.\n+ * <p>\n+ * The actual code of Neville's evalution is in PolynomialFunctionLagrangeForm,\n+ * this class provides an easy-to-use interface to it.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class NevilleInterpolator implements UnivariateRealInterpolator,\n+    Serializable {\n+\n+    /** serializable version identifier */\n+    static final long serialVersionUID = 3003707660147873733L;\n+\n+    /**\n+     * Computes an interpolating function for the data set.\n+     *\n+     * @param x the interpolating points array\n+     * @param y the interpolating values array\n+     * @return a function which interpolates the data set\n+     * @throws MathException if arguments are invalid\n+     */\n+    public PolynomialFunctionLagrangeForm interpolate(double x[], double y[])\n+        throws MathException {\n+        return new PolynomialFunctionLagrangeForm(x, y);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/SplineInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n+\n+/**\n+ * Computes a natural (also known as \"free\", \"unclamped\") cubic spline interpolation for the data set.\n+ * <p>\n+ * The {@link #interpolate(double[], double[])} method returns a {@link PolynomialSplineFunction}\n+ * consisting of n cubic polynomials, defined over the subintervals determined by the x values,  \n+ * x[0] < x[i] ... < x[n].  The x values are referred to as \"knot points.\"</p>\n+ * <p>\n+ * The value of the PolynomialSplineFunction at a point x that is greater than or equal to the smallest\n+ * knot point and strictly less than the largest knot point is computed by finding the subinterval to which\n+ * x belongs and computing the value of the corresponding polynomial at <code>x - x[i] </code> where\n+ * <code>i</code> is the index of the subinterval.  See {@link PolynomialSplineFunction} for more details.\n+ * </p>\n+ * <p>\n+ * The interpolating polynomials satisfy: <ol>\n+ * <li>The value of the PolynomialSplineFunction at each of the input x values equals the \n+ *  corresponding y value.</li>\n+ * <li>Adjacent polynomials are equal through two derivatives at the knot points (i.e., adjacent polynomials \n+ *  \"match up\" at the knot points, as do their first and second derivatives).</li>\n+ * </ol></p>\n+ * <p>\n+ * The cubic spline interpolation algorithm implemented is as described in R.L. Burden, J.D. Faires, \n+ * <u>Numerical Analysis</u>, 4th Ed., 1989, PWS-Kent, ISBN 0-53491-585-X, pp 126-131.\n+ * </p>\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ */\n+public class SplineInterpolator implements UnivariateRealInterpolator {\n+    \n+    /**\n+     * Computes an interpolating function for the data set.\n+     * @param x the arguments for the interpolation points\n+     * @param y the values for the interpolation points\n+     * @return a function which interpolates the data set\n+     */\n+    public PolynomialSplineFunction interpolate(double x[], double y[]) {\n+        if (x.length != y.length) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"dimension mismatch {0} != {1}\", x.length, y.length);\n+        }\n+        \n+        if (x.length < 3) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} points are required, got only {1}\", 3, x.length);\n+        }\n+        \n+        // Number of intervals.  The number of data points is n + 1.\n+        int n = x.length - 1;   \n+        \n+        for (int i = 0; i < n; i++) {\n+            if (x[i]  >= x[i + 1]) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"points {0} and {1} are not strictly increasing ({2} >= {3})\",\n+                      i, i+1, x[i], x[i+1]);\n+            }\n+        }\n+        \n+        // Differences between knot points\n+        double h[] = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            h[i] = x[i + 1] - x[i];\n+        }\n+        \n+        double mu[] = new double[n];\n+        double z[] = new double[n + 1];\n+        mu[0] = 0d;\n+        z[0] = 0d;\n+        double g = 0;\n+        for (int i = 1; i < n; i++) {\n+            g = 2d * (x[i+1]  - x[i - 1]) - h[i - 1] * mu[i -1];\n+            mu[i] = h[i] / g;\n+            z[i] = (3d * (y[i + 1] * h[i - 1] - y[i] * (x[i + 1] - x[i - 1])+ y[i - 1] * h[i]) /\n+                    (h[i - 1] * h[i]) - h[i - 1] * z[i - 1]) / g;\n+        }\n+       \n+        // cubic spline coefficients --  b is linear, c quadratic, d is cubic (original y's are constants)\n+        double b[] = new double[n];\n+        double c[] = new double[n + 1];\n+        double d[] = new double[n];\n+        \n+        z[n] = 0d;\n+        c[n] = 0d;\n+        \n+        for (int j = n -1; j >=0; j--) {\n+            c[j] = z[j] - mu[j] * c[j + 1];\n+            b[j] = (y[j + 1] - y[j]) / h[j] - h[j] * (c[j + 1] + 2d * c[j]) / 3d;\n+            d[j] = (c[j + 1] - c[j]) / (3d * h[j]);\n+        }\n+        \n+        PolynomialFunction polynomials[] = new PolynomialFunction[n];\n+        double coefficients[] = new double[4];\n+        for (int i = 0; i < n; i++) {\n+            coefficients[0] = y[i];\n+            coefficients[1] = b[i];\n+            coefficients[2] = c[i];\n+            coefficients[3] = d[i];\n+            polynomials[i] = new PolynomialFunction(coefficients);\n+        }\n+        \n+        return new PolynomialSplineFunction(x, polynomials);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/UnivariateRealInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Interface representing a univariate real interpolating function.\n+ *  \n+ * @version $Revision$ $Date$\n+ */\n+public interface UnivariateRealInterpolator {\n+\n+    /**\n+     * Computes an interpolating function for the data set.\n+     * @param xval the arguments for the interpolation points\n+     * @param yval the values for the interpolation points\n+     * @return a function which interpolates the data set\n+     * @throws MathException if arguments violate assumptions made by the\n+     *         interpolationg algorithm\n+     */\n+    public UnivariateRealFunction interpolate(double xval[], double yval[])\n+        throws MathException;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Immutable representation of a real polynomial function with real coefficients.\n+ * <p>\n+ * <a href=\"http://mathworld.wolfram.com/HornersMethod.html\">Horner's Method</a>\n+ *  is used to evaluate the function.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class PolynomialFunction implements DifferentiableUnivariateRealFunction, Serializable {\n+\n+    /**\n+     * Serializtion identifier\n+     */\n+    private static final long serialVersionUID = -7726511984200295583L;\n+    \n+    /**\n+     * The coefficients of the polynomial, ordered by degree -- i.e.,  \n+     * coefficients[0] is the constant term and coefficients[n] is the \n+     * coefficient of x^n where n is the degree of the polynomial.\n+     */\n+    private final double coefficients[];\n+\n+    /**\n+     * Construct a polynomial with the given coefficients.  The first element\n+     * of the coefficients array is the constant term.  Higher degree\n+     * coefficients follow in sequence.  The degree of the resulting polynomial\n+     * is the index of the last non-null element of the array, or 0 if all elements\n+     * are null. \n+     * <p>\n+     * The constructor makes a copy of the input array and assigns the copy to\n+     * the coefficients property.</p>\n+     * \n+     * @param c polynomial coefficients\n+     * @throws NullPointerException if c is null\n+     * @throws IllegalArgumentException if c is empty\n+     */\n+    public PolynomialFunction(double c[]) {\n+        super();\n+        if (c.length < 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"empty polynomials coefficients array\");\n+        }\n+        int l = c.length;\n+        while ((l > 1) && (c[l - 1] == 0)) {\n+            --l;\n+        }\n+        this.coefficients = new double[l];\n+        System.arraycopy(c, 0, this.coefficients, 0, l);\n+    }\n+\n+    /**\n+     * Compute the value of the function for the given argument.\n+     * <p>\n+     *  The value returned is <br>\n+     *   <code>coefficients[n] * x^n + ... + coefficients[1] * x  + coefficients[0]</code>\n+     * </p>\n+     * \n+     * @param x the argument for which the function value should be computed\n+     * @return the value of the polynomial at the given point\n+     * @see UnivariateRealFunction#value(double)\n+     */\n+    public double value(double x) {\n+       return evaluate(coefficients, x);\n+    }\n+\n+\n+    /**\n+     *  Returns the degree of the polynomial\n+     * \n+     * @return the degree of the polynomial\n+     */\n+    public int degree() {\n+        return coefficients.length - 1;\n+    }\n+    \n+    /**\n+     * Returns a copy of the coefficients array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the coefficients of\n+     * the polynomial.</p>\n+     * \n+     * @return  a fresh copy of the coefficients array\n+     */\n+    public double[] getCoefficients() {\n+        return coefficients.clone();\n+    }\n+    \n+    /**\n+     * Uses Horner's Method to evaluate the polynomial with the given coefficients at\n+     * the argument.\n+     * \n+     * @param coefficients  the coefficients of the polynomial to evaluate\n+     * @param argument  the input value\n+     * @return  the value of the polynomial \n+     * @throws IllegalArgumentException if coefficients is empty\n+     * @throws NullPointerException if coefficients is null\n+     */\n+    protected static double evaluate(double[] coefficients, double argument) {\n+        int n = coefficients.length;\n+        if (n < 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"empty polynomials coefficients array\");\n+        }\n+        double result = coefficients[n - 1];\n+        for (int j = n -2; j >=0; j--) {\n+            result = argument * result + coefficients[j];\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Add a polynomial to the instance.\n+     * @param p polynomial to add\n+     * @return a new polynomial which is the sum of the instance and p\n+     */\n+    public PolynomialFunction add(final PolynomialFunction p) {\n+\n+        // identify the lowest degree polynomial\n+        final int lowLength  = Math.min(coefficients.length, p.coefficients.length);\n+        final int highLength = Math.max(coefficients.length, p.coefficients.length);\n+\n+        // build the coefficients array\n+        double[] newCoefficients = new double[highLength];\n+        for (int i = 0; i < lowLength; ++i) {\n+            newCoefficients[i] = coefficients[i] + p.coefficients[i];\n+        }\n+        System.arraycopy((coefficients.length < p.coefficients.length) ?\n+                         p.coefficients : coefficients,\n+                         lowLength,\n+                         newCoefficients, lowLength,\n+                         highLength - lowLength);\n+\n+        return new PolynomialFunction(newCoefficients);\n+\n+    }\n+\n+    /**\n+     * Subtract a polynomial from the instance.\n+     * @param p polynomial to subtract\n+     * @return a new polynomial which is the difference the instance minus p\n+     */\n+    public PolynomialFunction subtract(final PolynomialFunction p) {\n+\n+        // identify the lowest degree polynomial\n+        int lowLength  = Math.min(coefficients.length, p.coefficients.length);\n+        int highLength = Math.max(coefficients.length, p.coefficients.length);\n+\n+        // build the coefficients array\n+        double[] newCoefficients = new double[highLength];\n+        for (int i = 0; i < lowLength; ++i) {\n+            newCoefficients[i] = coefficients[i] - p.coefficients[i];\n+        }\n+        if (coefficients.length < p.coefficients.length) {\n+            for (int i = lowLength; i < highLength; ++i) {\n+                newCoefficients[i] = -p.coefficients[i];\n+            }\n+        } else {\n+            System.arraycopy(coefficients, lowLength, newCoefficients, lowLength,\n+                             highLength - lowLength);\n+        }\n+\n+        return new PolynomialFunction(newCoefficients);\n+\n+    }\n+\n+    /**\n+     * Negate the instance.\n+     * @return a new polynomial\n+     */\n+    public PolynomialFunction negate() {\n+        double[] newCoefficients = new double[coefficients.length];\n+        for (int i = 0; i < coefficients.length; ++i) {\n+            newCoefficients[i] = -coefficients[i];\n+        }\n+        return new PolynomialFunction(newCoefficients);\n+    }\n+\n+    /**\n+     * Multiply the instance by a polynomial.\n+     * @param p polynomial to multiply by\n+     * @return a new polynomial\n+     */\n+    public PolynomialFunction multiply(final PolynomialFunction p) {\n+\n+        double[] newCoefficients = new double[coefficients.length + p.coefficients.length - 1];\n+\n+        for (int i = 0; i < newCoefficients.length; ++i) {\n+            newCoefficients[i] = 0.0;\n+            for (int j = Math.max(0, i + 1 - p.coefficients.length);\n+                 j < Math.min(coefficients.length, i + 1);\n+                 ++j) {\n+                newCoefficients[i] += coefficients[j] * p.coefficients[i-j];\n+            }\n+        }\n+\n+        return new PolynomialFunction(newCoefficients);\n+\n+    }\n+\n+    /**\n+     * Returns the coefficients of the derivative of the polynomial with the given coefficients.\n+     * \n+     * @param coefficients  the coefficients of the polynomial to differentiate\n+     * @return the coefficients of the derivative or null if coefficients has length 1.\n+     * @throws IllegalArgumentException if coefficients is empty\n+     * @throws NullPointerException if coefficients is null\n+     */\n+    protected static double[] differentiate(double[] coefficients) {\n+        int n = coefficients.length;\n+        if (n < 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"empty polynomials coefficients array\");\n+        }\n+        if (n == 1) {\n+            return new double[]{0};\n+        }\n+        double[] result = new double[n - 1];\n+        for (int i = n - 1; i  > 0; i--) {\n+            result[i - 1] = i * coefficients[i];\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Returns the derivative as a PolynomialRealFunction\n+     * \n+     * @return  the derivative polynomial\n+     */\n+    public PolynomialFunction polynomialDerivative() {\n+        return new PolynomialFunction(differentiate(coefficients));\n+    }\n+    \n+    /**\n+     * Returns the derivative as a UnivariateRealFunction\n+     * \n+     * @return  the derivative function\n+     */\n+    public UnivariateRealFunction derivative() {\n+        return polynomialDerivative();\n+    }\n+\n+    /** Returns a string representation of the polynomial.\n+\n+     * <p>The representation is user oriented. Terms are displayed lowest\n+     * degrees first. The multiplications signs, coefficients equals to\n+     * one and null terms are not displayed (except if the polynomial is 0,\n+     * in which case the 0 constant term is displayed). Addition of terms\n+     * with negative coefficients are replaced by subtraction of terms\n+     * with positive coefficients except for the first displayed term\n+     * (i.e. we display <code>-3</code> for a constant negative polynomial,\n+     * but <code>1 - 3 x + x^2</code> if the negative coefficient is not\n+     * the first one displayed).</p>\n+\n+     * @return a string representation of the polynomial\n+\n+     */\n+    @Override\n+     public String toString() {\n+\n+       StringBuffer s = new StringBuffer();\n+       if (coefficients[0] == 0.0) {\n+         if (coefficients.length == 1) {\n+           return \"0\";\n+         }\n+       } else {\n+         s.append(Double.toString(coefficients[0]));\n+       }\n+\n+       for (int i = 1; i < coefficients.length; ++i) {\n+\n+         if (coefficients[i] != 0) {\n+\n+           if (s.length() > 0) {\n+             if (coefficients[i] < 0) {\n+               s.append(\" - \");\n+             } else {\n+               s.append(\" + \");\n+             }\n+           } else {\n+             if (coefficients[i] < 0) {\n+               s.append(\"-\");\n+             }\n+           }\n+\n+           double absAi = Math.abs(coefficients[i]);\n+           if ((absAi - 1) != 0) {\n+             s.append(Double.toString(absAi));\n+             s.append(' ');\n+           }\n+\n+           s.append(\"x\");\n+           if (i > 1) {\n+             s.append('^');\n+             s.append(Integer.toString(i));\n+           }\n+         }\n+\n+       }\n+\n+       return s.toString();\n+\n+     }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + Arrays.hashCode(coefficients);\n+        return result;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (!(obj instanceof PolynomialFunction))\n+            return false;\n+        PolynomialFunction other = (PolynomialFunction) obj;\n+        if (!Arrays.equals(coefficients, other.coefficients))\n+            return false;\n+        return true;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeForm.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+import org.apache.commons.math.DuplicateSampleAbscissaException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Implements the representation of a real polynomial function in\n+ * <a href=\"http://mathworld.wolfram.com/LagrangeInterpolatingPolynomial.html\">\n+ * Lagrange Form</a>. For reference, see <b>Introduction to Numerical\n+ * Analysis</b>, ISBN 038795452X, chapter 2.\n+ * <p>\n+ * The approximated function should be smooth enough for Lagrange polynomial\n+ * to work well. Otherwise, consider using splines instead.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class PolynomialFunctionLagrangeForm implements UnivariateRealFunction {\n+\n+    /**\n+     * The coefficients of the polynomial, ordered by degree -- i.e.\n+     * coefficients[0] is the constant term and coefficients[n] is the \n+     * coefficient of x^n where n is the degree of the polynomial.\n+     */\n+    private double coefficients[];\n+\n+    /**\n+     * Interpolating points (abscissas) and the function values at these points.\n+     */\n+    private double x[], y[];\n+\n+    /**\n+     * Whether the polynomial coefficients are available.\n+     */\n+    private boolean coefficientsComputed;\n+\n+    /**\n+     * Construct a Lagrange polynomial with the given abscissas and function\n+     * values. The order of interpolating points are not important.\n+     * <p>\n+     * The constructor makes copy of the input arrays and assigns them.</p>\n+     * \n+     * @param x interpolating points\n+     * @param y function values at interpolating points\n+     * @throws IllegalArgumentException if input arrays are not valid\n+     */\n+    public PolynomialFunctionLagrangeForm(double x[], double y[])\n+        throws IllegalArgumentException {\n+\n+        verifyInterpolationArray(x, y);\n+        this.x = new double[x.length];\n+        this.y = new double[y.length];\n+        System.arraycopy(x, 0, this.x, 0, x.length);\n+        System.arraycopy(y, 0, this.y, 0, y.length);\n+        coefficientsComputed = false;\n+    }\n+\n+    /**\n+     * Calculate the function value at the given point.\n+     *\n+     * @param z the point at which the function value is to be computed\n+     * @return the function value\n+     * @throws FunctionEvaluationException if a runtime error occurs\n+     * @see UnivariateRealFunction#value(double)\n+     */\n+    public double value(double z) throws FunctionEvaluationException {\n+        try {\n+            return evaluate(x, y, z);\n+        } catch (DuplicateSampleAbscissaException e) {\n+            throw new FunctionEvaluationException(e, z, e.getPattern(), e.getArguments());\n+        }\n+    }\n+\n+    /**\n+     * Returns the degree of the polynomial.\n+     * \n+     * @return the degree of the polynomial\n+     */\n+    public int degree() {\n+        return x.length - 1;\n+    }\n+\n+    /**\n+     * Returns a copy of the interpolating points array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.</p>\n+     * \n+     * @return a fresh copy of the interpolating points array\n+     */\n+    public double[] getInterpolatingPoints() {\n+        double[] out = new double[x.length];\n+        System.arraycopy(x, 0, out, 0, x.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Returns a copy of the interpolating values array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.</p>\n+     * \n+     * @return a fresh copy of the interpolating values array\n+     */\n+    public double[] getInterpolatingValues() {\n+        double[] out = new double[y.length];\n+        System.arraycopy(y, 0, out, 0, y.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Returns a copy of the coefficients array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.</p>\n+     * \n+     * @return a fresh copy of the coefficients array\n+     */\n+    public double[] getCoefficients() {\n+        if (!coefficientsComputed) {\n+            computeCoefficients();\n+        }\n+        double[] out = new double[coefficients.length];\n+        System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Evaluate the Lagrange polynomial using \n+     * <a href=\"http://mathworld.wolfram.com/NevillesAlgorithm.html\">\n+     * Neville's Algorithm</a>. It takes O(N^2) time.\n+     * <p>\n+     * This function is made public static so that users can call it directly\n+     * without instantiating PolynomialFunctionLagrangeForm object.</p>\n+     *\n+     * @param x the interpolating points array\n+     * @param y the interpolating values array\n+     * @param z the point at which the function value is to be computed\n+     * @return the function value\n+     * @throws DuplicateSampleAbscissaException if the sample has duplicate abscissas\n+     * @throws IllegalArgumentException if inputs are not valid\n+     */\n+    public static double evaluate(double x[], double y[], double z) throws\n+        DuplicateSampleAbscissaException, IllegalArgumentException {\n+\n+        int i, j, n, nearest = 0;\n+        double value, c[], d[], tc, td, divider, w, dist, min_dist;\n+\n+        verifyInterpolationArray(x, y);\n+\n+        n = x.length;\n+        c = new double[n];\n+        d = new double[n];\n+        min_dist = Double.POSITIVE_INFINITY;\n+        for (i = 0; i < n; i++) {\n+            // initialize the difference arrays\n+            c[i] = y[i];\n+            d[i] = y[i];\n+            // find out the abscissa closest to z\n+            dist = Math.abs(z - x[i]);\n+            if (dist < min_dist) {\n+                nearest = i;\n+                min_dist = dist;\n+            }\n+        }\n+\n+        // initial approximation to the function value at z\n+        value = y[nearest];\n+\n+        for (i = 1; i < n; i++) {\n+            for (j = 0; j < n-i; j++) {\n+                tc = x[j] - z;\n+                td = x[i+j] - z;\n+                divider = x[j] - x[i+j];\n+                if (divider == 0.0) {\n+                    // This happens only when two abscissas are identical.\n+                    throw new DuplicateSampleAbscissaException(x[i], i, i+j);\n+                }\n+                // update the difference arrays\n+                w = (c[j+1] - d[j]) / divider;\n+                c[j] = tc * w;\n+                d[j] = td * w;\n+            }\n+            // sum up the difference terms to get the final value\n+            if (nearest < 0.5*(n-i+1)) {\n+                value += c[nearest];    // fork down\n+            } else {\n+                nearest--;\n+                value += d[nearest];    // fork up\n+            }\n+        }\n+\n+        return value;\n+    }\n+\n+    /**\n+     * Calculate the coefficients of Lagrange polynomial from the\n+     * interpolation data. It takes O(N^2) time.\n+     * <p>\n+     * Note this computation can be ill-conditioned. Use with caution\n+     * and only when it is necessary.</p>\n+     *\n+     * @throws ArithmeticException if any abscissas coincide\n+     */\n+    protected void computeCoefficients() throws ArithmeticException {\n+        int i, j, n;\n+        double c[], tc[], d, t;\n+\n+        n = degree() + 1;\n+        coefficients = new double[n];\n+        for (i = 0; i < n; i++) {\n+            coefficients[i] = 0.0;\n+        }\n+\n+        // c[] are the coefficients of P(x) = (x-x[0])(x-x[1])...(x-x[n-1])\n+        c = new double[n+1];\n+        c[0] = 1.0;\n+        for (i = 0; i < n; i++) {\n+            for (j = i; j > 0; j--) {\n+                c[j] = c[j-1] - c[j] * x[i];\n+            }\n+            c[0] *= (-x[i]);\n+            c[i+1] = 1;\n+        }\n+\n+        tc = new double[n];\n+        for (i = 0; i < n; i++) {\n+            // d = (x[i]-x[0])...(x[i]-x[i-1])(x[i]-x[i+1])...(x[i]-x[n-1])\n+            d = 1;\n+            for (j = 0; j < n; j++) {\n+                if (i != j) {\n+                    d *= (x[i] - x[j]);\n+                }\n+            }\n+            if (d == 0.0) {\n+                // This happens only when two abscissas are identical.\n+                for (int k = 0; k < n; ++k) {\n+                    if ((i != k) && (x[i] == x[k])) {\n+                        throw MathRuntimeException.createArithmeticException(\"identical abscissas x[{0}] == x[{1}] == {2} cause division by zero\",\n+                                                                             i, k, x[i]);\n+                    }\n+                }\n+            }\n+            t = y[i] / d;\n+            // Lagrange polynomial is the sum of n terms, each of which is a\n+            // polynomial of degree n-1. tc[] are the coefficients of the i-th\n+            // numerator Pi(x) = (x-x[0])...(x-x[i-1])(x-x[i+1])...(x-x[n-1]).\n+            tc[n-1] = c[n];     // actually c[n] = 1\n+            coefficients[n-1] += t * tc[n-1];\n+            for (j = n-2; j >= 0; j--) {\n+                tc[j] = c[j+1] + tc[j+1] * x[i];\n+                coefficients[j] += t * tc[j];\n+            }\n+        }\n+\n+        coefficientsComputed = true;\n+    }\n+\n+    /**\n+     * Verifies that the interpolation arrays are valid.\n+     * <p>\n+     * The interpolating points must be distinct. However it is not\n+     * verified here, it is checked in evaluate() and computeCoefficients().</p>\n+     * \n+     * @param x the interpolating points array\n+     * @param y the interpolating values array\n+     * @throws IllegalArgumentException if not valid\n+     * @see #evaluate(double[], double[], double)\n+     * @see #computeCoefficients()\n+     */\n+    public static void verifyInterpolationArray(double x[], double y[]) throws\n+        IllegalArgumentException {\n+\n+        if (Math.min(x.length, y.length) < 2) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} points are required, got only {1}\",\n+                  2, Math.min(x.length, y.length));\n+        }\n+        if (x.length != y.length) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"dimension mismatch {0} != {1}\", x.length, y.length);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonForm.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.interpolation.DividedDifferenceInterpolator;\n+\n+/**\n+ * Implements the representation of a real polynomial function in\n+ * Newton Form. For reference, see <b>Elementary Numerical Analysis</b>,\n+ * ISBN 0070124477, chapter 2.\n+ * <p>\n+ * The formula of polynomial in Newton form is\n+ *     p(x) = a[0] + a[1](x-c[0]) + a[2](x-c[0])(x-c[1]) + ... +\n+ *            a[n](x-c[0])(x-c[1])...(x-c[n-1])\n+ * Note that the length of a[] is one more than the length of c[]</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class PolynomialFunctionNewtonForm implements UnivariateRealFunction {\n+\n+    /**\n+     * The coefficients of the polynomial, ordered by degree -- i.e.\n+     * coefficients[0] is the constant term and coefficients[n] is the \n+     * coefficient of x^n where n is the degree of the polynomial.\n+     */\n+    private double coefficients[];\n+\n+    /**\n+     * Members of c[] are called centers of the Newton polynomial.\n+     * When all c[i] = 0, a[] becomes normal polynomial coefficients,\n+     * i.e. a[i] = coefficients[i].\n+     */\n+    private double a[], c[];\n+\n+    /**\n+     * Whether the polynomial coefficients are available.\n+     */\n+    private boolean coefficientsComputed;\n+\n+    /**\n+     * Construct a Newton polynomial with the given a[] and c[]. The order of\n+     * centers are important in that if c[] shuffle, then values of a[] would\n+     * completely change, not just a permutation of old a[].\n+     * <p>\n+     * The constructor makes copy of the input arrays and assigns them.</p>\n+     * \n+     * @param a the coefficients in Newton form formula\n+     * @param c the centers\n+     * @throws IllegalArgumentException if input arrays are not valid\n+     */\n+    public PolynomialFunctionNewtonForm(double a[], double c[])\n+        throws IllegalArgumentException {\n+\n+        verifyInputArray(a, c);\n+        this.a = new double[a.length];\n+        this.c = new double[c.length];\n+        System.arraycopy(a, 0, this.a, 0, a.length);\n+        System.arraycopy(c, 0, this.c, 0, c.length);\n+        coefficientsComputed = false;\n+    }\n+\n+    /**\n+     * Calculate the function value at the given point.\n+     *\n+     * @param z the point at which the function value is to be computed\n+     * @return the function value\n+     * @throws FunctionEvaluationException if a runtime error occurs\n+     * @see UnivariateRealFunction#value(double)\n+     */\n+    public double value(double z) throws FunctionEvaluationException {\n+       return evaluate(a, c, z);\n+    }\n+\n+    /**\n+     * Returns the degree of the polynomial.\n+     * \n+     * @return the degree of the polynomial\n+     */\n+    public int degree() {\n+        return c.length;\n+    }\n+\n+    /**\n+     * Returns a copy of coefficients in Newton form formula.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.</p>\n+     * \n+     * @return a fresh copy of coefficients in Newton form formula\n+     */\n+    public double[] getNewtonCoefficients() {\n+        double[] out = new double[a.length];\n+        System.arraycopy(a, 0, out, 0, a.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Returns a copy of the centers array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.</p>\n+     * \n+     * @return a fresh copy of the centers array\n+     */\n+    public double[] getCenters() {\n+        double[] out = new double[c.length];\n+        System.arraycopy(c, 0, out, 0, c.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Returns a copy of the coefficients array.\n+     * <p>\n+     * Changes made to the returned copy will not affect the polynomial.</p>\n+     * \n+     * @return a fresh copy of the coefficients array\n+     */\n+    public double[] getCoefficients() {\n+        if (!coefficientsComputed) {\n+            computeCoefficients();\n+        }\n+        double[] out = new double[coefficients.length];\n+        System.arraycopy(coefficients, 0, out, 0, coefficients.length);\n+        return out;\n+    }\n+\n+    /**\n+     * Evaluate the Newton polynomial using nested multiplication. It is\n+     * also called <a href=\"http://mathworld.wolfram.com/HornersRule.html\">\n+     * Horner's Rule</a> and takes O(N) time.\n+     *\n+     * @param a the coefficients in Newton form formula\n+     * @param c the centers\n+     * @param z the point at which the function value is to be computed\n+     * @return the function value\n+     * @throws FunctionEvaluationException if a runtime error occurs\n+     * @throws IllegalArgumentException if inputs are not valid\n+     */\n+    public static double evaluate(double a[], double c[], double z) throws\n+        FunctionEvaluationException, IllegalArgumentException {\n+\n+        verifyInputArray(a, c);\n+\n+        int n = c.length;\n+        double value = a[n];\n+        for (int i = n-1; i >= 0; i--) {\n+            value = a[i] + (z - c[i]) * value;\n+        }\n+\n+        return value;\n+    }\n+\n+    /**\n+     * Calculate the normal polynomial coefficients given the Newton form.\n+     * It also uses nested multiplication but takes O(N^2) time.\n+     */\n+    protected void computeCoefficients() {\n+        int i, j, n = degree();\n+\n+        coefficients = new double[n+1];\n+        for (i = 0; i <= n; i++) {\n+            coefficients[i] = 0.0;\n+        }\n+\n+        coefficients[0] = a[n];\n+        for (i = n-1; i >= 0; i--) {\n+            for (j = n-i; j > 0; j--) {\n+                coefficients[j] = coefficients[j-1] - c[i] * coefficients[j];\n+            }\n+            coefficients[0] = a[i] - c[i] * coefficients[0];\n+        }\n+\n+        coefficientsComputed = true;\n+    }\n+\n+    /**\n+     * Verifies that the input arrays are valid.\n+     * <p>\n+     * The centers must be distinct for interpolation purposes, but not\n+     * for general use. Thus it is not verified here.</p>\n+     * \n+     * @param a the coefficients in Newton form formula\n+     * @param c the centers\n+     * @throws IllegalArgumentException if not valid\n+     * @see DividedDifferenceInterpolator#computeDividedDifference(double[],\n+     * double[])\n+     */\n+    protected static void verifyInputArray(double a[], double c[]) throws\n+        IllegalArgumentException {\n+\n+        if (a.length < 1 || c.length < 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"empty polynomials coefficients array\");\n+        }\n+        if (a.length != c.length + 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"array sizes should have difference 1 ({0} != {1} + 1)\",\n+                  a.length, c.length);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.ArgumentOutsideDomainException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Represents a polynomial spline function.\n+ * <p>\n+ * A <strong>polynomial spline function</strong> consists of a set of \n+ * <i>interpolating polynomials</i> and an ascending array of domain \n+ * <i>knot points</i>, determining the intervals over which the spline function\n+ * is defined by the constituent polynomials.  The polynomials are assumed to\n+ * have been computed to match the values of another function at the knot\n+ * points.  The value consistency constraints are not currently enforced by \n+ * <code>PolynomialSplineFunction</code> itself, but are assumed to hold among\n+ * the polynomials and knot points passed to the constructor.</p>\n+ * <p>\n+ * N.B.:  The polynomials in the <code>polynomials</code> property must be\n+ * centered on the knot points to compute the spline function values.  \n+ * See below.</p>\n+ * <p>\n+ * The domain of the polynomial spline function is \n+ * <code>[smallest knot, largest knot]</code>.  Attempts to evaluate the\n+ * function at values outside of this range generate IllegalArgumentExceptions.\n+ * </p>\n+ * <p>\n+ * The value of the polynomial spline function for an argument <code>x</code>\n+ * is computed as follows:\n+ * <ol>\n+ * <li>The knot array is searched to find the segment to which <code>x</code>\n+ * belongs.  If <code>x</code> is less than the smallest knot point or greater\n+ * than the largest one, an <code>IllegalArgumentException</code>\n+ * is thrown.</li>\n+ * <li> Let <code>j</code> be the index of the largest knot point that is less\n+ * than or equal to <code>x</code>.  The value returned is <br>\n+ * <code>polynomials[j](x - knot[j])</code></li></ol></p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class PolynomialSplineFunction \n+    implements DifferentiableUnivariateRealFunction {\n+\n+    /** Spline segment interval delimiters (knots).   Size is n+1 for n segments. */\n+    private double knots[];\n+\n+    /**\n+     * The polynomial functions that make up the spline.  The first element\n+     * determines the value of the spline over the first subinterval, the\n+     * second over the second, etc.   Spline function values are determined by\n+     * evaluating these functions at <code>(x - knot[i])</code> where i is the\n+     * knot segment to which x belongs.\n+     */\n+    private PolynomialFunction polynomials[] = null;\n+    \n+    /** \n+     * Number of spline segments = number of polynomials\n+     *  = number of partition points - 1 \n+     */\n+    private int n = 0;\n+    \n+\n+    /**\n+     * Construct a polynomial spline function with the given segment delimiters\n+     * and interpolating polynomials.\n+     * <p>\n+     * The constructor copies both arrays and assigns the copies to the knots\n+     * and polynomials properties, respectively.</p>\n+     * \n+     * @param knots spline segment interval delimiters\n+     * @param polynomials polynomial functions that make up the spline\n+     * @throws NullPointerException if either of the input arrays is null\n+     * @throws IllegalArgumentException if knots has length less than 2,  \n+     * <code>polynomials.length != knots.length - 1 </code>, or the knots array\n+     * is not strictly increasing.\n+     * \n+     */\n+    public PolynomialSplineFunction(double knots[], PolynomialFunction polynomials[]) {\n+        if (knots.length < 2) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"spline partition must have at least {0} points, got {1}\",\n+                  2, knots.length);\n+        }\n+        if (knots.length - 1 != polynomials.length) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"number of polynomial interpolants must match the number of segments ({0} != {1} - 1)\",\n+                  polynomials.length, knots.length);\n+        }\n+        if (!isStrictlyIncreasing(knots)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"knot values must be strictly increasing\");\n+        }\n+        \n+        this.n = knots.length -1;\n+        this.knots = new double[n + 1];\n+        System.arraycopy(knots, 0, this.knots, 0, n + 1);\n+        this.polynomials = new PolynomialFunction[n];\n+        System.arraycopy(polynomials, 0, this.polynomials, 0, n);\n+    }\n+\n+    /**\n+     * Compute the value for the function.\n+     * <p>\n+     * Throws FunctionEvaluationException if v is outside of the domain of the\n+     * function.  The domain is [smallest knot, largest knot].</p>\n+     * <p>\n+     * See {@link PolynomialSplineFunction} for details on the algorithm for\n+     * computing the value of the function.</p>\n+     * \n+     * @param v the point for which the function value should be computed\n+     * @return the value\n+     * @throws ArgumentOutsideDomainException if v is outside of the domain of\n+     * of the spline function (less than the smallest knot point or greater\n+     * than the largest knot point)\n+     */\n+    public double value(double v) throws ArgumentOutsideDomainException {\n+        if (v < knots[0] || v > knots[n]) {\n+            throw new ArgumentOutsideDomainException(v, knots[0], knots[n]);\n+        }\n+        int i = Arrays.binarySearch(knots, v);\n+        if (i < 0) {\n+            i = -i - 2;\n+        }\n+        //This will handle the case where v is the last knot value\n+        //There are only n-1 polynomials, so if v is the last knot\n+        //then we will use the last polynomial to calculate the value.\n+        if ( i >= polynomials.length ) {\n+            i--;\n+        }\n+        return polynomials[i].value(v - knots[i]);\n+    }\n+    \n+    /**\n+     * Returns the derivative of the polynomial spline function as a UnivariateRealFunction\n+     * @return  the derivative function\n+     */\n+    public UnivariateRealFunction derivative() {\n+        return polynomialSplineDerivative();\n+    }\n+    \n+    /**\n+     * Returns the derivative of the polynomial spline function as a PolynomialSplineFunction\n+     * \n+     * @return  the derivative function\n+     */\n+    public PolynomialSplineFunction polynomialSplineDerivative() {\n+        PolynomialFunction derivativePolynomials[] = new PolynomialFunction[n];\n+        for (int i = 0; i < n; i++) {\n+            derivativePolynomials[i] = polynomials[i].polynomialDerivative();\n+        }\n+        return new PolynomialSplineFunction(knots, derivativePolynomials);\n+    }\n+\n+    /**\n+     * Returns the number of spline segments = the number of polynomials \n+     * = the number of knot points - 1.\n+     * \n+     * @return the number of spline segments\n+     */\n+    public int getN() {\n+        return n;\n+    }\n+\n+    /**\n+     * Returns a copy of the interpolating polynomials array.\n+     * <p>\n+     * Returns a fresh copy of the array. Changes made to the copy will\n+     * not affect the polynomials property.</p>\n+     * \n+     * @return the interpolating polynomials\n+     */\n+    public PolynomialFunction[] getPolynomials() {\n+        PolynomialFunction p[] = new PolynomialFunction[n];\n+        System.arraycopy(polynomials, 0, p, 0, n);\n+        return p;\n+    }\n+\n+    /**\n+     * Returns an array copy of the knot points.\n+     * <p>\n+     * Returns a fresh copy of the array. Changes made to the copy\n+     * will not affect the knots property.</p>\n+     * \n+     * @return the knot points\n+     */\n+    public double[] getKnots() {\n+        double out[] = new double[n + 1];\n+        System.arraycopy(knots, 0, out, 0, n + 1);\n+        return out;  \n+    }\n+\n+    /**\n+     * Determines if the given array is ordered in a strictly increasing\n+     * fashion.\n+     * \n+     * @param x the array to examine.\n+     * @return <code>true</code> if the elements in <code>x</code> are ordered\n+     * in a stricly increasing manner.  <code>false</code>, otherwise.\n+     */\n+    private static boolean isStrictlyIncreasing(double[] x) {\n+        for (int i = 1; i < x.length; ++i) {\n+            if (x[i - 1] >= x[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/polynomials/PolynomialsUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+import java.util.ArrayList;\n+\n+import org.apache.commons.math.fraction.BigFraction;\n+\n+/**\n+ * A collection of static methods that operate on or return polynomials.\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class PolynomialsUtils {\n+\n+    /** Coefficients for Chebyshev polynomials. */\n+    private static final ArrayList<BigFraction> CHEBYSHEV_COEFFICIENTS;\n+\n+    /** Coefficients for Hermite polynomials. */\n+    private static final ArrayList<BigFraction> HERMITE_COEFFICIENTS;\n+\n+    /** Coefficients for Laguerre polynomials. */\n+    private static final ArrayList<BigFraction> LAGUERRE_COEFFICIENTS;\n+\n+    /** Coefficients for Legendre polynomials. */\n+    private static final ArrayList<BigFraction> LEGENDRE_COEFFICIENTS;\n+\n+    static {\n+\n+        // initialize recurrence for Chebyshev polynomials\n+        // T0(X) = 1, T1(X) = 0 + 1 * X\n+        CHEBYSHEV_COEFFICIENTS = new ArrayList<BigFraction>();\n+        CHEBYSHEV_COEFFICIENTS.add(BigFraction.ONE);\n+        CHEBYSHEV_COEFFICIENTS.add(BigFraction.ZERO);\n+        CHEBYSHEV_COEFFICIENTS.add(BigFraction.ONE);\n+\n+        // initialize recurrence for Hermite polynomials\n+        // H0(X) = 1, H1(X) = 0 + 2 * X\n+        HERMITE_COEFFICIENTS = new ArrayList<BigFraction>();\n+        HERMITE_COEFFICIENTS.add(BigFraction.ONE);\n+        HERMITE_COEFFICIENTS.add(BigFraction.ZERO);\n+        HERMITE_COEFFICIENTS.add(BigFraction.TWO);\n+\n+        // initialize recurrence for Laguerre polynomials\n+        // L0(X) = 1, L1(X) = 1 - 1 * X\n+        LAGUERRE_COEFFICIENTS = new ArrayList<BigFraction>();\n+        LAGUERRE_COEFFICIENTS.add(BigFraction.ONE);\n+        LAGUERRE_COEFFICIENTS.add(BigFraction.ONE);\n+        LAGUERRE_COEFFICIENTS.add(BigFraction.MINUS_ONE);\n+\n+        // initialize recurrence for Legendre polynomials\n+        // P0(X) = 1, P1(X) = 0 + 1 * X\n+        LEGENDRE_COEFFICIENTS = new ArrayList<BigFraction>();\n+        LEGENDRE_COEFFICIENTS.add(BigFraction.ONE);\n+        LEGENDRE_COEFFICIENTS.add(BigFraction.ZERO);\n+        LEGENDRE_COEFFICIENTS.add(BigFraction.ONE);\n+\n+    }\n+\n+    /**\n+     * Private constructor, to prevent instantiation.\n+     */\n+    private PolynomialsUtils() {\n+    }\n+\n+    /**\n+     * Create a Chebyshev polynomial of the first kind.\n+     * <p><a href=\"http://mathworld.wolfram.com/ChebyshevPolynomialoftheFirstKind.html\">Chebyshev\n+     * polynomials of the first kind</a> are orthogonal polynomials.\n+     * They can be defined by the following recurrence relations:\n+     * <pre>\n+     *  T<sub>0</sub>(X)   = 1\n+     *  T<sub>1</sub>(X)   = X\n+     *  T<sub>k+1</sub>(X) = 2X T<sub>k</sub>(X) - T<sub>k-1</sub>(X)\n+     * </pre></p>\n+     * @param degree degree of the polynomial\n+     * @return Chebyshev polynomial of specified degree\n+     */\n+    public static PolynomialFunction createChebyshevPolynomial(final int degree) {\n+        return buildPolynomial(degree, CHEBYSHEV_COEFFICIENTS,\n+                new RecurrenceCoefficientsGenerator() {\n+            private final BigFraction[] coeffs = { BigFraction.ZERO, BigFraction.TWO, BigFraction.ONE };\n+            /** {@inheritDoc} */\n+            public BigFraction[] generate(int k) {\n+                return coeffs;\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Create a Hermite polynomial.\n+     * <p><a href=\"http://mathworld.wolfram.com/HermitePolynomial.html\">Hermite\n+     * polynomials</a> are orthogonal polynomials.\n+     * They can be defined by the following recurrence relations:\n+     * <pre>\n+     *  H<sub>0</sub>(X)   = 1\n+     *  H<sub>1</sub>(X)   = 2X\n+     *  H<sub>k+1</sub>(X) = 2X H<sub>k</sub>(X) - 2k H<sub>k-1</sub>(X)\n+     * </pre></p>\n+\n+     * @param degree degree of the polynomial\n+     * @return Hermite polynomial of specified degree\n+     */\n+    public static PolynomialFunction createHermitePolynomial(final int degree) {\n+        return buildPolynomial(degree, HERMITE_COEFFICIENTS,\n+                new RecurrenceCoefficientsGenerator() {\n+            /** {@inheritDoc} */\n+            public BigFraction[] generate(int k) {\n+                return new BigFraction[] {\n+                        BigFraction.ZERO,\n+                        BigFraction.TWO,\n+                        new BigFraction(2 * k)};\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Create a Laguerre polynomial.\n+     * <p><a href=\"http://mathworld.wolfram.com/LaguerrePolynomial.html\">Laguerre\n+     * polynomials</a> are orthogonal polynomials.\n+     * They can be defined by the following recurrence relations:\n+     * <pre>\n+     *        L<sub>0</sub>(X)   = 1\n+     *        L<sub>1</sub>(X)   = 1 - X\n+     *  (k+1) L<sub>k+1</sub>(X) = (2k + 1 - X) L<sub>k</sub>(X) - k L<sub>k-1</sub>(X)\n+     * </pre></p>\n+     * @param degree degree of the polynomial\n+     * @return Laguerre polynomial of specified degree\n+     */\n+    public static PolynomialFunction createLaguerrePolynomial(final int degree) {\n+        return buildPolynomial(degree, LAGUERRE_COEFFICIENTS,\n+                new RecurrenceCoefficientsGenerator() {\n+            /** {@inheritDoc} */\n+            public BigFraction[] generate(int k) {\n+                final int kP1 = k + 1;\n+                return new BigFraction[] {\n+                        new BigFraction(2 * k + 1, kP1),\n+                        new BigFraction(-1, kP1),\n+                        new BigFraction(k, kP1)};\n+            }\n+        });\n+    }\n+\n+    /**\n+     * Create a Legendre polynomial.\n+     * <p><a href=\"http://mathworld.wolfram.com/LegendrePolynomial.html\">Legendre\n+     * polynomials</a> are orthogonal polynomials.\n+     * They can be defined by the following recurrence relations:\n+     * <pre>\n+     *        P<sub>0</sub>(X)   = 1\n+     *        P<sub>1</sub>(X)   = X\n+     *  (k+1) P<sub>k+1</sub>(X) = (2k+1) X P<sub>k</sub>(X) - k P<sub>k-1</sub>(X)\n+     * </pre></p>\n+     * @param degree degree of the polynomial\n+     * @return Legendre polynomial of specified degree\n+     */\n+    public static PolynomialFunction createLegendrePolynomial(final int degree) {\n+        return buildPolynomial(degree, LEGENDRE_COEFFICIENTS,\n+                               new RecurrenceCoefficientsGenerator() {\n+            /** {@inheritDoc} */\n+            public BigFraction[] generate(int k) {\n+                final int kP1 = k + 1;\n+                return new BigFraction[] {\n+                        BigFraction.ZERO,\n+                        new BigFraction(k + kP1, kP1),\n+                        new BigFraction(k, kP1)};\n+            }\n+        });\n+    }\n+\n+    /** Get the coefficients array for a given degree.\n+     * @param degree degree of the polynomial\n+     * @param coefficients list where the computed coefficients are stored\n+     * @param generator recurrence coefficients generator\n+     * @return coefficients array\n+     */\n+    private static PolynomialFunction buildPolynomial(final int degree,\n+                                                      final ArrayList<BigFraction> coefficients,\n+                                                      final RecurrenceCoefficientsGenerator generator) {\n+\n+        final int maxDegree = (int) Math.floor(Math.sqrt(2 * coefficients.size())) - 1;\n+        synchronized (PolynomialsUtils.class) {\n+            if (degree > maxDegree) {\n+                computeUpToDegree(degree, maxDegree, generator, coefficients);\n+            }\n+        }\n+\n+        // coefficient  for polynomial 0 is  l [0]\n+        // coefficients for polynomial 1 are l [1] ... l [2] (degrees 0 ... 1)\n+        // coefficients for polynomial 2 are l [3] ... l [5] (degrees 0 ... 2)\n+        // coefficients for polynomial 3 are l [6] ... l [9] (degrees 0 ... 3)\n+        // coefficients for polynomial 4 are l[10] ... l[14] (degrees 0 ... 4)\n+        // coefficients for polynomial 5 are l[15] ... l[20] (degrees 0 ... 5)\n+        // coefficients for polynomial 6 are l[21] ... l[27] (degrees 0 ... 6)\n+        // ...\n+        final int start = degree * (degree + 1) / 2;\n+\n+        final double[] a = new double[degree + 1];\n+        for (int i = 0; i <= degree; ++i) {\n+            a[i] = coefficients.get(start + i).doubleValue();\n+        }\n+\n+        // build the polynomial\n+        return new PolynomialFunction(a);\n+\n+    }\n+    \n+    /** Compute polynomial coefficients up to a given degree.\n+     * @param degree maximal degree\n+     * @param maxDegree current maximal degree\n+     * @param generator recurrence coefficients generator\n+     * @param coefficients list where the computed coefficients should be appended\n+     */\n+    private static void computeUpToDegree(final int degree, final int maxDegree,\n+                                          final RecurrenceCoefficientsGenerator generator,\n+                                          final ArrayList<BigFraction> coefficients) {\n+\n+        int startK = (maxDegree - 1) * maxDegree / 2;\n+        for (int k = maxDegree; k < degree; ++k) {\n+\n+            // start indices of two previous polynomials Pk(X) and Pk-1(X)\n+            int startKm1 = startK;\n+            startK += k;\n+\n+            // Pk+1(X) = (a[0] + a[1] X) Pk(X) - a[2] Pk-1(X)\n+            BigFraction[] ai = generator.generate(k);\n+\n+            BigFraction ck     = coefficients.get(startK);\n+            BigFraction ckm1   = coefficients.get(startKm1);\n+\n+            // degree 0 coefficient\n+            coefficients.add(ck.multiply(ai[0]).subtract(ckm1.multiply(ai[2])));\n+\n+            // degree 1 to degree k-1 coefficients\n+            for (int i = 1; i < k; ++i) {\n+                final BigFraction ckPrev = ck;\n+                ck     = coefficients.get(startK + i);\n+                ckm1   = coefficients.get(startKm1 + i);\n+                coefficients.add(ck.multiply(ai[0]).add(ckPrev.multiply(ai[1])).subtract(ckm1.multiply(ai[2])));\n+            }\n+\n+            // degree k coefficient\n+            final BigFraction ckPrev = ck;\n+            ck = coefficients.get(startK + k);\n+            coefficients.add(ck.multiply(ai[0]).add(ckPrev.multiply(ai[1])));\n+\n+            // degree k+1 coefficient\n+            coefficients.add(ck.multiply(ai[1]));\n+\n+        }\n+\n+    }\n+\n+    /** Interface for recurrence coefficients generation. */\n+    private static interface RecurrenceCoefficientsGenerator {\n+        /**\n+         * Generate recurrence coefficients.\n+         * @param k highest degree of the polynomials used in the recurrence\n+         * @return an array of three coefficients such that\n+         * P<sub>k+1</sub>(X) = (a[0] + a[1] X) P<sub>k</sub>(X) - a[2] P<sub>k-1</sub>(X)\n+         */\n+        BigFraction[] generate(int k);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/Bisection.html\">\n+ * bisection algorithm</a> for finding zeros of univariate real functions. \n+ * <p>\n+ * The function should be continuous but not necessarily smooth.</p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class BisectionSolver extends UnivariateRealSolverImpl {\n+    \n+    /**\n+     * Construct a solver for the given function.\n+     * \n+     * @param f function to solve.\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n+    public BisectionSolver(UnivariateRealFunction f) {\n+        super(f, 100, 1E-6);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     * \n+     */\n+    public BisectionSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(double min, double max, double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(double min, double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve(min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double solve(final UnivariateRealFunction f, double min, double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+            \n+        clearResult();\n+        verifyInterval(min,max);\n+        double m;\n+        double fm;\n+        double fmin;\n+        \n+        int i = 0;\n+        while (i < maximalIterationCount) {\n+            m = UnivariateRealSolverUtils.midpoint(min, max);\n+           fmin = f.value(min);\n+           fm = f.value(m);\n+\n+            if (fm * fmin > 0.0) {\n+                // max and m bracket the root.\n+                min = m;\n+            } else {\n+                // min and m bracket the root.\n+                max = m;\n+            }\n+\n+            if (Math.abs(max - min) <= absoluteAccuracy) {\n+                m = UnivariateRealSolverUtils.midpoint(min, max);\n+                setResult(m, i);\n+                return m;\n+            }\n+            ++i;\n+        }\n+        \n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/BrentsMethod.html\">\n+ * Brent algorithm</a> for  finding zeros of real univariate functions.\n+ * <p>\n+ * The function should be continuous but not necessarily smooth.</p>\n+ *  \n+ * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $\n+ */\n+public class BrentSolver extends UnivariateRealSolverImpl {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 7694577816772532779L;\n+\n+    /**\n+     * Construct a solver for the given function.\n+     * \n+     * @param f function to solve.\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n+    public BrentSolver(UnivariateRealFunction f) {\n+        super(f, 100, 1E-6);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     */\n+    public BrentSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(double min, double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(double min, double max, double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve(f, min, max, initial);\n+    }\n+\n+    /**\n+     * Find a zero in the given interval with an initial guess.\n+     * <p>Throws <code>IllegalArgumentException</code> if the values of the\n+     * function at the three points have the same sign (note that it is\n+     * allowed to have endpoints with the same sign if the initial point has\n+     * opposite sign function-wise).</p>\n+     * \n+     * @param f function to solve.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @param initial the start value to use (must be set to min if no\n+     * initial point is known).\n+     * @return the value where the function is zero\n+     * @throws MaxIterationsExceededException the maximum iteration count\n+     * is exceeded \n+     * @throws FunctionEvaluationException if an error occurs evaluating\n+     *  the function\n+     * @throws IllegalArgumentException if initial is not between min and max\n+     * (even if it <em>is</em> a root)\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max, final double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        clearResult();\n+        verifySequence(min, initial, max);\n+\n+        // return the initial guess if it is good enough\n+        double yInitial = f.value(initial);\n+        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+            setResult(initial, 0);\n+            return result;\n+        }\n+\n+        // return the first endpoint if it is good enough\n+        double yMin = f.value(min);\n+        if (Math.abs(yMin) <= functionValueAccuracy) {\n+            setResult(yMin, 0);\n+            return result;\n+        }\n+\n+        // reduce interval if min and initial bracket the root\n+        if (yInitial * yMin < 0) {\n+            return solve(f, min, yMin, initial, yInitial, min, yMin);\n+        }\n+\n+        // return the second endpoint if it is good enough\n+        double yMax = f.value(max);\n+        if (Math.abs(yMax) <= functionValueAccuracy) {\n+            setResult(yMax, 0);\n+            return result;\n+        }\n+\n+        // reduce interval if initial and max bracket the root\n+        if (yInitial * yMax < 0) {\n+            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+        }\n+\n+        // full Brent algorithm starting with provided initial guess\n+        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+\n+    }\n+    \n+    /**\n+     * Find a zero in the given interval.\n+     * <p>\n+     * Requires that the values of the function at the endpoints have opposite\n+     * signs. An <code>IllegalArgumentException</code> is thrown if this is not\n+     * the case.</p>\n+     * \n+     * @param f the function to solve\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @return the value where the function is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if min is not less than max or the\n+     * signs of the values of the function at the endpoints are not opposites\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max)\n+        throws MaxIterationsExceededException, \n+        FunctionEvaluationException {\n+        \n+        clearResult();\n+        verifyInterval(min, max);\n+        \n+        double ret = Double.NaN;\n+        \n+        double yMin = f.value(min);\n+        double yMax = f.value(max);\n+        \n+        // Verify bracketing\n+        double sign = yMin * yMax;\n+        if (sign > 0) {\n+            // check if either value is close to a zero\n+            if (Math.abs(yMin) <= functionValueAccuracy) {\n+                setResult(min, 0);\n+                ret = min;\n+            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n+                setResult(max, 0);\n+                ret = max;\n+            } else {\n+                // neither value is close to zero and min and max do not bracket root.\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"function values at endpoints do not have different signs.  \" +\n+                        \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\",\n+                        min, max, yMin, yMax);       \n+            }\n+        } else if (sign < 0){\n+            // solve using only the first endpoint as initial guess\n+            ret = solve(f, min, yMin, max, yMax, min, yMin);\n+        } else {\n+            // either min or max is a root\n+            if (yMin == 0.0) {\n+                ret = min;\n+            } else {\n+                ret = max;\n+            }\n+        }\n+\n+        return ret;\n+    }\n+        \n+    /**\n+     * Find a zero starting search according to the three provided points.\n+     * @param f the function to solve\n+     * @param x0 old approximation for the root\n+     * @param y0 function value at the approximation for the root\n+     * @param x1 last calculated approximation for the root\n+     * @param y1 function value at the last calculated approximation\n+     * for the root\n+     * @param x2 bracket point (must be set to x0 if no bracket point is\n+     * known, this will force starting with linear interpolation)\n+     * @param y2 function value at the bracket point.\n+     * @return the value where the function is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count\n+     * is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating\n+     * the function \n+     */\n+    private double solve(final UnivariateRealFunction f,\n+                         double x0, double y0,\n+                         double x1, double y1,\n+                         double x2, double y2)\n+    throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        double delta = x1 - x0;\n+        double oldDelta = delta;\n+\n+        int i = 0;\n+        while (i < maximalIterationCount) {\n+            if (Math.abs(y2) < Math.abs(y1)) {\n+                // use the bracket point if is better than last approximation\n+                x0 = x1;\n+                x1 = x2;\n+                x2 = x0;\n+                y0 = y1;\n+                y1 = y2;\n+                y2 = y0;\n+            }\n+            if (Math.abs(y1) <= functionValueAccuracy) {\n+                // Avoid division by very small values. Assume\n+                // the iteration has converged (the problem may\n+                // still be ill conditioned)\n+                setResult(x1, i);\n+                return result;\n+            }\n+            double dx = (x2 - x1);\n+            double tolerance =\n+                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n+            if (Math.abs(dx) <= tolerance) {\n+                setResult(x1, i);\n+                return result;\n+            }\n+            if ((Math.abs(oldDelta) < tolerance) ||\n+                    (Math.abs(y0) <= Math.abs(y1))) {\n+                // Force bisection.\n+                delta = 0.5 * dx;\n+                oldDelta = delta;\n+            } else {\n+                double r3 = y1 / y0;\n+                double p;\n+                double p1;\n+                // the equality test (x0 == x2) is intentional,\n+                // it is part of the original Brent's method,\n+                // it should NOT be replaced by proximity test\n+                if (x0 == x2) {\n+                    // Linear interpolation.\n+                    p = dx * r3;\n+                    p1 = 1.0 - r3;\n+                } else {\n+                    // Inverse quadratic interpolation.\n+                    double r1 = y0 / y2;\n+                    double r2 = y1 / y2;\n+                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n+                    p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n+                }\n+                if (p > 0.0) {\n+                    p1 = -p1;\n+                } else {\n+                    p = -p;\n+                }\n+                if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n+                        p >= Math.abs(0.5 * oldDelta * p1)) {\n+                    // Inverse quadratic interpolation gives a value\n+                    // in the wrong direction, or progress is slow.\n+                    // Fall back to bisection.\n+                    delta = 0.5 * dx;\n+                    oldDelta = delta;\n+                } else {\n+                    oldDelta = delta;\n+                    delta = p / p1;\n+                }\n+            }\n+            // Save old X1, Y1 \n+            x0 = x1;\n+            y0 = y1;\n+            // Compute new X1, Y1\n+            if (Math.abs(delta) > tolerance) {\n+                x1 = x1 + delta;\n+            } else if (dx > 0.0) {\n+                x1 = x1 + 0.5 * tolerance;\n+            } else if (dx <= 0.0) {\n+                x1 = x1 - 0.5 * tolerance;\n+            }\n+            y1 = f.value(x1);\n+            if ((y1 > 0) == (y2 > 0)) {\n+                x2 = x0;\n+                y2 = y0;\n+                delta = x1 - x0;\n+                oldDelta = delta;\n+            }\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/LaguerreSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math.complex.Complex;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/LaguerresMethod.html\">\n+ * Laguerre's Method</a> for root finding of real coefficient polynomials.\n+ * For reference, see <b>A First Course in Numerical Analysis</b>,\n+ * ISBN 048641454X, chapter 8.\n+ * <p>\n+ * Laguerre's method is global in the sense that it can start with any initial\n+ * approximation and be able to solve all roots from that point.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class LaguerreSolver extends UnivariateRealSolverImpl {\n+    /** polynomial function to solve.\n+     * @deprecated as of 2.0 the function is not stored anymore in the instance\n+     */\n+    @Deprecated\n+    private PolynomialFunction p;\n+\n+    /**\n+     * Construct a solver for the given function.\n+     *\n+     * @param f function to solve\n+     * @throws IllegalArgumentException if function is not polynomial\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n+    public LaguerreSolver(UnivariateRealFunction f) throws\n+        IllegalArgumentException {\n+        super(f, 100, 1E-6);\n+        if (f instanceof PolynomialFunction) {\n+            p = (PolynomialFunction) f;\n+        } else {\n+            throw MathRuntimeException.createIllegalArgumentException(\"function is not polynomial\");\n+        }\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     */\n+    public LaguerreSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /**\n+     * Returns a copy of the polynomial function.\n+     * \n+     * @return a fresh copy of the polynomial function\n+     * @deprecated as of 2.0 the function is not stored anymore within the instance.\n+     */\n+    @Deprecated\n+    public PolynomialFunction getPolynomialFunction() {\n+        return new PolynomialFunction(p.getCoefficients());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(p, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max, final double initial)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(p, min, max, initial);\n+    }\n+\n+    /**\n+     * Find a real root in the given interval with initial value.\n+     * <p>\n+     * Requires bracketing condition.</p>\n+     * \n+     * @param f function to solve (must be polynomial)\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max, final double initial)\n+        throws ConvergenceException, FunctionEvaluationException {\n+\n+        // check for zeros before verifying bracketing\n+        if (f.value(min) == 0.0) { return min; }\n+        if (f.value(max) == 0.0) { return max; }\n+        if (f.value(initial) == 0.0) { return initial; }\n+\n+        verifyBracketing(min, max, f);\n+        verifySequence(min, initial, max);\n+        if (isBracketing(min, initial, f)) {\n+            return solve(f, min, initial);\n+        } else {\n+            return solve(f, initial, max);\n+        }\n+\n+    }\n+\n+    /**\n+     * Find a real root in the given interval.\n+     * <p>\n+     * Despite the bracketing condition, the root returned by solve(Complex[],\n+     * Complex) may not be a real zero inside [min, max]. For example,\n+     * p(x) = x^3 + 1, min = -2, max = 2, initial = 0. We can either try\n+     * another initial value, or, as we did here, call solveAll() to obtain\n+     * all roots and pick up the one that we're looking for.</p>\n+     *\n+     * @param f the function to solve\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the point at which the function value is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max)\n+        throws ConvergenceException, FunctionEvaluationException {\n+\n+        // check function type\n+        if (!(f instanceof PolynomialFunction)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"function is not polynomial\");\n+        }\n+\n+        // check for zeros before verifying bracketing\n+        if (f.value(min) == 0.0) { return min; }\n+        if (f.value(max) == 0.0) { return max; }\n+        verifyBracketing(min, max, f);\n+\n+        double coefficients[] = ((PolynomialFunction) f).getCoefficients();\n+        Complex c[] = new Complex[coefficients.length];\n+        for (int i = 0; i < coefficients.length; i++) {\n+            c[i] = new Complex(coefficients[i], 0.0);\n+        }\n+        Complex initial = new Complex(0.5 * (min + max), 0.0);\n+        Complex z = solve(c, initial);\n+        if (isRootOK(min, max, z)) {\n+            setResult(z.getReal(), iterationCount);\n+            return result;\n+        }\n+\n+        // solve all roots and select the one we're seeking\n+        Complex[] root = solveAll(c, initial);\n+        for (int i = 0; i < root.length; i++) {\n+            if (isRootOK(min, max, root[i])) {\n+                setResult(root[i].getReal(), iterationCount);\n+                return result;\n+            }\n+        }\n+\n+        // should never happen\n+        throw new ConvergenceException();\n+    }\n+\n+    /**\n+     * Returns true iff the given complex root is actually a real zero\n+     * in the given interval, within the solver tolerance level.\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param z the complex root\n+     * @return true iff z is the sought-after real zero\n+     */\n+    protected boolean isRootOK(double min, double max, Complex z) {\n+        double tolerance = Math.max(relativeAccuracy * z.abs(), absoluteAccuracy);\n+        return (isSequence(min, z.getReal(), max)) &&\n+               (Math.abs(z.getImaginary()) <= tolerance ||\n+                z.abs() <= functionValueAccuracy);\n+    }\n+\n+    /**\n+     * Find all complex roots for the polynomial with the given coefficients,\n+     * starting from the given initial value.\n+     * \n+     * @param coefficients the polynomial coefficients array\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] solveAll(double coefficients[], double initial) throws\n+        ConvergenceException, FunctionEvaluationException {\n+\n+        Complex c[] = new Complex[coefficients.length];\n+        Complex z = new Complex(initial, 0.0);\n+        for (int i = 0; i < c.length; i++) {\n+            c[i] = new Complex(coefficients[i], 0.0);\n+        }\n+        return solveAll(c, z);\n+    }\n+\n+    /**\n+     * Find all complex roots for the polynomial with the given coefficients,\n+     * starting from the given initial value.\n+     * \n+     * @param coefficients the polynomial coefficients array\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] solveAll(Complex coefficients[], Complex initial) throws\n+        MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        int n = coefficients.length - 1;\n+        int iterationCount = 0;\n+        if (n < 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"polynomial degree must be positive: degree={0}\", n);\n+        }\n+        Complex c[] = new Complex[n+1];    // coefficients for deflated polynomial\n+        for (int i = 0; i <= n; i++) {\n+            c[i] = coefficients[i];\n+        }\n+\n+        // solve individual root successively\n+        Complex root[] = new Complex[n];\n+        for (int i = 0; i < n; i++) {\n+            Complex subarray[] = new Complex[n-i+1];\n+            System.arraycopy(c, 0, subarray, 0, subarray.length);\n+            root[i] = solve(subarray, initial);\n+            // polynomial deflation using synthetic division\n+            Complex newc = c[n-i];\n+            Complex oldc = null;\n+            for (int j = n-i-1; j >= 0; j--) {\n+                oldc = c[j];\n+                c[j] = newc;\n+                newc = oldc.add(newc.multiply(root[i]));\n+            }\n+            iterationCount += this.iterationCount;\n+        }\n+\n+        resultComputed = true;\n+        this.iterationCount = iterationCount;\n+        return root;\n+    }\n+\n+    /**\n+     * Find a complex root for the polynomial with the given coefficients,\n+     * starting from the given initial value.\n+     * \n+     * @param coefficients the polynomial coefficients array\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex solve(Complex coefficients[], Complex initial) throws\n+        MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        int n = coefficients.length - 1;\n+        if (n < 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"polynomial degree must be positive: degree={0}\", n);\n+        }\n+        Complex N = new Complex(n, 0.0);\n+        Complex N1 = new Complex((n-1), 0.0);\n+\n+        int i = 1;\n+        Complex pv = null;\n+        Complex dv = null;\n+        Complex d2v = null;\n+        Complex G = null;\n+        Complex G2 = null;\n+        Complex H = null;\n+        Complex delta = null;\n+        Complex denominator = null;\n+        Complex z = initial;\n+        Complex oldz = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+        while (i <= maximalIterationCount) {\n+            // Compute pv (polynomial value), dv (derivative value), and\n+            // d2v (second derivative value) simultaneously.\n+            pv = coefficients[n];\n+            dv = Complex.ZERO;\n+            d2v = Complex.ZERO;\n+            for (int j = n-1; j >= 0; j--) {\n+                d2v = dv.add(z.multiply(d2v));\n+                dv = pv.add(z.multiply(dv));\n+                pv = coefficients[j].add(z.multiply(pv));\n+            }\n+            d2v = d2v.multiply(new Complex(2.0, 0.0));\n+\n+            // check for convergence\n+            double tolerance = Math.max(relativeAccuracy * z.abs(),\n+                                        absoluteAccuracy);\n+            if ((z.subtract(oldz)).abs() <= tolerance) {\n+                resultComputed = true;\n+                iterationCount = i;\n+                return z;\n+            }\n+            if (pv.abs() <= functionValueAccuracy) {\n+                resultComputed = true;\n+                iterationCount = i;\n+                return z;\n+            }\n+\n+            // now pv != 0, calculate the new approximation\n+            G = dv.divide(pv);\n+            G2 = G.multiply(G);\n+            H = G2.subtract(d2v.divide(pv));\n+            delta = N1.multiply((N.multiply(H)).subtract(G2));\n+            // choose a denominator larger in magnitude\n+            Complex deltaSqrt = delta.sqrt();\n+            Complex dplus = G.add(deltaSqrt);\n+            Complex dminus = G.subtract(deltaSqrt);\n+            denominator = dplus.abs() > dminus.abs() ? dplus : dminus;\n+            // Perturb z if denominator is zero, for instance,\n+            // p(x) = x^3 + 1, z = 0.\n+            if (denominator.equals(new Complex(0.0, 0.0))) {\n+                z = z.add(new Complex(absoluteAccuracy, absoluteAccuracy));\n+                oldz = new Complex(Double.POSITIVE_INFINITY,\n+                                   Double.POSITIVE_INFINITY);\n+            } else {\n+                oldz = z;\n+                z = z.subtract(N.divide(denominator));\n+            }\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/MullerSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/MullersMethod.html\">\n+ * Muller's Method</a> for root finding of real univariate functions. For\n+ * reference, see <b>Elementary Numerical Analysis</b>, ISBN 0070124477,\n+ * chapter 3.\n+ * <p>\n+ * Muller's method applies to both real and complex functions, but here we\n+ * restrict ourselves to real functions. Methods solve() and solve2() find\n+ * real zeros, using different ways to bypass complex arithmetics.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class MullerSolver extends UnivariateRealSolverImpl {\n+\n+    /**\n+     * Construct a solver for the given function.\n+     * \n+     * @param f function to solve\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n+    public MullerSolver(UnivariateRealFunction f) {\n+        super(f, 100, 1E-6);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     */\n+    public MullerSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max, final double initial)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(f, min, max, initial);\n+    }\n+\n+    /**\n+     * Find a real root in the given interval with initial value.\n+     * <p>\n+     * Requires bracketing condition.</p>\n+     * \n+     * @param f the function to solve\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max, final double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        // check for zeros before verifying bracketing\n+        if (f.value(min) == 0.0) { return min; }\n+        if (f.value(max) == 0.0) { return max; }\n+        if (f.value(initial) == 0.0) { return initial; }\n+\n+        verifyBracketing(min, max, f);\n+        verifySequence(min, initial, max);\n+        if (isBracketing(min, initial, f)) {\n+            return solve(f, min, initial);\n+        } else {\n+            return solve(f, initial, max);\n+        }\n+    }\n+\n+    /**\n+     * Find a real root in the given interval.\n+     * <p>\n+     * Original Muller's method would have function evaluation at complex point.\n+     * Since our f(x) is real, we have to find ways to avoid that. Bracketing\n+     * condition is one way to go: by requiring bracketing in every iteration,\n+     * the newly computed approximation is guaranteed to be real.</p>\n+     * <p>\n+     * Normally Muller's method converges quadratically in the vicinity of a\n+     * zero, however it may be very slow in regions far away from zeros. For\n+     * example, f(x) = exp(x) - 1, min = -50, max = 100. In such case we use\n+     * bisection as a safety backup if it performs very poorly.</p>\n+     * <p>\n+     * The formulas here use divided differences directly.</p>\n+     * \n+     * @param f the function to solve\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        // [x0, x2] is the bracketing interval in each iteration\n+        // x1 is the last approximation and an interpolation point in (x0, x2)\n+        // x is the new root approximation and new x1 for next round\n+        // d01, d12, d012 are divided differences\n+        double x0, x1, x2, x, oldx, y0, y1, y2, y;\n+        double d01, d12, d012, c1, delta, xplus, xminus, tolerance;\n+\n+        x0 = min; y0 = f.value(x0);\n+        x2 = max; y2 = f.value(x2);\n+        x1 = 0.5 * (x0 + x2); y1 = f.value(x1);\n+\n+        // check for zeros before verifying bracketing\n+        if (y0 == 0.0) { return min; }\n+        if (y2 == 0.0) { return max; }\n+        verifyBracketing(min, max, f);\n+\n+        int i = 1;\n+        oldx = Double.POSITIVE_INFINITY;\n+        while (i <= maximalIterationCount) {\n+            // Muller's method employs quadratic interpolation through\n+            // x0, x1, x2 and x is the zero of the interpolating parabola.\n+            // Due to bracketing condition, this parabola must have two\n+            // real roots and we choose one in [x0, x2] to be x.\n+            d01 = (y1 - y0) / (x1 - x0);\n+            d12 = (y2 - y1) / (x2 - x1);\n+            d012 = (d12 - d01) / (x2 - x0);\n+            c1 = d01 + (x1 - x0) * d012;\n+            delta = c1 * c1 - 4 * y1 * d012;\n+            xplus = x1 + (-2.0 * y1) / (c1 + Math.sqrt(delta));\n+            xminus = x1 + (-2.0 * y1) / (c1 - Math.sqrt(delta));\n+            // xplus and xminus are two roots of parabola and at least\n+            // one of them should lie in (x0, x2)\n+            x = isSequence(x0, xplus, x2) ? xplus : xminus;\n+            y = f.value(x);\n+\n+            // check for convergence\n+            tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n+            if (Math.abs(x - oldx) <= tolerance) {\n+                setResult(x, i);\n+                return result;\n+            }\n+            if (Math.abs(y) <= functionValueAccuracy) {\n+                setResult(x, i);\n+                return result;\n+            }\n+\n+            // Bisect if convergence is too slow. Bisection would waste\n+            // our calculation of x, hopefully it won't happen often.\n+            // the real number equality test x == x1 is intentional and\n+            // completes the proximity tests above it\n+            boolean bisect = (x < x1 && (x1 - x0) > 0.95 * (x2 - x0)) ||\n+                             (x > x1 && (x2 - x1) > 0.95 * (x2 - x0)) ||\n+                             (x == x1);\n+            // prepare the new bracketing interval for next iteration\n+            if (!bisect) {\n+                x0 = x < x1 ? x0 : x1;\n+                y0 = x < x1 ? y0 : y1;\n+                x2 = x > x1 ? x2 : x1;\n+                y2 = x > x1 ? y2 : y1;\n+                x1 = x; y1 = y;\n+                oldx = x;\n+            } else {\n+                double xm = 0.5 * (x0 + x2);\n+                double ym = f.value(xm);\n+                if (MathUtils.sign(y0) + MathUtils.sign(ym) == 0.0) {\n+                    x2 = xm; y2 = ym;\n+                } else {\n+                    x0 = xm; y0 = ym;\n+                }\n+                x1 = 0.5 * (x0 + x2);\n+                y1 = f.value(x1);\n+                oldx = Double.POSITIVE_INFINITY;\n+            }\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+\n+    /**\n+     * Find a real root in the given interval.\n+     * <p>\n+     * solve2() differs from solve() in the way it avoids complex operations.\n+     * Except for the initial [min, max], solve2() does not require bracketing\n+     * condition, e.g. f(x0), f(x1), f(x2) can have the same sign. If complex\n+     * number arises in the computation, we simply use its modulus as real\n+     * approximation.</p>\n+     * <p>\n+     * Because the interval may not be bracketing, bisection alternative is\n+     * not applicable here. However in practice our treatment usually works\n+     * well, especially near real zeros where the imaginary part of complex\n+     * approximation is often negligible.</p>\n+     * <p>\n+     * The formulas here do not use divided differences directly.</p>\n+     * \n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     * @deprecated replaced by {@link #solve2(UnivariateRealFunction, double, double)}\n+     * since 2.0\n+     */\n+    @Deprecated\n+    public double solve2(final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve2(f, min, max);\n+    }\n+\n+    /**\n+     * Find a real root in the given interval.\n+     * <p>\n+     * solve2() differs from solve() in the way it avoids complex operations.\n+     * Except for the initial [min, max], solve2() does not require bracketing\n+     * condition, e.g. f(x0), f(x1), f(x2) can have the same sign. If complex\n+     * number arises in the computation, we simply use its modulus as real\n+     * approximation.</p>\n+     * <p>\n+     * Because the interval may not be bracketing, bisection alternative is\n+     * not applicable here. However in practice our treatment usually works\n+     * well, especially near real zeros where the imaginary part of complex\n+     * approximation is often negligible.</p>\n+     * <p>\n+     * The formulas here do not use divided differences directly.</p>\n+     * \n+     * @param f the function to solve\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve2(final UnivariateRealFunction f,\n+                         final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        // x2 is the last root approximation\n+        // x is the new approximation and new x2 for next round\n+        // x0 < x1 < x2 does not hold here\n+        double x0, x1, x2, x, oldx, y0, y1, y2, y;\n+        double q, A, B, C, delta, denominator, tolerance;\n+\n+        x0 = min; y0 = f.value(x0);\n+        x1 = max; y1 = f.value(x1);\n+        x2 = 0.5 * (x0 + x1); y2 = f.value(x2);\n+\n+        // check for zeros before verifying bracketing\n+        if (y0 == 0.0) { return min; }\n+        if (y1 == 0.0) { return max; }\n+        verifyBracketing(min, max, f);\n+\n+        int i = 1;\n+        oldx = Double.POSITIVE_INFINITY;\n+        while (i <= maximalIterationCount) {\n+            // quadratic interpolation through x0, x1, x2\n+            q = (x2 - x1) / (x1 - x0);\n+            A = q * (y2 - (1 + q) * y1 + q * y0);\n+            B = (2*q + 1) * y2 - (1 + q) * (1 + q) * y1 + q * q * y0;\n+            C = (1 + q) * y2;\n+            delta = B * B - 4 * A * C;\n+            if (delta >= 0.0) {\n+                // choose a denominator larger in magnitude\n+                double dplus = B + Math.sqrt(delta);\n+                double dminus = B - Math.sqrt(delta);\n+                denominator = Math.abs(dplus) > Math.abs(dminus) ? dplus : dminus;\n+            } else {\n+                // take the modulus of (B +/- Math.sqrt(delta))\n+                denominator = Math.sqrt(B * B - delta);\n+            }\n+            if (denominator != 0) {\n+                x = x2 - 2.0 * C * (x2 - x1) / denominator;\n+                // perturb x if it exactly coincides with x1 or x2\n+                // the equality tests here are intentional\n+                while (x == x1 || x == x2) {\n+                    x += absoluteAccuracy;\n+                }\n+            } else {\n+                // extremely rare case, get a random number to skip it\n+                x = min + Math.random() * (max - min);\n+                oldx = Double.POSITIVE_INFINITY;\n+            }\n+            y = f.value(x);\n+\n+            // check for convergence\n+            tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n+            if (Math.abs(x - oldx) <= tolerance) {\n+                setResult(x, i);\n+                return result;\n+            }\n+            if (Math.abs(y) <= functionValueAccuracy) {\n+                setResult(x, i);\n+                return result;\n+            }\n+\n+            // prepare the next iteration\n+            x0 = x1; y0 = y1;\n+            x1 = x2; y1 = y2;\n+            x2 = x; y2 = y;\n+            oldx = x;\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/NewtonSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Implements <a href=\"http://mathworld.wolfram.com/NewtonsMethod.html\">\n+ * Newton's Method</a> for finding zeros of real univariate functions. \n+ * <p> \n+ * The function should be continuous but not necessarily smooth.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class NewtonSolver extends UnivariateRealSolverImpl {\n+    \n+    /**\n+     * Construct a solver for the given function.\n+     * @param f function to solve.\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n+    public NewtonSolver(DifferentiableUnivariateRealFunction f) {\n+        super(f, 100, 1E-6);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     */\n+    public NewtonSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max)\n+        throws MaxIterationsExceededException, \n+        FunctionEvaluationException  {\n+        return solve(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max, final double startValue)\n+        throws MaxIterationsExceededException, FunctionEvaluationException  {\n+        return solve(f, min, max, startValue);\n+    }\n+\n+    /**\n+     * Find a zero near the midpoint of <code>min</code> and <code>max</code>.\n+     * \n+     * @param f the function to solve\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the value where the function is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded \n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function or derivative\n+     * @throws IllegalArgumentException if min is not less than max\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException  {\n+        return solve(f, min, max, UnivariateRealSolverUtils.midpoint(min, max));\n+    }\n+\n+    /**\n+     * Find a zero near the value <code>startValue</code>.\n+     * \n+     * @param f the function to solve\n+     * @param min the lower bound for the interval (ignored).\n+     * @param max the upper bound for the interval (ignored).\n+     * @param startValue the start value to use.\n+     * @return the value where the function is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded \n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function or derivative\n+     * @throws IllegalArgumentException if startValue is not between min and max or\n+     * if function is not a {@link DifferentiableUnivariateRealFunction} instance\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max, final double startValue)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        try {\n+\n+            final UnivariateRealFunction derivative =\n+                ((DifferentiableUnivariateRealFunction) f).derivative();\n+            clearResult();\n+            verifySequence(min, startValue, max);\n+\n+            double x0 = startValue;\n+            double x1;\n+\n+            int i = 0;\n+            while (i < maximalIterationCount) {\n+\n+                x1 = x0 - (f.value(x0) / derivative.value(x0));\n+                if (Math.abs(x1 - x0) <= absoluteAccuracy) {\n+                    setResult(x1, i);\n+                    return x1;\n+                }\n+\n+                x0 = x1;\n+                ++i;\n+            }\n+\n+            throw new MaxIterationsExceededException(maximalIterationCount);\n+        } catch (ClassCastException cce) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"function is not differentiable\");\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/RiddersSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/RiddersMethod.html\">\n+ * Ridders' Method</a> for root finding of real univariate functions. For\n+ * reference, see C. Ridders, <i>A new algorithm for computing a single root\n+ * of a real continuous function </i>, IEEE Transactions on Circuits and\n+ * Systems, 26 (1979), 979 - 980.\n+ * <p>\n+ * The function should be continuous but not necessarily smooth.</p>\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class RiddersSolver extends UnivariateRealSolverImpl {\n+\n+    /**\n+     * Construct a solver for the given function.\n+     * \n+     * @param f function to solve\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n+    public RiddersSolver(UnivariateRealFunction f) {\n+        super(f, 100, 1E-6);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     */\n+    public RiddersSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max, final double initial)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(f, min, max, initial);\n+    }\n+\n+    /**\n+     * Find a root in the given interval with initial value.\n+     * <p>\n+     * Requires bracketing condition.</p>\n+     * \n+     * @param f the function to solve\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param initial the start value to use\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max, final double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        // check for zeros before verifying bracketing\n+        if (f.value(min) == 0.0) { return min; }\n+        if (f.value(max) == 0.0) { return max; }\n+        if (f.value(initial) == 0.0) { return initial; }\n+\n+        verifyBracketing(min, max, f);\n+        verifySequence(min, initial, max);\n+        if (isBracketing(min, initial, f)) {\n+            return solve(f, min, initial);\n+        } else {\n+            return solve(f, initial, max);\n+        }\n+    }\n+\n+    /**\n+     * Find a root in the given interval.\n+     * <p>\n+     * Requires bracketing condition.</p>\n+     * \n+     * @param f the function to solve\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @return the point at which the function value is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        // [x1, x2] is the bracketing interval in each iteration\n+        // x3 is the midpoint of [x1, x2]\n+        // x is the new root approximation and an endpoint of the new interval\n+        double x1, x2, x3, x, oldx, y1, y2, y3, y, delta, correction, tolerance;\n+\n+        x1 = min; y1 = f.value(x1);\n+        x2 = max; y2 = f.value(x2);\n+\n+        // check for zeros before verifying bracketing\n+        if (y1 == 0.0) { return min; }\n+        if (y2 == 0.0) { return max; }\n+        verifyBracketing(min, max, f);\n+\n+        int i = 1;\n+        oldx = Double.POSITIVE_INFINITY;\n+        while (i <= maximalIterationCount) {\n+            // calculate the new root approximation\n+            x3 = 0.5 * (x1 + x2);\n+            y3 = f.value(x3);\n+            if (Math.abs(y3) <= functionValueAccuracy) {\n+                setResult(x3, i);\n+                return result;\n+            }\n+            delta = 1 - (y1 * y2) / (y3 * y3);  // delta > 1 due to bracketing\n+            correction = (MathUtils.sign(y2) * MathUtils.sign(y3)) *\n+                         (x3 - x1) / Math.sqrt(delta);\n+            x = x3 - correction;                // correction != 0\n+            y = f.value(x);\n+\n+            // check for convergence\n+            tolerance = Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy);\n+            if (Math.abs(x - oldx) <= tolerance) {\n+                setResult(x, i);\n+                return result;\n+            }\n+            if (Math.abs(y) <= functionValueAccuracy) {\n+                setResult(x, i);\n+                return result;\n+            }\n+\n+            // prepare the new interval for next iteration\n+            // Ridders' method guarantees x1 < x < x2\n+            if (correction > 0.0) {             // x1 < x < x3\n+                if (MathUtils.sign(y1) + MathUtils.sign(y) == 0.0) {\n+                    x2 = x; y2 = y;\n+                } else {\n+                    x1 = x; x2 = x3;\n+                    y1 = y; y2 = y3;\n+                }\n+            } else {                            // x3 < x < x2\n+                if (MathUtils.sign(y2) + MathUtils.sign(y) == 0.0) {\n+                    x1 = x; y1 = y;\n+                } else {\n+                    x1 = x3; x2 = x;\n+                    y1 = y3; y2 = y;\n+                }\n+            }\n+            oldx = x;\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/SecantSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+\n+/**\n+ * Implements a modified version of the \n+ * <a href=\"http://mathworld.wolfram.com/SecantMethod.html\">secant method</a>\n+ * for approximating a zero of a real univariate function.  \n+ * <p>\n+ * The algorithm is modified to maintain bracketing of a root by successive\n+ * approximations. Because of forced bracketing, convergence may be slower than\n+ * the unrestricted secant algorithm. However, this implementation should in\n+ * general outperform the \n+ * <a href=\"http://mathworld.wolfram.com/MethodofFalsePosition.html\">\n+ * regula falsi method.</a></p>\n+ * <p>\n+ * The function is assumed to be continuous but not necessarily smooth.</p>\n+ *  \n+ * @version $Revision$ $Date$\n+ */\n+public class SecantSolver extends UnivariateRealSolverImpl {\n+    \n+    /**\n+     * Construct a solver for the given function.\n+     * @param f function to solve.\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n+    public SecantSolver(UnivariateRealFunction f) {\n+        super(f, 100, 1E-6);\n+    }\n+\n+    /**\n+     * Construct a solver.\n+     */\n+    public SecantSolver() {\n+        super(100, 1E-6);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double solve(final double min, final double max, final double initial)\n+        throws ConvergenceException, FunctionEvaluationException {\n+        return solve(f, min, max, initial);\n+    }\n+\n+    /**\n+     * Find a zero in the given interval.\n+     * \n+     * @param f the function to solve\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param initial the start value to use (ignored)\n+     * @return the value where the function is zero\n+     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if min is not less than max or the\n+     * signs of the values of the function at the endpoints are not opposites\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max, final double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return solve(f, min, max);\n+    }\n+    \n+    /**\n+     * Find a zero in the given interval.\n+     * @param f the function to solve\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @return the value where the function is zero\n+     * @throws MaxIterationsExceededException  if the maximum iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function \n+     * @throws IllegalArgumentException if min is not less than max or the\n+     * signs of the values of the function at the endpoints are not opposites\n+     */\n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        \n+        clearResult();\n+        verifyInterval(min, max);\n+        \n+        // Index 0 is the old approximation for the root.\n+        // Index 1 is the last calculated approximation  for the root.\n+        // Index 2 is a bracket for the root with respect to x0.\n+        // OldDelta is the length of the bracketing interval of the last\n+        // iteration.\n+        double x0 = min;\n+        double x1 = max;\n+        double y0 = f.value(x0);\n+        double y1 = f.value(x1);\n+        \n+        // Verify bracketing\n+        if (y0 * y1 >= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"function values at endpoints do not have different signs, \" +\n+                  \"endpoints: [{0}, {1}], values: [{2}, {3}]\",\n+                  min, max, y0, y1);       \n+        }\n+        \n+        double x2 = x0;\n+        double y2 = y0;\n+        double oldDelta = x2 - x1;\n+        int i = 0;\n+        while (i < maximalIterationCount) {\n+            if (Math.abs(y2) < Math.abs(y1)) {\n+                x0 = x1;\n+                x1 = x2;\n+                x2 = x0;\n+                y0 = y1;\n+                y1 = y2;\n+                y2 = y0;\n+            }\n+            if (Math.abs(y1) <= functionValueAccuracy) {\n+                setResult(x1, i);\n+                return result;\n+            }\n+            if (Math.abs(oldDelta) <\n+                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n+                setResult(x1, i);\n+                return result;\n+            }\n+            double delta;\n+            if (Math.abs(y1) > Math.abs(y0)) {\n+                // Function value increased in last iteration. Force bisection.\n+                delta = 0.5 * oldDelta;\n+            } else {\n+                delta = (x0 - x1) / (1 - y0 / y1);\n+                if (delta / oldDelta > 1) {\n+                    // New approximation falls outside bracket.\n+                    // Fall back to bisection.\n+                    delta = 0.5 * oldDelta;\n+                }\n+            }\n+            x0 = x1;\n+            y0 = y1;\n+            x1 = x1 + delta;\n+            y1 = f.value(x1);\n+            if ((y1 > 0) == (y2 > 0)) {\n+                // New bracket is (x0,x1).                    \n+                x2 = x0;\n+                y2 = y0;\n+            }\n+            oldDelta = x2 - x1;\n+            i++;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.ConvergingAlgorithm;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+\n+/**\n+ * Interface for (univariate real) rootfinding algorithms.\n+ * <p>\n+ * Implementations will search for only one zero in the given interval.</p>\n+ *  \n+ * @version $Revision$ $Date$\n+ */\n+public interface UnivariateRealSolver extends ConvergingAlgorithm {\n+\n+    /**\n+     * Set the function value accuracy.\n+     * <p>\n+     * This is used to determine when an evaluated function value or some other\n+     * value which is used as divisor is zero.</p>\n+     * <p>\n+     * This is a safety guard and it shouldn't be necessary to change this in\n+     * general.</p>\n+     * \n+     * @param accuracy the accuracy.\n+     * @throws IllegalArgumentException if the accuracy can't be achieved by\n+     * the solver or is otherwise deemed unreasonable. \n+     */\n+    void setFunctionValueAccuracy(double accuracy);\n+\n+    /**\n+     * Get the actual function value accuracy.\n+     * @return the accuracy\n+     */\n+    double getFunctionValueAccuracy();\n+\n+    /**\n+     * Reset the actual function accuracy to the default.\n+     * The default value is provided by the solver implementation.\n+     */\n+    void resetFunctionValueAccuracy();\n+\n+    /**\n+     * Solve for a zero root in the given interval.\n+     * <p>A solver may require that the interval brackets a single zero root.\n+     * Solvers that do require bracketing should be able to handle the case\n+     * where one of the endpoints is itself a root.</p>\n+     * \n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @return a value where the function is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the endpoints do not\n+     * satisfy the requirements specified by the solver\n+     * @deprecated replaced by {@link #solve(UnivariateRealFunction, double, double)}\n+     * since 2.0\n+     */\n+    @Deprecated\n+    double solve(double min, double max) throws ConvergenceException, \n+        FunctionEvaluationException;\n+\n+    /**\n+     * Solve for a zero root in the given interval.\n+     * <p>A solver may require that the interval brackets a single zero root.\n+     * Solvers that do require bracketing should be able to handle the case\n+     * where one of the endpoints is itself a root.</p>\n+     * \n+     * @param f the function to solve.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @return a value where the function is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the endpoints do not\n+     * satisfy the requirements specified by the solver\n+     * @since 2.0\n+     */\n+    double solve(UnivariateRealFunction f, double min, double max)\n+        throws ConvergenceException, \n+        FunctionEvaluationException;\n+\n+    /**\n+     * Solve for a zero in the given interval, start at startValue.\n+     * <p>A solver may require that the interval brackets a single zero root.\n+     * Solvers that do require bracketing should be able to handle the case\n+     * where one of the endpoints is itself a root.</p>\n+     * \n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @param startValue the start value to use\n+     * @return a value where the function is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the arguments do not\n+     * satisfy the requirements specified by the solver\n+     * @deprecated replaced by {@link #solve(UnivariateRealFunction, double, double, double)}\n+     * since 2.0\n+     */\n+    @Deprecated\n+    double solve(double min, double max, double startValue)\n+        throws ConvergenceException, FunctionEvaluationException, IllegalArgumentException;\n+\n+    /**\n+     * Solve for a zero in the given interval, start at startValue.\n+     * <p>A solver may require that the interval brackets a single zero root.\n+     * Solvers that do require bracketing should be able to handle the case\n+     * where one of the endpoints is itself a root.</p>\n+     * \n+     * @param f the function to solve.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @param startValue the start value to use\n+     * @return a value where the function is zero\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the solver detects convergence problems otherwise.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the arguments do not\n+     * satisfy the requirements specified by the solver\n+     * @since 2.0\n+     */\n+    double solve(UnivariateRealFunction f, double min, double max, double startValue)\n+        throws ConvergenceException, FunctionEvaluationException, IllegalArgumentException;\n+\n+    /**\n+     * Get the result of the last run of the solver.\n+     * \n+     * @return the last result.\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed.\n+     */\n+    double getResult();\n+\n+    /**\n+     * Get the result of the last run of the solver.\n+     * \n+     * @return the value of the function at the last result.\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed.\n+     */\n+    double getFunctionValue();\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverFactory.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+/**\n+ * Abstract factory class used to create {@link UnivariateRealSolver} instances.\n+ * <p>\n+ * Solvers implementing the following algorithms are supported:\n+ * <ul>\n+ * <li>Bisection</li>\n+ * <li>Brent's method</li>\n+ * <li>Secant method</li>\n+ * </ul>\n+ * Concrete factories extending this class also specify a default solver, instances of which\n+ * are returned by <code>newDefaultSolver()</code>.</p>\n+ * <p>\n+ * Common usage:<pre>\n+ * SolverFactory factory = UnivariateRealSolverFactory.newInstance();</p>\n+ *\n+ * // create a Brent solver to use\n+ * BrentSolver solver = factory.newBrentSolver();\n+ * </pre>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public abstract class UnivariateRealSolverFactory {\n+    /**\n+     * Default constructor.\n+     */\n+    protected UnivariateRealSolverFactory() {\n+    }\n+\n+    /**\n+     * Create a new factory.\n+     * @return a new factory.\n+     */\n+    public static UnivariateRealSolverFactory newInstance() {\n+        return new UnivariateRealSolverFactoryImpl();\n+    }\n+    \n+    /**\n+     * Create a new {@link UnivariateRealSolver}.  The\n+     * actual solver returned is determined by the underlying factory.\n+     * @return the new solver.\n+     */\n+    public abstract UnivariateRealSolver newDefaultSolver();\n+    \n+    /**\n+     * Create a new {@link UnivariateRealSolver}.  The\n+     * solver is an implementation of the bisection method.\n+     * @return the new solver.\n+     */\n+    public abstract UnivariateRealSolver newBisectionSolver();\n+    \n+    /**\n+     * Create a new {@link UnivariateRealSolver}.  The\n+     * solver is an implementation of the Brent method.\n+     * @return the new solver.\n+     */\n+    public abstract UnivariateRealSolver newBrentSolver();\n+    \n+    /**\n+     * Create a new {@link UnivariateRealSolver}.  The\n+     * solver is an implementation of Newton's Method.\n+     * @return the new solver.\n+     */\n+    public abstract UnivariateRealSolver newNewtonSolver();\n+    \n+    /**\n+     * Create a new {@link UnivariateRealSolver}.  The\n+     * solver is an implementation of the secant method.\n+     * @return the new solver.\n+     */\n+    public abstract UnivariateRealSolver newSecantSolver();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverFactoryImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+/**\n+ * A concrete {@link  UnivariateRealSolverFactory}.  This is the default solver factory\n+ * used by commons-math.\n+ * <p>\n+ * The default solver returned by this factory is a {@link BrentSolver}.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class UnivariateRealSolverFactoryImpl extends UnivariateRealSolverFactory {\n+        \n+    /**\n+     * Default constructor.\n+     */\n+    public UnivariateRealSolverFactoryImpl() {\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public UnivariateRealSolver newDefaultSolver() {\n+        return newBrentSolver();\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Override\n+    public UnivariateRealSolver newBisectionSolver() {\n+        return new BisectionSolver();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public UnivariateRealSolver newBrentSolver() {\n+        return new BrentSolver();\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Override\n+    public UnivariateRealSolver newNewtonSolver() {\n+        return new NewtonSolver();\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Override\n+    public UnivariateRealSolver newSecantSolver() {\n+        return new SecantSolver();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.ConvergingAlgorithmImpl;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Provide a default implementation for several functions useful to generic\n+ * solvers.\n+ *  \n+ * @version $Revision$ $Date$\n+ */\n+public abstract class UnivariateRealSolverImpl\n+    extends ConvergingAlgorithmImpl implements UnivariateRealSolver {\n+\n+    /** Maximum error of function. */\n+    protected double functionValueAccuracy;\n+\n+    /** Default maximum error of function. */\n+    protected double defaultFunctionValueAccuracy;\n+\n+    /** Indicates where a root has been computed. */\n+    protected boolean resultComputed = false;\n+\n+    /** The last computed root. */\n+    protected double result;\n+\n+    /** Value of the function at the last computed result. */\n+    protected double functionValue;\n+\n+    /** The function to solve.\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method. */\n+    @Deprecated\n+    protected UnivariateRealFunction f;\n+\n+    /**\n+     * Construct a solver with given iteration count and accuracy.\n+     * \n+     * @param f the function to solve.\n+     * @param defaultAbsoluteAccuracy maximum absolute error\n+     * @param defaultMaximalIterationCount maximum number of iterations\n+     * @throws IllegalArgumentException if f is null or the \n+     * defaultAbsoluteAccuracy is not valid\n+     * @deprecated as of 2.0 the function to solve is passed as an argument\n+     * to the {@link #solve(UnivariateRealFunction, double, double)} or\n+     * {@link UnivariateRealSolverImpl#solve(UnivariateRealFunction, double, double, double)}\n+     * method.\n+     */\n+    @Deprecated\n+    protected UnivariateRealSolverImpl(final UnivariateRealFunction f,\n+                                       final int defaultMaximalIterationCount,\n+                                       final double defaultAbsoluteAccuracy) {\n+        super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\n+        if (f == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"function to solve cannot be null\");\n+        }\n+        this.f = f;\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n+        this.functionValueAccuracy = defaultFunctionValueAccuracy;\n+    }\n+\n+    /**\n+     * Construct a solver with given iteration count and accuracy.\n+     * \n+     * @param defaultAbsoluteAccuracy maximum absolute error\n+     * @param defaultMaximalIterationCount maximum number of iterations\n+     * @throws IllegalArgumentException if f is null or the \n+     * defaultAbsoluteAccuracy is not valid\n+     */\n+    protected UnivariateRealSolverImpl(final int defaultMaximalIterationCount,\n+                                       final double defaultAbsoluteAccuracy) {\n+        super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\n+        this.defaultFunctionValueAccuracy = 1.0e-15;\n+        this.functionValueAccuracy = defaultFunctionValueAccuracy;\n+    }\n+\n+    /** Check if a result has been computed.\n+     * @exception IllegalStateException if no result has been computed\n+     */\n+    protected void checkResultComputed() throws IllegalStateException {\n+        if (!resultComputed) {\n+            throw MathRuntimeException.createIllegalStateException(\"no result available\");\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getResult() {\n+        checkResultComputed();\n+        return result;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getFunctionValue() {\n+        checkResultComputed();\n+        return functionValue;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setFunctionValueAccuracy(final double accuracy) {\n+        functionValueAccuracy = accuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getFunctionValueAccuracy() {\n+        return functionValueAccuracy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void resetFunctionValueAccuracy() {\n+        functionValueAccuracy = defaultFunctionValueAccuracy;\n+    }\n+\n+    /**\n+     * Convenience function for implementations.\n+     * \n+     * @param result the result to set\n+     * @param iterationCount the iteration count to set\n+     */\n+    protected final void setResult(final double result, final int iterationCount) {\n+        this.result         = result;\n+        this.iterationCount = iterationCount;\n+        this.resultComputed = true;\n+    }\n+\n+    /**\n+     * Convenience function for implementations.\n+     * \n+     * @param x the result to set\n+     * @param fx the result to set\n+     * @param iterationCount the iteration count to set\n+     */\n+    protected final void setResult(final double x, final double fx,\n+                                   final int iterationCount) {\n+        this.result         = x;\n+        this.functionValue  = fx;\n+        this.iterationCount = iterationCount;\n+        this.resultComputed = true;\n+    }\n+\n+    /**\n+     * Convenience function for implementations.\n+     */\n+    protected final void clearResult() {\n+        this.iterationCount = 0;\n+        this.resultComputed = false;\n+    }\n+\n+    /**\n+     * Returns true iff the function takes opposite signs at the endpoints.\n+     * \n+     * @param lower  the lower endpoint \n+     * @param upper  the upper endpoint\n+     * @param f the function\n+     * @return true if f(lower) * f(upper) < 0\n+     * @throws FunctionEvaluationException if an error occurs evaluating the \n+     * function at the endpoints\n+     */\n+    protected boolean isBracketing(final double lower, final double upper, \n+                                   final UnivariateRealFunction f)\n+        throws FunctionEvaluationException {\n+        final double f1 = f.value(lower);\n+        final double f2 = f.value(upper);\n+        return ((f1 > 0 && f2 < 0) || (f1 < 0 && f2 > 0));\n+    }\n+    \n+    /**\n+     * Returns true if the arguments form a (strictly) increasing sequence\n+     * \n+     * @param start  first number\n+     * @param mid   second number\n+     * @param end  third number\n+     * @return true if the arguments form an increasing sequence\n+     */\n+    protected boolean isSequence(final double start, final double mid, final double end) {\n+        return (start < mid) && (mid < end);\n+    }\n+    \n+    /**\n+     * Verifies that the endpoints specify an interval, \n+     * throws IllegalArgumentException if not\n+     * \n+     * @param lower  lower endpoint\n+     * @param upper upper endpoint\n+     * @throws IllegalArgumentException\n+     */\n+    protected void verifyInterval(final double lower, final double upper) {\n+        if (lower >= upper) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"endpoints do not specify an interval: [{0}, {1}]\",\n+                    lower, upper);\n+        }       \n+    }\n+    \n+    /**\n+     * Verifies that <code>lower < initial < upper</code>\n+     * throws IllegalArgumentException if not\n+     * \n+     * @param lower  lower endpoint\n+     * @param initial initial value\n+     * @param upper upper endpoint\n+     * @throws IllegalArgumentException\n+     */\n+    protected void verifySequence(final double lower, final double initial, final double upper) {\n+        if (!isSequence(lower, initial, upper)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",\n+                    lower, initial, upper);\n+        }       \n+    }\n+    \n+    /**\n+     * Verifies that the endpoints specify an interval and the function takes\n+     * opposite signs at the enpoints, throws IllegalArgumentException if not\n+     * \n+     * @param lower  lower endpoint\n+     * @param upper upper endpoint\n+     * @param f function\n+     * @throws IllegalArgumentException\n+     * @throws FunctionEvaluationException if an error occurs evaluating the \n+     * function at the endpoints\n+     */\n+    protected void verifyBracketing(final double lower, final double upper, \n+                                    final UnivariateRealFunction f)\n+        throws FunctionEvaluationException {\n+        \n+        verifyInterval(lower, upper);\n+        if (!isBracketing(lower, upper, f)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"function values at endpoints do not have different signs.  \" +\n+                    \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\",\n+                    lower, upper, f.value(lower), f.value(upper));       \n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Utility routines for {@link UnivariateRealSolver} objects.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class UnivariateRealSolverUtils {\n+    /**\n+     * Default constructor.\n+     */\n+    private UnivariateRealSolverUtils() {\n+        super();\n+    }\n+    \n+    /**\n+     * Convenience method to find a zero of a univariate real function.  A default\n+     * solver is used. \n+     * \n+     * @param f the function.\n+     * @param x0 the lower bound for the interval.\n+     * @param x1 the upper bound for the interval.\n+     * @return a value where the function is zero.\n+     * @throws ConvergenceException if the iteration count was exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating\n+     * the function\n+     * @throws IllegalArgumentException if f is null or the endpoints do not\n+     * specify a valid interval\n+     */\n+    public static double solve(UnivariateRealFunction f, double x0, double x1)\n+    throws ConvergenceException, FunctionEvaluationException {\n+        setup(f);\n+        return LazyHolder.FACTORY.newDefaultSolver().solve(f, x0, x1);\n+    }\n+\n+    /**\n+     * Convenience method to find a zero of a univariate real function.  A default\n+     * solver is used. \n+     * \n+     * @param f the function\n+     * @param x0 the lower bound for the interval\n+     * @param x1 the upper bound for the interval\n+     * @param absoluteAccuracy the accuracy to be used by the solver\n+     * @return a value where the function is zero\n+     * @throws ConvergenceException if the iteration count is exceeded\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if f is null, the endpoints do not \n+     * specify a valid interval, or the absoluteAccuracy is not valid for the\n+     * default solver\n+     */\n+    public static double solve(UnivariateRealFunction f, double x0, double x1,\n+            double absoluteAccuracy) throws ConvergenceException, \n+            FunctionEvaluationException {    \n+       \n+        setup(f);\n+        UnivariateRealSolver solver = LazyHolder.FACTORY.newDefaultSolver();\n+        solver.setAbsoluteAccuracy(absoluteAccuracy);\n+        return solver.solve(f, x0, x1);\n+    }\n+\n+    /**\n+     * This method attempts to find two values a and b satisfying <ul>\n+    * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n+     * <li> <code> f(a) * f(b) < 0 </code></li>\n+     * </ul>\n+     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n+     * and <code>b</code> bracket a root of f.\n+     * <p>\n+     * The algorithm starts by setting \n+     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n+     * function at <code>a</code> and <code>b</code> and keeps moving\n+     * the endpoints out by one unit each time through a loop that terminates \n+     * when one of the following happens: <ul>\n+     * <li> <code> f(a) * f(b) < 0 </code> --  success!</li>\n+     * <li> <code> a = lower </code> and <code> b = upper</code> \n+     * -- ConvergenceException </li>\n+     * <li> <code> Integer.MAX_VALUE</code> iterations elapse \n+     * -- ConvergenceException </li>\n+     * </ul></p>\n+     * <p>\n+     * <strong>Note: </strong> this method can take \n+     * <code>Integer.MAX_VALUE</code> iterations to throw a \n+     * <code>ConvergenceException.</code>  Unless you are confident that there\n+     * is a root between <code>lowerBound</code> and <code>upperBound</code>\n+     * near <code>initial,</code> it is better to use \n+     * {@link #bracket(UnivariateRealFunction, double, double, double, int)}, \n+     * explicitly specifying the maximum number of iterations.</p>\n+     *\n+     * @param function the function\n+     * @param initial initial midpoint of interval being expanded to\n+     * bracket a root\n+     * @param lowerBound lower bound (a is never lower than this value)\n+     * @param upperBound upper bound (b never is greater than this\n+     * value)\n+     * @return a two element array holding {a, b}\n+     * @throws ConvergenceException if a root can not be bracketted\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if function is null, maximumIterations\n+     * is not positive, or initial is not between lowerBound and upperBound\n+     */\n+    public static double[] bracket(UnivariateRealFunction function, \n+            double initial, double lowerBound, double upperBound) \n+    throws ConvergenceException, FunctionEvaluationException {\n+        return bracket( function, initial, lowerBound, upperBound,\n+            Integer.MAX_VALUE ) ;\n+    }\n+\n+     /**\n+     * This method attempts to find two values a and b satisfying <ul>\n+     * <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li>\n+     * <li> <code> f(a) * f(b) <= 0 </code> </li>\n+     * </ul>\n+     * If f is continuous on <code>[a,b],</code> this means that <code>a</code>\n+     * and <code>b</code> bracket a root of f.\n+     * <p>\n+     * The algorithm starts by setting \n+     * <code>a := initial -1; b := initial +1,</code> examines the value of the\n+     * function at <code>a</code> and <code>b</code> and keeps moving\n+     * the endpoints out by one unit each time through a loop that terminates \n+     * when one of the following happens: <ul>\n+     * <li> <code> f(a) * f(b) <= 0 </code> --  success!</li>\n+     * <li> <code> a = lower </code> and <code> b = upper</code> \n+     * -- ConvergenceException </li>\n+     * <li> <code> maximumIterations</code> iterations elapse \n+     * -- ConvergenceException </li></ul></p>\n+     * \n+     * @param function the function\n+     * @param initial initial midpoint of interval being expanded to\n+     * bracket a root\n+     * @param lowerBound lower bound (a is never lower than this value)\n+     * @param upperBound upper bound (b never is greater than this\n+     * value)\n+     * @param maximumIterations maximum number of iterations to perform\n+     * @return a two element array holding {a, b}.\n+     * @throws ConvergenceException if the algorithm fails to find a and b\n+     * satisfying the desired conditions\n+     * @throws FunctionEvaluationException if an error occurs evaluating the \n+     * function\n+     * @throws IllegalArgumentException if function is null, maximumIterations\n+     * is not positive, or initial is not between lowerBound and upperBound\n+     */\n+    public static double[] bracket(UnivariateRealFunction function,\n+            double initial, double lowerBound, double upperBound, \n+            int maximumIterations) throws ConvergenceException, \n+            FunctionEvaluationException {\n+        \n+        if (function == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n+        }\n+        if (maximumIterations <= 0)  {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n+        }\n+        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n+                  lowerBound, initial, upperBound);\n+        }\n+        double a = initial;\n+        double b = initial;\n+        double fa;\n+        double fb;\n+        int numIterations = 0 ;\n+    \n+        do {\n+            a = Math.max(a - 1.0, lowerBound);\n+            b = Math.min(b + 1.0, upperBound);\n+            fa = function.value(a);\n+            \n+            fb = function.value(b);\n+            numIterations++ ;\n+        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n+                ((a > lowerBound) || (b < upperBound)));\n+   \n+        if (fa * fb > 0.0 ) {\n+            throw new ConvergenceException(\n+                      \"number of iterations={0}, maximum iterations={1}, \" +\n+                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n+                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n+                      numIterations, maximumIterations, initial,\n+                      lowerBound, upperBound, a, b, fa, fb);\n+        }\n+        \n+        return new double[]{a, b};\n+    }\n+\n+    /**\n+     * Compute the midpoint of two values.\n+     * \n+     * @param a first value.\n+     * @param b second value.\n+     * @return the midpoint. \n+     */\n+    public static double midpoint(double a, double b) {\n+        return (a + b) * .5;\n+    }\n+    \n+    /**\n+     * Checks to see if f is null, throwing IllegalArgumentException if so.\n+     * @param f  input function\n+     * @throws IllegalArgumentException if f is null\n+     */\n+    private static void setup(UnivariateRealFunction f) {\n+        if (f == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n+        }\n+    }\n+\n+    /** Holder for the factory.\n+     * <p>We use here the Initialization On Demand Holder Idiom.</p>\n+     */\n+    private static class LazyHolder {\n+        /** Cached solver factory */\n+        private static final UnivariateRealSolverFactory FACTORY =\n+            UnivariateRealSolverFactory.newInstance();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.complex;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Representation of a Complex number - a number which has both a \n+ * real and imaginary part.\n+ * <p>\n+ * Implementations of arithmetic operations handle <code>NaN</code> and\n+ * infinite values according to the rules for {@link java.lang.Double}\n+ * arithmetic, applying definitional formulas and returning <code>NaN</code> or\n+ * infinite values in real or imaginary parts as these arise in computation. \n+ * See individual method javadocs for details.</p>\n+ * <p>\n+ * {@link #equals} identifies all values with <code>NaN</code> in either real \n+ * or imaginary part - e.g., <pre>\n+ * <code>1 + NaNi  == NaN + i == NaN + NaNi.</code></pre></p>\n+ *\n+ * implements Serializable since 2.0\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class Complex implements FieldElement<Complex>, Serializable  {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -6195664516687396620L;\n+\n+    /** The square root of -1. A number representing \"0.0 + 1.0i\" */    \n+    public static final Complex I = new Complex(0.0, 1.0);\n+    \n+    /** A complex number representing \"NaN + NaNi\" */\n+    public static final Complex NaN = new Complex(Double.NaN, Double.NaN);\n+\n+    /** A complex number representing \"+INF + INFi\" */\n+    public static final Complex INF = new Complex(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+\n+    /** A complex number representing \"1.0 + 0.0i\" */    \n+    public static final Complex ONE = new Complex(1.0, 0.0);\n+    \n+    /** A complex number representing \"0.0 + 0.0i\" */    \n+    public static final Complex ZERO = new Complex(0.0, 0.0);\n+    \n+    /** \n+     * The imaginary part \n+     */\n+    private final double imaginary;\n+    \n+    /** \n+     * The real part \n+     */\n+    private final double real;\n+    \n+    /**\n+     * Record whether this complex number is equal to NaN\n+     */\n+    private final transient boolean isNaN;\n+    \n+    /**\n+     * Record whether this complex number is infinite\n+     */\n+    private final transient boolean isInfinite;\n+    \n+    /**\n+     * Create a complex number given the real and imaginary parts.\n+     *\n+     * @param real the real part\n+     * @param imaginary the imaginary part\n+     */\n+    public Complex(double real, double imaginary) {\n+        super();\n+        this.real = real;\n+        this.imaginary = imaginary;\n+        \n+        isNaN = Double.isNaN(real) || Double.isNaN(imaginary);\n+        isInfinite = !isNaN &&\n+        (Double.isInfinite(real) || Double.isInfinite(imaginary));\n+    }\n+\n+    /**\n+     * Return the absolute value of this complex number.\n+     * <p>\n+     * Returns <code>NaN</code> if either real or imaginary part is\n+     * <code>NaN</code> and <code>Double.POSITIVE_INFINITY</code> if\n+     * neither part is <code>NaN</code>, but at least one part takes an infinite\n+     * value.</p>\n+     *\n+     * @return the absolute value\n+     */\n+    public double abs() {\n+        if (isNaN()) {\n+            return Double.NaN;\n+        }\n+        \n+        if (isInfinite()) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+        \n+        if (Math.abs(real) < Math.abs(imaginary)) {\n+            if (imaginary == 0.0) {\n+                return Math.abs(real);\n+            }\n+            double q = real / imaginary;\n+            return (Math.abs(imaginary) * Math.sqrt(1 + q*q));\n+        } else {\n+            if (real == 0.0) {\n+                return Math.abs(imaginary);\n+            }\n+            double q = imaginary / real;\n+            return (Math.abs(real) * Math.sqrt(1 + q*q));\n+        }\n+    }\n+    \n+    /**\n+     * Return the sum of this complex number and the given complex number.\n+     * <p>\n+     * Uses the definitional formula \n+     * <pre>\n+     * (a + bi) + (c + di) = (a+c) + (b+d)i\n+     * </pre></p>\n+     * <p>\n+     * If either this or <code>rhs</code> has a NaN value in either part,\n+     * {@link #NaN} is returned; otherwise Inifinite and NaN values are\n+     * returned in the parts of the result according to the rules for\n+     * {@link java.lang.Double} arithmetic.</p> \n+     *\n+     * @param rhs the other complex number\n+     * @return the complex number sum\n+     * @throws NullPointerException if <code>rhs</code> is null\n+     */\n+    public Complex add(Complex rhs) {   \n+        return createComplex(real + rhs.getReal(),\n+            imaginary + rhs.getImaginary());\n+    }\n+    \n+    /**\n+     * Return the conjugate of this complex number. The conjugate of\n+     * \"A + Bi\" is \"A - Bi\". \n+     * <p>\n+     * {@link #NaN} is returned if either the real or imaginary\n+     * part of this Complex number equals <code>Double.NaN</code>.</p>\n+     * <p>\n+     * If the imaginary part is infinite, and the real part is not NaN, \n+     * the returned value has infinite imaginary part of the opposite\n+     * sign - e.g. the conjugate of <code>1 + POSITIVE_INFINITY i</code>\n+     * is <code>1 - NEGATIVE_INFINITY i</code></p>\n+     *\n+     * @return the conjugate of this Complex object\n+     */\n+    public Complex conjugate() {\n+        if (isNaN()) {\n+            return NaN;\n+        }   \n+        return createComplex(real, -imaginary);\n+    }\n+    \n+    /**\n+     * Return the quotient of this complex number and the given complex number.\n+     * <p>\n+     * Implements the definitional formula\n+     * <pre><code>\n+     *    a + bi          ac + bd + (bc - ad)i\n+     *    ----------- = -------------------------\n+     *    c + di               c<sup>2</sup> + d<sup>2</sup>\n+     * </code></pre>\n+     * but uses \n+     * <a href=\"http://doi.acm.org/10.1145/1039813.1039814\">\n+     * prescaling of operands</a> to limit the effects of overflows and\n+     * underflows in the computation.</p>\n+     * <p>\n+     * Infinite and NaN values are handled / returned according to the\n+     * following rules, applied in the order presented:\n+     * <ul>\n+     * <li>If either this or <code>rhs</code> has a NaN value in either part,\n+     *  {@link #NaN} is returned.</li>\n+     * <li>If <code>rhs</code> equals {@link #ZERO}, {@link #NaN} is returned.\n+     * </li>\n+     * <li>If this and <code>rhs</code> are both infinite,\n+     * {@link #NaN} is returned.</li>\n+     * <li>If this is finite (i.e., has no infinite or NaN parts) and\n+     *  <code>rhs</code> is infinite (one or both parts infinite), \n+     * {@link #ZERO} is returned.</li>\n+     * <li>If this is infinite and <code>rhs</code> is finite, NaN values are\n+     * returned in the parts of the result if the {@link java.lang.Double}\n+     * rules applied to the definitional formula force NaN results.</li>\n+     * </ul></p>\n+     * \n+     * @param rhs the other complex number\n+     * @return the complex number quotient\n+     * @throws NullPointerException if <code>rhs</code> is null\n+     */\n+    public Complex divide(Complex rhs) {\n+        if (isNaN() || rhs.isNaN()) {\n+            return NaN;\n+        }\n+\n+        double c = rhs.getReal();\n+        double d = rhs.getImaginary();\n+        if (c == 0.0 && d == 0.0) {\n+            return NaN;\n+        }\n+        \n+        if (rhs.isInfinite() && !isInfinite()) {\n+            return ZERO;\n+        }\n+\n+        if (Math.abs(c) < Math.abs(d)) {\n+            if (d == 0.0) {\n+                return createComplex(real/c, imaginary/c);\n+            }\n+            double q = c / d;\n+            double denominator = c * q + d;\n+            return createComplex((real * q + imaginary) / denominator,\n+                (imaginary * q - real) / denominator);\n+        } else {\n+            if (c == 0.0) {\n+                return createComplex(imaginary/d, -real/c);\n+            }\n+            double q = d / c;\n+            double denominator = d * q + c;\n+            return createComplex((imaginary * q + real) / denominator,\n+                (imaginary - real * q) / denominator);\n+        }\n+    }\n+    \n+    /**\n+     * Test for the equality of two Complex objects.\n+     * <p>\n+     * If both the real and imaginary parts of two Complex numbers\n+     * are exactly the same, and neither is <code>Double.NaN</code>, the two\n+     * Complex objects are considered to be equal.</p>\n+     * <p>\n+     * All <code>NaN</code> values are considered to be equal - i.e, if either\n+     * (or both) real and imaginary parts of the complex number are equal\n+     * to <code>Double.NaN</code>, the complex number is equal to \n+     * <code>Complex.NaN</code>.</p>\n+     *\n+     * @param other Object to test for equality to this\n+     * @return true if two Complex objects are equal, false if\n+     *         object is null, not an instance of Complex, or\n+     *         not equal to this Complex instance\n+     * \n+     */\n+    @Override\n+    public boolean equals(Object other) {\n+        boolean ret;\n+        \n+        if (this == other) { \n+            ret = true;\n+        } else if (other == null) {\n+            ret = false;\n+        } else  {\n+            try {\n+                Complex rhs = (Complex)other;\n+                if (rhs.isNaN()) {\n+                    ret = this.isNaN();\n+                } else {\n+                    ret = (real == rhs.real) && (imaginary == rhs.imaginary); \n+                }\n+            } catch (ClassCastException ex) {\n+                // ignore exception\n+                ret = false;\n+            }\n+        }\n+      \n+        return ret;\n+    }\n+    \n+    /**\n+     * Get a hashCode for the complex number.\n+     * <p>\n+     * All NaN values have the same hash code.</p>\n+     * \n+     * @return a hash code value for this object\n+     */\n+    @Override\n+    public int hashCode() {\n+        if (isNaN()) {\n+            return 7;\n+        }\n+        return 37 * (17 * MathUtils.hash(imaginary) + \n+            MathUtils.hash(real));\n+    }\n+\n+    /**\n+     * Access the imaginary part.\n+     *\n+     * @return the imaginary part\n+     */\n+    public double getImaginary() {\n+        return imaginary;\n+    }\n+\n+    /**\n+     * Access the real part.\n+     *\n+     * @return the real part\n+     */\n+    public double getReal() {\n+        return real;\n+    }\n+    \n+    /**\n+     * Returns true if either or both parts of this complex number is NaN;\n+     * false otherwise\n+     *\n+     * @return  true if either or both parts of this complex number is NaN;\n+     * false otherwise\n+     */\n+    public boolean isNaN() {\n+        return isNaN;        \n+    }\n+    \n+    /**\n+     * Returns true if either the real or imaginary part of this complex number\n+     * takes an infinite value (either <code>Double.POSITIVE_INFINITY</code> or \n+     * <code>Double.NEGATIVE_INFINITY</code>) and neither part\n+     * is <code>NaN</code>.\n+     * \n+     * @return true if one or both parts of this complex number are infinite\n+     * and neither part is <code>NaN</code>\n+     */\n+    public boolean isInfinite() {\n+        return isInfinite;        \n+    }\n+    \n+    /**\n+     * Return the product of this complex number and the given complex number.\n+     * <p>\n+     * Implements preliminary checks for NaN and infinity followed by\n+     * the definitional formula:\n+     * <pre><code>\n+     * (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n+     * </code></pre>\n+     * </p>\n+     * <p>\n+     * Returns {@link #NaN} if either this or <code>rhs</code> has one or more\n+     * NaN parts.\n+     * </p>\n+     * Returns {@link #INF} if neither this nor <code>rhs</code> has one or more\n+     * NaN parts and if either this or <code>rhs</code> has one or more\n+     * infinite parts (same result is returned regardless of the sign of the\n+     * components).\n+     * </p>\n+     * <p>\n+     * Returns finite values in components of the result per the\n+     * definitional formula in all remaining cases.\n+     *  </p>\n+     * \n+     * @param rhs the other complex number\n+     * @return the complex number product\n+     * @throws NullPointerException if <code>rhs</code> is null\n+     */\n+    public Complex multiply(Complex rhs) {\n+        if (isNaN() || rhs.isNaN()) {\n+            return NaN;\n+        }\n+        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n+            Double.isInfinite(rhs.real)|| Double.isInfinite(rhs.imaginary)) {\n+            // we don't use Complex.isInfinite() to avoid testing for NaN again\n+            return INF;\n+        }\n+        return createComplex(real * rhs.real - imaginary * rhs.imaginary,\n+                real * rhs.imaginary + imaginary * rhs.real);\n+    }\n+    \n+    /**\n+     * Return the product of this complex number and the given scalar number.\n+     * <p>\n+     * Implements preliminary checks for NaN and infinity followed by\n+     * the definitional formula:\n+     * <pre><code>\n+     * c(a + bi) = (ca) + (cb)i\n+     * </code></pre>\n+     * </p>\n+     * <p>\n+     * Returns {@link #NaN} if either this or <code>rhs</code> has one or more\n+     * NaN parts.\n+     * </p>\n+     * Returns {@link #INF} if neither this nor <code>rhs</code> has one or more\n+     * NaN parts and if either this or <code>rhs</code> has one or more\n+     * infinite parts (same result is returned regardless of the sign of the\n+     * components).\n+     * </p>\n+     * <p>\n+     * Returns finite values in components of the result per the\n+     * definitional formula in all remaining cases.\n+     *  </p>\n+     * \n+     * @param rhs the scalar number\n+     * @return the complex number product\n+     */\n+    public Complex multiply(double rhs) {\n+        if (isNaN() || Double.isNaN(rhs)) {\n+            return NaN;\n+        }\n+        if (Double.isInfinite(real) || Double.isInfinite(imaginary) ||\n+            Double.isInfinite(rhs)) {\n+            // we don't use Complex.isInfinite() to avoid testing for NaN again\n+            return INF;\n+        }\n+        return createComplex(real * rhs, imaginary * rhs);\n+    }\n+    \n+    /**\n+     * Return the additive inverse of this complex number.\n+     * <p>\n+     * Returns <code>Complex.NaN</code> if either real or imaginary\n+     * part of this Complex number equals <code>Double.NaN</code>.</p>\n+     *\n+     * @return the negation of this complex number\n+     */\n+    public Complex negate() {\n+        if (isNaN()) {\n+            return NaN;\n+        }\n+        \n+        return createComplex(-real, -imaginary);\n+    }\n+    \n+    /**\n+     * Return the difference between this complex number and the given complex\n+     * number.\n+      * <p>\n+     * Uses the definitional formula \n+     * <pre>\n+     * (a + bi) - (c + di) = (a-c) + (b-d)i\n+     * </pre></p>\n+     * <p>\n+     * If either this or <code>rhs</code> has a NaN value in either part,\n+     * {@link #NaN} is returned; otherwise inifinite and NaN values are\n+     * returned in the parts of the result according to the rules for\n+     * {@link java.lang.Double} arithmetic. </p>\n+     * \n+     * @param rhs the other complex number\n+     * @return the complex number difference\n+     * @throws NullPointerException if <code>rhs</code> is null\n+     */\n+    public Complex subtract(Complex rhs) {\n+        if (isNaN() || rhs.isNaN()) {\n+            return NaN;\n+        }\n+        \n+        return createComplex(real - rhs.getReal(),\n+            imaginary - rhs.getImaginary());\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/InverseCosine.html\" TARGET=\"_top\">\n+     * inverse cosine</a> of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> acos(z) = -i (log(z + i (sqrt(1 - z<sup>2</sup>))))</code></pre></p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code> or infinite.</p>\n+     * \n+     * @return the inverse cosine of this complex number\n+     * @since 1.2\n+     */\n+    public Complex acos() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+\n+        return this.add(this.sqrt1z().multiply(Complex.I)).log()\n+              .multiply(Complex.I.negate());\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/InverseSine.html\" TARGET=\"_top\">\n+     * inverse sine</a> of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> asin(z) = -i (log(sqrt(1 - z<sup>2</sup>) + iz)) </code></pre></p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code> or infinite.</p>\n+     * \n+     * @return the inverse sine of this complex number.\n+     * @since 1.2\n+     */\n+    public Complex asin() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+\n+        return sqrt1z().add(this.multiply(Complex.I)).log()\n+              .multiply(Complex.I.negate());\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/InverseTangent.html\" TARGET=\"_top\">\n+     * inverse tangent</a> of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> atan(z) = (i/2) log((i + z)/(i - z)) </code></pre></p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code> or infinite.</p>\n+     * \n+     * @return the inverse tangent of this complex number\n+     * @since 1.2\n+     */\n+    public Complex atan() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        return this.add(Complex.I).divide(Complex.I.subtract(this)).log()\n+            .multiply(Complex.I.divide(createComplex(2.0, 0.0)));\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/Cosine.html\" TARGET=\"_top\">\n+     * cosine</a>\n+     * of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> cos(a + bi) = cos(a)cosh(b) - sin(a)sinh(b)i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * cos(1 &plusmn; INFINITY i) = 1 &#x2213; INFINITY i\n+     * cos(&plusmn;INFINITY + i) = NaN + NaN i\n+     * cos(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n+     * \n+     * @return the cosine of this complex number\n+     * @since 1.2\n+     */\n+    public Complex cos() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        return createComplex(Math.cos(real) * MathUtils.cosh(imaginary),\n+            -Math.sin(real) * MathUtils.sinh(imaginary));\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\" TARGET=\"_top\">\n+     * hyperbolic cosine</a> of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> cosh(a + bi) = cosh(a)cos(b) + sinh(a)sin(b)i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * cosh(1 &plusmn; INFINITY i) = NaN + NaN i\n+     * cosh(&plusmn;INFINITY + i) = INFINITY &plusmn; INFINITY i\n+     * cosh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n+     * \n+     * @return the hyperbolic cosine of this complex number.\n+     * @since 1.2\n+     */\n+    public Complex cosh() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        return createComplex(MathUtils.cosh(real) * Math.cos(imaginary),\n+            MathUtils.sinh(real) * Math.sin(imaginary));\n+    }\n+    \n+    /**\n+     * Compute the\n+     * <a href=\"http://mathworld.wolfram.com/ExponentialFunction.html\" TARGET=\"_top\">\n+     * exponential function</a> of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> exp(a + bi) = exp(a)cos(b) + exp(a)sin(b)i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#exp}, {@link java.lang.Math#cos}, and\n+     * {@link java.lang.Math#sin}.</p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * exp(1 &plusmn; INFINITY i) = NaN + NaN i\n+     * exp(INFINITY + i) = INFINITY + INFINITY i\n+     * exp(-INFINITY + i) = 0 + 0i\n+     * exp(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n+     * \n+     * @return <i>e</i><sup><code>this</code></sup>\n+     * @since 1.2\n+     */\n+    public Complex exp() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double expReal = Math.exp(real);\n+        return createComplex(expReal *  Math.cos(imaginary), expReal * Math.sin(imaginary));\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/NaturalLogarithm.html\" TARGET=\"_top\">\n+     * natural logarithm</a> of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> log(a + bi) = ln(|a + bi|) + arg(a + bi)i</code></pre>\n+     * where ln on the right hand side is {@link java.lang.Math#log},\n+     * <code>|a + bi|</code> is the modulus, {@link Complex#abs},  and\n+     * <code>arg(a + bi) = {@link java.lang.Math#atan2}(b, a)</code></p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n+     * <p>\n+     * Infinite (or critical) values in real or imaginary parts of the input may\n+     * result in infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * log(1 &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/2)i\n+     * log(INFINITY + i) = INFINITY + 0i\n+     * log(-INFINITY + i) = INFINITY + &pi;i\n+     * log(INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (&pi;/4)i\n+     * log(-INFINITY &plusmn; INFINITY i) = INFINITY &plusmn; (3&pi;/4)i\n+     * log(0 + 0i) = -INFINITY + 0i\n+     * </code></pre></p>\n+     * \n+     * @return ln of this complex number.\n+     * @since 1.2\n+     */\n+    public Complex log() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+\n+        return createComplex(Math.log(abs()),\n+            Math.atan2(imaginary, real));        \n+    }\n+    \n+    /**\n+     * Returns of value of this complex number raised to the power of <code>x</code>.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> y<sup>x</sup> = exp(x&middot;log(y))</code></pre> \n+     * where <code>exp</code> and <code>log</code> are {@link #exp} and\n+     * {@link #log}, respectively.</p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code> or infinite, or if <code>y</code>\n+     * equals {@link Complex#ZERO}.</p>\n+     * \n+     * @param x the exponent.\n+     * @return <code>this</code><sup><code>x</code></sup>\n+     * @throws NullPointerException if x is null\n+     * @since 1.2\n+     */\n+    public Complex pow(Complex x) {\n+        if (x == null) {\n+            throw new NullPointerException();\n+        }\n+        return this.log().multiply(x).exp();\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/Sine.html\" TARGET=\"_top\">\n+     * sine</a>\n+     * of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> sin(a + bi) = sin(a)cosh(b) - cos(a)sinh(b)i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * sin(1 &plusmn; INFINITY i) = 1 &plusmn; INFINITY i\n+     * sin(&plusmn;INFINITY + i) = NaN + NaN i\n+     * sin(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n+     * \n+     * @return the sine of this complex number.\n+     * @since 1.2\n+     */\n+    public Complex sin() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        return createComplex(Math.sin(real) * MathUtils.cosh(imaginary),\n+            Math.cos(real) * MathUtils.sinh(imaginary));\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\" TARGET=\"_top\">\n+     * hyperbolic sine</a> of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code> sinh(a + bi) = sinh(a)cos(b)) + cosh(a)sin(b)i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * sinh(1 &plusmn; INFINITY i) = NaN + NaN i\n+     * sinh(&plusmn;INFINITY + i) = &plusmn; INFINITY + INFINITY i\n+     * sinh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i</code></pre></p>\n+     * \n+     * @return the hyperbolic sine of this complex number\n+     * @since 1.2\n+     */\n+    public Complex sinh() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        return createComplex(MathUtils.sinh(real) * Math.cos(imaginary),\n+            MathUtils.cosh(real) * Math.sin(imaginary));\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n+     * square root</a> of this complex number.\n+     * <p>\n+     * Implements the following algorithm to compute <code>sqrt(a + bi)</code>: \n+     * <ol><li>Let <code>t = sqrt((|a| + |a + bi|) / 2)</code></li>\n+     * <li><pre>if <code> a &#8805; 0</code> return <code>t + (b/2t)i</code>\n+     *  else return <code>|b|/2t + sign(b)t i </code></pre></li>\n+     * </ol>\n+     * where <ul>\n+     * <li><code>|a| = {@link Math#abs}(a)</code></li>\n+     * <li><code>|a + bi| = {@link Complex#abs}(a + bi) </code></li>\n+     * <li><code>sign(b) =  {@link MathUtils#indicator}(b) </code>\n+     * </ul></p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * sqrt(1 &plusmn; INFINITY i) = INFINITY + NaN i\n+     * sqrt(INFINITY + i) = INFINITY + 0i\n+     * sqrt(-INFINITY + i) = 0 + INFINITY i\n+     * sqrt(INFINITY &plusmn; INFINITY i) = INFINITY + NaN i\n+     * sqrt(-INFINITY &plusmn; INFINITY i) = NaN &plusmn; INFINITY i\n+     * </code></pre></p>\n+     * \n+     * @return the square root of this complex number\n+     * @since 1.2\n+     */\n+    public Complex sqrt() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        if (real == 0.0 && imaginary == 0.0) {\n+            return createComplex(0.0, 0.0);\n+        }\n+        \n+        double t = Math.sqrt((Math.abs(real) + abs()) / 2.0);\n+        if (real >= 0.0) {\n+            return createComplex(t, imaginary / (2.0 * t));\n+        } else {\n+            return createComplex(Math.abs(imaginary) / (2.0 * t),\n+                MathUtils.indicator(imaginary) * t);\n+        }\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/SquareRoot.html\" TARGET=\"_top\">\n+     * square root</a> of 1 - <code>this</code><sup>2</sup> for this complex\n+     * number.\n+     * <p>\n+     * Computes the result directly as \n+     * <code>sqrt(Complex.ONE.subtract(z.multiply(z)))</code>.</p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.</p>\n+     * \n+     * @return the square root of 1 - <code>this</code><sup>2</sup>\n+     * @since 1.2\n+     */\n+    public Complex sqrt1z() {\n+        return createComplex(1.0, 0.0).subtract(this.multiply(this)).sqrt();\n+    }\n+    \n+    /**\n+     * Compute the \n+     * <a href=\"http://mathworld.wolfram.com/Tangent.html\" TARGET=\"_top\">\n+     * tangent</a> of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code>tan(a + bi) = sin(2a)/(cos(2a)+cosh(2b)) + [sinh(2b)/(cos(2a)+cosh(2b))]i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n+     * <p>\n+     * Infinite (or critical) values in real or imaginary parts of the input may\n+     * result in infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * tan(1 &plusmn; INFINITY i) = 0 + NaN i\n+     * tan(&plusmn;INFINITY + i) = NaN + NaN i\n+     * tan(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n+     * tan(&plusmn;&pi;/2 + 0 i) = &plusmn;INFINITY + NaN i</code></pre></p>\n+     * \n+     * @return the tangent of this complex number\n+     * @since 1.2\n+     */\n+    public Complex tan() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double real2 = 2.0 * real;\n+        double imaginary2 = 2.0 * imaginary;\n+        double d = Math.cos(real2) + MathUtils.cosh(imaginary2);\n+        \n+        return createComplex(Math.sin(real2) / d, MathUtils.sinh(imaginary2) / d);\n+    }\n+    \n+    /**\n+     * Compute the\n+     * <a href=\"http://mathworld.wolfram.com/HyperbolicTangent.html\" TARGET=\"_top\">\n+     * hyperbolic tangent</a> of this complex number.\n+     * <p>\n+     * Implements the formula: <pre>\n+     * <code>tan(a + bi) = sinh(2a)/(cosh(2a)+cos(2b)) + [sin(2b)/(cosh(2a)+cos(2b))]i</code></pre>\n+     * where the (real) functions on the right-hand side are\n+     * {@link java.lang.Math#sin}, {@link java.lang.Math#cos}, \n+     * {@link MathUtils#cosh} and {@link MathUtils#sinh}.</p>\n+     * <p>\n+     * Returns {@link Complex#NaN} if either real or imaginary part of the \n+     * input argument is <code>NaN</code>.</p>\n+     * <p>\n+     * Infinite values in real or imaginary parts of the input may result in\n+     * infinite or NaN values returned in parts of the result.<pre>\n+     * Examples: \n+     * <code>\n+     * tanh(1 &plusmn; INFINITY i) = NaN + NaN i\n+     * tanh(&plusmn;INFINITY + i) = NaN + 0 i\n+     * tanh(&plusmn;INFINITY &plusmn; INFINITY i) = NaN + NaN i\n+     * tanh(0 + (&pi;/2)i) = NaN + INFINITY i</code></pre></p>\n+     *\n+     * @return the hyperbolic tangent of this complex number\n+     * @since 1.2\n+     */\n+    public Complex tanh() {\n+        if (isNaN()) {\n+            return Complex.NaN;\n+        }\n+        \n+        double real2 = 2.0 * real;\n+        double imaginary2 = 2.0 * imaginary;\n+        double d = MathUtils.cosh(real2) + Math.cos(imaginary2);\n+        \n+        return createComplex(MathUtils.sinh(real2) / d, Math.sin(imaginary2) / d);\n+    }\n+    \n+    \n+    \n+    /**\n+     * <p>Compute the argument of this complex number.\n+     * </p>\n+     * <p>The argument is the angle phi between the positive real axis and the point\n+     * representing this number in the complex plane. The value returned is between -PI (not inclusive) \n+     * and PI (inclusive), with negative values returned for numbers with negative imaginary parts.\n+     * </p>\n+     * <p>If either real or imaginary part (or both) is NaN, NaN is returned.  Infinite parts are handled\n+     * as java.Math.atan2 handles them, essentially treating finite parts as zero in the presence of\n+     * an infinite coordinate and returning a multiple of pi/4 depending on the signs of the infinite\n+     * parts.  See the javadoc for java.Math.atan2 for full details.</p>\n+     * \n+     * @return the argument of this complex number\n+     */\n+    public double getArgument() {\n+        return Math.atan2(getImaginary(), getReal());\n+    }\n+    \n+    /**\n+     * <p>Computes the n-th roots of this complex number.\n+     * </p>\n+     * <p>The nth roots are defined by the formula: <pre>\n+     * <code> z<sub>k</sub> = abs<sup> 1/n</sup> (cos(phi + 2&pi;k/n) + i (sin(phi + 2&pi;k/n))</code></pre>\n+     * for <i><code>k=0, 1, ..., n-1</code></i>, where <code>abs</code> and <code>phi</code> are\n+     * respectively the {@link #abs() modulus} and {@link #getArgument() argument} of this complex number.\n+     * </p>\n+     * <p>If one or both parts of this complex number is NaN, a list with just one element,\n+     *  {@link #NaN} is returned.</p>\n+     * <p>if neither part is NaN, but at least one part is infinite, the result is a one-element\n+     * list containing {@link #INF}.</p>\n+     * \n+     * @param n degree of root\n+     * @return List<Complex> all nth roots of this complex number\n+     * @throws IllegalArgumentException if parameter n is less than or equal to 0\n+     * @since 2.0\n+     */\n+    public List<Complex> nthRoot(int n) throws IllegalArgumentException {\n+\n+        if (n <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"cannot compute nth root for null or negative n: {0}\",\n+                    n);\n+        }\n+        \n+        List<Complex> result = new ArrayList<Complex>();\n+        \n+        if (isNaN()) {\n+            result.add(Complex.NaN);\n+            return result;\n+        }\n+        \n+        if (isInfinite()) {\n+            result.add(Complex.INF);\n+            return result;\n+        }\n+\n+        // nth root of abs -- faster / more accurate to use a solver here?\n+        final double nthRootOfAbs = Math.pow(abs(), 1.0 / n);\n+\n+        // Compute nth roots of complex number with k = 0, 1, ... n-1\n+        final double nthPhi = getArgument()/n;\n+        final double slice = 2 * Math.PI / n;\n+        double innerPart = nthPhi;\n+        for (int k = 0; k < n ; k++) {\n+            // inner part\n+            final double realPart      = nthRootOfAbs *  Math.cos(innerPart);\n+            final double imaginaryPart = nthRootOfAbs *  Math.sin(innerPart);\n+            result.add(createComplex(realPart, imaginaryPart));\n+            innerPart += slice;\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Create a complex number given the real and imaginary parts.\n+     *\n+     * @param real the real part\n+     * @param imaginary the imaginary part\n+     * @return a new complex number instance\n+     * @since 1.2\n+     */\n+    protected Complex createComplex(double real, double imaginary) {\n+        return new Complex(real, imaginary);\n+    }\n+\n+    /**\n+     * <p>Resolve the transient fields in a deserialized Complex Object.</p>\n+     * <p>Subclasses will need to override {@link #createComplex} to deserialize properly</p> \n+     * @return A Complex instance with all fields resolved.\n+     * @since 2.0\n+     */\n+    protected final Object readResolve() {\n+        return createComplex(real, imaginary);\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public ComplexField getField() {\n+        return ComplexField.getInstance();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/complex/ComplexField.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.complex;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.Field;\n+\n+/**\n+ * Representation of the complex numbers field.\n+ * <p>\n+ * This class is a singleton.\n+ * </p>\n+ * @see Complex\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class ComplexField implements Field<Complex>, Serializable  {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -6130362688700788798L;\n+\n+    /** Private constructor for the singleton.\n+     */\n+    private ComplexField() {\n+    }\n+\n+    /** Get the unique instance.\n+     * @return the unique instance\n+     */\n+    public static ComplexField getInstance() {\n+        return LazyHolder.INSTANCE;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Complex getOne() {\n+        return Complex.ONE;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Complex getZero() {\n+        return Complex.ZERO;\n+    }\n+\n+    /** Holder for the instance.\n+     * <p>We use here the Initialization On Demand Holder Idiom.</p>\n+     */\n+    private static class LazyHolder {\n+        /** Cached field instance. */\n+        private static final ComplexField INSTANCE = new ComplexField();\n+    }\n+\n+    /** Handle deserialization of the singleton.\n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        // return the singleton instance\n+        return LazyHolder.INSTANCE; \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/complex/ComplexFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.complex;\n+\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.CompositeFormat;\n+\n+/**\n+ * Formats a Complex number in cartesian format \"Re(c) + Im(c)i\".  'i' can\n+ * be replaced with 'j' (or anything else), and the number format for both real\n+ * and imaginary parts can be configured.\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Revision$ $Date$\n+ */\n+public class ComplexFormat extends CompositeFormat {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -3343698360149467646L;\n+\n+     /** The default imaginary character. */\n+    private static final String DEFAULT_IMAGINARY_CHARACTER = \"i\";\n+    \n+    /** The notation used to signify the imaginary part of the complex number. */\n+    private String imaginaryCharacter;\n+    \n+    /** The format used for the imaginary part. */\n+    private NumberFormat imaginaryFormat;\n+\n+    /** The format used for the real part. */\n+    private NumberFormat realFormat;\n+    \n+    /**\n+     * Create an instance with the default imaginary character, 'i', and the\n+     * default number format for both real and imaginary parts.\n+     */\n+    public ComplexFormat() {\n+        this(DEFAULT_IMAGINARY_CHARACTER, getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with a custom number format for both real and\n+     * imaginary parts.\n+     * @param format the custom format for both real and imaginary parts.\n+     */\n+    public ComplexFormat(NumberFormat format) {\n+        this(DEFAULT_IMAGINARY_CHARACTER, format);\n+    }\n+    \n+    /**\n+     * Create an instance with a custom number format for the real part and a\n+     * custom number format for the imaginary part.\n+     * @param realFormat the custom format for the real part.\n+     * @param imaginaryFormat the custom format for the imaginary part.\n+     */\n+    public ComplexFormat(NumberFormat realFormat, NumberFormat imaginaryFormat) {\n+        this(DEFAULT_IMAGINARY_CHARACTER, realFormat, imaginaryFormat);\n+    }\n+    \n+    /**\n+     * Create an instance with a custom imaginary character, and the default\n+     * number format for both real and imaginary parts.\n+     * @param imaginaryCharacter The custom imaginary character.\n+     */\n+    public ComplexFormat(String imaginaryCharacter) {\n+        this(imaginaryCharacter, getDefaultNumberFormat());\n+    }\n+    \n+    /**\n+     * Create an instance with a custom imaginary character, and a custom number\n+     * format for both real and imaginary parts.\n+     * @param imaginaryCharacter The custom imaginary character.\n+     * @param format the custom format for both real and imaginary parts.\n+     */\n+    public ComplexFormat(String imaginaryCharacter, NumberFormat format) {\n+        this(imaginaryCharacter, format, (NumberFormat)format.clone());\n+    }\n+    \n+    /**\n+     * Create an instance with a custom imaginary character, a custom number\n+     * format for the real part, and a custom number format for the imaginary\n+     * part.\n+     * @param imaginaryCharacter The custom imaginary character.\n+     * @param realFormat the custom format for the real part.\n+     * @param imaginaryFormat the custom format for the imaginary part.\n+     */\n+    public ComplexFormat(String imaginaryCharacter, NumberFormat realFormat,\n+            NumberFormat imaginaryFormat) {\n+        super();\n+        setImaginaryCharacter(imaginaryCharacter);\n+        setImaginaryFormat(imaginaryFormat);\n+        setRealFormat(realFormat);\n+    }\n+\n+    /**\n+     * Get the set of locales for which complex formats are available.\n+     * <p>This is the same set as the {@link NumberFormat} set.</p> \n+     * @return available complex format locales.\n+     */\n+    public static Locale[] getAvailableLocales() {\n+        return NumberFormat.getAvailableLocales();\n+    }\n+\n+    /**\n+     * This static method calls {@link #format(Object)} on a default instance of\n+     * ComplexFormat.\n+     *\n+     * @param c Complex object to format\n+     * @return A formatted number in the form \"Re(c) + Im(c)i\"\n+     */\n+    public static String formatComplex(Complex c) {\n+        return getInstance().format(c);\n+    }\n+    \n+    /**\n+     * Formats a {@link Complex} object to produce a string.\n+     *\n+     * @param complex the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(Complex complex, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        \n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        // format real\n+        double re = complex.getReal();\n+        formatDouble(re, getRealFormat(), toAppendTo, pos);\n+        \n+        // format sign and imaginary\n+        double im = complex.getImaginary();\n+        if (im < 0.0) {\n+            toAppendTo.append(\" - \");\n+            formatDouble(-im, getImaginaryFormat(), toAppendTo, pos);\n+            toAppendTo.append(getImaginaryCharacter());\n+        } else if (im > 0.0 || Double.isNaN(im)) {\n+            toAppendTo.append(\" + \");\n+            formatDouble(im, getImaginaryFormat(), toAppendTo, pos);\n+            toAppendTo.append(getImaginaryCharacter());\n+        }\n+        \n+        return toAppendTo;\n+    }\n+    \n+    /**\n+     * Formats a object to produce a string.  <code>obj</code> must be either a \n+     * {@link Complex} object or a {@link Number} object.  Any other type of\n+     * object will result in an {@link IllegalArgumentException} being thrown.\n+     *\n+     * @param obj the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n+     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n+     */\n+    @Override\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        \n+        StringBuffer ret = null;\n+        \n+        if (obj instanceof Complex) {\n+            ret = format( (Complex)obj, toAppendTo, pos);\n+        } else if (obj instanceof Number) {\n+            ret = format( new Complex(((Number)obj).doubleValue(), 0.0),\n+                toAppendTo, pos);\n+        } else { \n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"cannot format a {0} instance as a complex number\",\n+                  obj.getClass().getName());\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Access the imaginaryCharacter.\n+     * @return the imaginaryCharacter.\n+     */\n+    public String getImaginaryCharacter() {\n+        return imaginaryCharacter;\n+    }\n+    \n+    /**\n+     * Access the imaginaryFormat.\n+     * @return the imaginaryFormat.\n+     */\n+    public NumberFormat getImaginaryFormat() {\n+        return imaginaryFormat;\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the current locale.\n+     * @return the default complex format.\n+     */\n+    public static ComplexFormat getInstance() {\n+        return getInstance(Locale.getDefault());\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the complex format specific to the given locale.\n+     */\n+    public static ComplexFormat getInstance(Locale locale) {\n+        NumberFormat f = getDefaultNumberFormat(locale);\n+        return new ComplexFormat(f);\n+    }\n+    \n+    /**\n+     * Access the realFormat.\n+     * @return the realFormat.\n+     */\n+    public NumberFormat getRealFormat() {\n+        return realFormat;\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link Complex} object.\n+     *\n+     * @param source the string to parse\n+     * @return the parsed {@link Complex} object.\n+     * @exception ParseException if the beginning of the specified string\n+     *            cannot be parsed.\n+     */\n+    public Complex parse(String source) throws ParseException {\n+        ParsePosition parsePosition = new ParsePosition(0);\n+        Complex result = parse(source, parsePosition);\n+        if (parsePosition.getIndex() == 0) {\n+            throw MathRuntimeException.createParseException(\n+                    parsePosition.getErrorIndex(),\n+                    \"unparseable complex number: \\\"{0}\\\"\", source);\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Parses a string to produce a {@link Complex} object.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link Complex} object.\n+     */\n+    public Complex parse(String source, ParsePosition pos) {\n+        int initialIndex = pos.getIndex();\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse real\n+        Number re = parseNumber(source, getRealFormat(), pos);\n+        if (re == null) {\n+            // invalid real number\n+            // set index back to initial, error index should already be set\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse sign\n+        int startIndex = pos.getIndex();\n+        char c = parseNextCharacter(source, pos);\n+        int sign = 0;\n+        switch (c) {\n+        case 0 :\n+            // no sign\n+            // return real only complex number\n+            return new Complex(re.doubleValue(), 0.0);\n+        case '-' :\n+            sign = -1;\n+            break;\n+        case '+' :\n+            sign = 1;\n+            break;\n+        default :\n+            // invalid sign\n+            // set index back to initial, error index should be the last\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            pos.setErrorIndex(startIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse imaginary\n+        Number im = parseNumber(source, getRealFormat(), pos);\n+        if (im == null) {\n+            // invalid imaginary number\n+            // set index back to initial, error index should already be set\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse imaginary character\n+        if (!parseFixedstring(source, getImaginaryCharacter(), pos)) {\n+            return null;\n+        }\n+\n+        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n+\n+    }\n+     \n+    /**\n+     * Parses a string to produce a object.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed object.\n+     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n+     */\n+    @Override\n+    public Object parseObject(String source, ParsePosition pos) {\n+        return parse(source, pos);\n+    }\n+\n+    /**\n+     * Modify the imaginaryCharacter.\n+     * @param imaginaryCharacter The new imaginaryCharacter value.\n+     * @throws IllegalArgumentException if <code>imaginaryCharacter</code> is\n+     *         <code>null</code> or an empty string.\n+     */\n+    public void setImaginaryCharacter(String imaginaryCharacter) {\n+        if (imaginaryCharacter == null || imaginaryCharacter.length() == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"empty string for imaginary character\");\n+        }\n+        this.imaginaryCharacter = imaginaryCharacter;\n+    }\n+    \n+    /**\n+     * Modify the imaginaryFormat.\n+     * @param imaginaryFormat The new imaginaryFormat value.\n+     * @throws IllegalArgumentException if <code>imaginaryFormat</code> is\n+     *         <code>null</code>.\n+     */\n+    public void setImaginaryFormat(NumberFormat imaginaryFormat) {\n+        if (imaginaryFormat == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"null imaginary format\");\n+        }\n+        this.imaginaryFormat = imaginaryFormat;\n+    }\n+    \n+    /**\n+     * Modify the realFormat.\n+     * @param realFormat The new realFormat value.\n+     * @throws IllegalArgumentException if <code>realFormat</code> is\n+     *         <code>null</code>.\n+     */\n+    public void setRealFormat(NumberFormat realFormat) {\n+        if (realFormat == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"null real format\");\n+        }\n+        this.realFormat = realFormat;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/complex/ComplexUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.complex;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Static implementations of common \n+ * {@link org.apache.commons.math.complex.Complex} utilities functions.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class ComplexUtils {\n+    \n+    /**\n+     * Default constructor.\n+     */\n+    private ComplexUtils() {\n+        super();\n+    }\n+    \n+    /**\n+     * Creates a complex number from the given polar representation.\n+     * <p>\n+     * The value returned is <code>r&middot;e<sup>i&middot;theta</sup></code>,\n+     * computed as <code>r&middot;cos(theta) + r&middot;sin(theta)i</code></p>\n+     * <p>\n+     * If either <code>r</code> or <code>theta</code> is NaN, or \n+     * <code>theta</code> is infinite, {@link Complex#NaN} is returned.</p>\n+     * <p>\n+     * If <code>r</code> is infinite and <code>theta</code> is finite, \n+     * infinite or NaN values may be returned in parts of the result, following\n+     * the rules for double arithmetic.<pre>\n+     * Examples: \n+     * <code>\n+     * polar2Complex(INFINITY, &pi;/4) = INFINITY + INFINITY i\n+     * polar2Complex(INFINITY, 0) = INFINITY + NaN i\n+     * polar2Complex(INFINITY, -&pi;/4) = INFINITY - INFINITY i\n+     * polar2Complex(INFINITY, 5&pi;/4) = -INFINITY - INFINITY i </code></pre></p>\n+     * \n+     * @param r the modulus of the complex number to create\n+     * @param theta  the argument of the complex number to create\n+     * @return <code>r&middot;e<sup>i&middot;theta</sup></code>\n+     * @throws IllegalArgumentException  if r is negative\n+     * @since 1.1\n+     */\n+    public static Complex polar2Complex(double r, double theta) {\n+        if (r < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"negative complex module {0}\", r);\n+        }\n+        return new Complex(r * Math.cos(theta), r * Math.sin(theta));\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n+\n+/**\n+ * Base class for continuous distributions.  Default implementations are\n+ * provided for some of the methods that do not vary from distribution to\n+ * distribution.\n+ *  \n+ * @version $Revision$ $Date$\n+ */\n+public abstract class AbstractContinuousDistribution\n+    extends AbstractDistribution\n+    implements ContinuousDistribution, Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -38038050983108802L;\n+    \n+    /**\n+     * Default constructor.\n+     */\n+    protected AbstractContinuousDistribution() {\n+        super();\n+    }\n+\n+    /**\n+     * For this distribution, X, this method returns the critical point x, such\n+     * that P(X &lt; x) = <code>p</code>.\n+     *\n+     * @param p the desired probability\n+     * @return x, such that P(X &lt; x) = <code>p</code>\n+     * @throws MathException if the inverse cumulative probability can not be\n+     *         computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if <code>p</code> is not a valid\n+     *         probability.\n+     */\n+    public double inverseCumulativeProbability(final double p)\n+        throws MathException {\n+        if (p < 0.0 || p > 1.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n+        }\n+\n+        // by default, do simple root finding using bracketing and default solver.\n+        // subclasses can override if there is a better method.\n+        UnivariateRealFunction rootFindingFunction =\n+            new UnivariateRealFunction() {\n+            public double value(double x) throws FunctionEvaluationException {\n+                try {\n+                    return cumulativeProbability(x) - p;\n+                } catch (MathException ex) {\n+                    throw new FunctionEvaluationException(ex, x, ex.getPattern(), ex.getArguments());\n+                }\n+            }\n+        };\n+              \n+        // Try to bracket root, test domain endoints if this fails     \n+        double lowerBound = getDomainLowerBound(p);\n+        double upperBound = getDomainUpperBound(p);\n+        double[] bracket = null;\n+        try {\n+            bracket = UnivariateRealSolverUtils.bracket(\n+                    rootFindingFunction, getInitialDomain(p),\n+                    lowerBound, upperBound);\n+        }  catch (ConvergenceException ex) {\n+            /* \n+             * Check domain endpoints to see if one gives value that is within\n+             * the default solver's defaultAbsoluteAccuracy of 0 (will be the\n+             * case if density has bounded support and p is 0 or 1).\n+             * \n+             * TODO: expose the default solver, defaultAbsoluteAccuracy as\n+             * a constant.\n+             */ \n+            if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) {\n+                return lowerBound;\n+            }\n+            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) {\n+                return upperBound;\n+            }     \n+            // Failed bracket convergence was not because of corner solution\n+            throw new MathException(ex);\n+        }\n+\n+        // find root\n+        double root = UnivariateRealSolverUtils.solve(rootFindingFunction,\n+                bracket[0],bracket[1]);\n+        return root;\n+    }\n+\n+    /**\n+     * Access the initial domain value, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return initial domain value\n+     */\n+    protected abstract double getInitialDomain(double p);\n+\n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     */\n+    protected abstract double getDomainLowerBound(double p);\n+\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    protected abstract double getDomainUpperBound(double p);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Base class for probability distributions.   \n+ *  \n+ * @version $Revision$ $Date$\n+ */\n+public abstract class AbstractDistribution\n+    implements Distribution, Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -38038050983108802L;\n+    \n+    /**\n+     * Default constructor.\n+     */\n+    protected AbstractDistribution() {\n+        super();\n+    }\n+\n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(x0 &le; X &le; x1).\n+     * <p>\n+     * The default implementation uses the identity</p>\n+     * <p>\n+     * P(x0 &le; X &le; x1) = P(X &le; x1) - P(X &le; x0) </p>\n+     * \n+     * @param x0 the (inclusive) lower bound\n+     * @param x1 the (inclusive) upper bound\n+     * @return the probability that a random variable with this distribution\n+     * will take a value between <code>x0</code> and <code>x1</code>,\n+     * including the endpoints.\n+     * @throws MathException if the cumulative probability can not be\n+     * computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if <code>x0 > x1</code>\n+     */\n+    public double cumulativeProbability(double x0, double x1)\n+        throws MathException {\n+        if (x0 > x1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"lower endpoint ({0}) must be less than or equal to upper endpoint ({1})\",\n+                  x0, x1);\n+        }\n+        return cumulativeProbability(x1) - cumulativeProbability(x0);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n+\n+\n+/**\n+ * Base class for integer-valued discrete distributions.  Default\n+ * implementations are provided for some of the methods that do not vary\n+ * from distribution to distribution.\n+ *  \n+ * @version $Revision$ $Date$\n+ */\n+public abstract class AbstractIntegerDistribution extends AbstractDistribution\n+    implements IntegerDistribution, Serializable {\n+        \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -1146319659338487221L;\n+    \n+    /**\n+     * Default constructor.\n+     */\n+    protected AbstractIntegerDistribution() {\n+        super();\n+    }\n+    \n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(X &le; x).  In other words,\n+     * this method represents the  (cumulative) distribution function, or\n+     * CDF, for this distribution.\n+     * <p>\n+     * If <code>x</code> does not represent an integer value, the CDF is \n+     * evaluated at the greatest integer less than x.\n+     * \n+     * @param x the value at which the distribution function is evaluated.\n+     * @return cumulative probability that a random variable with this\n+     * distribution takes a value less than or equal to <code>x</code>\n+     * @throws MathException if the cumulative probability can not be\n+     * computed due to convergence or other numerical errors.\n+     */\n+    public double cumulativeProbability(double x) throws MathException {\n+        return cumulativeProbability((int) Math.floor(x));  \n+    }\n+    \n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(x0 &le; X &le; x1).\n+     * \n+     * @param x0 the (inclusive) lower bound\n+     * @param x1 the (inclusive) upper bound\n+     * @return the probability that a random variable with this distribution\n+     * will take a value between <code>x0</code> and <code>x1</code>,\n+     * including the endpoints.\n+     * @throws MathException if the cumulative probability can not be\n+     * computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if <code>x0 > x1</code>\n+     */\n+    @Override\n+    public double cumulativeProbability(double x0, double x1)\n+        throws MathException {\n+        if (x0 > x1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"lower endpoint ({0}) must be less than or equal to upper endpoint ({1})\",\n+                  x0, x1);\n+        }\n+        if (Math.floor(x0) < x0) {\n+            return cumulativeProbability(((int) Math.floor(x0)) + 1,\n+               (int) Math.floor(x1)); // don't want to count mass below x0\n+        } else { // x0 is mathematical integer, so use as is\n+            return cumulativeProbability((int) Math.floor(x0),\n+                (int) Math.floor(x1)); \n+        }\n+    }\n+    \n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(X &le; x).  In other words,\n+     * this method represents the probability distribution function, or PDF,\n+     * for this distribution.\n+     * \n+     * @param x the value at which the PDF is evaluated.\n+     * @return PDF for this distribution. \n+     * @throws MathException if the cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     */\n+    abstract public double cumulativeProbability(int x) throws MathException;\n+    \n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(X = x). In other words, this\n+     * method represents the probability mass function,  or PMF, for the distribution.\n+     * <p>\n+     * If <code>x</code> does not represent an integer value, 0 is returned.\n+     * \n+     * @param x the value at which the probability density function is evaluated\n+     * @return the value of the probability density function at x\n+     */\n+    public double probability(double x) {\n+        double fl = Math.floor(x);\n+        if (fl == x) {\n+            return this.probability((int) x);\n+        } else {\n+            return 0;\n+        }\n+    }\n+    \n+    /**\n+    * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(x0 &le; X &le; x1).\n+     * \n+     * @param x0 the inclusive, lower bound\n+     * @param x1 the inclusive, upper bound\n+     * @return the cumulative probability. \n+     * @throws MathException if the cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if x0 > x1\n+     */\n+    public double cumulativeProbability(int x0, int x1) throws MathException {\n+        if (x0 > x1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"lower endpoint ({0}) must be less than or equal to upper endpoint ({1})\",\n+                  x0, x1);\n+        }\n+        return cumulativeProbability(x1) - cumulativeProbability(x0 - 1);\n+    }\n+    \n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns the largest x, such\n+     * that P(X &le; x) &le; <code>p</code>.\n+     *\n+     * @param p the desired probability\n+     * @return the largest x such that P(X &le; x) <= p\n+     * @throws MathException if the inverse cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if p < 0 or p > 1\n+     */\n+    public int inverseCumulativeProbability(final double p) throws MathException{\n+        if (p < 0.0 || p > 1.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n+        }\n+        \n+        // by default, do simple bisection.\n+        // subclasses can override if there is a better method.\n+        int x0 = getDomainLowerBound(p);\n+        int x1 = getDomainUpperBound(p);\n+        double pm;\n+        while (x0 < x1) {\n+            int xm = x0 + (x1 - x0) / 2;\n+            pm = cumulativeProbability(xm);\n+            if (pm > p) {\n+                // update x1\n+                if (xm == x1) {\n+                    // this can happen with integer division\n+                    // simply decrement x1\n+                    --x1;\n+                } else {\n+                    // update x1 normally\n+                    x1 = xm;\n+                }\n+            } else {\n+                // update x0\n+                if (xm == x0) {\n+                    // this can happen with integer division\n+                    // simply increment x0\n+                    ++x0;\n+                } else {\n+                    // update x0 normally\n+                    x0 = xm;\n+                }\n+            }\n+        }\n+        \n+        // insure x0 is the correct critical point\n+        pm = cumulativeProbability(x0);\n+        while (pm > p) {\n+            --x0;\n+            pm = cumulativeProbability(x0);\n+        }\n+    \n+        return x0;        \n+    }\n+    \n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a PDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     */\n+    protected abstract int getDomainLowerBound(double p);\n+    \n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a PDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    protected abstract int getDomainUpperBound(double p);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/BetaDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Computes the cumulative, inverse cumulative and density functions for the beta distribuiton.\n+ *\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Beta_distribution\">Beta_distribution</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface BetaDistribution extends ContinuousDistribution, HasDensity<Double> {\n+    /**\n+      * Modify the shape parameter, alpha.\n+      * @param alpha the new shape parameter.\n+      */\n+     void setAlpha(double alpha);\n+\n+     /**\n+      * Access the shape parameter, alpha\n+      * @return alpha.\n+      */\n+     double getAlpha();\n+\n+     /**\n+      * Modify the shape parameter, beta.\n+      * @param beta the new scale parameter.\n+      */\n+     void setBeta(double beta);\n+\n+     /**\n+      * Access the shape parameter, beta\n+      * @return beta.\n+      */\n+     double getBeta();\n+\n+     /**\n+      * Return the probability density for a particular point.\n+      * @param x  The point at which the density should be computed.\n+      * @return  The pdf at point x.\n+      * @exception MathException if probability density cannot be computed\n+      */\n+     double density(Double x) throws MathException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.special.Gamma;\n+import org.apache.commons.math.special.Beta;\n+\n+/**\n+ * Implements the Beta distribution.\n+ * <p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://en.wikipedia.org/wiki/Beta_distribution\">\n+ * Beta distribution</a></li>\n+ * </ul>\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class BetaDistributionImpl\n+    extends AbstractContinuousDistribution implements BetaDistribution {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -1221965979403477668L;\n+\n+    /** First shape parameter. */\n+    private double alpha;\n+\n+    /** Second shape parameter. */\n+    private double beta;\n+\n+    /** Normalizing factor used in density computations.\n+     * updated whenever alpha or beta are changed.\n+     */\n+    private double z;\n+\n+    /**\n+     * Build a new instance.\n+     * @param alpha first shape parameter (must be positive)\n+     * @param beta second shape parameter (must be positive)\n+     */\n+    public BetaDistributionImpl(double alpha, double beta) {\n+        this.alpha = alpha;\n+        this.beta = beta;\n+        z = Double.NaN;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setAlpha(double alpha) {\n+        this.alpha = alpha;\n+        z = Double.NaN;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getAlpha() {\n+        return alpha;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setBeta(double beta) {\n+        this.beta = beta;\n+        z = Double.NaN;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getBeta() {\n+        return beta;\n+    }\n+\n+    /**\n+     * Recompute the normalization factor.\n+     */\n+    private void recomputeZ() {\n+        if (Double.isNaN(z)) {\n+            z = Gamma.logGamma(alpha) + Gamma.logGamma(beta) - Gamma.logGamma(alpha + beta);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double density(Double x) throws MathException {\n+        recomputeZ();\n+        if (x < 0 || x > 1) {\n+            return 0;\n+        } else if (x == 0) {\n+            if (alpha < 1) {\n+                throw new MathException(\"Cannot compute beta density at 0 when alpha = {0,number}\", alpha);\n+            }\n+            return 0;\n+        } else if (x == 1) {\n+            if (beta < 1) {\n+                throw new MathException(\"Cannot compute beta density at 1 when beta = %.3g\", beta);\n+            }\n+            return 0;\n+        } else {\n+            double logX = Math.log(x);\n+            double log1mX = Math.log1p(-x);\n+            return Math.exp((alpha - 1) * logX + (beta - 1) * log1mX - z);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double inverseCumulativeProbability(double p) throws MathException {\n+        if (p == 0) {\n+            return 0;\n+        } else if (p == 1) {\n+            return 1;\n+        } else {\n+            return super.inverseCumulativeProbability(p);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getInitialDomain(double p) {\n+        return p;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        return 0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected double getDomainUpperBound(double p) {\n+        return 1;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double cumulativeProbability(double x) throws MathException {\n+        if (x <= 0) {\n+            return 0;\n+        } else if (x >= 1) {\n+            return 1;\n+        } else {\n+            return Beta.regularizedBeta(x, alpha, beta);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double cumulativeProbability(double x0, double x1) throws MathException {\n+        return cumulativeProbability(x1) - cumulativeProbability(x0);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/BinomialDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * The Binomial Distribution.\n+ *\n+ * <p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/BinomialDistribution.html\">\n+ * Binomial Distribution</a></li>\n+ * </ul>\n+ * </p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public interface BinomialDistribution extends IntegerDistribution {\n+    /**\n+     * Access the number of trials for this distribution.\n+     * @return the number of trials.\n+     */\n+    int getNumberOfTrials();\n+    \n+    /**\n+     * Access the probability of success for this distribution.\n+     * @return the probability of success.\n+     */\n+    double getProbabilityOfSuccess();\n+    \n+    /**\n+     * Change the number of trials for this distribution.\n+     * @param trials the new number of trials.\n+     */\n+    void setNumberOfTrials(int trials);\n+    \n+    /**\n+     * Change the probability of success for this distribution.\n+     * @param p the new probability of success.\n+     */\n+    void setProbabilityOfSuccess(double p);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.special.Beta;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * The default implementation of {@link BinomialDistribution}.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class BinomialDistributionImpl\n+    extends AbstractIntegerDistribution\n+    implements BinomialDistribution, Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 6751309484392813623L;\n+\n+    /** The number of trials. */\n+    private int numberOfTrials;\n+\n+    /** The probability of success. */\n+    private double probabilityOfSuccess;\n+\n+    /**\n+     * Create a binomial distribution with the given number of trials and\n+     * probability of success.\n+     * @param trials the number of trials.\n+     * @param p the probability of success.\n+     */\n+    public BinomialDistributionImpl(int trials, double p) {\n+        super();\n+        setNumberOfTrials(trials);\n+        setProbabilityOfSuccess(p);\n+    }\n+\n+    /**\n+     * Access the number of trials for this distribution.\n+     * @return the number of trials.\n+     */\n+    public int getNumberOfTrials() {\n+        return numberOfTrials;\n+    }\n+\n+    /**\n+     * Access the probability of success for this distribution.\n+     * @return the probability of success.\n+     */\n+    public double getProbabilityOfSuccess() {\n+        return probabilityOfSuccess;\n+    }\n+\n+    /**\n+     * Change the number of trials for this distribution.\n+     * @param trials the new number of trials.\n+     * @throws IllegalArgumentException if <code>trials</code> is not a valid\n+     *         number of trials.\n+     */\n+    public void setNumberOfTrials(int trials) {\n+        if (trials < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"number of trials must be non-negative ({0})\", trials);\n+        }\n+        numberOfTrials = trials;\n+    }\n+\n+    /**\n+     * Change the probability of success for this distribution.\n+     * @param p the new probability of success.\n+     * @throws IllegalArgumentException if <code>p</code> is not a valid\n+     *         probability.\n+     */\n+    public void setProbabilityOfSuccess(double p) {\n+        if (p < 0.0 || p > 1.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n+        }\n+        probabilityOfSuccess = p;\n+    }\n+\n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a PDF root.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     */\n+    @Override\n+    protected int getDomainLowerBound(double p) {\n+        return -1;\n+    }\n+\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a PDF root.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    @Override\n+    protected int getDomainUpperBound(double p) {\n+        return getNumberOfTrials();\n+    }\n+\n+    /**\n+     * For this distribution, X, this method returns P(X &le; x).\n+     * @param x the value at which the PDF is evaluated.\n+     * @return PDF for this distribution. \n+     * @throws MathException if the cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     */\n+    @Override\n+    public double cumulativeProbability(int x) throws MathException {\n+        double ret;\n+        if (x < 0) {\n+            ret = 0.0;\n+        } else if (x >= getNumberOfTrials()) {\n+            ret = 1.0;\n+        } else {\n+            ret =\n+                1.0 - Beta.regularizedBeta(\n+                        getProbabilityOfSuccess(),\n+                        x + 1.0,\n+                        getNumberOfTrials() - x);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * For this distribution, X, this method returns P(X = x).\n+     * \n+     * @param x the value at which the PMF is evaluated.\n+     * @return PMF for this distribution. \n+     */\n+    public double probability(int x) {\n+        double ret;\n+        if (x < 0 || x > getNumberOfTrials()) {\n+            ret = 0.0;\n+        } else {\n+            ret = MathUtils.binomialCoefficientDouble(\n+                    getNumberOfTrials(), x) *\n+                  Math.pow(getProbabilityOfSuccess(), x) *\n+                  Math.pow(1.0 - getProbabilityOfSuccess(),\n+                        getNumberOfTrials() - x);\n+        }\n+        return ret;\n+    }\n+    \n+    /**\n+     * For this distribution, X, this method returns the largest x, such\n+     * that P(X &le; x) &le; <code>p</code>.\n+     * <p>\n+     * Returns <code>-1</code> for p=0 and <code>Integer.MAX_VALUE</code> for\n+     * p=1.</p>\n+     *\n+     * @param p the desired probability\n+     * @return the largest x such that P(X &le; x) <= p\n+     * @throws MathException if the inverse cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if p < 0 or p > 1\n+     */\n+    @Override\n+    public int inverseCumulativeProbability(final double p) throws MathException {\n+        // handle extreme values explicitly\n+        if (p == 0) {\n+            return -1;\n+        } \n+        if (p == 1) {\n+            return Integer.MAX_VALUE; \n+        }\n+        \n+        // use default bisection impl\n+        return super.inverseCumulativeProbability(p);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/CauchyDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Cauchy Distribution.\n+ *\n+ * <p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/CauchyDistribution.html\">\n+ * Cauchy Distribution</a></li>\n+ * </ul>\n+ * </p>\n+ *\n+ * @since 1.1\n+ * @version $Revision$ $Date$\n+ */\n+public interface CauchyDistribution extends ContinuousDistribution {\n+    \n+    /**\n+     * Access the median.\n+     * @return median for this distribution\n+     */\n+    double getMedian();\n+    \n+    /**\n+     * Access the scale parameter.\n+     * @return scale parameter for this distribution\n+     */\n+    double getScale();\n+    \n+    /**\n+     * Modify the median.\n+     * @param median for this distribution\n+     */\n+    void setMedian(double median);\n+    \n+    /**\n+     * Modify the scale parameter.\n+     * @param s scale parameter for this distribution\n+     */\n+    void setScale(double s);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Default implementation of\n+ * {@link org.apache.commons.math.distribution.CauchyDistribution}.\n+ *\n+ * @since 1.1\n+ * @version $Revision$ $Date$\n+ */\n+public class CauchyDistributionImpl extends AbstractContinuousDistribution \n+        implements CauchyDistribution, Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 8589540077390120676L;\n+\n+    /** The median of this distribution. */\n+    private double median = 0;\n+    \n+    /** The scale of this distribution. */\n+    private double scale = 1;\n+    \n+    /**\n+     * Creates cauchy distribution with the medain equal to zero and scale\n+     * equal to one. \n+     */\n+    public CauchyDistributionImpl(){\n+        this(0.0, 1.0);\n+    }\n+    \n+    /**\n+     * Create a cauchy distribution using the given median and scale.\n+     * @param median median for this distribution\n+     * @param s scale parameter for this distribution\n+     */\n+    public CauchyDistributionImpl(double median, double s){\n+        super();\n+        setMedian(median);\n+        setScale(s);\n+    }\n+\n+    /**\n+     * For this distribution, X, this method returns P(X &lt; <code>x</code>).\n+     * @param x the value at which the CDF is evaluated.\n+     * @return CDF evaluted at <code>x</code>. \n+     */\n+    public double cumulativeProbability(double x) {\n+        return 0.5 + (Math.atan((x - median) / scale) / Math.PI);\n+    }\n+    \n+    /**\n+     * Access the median.\n+     * @return median for this distribution\n+     */ \n+    public double getMedian() {\n+        return median;\n+    }\n+\n+    /**\n+     * Access the scale parameter.\n+     * @return scale parameter for this distribution\n+     */\n+    public double getScale() {\n+        return scale;\n+    }\n+    \n+    /**\n+     * For this distribution, X, this method returns the critical point x, such\n+     * that P(X &lt; x) = <code>p</code>.\n+     * <p>\n+     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and \n+     * <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n+     *\n+     * @param p the desired probability\n+     * @return x, such that P(X &lt; x) = <code>p</code>\n+     * @throws IllegalArgumentException if <code>p</code> is not a valid\n+     *         probability.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(double p) {\n+        double ret;\n+        if (p < 0.0 || p > 1.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n+        } else if (p == 0) {\n+            ret = Double.NEGATIVE_INFINITY;\n+        } else  if (p == 1) {\n+            ret = Double.POSITIVE_INFINITY;\n+        } else {\n+            ret = median + scale * Math.tan(Math.PI * (p - .5));\n+        }\n+        return ret;\n+    }\n+    \n+    /**\n+     * Modify the median.\n+     * @param median for this distribution\n+     */\n+    public void setMedian(double median) {\n+        this.median = median;\n+    }\n+\n+    /**\n+     * Modify the scale parameter.\n+     * @param s scale parameter for this distribution\n+     * @throws IllegalArgumentException if <code>sd</code> is not positive.\n+     */\n+    public void setScale(double s) {\n+        if (s <= 0.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"scale must be positive ({0})\", s);\n+        }       \n+        scale = s;\n+    }\n+    \n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        double ret;\n+\n+        if (p < .5) {\n+            ret = -Double.MAX_VALUE;\n+        } else {\n+            ret = getMedian();\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    @Override\n+    protected double getDomainUpperBound(double p) {\n+        double ret;\n+\n+        if (p < .5) {\n+            ret = getMedian();\n+        } else {\n+            ret = Double.MAX_VALUE;\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Access the initial domain value, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return initial domain value\n+     */\n+    @Override\n+    protected double getInitialDomain(double p) {\n+        double ret;\n+\n+        if (p < .5) {\n+            ret = getMedian() - getScale();\n+        } else if (p > .5) {\n+            ret = getMedian() + getScale();\n+        } else {\n+            ret = getMedian();\n+        }\n+        \n+        return ret;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * The Chi-Squared Distribution.\n+ *\n+ * <p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">\n+ * Chi-Squared Distribution</a></li>\n+ * </ul>\n+ * </p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public interface ChiSquaredDistribution extends ContinuousDistribution, HasDensity<Double> {\n+    /**\n+     * Modify the degrees of freedom.\n+     * @param degreesOfFreedom the new degrees of freedom.\n+     */\n+    void setDegreesOfFreedom(double degreesOfFreedom);\n+    \n+    /**\n+     * Access the degrees of freedom.\n+     * @return the degrees of freedom.\n+     */\n+    double getDegreesOfFreedom();\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     * @param x  The point at which the density should be computed.\n+     * @return  The pdf at point x.\n+     */\n+    double density(Double x);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * The default implementation of {@link ChiSquaredDistribution}\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class ChiSquaredDistributionImpl\n+    extends AbstractContinuousDistribution\n+    implements ChiSquaredDistribution, Serializable  {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -8352658048349159782L;\n+\n+    /** Internal Gamma distribution. */    \n+    private GammaDistribution gamma;\n+    \n+    /**\n+     * Create a Chi-Squared distribution with the given degrees of freedom.\n+     * @param df degrees of freedom.\n+     */\n+    public ChiSquaredDistributionImpl(double df) {\n+        this(df, new GammaDistributionImpl(df / 2.0, 2.0));\n+    }\n+    \n+    /**\n+     * Create a Chi-Squared distribution with the given degrees of freedom.\n+     * @param df degrees of freedom.\n+     * @param g the underlying gamma distribution used to compute probabilities.\n+     * @since 1.2\n+     */\n+    public ChiSquaredDistributionImpl(double df, GammaDistribution g) {\n+        super();\n+        setGamma(g);\n+        setDegreesOfFreedom(df);\n+    }\n+    \n+    /**\n+     * Modify the degrees of freedom.\n+     * @param degreesOfFreedom the new degrees of freedom.\n+     */\n+    public void setDegreesOfFreedom(double degreesOfFreedom) {\n+        getGamma().setAlpha(degreesOfFreedom / 2.0);\n+    }\n+        \n+    /**\n+     * Access the degrees of freedom.\n+     * @return the degrees of freedom.\n+     */\n+    public double getDegreesOfFreedom() {\n+        return getGamma().getAlpha() * 2.0;\n+    }\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    public double density(Double x) {\n+        return gamma.density(x);\n+    }\n+\n+    /**\n+     * For this distribution, X, this method returns P(X &lt; x).\n+     * @param x the value at which the CDF is evaluated.\n+     * @return CDF for this distribution. \n+     * @throws MathException if the cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     */\n+    public double cumulativeProbability(double x) throws MathException {\n+        return getGamma().cumulativeProbability(x);\n+    }\n+    \n+    /**\n+     * For this distribution, X, this method returns the critical point x, such\n+     * that P(X &lt; x) = <code>p</code>.\n+     * <p>\n+     * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n+     *\n+     * @param p the desired probability\n+     * @return x, such that P(X &lt; x) = <code>p</code>\n+     * @throws MathException if the inverse cumulative probability can not be\n+     *         computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if <code>p</code> is not a valid\n+     *         probability.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(final double p)\n+        throws MathException {\n+        if (p == 0) {\n+            return 0d;\n+        }\n+        if (p == 1) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+        return super.inverseCumulativeProbability(p);\n+    }\n+        \n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        return Double.MIN_VALUE * getGamma().getBeta();\n+    }\n+\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    @Override\n+    protected double getDomainUpperBound(double p) {\n+        // NOTE: chi squared is skewed to the left\n+        // NOTE: therefore, P(X < &mu;) > .5\n+\n+        double ret;\n+\n+        if (p < .5) {\n+            // use mean\n+            ret = getDegreesOfFreedom();\n+        } else {\n+            // use max\n+            ret = Double.MAX_VALUE;\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Access the initial domain value, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return initial domain value\n+     */\n+    @Override\n+    protected double getInitialDomain(double p) {\n+        // NOTE: chi squared is skewed to the left\n+        // NOTE: therefore, P(X < &mu;) > .5\n+        \n+        double ret;\n+\n+        if (p < .5) {\n+            // use 1/2 mean\n+            ret = getDegreesOfFreedom() * .5;\n+        } else {\n+            // use mean\n+            ret = getDegreesOfFreedom();\n+        }\n+        \n+        return ret;\n+    }\n+    \n+    /**\n+     * Modify the underlying gamma distribution.  The caller is responsible for\n+     * insuring the gamma distribution has the proper parameter settings.\n+     * @param g the new distribution.\n+     * @since 1.2 made public\n+     */\n+    public void setGamma(GammaDistribution g) {\n+        this.gamma = g;\n+        \n+    }\n+\n+    /**\n+     * Access the Gamma distribution.\n+     * @return the internal Gamma distribution.\n+     */\n+    private GammaDistribution getGamma() {\n+        return gamma;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/ContinuousDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Base interface for continuous distributions.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public interface ContinuousDistribution extends Distribution {\n+    \n+    /**\n+     * For this distribution, X, this method returns x such that P(X &lt; x) = p.\n+     * @param p the cumulative probability.\n+     * @return x. \n+     * @throws MathException if the inverse cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     */\n+    double inverseCumulativeProbability(double p) throws MathException;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/DiscreteDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+\n+/**\n+ * Base interface for discrete distributions.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public interface DiscreteDistribution extends Distribution {\n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(X = x). In other words, this\n+     * method represents the probability mass function, or PMF for the distribution.\n+     * \n+     * @param x the value at which the probability mass function is evaluated.\n+     * @return the value of the probability mass function at x\n+     */\n+    double probability(double x);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/Distribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Base interface for probability distributions.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public interface Distribution {\n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(X &le; x).  In other words,\n+     * this method represents the  (cumulative) distribution function, or\n+     * CDF, for this distribution.\n+     * \n+     * @param x the value at which the distribution function is evaluated.\n+     * @return the probability that a random variable with this\n+     * distribution takes a value less than or equal to <code>x</code>\n+     * @throws MathException if the cumulative probability can not be\n+     * computed due to convergence or other numerical errors.\n+     */\n+    double cumulativeProbability(double x) throws MathException;\n+    \n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(x0 &le; X &le; x1).\n+     * \n+     * @param x0 the (inclusive) lower bound\n+     * @param x1 the (inclusive) upper bound\n+     * @return the probability that a random variable with this distribution\n+     * will take a value between <code>x0</code> and <code>x1</code>, \n+     * including the endpoints\n+     * @throws MathException if the cumulative probability can not be\n+     * computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if <code>x0 > x1</code>\n+     */\n+    double cumulativeProbability(double x0, double x1) throws MathException;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * The Exponential Distribution.\n+ *\n+ * <p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/ExponentialDistribution.html\">\n+ * Exponential Distribution</a></li>\n+ * </ul>\n+ * </p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public interface ExponentialDistribution extends ContinuousDistribution, HasDensity<Double> {\n+    /**\n+     * Modify the mean.\n+     * @param mean the new mean.\n+     */\n+    void setMean(double mean);\n+    \n+    /**\n+     * Access the mean.\n+     * @return the mean.\n+     */\n+    double getMean();\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     * @param x  The point at which the density should be computed.\n+     * @return  The pdf at point x.\n+     */\n+    double density(Double x);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * The default implementation of {@link ExponentialDistribution}.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class ExponentialDistributionImpl extends AbstractContinuousDistribution\n+    implements ExponentialDistribution, Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 2401296428283614780L;\n+    \n+    /** The mean of this distribution. */\n+    private double mean;\n+    \n+    /**\n+     * Create a exponential distribution with the given mean.\n+     * @param mean mean of this distribution.\n+     */\n+    public ExponentialDistributionImpl(double mean) {\n+        super();\n+        setMean(mean);\n+    }\n+\n+    /**\n+     * Modify the mean.\n+     * @param mean the new mean.\n+     * @throws IllegalArgumentException if <code>mean</code> is not positive.\n+     */\n+    public void setMean(double mean) {\n+        if (mean <= 0.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"mean must be positive ({0})\", mean);\n+        }\n+        this.mean = mean;\n+    }\n+\n+    /**\n+     * Access the mean.\n+     * @return the mean.\n+     */\n+    public double getMean() {\n+        return mean;\n+    }\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    public double density(Double x) {\n+        if (x < 0) {\n+            return 0;\n+        }\n+        return Math.exp(-x / getMean()) / getMean();\n+    }\n+\n+    /**\n+     * For this distribution, X, this method returns P(X &lt; x).\n+     * \n+     * The implementation of this method is based on:\n+     * <ul>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/ExponentialDistribution.html\">\n+     * Exponential Distribution</a>, equation (1).</li>\n+     * </ul>\n+     * \n+     * @param x the value at which the CDF is evaluated.\n+     * @return CDF for this distribution.\n+     * @throws MathException if the cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     */\n+    public double cumulativeProbability(double x) throws MathException{\n+        double ret;\n+        if (x <= 0.0) {\n+            ret = 0.0;\n+        } else {\n+            ret = 1.0 - Math.exp(-x / getMean());\n+        }\n+        return ret;\n+    }\n+    \n+    /**\n+     * For this distribution, X, this method returns the critical point x, such\n+     * that P(X &lt; x) = <code>p</code>.\n+     * <p>\n+     * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n+     * \n+     * @param p the desired probability\n+     * @return x, such that P(X &lt; x) = <code>p</code>\n+     * @throws MathException if the inverse cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if p < 0 or p > 1.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(double p) throws MathException {\n+        double ret;\n+        \n+        if (p < 0.0 || p > 1.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n+        } else if (p == 1.0) {\n+            ret = Double.POSITIVE_INFINITY;\n+        } else {\n+            ret = -getMean() * Math.log(1.0 - p);\n+        }\n+        \n+        return ret;\n+    }\n+    \n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a CDF root.   \n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n+     */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        return 0;\n+    }\n+    \n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a CDF root.   \n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    @Override\n+    protected double getDomainUpperBound(double p) {\n+        // NOTE: exponential is skewed to the left\n+        // NOTE: therefore, P(X < &mu;) > .5\n+\n+        if (p < .5) {\n+            // use mean\n+            return getMean();\n+        } else {\n+            // use max\n+            return Double.MAX_VALUE;\n+        }\n+    }\n+    \n+    /**\n+     * Access the initial domain value, based on <code>p</code>, used to\n+     * bracket a CDF root.   \n+     * \n+     * @param p the desired probability for the critical value\n+     * @return initial domain value\n+     */\n+    @Override\n+    protected double getInitialDomain(double p) {\n+        // TODO: try to improve on this estimate\n+        // TODO: what should really happen here is not derive from AbstractContinuousDistribution\n+        // TODO: because the inverse cumulative distribution is simple.\n+        // Exponential is skewed to the left, therefore, P(X < &mu;) > .5\n+        if (p < .5) {\n+            // use 1/2 mean\n+            return getMean() * .5;\n+        } else {\n+            // use mean\n+            return getMean();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/FDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * F-Distribution.\n+ *\n+ * <p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/F-Distribution.html\">\n+ * F-Distribution</a></li>\n+ * </ul>\n+ * </p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public interface FDistribution extends ContinuousDistribution {\n+    /**\n+     * Modify the numerator degrees of freedom.\n+     * @param degreesOfFreedom the new numerator degrees of freedom.\n+     */\n+    void setNumeratorDegreesOfFreedom(double degreesOfFreedom);\n+    \n+    /**\n+     * Access the numerator degrees of freedom.\n+     * @return the numerator degrees of freedom.\n+     */\n+    double getNumeratorDegreesOfFreedom();\n+    \n+    /**\n+     * Modify the denominator degrees of freedom.\n+     * @param degreesOfFreedom the new denominator degrees of freedom.\n+     */\n+    void setDenominatorDegreesOfFreedom(double degreesOfFreedom);\n+    \n+    /**\n+     * Access the denominator degrees of freedom.\n+     * @return the denominator degrees of freedom.\n+     */\n+    double getDenominatorDegreesOfFreedom();\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.special.Beta;\n+\n+/**\n+ * Default implementation of\n+ * {@link org.apache.commons.math.distribution.FDistribution}.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class FDistributionImpl\n+    extends AbstractContinuousDistribution\n+    implements FDistribution, Serializable  {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -8516354193418641566L;\n+\n+    /** The numerator degrees of freedom*/\n+    private double numeratorDegreesOfFreedom;\n+\n+    /** The numerator degrees of freedom*/\n+    private double denominatorDegreesOfFreedom;\n+    \n+    /**\n+     * Create a F distribution using the given degrees of freedom.\n+     * @param numeratorDegreesOfFreedom the numerator degrees of freedom.\n+     * @param denominatorDegreesOfFreedom the denominator degrees of freedom.\n+     */\n+    public FDistributionImpl(double numeratorDegreesOfFreedom,\n+            double denominatorDegreesOfFreedom) {\n+        super();\n+        setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);\n+        setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n+    }\n+    \n+    /**\n+     * For this distribution, X, this method returns P(X &lt; x).\n+     * \n+     * The implementation of this method is based on:\n+     * <ul>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/F-Distribution.html\">\n+     * F-Distribution</a>, equation (4).</li>\n+     * </ul>\n+     * \n+     * @param x the value at which the CDF is evaluated.\n+     * @return CDF for this distribution. \n+     * @throws MathException if the cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     */\n+    public double cumulativeProbability(double x) throws MathException {\n+        double ret;\n+        if (x <= 0.0) {\n+            ret = 0.0;\n+        } else {\n+            double n = getNumeratorDegreesOfFreedom();\n+            double m = getDenominatorDegreesOfFreedom();\n+            \n+            ret = Beta.regularizedBeta((n * x) / (m + n * x),\n+                0.5 * n,\n+                0.5 * m);\n+        }\n+        return ret;\n+    }\n+    \n+    /**\n+     * For this distribution, X, this method returns the critical point x, such\n+     * that P(X &lt; x) = <code>p</code>.\n+     * <p>\n+     * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n+     *\n+     * @param p the desired probability\n+     * @return x, such that P(X &lt; x) = <code>p</code>\n+     * @throws MathException if the inverse cumulative probability can not be\n+     *         computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if <code>p</code> is not a valid\n+     *         probability.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(final double p) \n+        throws MathException {\n+        if (p == 0) {\n+            return 0d;\n+        }\n+        if (p == 1) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+        return super.inverseCumulativeProbability(p);\n+    }\n+        \n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        return 0.0;\n+    }\n+\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    @Override\n+    protected double getDomainUpperBound(double p) {\n+        return Double.MAX_VALUE;\n+    }\n+\n+    /**\n+     * Access the initial domain value, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return initial domain value\n+     */\n+    @Override\n+    protected double getInitialDomain(double p) {\n+        double ret = 1.0;\n+        double d = getDenominatorDegreesOfFreedom();\n+        if (d > 2.0) {\n+            // use mean\n+            ret = d / (d - 2.0);\n+        }\n+        return ret;\n+    }\n+    \n+    /**\n+     * Modify the numerator degrees of freedom.\n+     * @param degreesOfFreedom the new numerator degrees of freedom.\n+     * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not\n+     *         positive.\n+     */\n+    public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {\n+        if (degreesOfFreedom <= 0.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"degrees of freedom must be positive ({0})\",\n+                  degreesOfFreedom);\n+        }\n+        this.numeratorDegreesOfFreedom = degreesOfFreedom;\n+    }\n+    \n+    /**\n+     * Access the numerator degrees of freedom.\n+     * @return the numerator degrees of freedom.\n+     */\n+    public double getNumeratorDegreesOfFreedom() {\n+        return numeratorDegreesOfFreedom;\n+    }\n+    \n+    /**\n+     * Modify the denominator degrees of freedom.\n+     * @param degreesOfFreedom the new denominator degrees of freedom.\n+     * @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not\n+     *         positive.\n+     */\n+    public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {\n+        if (degreesOfFreedom <= 0.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"degrees of freedom must be positive ({0})\",\n+                  degreesOfFreedom);\n+        }\n+        this.denominatorDegreesOfFreedom = degreesOfFreedom;\n+    }\n+    \n+    /**\n+     * Access the denominator degrees of freedom.\n+     * @return the denominator degrees of freedom.\n+     */\n+    public double getDenominatorDegreesOfFreedom() {\n+        return denominatorDegreesOfFreedom;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * The Gamma Distribution.\n+ *\n+ * <p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/GammaDistribution.html\">\n+ * Gamma Distribution</a></li>\n+ * </ul>\n+ * </p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public interface GammaDistribution extends ContinuousDistribution, HasDensity<Double> {\n+    /**\n+     * Modify the shape parameter, alpha.\n+     * @param alpha the new shape parameter.\n+     */\n+    void setAlpha(double alpha);\n+    \n+    /**\n+     * Access the shape parameter, alpha\n+     * @return alpha.\n+     */\n+    double getAlpha();\n+    \n+    /**\n+     * Modify the scale parameter, beta.\n+     * @param beta the new scale parameter.\n+     */\n+    void setBeta(double beta);\n+    \n+    /**\n+     * Access the scale parameter, beta\n+     * @return beta.\n+     */\n+    double getBeta();\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     * @param x  The point at which the density should be computed.\n+     * @return  The pdf at point x.\n+     */\n+    double density(Double x);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.special.Gamma;\n+\n+/**\n+ * The default implementation of {@link GammaDistribution}.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class GammaDistributionImpl extends AbstractContinuousDistribution\n+    implements GammaDistribution, Serializable  {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -3239549463135430361L;\n+\n+    /** The shape parameter. */\n+    private double alpha;\n+    \n+    /** The scale parameter. */\n+    private double beta;\n+    \n+    /**\n+     * Create a new gamma distribution with the given alpha and beta values.\n+     * @param alpha the shape parameter.\n+     * @param beta the scale parameter.\n+     */\n+    public GammaDistributionImpl(double alpha, double beta) {\n+        super();\n+        setAlpha(alpha);\n+        setBeta(beta);\n+    }\n+    \n+    /**\n+     * For this distribution, X, this method returns P(X &lt; x).\n+     * \n+     * The implementation of this method is based on:\n+     * <ul>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">\n+     * Chi-Squared Distribution</a>, equation (9).</li>\n+     * <li>Casella, G., & Berger, R. (1990). <i>Statistical Inference</i>.\n+     * Belmont, CA: Duxbury Press.</li>\n+     * </ul>\n+     * \n+     * @param x the value at which the CDF is evaluated.\n+     * @return CDF for this distribution. \n+     * @throws MathException if the cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     */\n+    public double cumulativeProbability(double x) throws MathException{\n+        double ret;\n+    \n+        if (x <= 0.0) {\n+            ret = 0.0;\n+        } else {\n+            ret = Gamma.regularizedGammaP(getAlpha(), x / getBeta());\n+        }\n+    \n+        return ret;\n+    }\n+    \n+    /**\n+     * For this distribution, X, this method returns the critical point x, such\n+     * that P(X &lt; x) = <code>p</code>.\n+     * <p>\n+     * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n+     *\n+     * @param p the desired probability\n+     * @return x, such that P(X &lt; x) = <code>p</code>\n+     * @throws MathException if the inverse cumulative probability can not be\n+     *         computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if <code>p</code> is not a valid\n+     *         probability.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(final double p) \n+    throws MathException {\n+        if (p == 0) {\n+            return 0d;\n+        }\n+        if (p == 1) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+        return super.inverseCumulativeProbability(p);\n+    }\n+    \n+    /**\n+     * Modify the shape parameter, alpha.\n+     * @param alpha the new shape parameter.\n+     * @throws IllegalArgumentException if <code>alpha</code> is not positive.\n+     */\n+    public void setAlpha(double alpha) {\n+        if (alpha <= 0.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"alpha must be positive ({0})\",\n+                  alpha);\n+        }\n+        this.alpha = alpha;\n+    }\n+    \n+    /**\n+     * Access the shape parameter, alpha\n+     * @return alpha.\n+     */\n+    public double getAlpha() {\n+        return alpha;\n+    }\n+    \n+    /**\n+     * Modify the scale parameter, beta.\n+     * @param beta the new scale parameter.\n+     * @throws IllegalArgumentException if <code>beta</code> is not positive.\n+     */\n+    public void setBeta(double beta) {\n+        if (beta <= 0.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"beta must be positive ({0})\",\n+                  beta);\n+        }\n+        this.beta = beta;\n+    }\n+    \n+    /**\n+     * Access the scale parameter, beta\n+     * @return beta.\n+     */\n+    public double getBeta() {\n+        return beta;\n+    }\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    public double density(Double x) {\n+        if (x < 0) return 0;\n+        return Math.pow(x / getBeta(), getAlpha() - 1) / getBeta() * Math.exp(-x / getBeta()) / Math.exp(Gamma.logGamma(getAlpha()));\n+    }\n+\n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n+     */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        // TODO: try to improve on this estimate\n+        return Double.MIN_VALUE;\n+    }\n+\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    @Override\n+    protected double getDomainUpperBound(double p) {\n+        // TODO: try to improve on this estimate\n+        // NOTE: gamma is skewed to the left\n+        // NOTE: therefore, P(X < &mu;) > .5\n+\n+        double ret;\n+\n+        if (p < .5) {\n+            // use mean\n+            ret = getAlpha() * getBeta();\n+        } else {\n+            // use max value\n+            ret = Double.MAX_VALUE;\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Access the initial domain value, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return initial domain value\n+     */\n+    @Override\n+    protected double getInitialDomain(double p) {\n+        // TODO: try to improve on this estimate\n+        // Gamma is skewed to the left, therefore, P(X < &mu;) > .5\n+\n+        double ret;\n+\n+        if (p < .5) {\n+            // use 1/2 mean\n+            ret = getAlpha() * getBeta() * .5;\n+        } else {\n+            // use mean\n+            ret = getAlpha() * getBeta();\n+        }\n+        \n+        return ret;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/HasDensity.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Interface that signals that a distribution can compute the probability density function\n+ * for a particular point.\n+ * @param <P> the type of the point at which density is to be computed, this\n+ * may be for example <code>Double</code>\n+ * @version $Revision$ $Date$\n+ */\n+public interface HasDensity<P> {\n+\n+    /**\n+     * Compute the probability density function.\n+     * @param x point for which the probability density is requested\n+     * @return probability density at point x\n+     * @throws MathException if probability density cannot be computed at specifed point\n+     */\n+    double density(P x) throws MathException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * The Hypergeometric Distribution.\n+ *\n+ * <p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/HypergeometricDistribution.html\">\n+ * Hypergeometric Distribution</a></li>\n+ * </ul>\n+ * </p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public interface HypergeometricDistribution extends IntegerDistribution {\n+    /**\n+     * Access the number of successes.\n+     * @return the number of successes.\n+     */\n+    public abstract int getNumberOfSuccesses();\n+    \n+    /**\n+     * Access the population size.\n+     * @return the population size.\n+     */\n+    public abstract int getPopulationSize();\n+    \n+    /**\n+     * Access the sample size.\n+     * @return the sample size.\n+     */\n+    public abstract int getSampleSize();\n+    \n+    /**\n+     * Modify the number of successes.\n+     * @param num the new number of successes.\n+     */\n+    public abstract void setNumberOfSuccesses(int num);\n+    \n+    /**\n+     * Modify the population size.\n+     * @param size the new population size.\n+     */\n+    public abstract void setPopulationSize(int size);\n+    \n+    /**\n+     * Modify the sample size.\n+     * @param size the new sample size.\n+     */\n+    public abstract void setSampleSize(int size);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * The default implementation of {@link HypergeometricDistribution}.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class HypergeometricDistributionImpl extends AbstractIntegerDistribution\n+    implements HypergeometricDistribution, Serializable \n+{\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -436928820673516179L;\n+\n+    /** The number of successes in the population. */\n+    private int numberOfSuccesses;\n+    \n+    /** The population size. */\n+    private int populationSize;\n+    \n+    /** The sample size. */\n+    private int sampleSize;\n+    \n+    /**\n+     * Construct a new hypergeometric distribution with the given the population\n+     * size, the number of successes in the population, and the sample size.\n+     * @param populationSize the population size.\n+     * @param numberOfSuccesses number of successes in the population.\n+     * @param sampleSize the sample size.\n+     */\n+    public HypergeometricDistributionImpl(int populationSize,\n+        int numberOfSuccesses, int sampleSize) {\n+        super();\n+        if (numberOfSuccesses > populationSize) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"number of successes ({0}) must be less than or equal to population size ({1})\",\n+                numberOfSuccesses, populationSize);\n+        }\n+        if (sampleSize > populationSize) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"sample size ({0}) must be less than or equal to population size ({1})\",\n+                  sampleSize, populationSize);\n+        }\n+        setPopulationSize(populationSize);\n+        setSampleSize(sampleSize);\n+        setNumberOfSuccesses(numberOfSuccesses);\n+    }\n+\n+    /**\n+     * For this distribution, X, this method returns P(X &le; x).\n+     * @param x the value at which the PDF is evaluated.\n+     * @return PDF for this distribution. \n+     */\n+    @Override\n+    public double cumulativeProbability(int x) {\n+        double ret;\n+        \n+        int n = getPopulationSize();\n+        int m = getNumberOfSuccesses();\n+        int k = getSampleSize();\n+\n+        int[] domain = getDomain(n, m, k);\n+        if (x < domain[0]) {\n+            ret = 0.0;\n+        } else if(x >= domain[1]) {\n+            ret = 1.0;\n+        } else {\n+            ret = innerCumulativeProbability(domain[0], x, 1, n, m, k);\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Return the domain for the given hypergeometric distribution parameters.\n+     * @param n the population size.\n+     * @param m number of successes in the population.\n+     * @param k the sample size.\n+     * @return a two element array containing the lower and upper bounds of the\n+     *         hypergeometric distribution.  \n+     */\n+    private int[] getDomain(int n, int m, int k){\n+        return new int[]{\n+            getLowerDomain(n, m, k),\n+            getUpperDomain(m, k)\n+        };\n+    }\n+    \n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a PDF root.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     */\n+    @Override\n+    protected int getDomainLowerBound(double p) {\n+        return getLowerDomain(getPopulationSize(), getNumberOfSuccesses(),\n+            getSampleSize());\n+    }\n+    \n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a PDF root.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    @Override\n+    protected int getDomainUpperBound(double p) {\n+        return getUpperDomain(getSampleSize(), getNumberOfSuccesses());\n+    }\n+\n+    /**\n+     * Return the lowest domain value for the given hypergeometric distribution\n+     * parameters.\n+     * @param n the population size.\n+     * @param m number of successes in the population.\n+     * @param k the sample size.\n+     * @return the lowest domain value of the hypergeometric distribution.  \n+     */\n+    private int getLowerDomain(int n, int m, int k) {\n+        return Math.max(0, m - (n - k));\n+    }\n+\n+    /**\n+     * Access the number of successes.\n+     * @return the number of successes.\n+     */\n+    public int getNumberOfSuccesses() {\n+        return numberOfSuccesses;\n+    }\n+\n+    /**\n+     * Access the population size.\n+     * @return the population size.\n+     */\n+    public int getPopulationSize() {\n+        return populationSize;\n+    }\n+\n+    /**\n+     * Access the sample size.\n+     * @return the sample size.\n+     */\n+    public int getSampleSize() {\n+        return sampleSize;\n+    }\n+\n+    /**\n+     * Return the highest domain value for the given hypergeometric distribution\n+     * parameters.\n+     * @param m number of successes in the population.\n+     * @param k the sample size.\n+     * @return the highest domain value of the hypergeometric distribution.  \n+     */\n+    private int getUpperDomain(int m, int k){\n+        return Math.min(k, m);\n+    }\n+\n+    /**\n+     * For this distribution, X, this method returns P(X = x).\n+     * \n+     * @param x the value at which the PMF is evaluated.\n+     * @return PMF for this distribution. \n+     */\n+    public double probability(int x) {\n+        double ret;\n+        \n+        int n = getPopulationSize();\n+        int m = getNumberOfSuccesses();\n+        int k = getSampleSize();\n+\n+        int[] domain = getDomain(n, m, k);\n+        if(x < domain[0] || x > domain[1]){\n+            ret = 0.0;\n+        } else {\n+            ret = probability(n, m, k, x);\n+        }\n+        \n+        return ret;\n+    }\n+    \n+    /**\n+     * For the distribution, X, defined by the given hypergeometric distribution\n+     * parameters, this method returns P(X = x).\n+     * \n+     * @param n the population size.\n+     * @param m number of successes in the population.\n+     * @param k the sample size.\n+     * @param x the value at which the PMF is evaluated.\n+     * @return PMF for the distribution. \n+     */\n+    private double probability(int n, int m, int k, int x) {\n+        return Math.exp(MathUtils.binomialCoefficientLog(m, x) +\n+            MathUtils.binomialCoefficientLog(n - m, k - x) -\n+            MathUtils.binomialCoefficientLog(n, k));\n+    }\n+\n+    /**\n+     * Modify the number of successes.\n+     * @param num the new number of successes.\n+     * @throws IllegalArgumentException if <code>num</code> is negative.\n+     */\n+    public void setNumberOfSuccesses(int num) {\n+        if(num < 0){\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"number of successes must be non-negative ({0})\",\n+                  num);\n+        }\n+        numberOfSuccesses = num;\n+    }\n+\n+    /**\n+     * Modify the population size.\n+     * @param size the new population size.\n+     * @throws IllegalArgumentException if <code>size</code> is not positive.\n+     */\n+    public void setPopulationSize(int size) {\n+        if(size <= 0){\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"population size must be positive ({0})\",\n+                  size);\n+        }\n+        populationSize = size;\n+    }\n+    \n+    /**\n+     * Modify the sample size.\n+     * @param size the new sample size.\n+     * @throws IllegalArgumentException if <code>size</code> is negative.\n+     */\n+    public void setSampleSize(int size) {\n+        if (size < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"sample size must be positive ({0})\",\n+                  size);\n+        }    \n+        sampleSize = size;\n+    }\n+\n+    /**\n+     * For this distribution, X, this method returns P(X &ge; x).\n+     * @param x the value at which the CDF is evaluated.\n+     * @return upper tail CDF for this distribution.\n+     * @since 1.1\n+     */\n+    public double upperCumulativeProbability(int x) {\n+        double ret;\n+        \n+        int n = getPopulationSize();\n+        int m = getNumberOfSuccesses();\n+        int k = getSampleSize();\n+\n+        int[] domain = getDomain(n, m, k);\n+        if (x < domain[0]) {\n+            ret = 1.0;\n+        } else if(x > domain[1]) {\n+            ret = 0.0;\n+        } else {\n+            ret = innerCumulativeProbability(domain[1], x, -1, n, m, k);\n+        }\n+        \n+        return ret;\n+    }\n+    \n+    /**\n+     * For this distribution, X, this method returns P(x0 &le; X &le; x1).  This\n+     * probability is computed by summing the point probabilities for the values\n+     * x0, x0 + 1, x0 + 2, ..., x1, in the order directed by dx. \n+     * @param x0 the inclusive, lower bound\n+     * @param x1 the inclusive, upper bound\n+     * @param dx the direction of summation. 1 indicates summing from x0 to x1.\n+     *           0 indicates summing from x1 to x0.\n+     * @param n the population size.\n+     * @param m number of successes in the population.\n+     * @param k the sample size.\n+     * @return P(x0 &le; X &le; x1). \n+     */\n+    private double innerCumulativeProbability(\n+        int x0, int x1, int dx, int n, int m, int k)\n+    {\n+        double ret = probability(n, m, k, x0);\n+        while (x0 != x1) {\n+            x0 += dx;\n+            ret += probability(n, m, k, x0);\n+        }\n+        return ret;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/IntegerDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Interface for discrete distributions of integer-valued random variables.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public interface IntegerDistribution extends DiscreteDistribution {\n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(X = x). In other words, this\n+     * method represents the probability mass function for the distribution.\n+     * \n+     * @param x the value at which the probability density function is evaluated.\n+     * @return the value of the probability density function at x\n+     */\n+    double probability(int x);\n+\n+    /**\n+     * For a random variable X whose values are distributed according\n+     * to this distribution, this method returns P(X &le; x).  In other words,\n+     * this method represents the probability distribution function, or PDF\n+     * for the distribution.\n+     * \n+     * @param x the value at which the PDF is evaluated.\n+     * @return PDF for this distribution. \n+     * @throws MathException if the cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     */\n+    double cumulativeProbability(int x) throws MathException;\n+    \n+    /**\n+     * For this distribution, X, this method returns P(x0 &le; X &le; x1).\n+     * @param x0 the inclusive, lower bound\n+     * @param x1 the inclusive, upper bound\n+     * @return the cumulative probability. \n+     * @throws MathException if the cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if x0 > x1\n+     */\n+    double cumulativeProbability(int x0, int x1) throws MathException;\n+    \n+    /**\n+     * For this distribution, X, this method returns the largest x such that\n+     * P(X &le; x) <= p.\n+     * <p>\n+     * Note that this definition implies: <ul>\n+     * <li> If there is a minimum value, <code>m</code>, with postive\n+     * probablility under (the density of) X, then <code>m - 1</code> is\n+     * returned by <code>inverseCumulativeProbability(0).</code>  If there is\n+     * no such value <code>m,  Integer.MIN_VALUE</code> is \n+     * returned.</li>\n+     * <li> If there is a maximum value, <code>M</code>, such that\n+     * P(X &le; M) =1, then <code>M</code> is returned by \n+     * <code>inverseCumulativeProbability(1).</code>\n+     * If there is no such value, <code>M, Integer.MAX_VALUE</code> is \n+     * returned.</li></ul></p>\n+     * \n+     * @param p the cumulative probability.\n+     * @return the largest x such that P(X &le; x) <= p\n+     * @throws MathException if the inverse cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if p is not between 0 and 1 (inclusive)\n+     */\n+    int inverseCumulativeProbability(double p) throws MathException;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Normal (Gauss) Distribution.\n+ *\n+ * <p>\n+ * References:</p><p>\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/NormalDistribution.html\">\n+ * Normal Distribution</a></li>\n+ * </ul>\n+ * </p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public interface NormalDistribution extends ContinuousDistribution, HasDensity<Double> {\n+    /**\n+     * Access the mean.\n+     * @return mean for this distribution\n+     */\n+    double getMean();\n+    /**\n+     * Modify the mean.\n+     * @param mean for this distribution\n+     */\n+    void setMean(double mean);\n+    /**\n+     * Access the standard deviation.\n+     * @return standard deviation for this distribution\n+     */\n+    double getStandardDeviation();\n+    /**\n+     * Modify the standard deviation.\n+     * @param sd standard deviation for this distribution\n+     */\n+    void setStandardDeviation(double sd);\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     * @param x  The point at which the density should be computed.\n+     * @return  The pdf at point x.\n+     */\n+    double density(Double x);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.special.Erf;\n+\n+/**\n+ * Default implementation of\n+ * {@link org.apache.commons.math.distribution.NormalDistribution}.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class NormalDistributionImpl extends AbstractContinuousDistribution \n+        implements NormalDistribution, Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 8589540077390120676L;\n+\n+    /** &sqrt;(2 &pi;) */\n+    private static final double SQRT2PI = Math.sqrt(2 * Math.PI);\n+\n+    /** The mean of this distribution. */\n+    private double mean = 0;\n+    \n+    /** The standard deviation of this distribution. */\n+    private double standardDeviation = 1;\n+\n+    /**\n+     * Create a normal distribution using the given mean and standard deviation.\n+     * @param mean mean for this distribution\n+     * @param sd standard deviation for this distribution\n+     */\n+    public NormalDistributionImpl(double mean, double sd){\n+        super();\n+        setMean(mean);\n+        setStandardDeviation(sd);\n+    }\n+    \n+    /**\n+     * Creates normal distribution with the mean equal to zero and standard\n+     * deviation equal to one. \n+     */\n+    public NormalDistributionImpl(){\n+        this(0.0, 1.0);\n+    }\n+    \n+    /**\n+     * Access the mean.\n+     * @return mean for this distribution\n+     */ \n+    public double getMean() {\n+        return mean;\n+    }\n+    \n+    /**\n+     * Modify the mean.\n+     * @param mean for this distribution\n+     */\n+    public void setMean(double mean) {\n+        this.mean = mean;\n+    }\n+\n+    /**\n+     * Access the standard deviation.\n+     * @return standard deviation for this distribution\n+     */\n+    public double getStandardDeviation() {\n+        return standardDeviation;\n+    }\n+\n+    /**\n+     * Modify the standard deviation.\n+     * @param sd standard deviation for this distribution\n+     * @throws IllegalArgumentException if <code>sd</code> is not positive.\n+     */\n+    public void setStandardDeviation(double sd) {\n+        if (sd <= 0.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"standard deviation must be positive ({0})\",\n+                  sd);\n+        }       \n+        standardDeviation = sd;\n+    }\n+\n+    /**\n+     * Return the probability density for a particular point.\n+     *\n+     * @param x The point at which the density should be computed.\n+     * @return The pdf at point x.\n+     */\n+    public double density(Double x) {\n+        double x0 = x - getMean();\n+        return Math.exp(-x0 * x0 / (2 * getStandardDeviation() * getStandardDeviation())) / (getStandardDeviation() * SQRT2PI);\n+    }\n+\n+    /**\n+     * For this distribution, X, this method returns P(X &lt; <code>x</code>).\n+     * @param x the value at which the CDF is evaluated.\n+     * @return CDF evaluted at <code>x</code>. \n+     * @throws MathException if the algorithm fails to converge; unless\n+     * x is more than 20 standard deviations from the mean, in which case the\n+     * convergence exception is caught and 0 or 1 is returned.\n+     */\n+    public double cumulativeProbability(double x) throws MathException {\n+        try {\n+            return 0.5 * (1.0 + Erf.erf((x - mean) /\n+                    (standardDeviation * Math.sqrt(2.0))));\n+        } catch (MaxIterationsExceededException ex) {\n+            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n+                return 0.0d;\n+            } else if (x > (mean + 20 * standardDeviation)) {\n+                return 1.0d;\n+            } else {\n+                throw ex;\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * For this distribution, X, this method returns the critical point x, such\n+     * that P(X &lt; x) = <code>p</code>.\n+     * <p>\n+     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and \n+     * <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n+     *\n+     * @param p the desired probability\n+     * @return x, such that P(X &lt; x) = <code>p</code>\n+     * @throws MathException if the inverse cumulative probability can not be\n+     *         computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if <code>p</code> is not a valid\n+     *         probability.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(final double p) \n+    throws MathException {\n+        if (p == 0) {\n+            return Double.NEGATIVE_INFINITY;\n+        }\n+        if (p == 1) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+        return super.inverseCumulativeProbability(p);\n+    }\n+    \n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        double ret;\n+\n+        if (p < .5) {\n+            ret = -Double.MAX_VALUE;\n+        } else {\n+            ret = getMean();\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    @Override\n+    protected double getDomainUpperBound(double p) {\n+        double ret;\n+\n+        if (p < .5) {\n+            ret = getMean();\n+        } else {\n+            ret = Double.MAX_VALUE;\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Access the initial domain value, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return initial domain value\n+     */\n+    @Override\n+    protected double getInitialDomain(double p) {\n+        double ret;\n+\n+        if (p < .5) {\n+            ret = getMean() - getStandardDeviation();\n+        } else if (p > .5) {\n+            ret = getMean() + getStandardDeviation();\n+        } else {\n+            ret = getMean();\n+        }\n+        \n+        return ret;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * The Pascal distribution.  The Pascal distribution is a special case of the\n+ * Negative Binomial distribution where the number of successes parameter is an\n+ * integer.\n+ * \n+ * There are various ways to express the probability mass and distribution\n+ * functions for the Pascal distribution.  The convention employed by the\n+ * library is to express these functions in terms of the number of failures in\n+ * a Bernoulli experiment [2].\n+ *\n+ * <p>\n+ * References:\n+ * <ol>\n+ * <li><a href=\"http://mathworld.wolfram.com/NegativeBinomialDistribution.html\">\n+ * Negative Binomial Distribution</a></li>\n+ * <oi><a href=\"http://en.wikipedia.org/wiki/Negative_binomial_distribution#Waiting_time_in_a_Bernoulli_process\">Waiting Time in a Bernoulli Process</a></li>\n+ * </ul>\n+ * </p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public interface PascalDistribution extends IntegerDistribution {\n+    /**\n+     * Access the number of successes for this distribution.\n+     * \n+     * @return the number of successes\n+     */\n+    int getNumberOfSuccesses();\n+    \n+    /**\n+     * Access the probability of success for this distribution.\n+     * \n+     * @return the probability of success\n+     */\n+    double getProbabilityOfSuccess();\n+    \n+    /**\n+     * Change the number of successes for this distribution.\n+     * \n+     * @param successes the new number of successes\n+     */\n+    void setNumberOfSuccesses(int successes);\n+    \n+    /**\n+     * Change the probability of success for this distribution.\n+     * \n+     * @param p the new probability of success\n+     */\n+    void setProbabilityOfSuccess(double p);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.special.Beta;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * The default implementation of {@link PascalDistribution}.\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class PascalDistributionImpl extends AbstractIntegerDistribution\n+    implements PascalDistribution, Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 6751309484392813623L;\n+\n+    /** The number of successes */\n+    private int numberOfSuccesses;\n+\n+    /** The probability of success */\n+    private double probabilityOfSuccess;\n+\n+    /**\n+     * Create a binomial distribution with the given number of trials and\n+     * probability of success.\n+     * @param r the number of successes\n+     * @param p the probability of success\n+     */\n+    public PascalDistributionImpl(int r, double p) {\n+        super();\n+        setNumberOfSuccesses(r);\n+        setProbabilityOfSuccess(p);\n+    }\n+\n+    /**\n+     * Access the number of successes for this distribution.\n+     * @return the number of successes\n+     */\n+    public int getNumberOfSuccesses() {\n+        return numberOfSuccesses;\n+    }\n+\n+    /**\n+     * Access the probability of success for this distribution.\n+     * @return the probability of success\n+     */\n+    public double getProbabilityOfSuccess() {\n+        return probabilityOfSuccess;\n+    }\n+\n+    /**\n+     * Change the number of successes for this distribution.\n+     * @param successes the new number of successes\n+     * @throws IllegalArgumentException if <code>successes</code> is not\n+     *         positive.\n+     */\n+    public void setNumberOfSuccesses(int successes) {\n+        if (successes < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"number of successes must be non-negative ({0})\",\n+                  successes);\n+        }\n+        numberOfSuccesses = successes;\n+    }\n+\n+    /**\n+     * Change the probability of success for this distribution.\n+     * @param p the new probability of success\n+     * @throws IllegalArgumentException if <code>p</code> is not a valid\n+     *         probability.\n+     */\n+    public void setProbabilityOfSuccess(double p) {\n+        if (p < 0.0 || p > 1.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n+        }\n+        probabilityOfSuccess = p;\n+    }\n+\n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a PDF root.\n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e. P(X &lt; <i>lower bound</i>) &lt;\n+     *         <code>p</code>\n+     */\n+    @Override\n+    protected int getDomainLowerBound(double p) {\n+        return -1;\n+    }\n+\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a PDF root.\n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e. P(X &lt; <i>upper bound</i>) &gt;\n+     *         <code>p</code>\n+     */\n+    @Override\n+    protected int getDomainUpperBound(double p) {\n+        // use MAX - 1 because MAX causes loop\n+        return Integer.MAX_VALUE - 1;\n+    }\n+\n+    /**\n+     * For this distribution, X, this method returns P(X &le; x).\n+     * @param x the value at which the PDF is evaluated\n+     * @return PDF for this distribution\n+     * @throws MathException if the cumulative probability can not be computed\n+     *         due to convergence or other numerical errors\n+     */\n+    @Override\n+    public double cumulativeProbability(int x) throws MathException {\n+        double ret;\n+        if (x < 0) {\n+            ret = 0.0;\n+        } else {\n+            ret = Beta.regularizedBeta(getProbabilityOfSuccess(),\n+                getNumberOfSuccesses(), x + 1);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * For this distribution, X, this method returns P(X = x).\n+     * @param x the value at which the PMF is evaluated\n+     * @return PMF for this distribution\n+     */\n+    public double probability(int x) {\n+        double ret;\n+        if (x < 0) {\n+            ret = 0.0;\n+        } else {\n+            ret = MathUtils.binomialCoefficientDouble(x +\n+                  getNumberOfSuccesses() - 1, getNumberOfSuccesses() - 1) *\n+                  Math.pow(getProbabilityOfSuccess(), getNumberOfSuccesses()) *\n+                  Math.pow(1.0 - getProbabilityOfSuccess(), x);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * For this distribution, X, this method returns the largest x, such that\n+     * P(X &le; x) &le; <code>p</code>.\n+     * <p>\n+     * Returns <code>-1</code> for p=0 and <code>Integer.MAX_VALUE</code>\n+     * for p=1.</p>\n+     * @param p the desired probability\n+     * @return the largest x such that P(X &le; x) <= p\n+     * @throws MathException if the inverse cumulative probability can not be\n+     *         computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if p < 0 or p > 1\n+     */\n+    @Override\n+    public int inverseCumulativeProbability(final double p)\n+        throws MathException {\n+        int ret;\n+\n+        // handle extreme values explicitly\n+        if (p == 0) {\n+            ret = -1;\n+        } else if (p == 1) {\n+            ret = Integer.MAX_VALUE;\n+        } else {\n+            ret = super.inverseCumulativeProbability(p);\n+        }\n+\n+        return ret;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Interface representing the Poisson Distribution.\n+ * \n+ * <p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/PoissonDistribution.html\">\n+ * Poisson distribution</a></li>\n+ * </ul>\n+ * </p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public interface PoissonDistribution extends IntegerDistribution {\n+\n+    /**\n+     * Get the mean for the distribution.\n+     * \n+     * @return the mean for the distribution.\n+     */\n+    public double getMean();\n+\n+    /**\n+     * Set the mean for the distribution.\n+     * The parameter value must be positive; otherwise an \n+     * <code>IllegalArgument</code> is thrown.\n+     * \n+     * @param p the mean\n+     * @throws IllegalArgumentException if p &le; 0\n+     */\n+    public void setMean(double p);\n+\n+    /**\n+     * Calculates the Poisson distribution function using a normal approximation.\n+     * \n+     * @param x the upper bound, inclusive\n+     * @return the distribution function value calculated using a normal approximation\n+     * @throws MathException if an error occurs computing the normal approximation\n+     */\n+    public double normalApproximateProbability(int x) throws MathException;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.special.Gamma;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Implementation for the {@link PoissonDistribution}.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class PoissonDistributionImpl extends AbstractIntegerDistribution\n+        implements PoissonDistribution, Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -3349935121172596109L;\n+\n+    /** Distribution used to compute normal approximation. */\n+    private NormalDistribution normal;\n+    \n+    /**\n+     * Holds the Poisson mean for the distribution.\n+     */\n+    private double mean;\n+\n+    /**\n+     * Create a new Poisson distribution with the given the mean.\n+     * The mean value must be positive; otherwise an \n+     * <code>IllegalArgument</code> is thrown.\n+     * \n+     * @param p the Poisson mean\n+     * @throws IllegalArgumentException if p &le; 0\n+     */\n+    public PoissonDistributionImpl(double p) {\n+        this(p, new NormalDistributionImpl());\n+    }\n+\n+    /**\n+     * Create a new Poisson distribution with the given the mean.\n+     * The mean value must be positive; otherwise an \n+     * <code>IllegalArgument</code> is thrown.\n+     * \n+     * @param p the Poisson mean\n+     * @param z a normal distribution used to compute normal approximations.\n+     * @throws IllegalArgumentException if p &le; 0\n+     * @since 1.2\n+     */\n+    public PoissonDistributionImpl(double p, NormalDistribution z) {\n+        super();\n+        setNormal(z);\n+        setMean(p);\n+    }\n+\n+    /**\n+     * Get the Poisson mean for the distribution.\n+     * \n+     * @return the Poisson mean for the distribution.\n+     */\n+    public double getMean() {\n+        return this.mean;\n+    }\n+\n+    /**\n+     * Set the Poisson mean for the distribution.\n+     * The mean value must be positive; otherwise an \n+     * <code>IllegalArgument</code> is thrown.\n+     * \n+     * @param p the Poisson mean value\n+     * @throws IllegalArgumentException if p &le; 0\n+     */\n+    public void setMean(double p) {\n+        if (p <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"the Poisson mean must be positive ({0})\",\n+                  p);\n+        }\n+        this.mean = p;\n+        normal.setMean(p);\n+        normal.setStandardDeviation(Math.sqrt(p));\n+    }\n+\n+    /**\n+     * The probability mass function P(X = x) for a Poisson distribution.\n+     * \n+     * @param x the value at which the probability density function is evaluated.\n+     * @return the value of the probability mass function at x\n+     */\n+    public double probability(int x) {\n+        if (x < 0 || x == Integer.MAX_VALUE) {\n+            return 0;\n+        }\n+        return Math.pow(getMean(), x) / \n+            MathUtils.factorialDouble(x) * Math.exp(-mean);\n+    }\n+    \n+    /**\n+     * The probability distribution function P(X <= x) for a Poisson distribution.\n+     * \n+     * @param x the value at which the PDF is evaluated.\n+     * @return Poisson distribution function evaluated at x\n+     * @throws MathException if the cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     */\n+    @Override\n+    public double cumulativeProbability(int x) throws MathException {\n+        if (x < 0) {\n+            return 0;\n+        }\n+        if (x == Integer.MAX_VALUE) {\n+            return 1;\n+        }\n+        return Gamma.regularizedGammaQ((double)x + 1, mean, \n+                1E-12, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Calculates the Poisson distribution function using a normal\n+     * approximation.  The <code>N(mean, sqrt(mean))</code>\n+     * distribution is used to approximate the Poisson distribution.\n+     * <p>\n+     * The computation uses \"half-correction\" -- evaluating the normal\n+     * distribution function at <code>x + 0.5</code></p>\n+     * \n+     * @param x the upper bound, inclusive\n+     * @return the distribution function value calculated using a normal approximation\n+     * @throws MathException if an error occurs computing the normal approximation\n+     */\n+    public double normalApproximateProbability(int x) throws MathException {\n+        // calculate the probability using half-correction\n+        return normal.cumulativeProbability(x + 0.5);\n+    }\n+\n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain lower bound\n+     */\n+    @Override\n+    protected int getDomainLowerBound(double p) {\n+        return 0;\n+    }\n+\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain upper bound\n+     */\n+    @Override\n+    protected int getDomainUpperBound(double p) {\n+        return Integer.MAX_VALUE;\n+    }\n+    \n+    /**\n+     * Modify the normal distribution used to compute normal approximations.\n+     * The caller is responsible for insuring the normal distribution has the\n+     * proper parameter settings.\n+     * @param value the new distribution\n+     * @since 1.2\n+     */\n+    public void setNormal(NormalDistribution value) {\n+        normal = value;\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/TDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Student's t-Distribution.\n+ *\n+ * <p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/Studentst-Distribution.html\">\n+ * Student's t-Distribution</a></li>\n+ * </ul>\n+ * </p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public interface TDistribution extends ContinuousDistribution {\n+    /**\n+     * Modify the degrees of freedom.\n+     * @param degreesOfFreedom the new degrees of freedom.\n+     */\n+    void setDegreesOfFreedom(double degreesOfFreedom);\n+    \n+    /**\n+     * Access the degrees of freedom.\n+     * @return the degrees of freedom.\n+     */\n+    double getDegreesOfFreedom();\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/TDistributionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.special.Beta;\n+\n+/**\n+ * Default implementation of\n+ * {@link org.apache.commons.math.distribution.TDistribution}.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class TDistributionImpl\n+    extends AbstractContinuousDistribution\n+    implements TDistribution, Serializable  {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -5852615386664158222L;\n+    \n+    /** The degrees of freedom*/\n+    private double degreesOfFreedom;\n+\n+    /**\n+     * Create a t distribution using the given degrees of freedom.\n+     * @param degreesOfFreedom the degrees of freedom.\n+     */\n+    public TDistributionImpl(double degreesOfFreedom) {\n+        super();\n+        setDegreesOfFreedom(degreesOfFreedom);\n+    }\n+\n+    /**\n+     * Modify the degrees of freedom.\n+     * @param degreesOfFreedom the new degrees of freedom.\n+     */\n+    public void setDegreesOfFreedom(double degreesOfFreedom) {\n+        if (degreesOfFreedom <= 0.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"degrees of freedom must be positive ({0})\",\n+                  degreesOfFreedom);\n+        }\n+        this.degreesOfFreedom = degreesOfFreedom;\n+    }\n+\n+    /**\n+     * Access the degrees of freedom.\n+     * @return the degrees of freedom.\n+     */\n+    public double getDegreesOfFreedom() {\n+        return degreesOfFreedom;\n+    }\n+\n+    /**\n+     * For this distribution, X, this method returns P(X &lt; <code>x</code>).\n+     * @param x the value at which the CDF is evaluated.\n+     * @return CDF evaluted at <code>x</code>. \n+     * @throws MathException if the cumulative probability can not be\n+     *            computed due to convergence or other numerical errors.\n+     */\n+    public double cumulativeProbability(double x) throws MathException{\n+        double ret;\n+        if (x == 0.0) {\n+            ret = 0.5;\n+        } else {\n+            double t =\n+                Beta.regularizedBeta(\n+                    getDegreesOfFreedom() / (getDegreesOfFreedom() + (x * x)),\n+                    0.5 * getDegreesOfFreedom(),\n+                    0.5);\n+            if (x < 0.0) {\n+                ret = 0.5 * t;\n+            } else {\n+                ret = 1.0 - 0.5 * t;\n+            }\n+        }\n+\n+        return ret;\n+    }\n+    \n+    /**\n+     * For this distribution, X, this method returns the critical point x, such\n+     * that P(X &lt; x) = <code>p</code>.\n+     * <p>\n+     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and \n+     * <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n+     *\n+     * @param p the desired probability\n+     * @return x, such that P(X &lt; x) = <code>p</code>\n+     * @throws MathException if the inverse cumulative probability can not be\n+     *         computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if <code>p</code> is not a valid\n+     *         probability.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(final double p) \n+    throws MathException {\n+        if (p == 0) {\n+            return Double.NEGATIVE_INFINITY;\n+        }\n+        if (p == 1) {\n+            return Double.POSITIVE_INFINITY;\n+        }\n+        return super.inverseCumulativeProbability(p);\n+    }\n+\n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        return -Double.MAX_VALUE;\n+    }\n+\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    @Override\n+    protected double getDomainUpperBound(double p) {\n+        return Double.MAX_VALUE;\n+    }\n+\n+    /**\n+     * Access the initial domain value, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return initial domain value\n+     */\n+    @Override\n+    protected double getInitialDomain(double p) {\n+        return 0.0;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * Weibull Distribution.  This interface defines the two parameter form of the\n+ * distribution as defined by\n+ * <a href=\"http://mathworld.wolfram.com/WeibullDistribution.html\">\n+ * Weibull Distribution</a>, equations (1) and (2).\n+ *\n+ * <p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/WeibullDistribution.html\">\n+ * Weibull Distribution</a></li>\n+ * </ul>\n+ * </p>\n+ *\n+ * @since 1.1\n+ * @version $Revision$ $Date$\n+ */\n+public interface WeibullDistribution extends ContinuousDistribution {\n+\n+    /**\n+     * Access the shape parameter.\n+     * @return the shape parameter.\n+     */\n+    double getShape();\n+    \n+    /**\n+     * Access the scale parameter.\n+     * @return the scale parameter.\n+     */\n+    double getScale();\n+    \n+    /**\n+     * Modify the shape parameter.\n+     * @param alpha The new shape parameter value.\n+     */\n+    void setShape(double alpha);\n+    \n+    /**\n+     * Modify the scale parameter.\n+     * @param beta The new scale parameter value.\n+     */\n+    void setScale(double beta);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Default implementation of\n+ * {@link org.apache.commons.math.distribution.WeibullDistribution}.\n+ *\n+ * @since 1.1\n+ * @version $Revision$ $Date$\n+ */\n+public class WeibullDistributionImpl extends AbstractContinuousDistribution\n+        implements WeibullDistribution, Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 8589540077390120676L;\n+    \n+    /** The shape parameter. */\n+    private double alpha;\n+    \n+    /** The scale parameter. */\n+    private double beta;\n+    \n+    /**\n+     * Creates weibull distribution with the given shape and scale and a\n+     * location equal to zero.\n+     * @param alpha the shape parameter.\n+     * @param beta the scale parameter.\n+     */\n+    public WeibullDistributionImpl(double alpha, double beta){\n+        super();\n+        setShape(alpha);\n+        setScale(beta);\n+    }\n+\n+    /**\n+     * For this distribution, X, this method returns P(X &lt; <code>x</code>).\n+     * @param x the value at which the CDF is evaluated.\n+     * @return CDF evaluted at <code>x</code>. \n+     */\n+    public double cumulativeProbability(double x) {\n+        double ret;\n+        if (x <= 0.0) {\n+            ret = 0.0;\n+        } else {\n+            ret = 1.0 - Math.exp(-Math.pow(x / getScale(), getShape()));\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Access the shape parameter.\n+     * @return the shape parameter.\n+     */\n+    public double getShape() {\n+        return alpha;\n+    }\n+    \n+    /**\n+     * Access the scale parameter.\n+     * @return the scale parameter.\n+     */\n+    public double getScale() {\n+        return beta;\n+    }\n+    \n+    /**\n+     * For this distribution, X, this method returns the critical point x, such\n+     * that P(X &lt; x) = <code>p</code>.\n+     * <p>\n+     * Returns <code>Double.NEGATIVE_INFINITY</code> for p=0 and \n+     * <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n+     *\n+     * @param p the desired probability\n+     * @return x, such that P(X &lt; x) = <code>p</code>\n+     * @throws IllegalArgumentException if <code>p</code> is not a valid\n+     *         probability.\n+     */\n+    @Override\n+    public double inverseCumulativeProbability(double p) {\n+        double ret;\n+        if (p < 0.0 || p > 1.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n+        } else if (p == 0) {\n+            ret = 0.0;\n+        } else  if (p == 1) {\n+            ret = Double.POSITIVE_INFINITY;\n+        } else {\n+            ret = getScale() * Math.pow(-Math.log(1.0 - p), 1.0 / getShape());\n+        }\n+        return ret;\n+    }\n+    \n+    /**\n+     * Modify the shape parameter.\n+     * @param alpha the new shape parameter value.\n+     */\n+    public void setShape(double alpha) {\n+        if (alpha <= 0.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"shape must be positive ({0})\",\n+                  alpha);\n+        }       \n+        this.alpha = alpha;\n+    }\n+    \n+    /**\n+     * Modify the scale parameter.\n+     * @param beta the new scale parameter value.\n+     */\n+    public void setScale(double beta) {\n+        if (beta <= 0.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"scale must be positive ({0})\",\n+                  beta);\n+        }       \n+        this.beta = beta;\n+    }\n+\n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     */\n+    @Override\n+    protected double getDomainLowerBound(double p) {\n+        return 0.0;\n+    }\n+\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    @Override\n+    protected double getDomainUpperBound(double p) {\n+        return Double.MAX_VALUE;\n+    }\n+\n+    /**\n+     * Access the initial domain value, based on <code>p</code>, used to\n+     * bracket a CDF root.  This method is used by\n+     * {@link #inverseCumulativeProbability(double)} to find critical values.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return initial domain value\n+     */\n+    @Override\n+    protected double getInitialDomain(double p) {\n+        // use median\n+        return Math.pow(getScale() * Math.log(2.0), 1.0 / getShape());\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/ZipfDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+/**\n+ * The Zipf (or zeta) Distribution.\n+ * <p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/ZipfDistribution.html\">Zipf \n+ * Distribution</a></li>\n+ * </ul>\n+ * </p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public interface ZipfDistribution extends IntegerDistribution {\n+    /**\n+     * Get the number of elements (e.g. corpus size) for the distribution.\n+     * \n+     * @return the number of elements\n+     */\n+    public int getNumberOfElements();\n+\n+    /**\n+     * Set the number of elements (e.g. corpus size) for the distribution.\n+     * The parameter value must be positive; otherwise an \n+     * <code>IllegalArgumentException</code> is thrown.\n+     * \n+     * @param n the number of elements\n+     * @throws IllegalArgumentException if n &le; 0\n+     */\n+    public void setNumberOfElements(int n);\n+\n+    /**\n+     * Get the exponent characterising the distribution.\n+     * \n+     * @return the exponent\n+     */\n+    public double getExponent();\n+\n+    /**\n+     * Set the exponent characterising the distribution.\n+     * The parameter value must be positive; otherwise an \n+     * <code>IllegalArgumentException</code> is thrown.\n+     * \n+     * @param s the exponent\n+     * @throws IllegalArgumentException if s &le; 0.0\n+     */\n+    public void setExponent(double s);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/distribution/ZipfDistributionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.distribution;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Implementation for the {@link ZipfDistribution}.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class ZipfDistributionImpl extends AbstractIntegerDistribution \n+    implements ZipfDistribution, Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -140627372283420404L;\n+\n+    /** Number of elements. */\n+    private int numberOfElements;\n+\n+    /** Exponent parameter of the distribution. */\n+    private double exponent;\n+\n+    /**\n+     * Create a new Zipf distribution with the given number of elements and \n+     * exponent. Both values must be positive; otherwise an \n+     * <code>IllegalArgumentException</code> is thrown.\n+     * \n+     * @param numberOfElements the number of elements\n+     * @param exponent the exponent\n+     * @exception IllegalArgumentException if n &le; 0 or s &le; 0.0\n+     */\n+    public ZipfDistributionImpl(final int numberOfElements, final double exponent)\n+        throws IllegalArgumentException {\n+        setNumberOfElements(numberOfElements);\n+        setExponent(exponent);\n+    }\n+\n+    /**\n+     * Get the number of elements (e.g. corpus size) for the distribution.\n+     * \n+     * @return the number of elements\n+     */\n+    public int getNumberOfElements() {\n+        return numberOfElements;\n+    }\n+\n+    /**\n+     * Set the number of elements (e.g. corpus size) for the distribution.\n+     * The parameter value must be positive; otherwise an \n+     * <code>IllegalArgumentException</code> is thrown.\n+     * \n+     * @param n the number of elements\n+     * @exception IllegalArgumentException if n &le; 0\n+     */\n+    public void setNumberOfElements(final int n)\n+        throws IllegalArgumentException {\n+        if (n <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid number of elements {0} (must be positive)\",\n+                    n);\n+        }\n+        this.numberOfElements = n;\n+    }\n+    \n+    /**\n+     * Get the exponent characterising the distribution.\n+     * \n+     * @return the exponent\n+     */\n+    public double getExponent() {\n+        return exponent;\n+    }\n+\n+    /**\n+     * Set the exponent characterising the distribution.\n+     * The parameter value must be positive; otherwise an \n+     * <code>IllegalArgumentException</code> is thrown.\n+     * \n+     * @param s the exponent\n+     * @exception IllegalArgumentException if s &le; 0.0\n+     */\n+    public void setExponent(final double s)\n+        throws IllegalArgumentException {\n+        if (s <= 0.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid exponent {0} (must be positive)\",\n+                    s);\n+        }\n+        this.exponent = s;\n+    }\n+\n+    /**\n+     * The probability mass function P(X = x) for a Zipf distribution.\n+     * \n+     * @param x the value at which the probability density function is evaluated.\n+     * @return the value of the probability mass function at x\n+     */\n+    public double probability(final int x) {\n+        if (x <= 0 || x > getNumberOfElements()) {\n+            return 0.0;\n+        }\n+\n+        return (1.0 / Math.pow(x, exponent)) / generalizedHarmonic(numberOfElements, exponent);\n+\n+    }\n+    \n+    /**\n+     * The probability distribution function P(X <= x) for a Zipf distribution.\n+     * \n+     * @param x the value at which the PDF is evaluated.\n+     * @return Zipf distribution function evaluated at x\n+     */\n+    @Override\n+    public double cumulativeProbability(final int x) {\n+        if (x <= 0) {\n+            return 0.0;\n+        } else if (x >= getNumberOfElements()) {\n+            return 1.0;\n+        }\n+\n+        return generalizedHarmonic(x, exponent) / generalizedHarmonic(numberOfElements, exponent);\n+\n+    }\n+\n+    /**\n+     * Access the domain value lower bound, based on <code>p</code>, used to\n+     * bracket a PDF root.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value lower bound, i.e.\n+     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code> \n+     */\n+    @Override\n+    protected int getDomainLowerBound(final double p) {\n+        return 0;\n+    }\n+\n+    /**\n+     * Access the domain value upper bound, based on <code>p</code>, used to\n+     * bracket a PDF root.\n+     * \n+     * @param p the desired probability for the critical value\n+     * @return domain value upper bound, i.e.\n+     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code> \n+     */\n+    @Override\n+    protected int getDomainUpperBound(final double p) {\n+        return numberOfElements;\n+    }\n+\n+\n+    /**\n+     * Calculates the Nth generalized harmonic number. See \n+     * <a href=\"http://mathworld.wolfram.com/HarmonicSeries.html\">Harmonic \n+     * Series</a>.\n+     * \n+     * @param n the term in the series to calculate (must be &ge; 1)\n+     * @param m the exponent; special case m == 1.0 is the harmonic series\n+     * @return the nth generalized harmonic number\n+     */\n+    private double generalizedHarmonic(final int n, final double m) {\n+        double value = 0;\n+        for (int k = n; k > 0; --k) {\n+            value += 1.0 / Math.pow(k, m);\n+        }\n+        return value;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/estimation/AbstractEstimator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.estimation;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.linear.InvalidMatrixException;\n+import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.RealMatrix;\n+\n+/**\n+ * Base class for implementing estimators.\n+ * <p>This base class handles the boilerplates methods associated to thresholds\n+ * settings, jacobian and error estimation.</p>\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ * @deprecated as of 2.0, everything in package org.apache.commons.math.estimation has\n+ * been deprecated and replaced by package org.apache.commons.math.optimization.general\n+ *\n+ */\n+@Deprecated\n+public abstract class AbstractEstimator implements Estimator {\n+\n+    /** Default maximal number of cost evaluations allowed. */\n+    public static final int DEFAULT_MAX_COST_EVALUATIONS = 100;\n+\n+    /**\n+     * Build an abstract estimator for least squares problems.\n+     * <p>The maximal number of cost evaluations allowed is set\n+     * to its default value {@link #DEFAULT_MAX_COST_EVALUATIONS}.</p>\n+     */\n+    protected AbstractEstimator() {\n+        setMaxCostEval(DEFAULT_MAX_COST_EVALUATIONS);\n+    }\n+\n+    /**\n+     * Set the maximal number of cost evaluations allowed.\n+     * \n+     * @param maxCostEval maximal number of cost evaluations allowed\n+     * @see #estimate\n+     */\n+    public final void setMaxCostEval(int maxCostEval) {\n+        this.maxCostEval = maxCostEval;\n+    }\n+\n+    /**\n+     * Get the number of cost evaluations.\n+     * \n+     * @return number of cost evaluations\n+     * */\n+    public final int getCostEvaluations() {\n+        return costEvaluations;\n+    }\n+\n+    /** \n+     * Get the number of jacobian evaluations.\n+     * \n+     * @return number of jacobian evaluations\n+     * */\n+    public final int getJacobianEvaluations() {\n+        return jacobianEvaluations;\n+    }\n+\n+    /** \n+     * Update the jacobian matrix.\n+     */\n+    protected void updateJacobian() {\n+        incrementJacobianEvaluationsCounter();\n+        Arrays.fill(jacobian, 0);\n+        for (int i = 0, index = 0; i < rows; i++) {\n+            WeightedMeasurement wm = measurements[i];\n+            double factor = -Math.sqrt(wm.getWeight());\n+            for (int j = 0; j < cols; ++j) {\n+                jacobian[index++] = factor * wm.getPartial(parameters[j]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Increment the jacobian evaluations counter.\n+     */\n+    protected final void incrementJacobianEvaluationsCounter() {\n+      ++jacobianEvaluations;\n+    }\n+\n+    /** \n+     * Update the residuals array and cost function value.\n+     * @exception EstimationException if the number of cost evaluations\n+     * exceeds the maximum allowed\n+     */\n+    protected void updateResidualsAndCost()\n+    throws EstimationException {\n+\n+        if (++costEvaluations > maxCostEval) {\n+            throw new EstimationException(\"maximal number of evaluations exceeded ({0})\",\n+                                          maxCostEval);\n+        }\n+\n+        cost = 0;\n+        for (int i = 0, index = 0; i < rows; i++, index += cols) {\n+            WeightedMeasurement wm = measurements[i];\n+            double residual = wm.getResidual();\n+            residuals[i] = Math.sqrt(wm.getWeight()) * residual;\n+            cost += wm.getWeight() * residual * residual;\n+        }\n+        cost = Math.sqrt(cost);\n+\n+    }\n+\n+    /** \n+     * Get the Root Mean Square value.\n+     * Get the Root Mean Square value, i.e. the root of the arithmetic\n+     * mean of the square of all weighted residuals. This is related to the\n+     * criterion that is minimized by the estimator as follows: if\n+     * <em>c</em> if the criterion, and <em>n</em> is the number of\n+     * measurements, then the RMS is <em>sqrt (c/n)</em>.\n+     * \n+     * @param problem estimation problem\n+     * @return RMS value\n+     */\n+    public double getRMS(EstimationProblem problem) {\n+        WeightedMeasurement[] wm = problem.getMeasurements();\n+        double criterion = 0;\n+        for (int i = 0; i < wm.length; ++i) {\n+            double residual = wm[i].getResidual();\n+            criterion += wm[i].getWeight() * residual * residual;\n+        }\n+        return Math.sqrt(criterion / wm.length);\n+    }\n+\n+    /**\n+     * Get the Chi-Square value.\n+     * @param problem estimation problem\n+     * @return chi-square value\n+     */\n+    public double getChiSquare(EstimationProblem problem) {\n+        WeightedMeasurement[] wm = problem.getMeasurements();\n+        double chiSquare = 0;\n+        for (int i = 0; i < wm.length; ++i) {\n+            double residual = wm[i].getResidual();\n+            chiSquare += residual * residual / wm[i].getWeight();\n+        }\n+        return chiSquare;\n+    }\n+\n+    /**\n+     * Get the covariance matrix of unbound estimated parameters.\n+     * @param problem estimation problem\n+     * @return covariance matrix\n+     * @exception EstimationException if the covariance matrix\n+     * cannot be computed (singular problem)\n+     */\n+    public double[][] getCovariances(EstimationProblem problem)\n+      throws EstimationException {\n+ \n+        // set up the jacobian\n+        updateJacobian();\n+\n+        // compute transpose(J).J, avoiding building big intermediate matrices\n+        final int rows = problem.getMeasurements().length;\n+        final int cols = problem.getUnboundParameters().length;\n+        final int max  = cols * rows;\n+        double[][] jTj = new double[cols][cols];\n+        for (int i = 0; i < cols; ++i) {\n+            for (int j = i; j < cols; ++j) {\n+                double sum = 0;\n+                for (int k = 0; k < max; k += cols) {\n+                    sum += jacobian[k + i] * jacobian[k + j];\n+                }\n+                jTj[i][j] = sum;\n+                jTj[j][i] = sum;\n+            }\n+        }\n+\n+        try {\n+            // compute the covariances matrix\n+            RealMatrix inverse =\n+                new LUDecompositionImpl(MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\n+            return inverse.getData();\n+        } catch (InvalidMatrixException ime) {\n+            throw new EstimationException(\"unable to compute covariances: singular problem\");\n+        }\n+\n+    }\n+\n+    /**\n+     * Guess the errors in unbound estimated parameters.\n+     * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>\n+     * @param problem estimation problem\n+     * @return errors in estimated parameters\n+     * @exception EstimationException if the covariances matrix cannot be computed\n+     * or the number of degrees of freedom is not positive (number of measurements\n+     * lesser or equal to number of parameters)\n+     */\n+    public double[] guessParametersErrors(EstimationProblem problem)\n+      throws EstimationException {\n+        int m = problem.getMeasurements().length;\n+        int p = problem.getUnboundParameters().length;\n+        if (m <= p) {\n+            throw new EstimationException(\n+                    \"no degrees of freedom ({0} measurements, {1} parameters)\",\n+                    m, p);\n+        }\n+        double[] errors = new double[problem.getUnboundParameters().length];\n+        final double c = Math.sqrt(getChiSquare(problem) / (m - p));\n+        double[][] covar = getCovariances(problem);\n+        for (int i = 0; i < errors.length; ++i) {\n+            errors[i] = Math.sqrt(covar[i][i]) * c;\n+        }\n+        return errors;\n+    }\n+\n+    /**\n+     * Initialization of the common parts of the estimation.\n+     * <p>This method <em>must</em> be called at the start\n+     * of the {@link #estimate(EstimationProblem) estimate}\n+     * method.</p>\n+     * @param problem estimation problem to solve\n+     */\n+    protected void initializeEstimate(EstimationProblem problem) {\n+\n+        // reset counters\n+        costEvaluations     = 0;\n+        jacobianEvaluations = 0;\n+\n+        // retrieve the equations and the parameters\n+        measurements = problem.getMeasurements();\n+        parameters   = problem.getUnboundParameters();\n+\n+        // arrays shared with the other private methods\n+        rows      = measurements.length;\n+        cols      = parameters.length;\n+        jacobian  = new double[rows * cols];\n+        residuals = new double[rows];\n+\n+        cost = Double.POSITIVE_INFINITY;\n+\n+    }\n+\n+    /** \n+     * Solve an estimation problem.\n+     *\n+     * <p>The method should set the parameters of the problem to several\n+     * trial values until it reaches convergence. If this method returns\n+     * normally (i.e. without throwing an exception), then the best\n+     * estimate of the parameters can be retrieved from the problem\n+     * itself, through the {@link EstimationProblem#getAllParameters\n+     * EstimationProblem.getAllParameters} method.</p>\n+     *\n+     * @param problem estimation problem to solve\n+     * @exception EstimationException if the problem cannot be solved\n+     *\n+     */\n+    public abstract void estimate(EstimationProblem problem)\n+    throws EstimationException;\n+\n+    /** Array of measurements. */\n+    protected WeightedMeasurement[] measurements;\n+\n+    /** Array of parameters. */\n+    protected EstimatedParameter[] parameters;\n+\n+    /** \n+     * Jacobian matrix.\n+     * <p>This matrix is in canonical form just after the calls to\n+     * {@link #updateJacobian()}, but may be modified by the solver\n+     * in the derived class (the {@link LevenbergMarquardtEstimator\n+     * Levenberg-Marquardt estimator} does this).</p>\n+     */\n+    protected double[] jacobian;\n+\n+    /** Number of columns of the jacobian matrix. */\n+    protected int cols;\n+\n+    /** Number of rows of the jacobian matrix. */\n+    protected int rows;\n+\n+    /** Residuals array.\n+     * <p>This array is in canonical form just after the calls to\n+     * {@link #updateJacobian()}, but may be modified by the solver\n+     * in the derived class (the {@link LevenbergMarquardtEstimator\n+     * Levenberg-Marquardt estimator} does this).</p>\n+     */\n+    protected double[] residuals;\n+\n+    /** Cost value (square root of the sum of the residuals). */\n+    protected double cost;\n+\n+    /** Maximal allowed number of cost evaluations. */\n+    private int maxCostEval;\n+\n+    /** Number of cost evaluations. */\n+    private int costEvaluations;\n+\n+    /** Number of jacobian evaluations. */\n+    private int jacobianEvaluations;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/estimation/EstimatedParameter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.estimation;\n+\n+import java.io.Serializable;\n+\n+/** This class represents the estimated parameters of an estimation problem.\n+ *\n+ * <p>The parameters of an estimation problem have a name, a value and\n+ * a bound flag. The value of bound parameters is considered trusted\n+ * and the solvers should not adjust them. On the other hand, the\n+ * solvers should adjust the value of unbounds parameters until they\n+ * satisfy convergence criterions specific to each solver.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ * @deprecated as of 2.0, everything in package org.apache.commons.math.estimation has\n+ * been deprecated and replaced by package org.apache.commons.math.optimization.general\n+ *\n+ */\n+@Deprecated\n+public class EstimatedParameter\n+  implements Serializable {\n+\n+  /** Simple constructor.\n+   * Build an instance from a first estimate of the parameter,\n+   * initially considered unbound.\n+   * @param name name of the parameter\n+   * @param firstEstimate first estimate of the parameter\n+   */\n+  public EstimatedParameter(String name, double firstEstimate) {\n+    this.name = name;\n+    estimate  = firstEstimate;\n+    bound     = false;\n+  }\n+\n+  /** Simple constructor.\n+   * Build an instance from a first estimate of the parameter and a\n+   * bound flag\n+   * @param name name of the parameter\n+   * @param firstEstimate first estimate of the parameter\n+   * @param bound flag, should be true if the parameter is bound\n+   */\n+  public EstimatedParameter(String name,\n+                            double firstEstimate,\n+                            boolean bound) {\n+    this.name  = name;\n+    estimate   = firstEstimate;\n+    this.bound = bound;\n+  }\n+\n+  /** Copy constructor.\n+   * Build a copy of a parameter\n+   * @param parameter instance to copy\n+   */\n+  public EstimatedParameter(EstimatedParameter parameter) {\n+    name     = parameter.name;\n+    estimate = parameter.estimate;\n+    bound    = parameter.bound;\n+  }\n+\n+  /** Set a new estimated value for the parameter.\n+   * @param estimate new estimate for the parameter\n+   */\n+  public void setEstimate(double estimate) {\n+    this.estimate = estimate;\n+  }\n+\n+  /** Get the current estimate of the parameter\n+   * @return current estimate\n+   */\n+  public double getEstimate() {\n+    return estimate;\n+  }\n+\n+  /** get the name of the parameter\n+   * @return parameter name\n+   */\n+  public String getName() {\n+    return name;\n+  }\n+\n+  /** Set the bound flag of the parameter\n+   * @param bound this flag should be set to true if the parameter is\n+   * bound (i.e. if it should not be adjusted by the solver).\n+   */\n+  public void setBound(boolean bound) {\n+    this.bound = bound;\n+  }\n+\n+  /** Check if the parameter is bound\n+   * @return true if the parameter is bound */\n+  public boolean isBound() {\n+    return bound;\n+  }\n+\n+  /** Name of the parameter */\n+  private   String  name;\n+\n+  /** Current value of the parameter */\n+  protected double  estimate;\n+\n+  /** Indicator for bound parameters\n+   * (ie parameters that should not be estimated)\n+   */\n+  private   boolean bound;\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -555440800213416949L;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/estimation/EstimationException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.estimation;\n+\n+import org.apache.commons.math.MathException;\n+\n+/** \n+ * This class represents exceptions thrown by the estimation solvers.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ * @deprecated as of 2.0, everything in package org.apache.commons.math.estimation has\n+ * been deprecated and replaced by package org.apache.commons.math.optimization.general\n+ *\n+ */\n+@Deprecated\n+public class EstimationException\n+extends MathException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -573038581493881337L;\n+\n+    /** \n+     * Simple constructor.\n+     * Build an exception by translating and formating a message\n+     * @param specifier format specifier (to be translated)\n+     * @param parts to insert in the format (no translation)\n+     */\n+    public EstimationException(String specifier, Object ... parts) {\n+        super(specifier, parts);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/estimation/EstimationProblem.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.estimation;\n+\n+/** \n+ * This interface represents an estimation problem.\n+ *\n+ * <p>This interface should be implemented by all real estimation\n+ * problems before they can be handled by the estimators through the\n+ * {@link Estimator#estimate Estimator.estimate} method.</p>\n+ *\n+ * <p>An estimation problem, as seen by a solver is a set of\n+ * parameters and a set of measurements. The parameters are adjusted\n+ * during the estimation through the {@link #getUnboundParameters\n+ * getUnboundParameters} and {@link EstimatedParameter#setEstimate\n+ * EstimatedParameter.setEstimate} methods. The measurements both have\n+ * a measured value which is generally fixed at construction and a\n+ * theoretical value which depends on the model and hence varies as\n+ * the parameters are adjusted. The purpose of the solver is to reduce\n+ * the residual between these values, it can retrieve the measurements\n+ * through the {@link #getMeasurements getMeasurements} method.</p>\n+ *\n+ * @see Estimator\n+ * @see WeightedMeasurement\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ * @deprecated as of 2.0, everything in package org.apache.commons.math.estimation has\n+ * been deprecated and replaced by package org.apache.commons.math.optimization.general\n+ *\n+ */\n+@Deprecated\n+public interface EstimationProblem {\n+  /** \n+   * Get the measurements of an estimation problem.\n+   * @return measurements\n+   */\n+  public WeightedMeasurement[] getMeasurements();\n+\n+  /** \n+   * Get the unbound parameters of the problem.\n+   * @return unbound parameters\n+   */\n+  public EstimatedParameter[] getUnboundParameters();\n+\n+  /** \n+   * Get all the parameters of the problem.\n+   * @return parameters\n+   */\n+  public EstimatedParameter[] getAllParameters();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/estimation/Estimator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.estimation;\n+\n+/**\n+ * This interface represents solvers for estimation problems.\n+ *\n+ * <p>The classes which are devoted to solve estimation problems\n+ * should implement this interface. The problems which can be handled\n+ * should implement the {@link EstimationProblem} interface which\n+ * gather all the information needed by the solver.</p>\n+ *\n+ * <p>The interface is composed only of the {@link #estimate estimate}\n+ * method.</p>\n+ *\n+ * @see EstimationProblem\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ * @deprecated as of 2.0, everything in package org.apache.commons.math.estimation has\n+ * been deprecated and replaced by package org.apache.commons.math.optimization.general\n+ *\n+ */\n+@Deprecated\n+public interface Estimator {\n+\n+  /** \n+   * Solve an estimation problem.\n+   *\n+   * <p>The method should set the parameters of the problem to several\n+   * trial values until it reaches convergence. If this method returns\n+   * normally (i.e. without throwing an exception), then the best\n+   * estimate of the parameters can be retrieved from the problem\n+   * itself, through the {@link EstimationProblem#getAllParameters\n+   * EstimationProblem.getAllParameters} method.</p>\n+   *\n+   * @param problem estimation problem to solve\n+   * @exception EstimationException if the problem cannot be solved\n+   *\n+   */\n+  public void estimate(EstimationProblem problem)\n+    throws EstimationException;\n+\n+  /** \n+   * Get the Root Mean Square value.\n+   * Get the Root Mean Square value, i.e. the root of the arithmetic\n+   * mean of the square of all weighted residuals. This is related to the\n+   * criterion that is minimized by the estimator as follows: if\n+   * <em>c</em> is the criterion, and <em>n</em> is the number of\n+   * measurements, then the RMS is <em>sqrt (c/n)</em>.\n+   * @see #guessParametersErrors(EstimationProblem)\n+   * \n+   * @param problem estimation problem\n+   * @return RMS value\n+   */\n+  public double getRMS(EstimationProblem problem);\n+\n+  /**\n+   * Get the covariance matrix of estimated parameters.\n+   * @param problem estimation problem\n+   * @return covariance matrix\n+   * @exception EstimationException if the covariance matrix\n+   * cannot be computed (singular problem)\n+   */\n+  public double[][] getCovariances(EstimationProblem problem)\n+    throws EstimationException;\n+\n+  /**\n+   * Guess the errors in estimated parameters.\n+   * @see #getRMS(EstimationProblem)\n+   * @param problem estimation problem\n+   * @return errors in estimated parameters\n+     * @exception EstimationException if the error cannot be guessed\n+   */\n+  public double[] guessParametersErrors(EstimationProblem problem)\n+    throws EstimationException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.estimation;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.linear.InvalidMatrixException;\n+import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.linear.ArrayRealVector;\n+\n+/** \n+ * This class implements a solver for estimation problems.\n+ *\n+ * <p>This class solves estimation problems using a weighted least\n+ * squares criterion on the measurement residuals. It uses a\n+ * Gauss-Newton algorithm.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ * @deprecated as of 2.0, everything in package org.apache.commons.math.estimation has\n+ * been deprecated and replaced by package org.apache.commons.math.optimization.general\n+ *\n+ */\n+@Deprecated\n+public class GaussNewtonEstimator extends AbstractEstimator implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 5485001826076289109L;\n+\n+    /** Default threshold for cost steady state detection. */\n+    private static final double DEFAULT_STEADY_STATE_THRESHOLD = 1.0e-6;\n+\n+    /** Default threshold for cost convergence. */\n+    private static final double DEFAULT_CONVERGENCE = 1.0e-6;\n+\n+    /** Threshold for cost steady state detection. */\n+    private double steadyStateThreshold;\n+\n+    /** Threshold for cost convergence. */\n+    private double convergence;\n+\n+    /** Simple constructor with default settings.\n+     * <p>\n+     * The estimator is built with default values for all settings.\n+     * </p>\n+     * @see #DEFAULT_STEADY_STATE_THRESHOLD\n+     * @see #DEFAULT_CONVERGENCE\n+     * @see AbstractEstimator#DEFAULT_MAX_COST_EVALUATIONS\n+     */\n+    public GaussNewtonEstimator() {\n+        this.steadyStateThreshold = DEFAULT_STEADY_STATE_THRESHOLD;\n+        this.convergence          = DEFAULT_CONVERGENCE;        \n+    }\n+\n+    /** \n+     * Simple constructor.\n+     *\n+     * <p>This constructor builds an estimator and stores its convergence\n+     * characteristics.</p>\n+     *\n+     * <p>An estimator is considered to have converged whenever either\n+     * the criterion goes below a physical threshold under which\n+     * improvements are considered useless or when the algorithm is\n+     * unable to improve it (even if it is still high). The first\n+     * condition that is met stops the iterations.</p>\n+     *\n+     * <p>The fact an estimator has converged does not mean that the\n+     * model accurately fits the measurements. It only means no better\n+     * solution can be found, it does not mean this one is good. Such an\n+     * analysis is left to the caller.</p>\n+     *\n+     * <p>If neither conditions are fulfilled before a given number of\n+     * iterations, the algorithm is considered to have failed and an\n+     * {@link EstimationException} is thrown.</p>\n+     *\n+     * @param maxCostEval maximal number of cost evaluations allowed\n+     * @param convergence criterion threshold below which we do not need\n+     * to improve the criterion anymore\n+     * @param steadyStateThreshold steady state detection threshold, the\n+     * problem has converged has reached a steady state if\n+     * <code>Math.abs(J<sub>n</sub> - J<sub>n-1</sub>) &lt;\n+     * J<sub>n</sub> &times convergence</code>, where <code>J<sub>n</sub></code>\n+     * and <code>J<sub>n-1</sub></code> are the current and preceding criterion\n+     * values (square sum of the weighted residuals of considered measurements).\n+     */\n+    public GaussNewtonEstimator(final int maxCostEval, final double convergence,\n+                                final double steadyStateThreshold) {\n+        setMaxCostEval(maxCostEval);\n+        this.steadyStateThreshold = steadyStateThreshold;\n+        this.convergence          = convergence;\n+    }\n+\n+    /**\n+     * Set the convergence criterion threshold.\n+     * @param convergence criterion threshold below which we do not need\n+     * to improve the criterion anymore\n+     */\n+    public void setConvergence(final double convergence) {\n+        this.convergence = convergence;\n+    }\n+\n+    /**\n+     * Set the steady state detection threshold.\n+     * <p>\n+     * The problem has converged has reached a steady state if\n+     * <code>Math.abs(J<sub>n</sub> - J<sub>n-1</sub>) &lt;\n+     * J<sub>n</sub> &times convergence</code>, where <code>J<sub>n</sub></code>\n+     * and <code>J<sub>n-1</sub></code> are the current and preceding criterion\n+     * values (square sum of the weighted residuals of considered measurements).\n+     * </p>\n+     * @param steadyStateThreshold steady state detection threshold\n+     */\n+    public void setSteadyStateThreshold(final double steadyStateThreshold) {\n+        this.steadyStateThreshold = steadyStateThreshold;\n+    }\n+\n+    /** \n+     * Solve an estimation problem using a least squares criterion.\n+     *\n+     * <p>This method set the unbound parameters of the given problem\n+     * starting from their current values through several iterations. At\n+     * each step, the unbound parameters are changed in order to\n+     * minimize a weighted least square criterion based on the\n+     * measurements of the problem.</p>\n+     *\n+     * <p>The iterations are stopped either when the criterion goes\n+     * below a physical threshold under which improvement are considered\n+     * useless or when the algorithm is unable to improve it (even if it\n+     * is still high). The first condition that is met stops the\n+     * iterations. If the convergence it not reached before the maximum\n+     * number of iterations, an {@link EstimationException} is\n+     * thrown.</p>\n+     *\n+     * @param problem estimation problem to solve\n+     * @exception EstimationException if the problem cannot be solved\n+     *\n+     * @see EstimationProblem\n+     *\n+     */\n+    @Override\n+    public void estimate(EstimationProblem problem)\n+    throws EstimationException {\n+\n+        initializeEstimate(problem);\n+\n+        // work matrices\n+        double[] grad             = new double[parameters.length];\n+        ArrayRealVector bDecrement = new ArrayRealVector(parameters.length);\n+        double[] bDecrementData   = bDecrement.getDataRef();\n+        RealMatrix wGradGradT     = MatrixUtils.createRealMatrix(parameters.length, parameters.length);\n+\n+        // iterate until convergence is reached\n+        double previous = Double.POSITIVE_INFINITY;\n+        do {\n+\n+            // build the linear problem\n+            incrementJacobianEvaluationsCounter();\n+            RealVector b = new ArrayRealVector(parameters.length);\n+            RealMatrix a = MatrixUtils.createRealMatrix(parameters.length, parameters.length);\n+            for (int i = 0; i < measurements.length; ++i) {\n+                if (! measurements [i].isIgnored()) {\n+\n+                    double weight   = measurements[i].getWeight();\n+                    double residual = measurements[i].getResidual();\n+\n+                    // compute the normal equation\n+                    for (int j = 0; j < parameters.length; ++j) {\n+                        grad[j] = measurements[i].getPartial(parameters[j]);\n+                        bDecrementData[j] = weight * residual * grad[j];\n+                    }\n+\n+                    // build the contribution matrix for measurement i\n+                    for (int k = 0; k < parameters.length; ++k) {\n+                        double gk = grad[k];\n+                        for (int l = 0; l < parameters.length; ++l) {\n+                            wGradGradT.setEntry(k, l, weight * gk * grad[l]);\n+                        }\n+                    }\n+\n+                    // update the matrices\n+                    a = a.add(wGradGradT);\n+                    b = b.add(bDecrement);\n+\n+                }\n+            }\n+\n+            try {\n+\n+                // solve the linearized least squares problem\n+                RealVector dX = new LUDecompositionImpl(a).getSolver().solve(b);\n+\n+                // update the estimated parameters\n+                for (int i = 0; i < parameters.length; ++i) {\n+                    parameters[i].setEstimate(parameters[i].getEstimate() + dX.getEntry(i));\n+                }\n+\n+            } catch(InvalidMatrixException e) {\n+                throw new EstimationException(\"unable to solve: singular problem\");\n+            }\n+\n+\n+            previous = cost;\n+            updateResidualsAndCost();\n+\n+        } while ((getCostEvaluations() < 2) ||\n+                 (Math.abs(previous - cost) > (cost * steadyStateThreshold) &&\n+                  (Math.abs(cost) > convergence)));\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/estimation/LevenbergMarquardtEstimator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.estimation;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+\n+/** \n+ * This class solves a least squares problem.\n+ *\n+ * <p>This implementation <em>should</em> work even for over-determined systems\n+ * (i.e. systems having more variables than equations). Over-determined systems\n+ * are solved by ignoring the variables which have the smallest impact according\n+ * to their jacobian column norm. Only the rank of the matrix and some loop bounds\n+ * are changed to implement this.</p>\n+ *\n+ * <p>The resolution engine is a simple translation of the MINPACK <a\n+ * href=\"http://www.netlib.org/minpack/lmder.f\">lmder</a> routine with minor\n+ * changes. The changes include the over-determined resolution and the Q.R.\n+ * decomposition which has been rewritten following the algorithm described in the\n+ * P. Lascaux and R. Theodor book <i>Analyse num&eacute;rique matricielle\n+ * appliqu&eacute;e &agrave; l'art de l'ing&eacute;nieur</i>, Masson 1986. The\n+ * redistribution policy for MINPACK is available <a\n+ * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for convenience, it\n+ * is reproduced below.</p>\n+ *\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>\n+ *    Minpack Copyright Notice (1999) University of Chicago.\n+ *    All rights reserved\n+ * </td></tr>\n+ * <tr><td>\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * <ol>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ * <li>Redistributions in binary form must reproduce the above\n+ *     copyright notice, this list of conditions and the following\n+ *     disclaimer in the documentation and/or other materials provided\n+ *     with the distribution.</li>\n+ * <li>The end-user documentation included with the redistribution, if any,\n+ *     must include the following acknowledgment:\n+ *     <code>This product includes software developed by the University of\n+ *           Chicago, as Operator of Argonne National Laboratory.</code>\n+ *     Alternately, this acknowledgment may appear in the software itself,\n+ *     if and wherever such third-party acknowledgments normally appear.</li>\n+ * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n+ *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n+ *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n+ *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n+ *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n+ *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n+ *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n+ *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n+ *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n+ *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n+ *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n+ *     BE CORRECTED.</strong></li>\n+ * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n+ *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n+ *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n+ *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n+ *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n+ *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n+ *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n+ *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n+ *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n+ *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n+ * <ol></td></tr>\n+ * </table>\n+\n+ * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran)\n+ * @author Burton S. Garbow (original fortran)\n+ * @author Kenneth E. Hillstrom (original fortran)\n+ * @author Jorge J. More (original fortran)\n+\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ * @deprecated as of 2.0, everything in package org.apache.commons.math.estimation has\n+ * been deprecated and replaced by package org.apache.commons.math.optimization.general\n+ *\n+ */\n+@Deprecated\n+public class LevenbergMarquardtEstimator extends AbstractEstimator implements Serializable {\n+\n+  /** \n+   * Build an estimator for least squares problems.\n+   * <p>The default values for the algorithm settings are:\n+   *   <ul>\n+   *    <li>{@link #setInitialStepBoundFactor initial step bound factor}: 100.0</li>\n+   *    <li>{@link #setMaxCostEval maximal cost evaluations}: 1000</li>\n+   *    <li>{@link #setCostRelativeTolerance cost relative tolerance}: 1.0e-10</li>\n+   *    <li>{@link #setParRelativeTolerance parameters relative tolerance}: 1.0e-10</li>\n+   *    <li>{@link #setOrthoTolerance orthogonality tolerance}: 1.0e-10</li>\n+   *   </ul>\n+   * </p>\n+   */\n+  public LevenbergMarquardtEstimator() {\n+\n+    // set up the superclass with a default  max cost evaluations setting\n+    setMaxCostEval(1000);\n+\n+    // default values for the tuning parameters\n+    setInitialStepBoundFactor(100.0);\n+    setCostRelativeTolerance(1.0e-10);\n+    setParRelativeTolerance(1.0e-10);\n+    setOrthoTolerance(1.0e-10);\n+\n+  }\n+\n+  /** \n+   * Set the positive input variable used in determining the initial step bound.\n+   * This bound is set to the product of initialStepBoundFactor and the euclidean norm of diag*x if nonzero,\n+   * or else to initialStepBoundFactor itself. In most cases factor should lie\n+   * in the interval (0.1, 100.0). 100.0 is a generally recommended value\n+   * \n+   * @param initialStepBoundFactor initial step bound factor\n+   * @see #estimate\n+   */\n+  public void setInitialStepBoundFactor(double initialStepBoundFactor) {\n+    this.initialStepBoundFactor = initialStepBoundFactor;\n+  }\n+\n+  /** \n+   * Set the desired relative error in the sum of squares.\n+   * \n+   * @param costRelativeTolerance desired relative error in the sum of squares\n+   * @see #estimate\n+   */\n+  public void setCostRelativeTolerance(double costRelativeTolerance) {\n+    this.costRelativeTolerance = costRelativeTolerance;\n+  }\n+\n+  /** \n+   * Set the desired relative error in the approximate solution parameters.\n+   * \n+   * @param parRelativeTolerance desired relative error\n+   * in the approximate solution parameters\n+   * @see #estimate\n+   */\n+  public void setParRelativeTolerance(double parRelativeTolerance) {\n+    this.parRelativeTolerance = parRelativeTolerance;\n+  }\n+\n+  /** \n+   * Set the desired max cosine on the orthogonality.\n+   * \n+   * @param orthoTolerance desired max cosine on the orthogonality\n+   * between the function vector and the columns of the jacobian\n+   * @see #estimate\n+   */\n+  public void setOrthoTolerance(double orthoTolerance) {\n+    this.orthoTolerance = orthoTolerance;\n+  }\n+\n+  /** \n+   * Solve an estimation problem using the Levenberg-Marquardt algorithm.\n+   * <p>The algorithm used is a modified Levenberg-Marquardt one, based\n+   * on the MINPACK <a href=\"http://www.netlib.org/minpack/lmder.f\">lmder</a>\n+   * routine. The algorithm settings must have been set up before this method\n+   * is called with the {@link #setInitialStepBoundFactor},\n+   * {@link #setMaxCostEval}, {@link #setCostRelativeTolerance},\n+   * {@link #setParRelativeTolerance} and {@link #setOrthoTolerance} methods.\n+   * If these methods have not been called, the default values set up by the\n+   * {@link #LevenbergMarquardtEstimator() constructor} will be used.</p>\n+   * <p>The authors of the original fortran function are:</p>\n+   * <ul>\n+   *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n+   *   <li>Burton  S. Garbow</li>\n+   *   <li>Kenneth E. Hillstrom</li>\n+   *   <li>Jorge   J. More</li>\n+   *   </ul>\n+   * <p>Luc Maisonobe did the Java translation.</p>\n+   * \n+   * @param problem estimation problem to solve\n+   * @exception EstimationException if convergence cannot be\n+   * reached with the specified algorithm settings or if there are more variables\n+   * than equations\n+   * @see #setInitialStepBoundFactor\n+   * @see #setCostRelativeTolerance\n+   * @see #setParRelativeTolerance\n+   * @see #setOrthoTolerance\n+   */\n+  @Override\n+  public void estimate(EstimationProblem problem)\n+    throws EstimationException {\n+\n+    initializeEstimate(problem);\n+\n+    // arrays shared with the other private methods\n+    solvedCols  = Math.min(rows, cols);\n+    diagR       = new double[cols];\n+    jacNorm     = new double[cols];\n+    beta        = new double[cols];\n+    permutation = new int[cols];\n+    lmDir       = new double[cols];\n+\n+    // local variables\n+    double   delta   = 0, xNorm = 0;\n+    double[] diag    = new double[cols];\n+    double[] oldX    = new double[cols];\n+    double[] oldRes  = new double[rows];\n+    double[] work1   = new double[cols];\n+    double[] work2   = new double[cols];\n+    double[] work3   = new double[cols];\n+\n+    // evaluate the function at the starting point and calculate its norm\n+    updateResidualsAndCost();\n+    \n+    // outer loop\n+    lmPar = 0;\n+    boolean firstIteration = true;\n+    while (true) {\n+\n+      // compute the Q.R. decomposition of the jacobian matrix\n+      updateJacobian();\n+      qrDecomposition();\n+\n+      // compute Qt.res\n+      qTy(residuals);\n+\n+      // now we don't need Q anymore,\n+      // so let jacobian contain the R matrix with its diagonal elements\n+      for (int k = 0; k < solvedCols; ++k) {\n+        int pk = permutation[k];\n+        jacobian[k * cols + pk] = diagR[pk];\n+      }\n+\n+      if (firstIteration) {\n+\n+        // scale the variables according to the norms of the columns\n+        // of the initial jacobian\n+        xNorm = 0;\n+        for (int k = 0; k < cols; ++k) {\n+          double dk = jacNorm[k];\n+          if (dk == 0) {\n+            dk = 1.0;\n+          }\n+          double xk = dk * parameters[k].getEstimate();\n+          xNorm  += xk * xk;\n+          diag[k] = dk;\n+        }\n+        xNorm = Math.sqrt(xNorm);\n+        \n+        // initialize the step bound delta\n+        delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n+ \n+      }\n+\n+      // check orthogonality between function vector and jacobian columns\n+      double maxCosine = 0;\n+      if (cost != 0) {\n+        for (int j = 0; j < solvedCols; ++j) {\n+          int    pj = permutation[j];\n+          double s  = jacNorm[pj];\n+          if (s != 0) {\n+            double sum = 0;\n+            for (int i = 0, index = pj; i <= j; ++i, index += cols) {\n+              sum += jacobian[index] * residuals[i];\n+            }\n+            maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n+          }\n+        }\n+      }\n+      if (maxCosine <= orthoTolerance) {\n+        return;\n+      }\n+\n+      // rescale if necessary\n+      for (int j = 0; j < cols; ++j) {\n+        diag[j] = Math.max(diag[j], jacNorm[j]);\n+      }\n+\n+      // inner loop\n+      for (double ratio = 0; ratio < 1.0e-4;) {\n+\n+        // save the state\n+        for (int j = 0; j < solvedCols; ++j) {\n+          int pj = permutation[j];\n+          oldX[pj] = parameters[pj].getEstimate();\n+        }\n+        double previousCost = cost;\n+        double[] tmpVec = residuals;\n+        residuals = oldRes;\n+        oldRes    = tmpVec;\n+        \n+        // determine the Levenberg-Marquardt parameter\n+        determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n+\n+        // compute the new point and the norm of the evolution direction\n+        double lmNorm = 0;\n+        for (int j = 0; j < solvedCols; ++j) {\n+          int pj = permutation[j];\n+          lmDir[pj] = -lmDir[pj];\n+          parameters[pj].setEstimate(oldX[pj] + lmDir[pj]);\n+          double s = diag[pj] * lmDir[pj];\n+          lmNorm  += s * s;\n+        }\n+        lmNorm = Math.sqrt(lmNorm);\n+\n+        // on the first iteration, adjust the initial step bound.\n+        if (firstIteration) {\n+          delta = Math.min(delta, lmNorm);\n+        }\n+\n+        // evaluate the function at x + p and calculate its norm\n+        updateResidualsAndCost();\n+\n+        // compute the scaled actual reduction\n+        double actRed = -1.0;\n+        if (0.1 * cost < previousCost) {\n+          double r = cost / previousCost;\n+          actRed = 1.0 - r * r;\n+        }\n+\n+        // compute the scaled predicted reduction\n+        // and the scaled directional derivative\n+        for (int j = 0; j < solvedCols; ++j) {\n+          int pj = permutation[j];\n+          double dirJ = lmDir[pj];\n+          work1[j] = 0;\n+          for (int i = 0, index = pj; i <= j; ++i, index += cols) {\n+            work1[i] += jacobian[index] * dirJ;\n+          }\n+        }\n+        double coeff1 = 0;\n+        for (int j = 0; j < solvedCols; ++j) {\n+         coeff1 += work1[j] * work1[j];\n+        }\n+        double pc2 = previousCost * previousCost;\n+        coeff1 = coeff1 / pc2;\n+        double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n+        double preRed = coeff1 + 2 * coeff2;\n+        double dirDer = -(coeff1 + coeff2);\n+\n+        // ratio of the actual to the predicted reduction\n+        ratio = (preRed == 0) ? 0 : (actRed / preRed);\n+\n+        // update the step bound\n+        if (ratio <= 0.25) {\n+          double tmp =\n+            (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n+          if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n+            tmp = 0.1;\n+          }\n+          delta = tmp * Math.min(delta, 10.0 * lmNorm);\n+          lmPar /= tmp;\n+        } else if ((lmPar == 0) || (ratio >= 0.75)) {\n+          delta = 2 * lmNorm;\n+          lmPar *= 0.5;\n+        }\n+\n+        // test for successful iteration.\n+        if (ratio >= 1.0e-4) {\n+          // successful iteration, update the norm\n+          firstIteration = false;\n+          xNorm = 0;\n+          for (int k = 0; k < cols; ++k) {\n+            double xK = diag[k] * parameters[k].getEstimate();\n+            xNorm    += xK * xK;\n+          }\n+          xNorm = Math.sqrt(xNorm);\n+        } else {\n+          // failed iteration, reset the previous values\n+          cost = previousCost;\n+          for (int j = 0; j < solvedCols; ++j) {\n+            int pj = permutation[j];\n+            parameters[pj].setEstimate(oldX[pj]);\n+          }\n+          tmpVec    = residuals;\n+          residuals = oldRes;\n+          oldRes    = tmpVec;\n+        }\n+   \n+        // tests for convergence.\n+        if (((Math.abs(actRed) <= costRelativeTolerance) &&\n+             (preRed <= costRelativeTolerance) &&\n+             (ratio <= 2.0)) ||\n+             (delta <= parRelativeTolerance * xNorm)) {\n+          return;\n+        }\n+\n+        // tests for termination and stringent tolerances\n+        // (2.2204e-16 is the machine epsilon for IEEE754)\n+        if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n+          throw new EstimationException(\"cost relative tolerance is too small ({0}),\" +\n+                                        \" no further reduction in the\" +\n+                                        \" sum of squares is possible\",\n+                                        costRelativeTolerance);\n+        } else if (delta <= 2.2204e-16 * xNorm) {\n+          throw new EstimationException(\"parameters relative tolerance is too small\" +\n+                                        \" ({0}), no further improvement in\" +\n+                                        \" the approximate solution is possible\",\n+                                        parRelativeTolerance);\n+        } else if (maxCosine <= 2.2204e-16)  {\n+          throw new EstimationException(\"orthogonality tolerance is too small ({0}),\" +\n+                                        \" solution is orthogonal to the jacobian\",\n+                                        orthoTolerance);\n+        }\n+\n+      }\n+\n+    }\n+\n+  }\n+\n+  /** \n+   * Determine the Levenberg-Marquardt parameter.\n+   * <p>This implementation is a translation in Java of the MINPACK\n+   * <a href=\"http://www.netlib.org/minpack/lmpar.f\">lmpar</a>\n+   * routine.</p>\n+   * <p>This method sets the lmPar and lmDir attributes.</p>\n+   * <p>The authors of the original fortran function are:</p>\n+   * <ul>\n+   *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n+   *   <li>Burton  S. Garbow</li>\n+   *   <li>Kenneth E. Hillstrom</li>\n+   *   <li>Jorge   J. More</li>\n+   * </ul>\n+   * <p>Luc Maisonobe did the Java translation.</p>\n+   * \n+   * @param qy array containing qTy\n+   * @param delta upper bound on the euclidean norm of diagR * lmDir\n+   * @param diag diagonal matrix\n+   * @param work1 work array\n+   * @param work2 work array\n+   * @param work3 work array\n+   */\n+  private void determineLMParameter(double[] qy, double delta, double[] diag,\n+                                    double[] work1, double[] work2, double[] work3) {\n+\n+    // compute and store in x the gauss-newton direction, if the\n+    // jacobian is rank-deficient, obtain a least squares solution\n+    for (int j = 0; j < rank; ++j) {\n+      lmDir[permutation[j]] = qy[j];\n+    }\n+    for (int j = rank; j < cols; ++j) {\n+      lmDir[permutation[j]] = 0;\n+    }\n+    for (int k = rank - 1; k >= 0; --k) {\n+      int pk = permutation[k];\n+      double ypk = lmDir[pk] / diagR[pk];\n+      for (int i = 0, index = pk; i < k; ++i, index += cols) {\n+        lmDir[permutation[i]] -= ypk * jacobian[index];\n+      }\n+      lmDir[pk] = ypk;\n+    }\n+\n+    // evaluate the function at the origin, and test\n+    // for acceptance of the Gauss-Newton direction\n+    double dxNorm = 0;\n+    for (int j = 0; j < solvedCols; ++j) {\n+      int pj = permutation[j];\n+      double s = diag[pj] * lmDir[pj];\n+      work1[pj] = s;\n+      dxNorm += s * s;\n+    }\n+    dxNorm = Math.sqrt(dxNorm);\n+    double fp = dxNorm - delta;\n+    if (fp <= 0.1 * delta) {\n+      lmPar = 0;\n+      return;\n+    }\n+\n+    // if the jacobian is not rank deficient, the Newton step provides\n+    // a lower bound, parl, for the zero of the function,\n+    // otherwise set this bound to zero\n+    double sum2, parl = 0;\n+    if (rank == solvedCols) {\n+      for (int j = 0; j < solvedCols; ++j) {\n+        int pj = permutation[j];\n+        work1[pj] *= diag[pj] / dxNorm; \n+      }\n+      sum2 = 0;\n+      for (int j = 0; j < solvedCols; ++j) {\n+        int pj = permutation[j];\n+        double sum = 0;\n+        for (int i = 0, index = pj; i < j; ++i, index += cols) {\n+          sum += jacobian[index] * work1[permutation[i]];\n+        }\n+        double s = (work1[pj] - sum) / diagR[pj];\n+        work1[pj] = s;\n+        sum2 += s * s;\n+      }\n+      parl = fp / (delta * sum2);\n+    }\n+\n+    // calculate an upper bound, paru, for the zero of the function\n+    sum2 = 0;\n+    for (int j = 0; j < solvedCols; ++j) {\n+      int pj = permutation[j];\n+      double sum = 0;\n+      for (int i = 0, index = pj; i <= j; ++i, index += cols) {\n+        sum += jacobian[index] * qy[i];\n+      }\n+      sum /= diag[pj];\n+      sum2 += sum * sum;\n+    }\n+    double gNorm = Math.sqrt(sum2);\n+    double paru = gNorm / delta;\n+    if (paru == 0) {\n+      // 2.2251e-308 is the smallest positive real for IEE754\n+      paru = 2.2251e-308 / Math.min(delta, 0.1);\n+    }\n+\n+    // if the input par lies outside of the interval (parl,paru),\n+    // set par to the closer endpoint\n+    lmPar = Math.min(paru, Math.max(lmPar, parl));\n+    if (lmPar == 0) {\n+      lmPar = gNorm / dxNorm;\n+    }\n+\n+    for (int countdown = 10; countdown >= 0; --countdown) {\n+\n+      // evaluate the function at the current value of lmPar\n+      if (lmPar == 0) {\n+        lmPar = Math.max(2.2251e-308, 0.001 * paru);\n+      }\n+      double sPar = Math.sqrt(lmPar);\n+      for (int j = 0; j < solvedCols; ++j) {\n+        int pj = permutation[j];\n+        work1[pj] = sPar * diag[pj];\n+      }\n+      determineLMDirection(qy, work1, work2, work3);\n+\n+      dxNorm = 0;\n+      for (int j = 0; j < solvedCols; ++j) {\n+        int pj = permutation[j];\n+        double s = diag[pj] * lmDir[pj];\n+        work3[pj] = s;\n+        dxNorm += s * s;\n+      }\n+      dxNorm = Math.sqrt(dxNorm);\n+      double previousFP = fp;\n+      fp = dxNorm - delta;\n+\n+      // if the function is small enough, accept the current value\n+      // of lmPar, also test for the exceptional cases where parl is zero\n+      if ((Math.abs(fp) <= 0.1 * delta) ||\n+          ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\n+        return;\n+      }\n+ \n+      // compute the Newton correction\n+      for (int j = 0; j < solvedCols; ++j) {\n+       int pj = permutation[j];\n+        work1[pj] = work3[pj] * diag[pj] / dxNorm; \n+      }\n+      for (int j = 0; j < solvedCols; ++j) {\n+        int pj = permutation[j];\n+        work1[pj] /= work2[j];\n+        double tmp = work1[pj];\n+        for (int i = j + 1; i < solvedCols; ++i) {\n+          work1[permutation[i]] -= jacobian[i * cols + pj] * tmp;\n+        }\n+      }\n+      sum2 = 0;\n+      for (int j = 0; j < solvedCols; ++j) {\n+        double s = work1[permutation[j]];\n+        sum2 += s * s;\n+      }\n+      double correction = fp / (delta * sum2);\n+\n+      // depending on the sign of the function, update parl or paru.\n+      if (fp > 0) {\n+        parl = Math.max(parl, lmPar);\n+      } else if (fp < 0) {\n+        paru = Math.min(paru, lmPar);\n+      }\n+\n+      // compute an improved estimate for lmPar\n+      lmPar = Math.max(parl, lmPar + correction);\n+\n+    }\n+  }\n+\n+  /** \n+   * Solve a*x = b and d*x = 0 in the least squares sense.\n+   * <p>This implementation is a translation in Java of the MINPACK\n+   * <a href=\"http://www.netlib.org/minpack/qrsolv.f\">qrsolv</a>\n+   * routine.</p>\n+   * <p>This method sets the lmDir and lmDiag attributes.</p>\n+   * <p>The authors of the original fortran function are:</p>\n+   * <ul>\n+   *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n+   *   <li>Burton  S. Garbow</li>\n+   *   <li>Kenneth E. Hillstrom</li>\n+   *   <li>Jorge   J. More</li>\n+   * </ul>\n+   * <p>Luc Maisonobe did the Java translation.</p>\n+   * \n+   * @param qy array containing qTy\n+   * @param diag diagonal matrix\n+   * @param lmDiag diagonal elements associated with lmDir\n+   * @param work work array\n+   */\n+  private void determineLMDirection(double[] qy, double[] diag,\n+                                    double[] lmDiag, double[] work) {\n+\n+    // copy R and Qty to preserve input and initialize s\n+    //  in particular, save the diagonal elements of R in lmDir\n+    for (int j = 0; j < solvedCols; ++j) {\n+      int pj = permutation[j];\n+      for (int i = j + 1; i < solvedCols; ++i) {\n+        jacobian[i * cols + pj] = jacobian[j * cols + permutation[i]];\n+      }\n+      lmDir[j] = diagR[pj];\n+      work[j]  = qy[j];\n+    }\n+\n+    // eliminate the diagonal matrix d using a Givens rotation\n+    for (int j = 0; j < solvedCols; ++j) {\n+\n+      // prepare the row of d to be eliminated, locating the\n+      // diagonal element using p from the Q.R. factorization\n+      int pj = permutation[j];\n+      double dpj = diag[pj];\n+      if (dpj != 0) {\n+        Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);\n+      }\n+      lmDiag[j] = dpj;\n+\n+      //  the transformations to eliminate the row of d\n+      // modify only a single element of Qty\n+      // beyond the first n, which is initially zero.\n+      double qtbpj = 0;\n+      for (int k = j; k < solvedCols; ++k) {\n+        int pk = permutation[k];\n+\n+        // determine a Givens rotation which eliminates the\n+        // appropriate element in the current row of d\n+        if (lmDiag[k] != 0) {\n+\n+          double sin, cos;\n+          double rkk = jacobian[k * cols + pk];\n+          if (Math.abs(rkk) < Math.abs(lmDiag[k])) {\n+            double cotan = rkk / lmDiag[k];\n+            sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);\n+            cos   = sin * cotan;\n+          } else {\n+            double tan = lmDiag[k] / rkk;\n+            cos = 1.0 / Math.sqrt(1.0 + tan * tan);\n+            sin = cos * tan;\n+          }\n+\n+          // compute the modified diagonal element of R and\n+          // the modified element of (Qty,0)\n+          jacobian[k * cols + pk] = cos * rkk + sin * lmDiag[k];\n+          double temp = cos * work[k] + sin * qtbpj;\n+          qtbpj = -sin * work[k] + cos * qtbpj;\n+          work[k] = temp;\n+\n+          // accumulate the tranformation in the row of s\n+          for (int i = k + 1; i < solvedCols; ++i) {\n+            double rik = jacobian[i * cols + pk];\n+            temp = cos * rik + sin * lmDiag[i];\n+            lmDiag[i] = -sin * rik + cos * lmDiag[i];\n+            jacobian[i * cols + pk] = temp;\n+          }\n+\n+        }\n+      }\n+\n+      // store the diagonal element of s and restore\n+      // the corresponding diagonal element of R\n+      int index = j * cols + permutation[j];\n+      lmDiag[j]       = jacobian[index];\n+      jacobian[index] = lmDir[j];\n+\n+    }\n+\n+    // solve the triangular system for z, if the system is\n+    // singular, then obtain a least squares solution\n+    int nSing = solvedCols;\n+    for (int j = 0; j < solvedCols; ++j) {\n+      if ((lmDiag[j] == 0) && (nSing == solvedCols)) {\n+        nSing = j;\n+      }\n+      if (nSing < solvedCols) {\n+        work[j] = 0;\n+      }\n+    }\n+    if (nSing > 0) {\n+      for (int j = nSing - 1; j >= 0; --j) {\n+        int pj = permutation[j];\n+        double sum = 0;\n+        for (int i = j + 1; i < nSing; ++i) {\n+          sum += jacobian[i * cols + pj] * work[i];\n+        }\n+        work[j] = (work[j] - sum) / lmDiag[j];\n+      }\n+    }\n+\n+    // permute the components of z back to components of lmDir\n+    for (int j = 0; j < lmDir.length; ++j) {\n+      lmDir[permutation[j]] = work[j];\n+    }\n+\n+  }\n+\n+  /** \n+   * Decompose a matrix A as A.P = Q.R using Householder transforms.\n+   * <p>As suggested in the P. Lascaux and R. Theodor book\n+   * <i>Analyse num&eacute;rique matricielle appliqu&eacute;e &agrave;\n+   * l'art de l'ing&eacute;nieur</i> (Masson, 1986), instead of representing\n+   * the Householder transforms with u<sub>k</sub> unit vectors such that:\n+   * <pre>\n+   * H<sub>k</sub> = I - 2u<sub>k</sub>.u<sub>k</sub><sup>t</sup>\n+   * </pre>\n+   * we use <sub>k</sub> non-unit vectors such that:\n+   * <pre>\n+   * H<sub>k</sub> = I - beta<sub>k</sub>v<sub>k</sub>.v<sub>k</sub><sup>t</sup>\n+   * </pre>\n+   * where v<sub>k</sub> = a<sub>k</sub> - alpha<sub>k</sub> e<sub>k</sub>.\n+   * The beta<sub>k</sub> coefficients are provided upon exit as recomputing\n+   * them from the v<sub>k</sub> vectors would be costly.</p>\n+   * <p>This decomposition handles rank deficient cases since the tranformations\n+   * are performed in non-increasing columns norms order thanks to columns\n+   * pivoting. The diagonal elements of the R matrix are therefore also in\n+   * non-increasing absolute values order.</p>\n+   * @exception EstimationException if the decomposition cannot be performed\n+   */\n+  private void qrDecomposition() throws EstimationException {\n+\n+    // initializations\n+    for (int k = 0; k < cols; ++k) {\n+      permutation[k] = k;\n+      double norm2 = 0;\n+      for (int index = k; index < jacobian.length; index += cols) {\n+        double akk = jacobian[index];\n+        norm2 += akk * akk;\n+      }\n+      jacNorm[k] = Math.sqrt(norm2);\n+    }\n+\n+    // transform the matrix column after column\n+    for (int k = 0; k < cols; ++k) {\n+\n+      // select the column with the greatest norm on active components\n+      int nextColumn = -1;\n+      double ak2 = Double.NEGATIVE_INFINITY;\n+      for (int i = k; i < cols; ++i) {\n+        double norm2 = 0;\n+        int iDiag = k * cols + permutation[i];\n+        for (int index = iDiag; index < jacobian.length; index += cols) {\n+          double aki = jacobian[index];\n+          norm2 += aki * aki;\n+        }\n+        if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n+            throw new EstimationException(\n+                    \"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\",\n+                    rows, cols);\n+        }\n+        if (norm2 > ak2) {\n+          nextColumn = i;\n+          ak2        = norm2;\n+        }\n+      }\n+      if (ak2 == 0) {\n+        rank = k;\n+        return;\n+      }\n+      int pk                  = permutation[nextColumn];\n+      permutation[nextColumn] = permutation[k];\n+      permutation[k]          = pk;\n+\n+      // choose alpha such that Hk.u = alpha ek\n+      int    kDiag = k * cols + pk;\n+      double akk   = jacobian[kDiag];\n+      double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n+      double betak = 1.0 / (ak2 - akk * alpha);\n+      beta[pk]     = betak;\n+\n+      // transform the current column\n+      diagR[pk]        = alpha;\n+      jacobian[kDiag] -= alpha;\n+\n+      // transform the remaining columns\n+      for (int dk = cols - 1 - k; dk > 0; --dk) {\n+        int dkp = permutation[k + dk] - pk;\n+        double gamma = 0;\n+        for (int index = kDiag; index < jacobian.length; index += cols) {\n+          gamma += jacobian[index] * jacobian[index + dkp];\n+        }\n+        gamma *= betak;\n+        for (int index = kDiag; index < jacobian.length; index += cols) {\n+          jacobian[index + dkp] -= gamma * jacobian[index];\n+        }\n+      }\n+\n+    }\n+\n+    rank = solvedCols;\n+\n+  }\n+\n+  /** \n+   * Compute the product Qt.y for some Q.R. decomposition.\n+   * \n+   * @param y vector to multiply (will be overwritten with the result)\n+   */\n+  private void qTy(double[] y) {\n+    for (int k = 0; k < cols; ++k) {\n+      int pk = permutation[k];\n+      int kDiag = k * cols + pk;\n+      double gamma = 0;\n+      for (int i = k, index = kDiag; i < rows; ++i, index += cols) {\n+        gamma += jacobian[index] * y[i];\n+      }\n+      gamma *= beta[pk];\n+      for (int i = k, index = kDiag; i < rows; ++i, index += cols) {\n+        y[i] -= gamma * jacobian[index];\n+      }\n+    }\n+  }\n+\n+  /** Number of solved variables. */\n+  private int solvedCols;\n+\n+  /** Diagonal elements of the R matrix in the Q.R. decomposition. */\n+  private double[] diagR;\n+\n+  /** Norms of the columns of the jacobian matrix. */\n+  private double[] jacNorm;\n+\n+  /** Coefficients of the Householder transforms vectors. */\n+  private double[] beta;\n+\n+  /** Columns permutation array. */\n+  private int[] permutation;\n+\n+  /** Rank of the jacobian matrix. */\n+  private int rank;\n+\n+  /** Levenberg-Marquardt parameter. */\n+  private double lmPar;\n+\n+  /** Parameters evolution direction associated with lmPar. */\n+  private double[] lmDir;\n+\n+  /** Positive input variable used in determining the initial step bound. */\n+  private double initialStepBoundFactor;\n+\n+  /** Desired relative error in the sum of squares. */\n+  private double costRelativeTolerance;\n+\n+  /**  Desired relative error in the approximate solution parameters. */\n+  private double parRelativeTolerance;\n+\n+  /** Desired max cosine on the orthogonality between the function vector\n+   * and the columns of the jacobian. */\n+  private double orthoTolerance;\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -5705952631533171019L;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/estimation/SimpleEstimationProblem.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.estimation;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Simple implementation of the {@link EstimationProblem\n+ * EstimationProblem} interface for boilerplate data handling.\n+ * <p>This class <em>only</em> handles parameters and measurements\n+ * storage and unbound parameters filtering. It does not compute\n+ * anything by itself. It should either be used with measurements\n+ * implementation that are smart enough to know about the\n+ * various parameters in order to compute the partial derivatives\n+ * appropriately. Since the problem-specific logic is mainly related to\n+ * the various measurements models, the simplest way to use this class\n+ * is by extending it and using one internal class extending\n+ * {@link WeightedMeasurement WeightedMeasurement} for each measurement\n+ * type. The instances of the internal classes would have access to the\n+ * various parameters and their current estimate.</p>\n+\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ * @deprecated as of 2.0, everything in package org.apache.commons.math.estimation has\n+ * been deprecated and replaced by package org.apache.commons.math.optimization.general\n+\n+ */\n+@Deprecated\n+public class SimpleEstimationProblem implements EstimationProblem {\n+\n+    /**\n+     * Build an empty instance without parameters nor measurements.\n+     */\n+    public SimpleEstimationProblem() {\n+        parameters   = new ArrayList<EstimatedParameter>();\n+        measurements = new ArrayList<WeightedMeasurement>();\n+    }\n+\n+    /** \n+     * Get all the parameters of the problem.\n+     * @return parameters\n+     */\n+    public EstimatedParameter[] getAllParameters() {\n+        return parameters.toArray(new EstimatedParameter[parameters.size()]);\n+    }\n+\n+    /** \n+     * Get the unbound parameters of the problem.\n+     * @return unbound parameters\n+     */\n+    public EstimatedParameter[] getUnboundParameters() {\n+\n+        // filter the unbound parameters\n+        List<EstimatedParameter> unbound = new ArrayList<EstimatedParameter>(parameters.size());\n+        for (EstimatedParameter p : parameters) {\n+            if (! p.isBound()) {\n+                unbound.add(p);\n+            }\n+        }\n+\n+        // convert to an array\n+        return unbound.toArray(new EstimatedParameter[unbound.size()]);\n+        \n+    }\n+\n+    /** \n+     * Get the measurements of an estimation problem.\n+     * @return measurements\n+     */\n+    public WeightedMeasurement[] getMeasurements() {\n+        return measurements.toArray(new WeightedMeasurement[measurements.size()]);\n+    }\n+\n+    /** Add a parameter to the problem.\n+     * @param p parameter to add\n+     */\n+    protected void addParameter(EstimatedParameter p) {\n+        parameters.add(p);\n+    }\n+\n+    /**\n+     * Add a new measurement to the set.\n+     * @param m measurement to add\n+     */\n+    protected void addMeasurement(WeightedMeasurement m) {\n+        measurements.add(m);\n+    }\n+\n+    /** Estimated parameters. */\n+    private final List<EstimatedParameter> parameters;\n+\n+    /** Measurements. */\n+    private final List<WeightedMeasurement> measurements;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/estimation/WeightedMeasurement.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.estimation;\n+\n+import java.io.Serializable;\n+\n+/** \n+ * This class represents measurements in estimation problems.\n+ *\n+ * <p>This abstract class implements all the methods needed to handle\n+ * measurements in a general way. It defines neither the {@link\n+ * #getTheoreticalValue getTheoreticalValue} nor the {@link\n+ * #getPartial getPartial} methods, which should be defined by\n+ * sub-classes according to the specific problem.</p>\n+ *\n+ * <p>The {@link #getTheoreticalValue getTheoreticalValue} and {@link\n+ * #getPartial getPartial} methods must always use the current\n+ * estimate of the parameters set by the solver in the problem. These\n+ * parameters can be retrieved through the {@link\n+ * EstimationProblem#getAllParameters\n+ * EstimationProblem.getAllParameters} method if the measurements are\n+ * independent of the problem, or directly if they are implemented as\n+ * inner classes of the problem.</p>\n+ *\n+ * <p>The instances for which the <code>ignored</code> flag is set\n+ * through the {@link #setIgnored setIgnored} method are ignored by the\n+ * solvers. This can be used to reject wrong measurements at some\n+ * steps of the estimation.</p>\n+ *\n+ * @see EstimationProblem\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ * @deprecated as of 2.0, everything in package org.apache.commons.math.estimation has\n+ * been deprecated and replaced by package org.apache.commons.math.optimization.general\n+ */\n+\n+@Deprecated\n+public abstract class WeightedMeasurement implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 4360046376796901941L;\n+\n+    /** \n+   * Simple constructor.\n+   * Build a measurement with the given parameters, and set its ignore\n+   * flag to false.\n+   * @param weight weight of the measurement in the least squares problem\n+   * (two common choices are either to use 1.0 for all measurements, or to\n+   * use a value proportional to the inverse of the variance of the measurement\n+   * type)\n+   * \n+   * @param measuredValue measured value\n+   */\n+  public WeightedMeasurement(double weight, double measuredValue) {\n+    this.weight        = weight;\n+    this.measuredValue = measuredValue;\n+    ignored            = false;\n+  }\n+\n+  /** Simple constructor.\n+   * \n+   * Build a measurement with the given parameters\n+   * \n+   * @param weight weight of the measurement in the least squares problem\n+   * @param measuredValue measured value\n+   * @param ignored true if the measurement should be ignored\n+   */\n+  public WeightedMeasurement(double weight, double measuredValue,\n+                             boolean ignored) {\n+    this.weight        = weight;\n+    this.measuredValue = measuredValue;\n+    this.ignored       = ignored;\n+  }\n+\n+  /** \n+   * Get the weight of the measurement in the least squares problem\n+   * \n+   * @return weight\n+   */\n+  public double getWeight() {\n+    return weight;\n+  }\n+\n+  /** \n+   * Get the measured value\n+   * \n+   * @return measured value\n+   */\n+  public double getMeasuredValue() {\n+    return measuredValue;\n+  }\n+\n+  /** \n+   * Get the residual for this measurement\n+   * The residual is the measured value minus the theoretical value.\n+   * \n+   * @return residual\n+   */\n+  public double getResidual() {\n+    return measuredValue - getTheoreticalValue();\n+  }\n+\n+  /** \n+   * Get the theoretical value expected for this measurement\n+   * <p>The theoretical value is the value expected for this measurement\n+   * if the model and its parameter were all perfectly known.</p>\n+   * <p>The value must be computed using the current estimate of the parameters\n+   * set by the solver in the problem.</p>\n+   * \n+   * @return theoretical value\n+   */\n+  public abstract double getTheoreticalValue();\n+\n+  /** \n+   * Get the partial derivative of the {@link #getTheoreticalValue\n+   * theoretical value} according to the parameter.\n+   * <p>The value must be computed using the current estimate of the parameters\n+   * set by the solver in the problem.</p>\n+   * \n+   * @param parameter parameter against which the partial derivative\n+   * should be computed\n+   * @return partial derivative of the {@link #getTheoreticalValue\n+   * theoretical value}\n+   */\n+  public abstract double getPartial(EstimatedParameter parameter);\n+\n+  /** \n+   * Set the ignore flag to the specified value\n+   * Setting the ignore flag to true allow to reject wrong\n+   * measurements, which sometimes can be detected only rather late.\n+   * \n+   * @param ignored value for the ignore flag\n+   */\n+  public void setIgnored(boolean ignored) {\n+    this.ignored = ignored;\n+  }\n+\n+  /** \n+   * Check if this measurement should be ignored\n+   * \n+   * @return true if the measurement should be ignored\n+   */\n+  public boolean isIgnored() {\n+    return ignored;\n+  }\n+\n+  /** Measurement weight. */\n+  private final double  weight;\n+\n+  /** Value of the measurements. */\n+  private final double  measuredValue;\n+\n+  /** Ignore measurement indicator. */\n+  private       boolean ignored;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/fraction/AbstractFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.fraction;\n+\n+import java.io.Serializable;\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Common part shared by both {@link FractionFormat} and {@link BigFractionFormat}.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class AbstractFormat extends NumberFormat implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -6981118387974191891L;\n+\n+    /** The format used for the denominator. */\n+    protected NumberFormat denominatorFormat;\n+\n+    /** The format used for the numerator. */\n+    protected NumberFormat numeratorFormat;\n+\n+    /**\n+     * Create an improper formatting instance with the default number format\n+     * for the numerator and denominator.  \n+     */\n+    protected AbstractFormat() {\n+        this(getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an improper formatting instance with a custom number format for\n+     * both the numerator and denominator.\n+     * @param format the custom format for both the numerator and denominator.\n+     */\n+    protected AbstractFormat(final NumberFormat format) {\n+        this(format, (NumberFormat) format.clone());\n+    }\n+\n+    /**\n+     * Create an improper formatting instance with a custom number format for\n+     * the numerator and a custom number format for the denominator.\n+     * @param numeratorFormat the custom format for the numerator.\n+     * @param denominatorFormat the custom format for the denominator.\n+     */\n+    protected AbstractFormat(final NumberFormat numeratorFormat,\n+                             final NumberFormat denominatorFormat) {\n+        this.numeratorFormat   = numeratorFormat;\n+        this.denominatorFormat = denominatorFormat;\n+    }\n+\n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getNumberInstance(java.util.Locale)} with the only\n+     * customizing is the maximum number of BigFraction digits, which is set to 0.  \n+     * @return the default number format.\n+     */\n+    protected static NumberFormat getDefaultNumberFormat() {\n+        return getDefaultNumberFormat(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getNumberInstance(java.util.Locale)} with the only\n+     * customizing is the maximum number of BigFraction digits, which is set to 0.  \n+     * @param locale the specific locale used by the format.\n+     * @return the default number format specific to the given locale.\n+     */\n+    protected static NumberFormat getDefaultNumberFormat(final Locale locale) {\n+        final NumberFormat nf = NumberFormat.getNumberInstance(locale);\n+        nf.setMaximumFractionDigits(0);\n+        nf.setParseIntegerOnly(true);\n+        return nf;\n+    }\n+\n+    /**\n+     * Access the denominator format.\n+     * @return the denominator format.\n+     */\n+    public NumberFormat getDenominatorFormat() {\n+        return denominatorFormat;\n+    }\n+\n+    /**\n+     * Access the numerator format.\n+     * @return the numerator format.\n+     */\n+    public NumberFormat getNumeratorFormat() {\n+        return numeratorFormat;\n+    }\n+\n+    /**\n+     * Modify the denominator format.\n+     * @param format the new denominator format value.\n+     * @throws IllegalArgumentException if <code>format</code> is\n+     *         <code>null</code>.\n+     */\n+    public void setDenominatorFormat(final NumberFormat format) {\n+        if (format == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"denominator format can not be null\");\n+        }\n+        this.denominatorFormat = format;\n+    }\n+\n+    /**\n+     * Modify the numerator format.\n+     * @param format the new numerator format value.\n+     * @throws IllegalArgumentException if <code>format</code> is\n+     *         <code>null</code>.\n+     */\n+    public void setNumeratorFormat(final NumberFormat format) {\n+        if (format == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"numerator format can not be null\");\n+        }\n+        this.numeratorFormat = format;\n+    }\n+\n+    /**\n+     * Parses <code>source</code> until a non-whitespace character is found.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.  On output, <code>pos</code>\n+     *        holds the index of the next non-whitespace character.\n+     */\n+    protected static void parseAndIgnoreWhitespace(final String source,\n+                                                   final ParsePosition pos) {\n+        parseNextCharacter(source, pos);\n+        pos.setIndex(pos.getIndex() - 1);\n+    }\n+\n+    /**\n+     * Parses <code>source</code> until a non-whitespace character is found.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the first non-whitespace character.\n+     */\n+    protected static char parseNextCharacter(final String source,\n+                                             final ParsePosition pos) {\n+         int index = pos.getIndex();\n+         final int n = source.length();\n+         char ret = 0;\n+\n+         if (index < n) {\n+             char c;\n+             do {\n+                 c = source.charAt(index++);\n+             } while (Character.isWhitespace(c) && index < n);\n+             pos.setIndex(index);\n+         \n+             if (index < n) {\n+                 ret = c;\n+             }\n+         }\n+         \n+         return ret;\n+    }\n+\n+    /**\n+     * Formats a double value as a fraction and appends the result to a StringBuffer. \n+     *\n+     * @param value the double value to format\n+     * @param buffer StringBuffer to append to\n+     * @param position On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return a reference to the appended buffer\n+     * @see #format(Object, StringBuffer, FieldPosition)\n+     */\n+    @Override\n+    public StringBuffer format(final double value,\n+                               final StringBuffer buffer, final FieldPosition position) {\n+        return format(Double.valueOf(value), buffer, position);\n+    }\n+\n+    \n+    /**\n+     * Formats a long value as a fraction and appends the result to a StringBuffer. \n+     *\n+     * @param value the long value to format\n+     * @param buffer StringBuffer to append to\n+     * @param position On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return a reference to the appended buffer\n+     * @see #format(Object, StringBuffer, FieldPosition)\n+     */\n+    @Override\n+    public StringBuffer format(final long value,\n+                               final StringBuffer buffer, final FieldPosition position) {\n+        return format(Long.valueOf(value), buffer, position);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFraction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.fraction;\n+\n+import java.io.Serializable;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Representation of a rational number without any overflow. This class is\n+ * immutable.\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class BigFraction\n+    extends Number\n+    implements FieldElement<BigFraction>, Comparable<BigFraction>, Serializable {\n+\n+    /** A fraction representing \"2 / 1\". */\n+    public static final BigFraction TWO = new BigFraction(2);\n+\n+    /** A fraction representing \"1\". */\n+    public static final BigFraction ONE = new BigFraction(1);\n+\n+    /** A fraction representing \"0\". */\n+    public static final BigFraction ZERO = new BigFraction(0);\n+\n+    /** A fraction representing \"-1 / 1\". */\n+    public static final BigFraction MINUS_ONE = new BigFraction(-1);\n+\n+    /** A fraction representing \"4/5\". */\n+    public static final BigFraction FOUR_FIFTHS = new BigFraction(4, 5);\n+\n+    /** A fraction representing \"1/5\". */\n+    public static final BigFraction ONE_FIFTH = new BigFraction(1, 5);\n+\n+    /** A fraction representing \"1/2\". */\n+    public static final BigFraction ONE_HALF = new BigFraction(1, 2);\n+\n+    /** A fraction representing \"1/4\". */\n+    public static final BigFraction ONE_QUARTER = new BigFraction(1, 4);\n+\n+    /** A fraction representing \"1/3\". */\n+    public static final BigFraction ONE_THIRD = new BigFraction(1, 3);\n+\n+    /** A fraction representing \"3/5\". */\n+    public static final BigFraction THREE_FIFTHS = new BigFraction(3, 5);\n+\n+    /** A fraction representing \"3/4\". */\n+    public static final BigFraction THREE_QUARTERS = new BigFraction(3, 4);\n+\n+    /** A fraction representing \"2/5\". */\n+    public static final BigFraction TWO_FIFTHS = new BigFraction(2, 5);\n+\n+    /** A fraction representing \"2/4\". */\n+    public static final BigFraction TWO_QUARTERS = new BigFraction(2, 4);\n+\n+    /** A fraction representing \"2/3\". */\n+    public static final BigFraction TWO_THIRDS = new BigFraction(2, 3);\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -5630213147331578515L;\n+\n+    /** <code>BigInteger</code> representation of 100. */\n+    private static final BigInteger ONE_HUNDRED_DOUBLE = BigInteger.valueOf(100);\n+\n+    /** The numerator. */\n+    private final BigInteger numerator;\n+\n+    /** The denominator. */\n+    private final BigInteger denominator;\n+\n+    /**\n+     * <p>\n+     * Creates a <code>BigFraction</code> instance with the 2 parts of a fraction\n+     * Y/Z.\n+     * </p>\n+     * \n+     * <p>\n+     * Any negative signs are resolved to be on the numerator.\n+     * </p>\n+     * \n+     * @param numerator\n+     *            the numerator, for example the three in 'three sevenths'.\n+     * @param denominator\n+     *            the denominator, for example the seven in 'three sevenths'.\n+     * @return a new fraction instance, with the numerator and denominator\n+     *         reduced.\n+     * @throws ArithmeticException\n+     *             if the denominator is <code>zero</code>.\n+     */\n+    public static BigFraction getReducedFraction(final int numerator,\n+                                                 final int denominator) {\n+        if (numerator == 0) {\n+            return ZERO; // normalize zero.\n+        }\n+\n+        return new BigFraction(numerator, denominator);\n+    }\n+\n+    /**\n+     * <p>\n+     * Create a {@link BigFraction} equivalent to the passed <tt>BigInteger</tt>, ie\n+     * \"num / 1\".\n+     * </p>\n+     * \n+     * @param num\n+     *            the numerator.\n+     */\n+    public BigFraction(final BigInteger num) {\n+        this(num, BigInteger.ONE);\n+    }\n+\n+    /**\n+     * <p>\n+     * Create a {@link BigFraction} given the numerator and denominator as\n+     * <code>BigInteger</code>. The {@link BigFraction} is reduced to lowest terms.\n+     * </p>\n+     * \n+     * @param num\n+     *            the numerator, must not be <code>null</code>.\n+     * @param den\n+     *            the denominator, must not be <code>null</code>.\n+     * @throws ArithmeticException\n+     *             if the denominator is <code>zero</code>.\n+     * @throws NullPointerException\n+     *             if the numerator or the denominator is <code>zero</code>.\n+     */\n+    public BigFraction(BigInteger num, BigInteger den) {\n+        if (num == null) {\n+            throw MathRuntimeException.createNullPointerException(\"numerator is null\");\n+        }\n+        if (den == null) {\n+            throw MathRuntimeException.createNullPointerException(\"denominator is null\");\n+        }\n+        if (BigInteger.ZERO.equals(den)) {\n+            throw MathRuntimeException.createArithmeticException(\"denominator must be different from 0\");\n+        }\n+        if (BigInteger.ZERO.equals(num)) {\n+            numerator   = BigInteger.ZERO;\n+            denominator = BigInteger.ONE;\n+        } else {\n+\n+            // reduce numerator and denominator by greatest common denominator\n+            final BigInteger gcd = num.gcd(den);\n+            if (BigInteger.ONE.compareTo(gcd) < 0) {\n+                num = num.divide(gcd);\n+                den = den.divide(gcd);\n+            }\n+\n+            // move sign to numerator\n+            if (BigInteger.ZERO.compareTo(den) > 0) {\n+                num = num.negate();\n+                den = den.negate();\n+            }\n+\n+            // store the values in the final fields\n+            numerator   = num;\n+            denominator = den;\n+\n+        }\n+    }\n+\n+    /**\n+     * Create a fraction given the double value.\n+     * <p>\n+     * This constructor behaves <em>differently</em> from\n+     * {@link #BigFraction(double, double, int)}. It converts the\n+     * double value exactly, considering its internal bits representation.\n+     * This does work for all values except NaN and infinities and does\n+     * not requires any loop or convergence threshold.\n+     * </p>\n+     * <p>\n+     * Since this conversion is exact and since double numbers are sometimes\n+     * approximated, the fraction created may seem strange in some cases. For example\n+     * calling <code>new BigFraction(1.0 / 3.0)</code> does <em>not</em> create\n+     * the fraction 1/3 but the fraction 6004799503160661 / 18014398509481984\n+     * because the double number passed to the constructor is not exactly 1/3\n+     * (this number cannot be stored exactly in IEEE754).\n+     * </p>\n+     * @see #BigFraction(double, double, int)\n+     * @param value the double value to convert to a fraction.\n+     * @exception IllegalArgumentException if value is NaN or infinite\n+     */\n+    public BigFraction(final double value) throws IllegalArgumentException {\n+        if (Double.isNaN(value)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"cannot convert NaN value\");\n+        }\n+        if (Double.isInfinite(value)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"cannot convert infinite value\");\n+        }\n+\n+        // compute m and k such that value = m * 2^k\n+        final long bits     = Double.doubleToLongBits(value);\n+        final long sign     = bits & 0x8000000000000000L;\n+        final long exponent = bits & 0x7ff0000000000000L;\n+        long m              = bits & 0x000fffffffffffffL;\n+        if (exponent != 0) {\n+            // this was a normalized number, add the implicit most significant bit\n+            m |= 0x0010000000000000L;\n+        }\n+        if (sign != 0) {\n+            m = -m;\n+        }\n+        int k = ((int) (exponent >> 52)) - 1075;\n+        while (((m & 0x001ffffffffffffeL) != 0) && ((m & 0x1) == 0)) {\n+            m = m >> 1;\n+            ++k;\n+        }\n+\n+        if (k < 0) {\n+            numerator   = BigInteger.valueOf(m);\n+            denominator = BigInteger.ZERO.flipBit(-k);\n+        } else {\n+            numerator   = BigInteger.valueOf(m).multiply(BigInteger.ZERO.flipBit(k));\n+            denominator = BigInteger.ONE;\n+        }\n+\n+    }\n+\n+    /**\n+     * Create a fraction given the double value and maximum error allowed.\n+     * <p>\n+     * References:\n+     * <ul>\n+     * <li><a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n+     * Continued Fraction</a> equations (11) and (22)-(26)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param value\n+     *            the double value to convert to a fraction.\n+     * @param epsilon\n+     *            maximum error allowed. The resulting fraction is within\n+     *            <code>epsilon</code> of <code>value</code>, in absolute terms.\n+     * @param maxIterations\n+     *            maximum number of convergents.\n+     * @throws FractionConversionException\n+     *             if the continued fraction failed to converge.\n+     * @see #BigFraction(double)\n+     */\n+    public BigFraction(final double value, final double epsilon,\n+                       final int maxIterations)\n+        throws FractionConversionException {\n+        this(value, epsilon, Integer.MAX_VALUE, maxIterations);\n+    }\n+\n+    /**\n+     * Create a fraction given the double value and either the maximum error\n+     * allowed or the maximum number of denominator digits.\n+     * <p>\n+     * \n+     * NOTE: This constructor is called with EITHER - a valid epsilon value and\n+     * the maxDenominator set to Integer.MAX_VALUE (that way the maxDenominator\n+     * has no effect). OR - a valid maxDenominator value and the epsilon value\n+     * set to zero (that way epsilon only has effect if there is an exact match\n+     * before the maxDenominator value is reached).\n+     * </p>\n+     * <p>\n+     * \n+     * It has been done this way so that the same code can be (re)used for both\n+     * scenarios. However this could be confusing to users if it were part of\n+     * the public API and this constructor should therefore remain PRIVATE.\n+     * </p>\n+     * \n+     * See JIRA issue ticket MATH-181 for more details:\n+     * \n+     * https://issues.apache.org/jira/browse/MATH-181\n+     * \n+     * @param value\n+     *            the double value to convert to a fraction.\n+     * @param epsilon\n+     *            maximum error allowed. The resulting fraction is within\n+     *            <code>epsilon</code> of <code>value</code>, in absolute terms.\n+     * @param maxDenominator\n+     *            maximum denominator value allowed.\n+     * @param maxIterations\n+     *            maximum number of convergents.\n+     * @throws FractionConversionException\n+     *             if the continued fraction failed to converge.\n+     */\n+    private BigFraction(final double value, final double epsilon,\n+                        final int maxDenominator, int maxIterations)\n+        throws FractionConversionException {\n+        long overflow = Integer.MAX_VALUE;\n+        double r0 = value;\n+        long a0 = (long) Math.floor(r0);\n+        if (a0 > overflow) {\n+            throw new FractionConversionException(value, a0, 1l);\n+        }\n+\n+        // check for (almost) integer arguments, which should not go\n+        // to iterations.\n+        if (Math.abs(a0 - value) < epsilon) {\n+            numerator = BigInteger.valueOf(a0);\n+            denominator = BigInteger.ONE;\n+            return;\n+        }\n+\n+        long p0 = 1;\n+        long q0 = 0;\n+        long p1 = a0;\n+        long q1 = 1;\n+\n+        long p2 = 0;\n+        long q2 = 1;\n+\n+        int n = 0;\n+        boolean stop = false;\n+        do {\n+            ++n;\n+            final double r1 = 1.0 / (r0 - a0);\n+            final long a1 = (long) Math.floor(r1);\n+            p2 = (a1 * p1) + p0;\n+            q2 = (a1 * q1) + q0;\n+            if ((p2 > overflow) || (q2 > overflow)) {\n+                throw new FractionConversionException(value, p2, q2);\n+            }\n+\n+            final double convergent = (double) p2 / (double) q2;\n+            if ((n < maxIterations) &&\n+                (Math.abs(convergent - value) > epsilon) &&\n+                (q2 < maxDenominator)) {\n+                p0 = p1;\n+                p1 = p2;\n+                q0 = q1;\n+                q1 = q2;\n+                a0 = a1;\n+                r0 = r1;\n+            } else {\n+                stop = true;\n+            }\n+        } while (!stop);\n+\n+        if (n >= maxIterations) {\n+            throw new FractionConversionException(value, maxIterations);\n+        }\n+\n+        if (q2 < maxDenominator) {\n+            numerator   = BigInteger.valueOf(p2);\n+            denominator = BigInteger.valueOf(q2);\n+        } else {\n+            numerator   = BigInteger.valueOf(p1);\n+            denominator = BigInteger.valueOf(q1);\n+        }\n+    }\n+\n+    /**\n+     * Create a fraction given the double value and maximum denominator.\n+     * <p>\n+     * References:\n+     * <ul>\n+     * <li><a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n+     * Continued Fraction</a> equations (11) and (22)-(26)</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param value\n+     *            the double value to convert to a fraction.\n+     * @param maxDenominator\n+     *            The maximum allowed value for denominator.\n+     * @throws FractionConversionException\n+     *             if the continued fraction failed to converge.\n+     */\n+    public BigFraction(final double value, final int maxDenominator)\n+        throws FractionConversionException {\n+        this(value, 0, maxDenominator, 100);\n+    }\n+\n+    /**\n+     * <p>\n+     * Create a {@link BigFraction} equivalent to the passed <tt>int</tt>, ie\n+     * \"num / 1\".\n+     * </p>\n+     * \n+     * @param num\n+     *            the numerator.\n+     */\n+    public BigFraction(final int num) {\n+        this(BigInteger.valueOf(num), BigInteger.ONE);\n+    }\n+\n+    /**\n+     * <p>\n+     * Create a {@link BigFraction} given the numerator and denominator as simple\n+     * <tt>int</tt>. The {@link BigFraction} is reduced to lowest terms.\n+     * </p>\n+     * \n+     * @param num\n+     *            the numerator.\n+     * @param den\n+     *            the denominator.\n+     */\n+    public BigFraction(final int num, final int den) {\n+        this(BigInteger.valueOf(num), BigInteger.valueOf(den));\n+    }\n+\n+    /**\n+     * <p>\n+     * Create a {@link BigFraction} equivalent to the passed long, ie \"num / 1\".\n+     * </p>\n+     * \n+     * @param num\n+     *            the numerator.\n+     */\n+    public BigFraction(final long num) {\n+        this(BigInteger.valueOf(num), BigInteger.ONE);\n+    }\n+\n+    /**\n+     * <p>\n+     * Create a {@link BigFraction} given the numerator and denominator as simple\n+     * <tt>long</tt>. The {@link BigFraction} is reduced to lowest terms.\n+     * </p>\n+     * \n+     * @param num\n+     *            the numerator.\n+     * @param den\n+     *            the denominator.\n+     */\n+    public BigFraction(final long num, final long den) {\n+        this(BigInteger.valueOf(num), BigInteger.valueOf(den));\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns the absolute value of this {@link BigFraction}.\n+     * </p>\n+     * \n+     * @return the absolute value as a {@link BigFraction}.\n+     */\n+    public BigFraction abs() {\n+        return (BigInteger.ZERO.compareTo(numerator) <= 0) ? this : negate();\n+    }\n+\n+    /**\n+     * <p>\n+     * Adds the value of this fraction to the passed {@link BigInteger},\n+     * returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param bg\n+     *            the {@link BigInteger} to add, must'nt be <code>null</code>.\n+     * @return a <code>BigFraction</code> instance with the resulting values.\n+     * @throws NullPointerException\n+     *             if the {@link BigInteger} is <code>null</code>.\n+     */\n+    public BigFraction add(final BigInteger bg) {\n+        return new BigFraction(numerator.add(denominator.multiply(bg)), denominator);\n+    }\n+\n+    /**\n+     * <p>\n+     * Adds the value of this fraction to the passed <tt>integer</tt>, returning\n+     * the result in reduced form.\n+     * </p>\n+     * \n+     * @param i\n+     *            the <tt>integer</tt> to add.\n+     * @return a <code>BigFraction</code> instance with the resulting values.\n+     */\n+    public BigFraction add(final int i) {\n+        return add(BigInteger.valueOf(i));\n+    }\n+\n+    /**\n+     * <p>\n+     * Adds the value of this fraction to the passed <tt>long</tt>, returning\n+     * the result in reduced form.\n+     * </p>\n+     * \n+     * @param l\n+     *            the <tt>long</tt> to add.\n+     * @return a <code>BigFraction</code> instance with the resulting values.\n+     */\n+    public BigFraction add(final long l) {\n+        return add(BigInteger.valueOf(l));\n+    }\n+\n+    /**\n+     * <p>\n+     * Adds the value of this fraction to another, returning the result in\n+     * reduced form.\n+     * </p>\n+     * \n+     * @param fraction\n+     *            the {@link BigFraction} to add, must not be <code>null</code>.\n+     * @return a {@link BigFraction} instance with the resulting values.\n+     * @throws NullPointerException\n+     *             if the {@link BigFraction} is <code>null</code>.\n+     */\n+    public BigFraction add(final BigFraction fraction) {\n+        if (ZERO.equals(fraction)) {\n+            return this;\n+        }\n+\n+        BigInteger num = null;\n+        BigInteger den = null;\n+\n+        if (denominator.equals(fraction.denominator)) {\n+            num = numerator.add(fraction.numerator);\n+            den = denominator;\n+        } else {\n+            num = (numerator.multiply(fraction.denominator)).add((fraction.numerator).multiply(denominator));\n+            den = denominator.multiply(fraction.denominator);\n+        }\n+        return new BigFraction(num, den);\n+\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the fraction as a <code>BigDecimal</code>. This calculates the\n+     * fraction as the numerator divided by denominator.\n+     * </p>\n+     * \n+     * @return the fraction as a <code>BigDecimal</code>.\n+     * @throws ArithmeticException\n+     *             if the exact quotient does not have a terminating decimal\n+     *             expansion.\n+     * @see BigDecimal\n+     */\n+    public BigDecimal bigDecimalValue() {\n+        return new BigDecimal(numerator).divide(new BigDecimal(denominator));\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the fraction as a <code>BigDecimal</code> following the passed\n+     * rounding mode. This calculates the fraction as the numerator divided by\n+     * denominator.\n+     * </p>\n+     * \n+     * @param roundingMode\n+     *            rounding mode to apply. see {@link BigDecimal} constants.\n+     * @return the fraction as a <code>BigDecimal</code>.\n+     * @throws IllegalArgumentException\n+     *             if <tt>roundingMode</tt> does not represent a valid rounding\n+     *             mode.\n+     * @see BigDecimal\n+     */\n+    public BigDecimal bigDecimalValue(final int roundingMode) {\n+        return new BigDecimal(numerator).divide(new BigDecimal(denominator), roundingMode);\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the fraction as a <code>BigDecimal</code> following the passed scale\n+     * and rounding mode. This calculates the fraction as the numerator divided\n+     * by denominator.\n+     * </p>\n+     * \n+     * @param scale\n+     *            scale of the <code>BigDecimal</code> quotient to be returned.\n+     *            see {@link BigDecimal} for more information.\n+     * @param roundingMode\n+     *            rounding mode to apply. see {@link BigDecimal} constants.\n+     * @return the fraction as a <code>BigDecimal</code>.\n+     * @see BigDecimal\n+     */\n+    public BigDecimal bigDecimalValue(final int scale, final int roundingMode) {\n+        return new BigDecimal(numerator).divide(new BigDecimal(denominator), scale, roundingMode);\n+    }\n+\n+    /**\n+     * <p>\n+     * Compares this object to another based on size.\n+     * </p>\n+     * \n+     * @param object\n+     *            the object to compare to, must not be <code>null</code>.\n+     * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n+     *         than <tt>object</tt>, 0 if they are equal.\n+     * @see java.lang.Comparable#compareTo(java.lang.Object)\n+     */\n+    public int compareTo(final BigFraction object) {\n+        BigInteger nOd = numerator.multiply(object.denominator);\n+        BigInteger dOn = denominator.multiply(object.numerator);\n+        return nOd.compareTo(dOn);\n+    }\n+\n+    /**\n+     * <p>\n+     * Divide the value of this fraction by the passed <code>BigInteger</code>,\n+     * ie \"this * 1 / bg\", returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param bg\n+     *            the <code>BigInteger</code> to divide by, must not be\n+     *            <code>null</code>.\n+     * @return a {@link BigFraction} instance with the resulting values.\n+     * @throws NullPointerException\n+     *             if the <code>BigInteger</code> is <code>null</code>.\n+     * @throws ArithmeticException\n+     *             if the fraction to divide by is zero.\n+     */\n+    public BigFraction divide(final BigInteger bg) {\n+        if (BigInteger.ZERO.equals(bg)) {\n+            throw MathRuntimeException.createArithmeticException(\"denominator must be different from 0\");\n+        }\n+        return new BigFraction(numerator, denominator.multiply(bg));\n+    }\n+\n+    /**\n+     * <p>\n+     * Divide the value of this fraction by the passed <tt>int</tt>, ie\n+     * \"this * 1 / i\", returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param i\n+     *            the <tt>int</tt> to divide by.\n+     * @return a {@link BigFraction} instance with the resulting values.\n+     * @throws ArithmeticException\n+     *             if the fraction to divide by is zero.\n+     */\n+    public BigFraction divide(final int i) {\n+        return divide(BigInteger.valueOf(i));\n+    }\n+\n+    /**\n+     * <p>\n+     * Divide the value of this fraction by the passed <tt>long</tt>, ie\n+     * \"this * 1 / l\", returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param l\n+     *            the <tt>long</tt> to divide by.\n+     * @return a {@link BigFraction} instance with the resulting values.\n+     * @throws ArithmeticException\n+     *             if the fraction to divide by is zero.\n+     */\n+    public BigFraction divide(final long l) {\n+        return divide(BigInteger.valueOf(l));\n+    }\n+\n+    /**\n+     * <p>\n+     * Divide the value of this fraction by another, returning the result in\n+     * reduced form.\n+     * </p>\n+     * \n+     * @param fraction\n+     *            the fraction to divide by, must not be <code>null</code>.\n+     * @return a {@link BigFraction} instance with the resulting values.\n+     * @throws NullPointerException\n+     *             if the fraction is <code>null</code>.\n+     * @throws ArithmeticException\n+     *             if the fraction to divide by is zero.\n+     */\n+    public BigFraction divide(final BigFraction fraction) {\n+        if (BigInteger.ZERO.equals(fraction.numerator)) {\n+            throw MathRuntimeException.createArithmeticException(\"denominator must be different from 0\");\n+        }\n+\n+        return multiply(fraction.reciprocal());\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n+     * the numerator divided by denominator.\n+     * </p>\n+     * \n+     * @return the fraction as a <tt>double</tt>\n+     * @see java.lang.Number#doubleValue()\n+     */\n+    @Override\n+    public double doubleValue() {\n+        return numerator.doubleValue() / denominator.doubleValue();\n+    }\n+\n+    /**\n+     * <p>\n+     * Test for the equality of two fractions. If the lowest term numerator and\n+     * denominators are the same for both fractions, the two fractions are\n+     * considered to be equal.\n+     * </p>\n+     * \n+     * @param other\n+     *            fraction to test for equality to this fraction, can be\n+     *            <code>null</code>.\n+     * @return true if two fractions are equal, false if object is\n+     *         <code>null</code>, not an instance of {@link BigFraction}, or not\n+     *         equal to this fraction instance.\n+     * @see java.lang.Object#equals(java.lang.Object)\n+     */\n+    @Override\n+    public boolean equals(final Object other) {\n+        boolean ret = false;\n+\n+        if (this == other) {\n+            ret = true;\n+        } else if (other instanceof BigFraction) {\n+            BigFraction rhs = ((BigFraction) other).reduce();\n+            BigFraction thisOne = this.reduce();\n+            ret = thisOne.numerator.equals(rhs.numerator) && thisOne.denominator.equals(rhs.denominator);\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the fraction as a <tt>float</tt>. This calculates the fraction as\n+     * the numerator divided by denominator.\n+     * </p>\n+     * \n+     * @return the fraction as a <tt>float</tt>.\n+     * @see java.lang.Number#floatValue()\n+     */\n+    @Override\n+    public float floatValue() {\n+        return numerator.floatValue() / denominator.floatValue();\n+    }\n+\n+    /**\n+     * <p>\n+     * Access the denominator as a <code>BigInteger</code>.\n+     * </p>\n+     * \n+     * @return the denominator as a <code>BigInteger</code>.\n+     */\n+    public BigInteger getDenominator() {\n+        return denominator;\n+    }\n+\n+    /**\n+     * <p>\n+     * Access the denominator as a <tt>int</tt>.\n+     * </p>\n+     * \n+     * @return the denominator as a <tt>int</tt>.\n+     */\n+    public int getDenominatorAsInt() {\n+        return denominator.intValue();\n+    }\n+\n+    /**\n+     * <p>\n+     * Access the denominator as a <tt>long</tt>.\n+     * </p>\n+     * \n+     * @return the denominator as a <tt>long</tt>.\n+     */\n+    public long getDenominatorAsLong() {\n+        return denominator.longValue();\n+    }\n+\n+    /**\n+     * <p>\n+     * Access the numerator as a <code>BigInteger</code>.\n+     * </p>\n+     * \n+     * @return the numerator as a <code>BigInteger</code>.\n+     */\n+    public BigInteger getNumerator() {\n+        return numerator;\n+    }\n+\n+    /**\n+     * <p>\n+     * Access the numerator as a <tt>int</tt>.\n+     * </p>\n+     * \n+     * @return the numerator as a <tt>int</tt>.\n+     */\n+    public int getNumeratorAsInt() {\n+        return numerator.intValue();\n+    }\n+\n+    /**\n+     * <p>\n+     * Access the numerator as a <tt>long</tt>.\n+     * </p>\n+     * \n+     * @return the numerator as a <tt>long</tt>.\n+     */\n+    public long getNumeratorAsLong() {\n+        return numerator.longValue();\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets a hashCode for the fraction.\n+     * </p>\n+     * \n+     * @return a hash code value for this object.\n+     * @see java.lang.Object#hashCode()\n+     */\n+    @Override\n+    public int hashCode() {\n+        return 37 * (37 * 17 + numerator.hashCode()) + denominator.hashCode();\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the fraction as an <tt>int</tt>. This returns the whole number part\n+     * of the fraction.\n+     * </p>\n+     * \n+     * @return the whole number fraction part.\n+     * @see java.lang.Number#intValue()\n+     */\n+    @Override\n+    public int intValue() {\n+        return numerator.divide(denominator).intValue();\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the fraction as a <tt>long</tt>. This returns the whole number part\n+     * of the fraction.\n+     * </p>\n+     * \n+     * @return the whole number fraction part.\n+     * @see java.lang.Number#longValue()\n+     */\n+    @Override\n+    public long longValue() {\n+        return numerator.divide(denominator).longValue();\n+    }\n+\n+    /**\n+     * <p>\n+     * Multiplies the value of this fraction by the passed\n+     * <code>BigInteger</code>, returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param bg\n+     *            the <code>BigInteger</code> to multiply by.\n+     * @return a <code>BigFraction</code> instance with the resulting values.\n+     * @throws NullPointerException\n+     *             if the bg is <code>null</code>.\n+     */\n+    public BigFraction multiply(final BigInteger bg) {\n+        return new BigFraction(bg.multiply(numerator), denominator);\n+    }\n+\n+    /**\n+     * <p>\n+     * Multiply the value of this fraction by the passed <tt>int</tt>, returning\n+     * the result in reduced form.\n+     * </p>\n+     * \n+     * @param i\n+     *            the <tt>int</tt> to multiply by.\n+     * @return a {@link BigFraction} instance with the resulting values.\n+     */\n+    public BigFraction multiply(final int i) {\n+        return multiply(BigInteger.valueOf(i));\n+    }\n+\n+    /**\n+     * <p>\n+     * Multiply the value of this fraction by the passed <tt>long</tt>,\n+     * returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param l\n+     *            the <tt>long</tt> to multiply by.\n+     * @return a {@link BigFraction} instance with the resulting values.\n+     */\n+    public BigFraction multiply(final long l) {\n+        return multiply(BigInteger.valueOf(l));\n+    }\n+\n+    /**\n+     * <p>\n+     * Multiplies the value of this fraction by another, returning the result in\n+     * reduced form.\n+     * </p>\n+     * \n+     * @param fraction\n+     *            the fraction to multiply by, must not be <code>null</code>.\n+     * @return a {@link BigFraction} instance with the resulting values.\n+     * @throws NullPointerException\n+     *             if the fraction is <code>null</code>.\n+     */\n+    public BigFraction multiply(final BigFraction fraction) {\n+        BigFraction ret = ZERO;\n+\n+        if (getNumeratorAsInt() != 0 && fraction.getNumeratorAsInt() != 0) {\n+            ret = new BigFraction(numerator.multiply(fraction.numerator), denominator.multiply(fraction.denominator));\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * <p>\n+     * Return the additive inverse of this fraction, returning the result in\n+     * reduced form.\n+     * </p>\n+     * \n+     * @return the negation of this fraction.\n+     */\n+    public BigFraction negate() {\n+        return new BigFraction(numerator.negate(), denominator);\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the fraction percentage as a <tt>double</tt>. This calculates the\n+     * fraction as the numerator divided by denominator multiplied by 100.\n+     * </p>\n+     * \n+     * @return the fraction percentage as a <tt>double</tt>.\n+     */\n+    public double percentageValue() {\n+        return (numerator.divide(denominator)).multiply(ONE_HUNDRED_DOUBLE).doubleValue();\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns a <tt>integer</tt> whose value is\n+     * <tt>(this<sup>exponent</sup>)</tt>, returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param exponent\n+     *            exponent to which this <code>BigInteger</code> is to be\n+     *            raised.\n+     * @return <tt>this<sup>exponent</sup></tt>.\n+     */\n+    public BigFraction pow(final int exponent) {\n+        if (exponent < 0) {\n+            return new BigFraction(denominator.pow(-exponent), numerator.pow(-exponent));\n+        }\n+        return new BigFraction(numerator.pow(exponent), denominator.pow(exponent));\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns a <code>BigFraction</code> whose value is\n+     * <tt>(this<sup>exponent</sup>)</tt>, returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param exponent\n+     *            exponent to which this <code>BigFraction</code> is to be raised.\n+     * @return <tt>this<sup>exponent</sup></tt> as a <code>BigFraction</code>.\n+     */\n+    public BigFraction pow(final long exponent) {\n+        if (exponent < 0) {\n+            return new BigFraction(MathUtils.pow(denominator, -exponent),\n+                                   MathUtils.pow(numerator,   -exponent));\n+        }\n+        return new BigFraction(MathUtils.pow(numerator,   exponent),\n+                               MathUtils.pow(denominator, exponent));\n+    }\n+ \n+    /**\n+     * <p>\n+     * Returns a <code>BigFraction</code> whose value is\n+     * <tt>(this<sup>exponent</sup>)</tt>, returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param exponent\n+     *            exponent to which this <code>BigFraction</code> is to be raised.\n+     * @return <tt>this<sup>exponent</sup></tt> as a <code>BigFraction</code>.\n+     */\n+    public BigFraction pow(final BigInteger exponent) {\n+        if (exponent.compareTo(BigInteger.ZERO) < 0) {\n+            final BigInteger eNeg = exponent.negate();\n+            return new BigFraction(MathUtils.pow(denominator, eNeg),\n+                                   MathUtils.pow(numerator,   eNeg));\n+        }\n+        return new BigFraction(MathUtils.pow(numerator,   exponent),\n+                               MathUtils.pow(denominator, exponent));\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns a <code>double</code> whose value is\n+     * <tt>(this<sup>exponent</sup>)</tt>, returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param exponent\n+     *            exponent to which this <code>BigFraction</code> is to be raised.\n+     * @return <tt>this<sup>exponent</sup></tt>.\n+     */\n+    public double pow(final double exponent) {\n+        return Math.pow(numerator.doubleValue(),   exponent) /\n+               Math.pow(denominator.doubleValue(), exponent);\n+    }\n+\n+    /**\n+     * <p>\n+     * Return the multiplicative inverse of this fraction.\n+     * </p>\n+     * \n+     * @return the reciprocal fraction.\n+     */\n+    public BigFraction reciprocal() {\n+        return new BigFraction(denominator, numerator);\n+    }\n+\n+    /**\n+     * <p>\n+     * Reduce this <code>BigFraction</code> to its lowest terms.\n+     * </p>\n+     * \n+     * @return the reduced <code>BigFraction</code>. It doesn't change anything if\n+     *         the fraction can be reduced.\n+     */\n+    public BigFraction reduce() {\n+        final BigInteger gcd = numerator.gcd(denominator);\n+        return new BigFraction(numerator.divide(gcd), denominator.divide(gcd));\n+    }\n+\n+    /**\n+     * <p>\n+     * Subtracts the value of an {@link BigInteger} from the value of this one,\n+     * returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param bg\n+     *            the {@link BigInteger} to subtract, must'nt be\n+     *            <code>null</code>.\n+     * @return a <code>BigFraction</code> instance with the resulting values.\n+     * @throws NullPointerException\n+     *             if the {@link BigInteger} is <code>null</code>.\n+     */\n+    public BigFraction subtract(final BigInteger bg) {\n+        return new BigFraction(numerator.subtract(denominator.multiply(bg)), denominator);\n+    }\n+\n+    /**\n+     * <p>\n+     * Subtracts the value of an <tt>integer</tt> from the value of this one,\n+     * returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param i\n+     *            the <tt>integer</tt> to subtract.\n+     * @return a <code>BigFraction</code> instance with the resulting values.\n+     */\n+    public BigFraction subtract(final int i) {\n+        return subtract(BigInteger.valueOf(i));\n+    }\n+\n+    /**\n+     * <p>\n+     * Subtracts the value of an <tt>integer</tt> from the value of this one,\n+     * returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param l\n+     *            the <tt>long</tt> to subtract.\n+     * @return a <code>BigFraction</code> instance with the resulting values, or\n+     *         this object if the <tt>long</tt> is zero.\n+     */\n+    public BigFraction subtract(final long l) {\n+        return subtract(BigInteger.valueOf(l));\n+    }\n+\n+    /**\n+     * <p>\n+     * Subtracts the value of another fraction from the value of this one,\n+     * returning the result in reduced form.\n+     * </p>\n+     * \n+     * @param fraction\n+     *            the {@link BigFraction} to subtract, must not be\n+     *            <code>null</code>.\n+     * @return a {@link BigFraction} instance with the resulting values\n+     * @throws NullPointerException\n+     *             if the fraction is <code>null</code>.\n+     */\n+    public BigFraction subtract(final BigFraction fraction) {\n+        if (ZERO.equals(fraction)) {\n+            return this;\n+        }\n+\n+        BigInteger num = null;\n+        BigInteger den = null;\n+        if (denominator.equals(fraction.denominator)) {\n+            num = numerator.subtract(fraction.numerator);\n+            den = denominator;\n+        } else {\n+            num = (numerator.multiply(fraction.denominator)).subtract((fraction.numerator).multiply(denominator));\n+            den = denominator.multiply(fraction.denominator);\n+        }\n+        return new BigFraction(num, den);\n+\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns the <code>String</code> representing this fraction, ie\n+     * \"num / dem\" or just \"num\" if the denominator is one.\n+     * </p>\n+     * \n+     * @return a string representation of the fraction.\n+     * @see java.lang.Object#toString()\n+     */\n+    @Override\n+    public String toString() {\n+        String str = null;\n+        if (BigInteger.ONE.equals(denominator)) {\n+            str = numerator.toString();\n+        } else if (BigInteger.ZERO.equals(numerator)) {\n+            str = \"0\";\n+        } else {\n+            str = numerator + \" / \" + denominator;\n+        }\n+        return str;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public BigFractionField getField() {\n+        return BigFractionField.getInstance();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFractionField.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.fraction;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.Field;\n+\n+/**\n+ * Representation of the fractional numbers  without any overflow field.\n+ * <p>\n+ * This class is a singleton.\n+ * </p>\n+ * @see Fraction\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class BigFractionField implements Field<BigFraction>, Serializable  {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -1699294557189741703L;\n+\n+    /** Private constructor for the singleton.\n+     */\n+    private BigFractionField() {\n+    }\n+\n+    /** Get the unique instance.\n+     * @return the unique instance\n+     */\n+    public static BigFractionField getInstance() {\n+        return LazyHolder.INSTANCE;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public BigFraction getOne() {\n+        return BigFraction.ONE;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public BigFraction getZero() {\n+        return BigFraction.ZERO;\n+    }\n+\n+    /** Holder for the instance.\n+     * <p>We use here the Initialization On Demand Holder Idiom.</p>\n+     */\n+    private static class LazyHolder {\n+        /** Cached field instance. */\n+        private static final BigFractionField INSTANCE = new BigFractionField();\n+    }\n+\n+    /** Handle deserialization of the singleton.\n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        // return the singleton instance\n+        return LazyHolder.INSTANCE; \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/fraction/BigFractionFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.fraction;\n+\n+import java.io.Serializable;\n+import java.math.BigInteger;\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Formats a BigFraction number in proper format or improper format.\n+ * <p>\n+ * The number format for each of the whole number, numerator and,\n+ * denominator can be configured.\n+ * </p>\n+ *\n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+public class BigFractionFormat extends AbstractFormat implements Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -2932167925527338976L;\n+\n+    /**\n+     * Create an improper formatting instance with the default number format\n+     * for the numerator and denominator.  \n+     */\n+    public BigFractionFormat() {\n+    }\n+\n+    /**\n+     * Create an improper formatting instance with a custom number format for\n+     * both the numerator and denominator.\n+     * @param format the custom format for both the numerator and denominator.\n+     */\n+    public BigFractionFormat(final NumberFormat format) {\n+        super(format);\n+    }\n+\n+    /**\n+     * Create an improper formatting instance with a custom number format for\n+     * the numerator and a custom number format for the denominator.\n+     * @param numeratorFormat the custom format for the numerator.\n+     * @param denominatorFormat the custom format for the denominator.\n+     */\n+    public BigFractionFormat(final NumberFormat numeratorFormat,\n+                             final NumberFormat denominatorFormat) {\n+        super(numeratorFormat, denominatorFormat);\n+    }\n+\n+    /**\n+     * Get the set of locales for which complex formats are available.  This\n+     * is the same set as the {@link NumberFormat} set. \n+     * @return available complex format locales.\n+     */\n+    public static Locale[] getAvailableLocales() {\n+        return NumberFormat.getAvailableLocales();\n+    }\n+\n+    /**\n+     * This static method calls formatBigFraction() on a default instance of\n+     * BigFractionFormat.\n+     *\n+     * @param f BigFraction object to format\n+     * @return A formatted BigFraction in proper form.\n+     */\n+    public static String formatBigFraction(final BigFraction f) {\n+        return getImproperInstance().format(f);\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the current locale.\n+     * @return the default complex format.\n+     */\n+    public static BigFractionFormat getImproperInstance() {\n+        return getImproperInstance(Locale.getDefault());\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the complex format specific to the given locale.\n+     */\n+    public static BigFractionFormat getImproperInstance(final Locale locale) {\n+        return new BigFractionFormat(getDefaultNumberFormat(locale));\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the current locale.\n+     * @return the default complex format.\n+     */\n+    public static BigFractionFormat getProperInstance() {\n+        return getProperInstance(Locale.getDefault());\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the complex format specific to the given locale.\n+     */\n+    public static BigFractionFormat getProperInstance(final Locale locale) {\n+        return new ProperBigFractionFormat(getDefaultNumberFormat(locale));\n+    }\n+    \n+    /**\n+     * Formats a {@link BigFraction} object to produce a string.  The BigFraction is\n+     * output in improper format.\n+     *\n+     * @param BigFraction the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(final BigFraction BigFraction,\n+                               final StringBuffer toAppendTo, final FieldPosition pos) {\n+        \n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        getNumeratorFormat().format(BigFraction.getNumerator(), toAppendTo, pos);\n+        toAppendTo.append(\" / \");\n+        getDenominatorFormat().format(BigFraction.getDenominator(), toAppendTo, pos);\n+        \n+        return toAppendTo;\n+    }\n+    \n+    /**\n+     * Formats an object and appends the result to a StringBuffer.\n+     * <code>obj</code> must be either a  {@link BigFraction} object or a\n+     * {@link BigInteger} object or a {@link Number} object. Any other type of\n+     * object will result in an {@link IllegalArgumentException} being thrown.\n+     *\n+     * @param obj the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n+     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n+     */\n+    @Override\n+    public StringBuffer format(final Object obj,\n+                               final StringBuffer toAppendTo, final FieldPosition pos) {\n+\n+        final StringBuffer ret;\n+        if (obj instanceof BigFraction) {\n+            ret = format((BigFraction) obj, toAppendTo, pos);\n+        } else if (obj instanceof BigInteger) {\n+            ret = format(new BigFraction((BigInteger) obj), toAppendTo, pos);\n+        } else if (obj instanceof Number) {\n+            ret = format(new BigFraction(((Number) obj).doubleValue()),\n+                         toAppendTo, pos);\n+        } else { \n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"cannot format given object as a fraction number\");\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link BigFraction} object.\n+     * @param source the string to parse\n+     * @return the parsed {@link BigFraction} object.\n+     * @exception ParseException if the beginning of the specified string\n+     *            cannot be parsed.\n+     */\n+    @Override\n+    public BigFraction parse(final String source) throws ParseException {\n+        final ParsePosition parsePosition = new ParsePosition(0);\n+        final BigFraction result = parse(source, parsePosition);\n+        if (parsePosition.getIndex() == 0) {\n+            throw MathRuntimeException.createParseException(\n+                    parsePosition.getErrorIndex(),\n+                    \"unparseable fraction number: \\\"{0}\\\"\", source);\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Parses a string to produce a {@link BigFraction} object.\n+     * This method expects the string to be formatted as an improper BigFraction.  \n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link BigFraction} object.\n+     */\n+    @Override\n+    public BigFraction parse(final String source, final ParsePosition pos) {\n+        final int initialIndex = pos.getIndex();\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse numerator\n+        final BigInteger num = parseNextBigInteger(source, pos);\n+        if (num == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse '/'\n+        final int startIndex = pos.getIndex();\n+        final char c = parseNextCharacter(source, pos);\n+        switch (c) {\n+        case 0 :\n+            // no '/'\n+            // return num as a BigFraction\n+            return new BigFraction(num);\n+        case '/' :\n+            // found '/', continue parsing denominator\n+            break;\n+        default :\n+            // invalid '/'\n+            // set index back to initial, error index should be the last\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            pos.setErrorIndex(startIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse denominator\n+        final BigInteger den = parseNextBigInteger(source, pos);\n+        if (den == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        return new BigFraction(num, den);\n+    }\n+\n+    /**\n+     * Parses a string to produce a <code>BigInteger</code>.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return a parsed <code>BigInteger</code> or null if string does not\n+     * contain a BigInteger at the specified position\n+     */\n+    protected BigInteger parseNextBigInteger(final String source,\n+                                             final ParsePosition pos) {\n+\n+        final int start = pos.getIndex();\n+         int end = (source.charAt(start) == '-') ? (start + 1) : start;\n+         while((end < source.length()) &&\n+               Character.isDigit(source.charAt(end))) {\n+             ++end;\n+         }\n+\n+         try {\n+             BigInteger n = new BigInteger(source.substring(start, end));\n+             pos.setIndex(end);\n+             return n;\n+         } catch (NumberFormatException nfe) {\n+             pos.setErrorIndex(start);\n+             return null;\n+         }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/fraction/Fraction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.fraction;\n+\n+import java.io.Serializable;\n+import java.math.BigInteger;\n+\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Representation of a rational number.\n+ *\n+ * implements Serializable since 2.0\n+ * \n+ * @since 1.1\n+ * @version $Revision$ $Date$\n+ */\n+public class Fraction\n+    extends Number\n+    implements FieldElement<Fraction>, Comparable<Fraction>, Serializable {\n+\n+    /** A fraction representing \"2 / 1\". */\n+    public static final Fraction TWO = new Fraction(2, 1);\n+\n+    /** A fraction representing \"1\". */\n+    public static final Fraction ONE = new Fraction(1, 1);\n+\n+    /** A fraction representing \"0\". */\n+    public static final Fraction ZERO = new Fraction(0, 1);\n+\n+    /** A fraction representing \"4/5\". */\n+    public static final Fraction FOUR_FIFTHS = new Fraction(4, 5);\n+\n+    /** A fraction representing \"1/5\". */\n+    public static final Fraction ONE_FIFTH = new Fraction(1, 5);\n+\n+    /** A fraction representing \"1/2\". */\n+    public static final Fraction ONE_HALF = new Fraction(1, 2);\n+\n+    /** A fraction representing \"1/4\". */\n+    public static final Fraction ONE_QUARTER = new Fraction(1, 4);\n+\n+    /** A fraction representing \"1/3\". */\n+    public static final Fraction ONE_THIRD = new Fraction(1, 3);\n+\n+    /** A fraction representing \"3/5\". */\n+    public static final Fraction THREE_FIFTHS = new Fraction(3, 5);\n+\n+    /** A fraction representing \"3/4\". */\n+    public static final Fraction THREE_QUARTERS = new Fraction(3, 4);\n+\n+    /** A fraction representing \"2/5\". */\n+    public static final Fraction TWO_FIFTHS = new Fraction(2, 5);\n+\n+    /** A fraction representing \"2/4\". */\n+    public static final Fraction TWO_QUARTERS = new Fraction(2, 4);\n+\n+    /** A fraction representing \"2/3\". */\n+    public static final Fraction TWO_THIRDS = new Fraction(2, 3);\n+\n+    /** A fraction representing \"-1 / 1\". */\n+    public static final Fraction MINUS_ONE = new Fraction(-1, 1);\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 3698073679419233275L;\n+\n+    /** The denominator. */\n+    private final int denominator;\n+    \n+    /** The numerator. */\n+    private final int numerator;\n+\n+    /**\n+     * Create a fraction given the double value.\n+     * @param value the double value to convert to a fraction.\n+     * @throws FractionConversionException if the continued fraction failed to\n+     *         converge.\n+     */\n+    public Fraction(double value) throws FractionConversionException {\n+        this(value, 1.0e-5, 100);\n+    }\n+\n+    /**\n+     * Create a fraction given the double value and maximum error allowed.\n+     * <p>\n+     * References:\n+     * <ul>\n+     * <li><a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n+     * Continued Fraction</a> equations (11) and (22)-(26)</li>\n+     * </ul>\n+     * </p>\n+     * @param value the double value to convert to a fraction.\n+     * @param epsilon maximum error allowed.  The resulting fraction is within\n+     *        <code>epsilon</code> of <code>value</code>, in absolute terms.\n+     * @param maxIterations maximum number of convergents\n+     * @throws FractionConversionException if the continued fraction failed to\n+     *         converge.\n+     */\n+    public Fraction(double value, double epsilon, int maxIterations)\n+        throws FractionConversionException\n+    {\n+        this(value, epsilon, Integer.MAX_VALUE, maxIterations);\n+    }\n+\n+    /**\n+     * Create a fraction given the double value and maximum denominator.\n+     * <p>\n+     * References:\n+     * <ul>\n+     * <li><a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n+     * Continued Fraction</a> equations (11) and (22)-(26)</li>\n+     * </ul>\n+     * </p>\n+     * @param value the double value to convert to a fraction.\n+     * @param maxDenominator The maximum allowed value for denominator\n+     * @throws FractionConversionException if the continued fraction failed to\n+     *         converge\n+     */\n+    public Fraction(double value, int maxDenominator)\n+        throws FractionConversionException\n+    {\n+       this(value, 0, maxDenominator, 100);\n+    }\n+\n+    /**\n+     * Create a fraction given the double value and either the maximum error\n+     * allowed or the maximum number of denominator digits.\n+     * <p>\n+     *\n+     * NOTE: This constructor is called with EITHER\n+     *   - a valid epsilon value and the maxDenominator set to Integer.MAX_VALUE\n+     *     (that way the maxDenominator has no effect).\n+     * OR\n+     *   - a valid maxDenominator value and the epsilon value set to zero\n+     *     (that way epsilon only has effect if there is an exact match before\n+     *     the maxDenominator value is reached).\n+     * </p><p>\n+     *\n+     * It has been done this way so that the same code can be (re)used for both\n+     * scenarios. However this could be confusing to users if it were part of\n+     * the public API and this constructor should therefore remain PRIVATE.\n+     * </p>\n+     *\n+     * See JIRA issue ticket MATH-181 for more details:\n+     *\n+     *     https://issues.apache.org/jira/browse/MATH-181\n+     *\n+     * @param value the double value to convert to a fraction.\n+     * @param epsilon maximum error allowed.  The resulting fraction is within\n+     *        <code>epsilon</code> of <code>value</code>, in absolute terms.\n+     * @param maxDenominator maximum denominator value allowed.\n+     * @param maxIterations maximum number of convergents\n+     * @throws FractionConversionException if the continued fraction failed to\n+     *         converge.\n+     */\n+    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n+        throws FractionConversionException\n+    {\n+        long overflow = Integer.MAX_VALUE;\n+        double r0 = value;\n+        long a0 = (long)Math.floor(r0);\n+        if (a0 > overflow) {\n+            throw new FractionConversionException(value, a0, 1l);\n+        }\n+\n+        // check for (almost) integer arguments, which should not go\n+        // to iterations.\n+        if (Math.abs(a0 - value) < epsilon) {\n+            this.numerator = (int) a0;\n+            this.denominator = 1;\n+            return;\n+        }\n+\n+        long p0 = 1;\n+        long q0 = 0;\n+        long p1 = a0;\n+        long q1 = 1;\n+\n+        long p2 = 0;\n+        long q2 = 1;\n+\n+        int n = 0;\n+        boolean stop = false;\n+        do {\n+            ++n;\n+            double r1 = 1.0 / (r0 - a0);\n+            long a1 = (long)Math.floor(r1);\n+            p2 = (a1 * p1) + p0;\n+            q2 = (a1 * q1) + q0;\n+            if ((p2 > overflow) || (q2 > overflow)) {\n+                throw new FractionConversionException(value, p2, q2);\n+            }\n+            \n+            double convergent = (double)p2 / (double)q2;\n+            if (n < maxIterations && Math.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n+                p0 = p1;\n+                p1 = p2;\n+                q0 = q1;\n+                q1 = q2;\n+                a0 = a1;\n+                r0 = r1;\n+            } else {\n+                stop = true;\n+            }\n+        } while (!stop);\n+\n+        if (n >= maxIterations) {\n+            throw new FractionConversionException(value, maxIterations);\n+        }\n+        \n+        if (q2 < maxDenominator) {\n+            this.numerator = (int) p2;\n+            this.denominator = (int) q2;\n+        } else {\n+            this.numerator = (int) p1;\n+            this.denominator = (int) q1;\n+        }\n+\n+    }\n+    \n+    /**\n+     * Create a fraction from an int. \n+     * The fraction is num / 1.\n+     * @param num the numerator.\n+     */\n+    public Fraction(int num) {\n+        this(num, 1);\n+    }\n+    \n+    /**\n+     * Create a fraction given the numerator and denominator.  The fraction is\n+     * reduced to lowest terms.\n+     * @param num the numerator.\n+     * @param den the denominator.\n+     * @throws ArithmeticException if the denominator is <code>zero</code>\n+     */\n+    public Fraction(int num, int den) {\n+        if (den == 0) {\n+            throw MathRuntimeException.createArithmeticException(\"zero denominator in fraction {0}/{1}\",\n+                                                                 num, den);\n+        }\n+        if (den < 0) {\n+            if (num == Integer.MIN_VALUE || den == Integer.MIN_VALUE) {\n+                throw MathRuntimeException.createArithmeticException(\"overflow in fraction {0}/{1}, cannot negate\",\n+                                                                     num, den);\n+            }\n+            num = -num;\n+            den = -den;\n+        }\n+        // reduce numerator and denominator by greatest common denominator.\n+        final int d = MathUtils.gcd(num, den);\n+        if (d > 1) {\n+            num /= d;\n+            den /= d;\n+        }\n+        \n+        // move sign to numerator.\n+        if (den < 0) {\n+            num = -num;\n+            den = -den;\n+        }\n+        this.numerator   = num;\n+        this.denominator = den;\n+    }\n+    \n+    /**\n+     * Returns the absolute value of this fraction.\n+     * @return the absolute value.\n+     */\n+    public Fraction abs() {\n+        Fraction ret;\n+        if (numerator >= 0) {\n+            ret = this;\n+        } else {\n+            ret = negate();\n+        }\n+        return ret;        \n+    }\n+    \n+    /**\n+     * Compares this object to another based on size.\n+     * @param object the object to compare to\n+     * @return -1 if this is less than <tt>object</tt>, +1 if this is greater\n+     *         than <tt>object</tt>, 0 if they are equal.\n+     */\n+    public int compareTo(Fraction object) {\n+        long nOd = ((long) numerator) * object.denominator;\n+        long dOn = ((long) denominator) * object.numerator;\n+        return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n+    }\n+\n+    /**\n+     * Gets the fraction as a <tt>double</tt>. This calculates the fraction as\n+     * the numerator divided by denominator.\n+     * @return the fraction as a <tt>double</tt>\n+     */\n+    @Override\n+    public double doubleValue() {\n+        return (double)numerator / (double)denominator;\n+    }\n+    \n+    /**\n+     * Test for the equality of two fractions.  If the lowest term\n+     * numerator and denominators are the same for both fractions, the two\n+     * fractions are considered to be equal.\n+     * @param other fraction to test for equality to this fraction\n+     * @return true if two fractions are equal, false if object is\n+     *         <tt>null</tt>, not an instance of {@link Fraction}, or not equal\n+     *         to this fraction instance.\n+     */\n+    @Override\n+    public boolean equals(Object other) {\n+        boolean ret;\n+        \n+        if (this == other) { \n+            ret = true;\n+        } else if (other == null) {\n+            ret = false;\n+        } else {\n+            try {\n+                // since fractions are always in lowest terms, numerators and\n+                // denominators can be compared directly for equality.\n+                Fraction rhs = (Fraction)other;\n+                ret = (numerator == rhs.numerator) &&\n+                    (denominator == rhs.denominator);\n+            } catch (ClassCastException ex) {\n+                // ignore exception\n+                ret = false;\n+            }\n+        }\n+        \n+        return ret;\n+    }\n+    \n+    /**\n+     * Gets the fraction as a <tt>float</tt>. This calculates the fraction as\n+     * the numerator divided by denominator.\n+     * @return the fraction as a <tt>float</tt>\n+     */\n+    @Override\n+    public float floatValue() {\n+        return (float)doubleValue();\n+    }\n+    \n+    /**\n+     * Access the denominator.\n+     * @return the denominator.\n+     */\n+    public int getDenominator() {\n+        return denominator;\n+    }\n+    \n+    /**\n+     * Access the numerator.\n+     * @return the numerator.\n+     */\n+    public int getNumerator() {\n+        return numerator;\n+    }\n+    \n+    /**\n+     * Gets a hashCode for the fraction.\n+     * @return a hash code value for this object\n+     */\n+    @Override\n+    public int hashCode() {\n+        return 37 * (37 * 17 + getNumerator()) + getDenominator();\n+    }\n+    \n+    /**\n+     * Gets the fraction as an <tt>int</tt>. This returns the whole number part\n+     * of the fraction.\n+     * @return the whole number fraction part\n+     */\n+    @Override\n+    public int intValue() {\n+        return (int)doubleValue();\n+    }\n+    \n+    /**\n+     * Gets the fraction as a <tt>long</tt>. This returns the whole number part\n+     * of the fraction.\n+     * @return the whole number fraction part\n+     */\n+    @Override\n+    public long longValue() {\n+        return (long)doubleValue();\n+    }\n+    \n+    /**\n+     * Return the additive inverse of this fraction.\n+     * @return the negation of this fraction.\n+     */\n+    public Fraction negate() {\n+        if (numerator==Integer.MIN_VALUE) {\n+            throw MathRuntimeException.createArithmeticException(\"overflow in fraction {0}/{1}, cannot negate\",\n+                                                                 numerator, denominator);\n+        }\n+        return new Fraction(-numerator, denominator);\n+    }\n+\n+    /**\n+     * Return the multiplicative inverse of this fraction.\n+     * @return the reciprocal fraction\n+     */\n+    public Fraction reciprocal() {\n+        return new Fraction(denominator, numerator);\n+    }\n+    \n+    /**\n+     * <p>Adds the value of this fraction to another, returning the result in reduced form.\n+     * The algorithm follows Knuth, 4.5.1.</p>\n+     *\n+     * @param fraction  the fraction to add, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction add(Fraction fraction) {\n+        return addSub(fraction, true /* add */);\n+    }\n+\n+    /**\n+     * Add an integer to the fraction.\n+     * @param i the <tt>integer</tt> to add.\n+     * @return this + i\n+     */\n+    public Fraction add(final int i) {\n+        return new Fraction(numerator + i * denominator, denominator);\n+    }\n+\n+    /**\n+     * <p>Subtracts the value of another fraction from the value of this one, \n+     * returning the result in reduced form.</p>\n+     *\n+     * @param fraction  the fraction to subtract, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator\n+     *   cannot be represented in an <code>int</code>.\n+     */\n+    public Fraction subtract(Fraction fraction) {\n+        return addSub(fraction, false /* subtract */);\n+    }\n+\n+    /**\n+     * Subtract an integer from the fraction.\n+     * @param i the <tt>integer</tt> to subtract.\n+     * @return this - i\n+     */\n+    public Fraction subtract(final int i) {\n+        return new Fraction(numerator - i * denominator, denominator);\n+    }\n+\n+    /** \n+     * Implement add and subtract using algorithm described in Knuth 4.5.1.\n+     * \n+     * @param fraction the fraction to subtract, must not be <code>null</code>\n+     * @param isAdd true to add, false to subtract\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator\n+     *   cannot be represented in an <code>int</code>.\n+     */\n+    private Fraction addSub(Fraction fraction, boolean isAdd) {\n+        if (fraction == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"null fraction\");\n+        }\n+        // zero is identity for addition.\n+        if (numerator == 0) {\n+            return isAdd ? fraction : fraction.negate();\n+        }\n+        if (fraction.numerator == 0) {\n+            return this;\n+        }     \n+        // if denominators are randomly distributed, d1 will be 1 about 61%\n+        // of the time.\n+        int d1 = MathUtils.gcd(denominator, fraction.denominator);\n+        if (d1==1) {\n+            // result is ( (u*v' +/- u'v) / u'v')\n+            int uvp = MathUtils.mulAndCheck(numerator, fraction.denominator);\n+            int upv = MathUtils.mulAndCheck(fraction.numerator, denominator);\n+            return new Fraction\n+                (isAdd ? MathUtils.addAndCheck(uvp, upv) : \n+                 MathUtils.subAndCheck(uvp, upv),\n+                 MathUtils.mulAndCheck(denominator, fraction.denominator));\n+        }\n+        // the quantity 't' requires 65 bits of precision; see knuth 4.5.1\n+        // exercise 7.  we're going to use a BigInteger.\n+        // t = u(v'/d1) +/- v(u'/d1)\n+        BigInteger uvp = BigInteger.valueOf(numerator)\n+        .multiply(BigInteger.valueOf(fraction.denominator/d1));\n+        BigInteger upv = BigInteger.valueOf(fraction.numerator)\n+        .multiply(BigInteger.valueOf(denominator/d1));\n+        BigInteger t = isAdd ? uvp.add(upv) : uvp.subtract(upv);\n+        // but d2 doesn't need extra precision because\n+        // d2 = gcd(t,d1) = gcd(t mod d1, d1)\n+        int tmodd1 = t.mod(BigInteger.valueOf(d1)).intValue();\n+        int d2 = (tmodd1==0)?d1:MathUtils.gcd(tmodd1, d1);\n+\n+        // result is (t/d2) / (u'/d1)(v'/d2)\n+        BigInteger w = t.divide(BigInteger.valueOf(d2));\n+        if (w.bitLength() > 31) {\n+            throw MathRuntimeException.createArithmeticException(\"overflow, numerator too large after multiply: {0}\",\n+                                                                 w);\n+        }\n+        return new Fraction (w.intValue(), \n+                MathUtils.mulAndCheck(denominator/d1, \n+                        fraction.denominator/d2));\n+    }\n+\n+    /**\n+     * <p>Multiplies the value of this fraction by another, returning the \n+     * result in reduced form.</p>\n+     *\n+     * @param fraction  the fraction to multiply by, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction multiply(Fraction fraction) {\n+        if (fraction == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"null fraction\");\n+        }\n+        if (numerator == 0 || fraction.numerator == 0) {\n+            return ZERO;\n+        }\n+        // knuth 4.5.1\n+        // make sure we don't overflow unless the result *must* overflow.\n+        int d1 = MathUtils.gcd(numerator, fraction.denominator);\n+        int d2 = MathUtils.gcd(fraction.numerator, denominator);\n+        return getReducedFraction\n+        (MathUtils.mulAndCheck(numerator/d1, fraction.numerator/d2),\n+                MathUtils.mulAndCheck(denominator/d2, fraction.denominator/d1));\n+    }\n+\n+    /**\n+     * Multiply the fraction by an integer.\n+     * @param i the <tt>integer</tt> to multiply by.\n+     * @return this * i\n+     */\n+    public Fraction multiply(final int i) {\n+        return new Fraction(numerator * i, denominator);\n+    }\n+\n+    /**\n+     * <p>Divide the value of this fraction by another.</p>\n+     *\n+     * @param fraction  the fraction to divide by, must not be <code>null</code>\n+     * @return a <code>Fraction</code> instance with the resulting values\n+     * @throws IllegalArgumentException if the fraction is <code>null</code>\n+     * @throws ArithmeticException if the fraction to divide by is zero\n+     * @throws ArithmeticException if the resulting numerator or denominator exceeds\n+     *  <code>Integer.MAX_VALUE</code>\n+     */\n+    public Fraction divide(Fraction fraction) {\n+        if (fraction == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"null fraction\");\n+        }\n+        if (fraction.numerator == 0) {\n+            throw MathRuntimeException.createArithmeticException(\n+                    \"the fraction to divide by must not be zero: {0}/{1}\",\n+                    fraction.numerator, fraction.denominator);\n+        }\n+        return multiply(fraction.reciprocal());\n+    }\n+\n+    /**\n+     * Divide the fraction by an integer.\n+     * @param i the <tt>integer</tt> to divide by.\n+     * @return this * i\n+     */\n+    public Fraction divide(final int i) {\n+        return new Fraction(numerator, denominator * i);\n+    }\n+\n+    /**\n+     * <p>Creates a <code>Fraction</code> instance with the 2 parts\n+     * of a fraction Y/Z.</p>\n+     *\n+     * <p>Any negative signs are resolved to be on the numerator.</p>\n+     *\n+     * @param numerator  the numerator, for example the three in 'three sevenths'\n+     * @param denominator  the denominator, for example the seven in 'three sevenths'\n+     * @return a new fraction instance, with the numerator and denominator reduced\n+     * @throws ArithmeticException if the denominator is <code>zero</code>\n+     */\n+    public static Fraction getReducedFraction(int numerator, int denominator) {\n+        if (denominator == 0) {\n+            throw MathRuntimeException.createArithmeticException(\n+                    \"zero denominator in fraction {0}/{1}\",\n+                    numerator, denominator);\n+        }\n+        if (numerator==0) {\n+            return ZERO; // normalize zero.\n+        }\n+        // allow 2^k/-2^31 as a valid fraction (where k>0)\n+        if (denominator==Integer.MIN_VALUE && (numerator&1)==0) {\n+            numerator/=2; denominator/=2;\n+        }\n+        if (denominator < 0) {\n+            if (numerator==Integer.MIN_VALUE ||\n+                    denominator==Integer.MIN_VALUE) {\n+                throw MathRuntimeException.createArithmeticException(\n+                        \"overflow in fraction {0}/{1}, cannot negate\",\n+                        numerator, denominator);\n+            }\n+            numerator = -numerator;\n+            denominator = -denominator;\n+        }\n+        // simplify fraction.\n+        int gcd = MathUtils.gcd(numerator, denominator);\n+        numerator /= gcd;\n+        denominator /= gcd;\n+        return new Fraction(numerator, denominator);\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns the <code>String</code> representing this fraction, ie\n+     * \"num / dem\" or just \"num\" if the denominator is one.\n+     * </p>\n+     * \n+     * @return a string representation of the fraction.\n+     * @see java.lang.Object#toString()\n+     */\n+    @Override\n+    public String toString() {\n+        String str = null;\n+        if (denominator == 1) {\n+            str = Integer.toString(numerator);\n+        } else if (numerator == 0) {\n+            str = \"0\";\n+        } else {\n+            str = numerator + \" / \" + denominator;\n+        }\n+        return str;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FractionField getField() {\n+        return FractionField.getInstance();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/fraction/FractionConversionException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.fraction;\n+\n+import org.apache.commons.math.ConvergenceException;\n+\n+/**\n+ * Error thrown when a double value cannot be converted to a fraction\n+ * in the allowed number of iterations.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class FractionConversionException extends ConvergenceException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -4661812640132576263L;\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param value double value to convert\n+     * @param maxIterations maximal number of iterations allowed\n+     */\n+    public FractionConversionException(double value, int maxIterations) {\n+        super(\"Unable to convert {0} to fraction after {1} iterations\", value, maxIterations);\n+    }\n+\n+    /**\n+     * Constructs an exception with specified formatted detail message.\n+     * Message formatting is delegated to {@link java.text.MessageFormat}.\n+     * @param value double value to convert\n+     * @param p current numerator \n+     * @param q current denominator\n+     */\n+    public FractionConversionException(double value, long p, long q) {\n+        super(\"Overflow trying to convert {0} to fraction ({1}/{2})\", value, p, q);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/fraction/FractionField.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.fraction;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.Field;\n+\n+/**\n+ * Representation of the fractional numbers field.\n+ * <p>\n+ * This class is a singleton.\n+ * </p>\n+ * @see Fraction\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class FractionField implements Field<Fraction>, Serializable  {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -1257768487499119313L;\n+\n+    /** Private constructor for the singleton.\n+     */\n+    private FractionField() {\n+    }\n+\n+    /** Get the unique instance.\n+     * @return the unique instance\n+     */\n+    public static FractionField getInstance() {\n+        return LazyHolder.INSTANCE;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Fraction getOne() {\n+        return Fraction.ONE;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Fraction getZero() {\n+        return Fraction.ZERO;\n+    }\n+\n+    /** Holder for the instance.\n+     * <p>We use here the Initialization On Demand Holder Idiom.</p>\n+     */\n+    private static class LazyHolder {\n+        /** Cached field instance. */\n+        private static final FractionField INSTANCE = new FractionField();\n+    }\n+\n+    /** Handle deserialization of the singleton.\n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        // return the singleton instance\n+        return LazyHolder.INSTANCE; \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/fraction/FractionFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.fraction;\n+\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Formats a Fraction number in proper format or improper format.  The number\n+ * format for each of the whole number, numerator and, denominator can be\n+ * configured.\n+ *\n+ * @since 1.1\n+ * @version $Revision$ $Date$\n+ */\n+public class FractionFormat extends AbstractFormat {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 3008655719530972611L;\n+\n+    /**\n+     * Create an improper formatting instance with the default number format\n+     * for the numerator and denominator.  \n+     */\n+    public FractionFormat() {\n+    }\n+\n+    /**\n+     * Create an improper formatting instance with a custom number format for\n+     * both the numerator and denominator.\n+     * @param format the custom format for both the numerator and denominator.\n+     */\n+    public FractionFormat(final NumberFormat format) {\n+        super(format);\n+    }\n+\n+    /**\n+     * Create an improper formatting instance with a custom number format for\n+     * the numerator and a custom number format for the denominator.\n+     * @param numeratorFormat the custom format for the numerator.\n+     * @param denominatorFormat the custom format for the denominator.\n+     */\n+    public FractionFormat(final NumberFormat numeratorFormat,\n+                          final NumberFormat denominatorFormat) {\n+        super(numeratorFormat, denominatorFormat);\n+    }\n+\n+    /**\n+     * Get the set of locales for which complex formats are available.  This\n+     * is the same set as the {@link NumberFormat} set. \n+     * @return available complex format locales.\n+     */\n+    public static Locale[] getAvailableLocales() {\n+        return NumberFormat.getAvailableLocales();\n+    }\n+\n+    /**\n+     * This static method calls formatFraction() on a default instance of\n+     * FractionFormat.\n+     *\n+     * @param f Fraction object to format\n+     * @return A formatted fraction in proper form.\n+     */\n+    public static String formatFraction(Fraction f) {\n+        return getImproperInstance().format(f);\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the current locale.\n+     * @return the default complex format.\n+     */\n+    public static FractionFormat getImproperInstance() {\n+        return getImproperInstance(Locale.getDefault());\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the complex format specific to the given locale.\n+     */\n+    public static FractionFormat getImproperInstance(final Locale locale) {\n+        return new FractionFormat(getDefaultNumberFormat(locale));\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the current locale.\n+     * @return the default complex format.\n+     */\n+    public static FractionFormat getProperInstance() {\n+        return getProperInstance(Locale.getDefault());\n+    }\n+    \n+    /**\n+     * Returns the default complex format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the complex format specific to the given locale.\n+     */\n+    public static FractionFormat getProperInstance(final Locale locale) {\n+        return new ProperFractionFormat(getDefaultNumberFormat(locale));\n+    }\n+    \n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getNumberInstance(java.util.Locale)} with the only\n+     * customizing is the maximum number of fraction digits, which is set to 0.  \n+     * @return the default number format.\n+     */\n+    protected static NumberFormat getDefaultNumberFormat() {\n+        return getDefaultNumberFormat(Locale.getDefault());\n+    }\n+    \n+    /**\n+     * Formats a {@link Fraction} object to produce a string.  The fraction is\n+     * output in improper format.\n+     *\n+     * @param fraction the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(final Fraction fraction,\n+                               final StringBuffer toAppendTo, final FieldPosition pos) {\n+        \n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        getNumeratorFormat().format(fraction.getNumerator(), toAppendTo, pos);\n+        toAppendTo.append(\" / \");\n+        getDenominatorFormat().format(fraction.getDenominator(), toAppendTo,\n+            pos);\n+        \n+        return toAppendTo;\n+    }\n+    \n+    /**\n+     * Formats an object and appends the result to a StringBuffer. <code>obj</code> must be either a \n+     * {@link Fraction} object or a {@link Number} object.  Any other type of\n+     * object will result in an {@link IllegalArgumentException} being thrown.\n+     *\n+     * @param obj the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n+     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n+     */\n+    @Override\n+    public StringBuffer format(final Object obj,\n+                               final StringBuffer toAppendTo, final FieldPosition pos) {\n+        StringBuffer ret = null;\n+        \n+        if (obj instanceof Fraction) {\n+            ret = format((Fraction) obj, toAppendTo, pos);\n+        } else if (obj instanceof Number) {\n+            try {\n+                ret = format(new Fraction(((Number) obj).doubleValue()),\n+                             toAppendTo, pos);\n+            } catch (ConvergenceException ex) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                    \"cannot convert given object to a fraction number: {0}\",\n+                    ex.getLocalizedMessage());\n+            }\n+        } else { \n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"cannot format given object as a fraction number\");\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link Fraction} object.\n+     * @param source the string to parse\n+     * @return the parsed {@link Fraction} object.\n+     * @exception ParseException if the beginning of the specified string\n+     *            cannot be parsed.\n+     */\n+    @Override\n+    public Fraction parse(final String source) throws ParseException {\n+        final ParsePosition parsePosition = new ParsePosition(0);\n+        final Fraction result = parse(source, parsePosition);\n+        if (parsePosition.getIndex() == 0) {\n+            throw MathRuntimeException.createParseException(\n+                    parsePosition.getErrorIndex(),\n+                    \"unparseable fraction number: \\\"{0}\\\"\", source);\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Parses a string to produce a {@link Fraction} object.  This method\n+     * expects the string to be formatted as an improper fraction.  \n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link Fraction} object.\n+     */\n+    @Override\n+    public Fraction parse(final String source, final ParsePosition pos) {\n+        final int initialIndex = pos.getIndex();\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse numerator\n+        final Number num = getNumeratorFormat().parse(source, pos);\n+        if (num == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse '/'\n+        final int startIndex = pos.getIndex();\n+        final char c = parseNextCharacter(source, pos);\n+        switch (c) {\n+        case 0 :\n+            // no '/'\n+            // return num as a fraction\n+            return new Fraction(num.intValue(), 1);\n+        case '/' :\n+            // found '/', continue parsing denominator\n+            break;\n+        default :\n+            // invalid '/'\n+            // set index back to initial, error index should be the last\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            pos.setErrorIndex(startIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse denominator\n+        final Number den = getDenominatorFormat().parse(source, pos);\n+        if (den == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        return new Fraction(num.intValue(), den.intValue());\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/fraction/ProperBigFractionFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.fraction;\n+\n+import java.math.BigInteger;\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Formats a BigFraction number in proper format.  The number format for each of\n+ * the whole number, numerator and, denominator can be configured.\n+ * <p>\n+ * Minus signs are only allowed in the whole number part - i.e.,\n+ * \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n+ * will result in a <code>ParseException</code>.</p>\n+ * \n+ * @since 1.1\n+ * @version $Revision$ $Date$\n+ */\n+public class ProperBigFractionFormat extends BigFractionFormat {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -6337346779577272307L;\n+    \n+    /** The format used for the whole number. */\n+    private NumberFormat wholeFormat;\n+\n+    /**\n+     * Create a proper formatting instance with the default number format for\n+     * the whole, numerator, and denominator.  \n+     */\n+    public ProperBigFractionFormat() {\n+        this(getDefaultNumberFormat());\n+    }\n+    \n+    /**\n+     * Create a proper formatting instance with a custom number format for the\n+     * whole, numerator, and denominator.\n+     * @param format the custom format for the whole, numerator, and\n+     *        denominator.\n+     */\n+    public ProperBigFractionFormat(final NumberFormat format) {\n+        this(format, (NumberFormat)format.clone(), (NumberFormat)format.clone());\n+    }\n+    \n+    /**\n+     * Create a proper formatting instance with a custom number format for each\n+     * of the whole, numerator, and denominator.\n+     * @param wholeFormat the custom format for the whole.\n+     * @param numeratorFormat the custom format for the numerator.\n+     * @param denominatorFormat the custom format for the denominator.\n+     */\n+    public ProperBigFractionFormat(final NumberFormat wholeFormat,\n+                                   final NumberFormat numeratorFormat,\n+                                   final NumberFormat denominatorFormat) {\n+        super(numeratorFormat, denominatorFormat);\n+        setWholeFormat(wholeFormat);\n+    }\n+    \n+    /**\n+     * Formats a {@link BigFraction} object to produce a string.  The BigFraction\n+     * is output in proper format.\n+     *\n+     * @param fraction the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    @Override\n+    public StringBuffer format(final BigFraction fraction,\n+                               final StringBuffer toAppendTo, final FieldPosition pos) {\n+        \n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        BigInteger num = fraction.getNumerator();\n+        BigInteger den = fraction.getDenominator();\n+        BigInteger whole = num.divide(den);\n+        num = num.remainder(den);\n+        \n+        if (!BigInteger.ZERO.equals(whole)) {\n+            getWholeFormat().format(whole, toAppendTo, pos);\n+            toAppendTo.append(' ');\n+            if (num.compareTo(BigInteger.ZERO) < 0) {\n+                num = num.negate();\n+            }\n+        }\n+        getNumeratorFormat().format(num, toAppendTo, pos);\n+        toAppendTo.append(\" / \");\n+        getDenominatorFormat().format(den, toAppendTo, pos);\n+        \n+        return toAppendTo;\n+    }\n+\n+    /**\n+     * Access the whole format.\n+     * @return the whole format.\n+     */\n+    public NumberFormat getWholeFormat() {\n+        return wholeFormat;\n+    }\n+    \n+    /**\n+     * Parses a string to produce a {@link BigFraction} object.  This method\n+     * expects the string to be formatted as a proper BigFraction.\n+     * <p>\n+     * Minus signs are only allowed in the whole number part - i.e.,\n+     * \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n+     * will result in a <code>ParseException</code>.</p>\n+     * \n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link BigFraction} object.\n+     */\n+    @Override\n+    public BigFraction parse(final String source, final ParsePosition pos) {\n+        // try to parse improper BigFraction\n+        BigFraction ret = super.parse(source, pos);\n+        if (ret != null) {\n+            return ret;\n+        }\n+        \n+        final int initialIndex = pos.getIndex();\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse whole\n+        BigInteger whole = parseNextBigInteger(source, pos);\n+        if (whole == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+        \n+        // parse numerator\n+        BigInteger num = parseNextBigInteger(source, pos);\n+        if (num == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+        \n+        if (num.compareTo(BigInteger.ZERO) < 0) {\n+            // minus signs should be leading, invalid expression\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse '/'\n+        final int startIndex = pos.getIndex();\n+        final char c = parseNextCharacter(source, pos);\n+        switch (c) {\n+        case 0 :\n+            // no '/'\n+            // return num as a BigFraction\n+            return new BigFraction(num);\n+        case '/' :\n+            // found '/', continue parsing denominator\n+            break;\n+        default :\n+            // invalid '/'\n+            // set index back to initial, error index should be the last\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            pos.setErrorIndex(startIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse denominator\n+        final BigInteger den = parseNextBigInteger(source, pos);\n+        if (den == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+        \n+        if (den.compareTo(BigInteger.ZERO) < 0) {\n+            // minus signs must be leading, invalid\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        boolean wholeIsNeg = whole.compareTo(BigInteger.ZERO) < 0;\n+        if (wholeIsNeg) {\n+            whole = whole.negate();\n+        }\n+        num = whole.multiply(den).add(num);\n+        if (wholeIsNeg) {\n+            num = num.negate();\n+        }\n+\n+        return new BigFraction(num, den);\n+\n+    }\n+    \n+    /**\n+     * Modify the whole format.\n+     * @param format The new whole format value.\n+     * @throws IllegalArgumentException if <code>format</code> is\n+     *         <code>null</code>.\n+     */\n+    public void setWholeFormat(final NumberFormat format) {\n+        if (format == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"whole format can not be null\");\n+        }\n+        this.wholeFormat = format;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.fraction;\n+\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Formats a Fraction number in proper format.  The number format for each of\n+ * the whole number, numerator and, denominator can be configured.\n+ * <p>\n+ * Minus signs are only allowed in the whole number part - i.e.,\n+ * \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n+ * will result in a <code>ParseException</code>.</p>\n+ * \n+ * @since 1.1\n+ * @version $Revision$ $Date$\n+ */\n+public class ProperFractionFormat extends FractionFormat {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 760934726031766749L;\n+\n+    /** The format used for the whole number. */\n+    private NumberFormat wholeFormat;\n+\n+    /**\n+     * Create a proper formatting instance with the default number format for\n+     * the whole, numerator, and denominator.  \n+     */\n+    public ProperFractionFormat() {\n+        this(getDefaultNumberFormat());\n+    }\n+    \n+    /**\n+     * Create a proper formatting instance with a custom number format for the\n+     * whole, numerator, and denominator.\n+     * @param format the custom format for the whole, numerator, and\n+     *        denominator.\n+     */\n+    public ProperFractionFormat(NumberFormat format) {\n+        this(format, (NumberFormat)format.clone(), (NumberFormat)format.clone());\n+    }\n+    \n+    /**\n+     * Create a proper formatting instance with a custom number format for each\n+     * of the whole, numerator, and denominator.\n+     * @param wholeFormat the custom format for the whole.\n+     * @param numeratorFormat the custom format for the numerator.\n+     * @param denominatorFormat the custom format for the denominator.\n+     */\n+    public ProperFractionFormat(NumberFormat wholeFormat,\n+            NumberFormat numeratorFormat,\n+            NumberFormat denominatorFormat)\n+    {\n+        super(numeratorFormat, denominatorFormat);\n+        setWholeFormat(wholeFormat);\n+    }\n+    \n+    /**\n+     * Formats a {@link Fraction} object to produce a string.  The fraction\n+     * is output in proper format.\n+     *\n+     * @param fraction the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    @Override\n+    public StringBuffer format(Fraction fraction, StringBuffer toAppendTo,\n+            FieldPosition pos) {\n+        \n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        int num = fraction.getNumerator();\n+        int den = fraction.getDenominator();\n+        int whole = num / den;\n+        num = num % den;\n+        \n+        if (whole != 0) {\n+            getWholeFormat().format(whole, toAppendTo, pos);\n+            toAppendTo.append(' ');\n+            num = Math.abs(num);\n+        }\n+        getNumeratorFormat().format(num, toAppendTo, pos);\n+        toAppendTo.append(\" / \");\n+        getDenominatorFormat().format(den, toAppendTo,\n+            pos);\n+        \n+        return toAppendTo;\n+    }\n+\n+    /**\n+     * Access the whole format.\n+     * @return the whole format.\n+     */\n+    public NumberFormat getWholeFormat() {\n+        return wholeFormat;\n+    }\n+    \n+    /**\n+     * Parses a string to produce a {@link Fraction} object.  This method\n+     * expects the string to be formatted as a proper fraction.\n+     * <p>\n+     * Minus signs are only allowed in the whole number part - i.e.,\n+     * \"-3 1/2\" is legitimate and denotes -7/2, but \"-3 -1/2\" is invalid and\n+     * will result in a <code>ParseException</code>.</p>\n+     * \n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link Fraction} object.\n+     */\n+    @Override\n+    public Fraction parse(String source, ParsePosition pos) {\n+        // try to parse improper fraction\n+        Fraction ret = super.parse(source, pos);\n+        if (ret != null) {\n+            return ret;\n+        }\n+        \n+        int initialIndex = pos.getIndex();\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse whole\n+        Number whole = getWholeFormat().parse(source, pos);\n+        if (whole == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+        \n+        // parse numerator\n+        Number num = getNumeratorFormat().parse(source, pos);\n+        if (num == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+        \n+        if (num.intValue() < 0) {\n+            // minus signs should be leading, invalid expression\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse '/'\n+        int startIndex = pos.getIndex();\n+        char c = parseNextCharacter(source, pos);\n+        switch (c) {\n+        case 0 :\n+            // no '/'\n+            // return num as a fraction\n+            return new Fraction(num.intValue(), 1);\n+        case '/' :\n+            // found '/', continue parsing denominator\n+            break;\n+        default :\n+            // invalid '/'\n+            // set index back to initial, error index should be the last\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            pos.setErrorIndex(startIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse denominator\n+        Number den = getDenominatorFormat().parse(source, pos);\n+        if (den == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+        \n+        if (den.intValue() < 0) {\n+            // minus signs must be leading, invalid\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        int w = whole.intValue();\n+        int n = num.intValue();\n+        int d = den.intValue();\n+        return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n+    }\n+    \n+    /**\n+     * Modify the whole format.\n+     * @param format The new whole format value.\n+     * @throws IllegalArgumentException if <code>format</code> is\n+     *         <code>null</code>.\n+     */\n+    public void setWholeFormat(NumberFormat format) {\n+        if (format == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"whole format can not be null\");\n+        }\n+        this.wholeFormat = format;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/AbstractListChromosome.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Chromosome represented by an immutable list of a fixed length.\n+ * \n+ * @param <T> type of the representation list\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class AbstractListChromosome<T> extends Chromosome {\n+    \n+    /** List representing the chromosome */\n+    private final List<T> representation;\n+    \n+    /**\n+     * Constructor.\n+     * @param representation inner representation of the chromosome\n+     */\n+    public AbstractListChromosome(final List<T> representation) {\n+        try {\n+            checkValidity(representation);\n+        } catch (InvalidRepresentationException e) {\n+            throw new IllegalArgumentException(String.format(\"Invalid representation for %s\", getClass().getSimpleName()), e);\n+        }\n+        this.representation = Collections.unmodifiableList(new ArrayList<T> (representation));\n+    }\n+    \n+    /**\n+     * Constructor.\n+     * @param representation inner representation of the chromosome\n+     */\n+    public AbstractListChromosome(final T[] representation) {\n+        this(Arrays.asList(representation));\n+    }\n+\n+    /**\n+     * \n+     * Asserts that <code>representation</code> can represent a valid chromosome.\n+     * @param representation representation of the chromosome\n+     * @throws InvalidRepresentationException iff the <code>representation</code> can not represent\n+     *         a valid chromosome\n+     */\n+    protected abstract void checkValidity(List<T> representation) throws InvalidRepresentationException;\n+\n+    /**\n+     * Returns the (immutable) inner representation of the chromosome.\n+     * @return the representation of the chromosome\n+     */\n+    protected List<T> getRepresentation() {\n+        return representation;\n+    }\n+\n+    /**\n+     * Returns the length of the chromosome.\n+     * @return the length of the chromosome\n+     */\n+    public int getLength() {\n+        return getRepresentation().size();\n+    }\n+\n+    /**\n+     * Creates a new instance of the same class as <code>this</code> is, with a\n+     * given <code>arrayRepresentation</code>. This is needed in crossover and\n+     * mutation operators, where we need a new instance of the same class, but\n+     * with different array representation.\n+     * \n+     * Usually, this method just calls a constructor of the class.\n+     * \n+     * @param representation\n+     *            the inner array representation of the new chromosome.\n+     * @return new instance extended from FixedLengthChromosome with the given\n+     *         arrayRepresentation\n+     */\n+    public abstract AbstractListChromosome<T> newFixedLengthChromosome(final List<T> representation);\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String toString() {\n+        return String.format(\"(f=%s %s)\", getFitness(), getRepresentation());\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/BinaryChromosome.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * Chromosome represented by a vector of 0s and 1s.\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class BinaryChromosome extends AbstractListChromosome<Integer> {\n+    \n+    /**\n+     * Constructor.\n+     * @param representation list of {0,1} values representing the chromosome\n+     */\n+    public BinaryChromosome(List<Integer> representation) {\n+        super(representation);\n+    }\n+    \n+    /**\n+     * Constructor.\n+     * @param representation array of {0,1} values representing the chromosome\n+     */\n+    public BinaryChromosome(Integer[] representation) {\n+        super(representation);\n+    }\n+     \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected void checkValidity(List<Integer> representation) throws InvalidRepresentationException {\n+        for (int i : representation) {\n+            if (i < 0 || i >1)\n+                throw new InvalidRepresentationException(\"Elements can be only 0 or 1.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns a representation of a random binary array of length <code>length</code>.\n+     * @param length length of the array\n+     * @return a random binary array of length <code>length</code>\n+     */\n+    public static List<Integer> randomBinaryRepresentation(int length) {\n+        // random binary list\n+        List<Integer> rList= new ArrayList<Integer> (length);\n+        for (int j=0; j<length; j++) {\n+            rList.add(GeneticAlgorithm.getRandomGenerator().nextInt(2));\n+        }\n+        return rList;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected boolean isSame(Chromosome another) {\n+        // type check\n+        if (! (another instanceof BinaryChromosome))\n+            return false;\n+        BinaryChromosome anotherBc = (BinaryChromosome) another;\n+        // size check\n+        if (getLength() != anotherBc.getLength())\n+            return false;\n+        \n+        for (int i=0; i< getRepresentation().size(); i++) {\n+            if (!(getRepresentation().get(i).equals(anotherBc.getRepresentation().get(i))))\n+                return false;\n+        }\n+        // all is ok\n+        return true;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/BinaryMutation.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Mutation for {@link BinaryChromosome}s. Randomly changes one gene.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class BinaryMutation implements MutationPolicy {\n+\n+    /**\n+     * Mutate the given chromosome. Randomly changes one gene.\n+     * @param original the original chromosome.\n+     * @return the mutated chromomsome.\n+     */\n+    public Chromosome mutate(Chromosome original) {\n+        if (!(original instanceof BinaryChromosome)) {\n+            throw new IllegalArgumentException(\"Binary mutation works on BinaryChromosome only.\"); \n+        }\n+        \n+        BinaryChromosome origChrom = (BinaryChromosome) original;\n+        List<Integer> newRepr = new ArrayList<Integer>(origChrom.getRepresentation());\n+        \n+        // randomly select a gene\n+        int geneIndex = GeneticAlgorithm.getRandomGenerator().nextInt(origChrom.getLength());\n+        // and change it\n+        newRepr.set(geneIndex, origChrom.getRepresentation().get(geneIndex) == 0 ? 1 : 0);\n+        \n+        Chromosome newChrom = origChrom.newFixedLengthChromosome(newRepr);\n+        return newChrom;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/Chromosome.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+/**\n+ * Individual in a population. Chromosomes are compared based on their fitness.\n+ * \n+ * The chromosomes are IMMUTABLE, and so their fitness is also immutable and\n+ * therefore it can be cached.\n+ * \n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n+ */\n+public abstract class Chromosome implements Comparable<Chromosome>,Fitness {\n+    \n+    /**\n+     * Cached value of the fitness of this chromosome.\n+     */\n+    private double fitness = Double.MIN_VALUE;\n+    \n+    /**\n+     * Access the fitness of this chromosome. The bigger the fitness, the better\n+     * the chromosome.\n+     * \n+     * Computation of fitness is usually very time-consuming task, therefore the\n+     * fitness is cached.\n+     * \n+     * @return the fitness.\n+     */\n+    public double getFitness() {\n+        if (this.fitness == Double.MIN_VALUE) {\n+            // no cache - compute the fitness\n+            this.fitness = fitness();\n+        }\n+        return this.fitness;\n+    }\n+        \n+    /**\n+     * Compares two chromosomes based on their fitness. The bigger the fitness,\n+     * the better the chromosome.\n+     * \n+     * @param another another chromosome to compare\n+     * @return\n+     * <ul>\n+     *     <li>-1 if <code>another</code> is better than <code>this</code></li>\n+     *     <li>1 if <code>another</code> is worse than <code>this</code></li>\n+     *     <li>0 if the two chromosomes have the same fitness</li>\n+     * </ul>\n+     */\n+    public int compareTo(Chromosome another) {\n+        return ((Double)this.getFitness()).compareTo(another.getFitness());\n+    }\n+\n+    /**\n+     * Returns <code>true<code> iff <code>another</code> has the same\n+     * representation and therefore the same fitness. By default, it returns\n+     * false -- override it in your implementation if you need it. \n+     * @param another chromosome to compare\n+     * @return true if <code>another</code> is equivalent to this chromosome\n+     */\n+    protected boolean isSame(Chromosome another) {\n+        return false;\n+    }\n+\n+    /**\n+     * Searches the <code>population</code> for another chromosome with the same\n+     * representation. If such chromosome is found, it is returned, if no such\n+     * chromosome exists, returns <code>null</code>.\n+     * \n+     * @param population\n+     *            Population to search\n+     * @return Chromosome with the same representation, or <code>null</code> if\n+     *         no such chromosome exists.\n+     */\n+    protected Chromosome findSameChromosome(Population population) {\n+        for (Chromosome anotherChr : population) {\n+            if (this.isSame(anotherChr))\n+                return anotherChr;\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Searches the population for a chromosome representing the same solution,\n+     * and if it finds one, updates the fitness to its value.\n+     * \n+     * @param population\n+     *            Population to search\n+     */\n+    public void searchForFitnessUpdate(Population population) {\n+        Chromosome sameChromosome = findSameChromosome(population);\n+        if (sameChromosome != null) {\n+            fitness = sameChromosome.getFitness();\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/ChromosomePair.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+/**\n+ * A pair of {@link Chromosome} objects.\n+ * @since 2.0\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class ChromosomePair {\n+    /** the first chromosome in the pair. */\n+    private final Chromosome first;\n+\n+    /** the second chromosome in the pair. */\n+    private final Chromosome second;\n+\n+    /**\n+     * Create a chromosome pair.\n+     * \n+     * @param c1 the first chromosome.\n+     * @param c2 the second chromosome.\n+     */\n+    public ChromosomePair(final Chromosome c1, final Chromosome c2) {\n+        super();\n+        first = c1;\n+        second = c2;\n+    }\n+\n+    /**\n+     * Access the first chromosome.\n+     * \n+     * @return the first chromosome.\n+     */\n+    public Chromosome getFirst() {\n+        return first;\n+    }\n+\n+    /**\n+     * Access the second chromosome.\n+     * \n+     * @return the second chromosome.\n+     */\n+    public Chromosome getSecond() {\n+        return second;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String toString() {        \n+        return String.format(\"(%s,%s)\", getFirst(), getSecond());\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/CrossoverPolicy.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+/**\n+ * Policy used to create a pair of new chromosomes by performing a crossover\n+ * operation on a source pair of chromosomes.\n+ * \n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+public interface CrossoverPolicy {\n+    /**\n+     * Perform a crossover operation on the given chromosomes.\n+     * \n+     * @param first the first chromosome.\n+     * @param second the second chromosome.\n+     * @return the pair of new chromosomes that resulted from the crossover.\n+     */\n+    ChromosomePair crossover(Chromosome first, Chromosome second);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/ElitisticListPopulation.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Population of chromosomes which uses elitism (certain percentace of the best\n+ * chromosomes is directly copied to the next generation).\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class ElitisticListPopulation extends ListPopulation {\n+    \n+    /** percentage of chromosomes copied to the next generation */\n+    private double elitismRate = 0.9;\n+\n+    /**\n+     * Creates a new ElitisticListPopulation instance.\n+     * \n+     * @param chromosomes\n+     *            list of chromosomes in the population\n+     * @param populationLimit\n+     *            maximal size of the population\n+     * @param elitismRate\n+     *            how many best chromosomes will be directly transferred to the\n+     *            next generation [in %]\n+     */\n+    public ElitisticListPopulation(List<Chromosome> chromosomes, int populationLimit, double elitismRate) {\n+        super(chromosomes, populationLimit);\n+        this.elitismRate = elitismRate;\n+    }\n+\n+    /**\n+     * Creates a new ListPopulation instance and initializes its inner\n+     * chromosome list.\n+     * \n+     * @param populationLimit maximal size of the population\n+     * @param elitismRate\n+     *            how many best chromosomes will be directly transferred to the\n+     *            next generation [in %] \n+     */\n+    public ElitisticListPopulation(int populationLimit, double elitismRate) {\n+        super(populationLimit);\n+        this.elitismRate = elitismRate;\n+    }\n+\n+    /**\n+     * Start the population for the next generation. The\n+     * <code>{@link #elitismRate}<code> percents of the best \n+     * chromosomes are directly copied to the next generation.\n+     * \n+     * @return the beginnings of the next generation.\n+     */\n+    public Population nextGeneration() {\n+        // initialize a new generation with the same parameters\n+        ElitisticListPopulation nextGeneration = new ElitisticListPopulation(this.getPopulationLimit(), this.getElitismRate());\n+        \n+        List<Chromosome> oldChromosomes = this.getChromosomes();\n+        Collections.sort(oldChromosomes);\n+        \n+        // index of the last \"not good enough\" chromosome \n+        int boundIndex = (int) Math.ceil((1.0 - this.getElitismRate()) * oldChromosomes.size());\n+        for (int i=boundIndex; i<oldChromosomes.size(); i++) {\n+            nextGeneration.addChromosome(oldChromosomes.get(i));\n+        }\n+        return nextGeneration;\n+    }\n+\n+    /**\n+     * Sets the elitism rate, i.e. how many best chromosomes will be directly\n+     * transferred to the next generation [in %].\n+     * \n+     * @param elitismRate\n+     *            how many best chromosomes will be directly transferred to the\n+     *            next generation [in %]\n+     */\n+    public void setElitismRate(double elitismRate) {\n+        if (elitismRate < 0 || elitismRate > 1)\n+            throw new IllegalArgumentException(\"Elitism rate has to be in [0,1]\");\n+        this.elitismRate = elitismRate;\n+    }\n+\n+    /**\n+     * Access the elitism rate.\n+     * @return the elitism rate\n+     */\n+    public double getElitismRate() {\n+        return this.elitismRate;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/Fitness.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+/**\n+ * Fitness of a chromosome.\n+ *\n+ * @version $Revision:$ $Date:$\n+ * @since 2.0\n+ */\n+public interface Fitness {\n+    /**\n+     * Compute the fitness. This is usually very time-consuming, so the value\n+     * should be cached.\n+     * \n+     * @return fitness\n+     */\n+    public double fitness();\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/FixedGenerationCount.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+/**\n+ * Stops after a fixed number of generations.  Each time \n+ * {@link #isSatisfied(Population)} is invoked, a generation counter is\n+ * incremented.  Once the counter reaches the configured \n+ * <code>maxGenerations</code> value, {@link #isSatisfied(Population)} returns\n+ * true.\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class FixedGenerationCount implements StoppingCondition {\n+    /** Number of generations that have passed */\n+    private int numGenerations = 0;\n+    \n+    /** Maximum number of generations (stopping criteria) */\n+    private final int maxGenerations;\n+    \n+    /**\n+     * Create a new FixedGenerationCount instance.\n+     * \n+     * @param maxGenerations number of generations to evolve\n+     */\n+    public FixedGenerationCount(int maxGenerations) {\n+        if (maxGenerations <= 0) \n+            throw new IllegalArgumentException(\"The number of generations has to be >= 0\");\n+        this.maxGenerations = maxGenerations;\n+    }\n+    \n+    /**\n+     * Determine whether or not the given number of generations have passed.\n+     * Increments the number of generations counter if the maximum has not\n+     * been reached.\n+     * \n+     * @param population ignored (no impact on result)\n+     * @return <code>true</code> IFF the maximum number of generations has been exceeded\n+     */\n+    public boolean isSatisfied(Population population) {\n+        if (this.numGenerations < this.maxGenerations) {\n+            numGenerations++;\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * @return the number of generations that have passed\n+     */\n+    public int getNumGenerations() {\n+        return numGenerations;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/GeneticAlgorithm.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import org.apache.commons.math.random.RandomGenerator;\n+import org.apache.commons.math.random.JDKRandomGenerator;\n+\n+/**\n+ * Implementation of a genetic algorithm. All factors that govern the operation\n+ * of the algorithm can be configured for a specific problem.\n+ *\n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+public class GeneticAlgorithm {\n+\n+    /**\n+     * Static random number generator shared by GA implementation classes.\n+     * Set the randomGenerator seed to get reproducible results.  \n+     * Use {@link #setRandomGenerator(RandomGenerator)} to supply an alternative\n+     * to the default JDK-provided PRNG.\n+     */\n+    //@GuardedBy(\"this\")\n+    private static RandomGenerator randomGenerator = new JDKRandomGenerator();\n+    \n+    /**\n+     * Set the (static) random generator.\n+     * \n+     * @param random random generator\n+     */\n+    public synchronized static void setRandomGenerator(RandomGenerator random) {\n+        randomGenerator = random;\n+    }\n+    \n+    /**\n+     * Returns the (static) random generator.\n+     * \n+     * @return the static random generator shared by GA implementation classes\n+     */\n+    public synchronized static RandomGenerator getRandomGenerator() {\n+        return randomGenerator;\n+    }\n+      \n+    /** the crossover policy used by the algorithm. */\n+    private final CrossoverPolicy crossoverPolicy;\n+\n+    /** the rate of crossover for the algorithm. */\n+    private final double crossoverRate;\n+\n+    /** the mutation policy used by the algorithm. */\n+    private final MutationPolicy mutationPolicy;\n+\n+    /** the rate of mutation for the algorithm. */\n+    private final double mutationRate;\n+\n+    /** the selection policy used by the algorithm. */\n+    private final SelectionPolicy selectionPolicy;\n+    \n+    /**\n+     * @param crossoverPolicy The {@link CrossoverPolicy}\n+     * @param crossoverRate The crossover rate as a percentage (0-1 inclusive)\n+     * @param mutationPolicy The {@link MutationPolicy}\n+     * @param mutationRate The mutation rate as a percentage (0-1 inclusive)\n+     * @param selectionPolicy The {@link SelectionPolicy}\n+     */\n+    public GeneticAlgorithm(\n+            CrossoverPolicy crossoverPolicy, double crossoverRate,\n+            MutationPolicy mutationPolicy, double mutationRate,\n+            SelectionPolicy selectionPolicy) {\n+        if (crossoverRate < 0 || crossoverRate > 1) {\n+            throw new IllegalArgumentException(\"crossoverRate must be between 0 and 1\");\n+        }\n+        if (mutationRate < 0 || mutationRate > 1) {\n+            throw new IllegalArgumentException(\"mutationRate must be between 0 and 1\");\n+        }\n+        this.crossoverPolicy = crossoverPolicy;\n+        this.crossoverRate = crossoverRate;\n+        this.mutationPolicy = mutationPolicy;\n+        this.mutationRate = mutationRate;\n+        this.selectionPolicy = selectionPolicy;\n+    }\n+    \n+    /**\n+     * Evolve the given population. Evolution stops when the stopping condition\n+     * is satisfied.\n+     * \n+     * @param initial the initial, seed population.\n+     * @param condition the stopping condition used to stop evolution.\n+     * @return the population that satisfies the stopping condition.\n+     */\n+    public Population evolve(Population initial, StoppingCondition condition) {\n+        Population current = initial;\n+        while (!condition.isSatisfied(current)) {\n+            current = nextGeneration(current);\n+        }\n+        return current;\n+    }\n+\n+    /**\n+     * <p>Evolve the given population into the next generation.</p>\n+     * <p><ol>\n+     *    <li>Get nextGeneration population to fill from <code>current</code>\n+     *        generation, using its nextGeneration method</li>\n+     *    <li>Loop until new generation is filled:</li>\n+     *    <ul><li>Apply configured SelectionPolicy to select a pair of parents\n+     *            from <code>current</code></li>\n+     *        <li>With probability = {@link #getCrossoverRate()}, apply\n+     *            configured {@link CrossoverPolicy} to parents</li>\n+     *        <li>With probability = {@link #getMutationRate()}, apply\n+     *            configured {@link MutationPolicy} to each of the offspring</li>\n+     *        <li>Add offspring individually to nextGeneration,\n+     *            space permitting</li>\n+     *    </ul>\n+     *    <li>Return nextGeneration</li>\n+     *    </ol>\n+     * </p>\n+     * \n+     * @param current the current population.\n+     * @return the population for the next generation.\n+     */\n+    public Population nextGeneration(Population current) {\n+        Population nextGeneration = current.nextGeneration();\n+\n+        RandomGenerator randGen = getRandomGenerator();\n+        \n+        while (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {\n+            // select parent chromosomes\n+            ChromosomePair pair = getSelectionPolicy().select(current);\n+\n+            // crossover?\n+            if (randGen.nextDouble() < getCrossoverRate()) {\n+                // apply crossover policy to create two offspring\n+                pair = getCrossoverPolicy().crossover(pair.getFirst(), pair.getSecond());\n+            }\n+\n+            // mutation?\n+            if (randGen.nextDouble() < getMutationRate()) {\n+                // apply mutation policy to the chromosomes\n+                pair = new ChromosomePair(\n+                    getMutationPolicy().mutate(pair.getFirst()),\n+                    getMutationPolicy().mutate(pair.getSecond()));\n+            }\n+\n+            // add the first chromosome to the population\n+            nextGeneration.addChromosome(pair.getFirst());\n+            // is there still a place for the second chromosome?\n+            if (nextGeneration.getPopulationSize() < nextGeneration.getPopulationLimit()) {\n+                // add the second chromosome to the population\n+                nextGeneration.addChromosome(pair.getSecond());\n+            }\n+        }\n+\n+        return nextGeneration;\n+    }    \n+    \n+    /**\n+     * Returns the crossover policy.\n+     * @return crossover policy\n+     */\n+    public CrossoverPolicy getCrossoverPolicy() {\n+        return crossoverPolicy;\n+    }\n+\n+    /**\n+     * Returns the crossover rate.\n+     * @return crossover rate\n+     */\n+    public double getCrossoverRate() {\n+        return crossoverRate;\n+    }\n+\n+    /**\n+     * Returns the mutation policy.\n+     * @return mutation policy\n+     */\n+    public MutationPolicy getMutationPolicy() {\n+        return mutationPolicy;\n+    }\n+\n+    /**\n+     * Returns the mutation rate.\n+     * @return mutation rate\n+     */\n+    public double getMutationRate() {\n+        return mutationRate;\n+    }\n+\n+    /**\n+     * Returns the selection policy.\n+     * @return selection policy\n+     */\n+    public SelectionPolicy getSelectionPolicy() {\n+        return selectionPolicy;\n+    }\n+        \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/InvalidRepresentationException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+/**\n+ * Exception indicating that the representation of a chromosome is not valid.\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class InvalidRepresentationException extends Exception {\n+\n+    /** Serialization version id */\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * Constructor\n+     */\n+    public InvalidRepresentationException() {\n+        super();\n+    }\n+\n+    /**\n+     * Construct an InvalidRepresentationException\n+     * @param arg0 exception message\n+     */\n+    public InvalidRepresentationException(String arg0) {\n+        super(arg0);\n+    }\n+\n+    /**\n+     * Construct an InvalidRepresentationException\n+     * @param arg0 cause\n+     */\n+    public InvalidRepresentationException(Throwable arg0) {\n+        super(arg0);\n+    }\n+\n+    /**\n+     * Construct an InvalidRepresentationException\n+     * \n+     * @param arg0 exception message\n+     * @param arg1 cause\n+     */\n+    public InvalidRepresentationException(String arg0, Throwable arg1) {\n+        super(arg0, arg1);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/ListPopulation.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+/**\n+ * Population of chromosomes represented by a {@link List}.\n+ *\n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+public abstract class ListPopulation implements Population {\n+    \n+    /** List of chromosomes */\n+    private List<Chromosome> chromosomes;\n+    \n+    /** maximial size of the population */\n+    private int populationLimit;\n+    \n+    \n+    /**\n+     * Creates a new ListPopulation instance.\n+     * \n+     * @param chromosomes list of chromosomes in the population\n+     * @param populationLimit maximal size of the population\n+     */\n+    public ListPopulation (List<Chromosome> chromosomes, int populationLimit) {\n+        if (chromosomes.size() > populationLimit) {\n+            throw new IllegalArgumentException(\"List of chromosomes bigger than maxPopulationSize.\");\n+        }\n+        if (populationLimit < 0) {\n+            throw new IllegalArgumentException(\"Population limit has to be >= 0\");\n+        }\n+            \n+        this.chromosomes = chromosomes;\n+        this.populationLimit = populationLimit;\n+    }\n+    \n+    /**\n+     * Creates a new ListPopulation instance and initializes its inner\n+     * chromosome list.\n+     * \n+     * @param populationLimit maximal size of the population\n+     */\n+    public ListPopulation (int populationLimit) {\n+        if (populationLimit < 0) {\n+            throw new IllegalArgumentException(\"Population limit has to be >= 0\");\n+        }\n+        this.populationLimit = populationLimit;\n+        this.chromosomes = new ArrayList<Chromosome>(populationLimit);\n+    }\n+\n+    /**\n+     * Sets the list of chromosomes.\n+     * @param chromosomes the list of chromosomes\n+     */\n+    public void setChromosomes(List<Chromosome> chromosomes) {\n+        this.chromosomes = chromosomes;\n+    }\n+    \n+    /**\n+     * Access the list of chromosomes.\n+     * @return the list of chromosomes\n+     */\n+    public List<Chromosome> getChromosomes() {\n+        return chromosomes;\n+    }\n+\n+    /**\n+     * Add the given chromosome to the population.\n+     * @param chromosome the chromosome to add.\n+     */\n+    public void addChromosome(Chromosome chromosome) {\n+        this.chromosomes.add(chromosome);\n+    }\n+\n+    /**\n+     * Access the fittest chromosome in this population.\n+     * @return the fittest chromosome.\n+     */\n+    public Chromosome getFittestChromosome() {\n+        // best so far\n+        Chromosome bestChromosome = this.chromosomes.get(0);    \n+        for (Chromosome chromosome : this.chromosomes) {\n+            if (chromosome.compareTo(bestChromosome) > 0) {\n+                // better chromosome found\n+                bestChromosome = chromosome;\n+            }\n+        }\n+        return bestChromosome;\n+    }\n+    \n+    /**\n+     * Access the maximum population size.\n+     * @return the maximum population size.\n+     */\n+    public int getPopulationLimit() {\n+        return this.populationLimit;\n+    }\n+    \n+    /**\n+     * Sets the maximal population size.\n+     * @param populationLimit maximal population size.\n+     */\n+    public void setPopulationLimit(int populationLimit) {\n+        this.populationLimit = populationLimit;\n+    }\n+\n+    /**\n+     * Access the current population size.\n+     * @return the current population size.\n+     */\n+    public int getPopulationSize() {        \n+        return this.chromosomes.size();\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String toString() {\n+        return this.chromosomes.toString();\n+    }\n+    \n+    /**\n+     * Chromosome list iterator\n+     * \n+     * @return chromosome iterator\n+     */\n+    public Iterator<Chromosome> iterator() {        \n+        return chromosomes.iterator();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/MutationPolicy.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+/**\n+ * Algorithm used to mutate a chrommosome.\n+ * \n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+public interface MutationPolicy {\n+\n+    /**\n+     * Mutate the given chromosome.\n+     * @param original the original chromosome.\n+     * @return the mutated chromomsome.\n+     */\n+    Chromosome mutate(Chromosome original);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/OnePointCrossover.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\n+/**\n+ * One point crossover policy. A random crossover point is selected and the\n+ * first part from each parent is copied to the corresponding child, and the\n+ * second parts are copied crosswise.\n+ * \n+ * Example:\n+ * <pre>\n+ * -C- denotes a crossover point\n+ *                   -C-                                -C-\n+ * p1 = (1 0 1 0 0 1  | 0 1 1)    X    p2 = (0 1 1 0 1 0  | 1 1 1)\n+ *         \\------------/ \\-----/              \\------------/ \\-----/\n+ *            ||         (*)                       ||        (**)\n+ *            VV         (**)                      VV        (*)\n+ *      /------------\\ /-----\\              /------------\\ /-----\\\n+ * c1 = (1 0 1 0 0 1  | 1 1 1)    X    p2 = (0 1 1 0 1 0  | 0 1 1)\n+ * </pre>\n+ * \n+ * This policy works only on {@link AbstractListChromosome}, and therefore it \n+ * is parametrized by T. Moreover, the chromosomes must have same lengths.\n+ * \n+ * @param <T> generic type of the {@link AbstractListChromosome}s for crossover\n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ * \n+ */\n+public class OnePointCrossover<T> implements CrossoverPolicy {\n+    \n+    /**\n+     * Performs one point crossover. A random crossover point is selected and the\n+     * first part from each parent is copied to the corresponding child, and the\n+     * second parts are copied crosswise.\n+     * \n+     * Example:\n+     * -C- denotes a crossover point\n+     *                   -C-                                -C-\n+     * p1 = (1 0 1 0 0 1  | 0 1 1)    X    p2 = (0 1 1 0 1 0  | 1 1 1)\n+     *         \\------------/ \\-----/              \\------------/ \\-----/\n+     *            ||         (*)                       ||        (**)\n+     *            VV         (**)                      VV        (*)\n+     *      /------------\\ /-----\\              /------------\\ /-----\\\n+     * c1 = (1 0 1 0 0 1  | 1 1 1)    X    p2 = (0 1 1 0 1 0  | 0 1 1)\n+     * \n+     * @param first first parent (p1)\n+     * @param second second parent (p2)\n+     * @return pair of two children (c1,c2)\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public ChromosomePair crossover(Chromosome first, Chromosome second) {\n+        if (! (first instanceof AbstractListChromosome && second instanceof AbstractListChromosome)) {\n+            throw new IllegalArgumentException(\"One point crossover works on FixedLengthChromosomes only.\");\n+        }\n+        return crossover((AbstractListChromosome<T>) first, (AbstractListChromosome<T>) second);\n+    }\n+\n+\n+    /**\n+     * Helper for {@link #crossover(Chromosome, Chromosome)}. Performs the actual crossover.\n+     * \n+     * @param first the first chromosome.\n+     * @param second the second chromosome.\n+     * @return the pair of new chromosomes that resulted from the crossover.\n+     */\n+    private ChromosomePair crossover(AbstractListChromosome<T> first, AbstractListChromosome<T> second) {\n+        int length = first.getLength();\n+        if (length != second.getLength()) \n+            throw new IllegalArgumentException(\"Both chromosomes must have same lengths.\");\n+        \n+        // array representations of the parents\n+        List<T> parent1Rep = first.getRepresentation();\n+        List<T> parent2Rep = second.getRepresentation();\n+        // and of the children\n+        ArrayList<T> child1Rep = new ArrayList<T> (first.getLength());\n+        ArrayList<T> child2Rep = new ArrayList<T> (second.getLength());\n+        \n+        // select a crossover point at random (0 and length makes no sense)\n+        int crossoverIndex = 1 + (GeneticAlgorithm.getRandomGenerator().nextInt(length-2));\n+\n+        // copy the first part\n+        for (int i = 0; i < crossoverIndex; i++) {\n+            child1Rep.add(parent1Rep.get(i));\n+            child2Rep.add(parent2Rep.get(i));\n+        }\n+        // and switch the second part\n+        for (int i = crossoverIndex; i < length; i++) {\n+            child1Rep.add(parent2Rep.get(i));\n+            child2Rep.add(parent1Rep.get(i));\n+        }\n+        \n+        return new ChromosomePair(\n+                first.newFixedLengthChromosome(child1Rep),\n+                second.newFixedLengthChromosome(child2Rep)\n+                );\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/PermutationChromosome.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.List;\n+\n+/**\n+ * Interface indicating that the chromosome represents a permutation of objects.\n+ * \n+ * @param <T>\n+ *            type of the permuted objects\n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+public interface PermutationChromosome<T> {\n+\n+    /**\n+     * Permutes the <code>sequence</code> of objects of type T according to the\n+     * permutation this chromosome represents. For example, if this chromosome\n+     * represents a permutation (3,0,1,2), and the unpermuted sequence is\n+     * (a,b,c,d), this yields (d,a,b,c).\n+     * \n+     * @param sequence\n+     *            the unpermuted (original) sequence of objects\n+     * @return permutation of <code>sequence</code> represented by this\n+     *         permutation\n+     */\n+    public List<T> decode(List<T> sequence);\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/Population.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+/**\n+ * A collection of chromosomes that facilitates generational evolution.\n+ * \n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n+ */\n+public interface Population extends Iterable<Chromosome> {\n+    /**\n+     * Access the current population size.\n+     * @return the current population size.\n+     */\n+    int getPopulationSize();\n+\n+    /**\n+     * Access the maximum population size.\n+     * @return the maximum population size.\n+     */\n+    int getPopulationLimit();\n+\n+    /**\n+     * Start the population for the next generation.\n+     * @return the beginnings of the next generation.\n+     */\n+    Population nextGeneration();\n+\n+    /**\n+     * Add the given chromosome to the population.\n+     * @param chromosome the chromosome to add.\n+     */\n+    void addChromosome(Chromosome chromosome);\n+\n+    /**\n+     * Access the fittest chromosome in this population.\n+     * @return the fittest chromosome.\n+     */\n+    Chromosome getFittestChromosome();\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/RandomKey.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+\n+/**\n+ * <p>\n+ * Random Key chromosome is used for permutation representation. It is a vector\n+ * of a fixed length of real numbers in [0,1] interval. The index of the i-th\n+ * smallest value in the vector represents an i-th member of the permutation.\n+ * </p>\n+ * \n+ * <p>\n+ * For example, the random key [0.2, 0.3, 0.8, 0.1] corresponds to the\n+ * permutation of indices (3,0,1,2). If the original (unpermuted) sequence would\n+ * be (a,b,c,d), this would mean the sequence (d,a,b,c).\n+ * </p>\n+ * \n+ * <p>\n+ * With this representation, common operators like n-point crossover can be\n+ * used, because any such chromosome represents a valid permutation.\n+ * </p>\n+ * \n+ * <p>\n+ * Since the chromosome (and thus its arrayRepresentation) is immutable, the\n+ * array representation is sorted only once in the constructor.\n+ * </p>\n+ * \n+ * <p>\n+ * For details, see:\n+ * <ul>\n+ * <li>Bean, J.C.: Genetic algorithms and random keys for sequencing and\n+ * optimization. ORSA Journal on Computing 6 (1994) 154\u2013160</li>\n+ * <li>Rothlauf, F.: Representations for Genetic and Evolutionary Algorithms.\n+ * Volume 104 of Studies in Fuzziness and Soft Computing. Physica-Verlag,\n+ * Heidelberg (2002)</li>\n+ * </ul>\n+ * </p>\n+ * \n+ * @param <T>\n+ *            type of the permuted objects\n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+public abstract class RandomKey<T> extends AbstractListChromosome<Double> implements PermutationChromosome<T> {\n+    \n+    /**\n+     * Cache of sorted representation (unmodifiable).\n+     */\n+    private final List<Double> sortedRepresentation;\n+    \n+    /**\n+     * Base sequence [0,1,...,n-1], permuted accorting to the representation (unmodifiable).\n+     */\n+    private final List<Integer> baseSeqPermutation;\n+    \n+    /**\n+     * Constructor.\n+     * \n+     * @param representation list of [0,1] values representing the permutation\n+     */\n+    public RandomKey(List<Double> representation) {\n+        super(representation);\n+        // store the sorted representation\n+        List<Double> sortedRepr = new ArrayList<Double> (getRepresentation());\n+        Collections.sort(sortedRepr);\n+        sortedRepresentation = Collections.unmodifiableList(sortedRepr);\n+        // store the permutation of [0,1,...,n-1] list for toString() and isSame() methods\n+        baseSeqPermutation = Collections.unmodifiableList(\n+            decodeGeneric(baseSequence(getLength()), getRepresentation(), sortedRepresentation)\n+        );\n+    }\n+    \n+    /**\n+     * Constructor.\n+     * \n+     * @param representation array of [0,1] values representing the permutation\n+     */\n+    public RandomKey(Double[] representation) {\n+        this(Arrays.asList(representation));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public List<T> decode(List<T> sequence) {\n+        return decodeGeneric(sequence, getRepresentation(), sortedRepresentation);\n+    }\n+\n+    /**\n+     * Decodes a permutation represented by <code>representation</code> and\n+     * returns a (generic) list with the permuted values.\n+     * \n+     * @param <S> generic type of the sequence values\n+     * @param sequence the unpermuted sequence\n+     * @param representation representation of the permutation ([0,1] vector)\n+     * @param sortedRepr sorted <code>representation</code>\n+     * @return list with the sequence values permuted according to the representation\n+     */\n+    private static <S> List<S> decodeGeneric(List<S> sequence, List<Double> representation, List<Double> sortedRepr) {\n+        int l = sequence.size();\n+        \n+        if (representation.size() != l) {\n+            throw new IllegalArgumentException(String.format(\"Length of sequence for decoding (%s) has to be equal to the length of the RandomKey (%s)\", l, representation.size()));\n+        }\n+        if (representation.size() != sortedRepr.size()) {\n+            throw new IllegalArgumentException(String.format(\"Representation and sortedRepr must have same sizes, %d != %d\", representation.size(), sortedRepr.size()));\n+        }\n+        \n+        List<Double> reprCopy = new ArrayList<Double> (representation);// do not modify the orig. representation\n+        \n+        // now find the indices in the original repr and use them for permuting\n+        List<S> res = new ArrayList<S> (l);\n+        for (int i=0; i<l; i++) {\n+            int index = reprCopy.indexOf(sortedRepr.get(i));\n+            res.add(sequence.get(index));\n+            reprCopy.set(index, null);\n+        }\n+        return res;\n+    }\n+\n+    /**\n+     * Returns <code>true</code> iff <code>another</code> is a RandomKey and\n+     * encodes the same permutation.\n+     * \n+     * @param another chromosome to compare\n+     * @return true iff chromosomes encode the same permutation\n+     */\n+    @Override\n+    protected boolean isSame(Chromosome another) {\n+        // type check\n+        if (! (another instanceof RandomKey<?>))\n+            return false;\n+        RandomKey<?> anotherRk = (RandomKey<?>) another;\n+        // size check\n+        if (getLength() != anotherRk.getLength())\n+            return false;\n+        \n+        // two different representations can still encode the same permutation\n+        // the ordering is what counts\n+        List<Integer> thisPerm = this.baseSeqPermutation;\n+        List<Integer> anotherPerm = anotherRk.baseSeqPermutation;\n+        \n+        for (int i=0; i<getLength(); i++) {\n+            if (thisPerm.get(i) != anotherPerm.get(i))\n+                return false;\n+        }\n+        // the permutations are the same\n+        return true;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override    \n+    protected void checkValidity(java.util.List<Double> representation) throws InvalidRepresentationException {\n+        for (double val : representation) {\n+            if (val < 0 || val > 1) {\n+                throw new InvalidRepresentationException(\"Values of representation must be in [0,1] interval\");\n+            }\n+        }\n+    };\n+    \n+\n+    /**\n+     * Generates a representation corresponding to a random permutation of\n+     * length l which can be passed to the RandomKey constructor.\n+     * \n+     * @param l\n+     *            length of the permutation\n+     * @return representation of a random permutation\n+     */\n+    public static final List<Double> randomPermutation(int l) {\n+        List<Double> repr = new ArrayList<Double>(l);\n+        for (int i=0; i<l; i++) {\n+            repr.add(GeneticAlgorithm.getRandomGenerator().nextDouble());\n+        }\n+        return repr;\n+    }\n+\n+    /**\n+     * Generates a representation corresponding to an identity permutation of\n+     * length l which can be passed to the RandomKey constructor.\n+     * \n+     * @param l\n+     *            length of the permutation\n+     * @return representation of an identity permutation\n+     */\n+    public static final List<Double> identityPermutation(int l) {\n+        List<Double> repr = new ArrayList<Double>(l);\n+        for (int i=0; i<l; i++) {\n+            repr.add((double)i/l);\n+        }\n+        return repr;\n+    }\n+\n+    /**\n+     * Generates a representation of a permutation corresponding to the\n+     * <code>data</code> sorted by <code>comparator</code>. The\n+     * <code>data</code> is not modified during the process.\n+     * \n+     * This is useful if you want to inject some permutations to the initial\n+     * population.\n+     * \n+     * @param <S> type of the data\n+     * @param data list of data determining the order\n+     * @param comparator how the data will be compared\n+     * @return list representation of the permutation corresponding to the parameters\n+     */\n+    public static <S> List<Double> comparatorPermutation(List<S> data, Comparator<S> comparator) {\n+        List<S> sortedData = new ArrayList<S> (data);\n+        Collections.sort(sortedData, comparator);\n+        \n+        return inducedPermutation(data, sortedData);\n+    }\n+\n+    /**\n+     * Generates a representation of a permutation corresponding to a\n+     * permutation which yields <code>permutedData</code> when applied to\n+     * <code>originalData</code>.\n+     * \n+     * This method can be viewed as an inverse to {@link #decode(List)}.\n+     * \n+     * @param <S> type of the data\n+     * @param originalData the original, unpermuted data\n+     * @param permutedData the data, somehow permuted\n+     * @return representation of a permutation corresponding to the permutation <code>originalData -> permutedData</code>\n+     * @throws IllegalArgumentException iff the <code>permutedData</code> and <code>originalData</code> contains different data \n+     */\n+    public static <S> List<Double> inducedPermutation(List<S> originalData, List<S> permutedData) throws IllegalArgumentException {\n+        if (originalData.size() != permutedData.size()) {\n+            throw new IllegalArgumentException(\"originalData and permutedData must have same length\");\n+        }\n+        int l = originalData.size();\n+        \n+        List<S> origDataCopy = new ArrayList<S> (originalData);\n+        \n+        Double[] res = new Double[l];\n+        for (int i=0; i<l; i++) {\n+            int index = origDataCopy.indexOf(permutedData.get(i));\n+            if (index == -1) {\n+                throw new IllegalArgumentException(\"originalData and permutedData must contain the same objects.\");\n+            }\n+            res[index] = (double) i / l;\n+            origDataCopy.set(index, null);\n+        }\n+        return Arrays.asList(res);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public String toString() {\n+        return String.format(\"(f=%s pi=(%s))\", getFitness(), baseSeqPermutation);\n+    }\n+\n+    /**\n+     * Helper for constructor. Generates a list of natural numbers (0,1,...,l-1).\n+     * \n+     * @param l length of list to generate\n+     * @return list of integers from 0 to l-1\n+     */\n+    private static List<Integer> baseSequence(int l) {\n+        List<Integer> baseSequence = new ArrayList<Integer> (l);\n+        for (int i=0; i<l; i++) {\n+            baseSequence.add(i);\n+        }\n+        return baseSequence;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/RandomKeyMutation.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Mutation operator for {@link RandomKey}s. Changes a randomly chosen element\n+ * of the array representation to a random value uniformly distributed in [0,1].\n+ * \n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+public class RandomKeyMutation implements MutationPolicy {\n+\n+    /**\n+     * {@inheritDoc}\n+     * \n+     * @throws IllegalArgumentException if <code>original</code> is not a \n+     * {@link RandomKey} instance\n+     */\n+    public Chromosome mutate(Chromosome original) {\n+        if (!(original instanceof RandomKey<?>)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"RandomKeyMutation works only with RandomKeys, got \" +\n+                    original.getClass().getSimpleName());\n+        }\n+        \n+        RandomKey<?> originalRk = (RandomKey<?>) original;\n+        List<Double> repr = originalRk.getRepresentation();\n+        int rInd = GeneticAlgorithm.getRandomGenerator().nextInt(repr.size());\n+        \n+        List<Double> newRepr = new ArrayList<Double> (repr);\n+        newRepr.set(rInd, GeneticAlgorithm.getRandomGenerator().nextDouble());\n+        \n+        return originalRk.newFixedLengthChromosome(newRepr);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/SelectionPolicy.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+/**\n+ * Algorithm used to select a chromosome pair from a population.\n+ * \n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n+ */\n+public interface SelectionPolicy {\n+    /**\n+     * Select two chromosomes from the population.\n+     * @param population the population from which the chromosomes are choosen.\n+     * @return the selected chromosomes.\n+     */\n+    ChromosomePair select(Population population);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/StoppingCondition.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+/**\n+ * Algorithm used to determine when to stop evolution.\n+ * \n+ * @since 2.0\n+ * @version $Revision:$ $Date:$\n+ */\n+public interface StoppingCondition {\n+    /**\n+     * Determine whether or not the given population satisfies the stopping\n+     * condition.\n+     * \n+     * @param population the population to test.\n+     * @return <code>true</code> if this stopping condition is met by the\n+     *         given population. <code>false</code> otherwise.\n+     */\n+    boolean isSatisfied(Population population);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/genetics/TournamentSelection.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.genetics;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Tournament selection scheme. Each of the two selected chromosomes is selected\n+ * based on n-ary tournament -- this is done by drawing {@link #arity} random\n+ * chromosomes without replacement from the population, and then selecting the\n+ * fittest chromosome among them. \n+ * \n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+public class TournamentSelection implements SelectionPolicy {\n+    \n+    /** number of chromosomes included in the tournament selections */\n+    private int arity;\n+    \n+    /**\n+     * Creates a new TournamentSelection instance.\n+     * \n+     * @param arity\n+     *            how many chromosomes will be drawn to the tournament\n+     */\n+    public TournamentSelection(int arity) {\n+        this.arity = arity;\n+    }\n+\n+    /**\n+     * Select two chromosomes from the population. Each of the two selected\n+     * chromosomes is selected based on n-ary tournament -- this is done by\n+     * drawing {@link #arity} random chromosomes without replacement from the\n+     * population, and then selecting the fittest chromosome among them.\n+     * \n+     * @param population\n+     *            the population from which the chromosomes are choosen.\n+     * @return the selected chromosomes.\n+     */\n+    public ChromosomePair select(Population population) {\n+        return new ChromosomePair(\n+                tournament((ListPopulation) population),\n+                tournament((ListPopulation)population)\n+                );\n+    }\n+    \n+    /**\n+     * Helper for {@link #select(Population)}. Draw {@link #arity} random\n+     * chromosomes without replacement from the population, and then select the\n+     * fittest chromosome among them.\n+     * \n+     * @param population\n+     *            the population from which the chromosomes are choosen.\n+     * @return the selected chromosome.\n+     */\n+    private Chromosome tournament(ListPopulation population) {\n+        if (population.getPopulationSize() < this.arity)\n+            throw new IllegalArgumentException(\"Tournament arity cannot be bigger than population size.\");\n+        // auxiliary population\n+        ListPopulation tournamentPopulation = new ListPopulation(this.arity) {\n+            public Population nextGeneration() {\n+                // not useful here\n+                return null;\n+            }\n+        };\n+        \n+        // create a copy of the chromosome list\n+        List<Chromosome> chromosomes = new ArrayList<Chromosome> (population.getChromosomes());\n+        for (int i=0; i<this.arity; i++) {\n+            // select a random individual and add it to the tournament\n+            int rind = GeneticAlgorithm.getRandomGenerator().nextInt(chromosomes.size());\n+            tournamentPopulation.addChromosome(chromosomes.get(rind));\n+            // do not select it again\n+            chromosomes.remove(rind);\n+        }\n+        // the winner takes it all\n+        return tournamentPopulation.getFittestChromosome();\n+    }\n+\n+    /**\n+     * Gets the arity (number of chromosomes drawn to the tournament).\n+     * \n+     * @return arity of the tournament\n+     */\n+    public int getArity() {\n+        return arity;\n+    }\n+\n+    /**\n+     * Sets the arity (number of chromosomes drawn to the tournament).\n+     * \n+     * @param arity arity of the tournament\n+     */\n+    public void setArity(int arity) {\n+        this.arity = arity;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/CardanEulerSingularityException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import org.apache.commons.math.MathException;\n+\n+/** This class represents exceptions thrown while extractiong Cardan\n+ * or Euler angles from a rotation.\n+\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class CardanEulerSingularityException\n+  extends MathException {\n+\n+  /** \n+   * Simple constructor.\n+   * build an exception with a default message.\n+   * @param isCardan if true, the rotation is related to Cardan angles,\n+   * if false it is related to EulerAngles\n+   */\n+  public CardanEulerSingularityException(boolean isCardan) {\n+    super(isCardan ? \"Cardan angles singularity\" : \"Euler angles singularity\");\n+  }\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -1360952845582206770L;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/NotARotationMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import org.apache.commons.math.MathException;\n+\n+/** \n+ * This class represents exceptions thrown while building rotations\n+ * from matrices.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class NotARotationMatrixException\n+  extends MathException {\n+\n+  /** \n+   * Simple constructor.\n+   * Build an exception by translating and formating a message\n+   * @param specifier format specifier (to be translated)\n+   * @param parts to insert in the format (no translation)\n+   */\n+  public NotARotationMatrixException(String specifier, Object ... parts) {\n+    super(specifier, parts);\n+  }\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = 5647178478658937642L;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/Rotation.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * This class implements rotations in a three-dimensional space.\n+ *\n+ * <p>Rotations can be represented by several different mathematical\n+ * entities (matrices, axe and angle, Cardan or Euler angles,\n+ * quaternions). This class presents an higher level abstraction, more\n+ * user-oriented and hiding this implementation details. Well, for the\n+ * curious, we use quaternions for the internal representation. The\n+ * user can build a rotation from any of these representations, and\n+ * any of these representations can be retrieved from a\n+ * <code>Rotation</code> instance (see the various constructors and\n+ * getters). In addition, a rotation can also be built implicitely\n+ * from a set of vectors and their image.</p>\n+ * <p>This implies that this class can be used to convert from one\n+ * representation to another one. For example, converting a rotation\n+ * matrix into a set of Cardan angles from can be done using the\n+ * followong single line of code:</p>\n+ * <pre>\n+ * double[] angles = new Rotation(matrix, 1.0e-10).getAngles(RotationOrder.XYZ);\n+ * </pre>\n+ * <p>Focus is oriented on what a rotation <em>do</em> rather than on its\n+ * underlying representation. Once it has been built, and regardless of its\n+ * internal representation, a rotation is an <em>operator</em> which basically\n+ * transforms three dimensional {@link Vector3D vectors} into other three\n+ * dimensional {@link Vector3D vectors}. Depending on the application, the\n+ * meaning of these vectors may vary and the semantics of the rotation also.</p>\n+ * <p>For example in an spacecraft attitude simulation tool, users will often\n+ * consider the vectors are fixed (say the Earth direction for example) and the\n+ * rotation transforms the coordinates coordinates of this vector in inertial\n+ * frame into the coordinates of the same vector in satellite frame. In this\n+ * case, the rotation implicitely defines the relation between the two frames.\n+ * Another example could be a telescope control application, where the rotation\n+ * would transform the sighting direction at rest into the desired observing\n+ * direction when the telescope is pointed towards an object of interest. In this\n+ * case the rotation transforms the directionf at rest in a topocentric frame\n+ * into the sighting direction in the same topocentric frame. In many case, both\n+ * approaches will be combined, in our telescope example, we will probably also\n+ * need to transform the observing direction in the topocentric frame into the\n+ * observing direction in inertial frame taking into account the observatory\n+ * location and the Earth rotation.</p>\n+ *\n+ * <p>These examples show that a rotation is what the user wants it to be, so this\n+ * class does not push the user towards one specific definition and hence does not\n+ * provide methods like <code>projectVectorIntoDestinationFrame</code> or\n+ * <code>computeTransformedDirection</code>. It provides simpler and more generic\n+ * methods: {@link #applyTo(Vector3D) applyTo(Vector3D)} and {@link\n+ * #applyInverseTo(Vector3D) applyInverseTo(Vector3D)}.</p>\n+ *\n+ * <p>Since a rotation is basically a vectorial operator, several rotations can be\n+ * composed together and the composite operation <code>r = r<sub>1</sub> o\n+ * r<sub>2</sub></code> (which means that for each vector <code>u</code>,\n+ * <code>r(u) = r<sub>1</sub>(r<sub>2</sub>(u))</code>) is also a rotation. Hence\n+ * we can consider that in addition to vectors, a rotation can be applied to other\n+ * rotations as well (or to itself). With our previous notations, we would say we\n+ * can apply <code>r<sub>1</sub></code> to <code>r<sub>2</sub></code> and the result\n+ * we get is <code>r = r<sub>1</sub> o r<sub>2</sub></code>. For this purpose, the\n+ * class provides the methods: {@link #applyTo(Rotation) applyTo(Rotation)} and\n+ * {@link #applyInverseTo(Rotation) applyInverseTo(Rotation)}.</p>\n+ *\n+ * <p>Rotations are guaranteed to be immutable objects.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @see Vector3D\n+ * @see RotationOrder\n+ * @since 1.2\n+ */\n+\n+public class Rotation implements Serializable {\n+\n+  /** Identity rotation. */\n+  public static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false);\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -2153622329907944313L;\n+\n+  /** Scalar coordinate of the quaternion. */\n+  private final double q0;\n+\n+  /** First coordinate of the vectorial part of the quaternion. */\n+  private final double q1;\n+\n+  /** Second coordinate of the vectorial part of the quaternion. */\n+  private final double q2;\n+\n+  /** Third coordinate of the vectorial part of the quaternion. */\n+  private final double q3;\n+\n+  /** Build a rotation from the quaternion coordinates.\n+   * <p>A rotation can be built from a <em>normalized</em> quaternion,\n+   * i.e. a quaternion for which q<sub>0</sub><sup>2</sup> +\n+   * q<sub>1</sub><sup>2</sup> + q<sub>2</sub><sup>2</sup> +\n+   * q<sub>3</sub><sup>2</sup> = 1. If the quaternion is not normalized,\n+   * the constructor can normalize it in a preprocessing step.</p>\n+   * @param q0 scalar part of the quaternion\n+   * @param q1 first coordinate of the vectorial part of the quaternion\n+   * @param q2 second coordinate of the vectorial part of the quaternion\n+   * @param q3 third coordinate of the vectorial part of the quaternion\n+   * @param needsNormalization if true, the coordinates are considered\n+   * not to be normalized, a normalization preprocessing step is performed\n+   * before using them\n+   */\n+  public Rotation(double q0, double q1, double q2, double q3,\n+                  boolean needsNormalization) {\n+\n+    if (needsNormalization) {\n+      // normalization preprocessing\n+      double inv = 1.0 / Math.sqrt(q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3);\n+      q0 *= inv;\n+      q1 *= inv;\n+      q2 *= inv;\n+      q3 *= inv;\n+    }\n+\n+    this.q0 = q0;\n+    this.q1 = q1;\n+    this.q2 = q2;\n+    this.q3 = q3;\n+\n+  }\n+\n+  /** Build a rotation from an axis and an angle.\n+   * <p>We use the convention that angles are oriented according to\n+   * the effect of the rotation on vectors around the axis. That means\n+   * that if (i, j, k) is a direct frame and if we first provide +k as\n+   * the axis and PI/2 as the angle to this constructor, and then\n+   * {@link #applyTo(Vector3D) apply} the instance to +i, we will get\n+   * +j.</p>\n+   * @param axis axis around which to rotate\n+   * @param angle rotation angle.\n+   * @exception ArithmeticException if the axis norm is zero\n+   */\n+  public Rotation(Vector3D axis, double angle) {\n+\n+    double norm = axis.getNorm();\n+    if (norm == 0) {\n+      throw MathRuntimeException.createArithmeticException(\"zero norm for rotation axis\");\n+    }\n+\n+    double halfAngle = -0.5 * angle;\n+    double coeff = Math.sin(halfAngle) / norm;\n+\n+    q0 = Math.cos (halfAngle);\n+    q1 = coeff * axis.getX();\n+    q2 = coeff * axis.getY();\n+    q3 = coeff * axis.getZ();\n+\n+  }\n+\n+  /** Build a rotation from a 3X3 matrix.\n+\n+   * <p>Rotation matrices are orthogonal matrices, i.e. unit matrices\n+   * (which are matrices for which m.m<sup>T</sup> = I) with real\n+   * coefficients. The module of the determinant of unit matrices is\n+   * 1, among the orthogonal 3X3 matrices, only the ones having a\n+   * positive determinant (+1) are rotation matrices.</p>\n+\n+   * <p>When a rotation is defined by a matrix with truncated values\n+   * (typically when it is extracted from a technical sheet where only\n+   * four to five significant digits are available), the matrix is not\n+   * orthogonal anymore. This constructor handles this case\n+   * transparently by using a copy of the given matrix and applying a\n+   * correction to the copy in order to perfect its orthogonality. If\n+   * the Frobenius norm of the correction needed is above the given\n+   * threshold, then the matrix is considered to be too far from a\n+   * true rotation matrix and an exception is thrown.<p>\n+\n+   * @param m rotation matrix\n+   * @param threshold convergence threshold for the iterative\n+   * orthogonality correction (convergence is reached when the\n+   * difference between two steps of the Frobenius norm of the\n+   * correction is below this threshold)\n+\n+   * @exception NotARotationMatrixException if the matrix is not a 3X3\n+   * matrix, or if it cannot be transformed into an orthogonal matrix\n+   * with the given threshold, or if the determinant of the resulting\n+   * orthogonal matrix is negative\n+\n+   */\n+  public Rotation(double[][] m, double threshold)\n+    throws NotARotationMatrixException {\n+\n+    // dimension check\n+    if ((m.length != 3) || (m[0].length != 3) ||\n+        (m[1].length != 3) || (m[2].length != 3)) {\n+      throw new NotARotationMatrixException(\n+              \"a {0}x{1} matrix cannot be a rotation matrix\",\n+              m.length, m[0].length);\n+    }\n+\n+    // compute a \"close\" orthogonal matrix\n+    double[][] ort = orthogonalizeMatrix(m, threshold);\n+\n+    // check the sign of the determinant\n+    double det = ort[0][0] * (ort[1][1] * ort[2][2] - ort[2][1] * ort[1][2]) -\n+                 ort[1][0] * (ort[0][1] * ort[2][2] - ort[2][1] * ort[0][2]) +\n+                 ort[2][0] * (ort[0][1] * ort[1][2] - ort[1][1] * ort[0][2]);\n+    if (det < 0.0) {\n+      throw new NotARotationMatrixException(\n+              \"the closest orthogonal matrix has a negative determinant {0}\",\n+              det);\n+    }\n+\n+    // There are different ways to compute the quaternions elements\n+    // from the matrix. They all involve computing one element from\n+    // the diagonal of the matrix, and computing the three other ones\n+    // using a formula involving a division by the first element,\n+    // which unfortunately can be zero. Since the norm of the\n+    // quaternion is 1, we know at least one element has an absolute\n+    // value greater or equal to 0.5, so it is always possible to\n+    // select the right formula and avoid division by zero and even\n+    // numerical inaccuracy. Checking the elements in turn and using\n+    // the first one greater than 0.45 is safe (this leads to a simple\n+    // test since qi = 0.45 implies 4 qi^2 - 1 = -0.19)\n+    double s = ort[0][0] + ort[1][1] + ort[2][2];\n+    if (s > -0.19) {\n+      // compute q0 and deduce q1, q2 and q3\n+      q0 = 0.5 * Math.sqrt(s + 1.0);\n+      double inv = 0.25 / q0;\n+      q1 = inv * (ort[1][2] - ort[2][1]);\n+      q2 = inv * (ort[2][0] - ort[0][2]);\n+      q3 = inv * (ort[0][1] - ort[1][0]);\n+    } else {\n+      s = ort[0][0] - ort[1][1] - ort[2][2];\n+      if (s > -0.19) {\n+        // compute q1 and deduce q0, q2 and q3\n+        q1 = 0.5 * Math.sqrt(s + 1.0);\n+        double inv = 0.25 / q1;\n+        q0 = inv * (ort[1][2] - ort[2][1]);\n+        q2 = inv * (ort[0][1] + ort[1][0]);\n+        q3 = inv * (ort[0][2] + ort[2][0]);\n+      } else {\n+        s = ort[1][1] - ort[0][0] - ort[2][2];\n+        if (s > -0.19) {\n+          // compute q2 and deduce q0, q1 and q3\n+          q2 = 0.5 * Math.sqrt(s + 1.0);\n+          double inv = 0.25 / q2;\n+          q0 = inv * (ort[2][0] - ort[0][2]);\n+          q1 = inv * (ort[0][1] + ort[1][0]);\n+          q3 = inv * (ort[2][1] + ort[1][2]);\n+        } else {\n+          // compute q3 and deduce q0, q1 and q2\n+          s = ort[2][2] - ort[0][0] - ort[1][1];\n+          q3 = 0.5 * Math.sqrt(s + 1.0);\n+          double inv = 0.25 / q3;\n+          q0 = inv * (ort[0][1] - ort[1][0]);\n+          q1 = inv * (ort[0][2] + ort[2][0]);\n+          q2 = inv * (ort[2][1] + ort[1][2]);\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  /** Build the rotation that transforms a pair of vector into another pair.\n+\n+   * <p>Except for possible scale factors, if the instance were applied to\n+   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n+   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n+\n+   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n+   * not the same as the angular separation between v<sub>1</sub> and\n+   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n+   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n+   * v<sub>2</sub>) plane.</p>\n+\n+   * @param u1 first vector of the origin pair\n+   * @param u2 second vector of the origin pair\n+   * @param v1 desired image of u1 by the rotation\n+   * @param v2 desired image of u2 by the rotation\n+   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n+   */\n+  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n+\n+  // norms computation\n+  double u1u1 = Vector3D.dotProduct(u1, u1);\n+  double u2u2 = Vector3D.dotProduct(u2, u2);\n+  double v1v1 = Vector3D.dotProduct(v1, v1);\n+  double v2v2 = Vector3D.dotProduct(v2, v2);\n+  if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n+    throw MathRuntimeException.createIllegalArgumentException(\"zero norm for rotation defining vector\");\n+  }\n+\n+  double u1x = u1.getX();\n+  double u1y = u1.getY();\n+  double u1z = u1.getZ();\n+\n+  double u2x = u2.getX();\n+  double u2y = u2.getY();\n+  double u2z = u2.getZ();\n+\n+  // normalize v1 in order to have (v1'|v1') = (u1|u1)\n+  double coeff = Math.sqrt (u1u1 / v1v1);\n+  double v1x   = coeff * v1.getX();\n+  double v1y   = coeff * v1.getY();\n+  double v1z   = coeff * v1.getZ();\n+  v1 = new Vector3D(v1x, v1y, v1z);\n+\n+  // adjust v2 in order to have (u1|u2) = (v1|v2) and (v2'|v2') = (u2|u2)\n+  double u1u2   = Vector3D.dotProduct(u1, u2);\n+  double v1v2   = Vector3D.dotProduct(v1, v2);\n+  double coeffU = u1u2 / u1u1;\n+  double coeffV = v1v2 / u1u1;\n+  double beta   = Math.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\n+  double alpha  = coeffU - beta * coeffV;\n+  double v2x    = alpha * v1x + beta * v2.getX();\n+  double v2y    = alpha * v1y + beta * v2.getY();\n+  double v2z    = alpha * v1z + beta * v2.getZ();\n+  v2 = new Vector3D(v2x, v2y, v2z);\n+\n+  // preliminary computation (we use explicit formulation instead\n+  // of relying on the Vector3D class in order to avoid building lots\n+  // of temporary objects)\n+  Vector3D uRef = u1;\n+  Vector3D vRef = v1;\n+  double dx1 = v1x - u1.getX();\n+  double dy1 = v1y - u1.getY();\n+  double dz1 = v1z - u1.getZ();\n+  double dx2 = v2x - u2.getX();\n+  double dy2 = v2y - u2.getY();\n+  double dz2 = v2z - u2.getZ();\n+  Vector3D k = new Vector3D(dy1 * dz2 - dz1 * dy2,\n+                            dz1 * dx2 - dx1 * dz2,\n+                            dx1 * dy2 - dy1 * dx2);\n+  double c = k.getX() * (u1y * u2z - u1z * u2y) +\n+             k.getY() * (u1z * u2x - u1x * u2z) +\n+             k.getZ() * (u1x * u2y - u1y * u2x);\n+\n+  if (c == 0) {\n+    // the (q1, q2, q3) vector is in the (u1, u2) plane\n+    // we try other vectors\n+    Vector3D u3 = Vector3D.crossProduct(u1, u2);\n+    Vector3D v3 = Vector3D.crossProduct(v1, v2);\n+    double u3x  = u3.getX();\n+    double u3y  = u3.getY();\n+    double u3z  = u3.getZ();\n+    double v3x  = v3.getX();\n+    double v3y  = v3.getY();\n+    double v3z  = v3.getZ();\n+\n+    double dx3 = v3x - u3x;\n+    double dy3 = v3y - u3y;\n+    double dz3 = v3z - u3z;\n+    k = new Vector3D(dy1 * dz3 - dz1 * dy3,\n+                     dz1 * dx3 - dx1 * dz3,\n+                     dx1 * dy3 - dy1 * dx3);\n+    c = k.getX() * (u1y * u3z - u1z * u3y) +\n+        k.getY() * (u1z * u3x - u1x * u3z) +\n+        k.getZ() * (u1x * u3y - u1y * u3x);\n+\n+    if (c == 0) {\n+      // the (q1, q2, q3) vector is aligned with u1:\n+      // we try (u2, u3) and (v2, v3)\n+      k = new Vector3D(dy2 * dz3 - dz2 * dy3,\n+                       dz2 * dx3 - dx2 * dz3,\n+                       dx2 * dy3 - dy2 * dx3);\n+      c = k.getX() * (u2y * u3z - u2z * u3y) +\n+          k.getY() * (u2z * u3x - u2x * u3z) +\n+          k.getZ() * (u2x * u3y - u2y * u3x);\n+\n+      if (c == 0) {\n+        // the (q1, q2, q3) vector is aligned with everything\n+        // this is really the identity rotation\n+        q0 = 1.0;\n+        q1 = 0.0;\n+        q2 = 0.0;\n+        q3 = 0.0;\n+        return;\n+      }\n+\n+      // we will have to use u2 and v2 to compute the scalar part\n+      uRef = u2;\n+      vRef = v2;\n+\n+    }\n+\n+  }\n+\n+  // compute the vectorial part\n+  c = Math.sqrt(c);\n+  double inv = 1.0 / (c + c);\n+  q1 = inv * k.getX();\n+  q2 = inv * k.getY();\n+  q3 = inv * k.getZ();\n+\n+  // compute the scalar part\n+   k = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\n+                    uRef.getZ() * q1 - uRef.getX() * q3,\n+                    uRef.getX() * q2 - uRef.getY() * q1);\n+   c = Vector3D.dotProduct(k, k);\n+  q0 = Vector3D.dotProduct(vRef, k) / (c + c);\n+\n+  }\n+\n+  /** Build one of the rotations that transform one vector into another one.\n+\n+   * <p>Except for a possible scale factor, if the instance were\n+   * applied to the vector u it will produce the vector v. There is an\n+   * infinite number of such rotations, this constructor choose the\n+   * one with the smallest associated angle (i.e. the one whose axis\n+   * is orthogonal to the (u, v) plane). If u and v are colinear, an\n+   * arbitrary rotation axis is chosen.</p>\n+\n+   * @param u origin vector\n+   * @param v desired image of u by the rotation\n+   * @exception IllegalArgumentException if the norm of one of the vectors is zero\n+   */\n+  public Rotation(Vector3D u, Vector3D v) {\n+\n+    double normProduct = u.getNorm() * v.getNorm();\n+    if (normProduct == 0) {\n+        throw MathRuntimeException.createIllegalArgumentException(\"zero norm for rotation defining vector\");\n+    }\n+\n+    double dot = Vector3D.dotProduct(u, v);\n+\n+    if (dot < ((2.0e-15 - 1.0) * normProduct)) {\n+      // special case u = -v: we select a PI angle rotation around\n+      // an arbitrary vector orthogonal to u\n+      Vector3D w = u.orthogonal();\n+      q0 = 0.0;\n+      q1 = -w.getX();\n+      q2 = -w.getY();\n+      q3 = -w.getZ();\n+    } else {\n+      // general case: (u, v) defines a plane, we select\n+      // the shortest possible rotation: axis orthogonal to this plane\n+      q0 = Math.sqrt(0.5 * (1.0 + dot / normProduct));\n+      double coeff = 1.0 / (2.0 * q0 * normProduct);\n+      q1 = coeff * (v.getY() * u.getZ() - v.getZ() * u.getY());\n+      q2 = coeff * (v.getZ() * u.getX() - v.getX() * u.getZ());\n+      q3 = coeff * (v.getX() * u.getY() - v.getY() * u.getX());\n+    }\n+\n+  }\n+\n+  /** Build a rotation from three Cardan or Euler elementary rotations.\n+\n+   * <p>Cardan rotations are three successive rotations around the\n+   * canonical axes X, Y and Z, each axis being used once. There are\n+   * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n+   * rotations are three successive rotations around the canonical\n+   * axes X, Y and Z, the first and last rotations being around the\n+   * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n+   * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n+   * <p>Beware that many people routinely use the term Euler angles even\n+   * for what really are Cardan angles (this confusion is especially\n+   * widespread in the aerospace business where Roll, Pitch and Yaw angles\n+   * are often wrongly tagged as Euler angles).</p>\n+\n+   * @param order order of rotations to use\n+   * @param alpha1 angle of the first elementary rotation\n+   * @param alpha2 angle of the second elementary rotation\n+   * @param alpha3 angle of the third elementary rotation\n+   */\n+  public Rotation(RotationOrder order,\n+                  double alpha1, double alpha2, double alpha3) {\n+    Rotation r1 = new Rotation(order.getA1(), alpha1);\n+    Rotation r2 = new Rotation(order.getA2(), alpha2);\n+    Rotation r3 = new Rotation(order.getA3(), alpha3);\n+    Rotation composed = r1.applyTo(r2.applyTo(r3));\n+    q0 = composed.q0;\n+    q1 = composed.q1;\n+    q2 = composed.q2;\n+    q3 = composed.q3;\n+  }\n+\n+  /** Revert a rotation.\n+   * Build a rotation which reverse the effect of another\n+   * rotation. This means that if r(u) = v, then r.revert(v) = u. The\n+   * instance is not changed.\n+   * @return a new rotation whose effect is the reverse of the effect\n+   * of the instance\n+   */\n+  public Rotation revert() {\n+    return new Rotation(-q0, q1, q2, q3, false);\n+  }\n+\n+  /** Get the scalar coordinate of the quaternion.\n+   * @return scalar coordinate of the quaternion\n+   */\n+  public double getQ0() {\n+    return q0;\n+  }\n+\n+  /** Get the first coordinate of the vectorial part of the quaternion.\n+   * @return first coordinate of the vectorial part of the quaternion\n+   */\n+  public double getQ1() {\n+    return q1;\n+  }\n+\n+  /** Get the second coordinate of the vectorial part of the quaternion.\n+   * @return second coordinate of the vectorial part of the quaternion\n+   */\n+  public double getQ2() {\n+    return q2;\n+  }\n+\n+  /** Get the third coordinate of the vectorial part of the quaternion.\n+   * @return third coordinate of the vectorial part of the quaternion\n+   */\n+  public double getQ3() {\n+    return q3;\n+  }\n+\n+  /** Get the normalized axis of the rotation.\n+   * @return normalized axis of the rotation\n+   */\n+  public Vector3D getAxis() {\n+    double squaredSine = q1 * q1 + q2 * q2 + q3 * q3;\n+    if (squaredSine == 0) {\n+      return new Vector3D(1, 0, 0);\n+    } else if (q0 < 0) {\n+      double inverse = 1 / Math.sqrt(squaredSine);\n+      return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n+    }\n+    double inverse = -1 / Math.sqrt(squaredSine);\n+    return new Vector3D(q1 * inverse, q2 * inverse, q3 * inverse);\n+  }\n+\n+  /** Get the angle of the rotation.\n+   * @return angle of the rotation (between 0 and &pi;)\n+   */\n+  public double getAngle() {\n+    if ((q0 < -0.1) || (q0 > 0.1)) {\n+      return 2 * Math.asin(Math.sqrt(q1 * q1 + q2 * q2 + q3 * q3));\n+    } else if (q0 < 0) {\n+      return 2 * Math.acos(-q0);\n+    }\n+    return 2 * Math.acos(q0);\n+  }\n+\n+  /** Get the Cardan or Euler angles corresponding to the instance.\n+\n+   * <p>The equations show that each rotation can be defined by two\n+   * different values of the Cardan or Euler angles set. For example\n+   * if Cardan angles are used, the rotation defined by the angles\n+   * a<sub>1</sub>, a<sub>2</sub> and a<sub>3</sub> is the same as\n+   * the rotation defined by the angles &pi; + a<sub>1</sub>, &pi;\n+   * - a<sub>2</sub> and &pi; + a<sub>3</sub>. This method implements\n+   * the following arbitrary choices:</p>\n+   * <ul>\n+   *   <li>for Cardan angles, the chosen set is the one for which the\n+   *   second angle is between -&pi;/2 and &pi;/2 (i.e its cosine is\n+   *   positive),</li>\n+   *   <li>for Euler angles, the chosen set is the one for which the\n+   *   second angle is between 0 and &pi; (i.e its sine is positive).</li>\n+   * </ul>\n+\n+   * <p>Cardan and Euler angle have a very disappointing drawback: all\n+   * of them have singularities. This means that if the instance is\n+   * too close to the singularities corresponding to the given\n+   * rotation order, it will be impossible to retrieve the angles. For\n+   * Cardan angles, this is often called gimbal lock. There is\n+   * <em>nothing</em> to do to prevent this, it is an intrinsic problem\n+   * with Cardan and Euler representation (but not a problem with the\n+   * rotation itself, which is perfectly well defined). For Cardan\n+   * angles, singularities occur when the second angle is close to\n+   * -&pi;/2 or +&pi;/2, for Euler angle singularities occur when the\n+   * second angle is close to 0 or &pi;, this implies that the identity\n+   * rotation is always singular for Euler angles!</p>\n+\n+   * @param order rotation order to use\n+   * @return an array of three angles, in the order specified by the set\n+   * @exception CardanEulerSingularityException if the rotation is\n+   * singular with respect to the angles set specified\n+   */\n+  public double[] getAngles(RotationOrder order)\n+    throws CardanEulerSingularityException {\n+\n+    if (order == RotationOrder.XYZ) {\n+\n+      // r (Vector3D.plusK) coordinates are :\n+      //  sin (theta), -cos (theta) sin (phi), cos (theta) cos (phi)\n+      // (-r) (Vector3D.plusI) coordinates are :\n+      // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n+      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n+      if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      return new double[] {\n+        Math.atan2(-(v1.getY()), v1.getZ()),\n+        Math.asin(v2.getZ()),\n+        Math.atan2(-(v2.getY()), v2.getX())\n+      };\n+\n+    } else if (order == RotationOrder.XZY) {\n+\n+      // r (Vector3D.plusJ) coordinates are :\n+      // -sin (psi), cos (psi) cos (phi), cos (psi) sin (phi)\n+      // (-r) (Vector3D.plusI) coordinates are :\n+      // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n+      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n+      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      return new double[] {\n+        Math.atan2(v1.getZ(), v1.getY()),\n+       -Math.asin(v2.getY()),\n+        Math.atan2(v2.getZ(), v2.getX())\n+      };\n+\n+    } else if (order == RotationOrder.YXZ) {\n+\n+      // r (Vector3D.plusK) coordinates are :\n+      //  cos (phi) sin (theta), -sin (phi), cos (phi) cos (theta)\n+      // (-r) (Vector3D.plusJ) coordinates are :\n+      // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n+      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n+      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      return new double[] {\n+        Math.atan2(v1.getX(), v1.getZ()),\n+       -Math.asin(v2.getZ()),\n+        Math.atan2(v2.getX(), v2.getY())\n+      };\n+\n+    } else if (order == RotationOrder.YZX) {\n+\n+      // r (Vector3D.plusI) coordinates are :\n+      // cos (psi) cos (theta), sin (psi), -cos (psi) sin (theta)\n+      // (-r) (Vector3D.plusJ) coordinates are :\n+      // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n+      // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n+      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      return new double[] {\n+        Math.atan2(-(v1.getZ()), v1.getX()),\n+        Math.asin(v2.getX()),\n+        Math.atan2(-(v2.getZ()), v2.getY())\n+      };\n+\n+    } else if (order == RotationOrder.ZXY) {\n+\n+      // r (Vector3D.plusJ) coordinates are :\n+      // -cos (phi) sin (psi), cos (phi) cos (psi), sin (phi)\n+      // (-r) (Vector3D.plusK) coordinates are :\n+      // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n+      // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n+      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      return new double[] {\n+        Math.atan2(-(v1.getX()), v1.getY()),\n+        Math.asin(v2.getY()),\n+        Math.atan2(-(v2.getX()), v2.getZ())\n+      };\n+\n+    } else if (order == RotationOrder.ZYX) {\n+\n+      // r (Vector3D.plusI) coordinates are :\n+      //  cos (theta) cos (psi), cos (theta) sin (psi), -sin (theta)\n+      // (-r) (Vector3D.plusK) coordinates are :\n+      // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n+      // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n+      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(true);\n+      }\n+      return new double[] {\n+        Math.atan2(v1.getY(), v1.getX()),\n+       -Math.asin(v2.getX()),\n+        Math.atan2(v2.getY(), v2.getZ())\n+      };\n+\n+    } else if (order == RotationOrder.XYX) {\n+\n+      // r (Vector3D.plusI) coordinates are :\n+      //  cos (theta), sin (phi1) sin (theta), -cos (phi1) sin (theta)\n+      // (-r) (Vector3D.plusI) coordinates are :\n+      // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n+      // and we can choose to have theta in the interval [0 ; PI]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n+      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      return new double[] {\n+        Math.atan2(v1.getY(), -v1.getZ()),\n+        Math.acos(v2.getX()),\n+        Math.atan2(v2.getY(), v2.getZ())\n+      };\n+\n+    } else if (order == RotationOrder.XZX) {\n+\n+      // r (Vector3D.plusI) coordinates are :\n+      //  cos (psi), cos (phi1) sin (psi), sin (phi1) sin (psi)\n+      // (-r) (Vector3D.plusI) coordinates are :\n+      // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n+      // and we can choose to have psi in the interval [0 ; PI]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n+      if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      return new double[] {\n+        Math.atan2(v1.getZ(), v1.getY()),\n+        Math.acos(v2.getX()),\n+        Math.atan2(v2.getZ(), -v2.getY())\n+      };\n+\n+    } else if (order == RotationOrder.YXY) {\n+\n+      // r (Vector3D.plusJ) coordinates are :\n+      //  sin (theta1) sin (phi), cos (phi), cos (theta1) sin (phi)\n+      // (-r) (Vector3D.plusJ) coordinates are :\n+      // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n+      // and we can choose to have phi in the interval [0 ; PI]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n+      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      return new double[] {\n+        Math.atan2(v1.getX(), v1.getZ()),\n+        Math.acos(v2.getY()),\n+        Math.atan2(v2.getX(), -v2.getZ())\n+      };\n+\n+    } else if (order == RotationOrder.YZY) {\n+\n+      // r (Vector3D.plusJ) coordinates are :\n+      //  -cos (theta1) sin (psi), cos (psi), sin (theta1) sin (psi)\n+      // (-r) (Vector3D.plusJ) coordinates are :\n+      // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n+      // and we can choose to have psi in the interval [0 ; PI]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n+      if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      return new double[] {\n+        Math.atan2(v1.getZ(), -v1.getX()),\n+        Math.acos(v2.getY()),\n+        Math.atan2(v2.getZ(), v2.getX())\n+      };\n+\n+    } else if (order == RotationOrder.ZXZ) {\n+\n+      // r (Vector3D.plusK) coordinates are :\n+      //  sin (psi1) sin (phi), -cos (psi1) sin (phi), cos (phi)\n+      // (-r) (Vector3D.plusK) coordinates are :\n+      // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n+      // and we can choose to have phi in the interval [0 ; PI]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n+      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      return new double[] {\n+        Math.atan2(v1.getX(), -v1.getY()),\n+        Math.acos(v2.getZ()),\n+        Math.atan2(v2.getX(), v2.getY())\n+      };\n+\n+    } else { // last possibility is ZYZ\n+\n+      // r (Vector3D.plusK) coordinates are :\n+      //  cos (psi1) sin (theta), sin (psi1) sin (theta), cos (theta)\n+      // (-r) (Vector3D.plusK) coordinates are :\n+      // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n+      // and we can choose to have theta in the interval [0 ; PI]\n+      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n+      if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n+        throw new CardanEulerSingularityException(false);\n+      }\n+      return new double[] {\n+        Math.atan2(v1.getY(), v1.getX()),\n+        Math.acos(v2.getZ()),\n+        Math.atan2(v2.getY(), -v2.getX())\n+      };\n+\n+    }\n+\n+  }\n+\n+  /** Get the 3X3 matrix corresponding to the instance\n+   * @return the matrix corresponding to the instance\n+   */\n+  public double[][] getMatrix() {\n+\n+    // products\n+    double q0q0  = q0 * q0;\n+    double q0q1  = q0 * q1;\n+    double q0q2  = q0 * q2;\n+    double q0q3  = q0 * q3;\n+    double q1q1  = q1 * q1;\n+    double q1q2  = q1 * q2;\n+    double q1q3  = q1 * q3;\n+    double q2q2  = q2 * q2;\n+    double q2q3  = q2 * q3;\n+    double q3q3  = q3 * q3;\n+\n+    // create the matrix\n+    double[][] m = new double[3][];\n+    m[0] = new double[3];\n+    m[1] = new double[3];\n+    m[2] = new double[3];\n+\n+    m [0][0] = 2.0 * (q0q0 + q1q1) - 1.0;\n+    m [1][0] = 2.0 * (q1q2 - q0q3);\n+    m [2][0] = 2.0 * (q1q3 + q0q2);\n+\n+    m [0][1] = 2.0 * (q1q2 + q0q3);\n+    m [1][1] = 2.0 * (q0q0 + q2q2) - 1.0;\n+    m [2][1] = 2.0 * (q2q3 - q0q1);\n+\n+    m [0][2] = 2.0 * (q1q3 - q0q2);\n+    m [1][2] = 2.0 * (q2q3 + q0q1);\n+    m [2][2] = 2.0 * (q0q0 + q3q3) - 1.0;\n+\n+    return m;\n+\n+  }\n+\n+  /** Apply the rotation to a vector.\n+   * @param u vector to apply the rotation to\n+   * @return a new vector which is the image of u by the rotation\n+   */\n+  public Vector3D applyTo(Vector3D u) {\n+\n+    double x = u.getX();\n+    double y = u.getY();\n+    double z = u.getZ();\n+\n+    double s = q1 * x + q2 * y + q3 * z;\n+\n+    return new Vector3D(2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x,\n+                        2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y,\n+                        2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z);\n+\n+  }\n+\n+  /** Apply the inverse of the rotation to a vector.\n+   * @param u vector to apply the inverse of the rotation to\n+   * @return a new vector which such that u is its image by the rotation\n+   */\n+  public Vector3D applyInverseTo(Vector3D u) {\n+\n+    double x = u.getX();\n+    double y = u.getY();\n+    double z = u.getZ();\n+\n+    double s = q1 * x + q2 * y + q3 * z;\n+    double m0 = -q0;\n+\n+    return new Vector3D(2 * (m0 * (x * m0 - (q2 * z - q3 * y)) + s * q1) - x,\n+                        2 * (m0 * (y * m0 - (q3 * x - q1 * z)) + s * q2) - y,\n+                        2 * (m0 * (z * m0 - (q1 * y - q2 * x)) + s * q3) - z);\n+\n+  }\n+\n+  /** Apply the instance to another rotation.\n+   * Applying the instance to a rotation is computing the composition\n+   * in an order compliant with the following rule : let u be any\n+   * vector and v its image by r (i.e. r.applyTo(u) = v), let w be the image\n+   * of v by the instance (i.e. applyTo(v) = w), then w = comp.applyTo(u),\n+   * where comp = applyTo(r).\n+   * @param r rotation to apply the rotation to\n+   * @return a new rotation which is the composition of r by the instance\n+   */\n+  public Rotation applyTo(Rotation r) {\n+    return new Rotation(r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),\n+                        r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),\n+                        r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),\n+                        r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),\n+                        false);\n+  }\n+\n+  /** Apply the inverse of the instance to another rotation.\n+   * Applying the inverse of the instance to a rotation is computing\n+   * the composition in an order compliant with the following rule :\n+   * let u be any vector and v its image by r (i.e. r.applyTo(u) = v),\n+   * let w be the inverse image of v by the instance\n+   * (i.e. applyInverseTo(v) = w), then w = comp.applyTo(u), where\n+   * comp = applyInverseTo(r).\n+   * @param r rotation to apply the rotation to\n+   * @return a new rotation which is the composition of r by the inverse\n+   * of the instance\n+   */\n+  public Rotation applyInverseTo(Rotation r) {\n+    return new Rotation(-r.q0 * q0 - (r.q1 * q1 + r.q2 * q2 + r.q3 * q3),\n+                        -r.q1 * q0 + r.q0 * q1 + (r.q2 * q3 - r.q3 * q2),\n+                        -r.q2 * q0 + r.q0 * q2 + (r.q3 * q1 - r.q1 * q3),\n+                        -r.q3 * q0 + r.q0 * q3 + (r.q1 * q2 - r.q2 * q1),\n+                        false);\n+  }\n+\n+  /** Perfect orthogonality on a 3X3 matrix.\n+   * @param m initial matrix (not exactly orthogonal)\n+   * @param threshold convergence threshold for the iterative\n+   * orthogonality correction (convergence is reached when the\n+   * difference between two steps of the Frobenius norm of the\n+   * correction is below this threshold)\n+   * @return an orthogonal matrix close to m\n+   * @exception NotARotationMatrixException if the matrix cannot be\n+   * orthogonalized with the given threshold after 10 iterations\n+   */\n+  private double[][] orthogonalizeMatrix(double[][] m, double threshold)\n+    throws NotARotationMatrixException {\n+    double[] m0 = m[0];\n+    double[] m1 = m[1];\n+    double[] m2 = m[2];\n+    double x00 = m0[0];\n+    double x01 = m0[1];\n+    double x02 = m0[2];\n+    double x10 = m1[0];\n+    double x11 = m1[1];\n+    double x12 = m1[2];\n+    double x20 = m2[0];\n+    double x21 = m2[1];\n+    double x22 = m2[2];\n+    double fn = 0;\n+    double fn1;\n+\n+    double[][] o = new double[3][3];\n+    double[] o0 = o[0];\n+    double[] o1 = o[1];\n+    double[] o2 = o[2];\n+\n+    // iterative correction: Xn+1 = Xn - 0.5 * (Xn.Mt.Xn - M)\n+    int i = 0;\n+    while (++i < 11) {\n+\n+      // Mt.Xn\n+      double mx00 = m0[0] * x00 + m1[0] * x10 + m2[0] * x20;\n+      double mx10 = m0[1] * x00 + m1[1] * x10 + m2[1] * x20;\n+      double mx20 = m0[2] * x00 + m1[2] * x10 + m2[2] * x20;\n+      double mx01 = m0[0] * x01 + m1[0] * x11 + m2[0] * x21;\n+      double mx11 = m0[1] * x01 + m1[1] * x11 + m2[1] * x21;\n+      double mx21 = m0[2] * x01 + m1[2] * x11 + m2[2] * x21;\n+      double mx02 = m0[0] * x02 + m1[0] * x12 + m2[0] * x22;\n+      double mx12 = m0[1] * x02 + m1[1] * x12 + m2[1] * x22;\n+      double mx22 = m0[2] * x02 + m1[2] * x12 + m2[2] * x22;\n+\n+      // Xn+1\n+      o0[0] = x00 - 0.5 * (x00 * mx00 + x01 * mx10 + x02 * mx20 - m0[0]);\n+      o0[1] = x01 - 0.5 * (x00 * mx01 + x01 * mx11 + x02 * mx21 - m0[1]);\n+      o0[2] = x02 - 0.5 * (x00 * mx02 + x01 * mx12 + x02 * mx22 - m0[2]);\n+      o1[0] = x10 - 0.5 * (x10 * mx00 + x11 * mx10 + x12 * mx20 - m1[0]);\n+      o1[1] = x11 - 0.5 * (x10 * mx01 + x11 * mx11 + x12 * mx21 - m1[1]);\n+      o1[2] = x12 - 0.5 * (x10 * mx02 + x11 * mx12 + x12 * mx22 - m1[2]);\n+      o2[0] = x20 - 0.5 * (x20 * mx00 + x21 * mx10 + x22 * mx20 - m2[0]);\n+      o2[1] = x21 - 0.5 * (x20 * mx01 + x21 * mx11 + x22 * mx21 - m2[1]);\n+      o2[2] = x22 - 0.5 * (x20 * mx02 + x21 * mx12 + x22 * mx22 - m2[2]);\n+\n+      // correction on each elements\n+      double corr00 = o0[0] - m0[0];\n+      double corr01 = o0[1] - m0[1];\n+      double corr02 = o0[2] - m0[2];\n+      double corr10 = o1[0] - m1[0];\n+      double corr11 = o1[1] - m1[1];\n+      double corr12 = o1[2] - m1[2];\n+      double corr20 = o2[0] - m2[0];\n+      double corr21 = o2[1] - m2[1];\n+      double corr22 = o2[2] - m2[2];\n+\n+      // Frobenius norm of the correction\n+      fn1 = corr00 * corr00 + corr01 * corr01 + corr02 * corr02 +\n+            corr10 * corr10 + corr11 * corr11 + corr12 * corr12 +\n+            corr20 * corr20 + corr21 * corr21 + corr22 * corr22;\n+\n+      // convergence test\n+      if (Math.abs(fn1 - fn) <= threshold)\n+        return o;\n+\n+      // prepare next iteration\n+      x00 = o0[0];\n+      x01 = o0[1];\n+      x02 = o0[2];\n+      x10 = o1[0];\n+      x11 = o1[1];\n+      x12 = o1[2];\n+      x20 = o2[0];\n+      x21 = o2[1];\n+      x22 = o2[2];\n+      fn  = fn1;\n+\n+    }\n+\n+    // the algorithm did not converge after 10 iterations\n+    throw new NotARotationMatrixException(\n+            \"unable to orthogonalize matrix in {0} iterations\",\n+            i - 1);\n+  }\n+\n+  /** Compute the <i>distance</i> between two rotations.\n+   * <p>The <i>distance</i> is intended here as a way to check if two\n+   * rotations are almost similar (i.e. they transform vectors the same way)\n+   * or very different. It is mathematically defined as the angle of\n+   * the rotation r that prepended to one of the rotations gives the other\n+   * one:</p>\n+   * <pre>\n+   *        r<sub>1</sub>(r) = r<sub>2</sub>\n+   * </pre>\n+   * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n+   * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n+   * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n+   * reached for some v. The distance is equal to 0 if and only if the two\n+   * rotations are identical.</p>\n+   * <p>Comparing two rotations should always be done using this value rather\n+   * than for example comparing the components of the quaternions. It is much\n+   * more stable, and has a geometric meaning. Also comparing quaternions\n+   * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n+   * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n+   * their components are different (they are exact opposites).</p>\n+   * @param r1 first rotation\n+   * @param r2 second rotation\n+   * @return <i>distance</i> between r1 and r2\n+   */\n+  public static double distance(Rotation r1, Rotation r2) {\n+      return r1.applyInverseTo(r2).getAngle();\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/RotationOrder.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+/**\n+ * This class is a utility representing a rotation order specification\n+ * for Cardan or Euler angles specification.\n+ *\n+ * This class cannot be instanciated by the user. He can only use one\n+ * of the twelve predefined supported orders as an argument to either\n+ * the {@link Rotation#Rotation(RotationOrder,double,double,double)}\n+ * constructor or the {@link Rotation#getAngles} method.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public final class RotationOrder {\n+\n+  /** Private constructor.\n+   * This is a utility class that cannot be instantiated by the user,\n+   * so its only constructor is private.\n+   * @param name name of the rotation order\n+   * @param a1 axis of the first rotation\n+   * @param a2 axis of the second rotation\n+   * @param a3 axis of the third rotation\n+   */\n+  private RotationOrder(String name,\n+                        Vector3D a1, Vector3D a2, Vector3D a3) {\n+    this.name = name;\n+    this.a1   = a1;\n+    this.a2   = a2;\n+    this.a3   = a3;\n+  }\n+\n+  /** Get a string representation of the instance.\n+   * @return a string representation of the instance (in fact, its name)\n+   */\n+  @Override\n+  public String toString() {\n+    return name;\n+  }\n+\n+  /** Get the axis of the first rotation.\n+   * @return axis of the first rotation\n+   */\n+  public Vector3D getA1() {\n+    return a1;\n+  }\n+\n+  /** Get the axis of the second rotation.\n+   * @return axis of the second rotation\n+   */\n+  public Vector3D getA2() {\n+    return a2;\n+  }\n+\n+  /** Get the axis of the second rotation.\n+   * @return axis of the second rotation\n+   */\n+  public Vector3D getA3() {\n+    return a3;\n+  }\n+\n+  /** Set of Cardan angles.\n+   * this ordered set of rotations is around X, then around Y, then\n+   * around Z\n+   */\n+  public static final RotationOrder XYZ =\n+    new RotationOrder(\"XYZ\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);\n+\n+  /** Set of Cardan angles.\n+   * this ordered set of rotations is around X, then around Z, then\n+   * around Y\n+   */\n+  public static final RotationOrder XZY =\n+    new RotationOrder(\"XZY\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);\n+\n+  /** Set of Cardan angles.\n+   * this ordered set of rotations is around Y, then around X, then\n+   * around Z\n+   */\n+  public static final RotationOrder YXZ =\n+    new RotationOrder(\"YXZ\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);\n+\n+  /** Set of Cardan angles.\n+   * this ordered set of rotations is around Y, then around Z, then\n+   * around X\n+   */\n+  public static final RotationOrder YZX =\n+    new RotationOrder(\"YZX\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);\n+\n+  /** Set of Cardan angles.\n+   * this ordered set of rotations is around Z, then around X, then\n+   * around Y\n+   */\n+  public static final RotationOrder ZXY =\n+    new RotationOrder(\"ZXY\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);\n+\n+  /** Set of Cardan angles.\n+   * this ordered set of rotations is around Z, then around Y, then\n+   * around X\n+   */\n+  public static final RotationOrder ZYX =\n+    new RotationOrder(\"ZYX\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);\n+\n+  /** Set of Euler angles.\n+   * this ordered set of rotations is around X, then around Y, then\n+   * around X\n+   */\n+  public static final RotationOrder XYX =\n+    new RotationOrder(\"XYX\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);\n+\n+  /** Set of Euler angles.\n+   * this ordered set of rotations is around X, then around Z, then\n+   * around X\n+   */\n+  public static final RotationOrder XZX =\n+    new RotationOrder(\"XZX\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);\n+\n+  /** Set of Euler angles.\n+   * this ordered set of rotations is around Y, then around X, then\n+   * around Y\n+   */\n+  public static final RotationOrder YXY =\n+    new RotationOrder(\"YXY\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);\n+\n+  /** Set of Euler angles.\n+   * this ordered set of rotations is around Y, then around Z, then\n+   * around Y\n+   */\n+  public static final RotationOrder YZY =\n+    new RotationOrder(\"YZY\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);\n+\n+  /** Set of Euler angles.\n+   * this ordered set of rotations is around Z, then around X, then\n+   * around Z\n+   */\n+  public static final RotationOrder ZXZ =\n+    new RotationOrder(\"ZXZ\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);\n+\n+  /** Set of Euler angles.\n+   * this ordered set of rotations is around Z, then around Y, then\n+   * around Z\n+   */\n+  public static final RotationOrder ZYZ =\n+    new RotationOrder(\"ZYZ\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);\n+\n+  /** Name of the rotations order. */\n+  private final String name;\n+\n+  /** Axis of the first rotation. */\n+  private final Vector3D a1;\n+\n+  /** Axis of the second rotation. */\n+  private final Vector3D a2;\n+\n+  /** Axis of the third rotation. */\n+  private final Vector3D a3;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/** \n+ * This class implements vectors in a three-dimensional space.\n+ * <p>Instance of this class are guaranteed to be immutable.</p>\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class Vector3D\n+  implements Serializable {\n+\n+  /** Null vector (coordinates: 0, 0, 0). */\n+  public static final Vector3D ZERO   = new Vector3D(0, 0, 0);\n+\n+  /** First canonical vector (coordinates: 1, 0, 0). */\n+  public static final Vector3D PLUS_I = new Vector3D(1, 0, 0);\n+\n+  /** Opposite of the first canonical vector (coordinates: -1, 0, 0). */\n+  public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);\n+\n+  /** Second canonical vector (coordinates: 0, 1, 0). */\n+  public static final Vector3D PLUS_J = new Vector3D(0, 1, 0);\n+\n+  /** Opposite of the second canonical vector (coordinates: 0, -1, 0). */\n+  public static final Vector3D MINUS_J = new Vector3D(0, -1, 0);\n+\n+  /** Third canonical vector (coordinates: 0, 0, 1). */\n+  public static final Vector3D PLUS_K = new Vector3D(0, 0, 1);\n+\n+  /** Opposite of the third canonical vector (coordinates: 0, 0, -1).  */\n+  public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);\n+\n+  /** A vector with all coordinates set to NaN. */\n+  public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);\n+\n+  /** A vector with all coordinates set to positive infinity. */\n+  public static final Vector3D POSITIVE_INFINITY =\n+      new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+\n+  /** A vector with all coordinates set to negative infinity. */\n+  public static final Vector3D NEGATIVE_INFINITY =\n+      new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n+\n+  /** Default format. */\n+  private static final Vector3DFormat DEFAULT_FORMAT =\n+      Vector3DFormat.getInstance();\n+\n+  /** Serializable version identifier. */\n+  private static final long serialVersionUID = 5133268763396045979L;\n+\n+  /** Abscissa. */\n+  private final double x;\n+\n+  /** Ordinate. */\n+  private final double y;\n+\n+  /** Height. */\n+  private final double z;\n+\n+  /** Simple constructor.\n+   * Build a vector from its coordinates\n+   * @param x abscissa\n+   * @param y ordinate\n+   * @param z height\n+   * @see #getX()\n+   * @see #getY()\n+   * @see #getZ()\n+   */\n+  public Vector3D(double x, double y, double z) {\n+    this.x = x;\n+    this.y = y;\n+    this.z = z;\n+  }\n+\n+  /** Simple constructor.\n+   * Build a vector from its azimuthal coordinates\n+   * @param alpha azimuth (&alpha;) around Z\n+   *              (0 is +X, &pi;/2 is +Y, &pi; is -X and 3&pi;/2 is -Y)\n+   * @param delta elevation (&delta;) above (XY) plane, from -&pi;/2 to +&pi;/2\n+   * @see #getAlpha()\n+   * @see #getDelta()\n+   */\n+  public Vector3D(double alpha, double delta) {\n+    double cosDelta = Math.cos(delta);\n+    this.x = Math.cos(alpha) * cosDelta;\n+    this.y = Math.sin(alpha) * cosDelta;\n+    this.z = Math.sin(delta);\n+  }\n+\n+  /** Multiplicative constructor\n+   * Build a vector from another one and a scale factor. \n+   * The vector built will be a * u\n+   * @param a scale factor\n+   * @param u base (unscaled) vector\n+   */\n+  public Vector3D(double a, Vector3D u) {\n+    this.x = a * u.x;\n+    this.y = a * u.y;\n+    this.z = a * u.z;\n+  }\n+\n+  /** Linear constructor\n+   * Build a vector from two other ones and corresponding scale factors.\n+   * The vector built will be a1 * u1 + a2 * u2\n+   * @param a1 first scale factor\n+   * @param u1 first base (unscaled) vector\n+   * @param a2 second scale factor\n+   * @param u2 second base (unscaled) vector\n+   */\n+  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\n+    this.x = a1 * u1.x + a2 * u2.x;\n+    this.y = a1 * u1.y + a2 * u2.y;\n+    this.z = a1 * u1.z + a2 * u2.z;\n+  }\n+\n+  /** Linear constructor\n+   * Build a vector from three other ones and corresponding scale factors.\n+   * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n+   * @param a1 first scale factor\n+   * @param u1 first base (unscaled) vector\n+   * @param a2 second scale factor\n+   * @param u2 second base (unscaled) vector\n+   * @param a3 third scale factor\n+   * @param u3 third base (unscaled) vector\n+   */\n+  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n+                  double a3, Vector3D u3) {\n+    this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x;\n+    this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y;\n+    this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z;\n+  }\n+\n+  /** Linear constructor\n+   * Build a vector from four other ones and corresponding scale factors.\n+   * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n+   * @param a1 first scale factor\n+   * @param u1 first base (unscaled) vector\n+   * @param a2 second scale factor\n+   * @param u2 second base (unscaled) vector\n+   * @param a3 third scale factor\n+   * @param u3 third base (unscaled) vector\n+   * @param a4 fourth scale factor\n+   * @param u4 fourth base (unscaled) vector\n+   */\n+  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n+                  double a3, Vector3D u3, double a4, Vector3D u4) {\n+    this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;\n+    this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y + a4 * u4.y;\n+    this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z + a4 * u4.z;\n+  }\n+\n+  /** Get the abscissa of the vector.\n+   * @return abscissa of the vector\n+   * @see #Vector3D(double, double, double)\n+   */\n+  public double getX() {\n+    return x;\n+  }\n+\n+  /** Get the ordinate of the vector.\n+   * @return ordinate of the vector\n+   * @see #Vector3D(double, double, double)\n+   */\n+  public double getY() {\n+    return y;\n+  }\n+\n+  /** Get the height of the vector.\n+   * @return height of the vector\n+   * @see #Vector3D(double, double, double)\n+   */\n+  public double getZ() {\n+    return z;\n+  }\n+\n+  /** Get the L<sub>1</sub> norm for the vector.\n+   * @return L<sub>1</sub> norm for the vector\n+   */\n+  public double getNorm1() {\n+    return Math.abs(x) + Math.abs(y) + Math.abs(z);\n+  }\n+\n+  /** Get the L<sub>2</sub> norm for the vector.\n+   * @return euclidian norm for the vector\n+   */\n+  public double getNorm() {\n+    return Math.sqrt (x * x + y * y + z * z);\n+  }\n+\n+  /** Get the square of the norm for the vector.\n+   * @return square of the euclidian norm for the vector\n+   */\n+  public double getNormSq() {\n+    return x * x + y * y + z * z;\n+  }\n+\n+  /** Get the L<sub>&infin;</sub> norm for the vector.\n+   * @return L<sub>&infin;</sub> norm for the vector\n+   */\n+  public double getNormInf() {\n+    return Math.max(Math.max(Math.abs(x), Math.abs(y)), Math.abs(z));\n+  }\n+\n+  /** Get the azimuth of the vector.\n+   * @return azimuth (&alpha;) of the vector, between -&pi; and +&pi;\n+   * @see #Vector3D(double, double)\n+   */\n+  public double getAlpha() {\n+    return Math.atan2(y, x);\n+  }\n+\n+  /** Get the elevation of the vector.\n+   * @return elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2\n+   * @see #Vector3D(double, double)\n+   */\n+  public double getDelta() {\n+    return Math.asin(z / getNorm());\n+  }\n+\n+  /** Add a vector to the instance.\n+   * @param v vector to add\n+   * @return a new vector\n+   */\n+  public Vector3D add(Vector3D v) {\n+    return new Vector3D(x + v.x, y + v.y, z + v.z);\n+  }\n+\n+  /** Add a scaled vector to the instance.\n+   * @param factor scale factor to apply to v before adding it\n+   * @param v vector to add\n+   * @return a new vector\n+   */\n+  public Vector3D add(double factor, Vector3D v) {\n+    return new Vector3D(x + factor * v.x, y + factor * v.y, z + factor * v.z);\n+  }\n+\n+  /** Subtract a vector from the instance.\n+   * @param v vector to subtract\n+   * @return a new vector\n+   */\n+  public Vector3D subtract(Vector3D v) {\n+    return new Vector3D(x - v.x, y - v.y, z - v.z);\n+  }\n+\n+  /** Subtract a scaled vector from the instance.\n+   * @param factor scale factor to apply to v before subtracting it\n+   * @param v vector to subtract\n+   * @return a new vector\n+   */\n+  public Vector3D subtract(double factor, Vector3D v) {\n+    return new Vector3D(x - factor * v.x, y - factor * v.y, z - factor * v.z);\n+  }\n+\n+  /** Get a normalized vector aligned with the instance.\n+   * @return a new normalized vector\n+   * @exception ArithmeticException if the norm is zero\n+   */\n+  public Vector3D normalize() {\n+    double s = getNorm();\n+    if (s == 0) {\n+      throw MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n+    }\n+    return scalarMultiply(1 / s);\n+  }\n+\n+  /** Get a vector orthogonal to the instance.\n+   * <p>There are an infinite number of normalized vectors orthogonal\n+   * to the instance. This method picks up one of them almost\n+   * arbitrarily. It is useful when one needs to compute a reference\n+   * frame with one of the axes in a predefined direction. The\n+   * following example shows how to build a frame having the k axis\n+   * aligned with the known vector u :\n+   * <pre><code>\n+   *   Vector3D k = u.normalize();\n+   *   Vector3D i = k.orthogonal();\n+   *   Vector3D j = Vector3D.crossProduct(k, i);\n+   * </code></pre></p>\n+   * @return a new normalized vector orthogonal to the instance\n+   * @exception ArithmeticException if the norm of the instance is null\n+   */\n+  public Vector3D orthogonal() {\n+\n+    double threshold = 0.6 * getNorm();\n+    if (threshold == 0) {\n+      throw MathRuntimeException.createArithmeticException(\"zero norm\");\n+    }\n+\n+    if ((x >= -threshold) && (x <= threshold)) {\n+      double inverse  = 1 / Math.sqrt(y * y + z * z);\n+      return new Vector3D(0, inverse * z, -inverse * y);\n+    } else if ((y >= -threshold) && (y <= threshold)) {\n+      double inverse  = 1 / Math.sqrt(x * x + z * z);\n+      return new Vector3D(-inverse * z, 0, inverse * x);\n+    }\n+    double inverse  = 1 / Math.sqrt(x * x + y * y);\n+    return new Vector3D(inverse * y, -inverse * x, 0);\n+\n+  }\n+\n+  /** Compute the angular separation between two vectors.\n+   * <p>This method computes the angular separation between two\n+   * vectors using the dot product for well separated vectors and the\n+   * cross product for almost aligned vectors. This allows to have a\n+   * good accuracy in all cases, even for vectors very close to each\n+   * other.</p>\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return angular separation between v1 and v2\n+   * @exception ArithmeticException if either vector has a null norm\n+   */\n+  public static double angle(Vector3D v1, Vector3D v2) {\n+\n+    double normProduct = v1.getNorm() * v2.getNorm();\n+    if (normProduct == 0) {\n+      throw MathRuntimeException.createArithmeticException(\"zero norm\");\n+    }\n+\n+    double dot = dotProduct(v1, v2);\n+    double threshold = normProduct * 0.9999;\n+    if ((dot < -threshold) || (dot > threshold)) {\n+      // the vectors are almost aligned, compute using the sine\n+      Vector3D v3 = crossProduct(v1, v2);\n+      if (dot >= 0) {\n+        return Math.asin(v3.getNorm() / normProduct);\n+      }\n+      return Math.PI - Math.asin(v3.getNorm() / normProduct);\n+    }\n+    \n+    // the vectors are sufficiently separated to use the cosine\n+    return Math.acos(dot / normProduct);\n+\n+  }\n+\n+  /** Get the opposite of the instance.\n+   * @return a new vector which is opposite to the instance\n+   */\n+  public Vector3D negate() {\n+    return new Vector3D(-x, -y, -z);\n+  }\n+\n+  /** Multiply the instance by a scalar\n+   * @param a scalar\n+   * @return a new vector\n+   */\n+  public Vector3D scalarMultiply(double a) {\n+    return new Vector3D(a * x, a * y, a * z);\n+  }\n+\n+  /**\n+   * Returns true if any coordinate of this vector is NaN; false otherwise\n+   * @return  true if any coordinate of this vector is NaN; false otherwise\n+   */\n+  public boolean isNaN() {\n+      return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z);        \n+  }\n+  \n+  /**\n+   * Returns true if any coordinate of this vector is infinite and none are NaN;\n+   * false otherwise\n+   * @return  true if any coordinate of this vector is infinite and none are NaN;\n+   * false otherwise\n+   */\n+  public boolean isInfinite() {\n+      return !isNaN() && (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z));        \n+  }\n+  \n+  /**\n+   * Test for the equality of two 3D vectors.\n+   * <p>\n+   * If all coordinates of two 3D vectors are exactly the same, and none are\n+   * <code>Double.NaN</code>, the two 3D vectors are considered to be equal.\n+   * </p>\n+   * <p>\n+   * <code>NaN</code> coordinates are considered to affect globally the vector\n+   * and be equals to each other - i.e, if either (or all) coordinates of the\n+   * 3D vector are equal to <code>Double.NaN</code>, the 3D vector is equal to\n+   * {@link #NaN}.\n+   * </p>\n+   *\n+   * @param other Object to test for equality to this\n+   * @return true if two 3D vector objects are equal, false if\n+   *         object is null, not an instance of Vector3D, or\n+   *         not equal to this Vector3D instance\n+   * \n+   */\n+  @Override\n+  public boolean equals(Object other) {\n+\n+    if (this == other) { \n+      return true;\n+    }\n+\n+    if (other == null) {\n+      return false;\n+    }\n+\n+    try {\n+\n+      final Vector3D rhs = (Vector3D)other;\n+      if (rhs.isNaN()) {\n+          return this.isNaN();\n+      }\n+\n+      return (x == rhs.x) && (y == rhs.y) && (z == rhs.z); \n+\n+    } catch (ClassCastException ex) {\n+        // ignore exception\n+        return false;\n+    }\n+\n+  }\n+  \n+  /**\n+   * Get a hashCode for the 3D vector.\n+   * <p>\n+   * All NaN values have the same hash code.</p>\n+   * \n+   * @return a hash code value for this object\n+   */\n+  @Override\n+  public int hashCode() {\n+      if (isNaN()) {\n+          return 8;\n+      }\n+      return 31 * (23 * MathUtils.hash(x) +  19 * MathUtils.hash(y) +  MathUtils.hash(z));\n+  }\n+\n+  /** Compute the dot-product of two vectors.\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the dot product v1.v2\n+   */\n+  public static double dotProduct(Vector3D v1, Vector3D v2) {\n+    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n+  }\n+\n+  /** Compute the cross-product of two vectors.\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the cross product v1 ^ v2 as a new Vector\n+   */\n+  public static Vector3D crossProduct(Vector3D v1, Vector3D v2) {\n+    return new Vector3D(v1.y * v2.z - v1.z * v2.y,\n+                        v1.z * v2.x - v1.x * v2.z,\n+                        v1.x * v2.y - v1.y * v2.x);\n+  }\n+\n+  /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n+   * <p>Calling this method is equivalent to calling:\n+   * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n+   * vector is built</p>\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n+   */\n+  public static double distance1(Vector3D v1, Vector3D v2) {\n+    final double dx = Math.abs(v2.x - v1.x);\n+    final double dy = Math.abs(v2.y - v1.y);\n+    final double dz = Math.abs(v2.z - v1.z);\n+    return dx + dy + dz;\n+  }\n+\n+  /** Compute the distance between two vectors according to the L<sub>2</sub> norm.\n+   * <p>Calling this method is equivalent to calling:\n+   * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n+   * vector is built</p>\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n+   */\n+  public static double distance(Vector3D v1, Vector3D v2) {\n+    final double dx = v2.x - v1.x;\n+    final double dy = v2.y - v1.y;\n+    final double dz = v2.z - v1.z;\n+    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n+  }\n+\n+  /** Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n+   * <p>Calling this method is equivalent to calling:\n+   * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n+   * vector is built</p>\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n+   */\n+  public static double distanceInf(Vector3D v1, Vector3D v2) {\n+    final double dx = Math.abs(v2.x - v1.x);\n+    final double dy = Math.abs(v2.y - v1.y);\n+    final double dz = Math.abs(v2.z - v1.z);\n+    return Math.max(Math.max(dx, dy), dz);\n+  }\n+\n+  /** Compute the square of the distance between two vectors.\n+   * <p>Calling this method is equivalent to calling:\n+   * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n+   * vector is built</p>\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the square of the distance between v1 and v2\n+   */\n+  public static double distanceSq(Vector3D v1, Vector3D v2) {\n+    final double dx = v2.x - v1.x;\n+    final double dy = v2.y - v1.y;\n+    final double dz = v2.z - v1.z;\n+    return dx * dx + dy * dy + dz * dz;\n+  }\n+\n+  /** Get a string representation of this vector.\n+   * @return a string representation of this vector\n+   */\n+  @Override\n+  public String toString() {\n+      return DEFAULT_FORMAT.format(this);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/Vector3DFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.CompositeFormat;\n+\n+/**\n+ * Formats a 3D vector in components list format \"{x; y; z}\".\n+ * <p>The prefix and suffix \"{\" and \"}\" and the separator \"; \" can be replaced by\n+ * any user-defined strings. The number format for components can be configured.</p>\n+ * <p>White space is ignored at parse time, even if it is in the prefix, suffix\n+ * or separator specifications. So even if the default separator does include a space\n+ * character that is used at format time, both input string \"{1;1;1}\" and\n+ * \" { 1 ; 1 ; 1 } \" will be parsed without error and the same vector will be\n+ * returned. In the second case, however, the parse position after parsing will be\n+ * just after the closing curly brace, i.e. just before the trailing space.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class Vector3DFormat extends CompositeFormat {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -5447606608652576301L;\n+\n+    /** The default prefix: \"{\". */\n+    private static final String DEFAULT_PREFIX = \"{\";\n+\n+    /** The default suffix: \"}\". */\n+    private static final String DEFAULT_SUFFIX = \"}\";\n+\n+    /** The default separator: \", \". */\n+    private static final String DEFAULT_SEPARATOR = \"; \";\n+\n+    /** Prefix. */\n+    private final String prefix;\n+\n+    /** Suffix. */\n+    private final String suffix;\n+\n+    /** Separator. */\n+    private final String separator;\n+\n+    /** Trimmed prefix. */\n+    private final String trimmedPrefix;\n+\n+    /** Trimmed suffix. */\n+    private final String trimmedSuffix;\n+\n+    /** Trimmed separator. */\n+    private final String trimmedSeparator;\n+\n+    /** The format used for components. */\n+    private NumberFormat format;\n+\n+    /**\n+     * Create an instance with default settings.\n+     * <p>The instance uses the default prefix, suffix and separator:\n+     * \"{\", \"}\", and \"; \" and the default number format for components.</p>\n+     */\n+    public Vector3DFormat() {\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with a custom number format for components.\n+     * @param format the custom format for components.\n+     */\n+    public Vector3DFormat(final NumberFormat format) {\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix and separator.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param separator separator to use instead of the default \"; \"\n+     */\n+    public Vector3DFormat(final String prefix, final String suffix,\n+                          final String separator) {\n+        this(prefix, suffix, separator, getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix, separator and format\n+     * for components.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param separator separator to use instead of the default \"; \"\n+     * @param format the custom format for components.\n+     */\n+    public Vector3DFormat(final String prefix, final String suffix,\n+                          final String separator, final NumberFormat format) {\n+        this.prefix      = prefix;\n+        this.suffix      = suffix;\n+        this.separator   = separator;\n+        trimmedPrefix    = prefix.trim();\n+        trimmedSuffix    = suffix.trim();\n+        trimmedSeparator = separator.trim();\n+        this.format      = format;\n+    }\n+\n+    /**\n+     * Get the set of locales for which 3D vectors formats are available.\n+     * <p>This is the same set as the {@link NumberFormat} set.</p>\n+     * @return available 3D vector format locales.\n+     */\n+    public static Locale[] getAvailableLocales() {\n+        return NumberFormat.getAvailableLocales();\n+    }\n+\n+    /**\n+     * Get the format prefix.\n+     * @return format prefix.\n+     */\n+    public String getPrefix() {\n+        return prefix;\n+    }\n+\n+    /**\n+     * Get the format suffix.\n+     * @return format suffix.\n+     */\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    /**\n+     * Get the format separator between components.\n+     * @return format separator.\n+     */\n+    public String getSeparator() {\n+        return separator;\n+    }\n+\n+    /**\n+     * Get the components format.\n+     * @return components format.\n+     */\n+    public NumberFormat getFormat() {\n+        return format;\n+    }\n+\n+    /**\n+     * Returns the default 3D vector format for the current locale.\n+     * @return the default 3D vector format.\n+     */\n+    public static Vector3DFormat getInstance() {\n+        return getInstance(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Returns the default 3D vector format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the 3D vector format specific to the given locale.\n+     */\n+    public static Vector3DFormat getInstance(final Locale locale) {\n+        return new Vector3DFormat(getDefaultNumberFormat(locale));\n+    }\n+\n+    /**\n+     * This static method calls {@link #format(Object)} on a default instance of\n+     * Vector3DFormat.\n+     *\n+     * @param v Vector3D object to format\n+     * @return A formatted vector\n+     */\n+    public static String formatVector3D(Vector3D v) {\n+        return getInstance().format(v);\n+    }\n+\n+    /**\n+     * Formats a {@link Vector3D} object to produce a string.\n+     * @param vector the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(Vector3D vector, StringBuffer toAppendTo,\n+                               FieldPosition pos) {\n+\n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        // format prefix\n+        toAppendTo.append(prefix);\n+\n+        // format components\n+        formatDouble(vector.getX(), format, toAppendTo, pos);\n+        toAppendTo.append(separator);\n+        formatDouble(vector.getY(), format, toAppendTo, pos);\n+        toAppendTo.append(separator);\n+        formatDouble(vector.getZ(), format, toAppendTo, pos);\n+\n+        // format suffix\n+        toAppendTo.append(suffix);\n+\n+        return toAppendTo;\n+\n+    }\n+\n+    /**\n+     * Formats a object to produce a string.\n+     * <p><code>obj</code> must be a  {@link Vector3D} object. Any other type of\n+     * object will result in an {@link IllegalArgumentException} being thrown.</p>\n+     * @param obj the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n+     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n+     */\n+    @Override\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+                               FieldPosition pos) {\n+\n+        if (obj instanceof Vector3D) {\n+            return format( (Vector3D)obj, toAppendTo, pos);\n+        }\n+\n+        throw MathRuntimeException.createIllegalArgumentException(\"cannot format a {0} instance as a 3D vector\",\n+                                                                  obj.getClass().getName());\n+\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link Vector3D} object.\n+     * @param source the string to parse\n+     * @return the parsed {@link Vector3D} object.\n+     * @exception ParseException if the beginning of the specified string\n+     *            cannot be parsed.\n+     */\n+    public Vector3D parse(String source) throws ParseException {\n+        ParsePosition parsePosition = new ParsePosition(0);\n+        Vector3D result = parse(source, parsePosition);\n+        if (parsePosition.getIndex() == 0) {\n+            throw MathRuntimeException.createParseException(\n+                    parsePosition.getErrorIndex(),\n+                    \"unparseable 3D vector: \\\"{0}\\\"\", source);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link Vector3D} object.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link Vector3D} object.\n+     */\n+    public Vector3D parse(String source, ParsePosition pos) {\n+        int initialIndex = pos.getIndex();\n+\n+        // parse prefix\n+        parseAndIgnoreWhitespace(source, pos);\n+        if (!parseFixedstring(source, trimmedPrefix, pos)) {\n+            return null;\n+        }\n+\n+        // parse X component\n+        parseAndIgnoreWhitespace(source, pos);\n+        Number x = parseNumber(source, format, pos);\n+        if (x == null) {\n+            // invalid abscissa\n+            // set index back to initial, error index should already be set\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse Y component\n+        parseAndIgnoreWhitespace(source, pos);\n+        if (!parseFixedstring(source, trimmedSeparator, pos)) {\n+            return null;\n+        }\n+        parseAndIgnoreWhitespace(source, pos);\n+        Number y = parseNumber(source, format, pos);\n+        if (y == null) {\n+            // invalid ordinate\n+            // set index back to initial, error index should already be set\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse Z component\n+        parseAndIgnoreWhitespace(source, pos);\n+        if (!parseFixedstring(source, trimmedSeparator, pos)) {\n+            return null;\n+        }\n+        parseAndIgnoreWhitespace(source, pos);\n+        Number z = parseNumber(source, format, pos);\n+        if (z == null) {\n+            // invalid height\n+            // set index back to initial, error index should already be set\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse suffix\n+        parseAndIgnoreWhitespace(source, pos);\n+        if (!parseFixedstring(source, trimmedSuffix, pos)) {\n+            return null;\n+        }\n+\n+        return new Vector3D(x.doubleValue(), y.doubleValue(), z.doubleValue());\n+\n+    }\n+\n+    /**\n+     * Parses a string to produce a object.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed object.\n+     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n+     */\n+    @Override\n+    public Object parseObject(String source, ParsePosition pos) {\n+        return parse(source, pos);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Basic implementation of {@link FieldMatrix} methods regardless of the underlying storage.\n+ * <p>All the methods implemented here use {@link #getEntry(int, int)} to access\n+ * matrix elements. Derived class can provide faster implementations. </p>\n+ *\n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class AbstractFieldMatrix<T extends FieldElement<T>> implements FieldMatrix<T> {\n+    \n+    /** Field to which the elements belong. */\n+    private final Field<T> field;\n+\n+    /**\n+     * Get the elements type from an array.\n+     * @param <T> the type of the field elements\n+     * @param d data array\n+     * @return field to which array elements belong\n+     * @exception IllegalArgumentException if array is empty\n+     */\n+    protected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d)\n+        throws IllegalArgumentException {\n+        if (d.length == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+        }\n+        if (d[0].length == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+        }\n+        return d[0][0].getField();\n+    }\n+\n+    /**\n+     * Get the elements type from an array.\n+     * @param <T> the type of the field elements\n+     * @param d data array\n+     * @return field to which array elements belong\n+     * @exception IllegalArgumentException if array is empty\n+     */\n+    protected static <T extends FieldElement<T>> Field<T> extractField(final T[] d)\n+        throws IllegalArgumentException {\n+        if (d.length == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+        }\n+        return d[0].getField();\n+    }\n+\n+    /** Build an array of elements.\n+     * <p>\n+     * Complete arrays are filled with field.getZero()\n+     * </p>\n+     * @param <T> the type of the field elements\n+     * @param field field to which array elements belong\n+     * @param rows number of rows\n+     * @param columns number of columns (may be negative to build partial\n+     * arrays in the same way <code>new Field[rows][]</code> works)\n+     * @return a new array\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected static <T extends FieldElement<T>> T[][] buildArray(final Field<T> field,\n+                                                                  final int rows,\n+                                                                  final int columns) {\n+        if (columns < 0) {\n+            T[] dummyRow = (T[]) Array.newInstance(field.getZero().getClass(), 0); \n+            return (T[][]) Array.newInstance(dummyRow.getClass(), rows);            \n+        }\n+        T[][] array =\n+            (T[][]) Array.newInstance(field.getZero().getClass(), new int[] { rows, columns });\n+        for (int i = 0; i < array.length; ++i) {\n+            Arrays.fill(array[i], field.getZero());\n+        }\n+        return array;\n+    }\n+\n+    /** Build an array of elements.\n+     * <p>\n+     * Arrays are filled with field.getZero()\n+     * </p>\n+     * @param <T> the type of the field elements\n+     * @param field field to which array elements belong\n+     * @param length of the array\n+     * @return a new array\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    protected static <T extends FieldElement<T>> T[] buildArray(final Field<T> field,\n+                                                                final int length) {\n+        T[] array = (T[]) Array.newInstance(field.getZero().getClass(), length);\n+        Arrays.fill(array, field.getZero());\n+        return array;\n+    }\n+\n+    /**\n+     * Constructor for use with Serializable\n+     */\n+    protected AbstractFieldMatrix() {\n+        field = null;\n+    }\n+    \n+    /**\n+     * Creates a matrix with no data\n+     * @param field field to which the elements belong\n+     */\n+    protected AbstractFieldMatrix(final Field<T> field) {\n+        this.field = field;\n+    }\n+\n+    /**\n+     * Create a new FieldMatrix<T> with the supplied row and column dimensions.\n+     *\n+     * @param field field to which the elements belong\n+     * @param rowDimension  the number of rows in the new matrix\n+     * @param columnDimension  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not positive\n+     */\n+    protected AbstractFieldMatrix(final Field<T> field,\n+                                  final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        if (rowDimension <= 0 ) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid row dimension {0} (must be positive)\",\n+                    rowDimension);\n+        }\n+        if (columnDimension <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid column dimension {0} (must be positive)\",\n+                    columnDimension);\n+        }\n+        this.field = field;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Field<T> getField() {\n+        return field;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public abstract FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException;\n+\n+    /** {@inheritDoc} */\n+    public abstract FieldMatrix<T> copy();\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> add(FieldMatrix<T> m) throws IllegalArgumentException {\n+\n+        // safety check\n+        checkAdditionCompatible(m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final FieldMatrix<T> out = createMatrix(rowCount, columnCount);\n+        for (int row = 0; row < rowCount; ++row) {\n+            for (int col = 0; col < columnCount; ++col) {\n+                out.setEntry(row, col, getEntry(row, col).add(m.getEntry(row, col)));\n+            }  \n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> subtract(final FieldMatrix<T> m) throws IllegalArgumentException {\n+\n+        // safety check\n+        checkSubtractionCompatible(m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final FieldMatrix<T> out = createMatrix(rowCount, columnCount);\n+        for (int row = 0; row < rowCount; ++row) {\n+            for (int col = 0; col < columnCount; ++col) {\n+                out.setEntry(row, col, getEntry(row, col).subtract(m.getEntry(row, col)));\n+            }  \n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> scalarAdd(final T d) {\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final FieldMatrix<T> out = createMatrix(rowCount, columnCount);\n+        for (int row = 0; row < rowCount; ++row) {\n+            for (int col = 0; col < columnCount; ++col) {\n+                out.setEntry(row, col, getEntry(row, col).add(d));\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> scalarMultiply(final T d) {\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final FieldMatrix<T> out = createMatrix(rowCount, columnCount);\n+        for (int row = 0; row < rowCount; ++row) {\n+            for (int col = 0; col < columnCount; ++col) {\n+                out.setEntry(row, col, getEntry(row, col).multiply(d));\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> multiply(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkMultiplicationCompatible(m);\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = m.getColumnDimension();\n+        final int nSum  = getColumnDimension();\n+        final FieldMatrix<T> out = createMatrix(nRows, nCols);\n+        for (int row = 0; row < nRows; ++row) {\n+            for (int col = 0; col < nCols; ++col) {\n+                T sum = field.getZero();\n+                for (int i = 0; i < nSum; ++i) {\n+                    sum = sum.add(getEntry(row, i).multiply(m.getEntry(i, col)));\n+                }\n+                out.setEntry(row, col, sum);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> preMultiply(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        return m.multiply(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T[][] getData() {\n+\n+        final T[][] data = buildArray(field, getRowDimension(), getColumnDimension());\n+\n+        for (int i = 0; i < data.length; ++i) {\n+            final T[] dataI = data[i];\n+            for (int j = 0; j < dataI.length; ++j) {\n+                dataI[j] = getEntry(i, j);\n+            }\n+        }\n+\n+        return data;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> getSubMatrix(final int startRow, final int endRow,\n+                                   final int startColumn, final int endColumn)\n+        throws MatrixIndexException {\n+\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+\n+        final FieldMatrix<T> subMatrix =\n+            createMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n+        for (int i = startRow; i <= endRow; ++i) {\n+            for (int j = startColumn; j <= endColumn; ++j) {\n+                subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));\n+            }\n+        }\n+\n+        return subMatrix;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> getSubMatrix(final int[] selectedRows, final int[] selectedColumns)\n+        throws MatrixIndexException {\n+\n+        // safety checks\n+        checkSubMatrixIndex(selectedRows, selectedColumns);\n+\n+        // copy entries\n+        final FieldMatrix<T> subMatrix =\n+            createMatrix(selectedRows.length, selectedColumns.length);\n+        subMatrix.walkInOptimizedOrder(new DefaultFieldMatrixChangingVisitor<T>(field.getZero()) {\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public T visit(final int row, final int column, final T value) {\n+                return getEntry(selectedRows[row], selectedColumns[column]);\n+            }\n+\n+        });\n+\n+        return subMatrix;\n+\n+    } \n+\n+    /** {@inheritDoc} */\n+    public void copySubMatrix(final int startRow, final int endRow,\n+                              final int startColumn, final int endColumn,\n+                              final T[][] destination)\n+        throws MatrixIndexException, IllegalArgumentException {\n+\n+        // safety checks\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        final int rowsCount    = endRow + 1 - startRow;\n+        final int columnsCount = endColumn + 1 - startColumn;\n+        if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    destination.length, destination[0].length,\n+                    rowsCount, columnsCount);\n+        }\n+\n+        // copy entries\n+        walkInOptimizedOrder(new DefaultFieldMatrixPreservingVisitor<T>(field.getZero()) {\n+\n+            /** Initial row index. */\n+            private int startRow;\n+\n+            /** Initial column index. */\n+            private int startColumn;\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public void start(final int rows, final int columns,\n+                              final int startRow, final int endRow,\n+                              final int startColumn, final int endColumn) {\n+                this.startRow    = startRow;\n+                this.startColumn = startColumn;\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public void visit(final int row, final int column, final T value) {\n+                destination[row - startRow][column - startColumn] = value;\n+            }\n+\n+        }, startRow, endRow, startColumn, endColumn);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void copySubMatrix(int[] selectedRows, int[] selectedColumns, T[][] destination)\n+        throws MatrixIndexException, IllegalArgumentException {\n+\n+        // safety checks\n+        checkSubMatrixIndex(selectedRows, selectedColumns);\n+        if ((destination.length < selectedRows.length) ||\n+            (destination[0].length < selectedColumns.length)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    destination.length, destination[0].length,\n+                    selectedRows.length, selectedColumns.length);\n+        }\n+\n+        // copy entries\n+        for (int i = 0; i < selectedRows.length; i++) {\n+            final T[] destinationI = destination[i];\n+            for (int j = 0; j < selectedColumns.length; j++) {\n+                destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubMatrix(final T[][] subMatrix, final int row, final int column) \n+        throws MatrixIndexException {\n+\n+        final int nRows = subMatrix.length;\n+        if (nRows == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+        }\n+\n+        final int nCols = subMatrix[0].length;\n+        if (nCols == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+        }\n+\n+        for (int r = 1; r < nRows; ++r) {\n+            if (subMatrix[r].length != nCols) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some rows have length {0} while others have length {1}\",\n+                        nCols, subMatrix[r].length); \n+            }\n+        }\n+\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+        checkRowIndex(nRows + row - 1);\n+        checkColumnIndex(nCols + column - 1);\n+\n+        for (int i = 0; i < nRows; ++i) {\n+            for (int j = 0; j < nCols; ++j) {\n+                setEntry(row + i, column + j, subMatrix[i][j]);\n+            }\n+        } \n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> getRowMatrix(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        final FieldMatrix<T> out = createMatrix(1, nCols);\n+        for (int i = 0; i < nCols; ++i) {\n+            out.setEntry(0, i, getEntry(row, i));\n+        }\n+\n+        return out;\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public void setRowMatrix(final int row, final FieldMatrix<T> matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        if ((matrix.getRowDimension() != 1) ||\n+            (matrix.getColumnDimension() != nCols)) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);\n+        }\n+        for (int i = 0; i < nCols; ++i) {\n+            setEntry(row, i, matrix.getEntry(0, i));\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> getColumnMatrix(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        final FieldMatrix<T> out = createMatrix(nRows, 1);\n+        for (int i = 0; i < nRows; ++i) {\n+            out.setEntry(i, 0, getEntry(i, column));\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setColumnMatrix(final int column, final FieldMatrix<T> matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        if ((matrix.getRowDimension() != nRows) ||\n+            (matrix.getColumnDimension() != 1)) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);\n+        }\n+        for (int i = 0; i < nRows; ++i) {\n+            setEntry(i, column, matrix.getEntry(i, 0));\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public FieldVector<T> getRowVector(final int row)\n+        throws MatrixIndexException {\n+        return new ArrayFieldVector<T>(getRow(row), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setRowVector(final int row, final FieldVector<T> vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        if (vector.getDimension() != nCols) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    1, vector.getDimension(), 1, nCols);\n+        }\n+        for (int i = 0; i < nCols; ++i) {\n+            setEntry(row, i, vector.getEntry(i));\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public FieldVector<T> getColumnVector(final int column)\n+        throws MatrixIndexException {\n+        return new ArrayFieldVector<T>(getColumn(column), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setColumnVector(final int column, final FieldVector<T> vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        if (vector.getDimension() != nRows) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    vector.getDimension(), 1, nRows, 1);\n+        }\n+        for (int i = 0; i < nRows; ++i) {\n+            setEntry(i, column, vector.getEntry(i));\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public T[] getRow(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        final T[] out = buildArray(field, nCols);\n+        for (int i = 0; i < nCols; ++i) {\n+            out[i] = getEntry(row, i);\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setRow(final int row, final T[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        if (array.length != nCols) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    1, array.length, 1, nCols);\n+        }\n+        for (int i = 0; i < nCols; ++i) {\n+            setEntry(row, i, array[i]);\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public T[] getColumn(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        final T[] out = buildArray(field, nRows);\n+        for (int i = 0; i < nRows; ++i) {\n+            out[i] = getEntry(i, column);\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setColumn(final int column, final T[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        if (array.length != nRows) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    array.length, 1, nRows, 1);\n+        }\n+        for (int i = 0; i < nRows; ++i) {\n+            setEntry(i, column, array[i]);\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public abstract T getEntry(int row, int column)\n+        throws MatrixIndexException;\n+\n+    /** {@inheritDoc} */\n+    public abstract void setEntry(int row, int column, T value)\n+        throws MatrixIndexException;\n+\n+    /** {@inheritDoc} */\n+    public abstract void addToEntry(int row, int column, T increment)\n+        throws MatrixIndexException;\n+\n+    /** {@inheritDoc} */\n+    public abstract void multiplyEntry(int row, int column, T factor)\n+        throws MatrixIndexException;\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> transpose() {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        final FieldMatrix<T> out = createMatrix(nCols, nRows);\n+        walkInOptimizedOrder(new DefaultFieldMatrixPreservingVisitor<T>(field.getZero()) {\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public void visit(final int row, final int column, final T value) {\n+                out.setEntry(column, row, value);\n+            }\n+\n+        });\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSquare() {\n+        return (getColumnDimension() == getRowDimension());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public abstract int getRowDimension();\n+\n+    /** {@inheritDoc} */\n+    public abstract int getColumnDimension();\n+\n+    /** {@inheritDoc} */\n+    public T getTrace()\n+        throws NonSquareMatrixException {\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (nRows != nCols) {\n+            throw new NonSquareMatrixException(nRows, nCols);\n+       }\n+        T trace = field.getZero();\n+        for (int i = 0; i < nRows; ++i) {\n+            trace = trace.add(getEntry(i, i));\n+        }\n+        return trace;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T[] operate(final T[] v)\n+        throws IllegalArgumentException {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (v.length != nCols) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nCols);\n+        }\n+\n+        final T[] out = buildArray(field, nRows);\n+        for (int row = 0; row < nRows; ++row) {\n+            T sum = field.getZero();\n+            for (int i = 0; i < nCols; ++i) {\n+                sum = sum.add(getEntry(row, i).multiply(v[i]));\n+            }\n+            out[row] = sum;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> operate(final FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        try {\n+            return new ArrayFieldVector<T>(operate(((ArrayFieldVector<T>) v).getDataRef()), false);\n+        } catch (ClassCastException cce) {\n+            final int nRows = getRowDimension();\n+            final int nCols = getColumnDimension();\n+            if (v.getDimension() != nCols) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"vector length mismatch: got {0} but expected {1}\",\n+                        v.getDimension(), nCols);\n+            }\n+\n+            final T[] out = buildArray(field, nRows);\n+            for (int row = 0; row < nRows; ++row) {\n+                T sum = field.getZero();\n+                for (int i = 0; i < nCols; ++i) {\n+                    sum = sum.add(getEntry(row, i).multiply(v.getEntry(i)));\n+                }\n+                out[row] = sum;\n+            }\n+\n+            return new ArrayFieldVector<T>(out, false);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T[] preMultiply(final T[] v)\n+        throws IllegalArgumentException {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (v.length != nRows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nRows);\n+        }\n+\n+        final T[] out = buildArray(field, nCols);\n+        for (int col = 0; col < nCols; ++col) {\n+            T sum = field.getZero();\n+            for (int i = 0; i < nRows; ++i) {\n+                sum = sum.add(getEntry(i, col).multiply(v[i]));\n+            }\n+            out[col] = sum;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> preMultiply(final FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        try {\n+            return new ArrayFieldVector<T>(preMultiply(((ArrayFieldVector<T>) v).getDataRef()), false);\n+        } catch (ClassCastException cce) {\n+\n+            final int nRows = getRowDimension();\n+            final int nCols = getColumnDimension();\n+            if (v.getDimension() != nRows) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"vector length mismatch: got {0} but expected {1}\",\n+                        v.getDimension(), nRows);\n+            }\n+\n+            final T[] out = buildArray(field, nCols);\n+            for (int col = 0; col < nCols; ++col) {\n+                T sum = field.getZero();\n+                for (int i = 0; i < nRows; ++i) {\n+                    sum = sum.add(getEntry(i, col).multiply(v.getEntry(i)));\n+                }\n+                out[col] = sum;\n+            }\n+\n+            return new ArrayFieldVector<T>(out);\n+\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int row = 0; row < rows; ++row) {\n+            for (int column = 0; column < columns; ++column) {\n+                final T oldValue = getEntry(row, column);\n+                final T newValue = visitor.visit(row, column, oldValue);\n+                setEntry(row, column, newValue);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int row = 0; row < rows; ++row) {\n+            for (int column = 0; column < columns; ++column) {\n+                visitor.visit(row, column, getEntry(row, column));\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor,\n+                            final int startRow, final int endRow,\n+                            final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int row = startRow; row <= endRow; ++row) {\n+            for (int column = startColumn; column <= endColumn; ++column) {\n+                final T oldValue = getEntry(row, column);\n+                final T newValue = visitor.visit(row, column, oldValue);\n+                setEntry(row, column, newValue);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int row = startRow; row <= endRow; ++row) {\n+            for (int column = startColumn; column <= endColumn; ++column) {\n+                visitor.visit(row, column, getEntry(row, column));\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInColumnOrder(final FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int column = 0; column < columns; ++column) {\n+            for (int row = 0; row < rows; ++row) {\n+                final T oldValue = getEntry(row, column);\n+                final T newValue = visitor.visit(row, column, oldValue);\n+                setEntry(row, column, newValue);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInColumnOrder(final FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int column = 0; column < columns; ++column) {\n+            for (int row = 0; row < rows; ++row) {\n+                visitor.visit(row, column, getEntry(row, column));\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInColumnOrder(final FieldMatrixChangingVisitor<T> visitor,\n+                               final int startRow, final int endRow,\n+                               final int startColumn, final int endColumn)\n+    throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int column = startColumn; column <= endColumn; ++column) {\n+            for (int row = startRow; row <= endRow; ++row) {\n+                final T oldValue = getEntry(row, column);\n+                final T newValue = visitor.visit(row, column, oldValue);\n+                setEntry(row, column, newValue);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInColumnOrder(final FieldMatrixPreservingVisitor<T> visitor,\n+                               final int startRow, final int endRow,\n+                               final int startColumn, final int endColumn)\n+    throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int column = startColumn; column <= endColumn; ++column) {\n+            for (int row = startRow; row <= endRow; ++row) {\n+                visitor.visit(row, column, getEntry(row, column));\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        return walkInRowOrder(visitor);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        return walkInRowOrder(visitor);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n+    }\n+\n+    /**\n+     * Get a string representation for this matrix.\n+     * @return a string representation for this matrix\n+     */\n+    @Override\n+    public String toString() {\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        final StringBuffer res = new StringBuffer();\n+        String fullClassName = getClass().getName();\n+        String shortClassName = fullClassName.substring(fullClassName.lastIndexOf('.') + 1);\n+        res.append(shortClassName).append(\"{\");\n+\n+        for (int i = 0; i < nRows; ++i) {\n+            if (i > 0) {\n+                res.append(\",\");\n+            }\n+            res.append(\"{\");\n+            for (int j = 0; j < nCols; ++j) {\n+                if (j > 0) {\n+                    res.append(\",\");\n+                }\n+                res.append(getEntry(i, j));\n+            } \n+            res.append(\"}\");\n+        } \n+\n+        res.append(\"}\");\n+        return res.toString();\n+\n+    } \n+    \n+    /**\n+     * Returns true iff <code>object</code> is a\n+     * <code>FieldMatrix</code> instance with the same dimensions as this\n+     * and all corresponding matrix entries are equal.\n+     * \n+     * @param object the object to test equality against.\n+     * @return true if object equals this\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public boolean equals(final Object object) {\n+        if (object == this ) {\n+            return true;\n+        }\n+        if (object instanceof FieldMatrix == false) {\n+            return false;\n+        }\n+        FieldMatrix<T> m = (FieldMatrix<T>) object;\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {\n+            return false;\n+        }\n+        for (int row = 0; row < nRows; ++row) {\n+            for (int col = 0; col < nCols; ++col) {\n+                if (!getEntry(row, col).equals(m.getEntry(row, col))) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Computes a hashcode for the matrix.\n+     * \n+     * @return hashcode for matrix\n+     */\n+    @Override\n+    public int hashCode() {\n+        int ret = 322562;\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        ret = ret * 31 + nRows;\n+        ret = ret * 31 + nCols;\n+        for (int row = 0; row < nRows; ++row) {\n+            for (int col = 0; col < nCols; ++col) {\n+               ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * getEntry(row, col).hashCode();\n+           }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Check if a row index is valid.\n+     * @param row row index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    protected void checkRowIndex(final int row) {\n+        if (row < 0 || row >= getRowDimension()) {\n+            throw new MatrixIndexException(\"row index {0} out of allowed range [{1}, {2}]\",\n+                                           row, 0, getRowDimension() - 1);\n+        }\n+    }\n+\n+    /**\n+     * Check if a column index is valid.\n+     * @param column column index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    protected void checkColumnIndex(final int column)\n+        throws MatrixIndexException {\n+        if (column < 0 || column >= getColumnDimension()) {\n+            throw new MatrixIndexException(\"column index {0} out of allowed range [{1}, {2}]\",\n+                                           column, 0, getColumnDimension() - 1);\n+        }\n+    }\n+\n+    /**\n+     * Check if submatrix ranges indices are valid.\n+     * Rows and columns are indicated counting from 0 to n-1.\n+     *\n+     * @param startRow Initial row index\n+     * @param endRow Final row index\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception MatrixIndexException  if the indices are not valid\n+     */\n+    protected void checkSubMatrixIndex(final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn) {\n+        checkRowIndex(startRow);\n+        checkRowIndex(endRow);\n+        if (startRow > endRow) {\n+            throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n+                                           startRow, endRow);\n+        }\n+\n+        checkColumnIndex(startColumn);\n+        checkColumnIndex(endColumn);\n+        if (startColumn > endColumn) {\n+            throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n+                                           startColumn, endColumn);\n+        }\n+\n+    \n+    }\n+\n+    /**\n+     * Check if submatrix ranges indices are valid.\n+     * Rows and columns are indicated counting from 0 to n-1.\n+     *\n+     * @param selectedRows Array of row indices.\n+     * @param selectedColumns Array of column indices.\n+     * @exception MatrixIndexException if row or column selections are not valid\n+     */\n+    protected void checkSubMatrixIndex(final int[] selectedRows, final int[] selectedColumns) {\n+        if (selectedRows.length * selectedColumns.length == 0) {\n+            if (selectedRows.length == 0) {\n+                throw new MatrixIndexException(\"empty selected row index array\");\n+            }\n+            throw new MatrixIndexException(\"empty selected column index array\");\n+        }\n+\n+        for (final int row : selectedRows) {\n+            checkRowIndex(row);\n+        }\n+        for (final int column : selectedColumns) {\n+            checkColumnIndex(column);\n+        }\n+    }\n+\n+    /**\n+     * Check if a matrix is addition compatible with the instance\n+     * @param m matrix to check\n+     * @exception IllegalArgumentException if matrix is not addition compatible with instance\n+     */\n+    protected void checkAdditionCompatible(final FieldMatrix<T> m) {\n+        if ((getRowDimension()    != m.getRowDimension()) ||\n+            (getColumnDimension() != m.getColumnDimension())) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0}x{1} and {2}x{3} matrices are not addition compatible\",\n+                    getRowDimension(), getColumnDimension(),\n+                    m.getRowDimension(), m.getColumnDimension());\n+        }\n+    }\n+\n+    /**\n+     * Check if a matrix is subtraction compatible with the instance\n+     * @param m matrix to check\n+     * @exception IllegalArgumentException if matrix is not subtraction compatible with instance\n+     */\n+    protected void checkSubtractionCompatible(final FieldMatrix<T> m) {\n+        if ((getRowDimension()    != m.getRowDimension()) ||\n+            (getColumnDimension() != m.getColumnDimension())) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0}x{1} and {2}x{3} matrices are not subtraction compatible\",\n+                    getRowDimension(), getColumnDimension(),\n+                    m.getRowDimension(), m.getColumnDimension());\n+        }\n+    }\n+\n+    /**\n+     * Check if a matrix is multiplication compatible with the instance\n+     * @param m matrix to check\n+     * @exception IllegalArgumentException if matrix is not multiplication compatible with instance\n+     */\n+    protected void checkMultiplicationCompatible(final FieldMatrix<T> m) {\n+        if (getColumnDimension() != m.getRowDimension()) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n+                    getRowDimension(), getColumnDimension(),\n+                    m.getRowDimension(), m.getColumnDimension());\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Basic implementation of RealMatrix methods regardless of the underlying storage.\n+ * <p>All the methods implemented here use {@link #getEntry(int, int)} to access\n+ * matrix elements. Derived class can provide faster implementations. </p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class AbstractRealMatrix implements RealMatrix {\n+    \n+    \n+    /** Cached LU solver.\n+     * @deprecated as of release 2.0, since all methods using this are deprecated\n+     */\n+    @Deprecated\n+    private DecompositionSolver lu;\n+\n+    /**\n+     * Creates a matrix with no data\n+     */\n+    protected AbstractRealMatrix() {\n+        lu = null;\n+    }\n+\n+    /**\n+     * Create a new RealMatrix with the supplied row and column dimensions.\n+     *\n+     * @param rowDimension  the number of rows in the new matrix\n+     * @param columnDimension  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not positive\n+     */\n+    protected AbstractRealMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        if (rowDimension <= 0 ) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid row dimension {0} (must be positive)\",\n+                    rowDimension);\n+        }\n+        if (columnDimension <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid column dimension {0} (must be positive)\",\n+                    columnDimension);\n+        }\n+        lu = null;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public abstract RealMatrix createMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException;\n+\n+    /** {@inheritDoc} */\n+    public abstract RealMatrix copy();\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix add(RealMatrix m) throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkAdditionCompatible(this, m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final RealMatrix out = createMatrix(rowCount, columnCount);\n+        for (int row = 0; row < rowCount; ++row) {\n+            for (int col = 0; col < columnCount; ++col) {\n+                out.setEntry(row, col, getEntry(row, col) + m.getEntry(row, col));\n+            }  \n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix subtract(final RealMatrix m) throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkSubtractionCompatible(this, m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final RealMatrix out = createMatrix(rowCount, columnCount);\n+        for (int row = 0; row < rowCount; ++row) {\n+            for (int col = 0; col < columnCount; ++col) {\n+                out.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));\n+            }  \n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix scalarAdd(final double d) {\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final RealMatrix out = createMatrix(rowCount, columnCount);\n+        for (int row = 0; row < rowCount; ++row) {\n+            for (int col = 0; col < columnCount; ++col) {\n+                out.setEntry(row, col, getEntry(row, col) + d);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix scalarMultiply(final double d) {\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final RealMatrix out = createMatrix(rowCount, columnCount);\n+        for (int row = 0; row < rowCount; ++row) {\n+            for (int col = 0; col < columnCount; ++col) {\n+                out.setEntry(row, col, getEntry(row, col) * d);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix multiply(final RealMatrix m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkMultiplicationCompatible(this, m);\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = m.getColumnDimension();\n+        final int nSum  = getColumnDimension();\n+        final RealMatrix out = createMatrix(nRows, nCols);\n+        for (int row = 0; row < nRows; ++row) {\n+            for (int col = 0; col < nCols; ++col) {\n+                double sum = 0;\n+                for (int i = 0; i < nSum; ++i) {\n+                    sum += getEntry(row, i) * m.getEntry(i, col);\n+                }\n+                out.setEntry(row, col, sum);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix preMultiply(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        return m.multiply(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[][] getData() {\n+\n+        final double[][] data = new double[getRowDimension()][getColumnDimension()];\n+\n+        for (int i = 0; i < data.length; ++i) {\n+            final double[] dataI = data[i];\n+            for (int j = 0; j < dataI.length; ++j) {\n+                dataI[j] = getEntry(i, j);\n+            }\n+        }\n+\n+        return data;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNorm() {\n+        return walkInColumnOrder(new RealMatrixPreservingVisitor() {\n+\n+            /** Last row index. */\n+            private double endRow;\n+\n+            /** Sum of absolute values on one column. */\n+            private double columnSum;\n+\n+            /** Maximal sum across all columns. */\n+            private double maxColSum;\n+\n+            /** {@inheritDoc} */\n+            public void start(final int rows, final int columns,\n+                              final int startRow, final int endRow,\n+                              final int startColumn, final int endColumn) {\n+                this.endRow = endRow;\n+                columnSum   = 0;\n+                maxColSum   = 0;\n+            }\n+\n+            /** {@inheritDoc} */\n+            public void visit(final int row, final int column, final double value) {\n+                columnSum += Math.abs(value);\n+                if (row == endRow) {\n+                    maxColSum = Math.max(maxColSum, columnSum);\n+                    columnSum = 0;\n+                }\n+            }\n+\n+            /** {@inheritDoc} */\n+            public double end() {\n+                return maxColSum;\n+            }\n+\n+        });\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public double getFrobeniusNorm() {\n+        return walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\n+\n+            /** Sum of squared entries. */\n+            private double sum;\n+\n+            /** {@inheritDoc} */\n+            public void start(final int rows, final int columns,\n+                              final int startRow, final int endRow,\n+                              final int startColumn, final int endColumn) {\n+                sum = 0;\n+            }\n+\n+            /** {@inheritDoc} */\n+            public void visit(final int row, final int column, final double value) {\n+                sum += value * value;\n+            }\n+\n+            /** {@inheritDoc} */\n+            public double end() {\n+                return Math.sqrt(sum);\n+            }\n+\n+        });\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public RealMatrix getSubMatrix(final int startRow, final int endRow,\n+                                   final int startColumn, final int endColumn)\n+        throws MatrixIndexException {\n+\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+\n+        final RealMatrix subMatrix =\n+            createMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n+        for (int i = startRow; i <= endRow; ++i) {\n+            for (int j = startColumn; j <= endColumn; ++j) {\n+                subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));\n+            }\n+        }\n+\n+        return subMatrix;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns)\n+        throws MatrixIndexException {\n+\n+        // safety checks\n+        MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);\n+\n+        // copy entries\n+        final RealMatrix subMatrix =\n+            createMatrix(selectedRows.length, selectedColumns.length);\n+        subMatrix.walkInOptimizedOrder(new DefaultRealMatrixChangingVisitor() {\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public double visit(final int row, final int column, final double value) {\n+                return getEntry(selectedRows[row], selectedColumns[column]);\n+            }\n+\n+        });\n+\n+        return subMatrix;\n+\n+    } \n+\n+    /** {@inheritDoc} */\n+    public void copySubMatrix(final int startRow, final int endRow,\n+                              final int startColumn, final int endColumn,\n+                              final double[][] destination)\n+        throws MatrixIndexException, IllegalArgumentException {\n+\n+        // safety checks\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        final int rowsCount    = endRow + 1 - startRow;\n+        final int columnsCount = endColumn + 1 - startColumn;\n+        if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    destination.length, destination[0].length,\n+                    rowsCount, columnsCount);\n+        }\n+\n+        // copy entries\n+        walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n+\n+            /** Initial row index. */\n+            private int startRow;\n+\n+            /** Initial column index. */\n+            private int startColumn;\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public void start(final int rows, final int columns,\n+                              final int startRow, final int endRow,\n+                              final int startColumn, final int endColumn) {\n+                this.startRow    = startRow;\n+                this.startColumn = startColumn;\n+            }\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public void visit(final int row, final int column, final double value) {\n+                destination[row - startRow][column - startColumn] = value;\n+            }\n+\n+        }, startRow, endRow, startColumn, endColumn);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination)\n+        throws MatrixIndexException, IllegalArgumentException {\n+\n+        // safety checks\n+        MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);\n+        if ((destination.length < selectedRows.length) ||\n+            (destination[0].length < selectedColumns.length)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    destination.length, destination[0].length,\n+                    selectedRows.length, selectedColumns.length);\n+        }\n+\n+        // copy entries\n+        for (int i = 0; i < selectedRows.length; i++) {\n+            final double[] destinationI = destination[i];\n+            for (int j = 0; j < selectedColumns.length; j++) {\n+                destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubMatrix(final double[][] subMatrix, final int row, final int column) \n+        throws MatrixIndexException {\n+\n+        final int nRows = subMatrix.length;\n+        if (nRows == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+        }\n+\n+        final int nCols = subMatrix[0].length;\n+        if (nCols == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+        }\n+\n+        for (int r = 1; r < nRows; ++r) {\n+            if (subMatrix[r].length != nCols) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some rows have length {0} while others have length {1}\",\n+                        nCols, subMatrix[r].length); \n+            }\n+        }\n+\n+        MatrixUtils.checkRowIndex(this, row);\n+        MatrixUtils.checkColumnIndex(this, column);\n+        MatrixUtils.checkRowIndex(this, nRows + row - 1);\n+        MatrixUtils.checkColumnIndex(this, nCols + column - 1);\n+\n+        for (int i = 0; i < nRows; ++i) {\n+            for (int j = 0; j < nCols; ++j) {\n+                setEntry(row + i, column + j, subMatrix[i][j]);\n+            }\n+        } \n+\n+        lu = null;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getRowMatrix(final int row)\n+        throws MatrixIndexException {\n+\n+        MatrixUtils.checkRowIndex(this, row);\n+        final int nCols = getColumnDimension();\n+        final RealMatrix out = createMatrix(1, nCols);\n+        for (int i = 0; i < nCols; ++i) {\n+            out.setEntry(0, i, getEntry(row, i));\n+        }\n+\n+        return out;\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public void setRowMatrix(final int row, final RealMatrix matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        MatrixUtils.checkRowIndex(this, row);\n+        final int nCols = getColumnDimension();\n+        if ((matrix.getRowDimension() != 1) ||\n+            (matrix.getColumnDimension() != nCols)) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);\n+        }\n+        for (int i = 0; i < nCols; ++i) {\n+            setEntry(row, i, matrix.getEntry(0, i));\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public RealMatrix getColumnMatrix(final int column)\n+        throws MatrixIndexException {\n+\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final int nRows = getRowDimension();\n+        final RealMatrix out = createMatrix(nRows, 1);\n+        for (int i = 0; i < nRows; ++i) {\n+            out.setEntry(i, 0, getEntry(i, column));\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setColumnMatrix(final int column, final RealMatrix matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final int nRows = getRowDimension();\n+        if ((matrix.getRowDimension() != nRows) ||\n+            (matrix.getColumnDimension() != 1)) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);\n+        }\n+        for (int i = 0; i < nRows; ++i) {\n+            setEntry(i, column, matrix.getEntry(i, 0));\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public RealVector getRowVector(final int row)\n+        throws MatrixIndexException {\n+        return new ArrayRealVector(getRow(row), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setRowVector(final int row, final RealVector vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        MatrixUtils.checkRowIndex(this, row);\n+        final int nCols = getColumnDimension();\n+        if (vector.getDimension() != nCols) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    1, vector.getDimension(), 1, nCols);\n+        }\n+        for (int i = 0; i < nCols; ++i) {\n+            setEntry(row, i, vector.getEntry(i));\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public RealVector getColumnVector(final int column)\n+        throws MatrixIndexException {\n+        return new ArrayRealVector(getColumn(column), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setColumnVector(final int column, final RealVector vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final int nRows = getRowDimension();\n+        if (vector.getDimension() != nRows) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    vector.getDimension(), 1, nRows, 1);\n+        }\n+        for (int i = 0; i < nRows; ++i) {\n+            setEntry(i, column, vector.getEntry(i));\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public double[] getRow(final int row)\n+        throws MatrixIndexException {\n+\n+        MatrixUtils.checkRowIndex(this, row);\n+        final int nCols = getColumnDimension();\n+        final double[] out = new double[nCols];\n+        for (int i = 0; i < nCols; ++i) {\n+            out[i] = getEntry(row, i);\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setRow(final int row, final double[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        MatrixUtils.checkRowIndex(this, row);\n+        final int nCols = getColumnDimension();\n+        if (array.length != nCols) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    1, array.length, 1, nCols);\n+        }\n+        for (int i = 0; i < nCols; ++i) {\n+            setEntry(row, i, array[i]);\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public double[] getColumn(final int column)\n+        throws MatrixIndexException {\n+\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final int nRows = getRowDimension();\n+        final double[] out = new double[nRows];\n+        for (int i = 0; i < nRows; ++i) {\n+            out[i] = getEntry(i, column);\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setColumn(final int column, final double[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final int nRows = getRowDimension();\n+        if (array.length != nRows) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    array.length, 1, nRows, 1);\n+        }\n+        for (int i = 0; i < nRows; ++i) {\n+            setEntry(i, column, array[i]);\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public abstract double getEntry(int row, int column)\n+        throws MatrixIndexException;\n+\n+    /** {@inheritDoc} */\n+    public abstract void setEntry(int row, int column, double value)\n+        throws MatrixIndexException;\n+\n+    /** {@inheritDoc} */\n+    public abstract void addToEntry(int row, int column, double increment)\n+        throws MatrixIndexException;\n+\n+    /** {@inheritDoc} */\n+    public abstract void multiplyEntry(int row, int column, double factor)\n+        throws MatrixIndexException;\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix transpose() {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        final RealMatrix out = createMatrix(nCols, nRows);\n+        walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n+\n+            /** {@inheritDoc} */\n+            @Override\n+            public void visit(final int row, final int column, final double value) {\n+                out.setEntry(column, row, value);\n+            }\n+\n+        });\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public RealMatrix inverse()\n+        throws InvalidMatrixException {\n+        if (lu == null) {\n+            lu = new LUDecompositionImpl(this, MathUtils.SAFE_MIN).getSolver();\n+        }\n+        return lu.getInverse();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double getDeterminant()\n+        throws InvalidMatrixException {\n+        return new LUDecompositionImpl(this, MathUtils.SAFE_MIN).getDeterminant();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSquare() {\n+        return (getColumnDimension() == getRowDimension());\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public boolean isSingular() {\n+        if (lu == null) {\n+            lu = new LUDecompositionImpl(this, MathUtils.SAFE_MIN).getSolver();\n+       }\n+        return !lu.isNonSingular();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public abstract int getRowDimension();\n+\n+    /** {@inheritDoc} */\n+    public abstract int getColumnDimension();\n+\n+    /** {@inheritDoc} */\n+    public double getTrace()\n+        throws NonSquareMatrixException {\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (nRows != nCols) {\n+            throw new NonSquareMatrixException(nRows, nCols);\n+       }\n+        double trace = 0;\n+        for (int i = 0; i < nRows; ++i) {\n+            trace += getEntry(i, i);\n+        }\n+        return trace;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] operate(final double[] v)\n+        throws IllegalArgumentException {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (v.length != nCols) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nCols);\n+        }\n+\n+        final double[] out = new double[nRows];\n+        for (int row = 0; row < nRows; ++row) {\n+            double sum = 0;\n+            for (int i = 0; i < nCols; ++i) {\n+                sum += getEntry(row, i) * v[i];\n+            }\n+            out[row] = sum;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector operate(final RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return new ArrayRealVector(operate(((ArrayRealVector) v).getDataRef()), false);\n+        } catch (ClassCastException cce) {\n+            final int nRows = getRowDimension();\n+            final int nCols = getColumnDimension();\n+            if (v.getDimension() != nCols) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"vector length mismatch: got {0} but expected {1}\",\n+                        v.getDimension(), nCols);\n+            }\n+\n+            final double[] out = new double[nRows];\n+            for (int row = 0; row < nRows; ++row) {\n+                double sum = 0;\n+                for (int i = 0; i < nCols; ++i) {\n+                    sum += getEntry(row, i) * v.getEntry(i);\n+                }\n+                out[row] = sum;\n+            }\n+\n+            return new ArrayRealVector(out, false);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] preMultiply(final double[] v)\n+        throws IllegalArgumentException {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (v.length != nRows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nRows);\n+        }\n+\n+        final double[] out = new double[nCols];\n+        for (int col = 0; col < nCols; ++col) {\n+            double sum = 0;\n+            for (int i = 0; i < nRows; ++i) {\n+                sum += getEntry(i, col) * v[i];\n+            }\n+            out[col] = sum;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector preMultiply(final RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return new ArrayRealVector(preMultiply(((ArrayRealVector) v).getDataRef()), false);\n+        } catch (ClassCastException cce) {\n+\n+            final int nRows = getRowDimension();\n+            final int nCols = getColumnDimension();\n+            if (v.getDimension() != nRows) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"vector length mismatch: got {0} but expected {1}\",\n+                        v.getDimension(), nRows);\n+            }\n+\n+            final double[] out = new double[nCols];\n+            for (int col = 0; col < nCols; ++col) {\n+                double sum = 0;\n+                for (int i = 0; i < nRows; ++i) {\n+                    sum += getEntry(i, col) * v.getEntry(i);\n+                }\n+                out[col] = sum;\n+            }\n+\n+            return new ArrayRealVector(out);\n+\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int row = 0; row < rows; ++row) {\n+            for (int column = 0; column < columns; ++column) {\n+                final double oldValue = getEntry(row, column);\n+                final double newValue = visitor.visit(row, column, oldValue);\n+                setEntry(row, column, newValue);\n+            }\n+        }\n+        lu = null;\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int row = 0; row < rows; ++row) {\n+            for (int column = 0; column < columns; ++column) {\n+                visitor.visit(row, column, getEntry(row, column));\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int row = startRow; row <= endRow; ++row) {\n+            for (int column = startColumn; column <= endColumn; ++column) {\n+                final double oldValue = getEntry(row, column);\n+                final double newValue = visitor.visit(row, column, oldValue);\n+                setEntry(row, column, newValue);\n+            }\n+        }\n+        lu = null;\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int row = startRow; row <= endRow; ++row) {\n+            for (int column = startColumn; column <= endColumn; ++column) {\n+                visitor.visit(row, column, getEntry(row, column));\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int column = 0; column < columns; ++column) {\n+            for (int row = 0; row < rows; ++row) {\n+                final double oldValue = getEntry(row, column);\n+                final double newValue = visitor.visit(row, column, oldValue);\n+                setEntry(row, column, newValue);\n+            }\n+        }\n+        lu = null;\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int column = 0; column < columns; ++column) {\n+            for (int row = 0; row < rows; ++row) {\n+                visitor.visit(row, column, getEntry(row, column));\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,\n+                                    final int startRow, final int endRow,\n+                                    final int startColumn, final int endColumn)\n+    throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int column = startColumn; column <= endColumn; ++column) {\n+            for (int row = startRow; row <= endRow; ++row) {\n+                final double oldValue = getEntry(row, column);\n+                final double newValue = visitor.visit(row, column, oldValue);\n+                setEntry(row, column, newValue);\n+            }\n+        }\n+        lu = null;\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,\n+                                    final int startRow, final int endRow,\n+                                    final int startColumn, final int endColumn)\n+    throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int column = startColumn; column <= endColumn; ++column) {\n+            for (int row = startRow; row <= endRow; ++row) {\n+                visitor.visit(row, column, getEntry(row, column));\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        return walkInRowOrder(visitor);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        return walkInRowOrder(visitor);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public double[] solve(final double[] b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+        if (lu == null) {\n+            lu = new LUDecompositionImpl(this, MathUtils.SAFE_MIN).getSolver();\n+        }\n+        return lu.solve(b);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Deprecated\n+    public RealMatrix solve(final RealMatrix b)\n+        throws IllegalArgumentException, InvalidMatrixException  {\n+        if (lu == null) {\n+            lu = new LUDecompositionImpl(this, MathUtils.SAFE_MIN).getSolver();\n+        }\n+        return lu.solve(b);\n+    }\n+\n+    /**\n+     * Computes a new\n+     * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n+     * LU decomposition</a> for this matrix, storing the result for use by other methods.\n+     * <p>\n+     * <strong>Implementation Note</strong>:<br>\n+     * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/people/sd/lectures/nummeth98/linear.htm\">\n+     * Crout's algorithm</a>, with partial pivoting.</p>\n+     * <p>\n+     * <strong>Usage Note</strong>:<br>\n+     * This method should rarely be invoked directly. Its only use is\n+     * to force recomputation of the LU decomposition when changes have been\n+     * made to the underlying data using direct array references. Changes\n+     * made using setXxx methods will trigger recomputation when needed\n+     * automatically.</p>\n+     *\n+     * @throws InvalidMatrixException if the matrix is non-square or singular.\n+     * @deprecated as of release 2.0, replaced by {@link LUDecomposition}\n+     */\n+    @Deprecated\n+    public void luDecompose()\n+        throws InvalidMatrixException {\n+        if (lu == null) {\n+            lu = new LUDecompositionImpl(this, MathUtils.SAFE_MIN).getSolver();\n+        }\n+    }\n+\n+    /**\n+     * Get a string representation for this matrix.\n+     * @return a string representation for this matrix\n+     */\n+    @Override\n+    public String toString() {\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        final StringBuffer res = new StringBuffer();\n+        String fullClassName = getClass().getName();\n+        String shortClassName = fullClassName.substring(fullClassName.lastIndexOf('.') + 1);\n+        res.append(shortClassName).append(\"{\");\n+\n+        for (int i = 0; i < nRows; ++i) {\n+            if (i > 0) {\n+                res.append(\",\");\n+            }\n+            res.append(\"{\");\n+            for (int j = 0; j < nCols; ++j) {\n+                if (j > 0) {\n+                    res.append(\",\");\n+                }\n+                res.append(getEntry(i, j));\n+            } \n+            res.append(\"}\");\n+        } \n+\n+        res.append(\"}\");\n+        return res.toString();\n+\n+    } \n+    \n+    /**\n+     * Returns true iff <code>object</code> is a\n+     * <code>RealMatrix</code> instance with the same dimensions as this\n+     * and all corresponding matrix entries are equal.\n+     * \n+     * @param object the object to test equality against.\n+     * @return true if object equals this\n+     */\n+    @Override\n+    public boolean equals(final Object object) {\n+        if (object == this ) {\n+            return true;\n+        }\n+        if (object instanceof RealMatrix == false) {\n+            return false;\n+        }\n+        RealMatrix m = (RealMatrix) object;\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {\n+            return false;\n+        }\n+        for (int row = 0; row < nRows; ++row) {\n+            for (int col = 0; col < nCols; ++col) {\n+                if (getEntry(row, col) != m.getEntry(row, col)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Computes a hashcode for the matrix.\n+     * \n+     * @return hashcode for matrix\n+     */\n+    @Override\n+    public int hashCode() {\n+        int ret = 7;\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        ret = ret * 31 + nRows;\n+        ret = ret * 31 + nCols;\n+        for (int row = 0; row < nRows; ++row) {\n+            for (int col = 0; col < nCols; ++col) {\n+               ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * \n+                   MathUtils.hash(getEntry(row, col));\n+           }\n+        }\n+        return ret;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/AnyMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+\n+/**\n+ * Interface defining very basic matrix operations.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface AnyMatrix {\n+\n+    /**\n+     * Is this a square matrix?\n+     * @return true if the matrix is square (rowDimension = columnDimension)\n+     */\n+    boolean isSquare();\n+\n+    /**\n+     * Returns the number of rows in the matrix.\n+     *\n+     * @return rowDimension\n+     */\n+    int getRowDimension();\n+\n+    /**\n+     * Returns the number of columns in the matrix.\n+     *\n+     * @return columnDimension\n+     */\n+    int getColumnDimension();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Implementation of FieldMatrix<T> using a {@link FieldElement}[][] array to store entries.\n+ * <p>\n+ * As specified in the {@link FieldMatrix} interface, matrix element indexing\n+ * is 0-based -- e.g., <code>getEntry(0, 0)</code>\n+ * returns the element in the first row, first column of the matrix.</li></ul>\n+ * </p>\n+ *\n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ */\n+public class Array2DRowFieldMatrix<T extends FieldElement<T>> extends AbstractFieldMatrix<T> implements Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 7260756672015356458L;\n+\n+    /** Entries of the matrix */\n+    protected T[][] data;\n+\n+    /**\n+     * Creates a matrix with no data\n+     * @param field field to which the elements belong\n+     */\n+    public Array2DRowFieldMatrix(final Field<T> field) {\n+        super(field);\n+    }\n+\n+    /**\n+     * Create a new FieldMatrix<T> with the supplied row and column dimensions.\n+     *\n+     * @param field field to which the elements belong\n+     * @param rowDimension  the number of rows in the new matrix\n+     * @param columnDimension  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not\n+     *  positive\n+     */\n+    public Array2DRowFieldMatrix(final Field<T> field,\n+                           final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        super(field, rowDimension, columnDimension);\n+        data = buildArray(field, rowDimension, columnDimension);\n+    }\n+\n+    /**\n+     * Create a new FieldMatrix<T> using the input array as the underlying\n+     * data array.\n+     * <p>The input array is copied, not referenced. This constructor has\n+     * the same effect as calling {@link #Array2DRowFieldMatrix(FieldElement[][], boolean)}\n+     * with the second argument set to <code>true</code>.</p>\n+     *\n+     * @param d data for new matrix\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #Array2DRowFieldMatrix(FieldElement[][], boolean)\n+     */\n+    public Array2DRowFieldMatrix(final T[][] d)\n+        throws IllegalArgumentException, NullPointerException {\n+        super(extractField(d));\n+        copyIn(d);\n+    }\n+\n+    /**\n+     * Create a new FieldMatrix<T> using the input array as the underlying\n+     * data array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * FieldMatrix<T> and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param d data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #Array2DRowFieldMatrix(FieldElement[][])\n+     */\n+    public Array2DRowFieldMatrix(final T[][] d, final boolean copyArray)\n+        throws IllegalArgumentException, NullPointerException {\n+        super(extractField(d));\n+        if (copyArray) {\n+            copyIn(d);\n+        } else {\n+            if (d == null) {\n+                throw new NullPointerException();\n+            }   \n+            final int nRows = d.length;\n+            if (nRows == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            }\n+            final int nCols = d[0].length;\n+            if (nCols == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            }\n+            for (int r = 1; r < nRows; r++) {\n+                if (d[r].length != nCols) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"some rows have length {0} while others have length {1}\",\n+                            nCols, d[r].length);\n+                }\n+            }       \n+            data = d;\n+        }\n+    }\n+\n+    /**\n+     * Create a new (column) FieldMatrix<T> using <code>v</code> as the\n+     * data for the unique column of the <code>v.length x 1</code> matrix\n+     * created.\n+     * <p>The input array is copied, not referenced.</p>\n+     *\n+     * @param v column vector holding data for new matrix\n+     */\n+    public Array2DRowFieldMatrix(final T[] v) {\n+        super(extractField(v));\n+        final int nRows = v.length;\n+        data = buildArray(getField(), nRows, 1);\n+        for (int row = 0; row < nRows; row++) {\n+            data[row][0] = v[row];\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        return new Array2DRowFieldMatrix<T>(getField(), rowDimension, columnDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> copy() {\n+        return new Array2DRowFieldMatrix<T>(copyOut(), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> add(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        try {\n+            return add((Array2DRowFieldMatrix<T>) m);\n+        } catch (ClassCastException cce) {\n+            return super.add(m);\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public Array2DRowFieldMatrix<T> add(final Array2DRowFieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkAdditionCompatible(m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final T[][] outData = buildArray(getField(), rowCount, columnCount);\n+        for (int row = 0; row < rowCount; row++) {\n+            final T[] dataRow    = data[row];\n+            final T[] mRow       = m.data[row];\n+            final T[] outDataRow = outData[row];\n+            for (int col = 0; col < columnCount; col++) {\n+                outDataRow[col] = dataRow[col].add(mRow[col]);\n+            }\n+        }\n+\n+        return new Array2DRowFieldMatrix<T>(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> subtract(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        try {\n+            return subtract((Array2DRowFieldMatrix<T>) m);\n+        } catch (ClassCastException cce) {\n+            return super.subtract(m);\n+        }\n+    }\n+\n+    /**\n+     * Compute  this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public Array2DRowFieldMatrix<T> subtract(final Array2DRowFieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkSubtractionCompatible(m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final T[][] outData = buildArray(getField(), rowCount, columnCount);\n+        for (int row = 0; row < rowCount; row++) {\n+            final T[] dataRow    = data[row];\n+            final T[] mRow       = m.data[row];\n+            final T[] outDataRow = outData[row];\n+            for (int col = 0; col < columnCount; col++) {\n+                outDataRow[col] = dataRow[col].subtract(mRow[col]);\n+            }\n+        }\n+\n+        return new Array2DRowFieldMatrix<T>(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> multiply(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        try {\n+            return multiply((Array2DRowFieldMatrix<T>) m);\n+        } catch (ClassCastException cce) {\n+            return super.multiply(m);\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by <code>m</code>.\n+     * @param m    matrix to postmultiply by\n+     * @return     this*m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public Array2DRowFieldMatrix<T> multiply(final Array2DRowFieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkMultiplicationCompatible(m);\n+\n+        final int nRows = this.getRowDimension();\n+        final int nCols = m.getColumnDimension();\n+        final int nSum = this.getColumnDimension();\n+        final T[][] outData = buildArray(getField(), nRows, nCols);\n+        for (int row = 0; row < nRows; row++) {\n+            final T[] dataRow    = data[row];\n+            final T[] outDataRow = outData[row];\n+            for (int col = 0; col < nCols; col++) {\n+                T sum = getField().getZero();\n+                for (int i = 0; i < nSum; i++) {\n+                    sum = sum.add(dataRow[i].multiply(m.data[i][col]));\n+                }\n+                outDataRow[col] = sum;\n+            }\n+        }\n+\n+        return new Array2DRowFieldMatrix<T>(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[][] getData() {\n+        return copyOut();\n+    }\n+\n+    /**\n+     * Returns a reference to the underlying data array.\n+     * <p>\n+     * Does <strong>not</strong> make a fresh copy of the underlying data.</p>\n+     *\n+     * @return 2-dimensional array of entries\n+     */\n+    public T[][] getDataRef() {\n+        return data;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setSubMatrix(final T[][] subMatrix, final int row, final int column) \n+    throws MatrixIndexException {\n+        if (data == null) {\n+            if (row > 0) {\n+                throw MathRuntimeException.createIllegalStateException(\n+                        \"first {0} rows are not initialized yet\",\n+                        row);\n+            }\n+            if (column > 0) {\n+                throw MathRuntimeException.createIllegalStateException(\n+                        \"first {0} columns are not initialized yet\",\n+                        column);\n+            }\n+            final int nRows = subMatrix.length;\n+            if (nRows == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            }\n+\n+            final int nCols = subMatrix[0].length;\n+            if (nCols == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            }\n+            data = buildArray(getField(), subMatrix.length, nCols);\n+            for (int i = 0; i < data.length; ++i) {\n+                if (subMatrix[i].length != nCols) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"some rows have length {0} while others have length {1}\",\n+                            nCols, subMatrix[i].length); \n+                }\n+                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n+            }\n+        } else {\n+            super.setSubMatrix(subMatrix, row, column);\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T getEntry(final int row, final int column)\n+        throws MatrixIndexException {\n+        try {\n+            return data[row][column];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(final int row, final int column, final T value)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] = value;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(final int row, final int column, final T increment)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] = data[row][column].add(increment);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }      \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(final int row, final int column, final T factor)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] = data[row][column].multiply(factor);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }      \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return (data == null) ? 0 : data.length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[] operate(final T[] v)\n+        throws IllegalArgumentException {\n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n+        if (v.length != nCols) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nCols);\n+        }\n+        final T[] out = buildArray(getField(), nRows);\n+        for (int row = 0; row < nRows; row++) {\n+            final T[] dataRow = data[row];\n+            T sum = getField().getZero();\n+            for (int i = 0; i < nCols; i++) {\n+                sum = sum.add(dataRow[i].multiply(v[i]));\n+            }\n+            out[row] = sum;\n+        }\n+        return out;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[] preMultiply(final T[] v)\n+        throws IllegalArgumentException {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (v.length != nRows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nRows);\n+        }\n+\n+        final T[] out = buildArray(getField(), nCols);\n+        for (int col = 0; col < nCols; ++col) {\n+            T sum = getField().getZero();\n+            for (int i = 0; i < nRows; ++i) {\n+                sum = sum.add(data[i][col].multiply(v[i]));\n+            }\n+            out[col] = sum;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int i = 0; i < rows; ++i) {\n+            final T[] rowI = data[i];\n+            for (int j = 0; j < columns; ++j) {\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int i = 0; i < rows; ++i) {\n+            final T[] rowI = data[i];\n+            for (int j = 0; j < columns; ++j) {\n+                visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor,\n+                            final int startRow, final int endRow,\n+                            final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int i = startRow; i <= endRow; ++i) {\n+            final T[] rowI = data[i];\n+            for (int j = startColumn; j <= endColumn; ++j) {\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n+                            final int startRow, final int endRow,\n+                            final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int i = startRow; i <= endRow; ++i) {\n+            final T[] rowI = data[i];\n+            for (int j = startColumn; j <= endColumn; ++j) {\n+                visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInColumnOrder(final FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int j = 0; j < columns; ++j) {\n+            for (int i = 0; i < rows; ++i) {\n+                final T[] rowI = data[i];\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInColumnOrder(final FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int j = 0; j < columns; ++j) {\n+            for (int i = 0; i < rows; ++i) {\n+                visitor.visit(i, j, data[i][j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInColumnOrder(final FieldMatrixChangingVisitor<T> visitor,\n+                               final int startRow, final int endRow,\n+                               final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int j = startColumn; j <= endColumn; ++j) {\n+            for (int i = startRow; i <= endRow; ++i) {\n+                final T[] rowI = data[i];\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInColumnOrder(final FieldMatrixPreservingVisitor<T> visitor,\n+                               final int startRow, final int endRow,\n+                               final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int j = startColumn; j <= endColumn; ++j) {\n+            for (int i = startRow; i <= endRow; ++i) {\n+                visitor.visit(i, j, data[i][j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /**\n+     * Returns a fresh copy of the underlying data array.\n+     *\n+     * @return a copy of the underlying data array.\n+     */\n+    private T[][] copyOut() {\n+        final int nRows = this.getRowDimension();\n+        final T[][] out = buildArray(getField(), nRows, getColumnDimension());\n+        // can't copy 2-d array in one shot, otherwise get row references\n+        for (int i = 0; i < nRows; i++) {\n+            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n+        }\n+        return out;\n+    }\n+\n+    /**\n+     * Replaces data with a fresh copy of the input array.\n+     * <p>\n+     * Verifies that the input array is rectangular and non-empty.</p>\n+     *\n+     * @param in data to copy in\n+     * @throws IllegalArgumentException if input array is empty or not\n+     *    rectangular\n+     * @throws NullPointerException if input array is null\n+     */\n+    private void copyIn(final T[][] in) {\n+        setSubMatrix(in, 0, 0);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/Array2DRowRealMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Implementation of RealMatrix using a double[][] array to store entries and\n+ * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n+ * LU decomposition</a> to support linear system\n+ * solution and inverse.\n+ * <p>\n+ * The LU decomposition is performed as needed, to support the following operations: <ul>\n+ * <li>solve</li>\n+ * <li>isSingular</li>\n+ * <li>getDeterminant</li>\n+ * <li>inverse</li> </ul></p>\n+ * <p>\n+ * <strong>Usage notes</strong>:<br>\n+ * <ul><li>\n+ * The LU decomposition is cached and reused on subsequent calls.   \n+ * If data are modified via references to the underlying array obtained using\n+ * <code>getDataRef()</code>, then the stored LU decomposition will not be\n+ * discarded.  In this case, you need to explicitly invoke \n+ * <code>LUDecompose()</code> to recompute the decomposition\n+ * before using any of the methods above.</li>\n+ * <li>\n+ * As specified in the {@link RealMatrix} interface, matrix element indexing\n+ * is 0-based -- e.g., <code>getEntry(0, 0)</code>\n+ * returns the element in the first row, first column of the matrix.</li></ul>\n+ * </p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class Array2DRowRealMatrix extends AbstractRealMatrix implements Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -1067294169172445528L;\n+\n+    /** Entries of the matrix */\n+    protected double data[][];\n+\n+    /**\n+     * Creates a matrix with no data\n+     */\n+    public Array2DRowRealMatrix() {\n+    }\n+\n+    /**\n+     * Create a new RealMatrix with the supplied row and column dimensions.\n+     *\n+     * @param rowDimension  the number of rows in the new matrix\n+     * @param columnDimension  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not\n+     *  positive\n+     */\n+    public Array2DRowRealMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        super(rowDimension, columnDimension);\n+        data = new double[rowDimension][columnDimension];\n+    }\n+\n+    /**\n+     * Create a new RealMatrix using the input array as the underlying\n+     * data array.\n+     * <p>The input array is copied, not referenced. This constructor has\n+     * the same effect as calling {@link #Array2DRowRealMatrix(double[][], boolean)}\n+     * with the second argument set to <code>true</code>.</p>\n+     *\n+     * @param d data for new matrix\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #Array2DRowRealMatrix(double[][], boolean)\n+     */\n+    public Array2DRowRealMatrix(final double[][] d)\n+        throws IllegalArgumentException, NullPointerException {\n+        copyIn(d);\n+    }\n+\n+    /**\n+     * Create a new RealMatrix using the input array as the underlying\n+     * data array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * RealMatrix and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param d data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #Array2DRowRealMatrix(double[][])\n+     */\n+    public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\n+        throws IllegalArgumentException, NullPointerException {\n+        if (copyArray) {\n+            copyIn(d);\n+        } else {\n+            if (d == null) {\n+                throw new NullPointerException();\n+            }   \n+            final int nRows = d.length;\n+            if (nRows == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            }\n+            final int nCols = d[0].length;\n+            if (nCols == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            }\n+            for (int r = 1; r < nRows; r++) {\n+                if (d[r].length != nCols) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"some rows have length {0} while others have length {1}\",\n+                            nCols, d[r].length);\n+                }\n+            }       \n+            data = d;\n+        }\n+    }\n+\n+    /**\n+     * Create a new (column) RealMatrix using <code>v</code> as the\n+     * data for the unique column of the <code>v.length x 1</code> matrix\n+     * created.\n+     * <p>The input array is copied, not referenced.</p>\n+     *\n+     * @param v column vector holding data for new matrix\n+     */\n+    public Array2DRowRealMatrix(final double[] v) {\n+        final int nRows = v.length;\n+        data = new double[nRows][1];\n+        for (int row = 0; row < nRows; row++) {\n+            data[row][0] = v[row];\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix createMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        return new Array2DRowRealMatrix(rowDimension, columnDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix copy() {\n+        return new Array2DRowRealMatrix(copyOut(), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix add(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return add((Array2DRowRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+            return super.add(m);\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public Array2DRowRealMatrix add(final Array2DRowRealMatrix m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkAdditionCompatible(this, m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final double[][] outData = new double[rowCount][columnCount];\n+        for (int row = 0; row < rowCount; row++) {\n+            final double[] dataRow    = data[row];\n+            final double[] mRow       = m.data[row];\n+            final double[] outDataRow = outData[row];\n+            for (int col = 0; col < columnCount; col++) {\n+                outDataRow[col] = dataRow[col] + mRow[col];\n+            }\n+        }\n+\n+        return new Array2DRowRealMatrix(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix subtract(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return subtract((Array2DRowRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+            return super.subtract(m);\n+        }\n+    }\n+\n+    /**\n+     * Compute  this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public Array2DRowRealMatrix subtract(final Array2DRowRealMatrix m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkSubtractionCompatible(this, m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final double[][] outData = new double[rowCount][columnCount];\n+        for (int row = 0; row < rowCount; row++) {\n+            final double[] dataRow    = data[row];\n+            final double[] mRow       = m.data[row];\n+            final double[] outDataRow = outData[row];\n+            for (int col = 0; col < columnCount; col++) {\n+                outDataRow[col] = dataRow[col] - mRow[col];\n+            }\n+        }\n+\n+        return new Array2DRowRealMatrix(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix multiply(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return multiply((Array2DRowRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+            return super.multiply(m);\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by <code>m</code>.\n+     * @param m    matrix to postmultiply by\n+     * @return     this*m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public Array2DRowRealMatrix multiply(final Array2DRowRealMatrix m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkMultiplicationCompatible(this, m);\n+\n+        final int nRows = this.getRowDimension();\n+        final int nCols = m.getColumnDimension();\n+        final int nSum = this.getColumnDimension();\n+        final double[][] outData = new double[nRows][nCols];\n+        for (int row = 0; row < nRows; row++) {\n+            final double[] dataRow    = data[row];\n+            final double[] outDataRow = outData[row];\n+            for (int col = 0; col < nCols; col++) {\n+                double sum = 0;\n+                for (int i = 0; i < nSum; i++) {\n+                    sum += dataRow[i] * m.data[i][col];\n+                }\n+                outDataRow[col] = sum;\n+            }\n+        }\n+\n+        return new Array2DRowRealMatrix(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[][] getData() {\n+        return copyOut();\n+    }\n+\n+    /**\n+     * Returns a reference to the underlying data array.\n+     * <p>\n+     * Does <strong>not</strong> make a fresh copy of the underlying data.</p>\n+     *\n+     * @return 2-dimensional array of entries\n+     */\n+    public double[][] getDataRef() {\n+        return data;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setSubMatrix(final double[][] subMatrix, final int row, final int column) \n+    throws MatrixIndexException {\n+        if (data == null) {\n+            if (row > 0) {\n+                throw MathRuntimeException.createIllegalStateException(\n+                        \"first {0} rows are not initialized yet\",\n+                        row);\n+            }\n+            if (column > 0) {\n+                throw MathRuntimeException.createIllegalStateException(\n+                        \"first {0} columns are not initialized yet\",\n+                        column);\n+            }\n+            final int nRows = subMatrix.length;\n+            if (nRows == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            }\n+\n+            final int nCols = subMatrix[0].length;\n+            if (nCols == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            }\n+            data = new double[subMatrix.length][nCols];\n+            for (int i = 0; i < data.length; ++i) {\n+                if (subMatrix[i].length != nCols) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"some rows have length {0} while others have length {1}\",\n+                            nCols, subMatrix[i].length); \n+                }\n+                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n+            }\n+        } else {\n+            super.setSubMatrix(subMatrix, row, column);\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double getEntry(final int row, final int column)\n+        throws MatrixIndexException {\n+        try {\n+            return data[row][column];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(final int row, final int column, final double value)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] = value;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(final int row, final int column, final double increment)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] += increment;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }      \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(final int row, final int column, final double factor)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] *= factor;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }      \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return (data == null) ? 0 : data.length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[] operate(final double[] v)\n+        throws IllegalArgumentException {\n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n+        if (v.length != nCols) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nCols);\n+        }\n+        final double[] out = new double[nRows];\n+        for (int row = 0; row < nRows; row++) {\n+            final double[] dataRow = data[row];\n+            double sum = 0;\n+            for (int i = 0; i < nCols; i++) {\n+                sum += dataRow[i] * v[i];\n+            }\n+            out[row] = sum;\n+        }\n+        return out;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[] preMultiply(final double[] v)\n+        throws IllegalArgumentException {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (v.length != nRows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nRows);\n+        }\n+\n+        final double[] out = new double[nCols];\n+        for (int col = 0; col < nCols; ++col) {\n+            double sum = 0;\n+            for (int i = 0; i < nRows; ++i) {\n+                sum += data[i][col] * v[i];\n+            }\n+            out[col] = sum;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int i = 0; i < rows; ++i) {\n+            final double[] rowI = data[i];\n+            for (int j = 0; j < columns; ++j) {\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int i = 0; i < rows; ++i) {\n+            final double[] rowI = data[i];\n+            for (int j = 0; j < columns; ++j) {\n+                visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int i = startRow; i <= endRow; ++i) {\n+            final double[] rowI = data[i];\n+            for (int j = startColumn; j <= endColumn; ++j) {\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int i = startRow; i <= endRow; ++i) {\n+            final double[] rowI = data[i];\n+            for (int j = startColumn; j <= endColumn; ++j) {\n+                visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int j = 0; j < columns; ++j) {\n+            for (int i = 0; i < rows; ++i) {\n+                final double[] rowI = data[i];\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int j = 0; j < columns; ++j) {\n+            for (int i = 0; i < rows; ++i) {\n+                visitor.visit(i, j, data[i][j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,\n+                                    final int startRow, final int endRow,\n+                                    final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int j = startColumn; j <= endColumn; ++j) {\n+            for (int i = startRow; i <= endRow; ++i) {\n+                final double[] rowI = data[i];\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,\n+                                    final int startRow, final int endRow,\n+                                    final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int j = startColumn; j <= endColumn; ++j) {\n+            for (int i = startRow; i <= endRow; ++i) {\n+                visitor.visit(i, j, data[i][j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /**\n+     * Returns a fresh copy of the underlying data array.\n+     *\n+     * @return a copy of the underlying data array.\n+     */\n+    private double[][] copyOut() {\n+        final int nRows = this.getRowDimension();\n+        final double[][] out = new double[nRows][this.getColumnDimension()];\n+        // can't copy 2-d array in one shot, otherwise get row references\n+        for (int i = 0; i < nRows; i++) {\n+            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n+        }\n+        return out;\n+    }\n+\n+    /**\n+     * Replaces data with a fresh copy of the input array.\n+     * <p>\n+     * Verifies that the input array is rectangular and non-empty.</p>\n+     *\n+     * @param in data to copy in\n+     * @throws IllegalArgumentException if input array is empty or not\n+     *    rectangular\n+     * @throws NullPointerException if input array is null\n+     */\n+    private void copyIn(final double[][] in) {\n+        setSubMatrix(in, 0, 0);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayFieldVector.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * This class implements the {@link FieldVector} interface with a {@link FieldElement} array.\n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class ArrayFieldVector<T extends FieldElement<T>> implements FieldVector<T>, Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 7648186910365927050L;\n+\n+    /** Field to which the elements belong. */\n+    private final Field<T> field;\n+\n+    /** Entries of the vector. */\n+    protected T[] data;\n+\n+    /** Build an array of elements.\n+     * @param length size of the array to build\n+     * @return a new array\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private T[] buildArray(final int length) {\n+        return (T[]) Array.newInstance(field.getZero().getClass(), length);\n+    }\n+\n+    /**\n+     * Build a 0-length vector.\n+     * <p>Zero-length vectors may be used to initialized construction of vectors\n+     * by data gathering. We start with zero-length and use either the {@link\n+     * #ArrayFieldVector(ArrayFieldVector, ArrayFieldVector)} constructor\n+     * or one of the <code>append</code> methods ({@link #append(FieldElement[])},\n+     * {@link #add(FieldVector)}, {@link #append(ArrayFieldVector)}) to gather data\n+     * into this vector.</p>\n+     * @param field field to which the elements belong\n+     */\n+    public ArrayFieldVector(final Field<T> field) {\n+        this(field, 0);\n+    }\n+\n+    /**\n+     * Construct a (size)-length vector of zeros.\n+     * @param field field to which the elements belong\n+     * @param size size of the vector\n+     */\n+    public ArrayFieldVector(Field<T> field, int size) {\n+        this.field = field;\n+        data = buildArray(size);\n+        Arrays.fill(data, field.getZero());\n+    }\n+\n+    /**\n+     * Construct an (size)-length vector with preset values.\n+     * @param size size of the vector\n+     * @param preset fill the vector with this scalar value\n+     */\n+    public ArrayFieldVector(int size, T preset) {\n+        this(preset.getField(), size);\n+        Arrays.fill(data, preset);\n+    }\n+\n+    /**\n+     * Construct a vector from an array, copying the input array.\n+     * @param d array of Ts.\n+     * @throws IllegalArgumentException if <code>d</code> is empty\n+     */\n+    public ArrayFieldVector(T[] d)\n+        throws IllegalArgumentException {\n+        try {\n+            field = d[0].getField();\n+            data = d.clone();\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                      \"vector must have at least one element\"); \n+        }\n+    }\n+\n+    /**\n+     * Create a new ArrayFieldVector using the input array as the underlying\n+     * data array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * ArrayFieldVector and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param d data for new vector\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @throws IllegalArgumentException if <code>d</code> is empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #ArrayFieldVector(FieldElement[])\n+     */\n+    public ArrayFieldVector(T[] d, boolean copyArray)\n+        throws NullPointerException, IllegalArgumentException {\n+        try {\n+            field = d[0].getField();\n+            data = copyArray ? d.clone() :  d;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                      \"vector must have at least one element\");\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector from part of a array.\n+     * @param d array of Ts.\n+     * @param pos position of first entry\n+     * @param size number of entries to copy\n+     */\n+    public ArrayFieldVector(T[] d, int pos, int size) {\n+        if (d.length < pos + size) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"position {0} and size {1} don't fit to the size of the input array {2}\",\n+                    pos, size, d.length);\n+        }\n+        field = d[0].getField();\n+        data = buildArray(size);\n+        System.arraycopy(d, pos, data, 0, size);\n+    }\n+\n+    /**\n+     * Construct a vector from another vector, using a deep copy.\n+     * @param v vector to copy\n+     */\n+    public ArrayFieldVector(FieldVector<T> v) {\n+        field = v.getField();\n+        data = buildArray(v.getDimension());\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = v.getEntry(i);\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector from another vector, using a deep copy.\n+     * @param v vector to copy\n+     */\n+    public ArrayFieldVector(ArrayFieldVector<T> v) {\n+        field = v.getField();\n+        data = v.data.clone();\n+    }\n+\n+    /**\n+     * Construct a vector from another vector.\n+     * @param v vector to copy\n+     * @param deep if true perform a deep copy otherwise perform a shallow copy\n+     */\n+    public ArrayFieldVector(ArrayFieldVector<T> v, boolean deep) {\n+        field = v.getField();\n+        data = deep ? v.data.clone() : v.data;\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public ArrayFieldVector(ArrayFieldVector<T> v1, ArrayFieldVector<T> v2) {\n+        field = v1.getField();\n+        data = buildArray(v1.data.length + v2.data.length);\n+        System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n+        System.arraycopy(v2.data, 0, data, v1.data.length, v2.data.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public ArrayFieldVector(ArrayFieldVector<T> v1, T[] v2) {\n+        field = v1.getField();\n+        data = buildArray(v1.data.length + v2.length);\n+        System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n+        System.arraycopy(v2, 0, data, v1.data.length, v2.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public ArrayFieldVector(T[] v1, ArrayFieldVector<T> v2) {\n+        field = v2.getField();\n+        data = buildArray(v1.length + v2.data.length);\n+        System.arraycopy(v1, 0, data, 0, v1.length);\n+        System.arraycopy(v2.data, 0, data, v1.length, v2.data.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     * @exception IllegalArgumentException if both vectors are empty\n+     */\n+    public ArrayFieldVector(T[] v1, T[] v2) {\n+        try {\n+            data = buildArray(v1.length + v2.length);\n+            System.arraycopy(v1, 0, data, 0, v1.length);\n+            System.arraycopy(v2, 0, data, v1.length, v2.length);\n+            field = data[0].getField();\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                      \"vector must have at least one element\");\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Field<T> getField() {\n+        return field;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> copy() {\n+        return new ArrayFieldVector<T>(this, true);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> add(FieldVector<T> v) throws IllegalArgumentException {\n+        try {\n+            return add((ArrayFieldVector<T>) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            T[] out = buildArray(data.length);\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i].add(v.getEntry(i));\n+            }\n+            return new ArrayFieldVector<T>(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> add(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].add(v[i]);\n+        }\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /**\n+     * Compute the sum of this and v.\n+     * @param v vector to be added\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayFieldVector<T> add(ArrayFieldVector<T> v)\n+        throws IllegalArgumentException {\n+        return (ArrayFieldVector<T>) add(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> subtract(FieldVector<T> v) throws IllegalArgumentException {\n+        try {\n+            return subtract((ArrayFieldVector<T>) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            T[] out = buildArray(data.length);\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i].subtract(v.getEntry(i));\n+            }\n+            return new ArrayFieldVector<T>(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> subtract(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].subtract(v[i]);\n+        }\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /**\n+     * Compute this minus v.\n+     * @param v vector to be subtracted\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayFieldVector<T> subtract(ArrayFieldVector<T> v)\n+        throws IllegalArgumentException {\n+        return (ArrayFieldVector<T>) subtract(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapAdd(T d) {\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].add(d);\n+        }\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapAddToSelf(T d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i].add(d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapSubtract(T d) {\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].subtract(d);\n+        }\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapSubtractToSelf(T d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i].subtract(d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapMultiply(T d) {\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].multiply(d);\n+        }\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapMultiplyToSelf(T d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i].multiply(d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapDivide(T d) {\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].divide(d);\n+        }\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapDivideToSelf(T d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i].divide(d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapInv() {\n+        T[] out = buildArray(data.length);\n+        final T one = field.getOne();\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = one.divide(data[i]);\n+        }\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> mapInvToSelf() {\n+        final T one = field.getOne();\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = one.divide(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> ebeMultiply(FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        try {\n+            return ebeMultiply((ArrayFieldVector<T>) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            T[] out = buildArray(data.length);\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i].multiply(v.getEntry(i));\n+            }\n+            return new ArrayFieldVector<T>(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> ebeMultiply(T[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i].multiply(v[i]);\n+        }\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /**\n+     * Element-by-element multiplication.\n+     * @param v vector by which instance elements must be multiplied\n+     * @return a vector containing this[i] * v[i] for all i\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayFieldVector<T> ebeMultiply(ArrayFieldVector<T> v)\n+        throws IllegalArgumentException {\n+        return (ArrayFieldVector<T>) ebeMultiply(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> ebeDivide(FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        try {\n+            return ebeDivide((ArrayFieldVector<T>) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            T[] out = buildArray(data.length);\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i].divide(v.getEntry(i));\n+            }\n+            return new ArrayFieldVector<T>(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> ebeDivide(T[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        T[] out = buildArray(data.length);\n+        for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i].divide(v[i]);\n+        }\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /**\n+     * Element-by-element division.\n+     * @param v vector by which instance elements must be divided\n+     * @return a vector containing this[i] / v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayFieldVector<T> ebeDivide(ArrayFieldVector<T> v)\n+        throws IllegalArgumentException {\n+        return (ArrayFieldVector<T>) ebeDivide(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T[] getData() {\n+        return data.clone();\n+    }\n+\n+    /**\n+     * Returns a reference to the underlying data array.\n+     * <p>Does not make a fresh copy of the underlying data.</p>\n+     * @return array of entries\n+     */\n+    public T[] getDataRef() {\n+        return data;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T dotProduct(FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        try {\n+            return dotProduct((ArrayFieldVector<T>) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            T dot = field.getZero();\n+            for (int i = 0; i < data.length; i++) {\n+                dot = dot.add(data[i].multiply(v.getEntry(i)));\n+            }\n+            return dot;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T dotProduct(T[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        T dot = field.getZero();\n+        for (int i = 0; i < data.length; i++) {\n+            dot = dot.add(data[i].multiply(v[i]));\n+        }\n+        return dot;\n+    }\n+\n+    /**\n+     * Compute the dot product.\n+     * @param v vector with which dot product should be computed\n+     * @return the scalar dot product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public T dotProduct(ArrayFieldVector<T> v)\n+        throws IllegalArgumentException {\n+        return dotProduct(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> projection(FieldVector<T> v) {\n+        return v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> projection(T[] v) {\n+        return projection(new ArrayFieldVector<T>(v, false));\n+    }\n+\n+   /** Find the orthogonal projection of this vector onto another vector.\n+     * @param v vector onto which instance must be projected\n+     * @return projection of the instance onto v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayFieldVector<T> projection(ArrayFieldVector<T> v) {\n+        return (ArrayFieldVector<T>) v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> outerProduct(FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        try {\n+            return outerProduct((ArrayFieldVector<T>) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            final int m = data.length;\n+            final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, m);\n+            for (int i = 0; i < data.length; i++) {\n+                for (int j = 0; j < data.length; j++) {\n+                    out.setEntry(i, j, data[i].multiply(v.getEntry(j)));\n+                }\n+            }\n+            return out;\n+        }\n+    }\n+\n+    /**\n+     * Compute the outer product.\n+     * @param v vector with which outer product should be computed\n+     * @return the square matrix outer product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public FieldMatrix<T> outerProduct(ArrayFieldVector<T> v)\n+        throws IllegalArgumentException {\n+        return outerProduct(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> outerProduct(T[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        final int m = data.length;\n+        final FieldMatrix<T> out = new Array2DRowFieldMatrix<T>(field, m, m);\n+        for (int i = 0; i < data.length; i++) {\n+            for (int j = 0; j < data.length; j++) {\n+                out.setEntry(i, j, data[i].multiply(v[j]));\n+            }\n+        }\n+        return out;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T getEntry(int index) throws MatrixIndexException {\n+        return data[index];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getDimension() {\n+        return data.length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> append(FieldVector<T> v) {\n+        try {\n+            return append((ArrayFieldVector<T>) v);\n+        } catch (ClassCastException cce) {\n+            return new ArrayFieldVector<T>(this,new ArrayFieldVector<T>(v));\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector by appending a vector to this vector.\n+     * @param v vector to append to this one.\n+     * @return a new vector\n+     */\n+    public ArrayFieldVector<T> append(ArrayFieldVector<T> v) {\n+        return new ArrayFieldVector<T>(this, v);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> append(T in) {\n+        final T[] out = buildArray(data.length + 1);\n+        System.arraycopy(data, 0, out, 0, data.length);\n+        out[data.length] = in;\n+        return new ArrayFieldVector<T>(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> append(T[] in) {\n+        return new ArrayFieldVector<T>(this, in);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> getSubVector(int index, int n) {\n+        ArrayFieldVector<T> out = new ArrayFieldVector<T>(field, n);\n+        try {\n+            System.arraycopy(data, index, out.data, 0, n);\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+            checkIndex(index + n - 1);\n+        }\n+        return out;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setEntry(int index, T value) {\n+        try {\n+            data[index] = value;\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, FieldVector<T> v) {\n+        try {\n+            try {\n+                set(index, (ArrayFieldVector<T>) v);\n+            } catch (ClassCastException cce) {\n+                for (int i = index; i < index + v.getDimension(); ++i) {\n+                    data[i] = v.getEntry(i-index);\n+                }\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+            checkIndex(index + v.getDimension() - 1);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, T[] v) {\n+        try {\n+            System.arraycopy(v, 0, data, index, v.length);\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+            checkIndex(index + v.length - 1);\n+        }\n+    }\n+\n+    /**\n+     * Set a set of consecutive elements.\n+     * \n+     * @param index index of first element to be set.\n+     * @param v vector containing the values to set.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     */\n+    public void set(int index, ArrayFieldVector<T> v)\n+        throws MatrixIndexException {\n+        setSubVector(index, v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(T value) {\n+        Arrays.fill(data, value);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T[] toArray(){\n+        return data.clone();\n+    }\n+\n+    /**\n+     * Check if instance and specified vectors have the same dimension.\n+     * @param v vector to compare instance with\n+     * @exception IllegalArgumentException if the vectors do not\n+     * have the same dimension\n+     */\n+    protected void checkVectorDimensions(FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+    }\n+\n+    /**\n+     * Check if instance dimension is equal to some expected value.\n+     * \n+     * @param n expected dimension.\n+     * @exception IllegalArgumentException if the dimension is\n+     * inconsistent with vector size\n+     */\n+    protected void checkVectorDimensions(int n)\n+        throws IllegalArgumentException {\n+        if (data.length != n) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    data.length, n);\n+        }\n+    }\n+\n+    /**\n+     * Test for the equality of two real vectors.\n+     * <p>\n+     * If all coordinates of two real vectors are exactly the same, and none are\n+     * <code>Double.NaN</code>, the two real vectors are considered to be equal.\n+     * </p>\n+     * <p>\n+     * <code>NaN</code> coordinates are considered to affect globally the vector\n+     * and be equals to each other - i.e, if either (or all) coordinates of the\n+     * real vector are equal to <code>Double.NaN</code>, the real vector is equal to\n+     * a vector with all <code>Double.NaN</code> coordinates.\n+     * </p>\n+     *\n+     * @param other Object to test for equality to this\n+     * @return true if two 3D vector objects are equal, false if\n+     *         object is null, not an instance of Vector3D, or\n+     *         not equal to this Vector3D instance\n+     * \n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public boolean equals(Object other) {\n+\n+      if (this == other) { \n+        return true;\n+      }\n+\n+      if (other == null) {\n+        return false;\n+      }\n+\n+      try {\n+\n+          FieldVector<T> rhs = (FieldVector<T>) other;\n+          if (data.length != rhs.getDimension()) {\n+              return false;\n+          }\n+\n+          for (int i = 0; i < data.length; ++i) {\n+              if (!data[i].equals(rhs.getEntry(i))) {\n+                  return false;\n+              }\n+          }\n+          return true;\n+\n+      } catch (ClassCastException ex) {\n+          // ignore exception\n+          return false;\n+      }\n+\n+    }\n+    \n+    /**\n+     * Get a hashCode for the real vector.\n+     * <p>All NaN values have the same hash code.</p>\n+     * @return a hash code value for this object\n+     */\n+    @Override\n+    public int hashCode() {\n+        int h = 3542;\n+        for (final T a : data) {\n+            h = h ^ a.hashCode();\n+        }\n+        return h;\n+    }\n+\n+    /**\n+     * Check if an index is valid.\n+     * @param index index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    private void checkIndex(final int index)\n+        throws MatrixIndexException {\n+        if (index < 0 || index >= getDimension()) {\n+            throw new MatrixIndexException(\n+                    \"index {0} out of allowed range [{1}, {2}]\",\n+                    index, 0, getDimension() - 1);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/ArrayRealVector.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * This class implements the {@link RealVector} interface with a double array.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class ArrayRealVector implements RealVector, Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -1097961340710804027L;\n+\n+    /** Default format. */\n+    private static final RealVectorFormat DEFAULT_FORMAT =\n+        RealVectorFormat.getInstance();\n+\n+    /** Entries of the vector. */\n+    protected double data[];\n+\n+    /**\n+     * Build a 0-length vector.\n+     * <p>Zero-length vectors may be used to initialized construction of vectors\n+     * by data gathering. We start with zero-length and use either the {@link\n+     * #ArrayRealVector(ArrayRealVector, ArrayRealVector)} constructor\n+     * or one of the <code>append</code> method ({@link #append(double)}, {@link\n+     * #append(double[])}, {@link #append(ArrayRealVector)}) to gather data\n+     * into this vector.</p>\n+     */\n+    public ArrayRealVector() {\n+        data = new double[0];\n+    }\n+\n+    /**\n+     * Construct a (size)-length vector of zeros.\n+     * @param size size of the vector\n+     */\n+    public ArrayRealVector(int size) {\n+        data = new double[size];\n+    }\n+\n+    /**\n+     * Construct an (size)-length vector with preset values.\n+     * @param size size of the vector\n+     * @param preset fill the vector with this scalar value\n+     */\n+    public ArrayRealVector(int size, double preset) {\n+        data = new double[size];\n+        Arrays.fill(data, preset);\n+    }\n+\n+    /**\n+     * Construct a vector from an array, copying the input array.\n+     * @param d array of doubles.\n+     */\n+    public ArrayRealVector(double[] d) {\n+        data = d.clone();\n+    }\n+\n+    /**\n+     * Create a new ArrayRealVector using the input array as the underlying\n+     * data array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * ArrayRealVector and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param d data for new vector\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @throws IllegalArgumentException if <code>d</code> is empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #ArrayRealVector(double[])\n+     */\n+    public ArrayRealVector(double[] d, boolean copyArray)\n+        throws NullPointerException, IllegalArgumentException {\n+        if (d == null) {\n+            throw new NullPointerException();\n+        }   \n+        if (d.length == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"vector must have at least one element\"); \n+        }\n+        data = copyArray ? d.clone() :  d;\n+    }\n+\n+    /**\n+     * Construct a vector from part of a array.\n+     * @param d array of doubles.\n+     * @param pos position of first entry\n+     * @param size number of entries to copy\n+     */\n+    public ArrayRealVector(double[] d, int pos, int size) {\n+        if (d.length < pos + size) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"position {0} and size {1} don't fit to the size of the input array {2}\",\n+                    pos, size, d.length);\n+        }\n+        data = new double[size];\n+        System.arraycopy(d, pos, data, 0, size);\n+    }\n+\n+    /**\n+     * Construct a vector from an array.\n+     * @param d array of Doubles.\n+     */\n+    public ArrayRealVector(Double[] d) {\n+        data = new double[d.length];\n+        for (int i = 0; i < d.length; i++) {\n+            data[i] = d[i].doubleValue();\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector from part of a Double array\n+     * @param d array of Doubles.\n+     * @param pos position of first entry\n+     * @param size number of entries to copy\n+     */\n+    public ArrayRealVector(Double[] d, int pos, int size) {\n+        if (d.length < pos + size) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"position {0} and size {1} don't fit to the size of the input array {2}\",\n+                    pos, size, d.length);\n+        }\n+        data = new double[size];\n+        for (int i = pos; i < pos + size; i++) {\n+            data[i-pos] = d[i].doubleValue();\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector from another vector, using a deep copy.\n+     * @param v vector to copy\n+     */\n+    public ArrayRealVector(RealVector v) {\n+        data = new double[v.getDimension()];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = v.getEntry(i);\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector from another vector, using a deep copy.\n+     * @param v vector to copy\n+     */\n+    public ArrayRealVector(ArrayRealVector v) {\n+        data = v.data.clone();\n+    }\n+\n+    /**\n+     * Construct a vector from another vector.\n+     * @param v vector to copy\n+     * @param deep if true perform a deep copy otherwise perform a shallow copy\n+     */\n+    public ArrayRealVector(ArrayRealVector v, boolean deep) {\n+        data = deep ? v.data.clone() : v.data;\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public ArrayRealVector(ArrayRealVector v1, ArrayRealVector v2) {\n+        data = new double[v1.data.length + v2.data.length];\n+        System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n+        System.arraycopy(v2.data, 0, data, v1.data.length, v2.data.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public ArrayRealVector(ArrayRealVector v1, double[] v2) {\n+        data = new double[v1.data.length + v2.length];\n+        System.arraycopy(v1.data, 0, data, 0, v1.data.length);\n+        System.arraycopy(v2, 0, data, v1.data.length, v2.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public ArrayRealVector(double[] v1, ArrayRealVector v2) {\n+        data = new double[v1.length + v2.data.length];\n+        System.arraycopy(v1, 0, data, 0, v1.length);\n+        System.arraycopy(v2.data, 0, data, v1.length, v2.data.length);\n+    }\n+\n+    /**\n+     * Construct a vector by appending one vector to another vector.\n+     * @param v1 first vector (will be put in front of the new vector)\n+     * @param v2 second vector (will be put at back of the new vector)\n+     */\n+    public ArrayRealVector(double[] v1, double[] v2) {\n+        data = new double[v1.length + v2.length];\n+        System.arraycopy(v1, 0, data, 0, v1.length);\n+        System.arraycopy(v2, 0, data, v1.length, v2.length);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector copy() {\n+        return new ArrayRealVector(this, true);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector add(RealVector v)\n+    throws IllegalArgumentException {\n+        try {\n+            return add((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] + v.getEntry(i);\n+            }\n+            return new ArrayRealVector(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector add(double[] v)\n+    throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] + v[i];\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /**\n+     * Compute the sum of this and v.\n+     * @param v vector to be added\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayRealVector add(ArrayRealVector v)\n+        throws IllegalArgumentException {\n+        return (ArrayRealVector) add(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector subtract(RealVector v)\n+    throws IllegalArgumentException {\n+        try {\n+            return subtract((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] - v.getEntry(i);\n+            }\n+            return new ArrayRealVector(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector subtract(double[] v)\n+    throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] - v[i];\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /**\n+     * Compute this minus v.\n+     * @param v vector to be subtracted\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayRealVector subtract(ArrayRealVector v)\n+        throws IllegalArgumentException {\n+        return (ArrayRealVector) subtract(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAdd(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] + d;\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAddToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i] + d;\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSubtract(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] - d;\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSubtractToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i] - d;\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapMultiply(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] * d;\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapMultiplyToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i] * d;\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapDivide(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] / d;\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapDivideToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = data[i] / d;\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapPow(double d) {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.pow(data[i], d);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapPowToSelf(double d) {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.pow(data[i], d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExp() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.exp(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.exp(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpm1() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.expm1(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapExpm1ToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.expm1(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.log(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLogToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.log(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog10() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.log10(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog10ToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.log10(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog1p() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.log1p(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapLog1pToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.log1p(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCosh() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.cosh(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCoshToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.cosh(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinh() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.sinh(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinhToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.sinh(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanh() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.tanh(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanhToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.tanh(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCos() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.cos(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCosToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.cos(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSin() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.sin(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSinToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.sin(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTan() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.tan(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapTanToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.tan(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAcos() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.acos(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAcosToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.acos(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAsin() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.asin(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAsinToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.asin(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAtan() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.atan(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAtanToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.atan(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapInv() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = 1.0 / data[i];\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapInvToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = 1.0 / data[i];\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAbs() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.abs(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapAbsToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.abs(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSqrt() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.sqrt(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSqrtToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.sqrt(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCbrt() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.cbrt(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCbrtToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.cbrt(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCeil() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.ceil(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapCeilToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.ceil(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapFloor() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.floor(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapFloorToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.floor(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapRint() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.rint(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapRintToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.rint(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSignum() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.signum(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapSignumToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.signum(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapUlp() {\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = Math.ulp(data[i]);\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector mapUlpToSelf() {\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] = Math.ulp(data[i]);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeMultiply(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return ebeMultiply((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] * v.getEntry(i);\n+            }\n+            return new ArrayRealVector(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeMultiply(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            out[i] = data[i] * v[i];\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /**\n+     * Element-by-element multiplication.\n+     * @param v vector by which instance elements must be multiplied\n+     * @return a vector containing this[i] * v[i] for all i\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayRealVector ebeMultiply(ArrayRealVector v)\n+        throws IllegalArgumentException {\n+        return (ArrayRealVector) ebeMultiply(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeDivide(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return ebeDivide((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double[] out = new double[data.length];\n+            for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] / v.getEntry(i);\n+            }\n+            return new ArrayRealVector(out);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector ebeDivide(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double[] out = new double[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+                out[i] = data[i] / v[i];\n+        }\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /**\n+     * Element-by-element division.\n+     * @param v vector by which instance elements must be divided\n+     * @return a vector containing this[i] / v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayRealVector ebeDivide(ArrayRealVector v)\n+        throws IllegalArgumentException {\n+        return (ArrayRealVector) ebeDivide(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getData() {\n+        return data.clone();\n+    }\n+\n+    /**\n+     * Returns a reference to the underlying data array.\n+     * <p>Does not make a fresh copy of the underlying data.</p>\n+     * @return array of entries\n+     */\n+    public double[] getDataRef() {\n+        return data;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double dotProduct(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return dotProduct((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double dot = 0;\n+            for (int i = 0; i < data.length; i++) {\n+                dot += data[i] * v.getEntry(i);\n+            }\n+            return dot;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double dotProduct(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double dot = 0;\n+        for (int i = 0; i < data.length; i++) {\n+            dot += data[i] * v[i];\n+        }\n+        return dot;\n+    }\n+\n+    /**\n+     * Compute the dot product.\n+     * @param v vector with which dot product should be computed\n+     * @return the scalar dot product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public double dotProduct(ArrayRealVector v)\n+        throws IllegalArgumentException {\n+        return dotProduct(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNorm() {\n+        double sum = 0;\n+        for (double a : data) {\n+            sum += a * a;\n+        }\n+        return Math.sqrt(sum);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Norm() {\n+        double sum = 0;\n+        for (double a : data) {\n+            sum += Math.abs(a);\n+        }\n+        return sum;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfNorm() {\n+        double max = 0;\n+        for (double a : data) {\n+            max += Math.max(max, Math.abs(a));\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDistance(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return getDistance((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double sum = 0;\n+            for (int i = 0; i < data.length; ++i) {\n+                final double delta = data[i] - v.getEntry(i); \n+                sum += delta * delta;\n+            }\n+            return Math.sqrt(sum);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDistance(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double sum = 0;\n+        for (int i = 0; i < data.length; ++i) {\n+            final double delta = data[i] - v[i];\n+            sum += delta * delta;\n+        }\n+        return Math.sqrt(sum);\n+    }\n+\n+   /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with the\n+     * L<sub>2</sub> norm, i.e. the square root of the sum of\n+     * elements differences, or euclidian distance.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(RealVector)\n+     * @see #getL1Distance(ArrayRealVector)\n+     * @see #getLInfDistance(ArrayRealVector)\n+     * @see #getNorm()\n+     */\n+    public double getDistance(ArrayRealVector v)\n+        throws IllegalArgumentException {\n+        return getDistance(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Distance(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return getL1Distance((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double sum = 0;\n+            for (int i = 0; i < data.length; ++i) {\n+                final double delta = data[i] - v.getEntry(i); \n+                sum += Math.abs(delta);\n+            }\n+            return sum;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Distance(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double sum = 0;\n+        for (int i = 0; i < data.length; ++i) {\n+            final double delta = data[i] - v[i];\n+            sum += Math.abs(delta);\n+        }\n+        return sum;\n+    }\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(RealVector)\n+     * @see #getL1Distance(ArrayRealVector)\n+     * @see #getLInfDistance(ArrayRealVector)\n+     * @see #getNorm()\n+     */\n+    public double getL1Distance(ArrayRealVector v)\n+        throws IllegalArgumentException {\n+        return getL1Distance(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfDistance(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return getLInfDistance((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            double max = 0;\n+            for (int i = 0; i < data.length; ++i) {\n+                final double delta = data[i] - v.getEntry(i); \n+                max = Math.max(max, Math.abs(delta));\n+            }\n+            return max;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfDistance(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double max = 0;\n+        for (int i = 0; i < data.length; ++i) {\n+            final double delta = data[i] - v[i];\n+            max = Math.max(max, Math.abs(delta));\n+        }\n+        return max;\n+    }\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>&infin;</sub> norm, i.e. the max of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(RealVector)\n+     * @see #getL1Distance(ArrayRealVector)\n+     * @see #getLInfDistance(ArrayRealVector)\n+     * @see #getNorm()\n+     */\n+    public double getLInfDistance(ArrayRealVector v)\n+        throws IllegalArgumentException {\n+        return getLInfDistance(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector unitVector() throws ArithmeticException {\n+        final double norm = getNorm();\n+        if (norm == 0) {\n+            throw MathRuntimeException.createArithmeticException(\"zero norm\");\n+        }\n+        return mapDivide(getNorm());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void unitize() throws ArithmeticException {\n+        final double norm = getNorm();\n+        if (norm == 0) {\n+            throw MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n+        }\n+        for (int i = 0; i < data.length; i++) {\n+            data[i] /= norm;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector projection(RealVector v) {\n+        return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector projection(double[] v) {\n+        return projection(new ArrayRealVector(v, false));\n+    }\n+\n+   /** Find the orthogonal projection of this vector onto another vector.\n+     * @param v vector onto which instance must be projected\n+     * @return projection of the instance onto v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public ArrayRealVector projection(ArrayRealVector v) {\n+        return (ArrayRealVector) v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix outerProduct(RealVector v)\n+        throws IllegalArgumentException {\n+        try {\n+            return outerProduct((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            checkVectorDimensions(v);\n+            final int m = data.length;\n+            final RealMatrix out = MatrixUtils.createRealMatrix(m, m);\n+            for (int i = 0; i < data.length; i++) {\n+                for (int j = 0; j < data.length; j++) {\n+                    out.setEntry(i, j, data[i] * v.getEntry(j));\n+                }\n+            }\n+            return out;\n+        }\n+    }\n+\n+    /**\n+     * Compute the outer product.\n+     * @param v vector with which outer product should be computed\n+     * @return the square matrix outer product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealMatrix outerProduct(ArrayRealVector v)\n+        throws IllegalArgumentException {\n+        return outerProduct(v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix outerProduct(double[] v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        final int m = data.length;\n+        final RealMatrix out = MatrixUtils.createRealMatrix(m, m);\n+        for (int i = 0; i < data.length; i++) {\n+            for (int j = 0; j < data.length; j++) {\n+                out.setEntry(i, j, data[i] * v[j]);\n+            }\n+        }\n+        return out;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getEntry(int index) throws MatrixIndexException {\n+        return data[index];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getDimension() {\n+        return data.length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector append(RealVector v) {\n+        try {\n+            return append((ArrayRealVector) v);\n+        } catch (ClassCastException cce) {\n+            return new ArrayRealVector(this,new ArrayRealVector(v));\n+        }\n+    }\n+\n+    /**\n+     * Construct a vector by appending a vector to this vector.\n+     * @param v vector to append to this one.\n+     * @return a new vector\n+     */\n+    public ArrayRealVector append(ArrayRealVector v) {\n+        return new ArrayRealVector(this, v);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector append(double in) {\n+        final double[] out = new double[data.length + 1];\n+        System.arraycopy(data, 0, out, 0, data.length);\n+        out[data.length] = in;\n+        return new ArrayRealVector(out);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector append(double[] in) {\n+        return new ArrayRealVector(this, in);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector getSubVector(int index, int n) {\n+        ArrayRealVector out = new ArrayRealVector(n);\n+        try {\n+            System.arraycopy(data, index, out.data, 0, n);\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+            checkIndex(index + n - 1);\n+        }\n+        return out;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setEntry(int index, double value) {\n+        try {\n+            data[index] = value;\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, RealVector v) {\n+        try {\n+            try {\n+                set(index, (ArrayRealVector) v);\n+            } catch (ClassCastException cce) {\n+                for (int i = index; i < index + v.getDimension(); ++i) {\n+                    data[i] = v.getEntry(i-index);\n+                }\n+            }\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+            checkIndex(index + v.getDimension() - 1);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, double[] v) {\n+        try {\n+            System.arraycopy(v, 0, data, index, v.length);\n+        } catch (IndexOutOfBoundsException e) {\n+            checkIndex(index);\n+            checkIndex(index + v.length - 1);\n+        }\n+    }\n+\n+    /**\n+     * Set a set of consecutive elements.\n+     * \n+     * @param index index of first element to be set.\n+     * @param v vector containing the values to set.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     */\n+    public void set(int index, ArrayRealVector v)\n+        throws MatrixIndexException {\n+        setSubVector(index, v.data);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(double value) {\n+        Arrays.fill(data, value);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] toArray(){\n+        return data.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public String toString(){\n+        return DEFAULT_FORMAT.format(this);\n+    }\n+\n+    /**\n+     * Check if instance and specified vectors have the same dimension.\n+     * @param v vector to compare instance with\n+     * @exception IllegalArgumentException if the vectors do not\n+     * have the same dimension\n+     */\n+    protected void checkVectorDimensions(RealVector v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+    }\n+\n+    /**\n+     * Check if instance dimension is equal to some expected value.\n+     * \n+     * @param n expected dimension.\n+     * @exception IllegalArgumentException if the dimension is\n+     * inconsistent with vector size\n+     */\n+    protected void checkVectorDimensions(int n)\n+        throws IllegalArgumentException {\n+        if (data.length != n) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    data.length, n);\n+        }\n+    }\n+\n+    /**\n+     * Returns true if any coordinate of this vector is NaN; false otherwise\n+     * @return  true if any coordinate of this vector is NaN; false otherwise\n+     */\n+    public boolean isNaN() {\n+        for (double v : data) {\n+            if (Double.isNaN(v)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * Returns true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     * @return  true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     */\n+    public boolean isInfinite() {\n+\n+        if (isNaN()) {\n+            return false;\n+        }\n+\n+        for (double v : data) {\n+            if (Double.isInfinite(v)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+\n+    }\n+    \n+    /**\n+     * Test for the equality of two real vectors.\n+     * <p>\n+     * If all coordinates of two real vectors are exactly the same, and none are\n+     * <code>Double.NaN</code>, the two real vectors are considered to be equal.\n+     * </p>\n+     * <p>\n+     * <code>NaN</code> coordinates are considered to affect globally the vector\n+     * and be equals to each other - i.e, if either (or all) coordinates of the\n+     * real vector are equal to <code>Double.NaN</code>, the real vector is equal to\n+     * a vector with all <code>Double.NaN</code> coordinates.\n+     * </p>\n+     *\n+     * @param other Object to test for equality to this\n+     * @return true if two vector objects are equal, false if\n+     *         object is null, not an instance of RealVector, or\n+     *         not equal to this RealVector instance\n+     * \n+     */\n+    @Override\n+    public boolean equals(Object other) {\n+\n+      if (this == other) { \n+        return true;\n+      }\n+\n+      if (other == null) {\n+        return false;\n+      }\n+\n+      try {\n+\n+          RealVector rhs = (RealVector) other;\n+          if (data.length != rhs.getDimension()) {\n+              return false;\n+          }\n+\n+          if (rhs.isNaN()) {\n+              return this.isNaN();\n+          }\n+\n+          for (int i = 0; i < data.length; ++i) {\n+              if (data[i] != rhs.getEntry(i)) {\n+                  return false;\n+              }\n+          }\n+          return true;\n+\n+      } catch (ClassCastException ex) {\n+          // ignore exception\n+          return false;\n+      }\n+\n+    }\n+    \n+    /**\n+     * Get a hashCode for the real vector.\n+     * <p>All NaN values have the same hash code.</p>\n+     * @return a hash code value for this object\n+     */\n+    @Override\n+    public int hashCode() {\n+        if (isNaN()) {\n+            return 9;\n+        }\n+        return MathUtils.hash(data);\n+    }\n+\n+    /**\n+     * Check if an index is valid.\n+     * @param index index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    private void checkIndex(final int index)\n+        throws MatrixIndexException {\n+        if (index < 0 || index >= getDimension()) {\n+            throw new MatrixIndexException(\n+                    \"index {0} out of allowed range [{1}, {2}]\",\n+                    index, 0, getDimension() - 1);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/BiDiagonalTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+\n+/**\n+ * Class transforming any matrix to bi-diagonal shape.\n+ * <p>Any m &times; n matrix A can be written as the product of three matrices:\n+ * A = U &times; B &times; V<sup>T</sup> with U an m &times; m orthogonal matrix,\n+ * B an m &times; n bi-diagonal matrix (lower diagonal if m &lt; n, upper diagonal\n+ * otherwise), and V an n &times; n orthogonal matrix.</p>\n+ * <p>Transformation to bi-diagonal shape is often not a goal by itself, but it is\n+ * an intermediate step in more general decomposition algorithms like {@link\n+ * SingularValueDecomposition Singular Value Decomposition}. This class is therefore\n+ * intended for internal use by the library and is not public. As a consequence of\n+ * this explicitly limited scope, many methods directly returns references to\n+ * internal arrays, not copies.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+class BiDiagonalTransformer {\n+\n+    /** Householder vectors. */\n+    private final double householderVectors[][];\n+\n+    /** Main diagonal. */\n+    private final double[] main;\n+\n+    /** Secondary diagonal. */\n+    private final double[] secondary;\n+\n+    /** Cached value of U. */\n+    private RealMatrix cachedU;\n+\n+    /** Cached value of B. */\n+    private RealMatrix cachedB;\n+\n+    /** Cached value of V. */\n+    private RealMatrix cachedV;\n+\n+    /**\n+     * Build the transformation to bi-diagonal shape of a matrix. \n+     * @param matrix the matrix to transform.\n+     */\n+    public BiDiagonalTransformer(RealMatrix matrix) {\n+\n+        final int m = matrix.getRowDimension();\n+        final int n = matrix.getColumnDimension();\n+        final int p = Math.min(m, n);\n+        householderVectors = matrix.getData();\n+        main      = new double[p];\n+        secondary = new double[p - 1];\n+        cachedU   = null;\n+        cachedB   = null;\n+        cachedV   = null;\n+\n+        // transform matrix\n+        if (m >= n) {\n+            transformToUpperBiDiagonal();\n+        } else {\n+            transformToLowerBiDiagonal();\n+        }\n+\n+    }\n+\n+    /**\n+     * Returns the matrix U of the transform. \n+     * <p>U is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the U matrix\n+     */\n+    public RealMatrix getU() {\n+\n+        if (cachedU == null) {\n+\n+            final int m = householderVectors.length;\n+            final int n = householderVectors[0].length;\n+            final int p = main.length;\n+            final int diagOffset    = (m >= n) ? 0 : 1;\n+            final double[] diagonal = (m >= n) ? main : secondary;\n+            cachedU = MatrixUtils.createRealMatrix(m, m);\n+\n+            // fill up the part of the matrix not affected by Householder transforms\n+            for (int k = m - 1; k >= p; --k) {\n+                cachedU.setEntry(k, k, 1);\n+            }\n+\n+            // build up first part of the matrix by applying Householder transforms\n+            for (int k = p - 1; k >= diagOffset; --k) {\n+                final double[] hK = householderVectors[k];\n+                cachedU.setEntry(k, k, 1);\n+                if (hK[k - diagOffset] != 0.0) {\n+                    for (int j = k; j < m; ++j) {\n+                        double alpha = 0;\n+                        for (int i = k; i < m; ++i) {\n+                            alpha -= cachedU.getEntry(i, j) * householderVectors[i][k - diagOffset];\n+                        }\n+                        alpha /= diagonal[k - diagOffset] * hK[k - diagOffset];\n+\n+                        for (int i = k; i < m; ++i) {\n+                            cachedU.addToEntry(i, j, -alpha * householderVectors[i][k - diagOffset]);\n+                        }\n+                    }\n+                }\n+            }\n+            if (diagOffset > 0) {\n+                cachedU.setEntry(0, 0, 1);\n+            }\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedU;\n+\n+    }\n+\n+    /**\n+     * Returns the bi-diagonal matrix B of the transform. \n+     * @return the B matrix\n+     */\n+    public RealMatrix getB() {\n+\n+        if (cachedB == null) {\n+\n+            final int m = householderVectors.length;\n+            final int n = householderVectors[0].length;\n+            cachedB = MatrixUtils.createRealMatrix(m, n);\n+            for (int i = 0; i < main.length; ++i) {\n+                cachedB.setEntry(i, i, main[i]);\n+                if (m < n) {\n+                    if (i > 0) {\n+                        cachedB.setEntry(i, i - 1, secondary[i - 1]);\n+                    }\n+                } else {\n+                    if (i < main.length - 1) {\n+                        cachedB.setEntry(i, i + 1, secondary[i]);\n+                    }\n+                }\n+            }\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedB;\n+\n+    }\n+\n+    /**\n+     * Returns the matrix V of the transform. \n+     * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the V matrix\n+     */\n+    public RealMatrix getV() {\n+\n+        if (cachedV == null) {\n+\n+            final int m = householderVectors.length;\n+            final int n = householderVectors[0].length;\n+            final int p = main.length;\n+            final int diagOffset    = (m >= n) ? 1 : 0;\n+            final double[] diagonal = (m >= n) ? secondary : main;\n+            cachedV = MatrixUtils.createRealMatrix(n, n);\n+\n+            // fill up the part of the matrix not affected by Householder transforms\n+            for (int k = n - 1; k >= p; --k) {\n+                cachedV.setEntry(k, k, 1);\n+            }\n+\n+            // build up first part of the matrix by applying Householder transforms\n+            for (int k = p - 1; k >= diagOffset; --k) {\n+                final double[] hK = householderVectors[k - diagOffset];\n+                cachedV.setEntry(k, k, 1);\n+                if (hK[k] != 0.0) {\n+                    for (int j = k; j < n; ++j) {\n+                        double beta = 0;\n+                        for (int i = k; i < n; ++i) {\n+                            beta -= cachedV.getEntry(i, j) * hK[i];\n+                        }\n+                        beta /= diagonal[k - diagOffset] * hK[k];\n+\n+                        for (int i = k; i < n; ++i) {\n+                            cachedV.addToEntry(i, j, -beta * hK[i]);\n+                        }\n+                    }\n+                }\n+            }\n+            if (diagOffset > 0) {\n+                cachedV.setEntry(0, 0, 1);\n+            }\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedV;\n+\n+    }\n+\n+    /**\n+     * Get the Householder vectors of the transform.\n+     * <p>Note that since this class is only intended for internal use,\n+     * it returns directly a reference to its internal arrays, not a copy.</p>\n+     * @return the main diagonal elements of the B matrix\n+     */\n+    double[][] getHouseholderVectorsRef() {\n+        return householderVectors;\n+    }\n+\n+    /**\n+     * Get the main diagonal elements of the matrix B of the transform.\n+     * <p>Note that since this class is only intended for internal use,\n+     * it returns directly a reference to its internal arrays, not a copy.</p>\n+     * @return the main diagonal elements of the B matrix\n+     */\n+    double[] getMainDiagonalRef() {\n+        return main;\n+    }\n+\n+    /**\n+     * Get the secondary diagonal elements of the matrix B of the transform.\n+     * <p>Note that since this class is only intended for internal use,\n+     * it returns directly a reference to its internal arrays, not a copy.</p>\n+     * @return the secondary diagonal elements of the B matrix\n+     */\n+    double[] getSecondaryDiagonalRef() {\n+        return secondary;\n+    }\n+\n+    /**\n+     * Check if the matrix is transformed to upper bi-diagonal.\n+     * @return true if the matrix is transformed to upper bi-diagonal\n+     */\n+    boolean isUpperBiDiagonal() {\n+        return householderVectors.length >=  householderVectors[0].length;\n+    }\n+\n+    /**\n+     * Transform original matrix to upper bi-diagonal form.\n+     * <p>Transformation is done using alternate Householder transforms\n+     * on columns and rows.</p>\n+     */\n+    private void transformToUpperBiDiagonal() {\n+\n+        final int m = householderVectors.length;\n+        final int n = householderVectors[0].length;\n+        for (int k = 0; k < n; k++) {\n+\n+            //zero-out a column\n+            double xNormSqr = 0;\n+            for (int i = k; i < m; ++i) {\n+                final double c = householderVectors[i][k];\n+                xNormSqr += c * c;\n+            }\n+            final double[] hK = householderVectors[k];\n+            final double a = (hK[k] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+            main[k] = a;\n+            if (a != 0.0) {\n+                hK[k] -= a;\n+                for (int j = k + 1; j < n; ++j) {\n+                    double alpha = 0;\n+                    for (int i = k; i < m; ++i) {\n+                        final double[] hI = householderVectors[i];\n+                        alpha -= hI[j] * hI[k];\n+                    }\n+                    alpha /= a * householderVectors[k][k];\n+                    for (int i = k; i < m; ++i) {\n+                        final double[] hI = householderVectors[i];\n+                        hI[j] -= alpha * hI[k];\n+                    }\n+                }\n+            }\n+\n+            if (k < n - 1) {\n+                //zero-out a row\n+                xNormSqr = 0;\n+                for (int j = k + 1; j < n; ++j) {\n+                    final double c = hK[j];\n+                    xNormSqr += c * c;\n+                }\n+                final double b = (hK[k + 1] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+                secondary[k] = b;\n+                if (b != 0.0) {\n+                    hK[k + 1] -= b;\n+                    for (int i = k + 1; i < m; ++i) {\n+                        final double[] hI = householderVectors[i];\n+                        double beta = 0;\n+                        for (int j = k + 1; j < n; ++j) {\n+                            beta -= hI[j] * hK[j];\n+                        }\n+                        beta /= b * hK[k + 1];\n+                        for (int j = k + 1; j < n; ++j) {\n+                            hI[j] -= beta * hK[j];\n+                        }\n+                    }\n+                }\n+            }\n+\n+        }\n+    }\n+\n+    /**\n+     * Transform original matrix to lower bi-diagonal form.\n+     * <p>Transformation is done using alternate Householder transforms\n+     * on rows and columns.</p>\n+     */\n+    private void transformToLowerBiDiagonal() {\n+\n+        final int m = householderVectors.length;\n+        final int n = householderVectors[0].length;\n+        for (int k = 0; k < m; k++) {\n+\n+            //zero-out a row\n+            final double[] hK = householderVectors[k];\n+            double xNormSqr = 0;\n+            for (int j = k; j < n; ++j) {\n+                final double c = hK[j];\n+                xNormSqr += c * c;\n+            }\n+            final double a = (hK[k] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+            main[k] = a;\n+            if (a != 0.0) {\n+                hK[k] -= a;\n+                for (int i = k + 1; i < m; ++i) {\n+                    final double[] hI = householderVectors[i];\n+                    double alpha = 0;\n+                    for (int j = k; j < n; ++j) {\n+                        alpha -= hI[j] * hK[j];\n+                    }\n+                    alpha /= a * householderVectors[k][k];\n+                    for (int j = k; j < n; ++j) {\n+                        hI[j] -= alpha * hK[j];\n+                    }\n+                }\n+            }\n+\n+            if (k < m - 1) {\n+                //zero-out a column\n+                final double[] hKp1 = householderVectors[k + 1];\n+                xNormSqr = 0;\n+                for (int i = k + 1; i < m; ++i) {\n+                    final double c = householderVectors[i][k];\n+                    xNormSqr += c * c;\n+                }\n+                final double b = (hKp1[k] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+                secondary[k] = b;\n+                if (b != 0.0) {\n+                    hKp1[k] -= b;\n+                    for (int j = k + 1; j < n; ++j) {\n+                        double beta = 0;\n+                        for (int i = k + 1; i < m; ++i) {\n+                            final double[] hI = householderVectors[i];\n+                            beta -= hI[j] * hI[k];\n+                        }\n+                        beta /= b * hKp1[k];\n+                        for (int i = k + 1; i < m; ++i) {\n+                            final double[] hI = householderVectors[i];\n+                            hI[j] -= beta * hI[k];\n+                        }\n+                    }\n+                }\n+            }\n+\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/BigMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * Interface defining a real-valued matrix with basic algebraic operations, using\n+ * BigDecimal representations for the entries.\n+ * <p>\n+ * Matrix element indexing is 0-based -- e.g., <code>getEntry(0, 0)</code>\n+ * returns the element in the first row, first column of the matrix.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @deprecated as of 2.0, replaced by {@link FieldMatrix} with a {@link\n+ * org.apache.commons.math.util.BigReal} parameter\n+ */\n+@Deprecated\n+public interface BigMatrix extends AnyMatrix {\n+\n+    /**\n+     * Returns a (deep) copy of this.\n+     *\n+     * @return matrix copy\n+     */\n+    BigMatrix copy();\n+    \n+    /**\n+     * Compute the sum of this and m.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @exception  IllegalArgumentException if m is not the same size as this\n+     */\n+    BigMatrix add(BigMatrix m) throws IllegalArgumentException;\n+    \n+    /**\n+     * Compute this minus m.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @exception  IllegalArgumentException if m is not the same size as this\n+     */\n+    BigMatrix subtract(BigMatrix m) throws IllegalArgumentException;\n+    \n+     /**\n+     * Returns the result of adding d to each entry of this.\n+     *\n+     * @param d    value to be added to each entry\n+     * @return     d + this\n+     */\n+    BigMatrix scalarAdd(BigDecimal d);\n+    \n+    /**\n+     * Returns the result multiplying each entry of this by d.\n+     *\n+     * @param d    value to multiply all entries by\n+     * @return     d * this\n+     */\n+    BigMatrix scalarMultiply(BigDecimal d);\n+    \n+    /**\n+     * Returns the result of postmultiplying this by m.\n+     *\n+     * @param m    matrix to postmultiply by\n+     * @return     this * m\n+     * @throws     IllegalArgumentException \n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    BigMatrix multiply(BigMatrix m) throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns the result premultiplying this by <code>m</code>.\n+     * @param m    matrix to premultiply by\n+     * @return     m * this\n+     * @throws     IllegalArgumentException\n+     *             if rowDimension(this) != columnDimension(m)\n+     */\n+    public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns matrix entries as a two-dimensional array.\n+     *\n+     * @return    2-dimensional array of entries\n+     */\n+    BigDecimal[][] getData();\n+\n+    /**\n+     * Returns matrix entries as a two-dimensional array.\n+     *\n+     * @return    2-dimensional array of entries\n+     */\n+    double [][] getDataAsDoubleArray();\n+\n+    /***\n+     * Gets the rounding mode\n+     * @return the rounding mode\n+     */\n+    int getRoundingMode();\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/MaximumAbsoluteRowSumNorm.html\">\n+     * maximum absolute row sum norm</a> of the matrix.\n+     *\n+     * @return norm\n+     */\n+    BigDecimal getNorm();\n+    \n+    /**\n+     * Gets a submatrix. Rows and columns are indicated\n+     * counting from 0 to n-1.\n+     *\n+     * @param startRow Initial row index\n+     * @param endRow Final row index\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @return The subMatrix containing the data of the\n+     *         specified rows and columns\n+     * @exception MatrixIndexException  if the indices are not valid\n+     */\n+    BigMatrix getSubMatrix(int startRow, int endRow, int startColumn,\n+            int endColumn) throws MatrixIndexException;\n+    \n+    /**\n+     * Gets a submatrix. Rows and columns are indicated\n+     * counting from 0 to n-1.\n+     *\n+     * @param selectedRows Array of row indices.\n+     * @param selectedColumns Array of column indices.\n+     * @return The subMatrix containing the data in the\n+     *         specified rows and columns\n+     * @exception MatrixIndexException if row or column selections are not valid\n+     */\n+    BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n+    throws MatrixIndexException;\n+    \n+    /**\n+     * Returns the entries in row number <code>row</code>\n+     * as a row matrix.  Row indices start at 0.\n+     *\n+     * @param row the row to be fetched\n+     * @return row matrix\n+     * @throws MatrixIndexException if the specified row index is invalid\n+     */\n+    BigMatrix getRowMatrix(int row) throws MatrixIndexException;\n+    \n+    /**\n+     * Returns the entries in column number <code>column</code>\n+     * as a column matrix.  Column indices start at 0.\n+     *\n+     * @param column the column to be fetched\n+     * @return column matrix\n+     * @throws MatrixIndexException if the specified column index is invalid\n+     */\n+    BigMatrix getColumnMatrix(int column) throws MatrixIndexException;\n+    \n+    /**\n+     * Returns the entries in row number <code>row</code> as an array.\n+     * <p>\n+     * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown\n+     * unless <code>0 <= row < rowDimension.</code></p>\n+     *\n+     * @param row the row to be fetched\n+     * @return array of entries in the row\n+     * @throws MatrixIndexException if the specified row index is not valid\n+     */\n+    BigDecimal[] getRow(int row) throws MatrixIndexException;\n+\n+    /**\n+     * Returns the entries in row number <code>row</code> as an array\n+     * of double values.\n+     * <p>\n+     * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown\n+     * unless <code>0 <= row < rowDimension.</code></p>\n+     *\n+     * @param row the row to be fetched\n+     * @return array of entries in the row\n+     * @throws MatrixIndexException if the specified row index is not valid\n+     */\n+    double [] getRowAsDoubleArray(int row) throws MatrixIndexException;\n+\n+    /**\n+     * Returns the entries in column number <code>col</code> as an array.\n+     * <p>\n+     * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown\n+     * unless <code>0 <= column < columnDimension.</code></p>\n+     *\n+     * @param col the column to be fetched\n+     * @return array of entries in the column\n+     * @throws MatrixIndexException if the specified column index is not valid\n+     */\n+    BigDecimal[] getColumn(int col) throws MatrixIndexException;\n+\n+    /**\n+     * Returns the entries in column number <code>col</code> as an array\n+     * of double values.\n+     * <p>\n+     * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown\n+     * unless <code>0 <= column < columnDimension.</code></p>\n+     *\n+     * @param col the column to be fetched\n+     * @return array of entries in the column\n+     * @throws MatrixIndexException if the specified column index is not valid\n+     */\n+    double [] getColumnAsDoubleArray(int col) throws MatrixIndexException;\n+\n+    /**\n+     * Returns the entry in the specified row and column.\n+     * <p>\n+     * Row and column indices start at 0 and must satisfy \n+     * <ul>\n+     * <li><code>0 <= row < rowDimension</code></li>\n+     * <li><code> 0 <= column < columnDimension</code></li>\n+     * </ul>\n+     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n+     *\n+     * @param row  row location of entry to be fetched  \n+     * @param column  column location of entry to be fetched\n+     * @return matrix entry in row,column\n+     * @throws MatrixIndexException if the row or column index is not valid\n+     */\n+    BigDecimal getEntry(int row, int column) throws MatrixIndexException;\n+    \n+    /**\n+     * Returns the entry in the specified row and column as a double.\n+     * <p>\n+     * Row and column indices start at 0 and must satisfy \n+     * <ul>\n+     * <li><code>0 <= row < rowDimension</code></li>\n+     * <li><code> 0 <= column < columnDimension</code></li>\n+     * </ul>\n+     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n+     *\n+     * @param row  row location of entry to be fetched\n+     * @param column  column location of entry to be fetched\n+     * @return matrix entry in row,column\n+     * @throws MatrixIndexException if the row or column index is not valid\n+     */\n+    double getEntryAsDouble(int row, int column) throws MatrixIndexException;\n+\n+    /**\n+     * Returns the transpose of this matrix.\n+     *\n+     * @return transpose matrix\n+     */\n+    BigMatrix transpose();\n+    \n+    /**\n+     * Returns the inverse of this matrix.\n+     *\n+     * @return inverse matrix\n+     * @throws org.apache.commons.math.linear.InvalidMatrixException if \n+     *     this is not invertible\n+     */\n+    BigMatrix inverse() throws InvalidMatrixException;\n+    \n+    /**\n+     * Returns the determinant of this matrix.\n+     *\n+     * @return determinant\n+      *@throws org.apache.commons.math.linear.InvalidMatrixException if \n+      *    matrix is not square\n+     */\n+    BigDecimal getDeterminant() throws InvalidMatrixException;\n+    \n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/MatrixTrace.html\">\n+     * trace</a> of the matrix (the sum of the elements on the main diagonal).\n+     *\n+     * @return trace\n+     */\n+    BigDecimal getTrace();\n+    \n+    /**\n+     * Returns the result of multiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the vector to operate on\n+     * @return this*v\n+     * @throws IllegalArgumentException if columnDimension != v.size()\n+     */\n+    BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the row vector to premultiply by\n+     * @return v*this\n+     * @throws IllegalArgumentException if rowDimension != v.size()\n+     */\n+    BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns the solution vector for a linear system with coefficient\n+     * matrix = this and constant vector = <code>b</code>.\n+     *\n+     * @param b  constant vector\n+     * @return vector of solution values to AX = b, where A is *this\n+     * @throws IllegalArgumentException if this.rowDimension != b.length \n+     * @throws org.apache.commons.math.linear.InvalidMatrixException if this matrix is not square or is singular\n+     */\n+    BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException;\n+\n+    /**\n+     * Returns a matrix of (column) solution vectors for linear systems with\n+     * coefficient matrix = this and constant vectors = columns of\n+     * <code>b</code>. \n+     *\n+     * @param b  matrix of constant vectors forming RHS of linear systems to\n+     * to solve\n+     * @return matrix of solution vectors\n+     * @throws IllegalArgumentException if this.rowDimension != row dimension\n+     * @throws org.apache.commons.math.linear.InvalidMatrixException if this matrix is not square or is singular\n+     */\n+    BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;\n+}\n+\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+import java.io.Serializable;\n+import java.math.BigDecimal;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Implementation of {@link BigMatrix} using a BigDecimal[][] array to store entries\n+ * and <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n+ * LU decompostion</a> to support linear system \n+ * solution and inverse.\n+ * <p>\n+ * The LU decompostion is performed as needed, to support the following operations: <ul>\n+ * <li>solve</li>\n+ * <li>isSingular</li>\n+ * <li>getDeterminant</li>\n+ * <li>inverse</li> </ul></p>\n+ * <p>\n+* <strong>Usage notes</strong>:<br>\n+ * <ul><li>\n+ * The LU decomposition is stored and reused on subsequent calls.  If matrix\n+ * data are modified using any of the public setXxx methods, the saved\n+ * decomposition is discarded.  If data are modified via references to the\n+ * underlying array obtained using <code>getDataRef()</code>, then the stored\n+ * LU decomposition will not be discarded.  In this case, you need to\n+ * explicitly invoke <code>LUDecompose()</code> to recompute the decomposition\n+ * before using any of the methods above.</li>\n+ * <li>\n+ * As specified in the {@link BigMatrix} interface, matrix element indexing\n+ * is 0-based -- e.g., <code>getEntry(0, 0)</code>\n+ * returns the element in the first row, first column of the matrix.</li></ul></p>\n+ * \n+ * @deprecated as of 2.0, replaced by {@link Array2DRowFieldMatrix} with a {@link\n+ * org.apache.commons.math.util.BigReal} parameter\n+ * @version $Revision$ $Date$\n+ */\n+@Deprecated\n+public class BigMatrixImpl implements BigMatrix, Serializable {\n+    \n+    /** Serialization id */\n+    private static final long serialVersionUID = -1011428905656140431L;\n+    \n+    /** Entries of the matrix */\n+    protected BigDecimal data[][] = null;\n+    \n+    /** Entries of cached LU decomposition.\n+     *  All updates to data (other than luDecompose()) *must* set this to null\n+     */\n+    protected BigDecimal lu[][] = null;\n+    \n+    /** Permutation associated with LU decomposition */\n+    protected int[] permutation = null;\n+    \n+    /** Parity of the permutation associated with the LU decomposition */\n+    protected int parity = 1;\n+    \n+    /** Rounding mode for divisions **/\n+    private int roundingMode = BigDecimal.ROUND_HALF_UP;\n+    \n+    /*** BigDecimal scale ***/\n+    private int scale = 64;\n+    \n+    /** Bound to determine effective singularity in LU decomposition */\n+    private static final BigDecimal TOO_SMALL = new BigDecimal(10E-12);\n+    \n+    /** BigDecimal 0 */\n+    static final BigDecimal ZERO = new BigDecimal(0);\n+    /** BigDecimal 1 */\n+    static final BigDecimal ONE = new BigDecimal(1);\n+    \n+    /** \n+     * Creates a matrix with no data\n+     */\n+    public BigMatrixImpl() {\n+    }\n+    \n+    /**\n+     * Create a new BigMatrix with the supplied row and column dimensions.\n+     *\n+     * @param rowDimension      the number of rows in the new matrix\n+     * @param columnDimension   the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not\n+     *  positive\n+     */\n+    public BigMatrixImpl(int rowDimension, int columnDimension) {\n+        if (rowDimension <= 0 ) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid row dimension {0} (must be positive)\",\n+                    rowDimension);\n+        }\n+        if (columnDimension <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid column dimension {0} (must be positive)\",\n+                    columnDimension);\n+        }\n+        data = new BigDecimal[rowDimension][columnDimension];\n+        lu = null;\n+    }\n+    \n+    /**\n+     * Create a new BigMatrix using <code>d</code> as the underlying\n+     * data array.\n+     * <p>The input array is copied, not referenced. This constructor has\n+     * the same effect as calling {@link #BigMatrixImpl(BigDecimal[][], boolean)}\n+     * with the second argument set to <code>true</code>.</p>\n+     *\n+     * @param d data for new matrix\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     */\n+    public BigMatrixImpl(BigDecimal[][] d) {\n+        this.copyIn(d);\n+        lu = null;\n+    }\n+\n+    /**\n+     * Create a new BigMatrix using the input array as the underlying\n+     * data array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * BigMatrix and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param d data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #BigMatrixImpl(BigDecimal[][])\n+     */\n+    public BigMatrixImpl(BigDecimal[][] d, boolean copyArray) {\n+        if (copyArray) {\n+            copyIn(d);\n+        } else {\n+            if (d == null) {\n+                throw new NullPointerException();\n+            }   \n+            final int nRows = d.length;\n+            if (nRows == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            }\n+\n+            final int nCols = d[0].length;\n+            if (nCols == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            }\n+            for (int r = 1; r < nRows; r++) {\n+                if (d[r].length != nCols) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                          \"some rows have length {0} while others have length {1}\",\n+                          nCols, d[r].length); \n+                }\n+            }       \n+            data = d;\n+        }\n+        lu = null;\n+    }\n+\n+    /**\n+     * Create a new BigMatrix using <code>d</code> as the underlying\n+     * data array.\n+     * <p>Since the underlying array will hold <code>BigDecimal</code>\n+     * instances, it will be created.</p>\n+     *\n+     * @param d data for new matrix\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     */\n+    public BigMatrixImpl(double[][] d) {\n+        final int nRows = d.length;\n+        if (nRows == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+        }\n+\n+        final int nCols = d[0].length;\n+        if (nCols == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+        }\n+        for (int row = 1; row < nRows; row++) {\n+            if (d[row].length != nCols) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"some rows have length {0} while others have length {1}\",\n+                      nCols, d[row].length); \n+            }\n+        }\n+        this.copyIn(d);\n+        lu = null;\n+    }\n+    \n+    /**\n+     * Create a new BigMatrix using the values represented by the strings in \n+     * <code>d</code> as the underlying data array.\n+     *\n+     * @param d data for new matrix\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     */\n+    public BigMatrixImpl(String[][] d) {\n+        final int nRows = d.length;\n+        if (nRows == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+        }\n+\n+        final int nCols = d[0].length;\n+        if (nCols == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+        }\n+        for (int row = 1; row < nRows; row++) {\n+            if (d[row].length != nCols) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"some rows have length {0} while others have length {1}\",\n+                      nCols, d[row].length); \n+            }\n+        }\n+        this.copyIn(d);\n+        lu = null;\n+    }\n+    \n+    /**\n+     * Create a new (column) BigMatrix using <code>v</code> as the\n+     * data for the unique column of the <code>v.length x 1</code> matrix \n+     * created.\n+     * <p>\n+     * The input array is copied, not referenced.</p>\n+     *\n+     * @param v column vector holding data for new matrix\n+     */\n+    public BigMatrixImpl(BigDecimal[] v) {\n+        final int nRows = v.length;\n+        data = new BigDecimal[nRows][1];\n+        for (int row = 0; row < nRows; row++) {\n+            data[row][0] = v[row];\n+        }\n+    }\n+    \n+    /**\n+     * Create a new BigMatrix which is a copy of this.\n+     *\n+     * @return  the cloned matrix\n+     */\n+    public BigMatrix copy() {\n+        return new BigMatrixImpl(this.copyOut(), false);\n+    }\n+    \n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public BigMatrix add(BigMatrix m) throws IllegalArgumentException {\n+        try {\n+            return add((BigMatrixImpl) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            MatrixUtils.checkAdditionCompatible(this, m);\n+\n+            final int rowCount    = getRowDimension();\n+            final int columnCount = getColumnDimension();\n+            final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+            for (int row = 0; row < rowCount; row++) {\n+                final BigDecimal[] dataRow    = data[row];\n+                final BigDecimal[] outDataRow = outData[row];\n+                for (int col = 0; col < columnCount; col++) {\n+                    outDataRow[col] = dataRow[col].add(m.getEntry(row, col));\n+                }  \n+            }\n+            return new BigMatrixImpl(outData, false);\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public BigMatrixImpl add(BigMatrixImpl m) throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkAdditionCompatible(this, m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+        for (int row = 0; row < rowCount; row++) {\n+            final BigDecimal[] dataRow    = data[row];\n+            final BigDecimal[] mRow       = m.data[row];\n+            final BigDecimal[] outDataRow = outData[row];\n+            for (int col = 0; col < columnCount; col++) {\n+                outDataRow[col] = dataRow[col].add(mRow[col]);\n+            }  \n+        }\n+        return new BigMatrixImpl(outData, false);\n+    }\n+\n+    /**\n+     * Compute  this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public BigMatrix subtract(BigMatrix m) throws IllegalArgumentException {\n+        try {\n+            return subtract((BigMatrixImpl) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            MatrixUtils.checkSubtractionCompatible(this, m);\n+\n+            final int rowCount    = getRowDimension();\n+            final int columnCount = getColumnDimension();\n+            final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+            for (int row = 0; row < rowCount; row++) {\n+                final BigDecimal[] dataRow    = data[row];\n+                final BigDecimal[] outDataRow = outData[row];\n+                for (int col = 0; col < columnCount; col++) {\n+                    outDataRow[col] = dataRow[col].subtract(getEntry(row, col));\n+                }  \n+            }\n+            return new BigMatrixImpl(outData, false);\n+        }\n+    }\n+\n+    /**\n+     * Compute  this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public BigMatrixImpl subtract(BigMatrixImpl m) throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkSubtractionCompatible(this, m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+        for (int row = 0; row < rowCount; row++) {\n+            final BigDecimal[] dataRow    = data[row];\n+            final BigDecimal[] mRow       = m.data[row];\n+            final BigDecimal[] outDataRow = outData[row];\n+            for (int col = 0; col < columnCount; col++) {\n+                outDataRow[col] = dataRow[col].subtract(mRow[col]);\n+            }  \n+        }\n+        return new BigMatrixImpl(outData, false);\n+    }\n+\n+    /**\n+     * Returns the result of adding d to each entry of this.\n+     *\n+     * @param d    value to be added to each entry\n+     * @return     d + this\n+     */\n+    public BigMatrix scalarAdd(BigDecimal d) {\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+        for (int row = 0; row < rowCount; row++) {\n+            final BigDecimal[] dataRow    = data[row];\n+            final BigDecimal[] outDataRow = outData[row];\n+            for (int col = 0; col < columnCount; col++) {\n+                outDataRow[col] = dataRow[col].add(d);\n+            }\n+        }\n+        return new BigMatrixImpl(outData, false);\n+    }\n+\n+    /**\n+     * Returns the result of multiplying each entry of this by <code>d</code>\n+     * @param d  value to multiply all entries by\n+     * @return d * this\n+     */\n+    public BigMatrix scalarMultiply(BigDecimal d) {\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+        for (int row = 0; row < rowCount; row++) {\n+            final BigDecimal[] dataRow    = data[row];\n+            final BigDecimal[] outDataRow = outData[row];\n+            for (int col = 0; col < columnCount; col++) {\n+                outDataRow[col] = dataRow[col].multiply(d);\n+            }\n+        }\n+        return new BigMatrixImpl(outData, false);\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by <code>m</code>.\n+     * @param m    matrix to postmultiply by\n+     * @return     this*m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public BigMatrix multiply(BigMatrix m) throws IllegalArgumentException {\n+        try {\n+            return multiply((BigMatrixImpl) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            MatrixUtils.checkMultiplicationCompatible(this, m);\n+\n+            final int nRows = this.getRowDimension();\n+            final int nCols = m.getColumnDimension();\n+            final int nSum = this.getColumnDimension();\n+            final BigDecimal[][] outData = new BigDecimal[nRows][nCols];\n+            for (int row = 0; row < nRows; row++) {\n+                final BigDecimal[] dataRow    = data[row];\n+                final BigDecimal[] outDataRow = outData[row];\n+                for (int col = 0; col < nCols; col++) {\n+                    BigDecimal sum = ZERO;\n+                    for (int i = 0; i < nSum; i++) {\n+                        sum = sum.add(dataRow[i].multiply(m.getEntry(i, col)));\n+                    }\n+                    outDataRow[col] = sum;\n+                }\n+            }\n+            return new BigMatrixImpl(outData, false);\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by <code>m</code>.\n+     * @param m    matrix to postmultiply by\n+     * @return     this*m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public BigMatrixImpl multiply(BigMatrixImpl m) throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkMultiplicationCompatible(this, m);\n+\n+        final int nRows = this.getRowDimension();\n+        final int nCols = m.getColumnDimension();\n+        final int nSum = this.getColumnDimension();\n+        final BigDecimal[][] outData = new BigDecimal[nRows][nCols];\n+        for (int row = 0; row < nRows; row++) {\n+            final BigDecimal[] dataRow    = data[row];\n+            final BigDecimal[] outDataRow = outData[row];\n+            for (int col = 0; col < nCols; col++) {\n+                BigDecimal sum = ZERO;\n+                for (int i = 0; i < nSum; i++) {\n+                    sum = sum.add(dataRow[i].multiply(m.data[i][col]));\n+                }\n+                outDataRow[col] = sum;\n+            }\n+        }            \n+        return new BigMatrixImpl(outData, false);\n+    }\n+\n+    /**\n+     * Returns the result premultiplying this by <code>m</code>.\n+     * @param m    matrix to premultiply by\n+     * @return     m * this\n+     * @throws     IllegalArgumentException\n+     *             if rowDimension(this) != columnDimension(m)\n+     */\n+    public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException {\n+        return m.multiply(this);\n+    }\n+\n+    /**\n+     * Returns matrix entries as a two-dimensional array.\n+     * <p>\n+     * Makes a fresh copy of the underlying data.</p>\n+     *\n+     * @return    2-dimensional array of entries\n+     */\n+    public BigDecimal[][] getData() {\n+        return copyOut();\n+    }\n+    \n+    /**\n+     * Returns matrix entries as a two-dimensional array.\n+     * <p>\n+     * Makes a fresh copy of the underlying data converted to\n+     * <code>double</code> values.</p>\n+     *\n+     * @return    2-dimensional array of entries\n+     */\n+    public double[][] getDataAsDoubleArray() {\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        final double d[][] = new double[nRows][nCols];\n+        for (int i = 0; i < nRows; i++) {\n+            for (int j = 0; j < nCols; j++) {\n+                d[i][j] = data[i][j].doubleValue();\n+            }\n+        }\n+        return d;\n+    }\n+    \n+    /**\n+     * Returns a reference to the underlying data array.\n+     * <p>\n+     * Does not make a fresh copy of the underlying data.</p>\n+     *\n+     * @return 2-dimensional array of entries\n+     */\n+    public BigDecimal[][] getDataRef() {\n+        return data;\n+    }\n+    \n+    /***\n+     * Gets the rounding mode for division operations\n+     * The default is {@link java.math.BigDecimal#ROUND_HALF_UP}\n+     * @see BigDecimal\n+     * @return the rounding mode.\n+     */ \n+    public int getRoundingMode() {\n+        return roundingMode;\n+    }\n+    \n+    /***\n+     * Sets the rounding mode for decimal divisions.\n+     * @see BigDecimal\n+     * @param roundingMode rounding mode for decimal divisions\n+     */\n+    public void setRoundingMode(int roundingMode) {\n+        this.roundingMode = roundingMode;\n+    }\n+    \n+    /***\n+     * Sets the scale for division operations.\n+     * The default is 64\n+     * @see BigDecimal\n+     * @return the scale\n+     */\n+    public int getScale() {\n+        return scale;\n+    }\n+    \n+    /***\n+     * Sets the scale for division operations.\n+     * @see BigDecimal\n+     * @param scale scale for division operations\n+     */\n+    public void setScale(int scale) {\n+        this.scale = scale;\n+    }\n+    \n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/MaximumAbsoluteRowSumNorm.html\">\n+     * maximum absolute row sum norm</a> of the matrix.\n+     *\n+     * @return norm\n+     */\n+    public BigDecimal getNorm() {\n+        BigDecimal maxColSum = ZERO;\n+        for (int col = 0; col < this.getColumnDimension(); col++) {\n+            BigDecimal sum = ZERO;\n+            for (int row = 0; row < this.getRowDimension(); row++) {\n+                sum = sum.add(data[row][col].abs());\n+            }\n+            maxColSum = maxColSum.max(sum);\n+        }\n+        return maxColSum;\n+    }\n+    \n+    /**\n+     * Gets a submatrix. Rows and columns are indicated\n+     * counting from 0 to n-1.\n+     *\n+     * @param startRow Initial row index\n+     * @param endRow Final row index\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @return The subMatrix containing the data of the\n+     *         specified rows and columns\n+     * @exception MatrixIndexException if row or column selections are not valid\n+     */\n+    public BigMatrix getSubMatrix(int startRow, int endRow,\n+                                  int startColumn, int endColumn)\n+        throws MatrixIndexException {\n+\n+        MatrixUtils.checkRowIndex(this, startRow);\n+        MatrixUtils.checkRowIndex(this, endRow);\n+        if (startRow > endRow) {\n+            throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n+                                           startRow, endRow);\n+        }\n+\n+        MatrixUtils.checkColumnIndex(this, startColumn);\n+        MatrixUtils.checkColumnIndex(this, endColumn);\n+        if (startColumn > endColumn) {\n+            throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n+                                           startColumn, endColumn);\n+        }\n+\n+        final BigDecimal[][] subMatrixData =\n+            new BigDecimal[endRow - startRow + 1][endColumn - startColumn + 1];\n+        for (int i = startRow; i <= endRow; i++) {\n+            System.arraycopy(data[i], startColumn,\n+                             subMatrixData[i - startRow], 0,\n+                             endColumn - startColumn + 1);\n+        }\n+\n+        return new BigMatrixImpl(subMatrixData, false);\n+\n+    }\n+    \n+    /**\n+     * Gets a submatrix. Rows and columns are indicated\n+     * counting from 0 to n-1.\n+     *\n+     * @param selectedRows Array of row indices must be non-empty\n+     * @param selectedColumns Array of column indices must be non-empty\n+     * @return The subMatrix containing the data in the\n+     *     specified rows and columns\n+     * @exception MatrixIndexException  if supplied row or column index arrays\n+     *     are not valid\n+     */\n+    public BigMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n+        throws MatrixIndexException {\n+\n+        if (selectedRows.length * selectedColumns.length == 0) {\n+            if (selectedRows.length == 0) {\n+                throw new MatrixIndexException(\"empty selected row index array\");\n+            }\n+            throw new MatrixIndexException(\"empty selected column index array\");\n+        }\n+\n+        final BigDecimal[][] subMatrixData =\n+            new BigDecimal[selectedRows.length][selectedColumns.length];\n+        try  {\n+            for (int i = 0; i < selectedRows.length; i++) {\n+                final BigDecimal[] subI = subMatrixData[i];\n+                final BigDecimal[] dataSelectedI = data[selectedRows[i]];\n+                for (int j = 0; j < selectedColumns.length; j++) {\n+                    subI[j] = dataSelectedI[selectedColumns[j]];\n+                }\n+            }\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            // we redo the loop with checks enabled\n+            // in order to generate an appropriate message\n+            for (final int row : selectedRows) {\n+                MatrixUtils.checkRowIndex(this, row);\n+            }\n+            for (final int column : selectedColumns) {\n+                MatrixUtils.checkColumnIndex(this, column);\n+            }\n+        }\n+        return new BigMatrixImpl(subMatrixData, false);\n+    } \n+    \n+    /**\n+     * Replace the submatrix starting at <code>row, column</code> using data in\n+     * the input <code>subMatrix</code> array. Indexes are 0-based.\n+     * <p> \n+     * Example:<br>\n+     * Starting with <pre>\n+     * 1  2  3  4\n+     * 5  6  7  8\n+     * 9  0  1  2\n+     * </pre>\n+     * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking \n+     * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>\n+     * 1  2  3  4\n+     * 5  3  4  8\n+     * 9  5  6  2\n+     * </pre></p>\n+     * \n+     * @param subMatrix  array containing the submatrix replacement data\n+     * @param row  row coordinate of the top, left element to be replaced\n+     * @param column  column coordinate of the top, left element to be replaced\n+     * @throws MatrixIndexException  if subMatrix does not fit into this \n+     *    matrix from element in (row, column) \n+     * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>subMatrix</code> is null\n+     * @since 1.1\n+     */\n+    public void setSubMatrix(BigDecimal[][] subMatrix, int row, int column) \n+    throws MatrixIndexException {\n+\n+        final int nRows = subMatrix.length;\n+        if (nRows == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+        }\n+\n+        final int nCols = subMatrix[0].length;\n+        if (nCols == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+        }\n+\n+        for (int r = 1; r < nRows; r++) {\n+            if (subMatrix[r].length != nCols) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"some rows have length {0} while others have length {1}\",\n+                      nCols, subMatrix[r].length); \n+            }\n+        }\n+\n+        if (data == null) {\n+            if (row > 0) {\n+                throw MathRuntimeException.createIllegalStateException(\n+                        \"first {0} rows are not initialized yet\",\n+                        row);\n+            }\n+            if (column > 0) {\n+                throw MathRuntimeException.createIllegalStateException(\n+                        \"first {0} columns are not initialized yet\",\n+                        column);\n+            }\n+            data = new BigDecimal[nRows][nCols];\n+            System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);          \n+        } else {\n+            MatrixUtils.checkRowIndex(this, row);\n+            MatrixUtils.checkColumnIndex(this, column);\n+            MatrixUtils.checkRowIndex(this, nRows + row - 1);\n+            MatrixUtils.checkColumnIndex(this, nCols + column - 1);\n+        }\n+        for (int i = 0; i < nRows; i++) {\n+            System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);\n+        } \n+\n+        lu = null;\n+\n+    }\n+    \n+    /**\n+     * Returns the entries in row number <code>row</code>\n+     * as a row matrix.  Row indices start at 0.\n+     *\n+     * @param row the row to be fetched\n+     * @return row matrix\n+     * @throws MatrixIndexException if the specified row index is invalid\n+     */\n+    public BigMatrix getRowMatrix(int row) throws MatrixIndexException {\n+        MatrixUtils.checkRowIndex(this, row);\n+        final int ncols = this.getColumnDimension();\n+        final BigDecimal[][] out = new BigDecimal[1][ncols]; \n+        System.arraycopy(data[row], 0, out[0], 0, ncols);\n+        return new BigMatrixImpl(out, false);\n+    } \n+    \n+    /**\n+     * Returns the entries in column number <code>column</code>\n+     * as a column matrix.  Column indices start at 0.\n+     *\n+     * @param column the column to be fetched\n+     * @return column matrix\n+     * @throws MatrixIndexException if the specified column index is invalid\n+     */\n+    public BigMatrix getColumnMatrix(int column) throws MatrixIndexException {\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final int nRows = this.getRowDimension();\n+        final BigDecimal[][] out = new BigDecimal[nRows][1]; \n+        for (int row = 0; row < nRows; row++) {\n+            out[row][0] = data[row][column];\n+        }\n+        return new BigMatrixImpl(out, false);\n+    }\n+    \n+    /**\n+     * Returns the entries in row number <code>row</code> as an array.\n+     * <p>\n+     * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown\n+     * unless <code>0 <= row < rowDimension.</code></p>\n+     *\n+     * @param row the row to be fetched\n+     * @return array of entries in the row\n+     * @throws MatrixIndexException if the specified row index is not valid\n+     */\n+    public BigDecimal[] getRow(int row) throws MatrixIndexException {\n+        MatrixUtils.checkRowIndex(this, row);\n+        final int ncols = this.getColumnDimension();\n+        final BigDecimal[] out = new BigDecimal[ncols];\n+        System.arraycopy(data[row], 0, out, 0, ncols);\n+        return out;\n+    }\n+    \n+     /**\n+     * Returns the entries in row number <code>row</code> as an array\n+     * of double values.\n+     * <p>\n+     * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown\n+     * unless <code>0 <= row < rowDimension.</code></p>\n+     *\n+     * @param row the row to be fetched\n+     * @return array of entries in the row\n+     * @throws MatrixIndexException if the specified row index is not valid\n+     */\n+    public double[] getRowAsDoubleArray(int row) throws MatrixIndexException {\n+        MatrixUtils.checkRowIndex(this, row);\n+        final int ncols = this.getColumnDimension();\n+        final double[] out = new double[ncols];\n+        for (int i=0;i<ncols;i++) {\n+            out[i] = data[row][i].doubleValue();\n+        }\n+        return out;\n+    }\n+    \n+     /**\n+     * Returns the entries in column number <code>col</code> as an array.\n+     * <p>\n+     * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown\n+     * unless <code>0 <= column < columnDimension.</code></p>\n+     *\n+     * @param col the column to be fetched\n+     * @return array of entries in the column\n+     * @throws MatrixIndexException if the specified column index is not valid\n+     */\n+    public BigDecimal[] getColumn(int col) throws MatrixIndexException {\n+        MatrixUtils.checkColumnIndex(this, col);\n+        final int nRows = this.getRowDimension();\n+        final BigDecimal[] out = new BigDecimal[nRows];\n+        for (int i = 0; i < nRows; i++) {\n+            out[i] = data[i][col];\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     * Returns the entries in column number <code>col</code> as an array\n+     * of double values.\n+     * <p>\n+     * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown\n+     * unless <code>0 <= column < columnDimension.</code></p>\n+     *\n+     * @param col the column to be fetched\n+     * @return array of entries in the column\n+     * @throws MatrixIndexException if the specified column index is not valid\n+     */\n+    public double[] getColumnAsDoubleArray(int col) throws MatrixIndexException {\n+        MatrixUtils.checkColumnIndex(this, col);\n+        final int nrows = this.getRowDimension();\n+        final double[] out = new double[nrows];\n+        for (int i=0;i<nrows;i++) {\n+            out[i] = data[i][col].doubleValue();\n+        }\n+        return out;\n+    }\n+    \n+     /**\n+     * Returns the entry in the specified row and column.\n+     * <p>\n+     * Row and column indices start at 0 and must satisfy \n+     * <ul>\n+     * <li><code>0 <= row < rowDimension</code></li>\n+     * <li><code> 0 <= column < columnDimension</code></li>\n+     * </ul>\n+     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n+     *\n+     * @param row  row location of entry to be fetched  \n+     * @param column  column location of entry to be fetched\n+     * @return matrix entry in row,column\n+     * @throws MatrixIndexException if the row or column index is not valid\n+     */\n+    public BigDecimal getEntry(int row, int column)\n+    throws MatrixIndexException {\n+        try {\n+            return data[row][column];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+    \n+    /**\n+     * Returns the entry in the specified row and column as a double.\n+     * <p>\n+     * Row and column indices start at 0 and must satisfy \n+     * <ul>\n+     * <li><code>0 <= row < rowDimension</code></li>\n+     * <li><code> 0 <= column < columnDimension</code></li>\n+     * </ul>\n+     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n+     *\n+     * @param row  row location of entry to be fetched\n+     * @param column  column location of entry to be fetched\n+     * @return matrix entry in row,column\n+     * @throws MatrixIndexException if the row\n+     * or column index is not valid\n+     */\n+    public double getEntryAsDouble(int row, int column) throws MatrixIndexException {\n+        return getEntry(row,column).doubleValue();\n+    }\n+    \n+    /**\n+     * Returns the transpose matrix.\n+     *\n+     * @return transpose matrix\n+     */\n+    public BigMatrix transpose() {\n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n+        final BigDecimal[][] outData = new BigDecimal[nCols][nRows];\n+        for (int row = 0; row < nRows; row++) {\n+            final BigDecimal[] dataRow = data[row];\n+            for (int col = 0; col < nCols; col++) {\n+                outData[col][row] = dataRow[col];\n+            }\n+        }\n+        return new BigMatrixImpl(outData, false);\n+    }\n+    \n+    /**\n+     * Returns the inverse matrix if this matrix is invertible.\n+     * \n+     * @return inverse matrix\n+     * @throws InvalidMatrixException if this is not invertible\n+     */\n+    public BigMatrix inverse() throws InvalidMatrixException {\n+        return solve(MatrixUtils.createBigIdentityMatrix(getRowDimension()));\n+    }\n+    \n+    /**\n+     * Returns the determinant of this matrix.\n+     *\n+     * @return determinant\n+     * @throws InvalidMatrixException if matrix is not square\n+     */\n+    public BigDecimal getDeterminant() throws InvalidMatrixException {\n+        if (!isSquare()) {\n+            throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());\n+        }\n+        if (isSingular()) {   // note: this has side effect of attempting LU decomp if lu == null\n+            return ZERO;\n+        } else {\n+            BigDecimal det = (parity == 1) ? ONE : ONE.negate();\n+            for (int i = 0; i < this.getRowDimension(); i++) {\n+                det = det.multiply(lu[i][i]);\n+            }\n+            return det;\n+        }\n+    }\n+    \n+     /**\n+     * Is this a square matrix?\n+     * @return true if the matrix is square (rowDimension = columnDimension)\n+     */\n+    public boolean isSquare() {\n+        return (this.getColumnDimension() == this.getRowDimension());\n+    }\n+    \n+    /**\n+     * Is this a singular matrix?\n+     * @return true if the matrix is singular\n+     */\n+    public boolean isSingular() {\n+        if (lu == null) {\n+            try {\n+                luDecompose();\n+                return false;\n+            } catch (InvalidMatrixException ex) {\n+                return true;\n+            }\n+        } else { // LU decomp must have been successfully performed\n+            return false; // so the matrix is not singular\n+        }\n+    }\n+    \n+    /**\n+     * Returns the number of rows in the matrix.\n+     *\n+     * @return rowDimension\n+     */\n+    public int getRowDimension() {\n+        return data.length;\n+    }\n+    \n+    /**\n+     * Returns the number of columns in the matrix.\n+     *\n+     * @return columnDimension\n+     */\n+    public int getColumnDimension() {\n+        return data[0].length;\n+    }\n+    \n+     /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/MatrixTrace.html\">\n+     * trace</a> of the matrix (the sum of the elements on the main diagonal).\n+     *\n+     * @return trace\n+     * \n+     * @throws IllegalArgumentException if this matrix is not square.\n+     */\n+    public BigDecimal getTrace() throws IllegalArgumentException {\n+        if (!isSquare()) {\n+            throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());\n+        }\n+        BigDecimal trace = data[0][0];\n+        for (int i = 1; i < this.getRowDimension(); i++) {\n+            trace = trace.add(data[i][i]);\n+        }\n+        return trace;\n+    }\n+    \n+    /**\n+     * Returns the result of multiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the vector to operate on\n+     * @return this*v\n+     * @throws IllegalArgumentException if columnDimension != v.size()\n+     */\n+    public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n+        if (v.length != getColumnDimension()) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, getColumnDimension() );\n+        }\n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n+        final BigDecimal[] out = new BigDecimal[nRows];\n+        for (int row = 0; row < nRows; row++) {\n+            BigDecimal sum = ZERO;\n+            for (int i = 0; i < nCols; i++) {\n+                sum = sum.add(data[row][i].multiply(v[i]));\n+            }\n+            out[row] = sum;\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     * Returns the result of multiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the vector to operate on\n+     * @return this*v\n+     * @throws IllegalArgumentException if columnDimension != v.size()\n+     */\n+    public BigDecimal[] operate(double[] v) throws IllegalArgumentException {\n+        final BigDecimal bd[] = new BigDecimal[v.length];\n+        for (int i = 0; i < bd.length; i++) {\n+            bd[i] = new BigDecimal(v[i]);\n+        }\n+        return operate(bd);\n+    }\n+    \n+    /**\n+     * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the row vector to premultiply by\n+     * @return v*this\n+     * @throws IllegalArgumentException if rowDimension != v.size()\n+     */\n+    public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n+        final int nRows = this.getRowDimension();\n+        if (v.length != nRows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nRows );\n+        }\n+        final int nCols = this.getColumnDimension();\n+        final BigDecimal[] out = new BigDecimal[nCols];\n+        for (int col = 0; col < nCols; col++) {\n+            BigDecimal sum = ZERO;\n+            for (int i = 0; i < nRows; i++) {\n+                sum = sum.add(data[i][col].multiply(v[i]));\n+            }\n+            out[col] = sum;\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     * Returns a matrix of (column) solution vectors for linear systems with\n+     * coefficient matrix = this and constant vectors = columns of\n+     * <code>b</code>. \n+     *\n+     * @param b  array of constants forming RHS of linear systems to\n+     * to solve\n+     * @return solution array\n+     * @throws IllegalArgumentException if this.rowDimension != row dimension\n+     * @throws InvalidMatrixException if this matrix is not square or is singular\n+     */\n+    public BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException {\n+        final int nRows = this.getRowDimension();\n+        if (b.length != nRows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    b.length, nRows);\n+        }\n+        final BigMatrix bMatrix = new BigMatrixImpl(b);\n+        final BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();\n+        final BigDecimal[] out = new BigDecimal[nRows];\n+        for (int row = 0; row < nRows; row++) {\n+            out[row] = solution[row][0];\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     * Returns a matrix of (column) solution vectors for linear systems with\n+     * coefficient matrix = this and constant vectors = columns of\n+     * <code>b</code>. \n+     *\n+     * @param b  array of constants forming RHS of linear systems to\n+     * to solve\n+     * @return solution array\n+     * @throws IllegalArgumentException if this.rowDimension != row dimension\n+     * @throws InvalidMatrixException if this matrix is not square or is singular\n+     */\n+    public BigDecimal[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n+        final BigDecimal bd[] = new BigDecimal[b.length];\n+        for (int i = 0; i < bd.length; i++) {\n+            bd[i] = new BigDecimal(b[i]);\n+        }\n+        return solve(bd);\n+    }\n+    \n+    /**\n+     * Returns a matrix of (column) solution vectors for linear systems with\n+     * coefficient matrix = this and constant vectors = columns of\n+     * <code>b</code>. \n+     *\n+     * @param b  matrix of constant vectors forming RHS of linear systems to\n+     * to solve\n+     * @return matrix of solution vectors\n+     * @throws IllegalArgumentException if this.rowDimension != row dimension\n+     * @throws InvalidMatrixException if this matrix is not square or is singular\n+     */\n+    public BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException  {\n+        if (b.getRowDimension() != getRowDimension()) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    b.getRowDimension(), b.getColumnDimension(), getRowDimension(), \"n\");\n+        }\n+        if (!isSquare()) {\n+            throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());\n+        }\n+        if (this.isSingular()) { // side effect: compute LU decomp\n+            throw new SingularMatrixException();\n+        }\n+        \n+        final int nCol = this.getColumnDimension();\n+        final int nColB = b.getColumnDimension();\n+        final int nRowB = b.getRowDimension();\n+        \n+        // Apply permutations to b\n+        final BigDecimal[][] bp = new BigDecimal[nRowB][nColB];\n+        for (int row = 0; row < nRowB; row++) {\n+            final BigDecimal[] bpRow = bp[row];\n+            for (int col = 0; col < nColB; col++) {\n+                bpRow[col] = b.getEntry(permutation[row], col);\n+            }\n+        }\n+        \n+        // Solve LY = b\n+        for (int col = 0; col < nCol; col++) {\n+            for (int i = col + 1; i < nCol; i++) {\n+                final BigDecimal[] bpI = bp[i];\n+                final BigDecimal[] luI = lu[i];\n+                for (int j = 0; j < nColB; j++) {\n+                    bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));\n+                }\n+            }\n+        }\n+        \n+        // Solve UX = Y\n+        for (int col = nCol - 1; col >= 0; col--) {\n+            final BigDecimal[] bpCol = bp[col];\n+            final BigDecimal luDiag = lu[col][col];\n+            for (int j = 0; j < nColB; j++) {\n+                bpCol[j] = bpCol[j].divide(luDiag, scale, roundingMode);\n+            }\n+            for (int i = 0; i < col; i++) {\n+                final BigDecimal[] bpI = bp[i];\n+                final BigDecimal[] luI = lu[i];\n+                for (int j = 0; j < nColB; j++) {\n+                    bpI[j] = bpI[j].subtract(bp[col][j].multiply(luI[col]));\n+                }\n+            }\n+        }\n+\n+        return new BigMatrixImpl(bp, false);\n+\n+    }\n+    \n+    /**\n+     * Computes a new \n+     * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n+     * LU decompostion</a> for this matrix, storing the result for use by other methods. \n+     * <p>\n+     * <strong>Implementation Note</strong>:<br>\n+     * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/people/sd/lectures/nummeth98/linear.htm\">\n+     * Crout's algortithm</a>, with partial pivoting.</p>\n+     * <p>\n+     * <strong>Usage Note</strong>:<br>\n+     * This method should rarely be invoked directly. Its only use is\n+     * to force recomputation of the LU decomposition when changes have been\n+     * made to the underlying data using direct array references. Changes\n+     * made using setXxx methods will trigger recomputation when needed\n+     * automatically.</p>\n+     *\n+     * @throws InvalidMatrixException if the matrix is non-square or singular.\n+     */\n+    public void luDecompose() throws InvalidMatrixException {\n+        \n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n+        if (nRows != nCols) {\n+            throw new NonSquareMatrixException(getRowDimension(), getColumnDimension());\n+        }\n+        lu = this.getData();\n+        \n+        // Initialize permutation array and parity\n+        permutation = new int[nRows];\n+        for (int row = 0; row < nRows; row++) {\n+            permutation[row] = row;\n+        }\n+        parity = 1;\n+        \n+        // Loop over columns\n+        for (int col = 0; col < nCols; col++) {\n+            \n+            BigDecimal sum = ZERO;\n+            \n+            // upper\n+            for (int row = 0; row < col; row++) {\n+                final BigDecimal[] luRow = lu[row];\n+                sum = luRow[col];\n+                for (int i = 0; i < row; i++) {\n+                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n+                }\n+                luRow[col] = sum;\n+            }\n+            \n+            // lower\n+            int max = col; // permutation row\n+            BigDecimal largest = ZERO;\n+            for (int row = col; row < nRows; row++) {\n+                final BigDecimal[] luRow = lu[row];\n+                sum = luRow[col];\n+                for (int i = 0; i < col; i++) {\n+                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n+                }\n+                luRow[col] = sum;\n+                \n+                // maintain best permutation choice\n+                if (sum.abs().compareTo(largest) == 1) {\n+                    largest = sum.abs();\n+                    max = row;\n+                }\n+            }\n+            \n+            // Singularity check\n+            if (lu[max][col].abs().compareTo(TOO_SMALL) <= 0) {\n+                lu = null;\n+                throw new SingularMatrixException();\n+            }\n+            \n+            // Pivot if necessary\n+            if (max != col) {\n+                BigDecimal tmp = ZERO;\n+                for (int i = 0; i < nCols; i++) {\n+                    tmp = lu[max][i];\n+                    lu[max][i] = lu[col][i];\n+                    lu[col][i] = tmp;\n+                }\n+                int temp = permutation[max];\n+                permutation[max] = permutation[col];\n+                permutation[col] = temp;\n+                parity = -parity;\n+            }\n+            \n+            // Divide the lower elements by the \"winning\" diagonal elt.\n+            final BigDecimal luDiag = lu[col][col];\n+            for (int row = col + 1; row < nRows; row++) {\n+                final BigDecimal[] luRow = lu[row];\n+                luRow[col] = luRow[col].divide(luDiag, scale, roundingMode);\n+            }\n+            \n+        }\n+        \n+    }\n+    \n+    /**\n+     * Get a string representation for this matrix.\n+     * @return a string representation for this matrix\n+     */\n+    @Override\n+    public String toString() {\n+        StringBuffer res = new StringBuffer();\n+        res.append(\"BigMatrixImpl{\");\n+        if (data != null) {\n+            for (int i = 0; i < data.length; i++) {\n+                if (i > 0) {\n+                    res.append(\",\");\n+                }\n+                res.append(\"{\");\n+                for (int j = 0; j < data[0].length; j++) {\n+                    if (j > 0) {\n+                        res.append(\",\");\n+                    }\n+                    res.append(data[i][j]);\n+                } \n+                res.append(\"}\");\n+            } \n+        }\n+        res.append(\"}\");\n+        return res.toString();\n+    } \n+    \n+    /**\n+     * Returns true iff <code>object</code> is a \n+     * <code>BigMatrixImpl</code> instance with the same dimensions as this\n+     * and all corresponding matrix entries are equal.  BigDecimal.equals\n+     * is used to compare corresponding entries.\n+     * \n+     * @param object the object to test equality against.\n+     * @return true if object equals this\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (object == this ) {\n+            return true;\n+        }\n+        if (object instanceof BigMatrixImpl == false) {\n+            return false;\n+        }\n+        final BigMatrix m = (BigMatrix) object;\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (m.getColumnDimension() != nCols || m.getRowDimension() != nRows) {\n+            return false;\n+        }\n+        for (int row = 0; row < nRows; row++) {\n+            final BigDecimal[] dataRow = data[row];\n+            for (int col = 0; col < nCols; col++) {\n+                if (!dataRow[col].equals(m.getEntry(row, col))) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /**\n+     * Computes a hashcode for the matrix.\n+     * \n+     * @return hashcode for matrix\n+     */\n+    @Override\n+    public int hashCode() {\n+        int ret = 7;\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        ret = ret * 31 + nRows;\n+        ret = ret * 31 + nCols;\n+        for (int row = 0; row < nRows; row++) {\n+            final BigDecimal[] dataRow = data[row];\n+            for (int col = 0; col < nCols; col++) {\n+                ret = ret * 31 + (11 * (row+1) + 17 * (col+1)) * \n+                dataRow[col].hashCode();\n+            }\n+        }   \n+        return ret;\n+    }\n+    \n+    //------------------------ Protected methods\n+    \n+    /**\n+     *  Returns the LU decomposition as a BigMatrix.\n+     *  Returns a fresh copy of the cached LU matrix if this has been computed; \n+     *  otherwise the composition is computed and cached for use by other methods.   \n+     *  Since a copy is returned in either case, changes to the returned matrix do not \n+     *  affect the LU decomposition property. \n+     * <p>\n+     * The matrix returned is a compact representation of the LU decomposition. \n+     * Elements below the main diagonal correspond to entries of the \"L\" matrix;   \n+     * elements on and above the main diagonal correspond to entries of the \"U\"\n+     * matrix.</p>\n+     * <p>\n+     * Example: <pre>\n+     * \n+     *     Returned matrix                L                  U\n+     *         2  3  1                   1  0  0            2  3  1          \n+     *         5  4  6                   5  1  0            0  4  6\n+     *         1  7  8                   1  7  1            0  0  8          \n+     * </pre>\n+     * \n+     * The L and U matrices satisfy the matrix equation LU = permuteRows(this), <br>\n+     *  where permuteRows reorders the rows of the matrix to follow the order determined\n+     *  by the <a href=#getPermutation()>permutation</a> property.</p>\n+     * \n+     * @return LU decomposition matrix\n+     * @throws InvalidMatrixException if the matrix is non-square or singular.\n+     */\n+    protected BigMatrix getLUMatrix() throws InvalidMatrixException {\n+        if (lu == null) {\n+            luDecompose();\n+        }\n+        return new BigMatrixImpl(lu);\n+    }\n+    \n+    /**\n+     * Returns the permutation associated with the lu decomposition.\n+     * The entries of the array represent a permutation of the numbers 0, ... , nRows - 1.\n+     * <p>\n+     * Example:\n+     * permutation = [1, 2, 0] means current 2nd row is first, current third row is second\n+     * and current first row is last.</p>\n+     * <p>\n+     * Returns a fresh copy of the array.</p>\n+     * \n+     * @return the permutation\n+     */\n+    protected int[] getPermutation() {\n+        final int[] out = new int[permutation.length];\n+        System.arraycopy(permutation, 0, out, 0, permutation.length);\n+        return out;\n+    }\n+    \n+    //------------------------ Private methods\n+    \n+    /**\n+     * Returns a fresh copy of the underlying data array.\n+     *\n+     * @return a copy of the underlying data array.\n+     */\n+    private BigDecimal[][] copyOut() {\n+        final int nRows = this.getRowDimension();\n+        final BigDecimal[][] out = new BigDecimal[nRows][this.getColumnDimension()];\n+        // can't copy 2-d array in one shot, otherwise get row references\n+        for (int i = 0; i < nRows; i++) {\n+            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     * Replaces data with a fresh copy of the input array.\n+     * <p>\n+     * Verifies that the input array is rectangular and non-empty.</p>\n+     *\n+     * @param in data to copy in\n+     * @throws IllegalArgumentException if input array is emtpy or not\n+     *    rectangular\n+     * @throws NullPointerException if input array is null\n+     */\n+    private void copyIn(BigDecimal[][] in) {\n+        setSubMatrix(in,0,0);\n+    }\n+    \n+    /**\n+     * Replaces data with a fresh copy of the input array.\n+     *\n+     * @param in data to copy in\n+     */\n+    private void copyIn(double[][] in) {\n+        final int nRows = in.length;\n+        final int nCols = in[0].length;\n+        data = new BigDecimal[nRows][nCols];\n+        for (int i = 0; i < nRows; i++) {\n+            final BigDecimal[] dataI = data[i];\n+            final double[] inI = in[i];\n+            for (int j = 0; j < nCols; j++) {\n+                dataI[j] = new BigDecimal(inI[j]);\n+            }\n+        }\n+        lu = null;\n+    }\n+    \n+    /**\n+     * Replaces data with BigDecimals represented by the strings in the input\n+     * array.\n+     *\n+     * @param in data to copy in\n+     */\n+    private void copyIn(String[][] in) {\n+        final int nRows = in.length;\n+        final int nCols = in[0].length;\n+        data = new BigDecimal[nRows][nCols];\n+        for (int i = 0; i < nRows; i++) {\n+            final BigDecimal[] dataI = data[i];\n+            final String[] inI = in[i];\n+            for (int j = 0; j < nCols; j++) {\n+                dataI[j] = new BigDecimal(inI[j]);\n+            }\n+        }\n+        lu = null;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Cache-friendly implementation of FieldMatrix using a flat arrays to store\n+ * square blocks of the matrix.\n+ * <p>\n+ * This implementation is specially designed to be cache-friendly. Square blocks are\n+ * stored as small arrays and allow efficient traversal of data both in row major direction\n+ * and columns major direction, one block at a time. This greatly increases performances\n+ * for algorithms that use crossed directions loops like multiplication or transposition.\n+ * </p>\n+ * <p>\n+ * The size of square blocks is a static parameter. It may be tuned according to the cache\n+ * size of the target computer processor. As a rule of thumbs, it should be the largest\n+ * value that allows three blocks to be simultaneously cached (this is necessary for example\n+ * for matrix multiplication). The default value is to use 36x36 blocks.\n+ * </p>\n+ * <p>\n+ * The regular blocks represent {@link #BLOCK_SIZE} x {@link #BLOCK_SIZE} squares. Blocks\n+ * at right hand side and bottom side which may be smaller to fit matrix dimensions. The square\n+ * blocks are flattened in row major order in single dimension arrays which are therefore\n+ * {@link #BLOCK_SIZE}<sup>2</sup> elements long for regular blocks. The blocks are themselves\n+ * organized in row major order.\n+ * </p>\n+ * <p>\n+ * As an example, for a block size of 36x36, a 100x60 matrix would be stored in 6 blocks.\n+ * Block 0 would be a Field[1296] array holding the upper left 36x36 square, block 1 would be\n+ * a Field[1296] array holding the upper center 36x36 square, block 2 would be a Field[1008]\n+ * array holding the upper right 36x28 rectangle, block 3 would be a Field[864] array holding\n+ * the lower left 24x36 rectangle, block 4 would be a Field[864] array holding the lower center\n+ * 24x36 rectangle and block 5 would be a Field[672] array holding the lower right 24x28\n+ * rectangle.\n+ * </p>\n+ * <p>\n+ * The layout complexity overhead versus simple mapping of matrices to java\n+ * arrays is negligible for small matrices (about 1%). The gain from cache efficiency leads\n+ * to up to 3-fold improvements for matrices of moderate to large size.\n+ * </p>\n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class BlockFieldMatrix<T extends FieldElement<T>> extends AbstractFieldMatrix<T> implements Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -4602336630143123183L;\n+\n+    /** Block size. */\n+    public static final int BLOCK_SIZE = 36;\n+\n+    /** Blocks of matrix entries. */\n+    private final T blocks[][];\n+\n+    /** Number of rows of the matrix. */\n+    private final int rows;\n+\n+    /** Number of columns of the matrix. */\n+    private final int columns;\n+\n+    /** Number of block rows of the matrix. */\n+    private final int blockRows;\n+\n+    /** Number of block columns of the matrix. */\n+    private final int blockColumns;\n+\n+    /**\n+     * Create a new matrix with the supplied row and column dimensions.\n+     *\n+     * @param field field to which the elements belong\n+     * @param rows  the number of rows in the new matrix\n+     * @param columns  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not\n+     *  positive\n+     */\n+    public BlockFieldMatrix(final Field<T> field, final int rows, final int columns)\n+        throws IllegalArgumentException {\n+\n+        super(field, rows, columns);\n+        this.rows    = rows;\n+        this.columns = columns;\n+\n+        // number of blocks\n+        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        // allocate storage blocks, taking care of smaller ones at right and bottom\n+        blocks = createBlocksLayout(field, rows, columns);\n+\n+    }\n+\n+    /**\n+     * Create a new dense matrix copying entries from raw layout data.\n+     * <p>The input array <em>must</em> already be in raw layout.</p>\n+     * <p>Calling this constructor is equivalent to call:\n+     * <pre>matrix = new BlockFieldMatrix<T>(getField(), rawData.length, rawData[0].length,\n+     *                                   toBlocksLayout(rawData), false);</pre>\n+     * </p>\n+     * @param rawData data for new matrix, in raw layout\n+     *\n+     * @exception IllegalArgumentException if <code>blockData</code> shape is\n+     * inconsistent with block layout\n+     * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)\n+     */\n+    public BlockFieldMatrix(final T[][] rawData)\n+        throws IllegalArgumentException {\n+        this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n+    }\n+\n+    /**\n+     * Create a new dense matrix copying entries from block layout data.\n+     * <p>The input array <em>must</em> already be in blocks layout.</p>\n+     * @param rows  the number of rows in the new matrix\n+     * @param columns  the number of columns in the new matrix\n+     * @param blockData data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     *\n+     * @exception IllegalArgumentException if <code>blockData</code> shape is\n+     * inconsistent with block layout\n+     * @see #createBlocksLayout(Field, int, int)\n+     * @see #toBlocksLayout(FieldElement[][])\n+     * @see #BlockFieldMatrix(FieldElement[][])\n+     */\n+    public BlockFieldMatrix(final int rows, final int columns,\n+                            final T[][] blockData, final boolean copyArray)\n+        throws IllegalArgumentException {\n+\n+        super(extractField(blockData), rows, columns);\n+        this.rows    = rows;\n+        this.columns = columns;\n+\n+        // number of blocks\n+        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        if (copyArray) {\n+            // allocate storage blocks, taking care of smaller ones at right and bottom\n+            blocks = buildArray(getField(), blockRows * blockColumns, -1);\n+        } else {\n+            // reference existing array\n+            blocks = blockData;\n+        }\n+\n+        int index = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n+                if (blockData[index].length != iHeight * blockWidth(jBlock)) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"wrong array shape (block length = {0}, expected {1})\",\n+                            blockData[index].length, iHeight * blockWidth(jBlock));\n+                }\n+                if (copyArray) {\n+                    blocks[index] = blockData[index].clone();\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * Convert a data array from raw layout to blocks layout.\n+     * <p>\n+     * Raw layout is the straightforward layout where element at row i and\n+     * column j is in array element <code>rawData[i][j]</code>. Blocks layout\n+     * is the layout used in {@link BlockFieldMatrix} instances, where the matrix\n+     * is split in square blocks (except at right and bottom side where blocks may\n+     * be rectangular to fit matrix size) and each block is stored in a flattened\n+     * one-dimensional array.\n+     * </p>\n+     * <p>\n+     * This method creates an array in blocks layout from an input array in raw layout.\n+     * It can be used to provide the array argument of the {@link\n+     * #BlockFieldMatrix(int, int, FieldElement[][], boolean)}\n+     * constructor.\n+     * </p>\n+     * @param <T> the type of the field elements\n+     * @param rawData data array in raw layout\n+     * @return a new data array containing the same entries but in blocks layout\n+     * @exception IllegalArgumentException if <code>rawData</code> is not rectangular\n+     *  (not all rows have the same length)\n+     * @see #createBlocksLayout(Field, int, int)\n+     * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)\n+     */\n+    public static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData)\n+        throws IllegalArgumentException {\n+\n+        final int rows         = rawData.length;\n+        final int columns      = rawData[0].length;\n+        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        // safety checks\n+        for (int i = 0; i < rawData.length; ++i) {\n+            final int length = rawData[i].length;\n+            if (length != columns) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some rows have length {0} while others have length {1}\",\n+                        columns, length); \n+            }\n+        }\n+\n+        // convert array\n+        final Field<T> field = extractField(rawData);\n+        final T[][] blocks = buildArray(field, blockRows * blockColumns, -1);\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart  = iBlock * BLOCK_SIZE;\n+            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int iHeight = pEnd - pStart;\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int jWidth = qEnd - qStart;\n+\n+                // allocate new block\n+                final T[] block = buildArray(field, iHeight * jWidth);\n+                blocks[blockIndex] = block;\n+\n+                // copy data\n+                for (int p = pStart, index = 0; p < pEnd; ++p, index += jWidth) {\n+                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n+                }\n+\n+            }\n+        }\n+\n+        return blocks;\n+\n+    }\n+\n+    /**\n+     * Create a data array in blocks layout.\n+     * <p>\n+     * This method can be used to create the array argument of the {@link\n+     * #BlockFieldMatrix(int, int, FieldElement[][], boolean)}\n+     * constructor.\n+     * </p>\n+     * @param <T> the type of the field elements\n+     * @param field field to which the elements belong\n+     * @param rows  the number of rows in the new matrix\n+     * @param columns  the number of columns in the new matrix\n+     * @return a new data array in blocks layout\n+     * @see #toBlocksLayout(FieldElement[][])\n+     * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)\n+     */\n+    public static <T extends FieldElement<T>> T[][] createBlocksLayout(final Field<T> field,\n+                                                                       final int rows, final int columns) {\n+\n+        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        final T[][] blocks = buildArray(field, blockRows * blockColumns, -1);\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart  = iBlock * BLOCK_SIZE;\n+            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int iHeight = pEnd - pStart;\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int jWidth = qEnd - qStart;\n+                blocks[blockIndex] = buildArray(field, iHeight * jWidth);\n+            }\n+        }\n+\n+        return blocks;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        return new BlockFieldMatrix<T>(getField(), rowDimension, columnDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> copy() {\n+\n+        // create an empty matrix\n+        BlockFieldMatrix<T> copied = new BlockFieldMatrix<T>(getField(), rows, columns);\n+\n+        // copy the blocks\n+        for (int i = 0; i < blocks.length; ++i) {\n+            System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);\n+        }\n+\n+        return copied;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> add(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        try {\n+            return add((BlockFieldMatrix<T>) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            checkAdditionCompatible(m);\n+\n+            final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns);\n+\n+            // perform addition block-wise, to ensure good cache behavior\n+            int blockIndex = 0;\n+            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+\n+                    // perform addition on the current block\n+                    final T[] outBlock = out.blocks[blockIndex];\n+                    final T[] tBlock   = blocks[blockIndex];\n+                    final int      pStart   = iBlock * BLOCK_SIZE;\n+                    final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n+                    final int      qStart   = jBlock * BLOCK_SIZE;\n+                    final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n+                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        for (int q = qStart; q < qEnd; ++q, ++k) {\n+                            outBlock[k] = tBlock[k].add(m.getEntry(p, q));\n+                        }\n+                    }\n+\n+                    // go to next block\n+                    ++blockIndex;\n+\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public BlockFieldMatrix<T> add(final BlockFieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkAdditionCompatible(m);\n+\n+        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns);\n+\n+        // perform addition block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final T[] outBlock = out.blocks[blockIndex];\n+            final T[] tBlock   = blocks[blockIndex];\n+            final T[] mBlock   = m.blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k].add(mBlock[k]);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> subtract(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        try {\n+            return subtract((BlockFieldMatrix<T>) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            checkSubtractionCompatible(m);\n+\n+            final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns);\n+\n+            // perform subtraction block-wise, to ensure good cache behavior\n+            int blockIndex = 0;\n+            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+\n+                    // perform subtraction on the current block\n+                    final T[] outBlock = out.blocks[blockIndex];\n+                    final T[] tBlock   = blocks[blockIndex];\n+                    final int      pStart   = iBlock * BLOCK_SIZE;\n+                    final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n+                    final int      qStart   = jBlock * BLOCK_SIZE;\n+                    final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n+                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        for (int q = qStart; q < qEnd; ++q, ++k) {\n+                            outBlock[k] = tBlock[k].subtract(m.getEntry(p, q));\n+                        }\n+                    }\n+\n+                    // go to next block\n+                    ++blockIndex;\n+\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Compute this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this - m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public BlockFieldMatrix<T> subtract(final BlockFieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        checkSubtractionCompatible(m);\n+\n+        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns);\n+\n+        // perform subtraction block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final T[] outBlock = out.blocks[blockIndex];\n+            final T[] tBlock   = blocks[blockIndex];\n+            final T[] mBlock   = m.blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k].subtract(mBlock[k]);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> scalarAdd(final T d)\n+        throws IllegalArgumentException {\n+\n+        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns);\n+\n+        // perform subtraction block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final T[] outBlock = out.blocks[blockIndex];\n+            final T[] tBlock   = blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k].add(d);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> scalarMultiply(final T d)\n+        throws IllegalArgumentException {\n+\n+        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns);\n+\n+        // perform subtraction block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final T[] outBlock = out.blocks[blockIndex];\n+            final T[] tBlock   = blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k].multiply(d);\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> multiply(final FieldMatrix<T> m)\n+        throws IllegalArgumentException {\n+        try {\n+            return multiply((BlockFieldMatrix<T>) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            checkMultiplicationCompatible(m);\n+\n+            final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, m.getColumnDimension());\n+            final T zero = getField().getZero();\n+\n+            // perform multiplication block-wise, to ensure good cache behavior\n+            int blockIndex = 0;\n+            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+\n+                final int pStart = iBlock * BLOCK_SIZE;\n+                final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+\n+                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n+\n+                    // select current block\n+                    final T[] outBlock = out.blocks[blockIndex];\n+\n+                    // perform multiplication on current block\n+                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n+                        final int kWidth      = blockWidth(kBlock);\n+                        final T[] tBlock = blocks[iBlock * blockColumns + kBlock];\n+                        final int rStart      = kBlock * BLOCK_SIZE;\n+                        for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                            final int lStart = (p - pStart) * kWidth;\n+                            final int lEnd   = lStart + kWidth;\n+                            for (int q = qStart; q < qEnd; ++q) {\n+                                T sum = zero;\n+                                for (int l = lStart, r = rStart; l < lEnd; ++l, ++r) {\n+                                    sum = sum.add(tBlock[l].multiply(m.getEntry(r, q)));\n+                                }\n+                                outBlock[k] = outBlock[k].add(sum);\n+                                ++k;\n+                            }\n+                        }\n+                    }\n+\n+                    // go to next block\n+                    ++blockIndex;\n+\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by m.\n+     *\n+     * @param m    matrix to postmultiply by\n+     * @return     this * m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public BlockFieldMatrix<T> multiply(BlockFieldMatrix<T> m) throws IllegalArgumentException {\n+\n+        // safety check\n+        checkMultiplicationCompatible(m);\n+\n+        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, m.columns);\n+        final T zero = getField().getZero();\n+\n+        // perform multiplication block-wise, to ensure good cache behavior\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+\n+            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+                final int jWidth = out.blockWidth(jBlock);\n+                final int jWidth2 = jWidth  + jWidth;\n+                final int jWidth3 = jWidth2 + jWidth;\n+                final int jWidth4 = jWidth3 + jWidth;\n+\n+                // select current block\n+                final T[] outBlock = out.blocks[blockIndex];\n+\n+                // perform multiplication on current block\n+                for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n+                    final int kWidth = blockWidth(kBlock);\n+                    final T[] tBlock = blocks[iBlock * blockColumns + kBlock];\n+                    final T[] mBlock = m.blocks[kBlock * m.blockColumns + jBlock];\n+                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        final int lStart = (p - pStart) * kWidth;\n+                        final int lEnd   = lStart + kWidth;\n+                        for (int nStart = 0; nStart < jWidth; ++nStart) {\n+                            T sum = zero;\n+                            int l = lStart;\n+                            int n = nStart;\n+                            while (l < lEnd - 3) {\n+                                sum = sum.\n+                                      add(tBlock[l].multiply(mBlock[n])).\n+                                      add(tBlock[l + 1].multiply(mBlock[n + jWidth])).\n+                                      add(tBlock[l + 2].multiply(mBlock[n + jWidth2])).\n+                                      add(tBlock[l + 3].multiply(mBlock[n + jWidth3]));\n+                                l += 4;\n+                                n += jWidth4;\n+                            }\n+                            while (l < lEnd) {\n+                                sum = sum.add(tBlock[l++].multiply(mBlock[n]));\n+                                n += jWidth;\n+                            }\n+                            outBlock[k] = outBlock[k].add(sum);\n+                            ++k;\n+                        }\n+                    }\n+                }\n+\n+                // go to next block\n+                ++blockIndex;\n+\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[][] getData() {\n+\n+        final T[][] data = buildArray(getField(), getRowDimension(), getColumnDimension());\n+        final int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE;\n+\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            int regularPos   = 0;\n+            int lastPos      = 0;\n+            for (int p = pStart; p < pEnd; ++p) {\n+                final T[] dataP = data[p];\n+                int blockIndex = iBlock * blockColumns;\n+                int dataPos    = 0;\n+                for (int jBlock = 0; jBlock < blockColumns - 1; ++jBlock) {\n+                    System.arraycopy(blocks[blockIndex++], regularPos, dataP, dataPos, BLOCK_SIZE);\n+                    dataPos += BLOCK_SIZE;\n+                }\n+                System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);\n+                regularPos += BLOCK_SIZE;\n+                lastPos    += lastColumns;\n+            }\n+        }\n+\n+        return data;\n+        \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> getSubMatrix(final int startRow, final int endRow,\n+                                   final int startColumn, final int endColumn)\n+        throws MatrixIndexException {\n+\n+        // safety checks\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+\n+        // create the output matrix\n+        final BlockFieldMatrix<T> out =\n+            new BlockFieldMatrix<T>(getField(), endRow - startRow + 1, endColumn - startColumn + 1);\n+\n+        // compute blocks shifts\n+        final int blockStartRow    = startRow    / BLOCK_SIZE;\n+        final int rowsShift        = startRow    % BLOCK_SIZE;\n+        final int blockStartColumn = startColumn / BLOCK_SIZE;\n+        final int columnsShift     = startColumn % BLOCK_SIZE;\n+\n+        // perform extraction block-wise, to ensure good cache behavior\n+        for (int iBlock = 0, pBlock = blockStartRow; iBlock < out.blockRows; ++iBlock, ++pBlock) {\n+            final int iHeight = out.blockHeight(iBlock);\n+            for (int jBlock = 0, qBlock = blockStartColumn; jBlock < out.blockColumns; ++jBlock, ++qBlock) {\n+                final int jWidth = out.blockWidth(jBlock);\n+\n+                // handle one block of the output matrix\n+                final int      outIndex = iBlock * out.blockColumns + jBlock;\n+                final T[] outBlock = out.blocks[outIndex];\n+                final int      index    = pBlock * blockColumns + qBlock;\n+                final int      width    = blockWidth(qBlock);\n+\n+                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\n+                final int widthExcess  = jWidth + columnsShift - BLOCK_SIZE;\n+                if (heightExcess > 0) {\n+                    // the submatrix block spans on two blocks rows from the original matrix\n+                    if (widthExcess > 0) {\n+                        // the submatrix block spans on two blocks columns from the original matrix\n+                        final int width2 = blockWidth(qBlock + 1);\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, BLOCK_SIZE,\n+                                      columnsShift, BLOCK_SIZE,\n+                                      outBlock, jWidth, 0, 0);\n+                        copyBlockPart(blocks[index + 1], width2,\n+                                      rowsShift, BLOCK_SIZE,\n+                                      0, widthExcess,\n+                                      outBlock, jWidth, 0, jWidth - widthExcess);\n+                        copyBlockPart(blocks[index + blockColumns], width,\n+                                      0, heightExcess,\n+                                      columnsShift, BLOCK_SIZE,\n+                                      outBlock, jWidth, iHeight - heightExcess, 0);\n+                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n+                                      0, heightExcess,\n+                                      0, widthExcess,\n+                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n+                    } else {\n+                        // the submatrix block spans on one block column from the original matrix\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, BLOCK_SIZE,\n+                                      columnsShift, jWidth + columnsShift,\n+                                      outBlock, jWidth, 0, 0);\n+                        copyBlockPart(blocks[index + blockColumns], width,\n+                                      0, heightExcess,\n+                                      columnsShift, jWidth + columnsShift,\n+                                      outBlock, jWidth, iHeight - heightExcess, 0);\n+                    }\n+                } else {\n+                    // the submatrix block spans on one block row from the original matrix\n+                    if (widthExcess > 0) {\n+                        // the submatrix block spans on two blocks columns from the original matrix\n+                        final int width2 = blockWidth(qBlock + 1);\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, iHeight + rowsShift,\n+                                      columnsShift, BLOCK_SIZE,\n+                                      outBlock, jWidth, 0, 0);\n+                        copyBlockPart(blocks[index + 1], width2,\n+                                      rowsShift, iHeight + rowsShift,\n+                                      0, widthExcess,\n+                                      outBlock, jWidth, 0, jWidth - widthExcess);\n+                    } else {\n+                        // the submatrix block spans on one block column from the original matrix\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, iHeight + rowsShift,\n+                                      columnsShift, jWidth + columnsShift,\n+                                      outBlock, jWidth, 0, 0);\n+                    }\n+               }\n+\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /**\n+     * Copy a part of a block into another one\n+     * <p>This method can be called only when the specified part fits in both\n+     * blocks, no verification is done here.</p>\n+     * @param srcBlock source block\n+     * @param srcWidth source block width ({@link #BLOCK_SIZE} or smaller)\n+     * @param srcStartRow start row in the source block\n+     * @param srcEndRow end row (exclusive) in the source block\n+     * @param srcStartColumn start column in the source block\n+     * @param srcEndColumn end column (exclusive) in the source block\n+     * @param dstBlock destination block\n+     * @param dstWidth destination block width ({@link #BLOCK_SIZE} or smaller)\n+     * @param dstStartRow start row in the destination block\n+     * @param dstStartColumn start column in the destination block\n+     */\n+    private void copyBlockPart(final T[] srcBlock, final int srcWidth,\n+                               final int srcStartRow, final int srcEndRow,\n+                               final int srcStartColumn, final int srcEndColumn,\n+                               final T[] dstBlock, final int dstWidth,\n+                               final int dstStartRow, final int dstStartColumn) {\n+        final int length = srcEndColumn - srcStartColumn;\n+        int srcPos = srcStartRow * srcWidth + srcStartColumn;\n+        int dstPos = dstStartRow * dstWidth + dstStartColumn;\n+        for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {\n+            System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);\n+            srcPos += srcWidth;\n+            dstPos += dstWidth;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setSubMatrix(final T[][] subMatrix, final int row, final int column)\n+        throws MatrixIndexException {\n+\n+        // safety checks\n+        final int refLength = subMatrix[0].length;\n+        if (refLength < 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");             \n+        }\n+        final int endRow    = row + subMatrix.length - 1;\n+        final int endColumn = column + refLength - 1;\n+        checkSubMatrixIndex(row, endRow, column, endColumn);\n+        for (final T[] subRow : subMatrix) {\n+            if (subRow.length != refLength) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some rows have length {0} while others have length {1}\",\n+                        refLength, subRow.length); \n+            }\n+        }\n+\n+        // compute blocks bounds\n+        final int blockStartRow    = row / BLOCK_SIZE;\n+        final int blockEndRow      = (endRow + BLOCK_SIZE) / BLOCK_SIZE;\n+        final int blockStartColumn = column / BLOCK_SIZE;\n+        final int blockEndColumn   = (endColumn + BLOCK_SIZE) / BLOCK_SIZE;\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {\n+            final int iHeight  = blockHeight(iBlock);\n+            final int firstRow = iBlock * BLOCK_SIZE;\n+            final int iStart   = Math.max(row,    firstRow);\n+            final int iEnd     = Math.min(endRow + 1, firstRow + iHeight);\n+\n+            for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {\n+                final int jWidth      = blockWidth(jBlock);\n+                final int firstColumn = jBlock * BLOCK_SIZE;\n+                final int jStart      = Math.max(column,    firstColumn);\n+                final int jEnd        = Math.min(endColumn + 1, firstColumn + jWidth);\n+                final int jLength     = jEnd - jStart;\n+\n+                // handle one block, row by row\n+                final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int i = iStart; i < iEnd; ++i) {\n+                    System.arraycopy(subMatrix[i - row], jStart - column,\n+                                     block, (i - firstRow) * jWidth + (jStart - firstColumn),\n+                                     jLength);\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> getRowMatrix(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), 1, columns);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outBlockIndex = 0;\n+        int outIndex      = 0;\n+        T[] outBlock = out.blocks[outBlockIndex];\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            final int available  = outBlock.length - outIndex;\n+            if (jWidth > available) {\n+                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, available);\n+                outBlock = out.blocks[++outBlockIndex];\n+                System.arraycopy(block, iRow * jWidth, outBlock, 0, jWidth - available);\n+                outIndex = jWidth - available;\n+            } else {\n+                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, jWidth);\n+                outIndex += jWidth;\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setRowMatrix(final int row, final FieldMatrix<T> matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setRowMatrix(row, (BlockFieldMatrix<T>) matrix);\n+        } catch (ClassCastException cce) {\n+            super.setRowMatrix(row, matrix);\n+        }\n+    }\n+\n+    /**\n+     * Sets the entries in row number <code>row</code>\n+     * as a row matrix.  Row indices start at 0.\n+     *\n+     * @param row the row to be set\n+     * @param matrix row matrix (must have one row and the same number of columns\n+     * as the instance)\n+     * @throws MatrixIndexException if the specified row index is invalid\n+     * @throws InvalidMatrixException if the matrix dimensions do not match one\n+     * instance row\n+     */\n+    public void setRowMatrix(final int row, final BlockFieldMatrix<T> matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        if ((matrix.getRowDimension() != 1) ||\n+            (matrix.getColumnDimension() != nCols)) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(),\n+                    1, nCols);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock = row / BLOCK_SIZE;\n+        final int iRow   = row - iBlock * BLOCK_SIZE;\n+        int mBlockIndex  = 0;\n+        int mIndex       = 0;\n+        T[] mBlock  = matrix.blocks[mBlockIndex];\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            final int available  = mBlock.length - mIndex;\n+            if (jWidth > available) {\n+                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, available);\n+                mBlock = matrix.blocks[++mBlockIndex];\n+                System.arraycopy(mBlock, 0, block, iRow * jWidth, jWidth - available);\n+                mIndex = jWidth - available;\n+            } else {\n+                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, jWidth);\n+                mIndex += jWidth;\n+           }\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> getColumnMatrix(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, 1);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outBlockIndex = 0;\n+        int outIndex      = 0;\n+        T[] outBlock = out.blocks[outBlockIndex];\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                if (outIndex >= outBlock.length) {\n+                    outBlock = out.blocks[++outBlockIndex];\n+                    outIndex = 0;\n+                }\n+                outBlock[outIndex++] = block[i * jWidth + jColumn];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setColumnMatrix(final int column, final FieldMatrix<T> matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setColumnMatrix(column, (BlockFieldMatrix<T>) matrix);\n+        } catch (ClassCastException cce) {\n+            super.setColumnMatrix(column, matrix);\n+        }\n+    }\n+\n+    /**\n+     * Sets the entries in column number <code>column</code>\n+     * as a column matrix.  Column indices start at 0.\n+     *\n+     * @param column the column to be set\n+     * @param matrix column matrix (must have one column and the same number of rows\n+     * as the instance)\n+     * @throws MatrixIndexException if the specified column index is invalid\n+     * @throws InvalidMatrixException if the matrix dimensions do not match one\n+     * instance column\n+     */\n+    void setColumnMatrix(final int column, final BlockFieldMatrix<T> matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        if ((matrix.getRowDimension() != nRows) ||\n+            (matrix.getColumnDimension() != 1)) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(),\n+                    nRows, 1);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int mBlockIndex = 0;\n+        int mIndex      = 0;\n+        T[] mBlock = matrix.blocks[mBlockIndex];\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                if (mIndex >= mBlock.length) {\n+                    mBlock = matrix.blocks[++mBlockIndex];\n+                    mIndex = 0;\n+                }\n+                block[i * jWidth + jColumn] = mBlock[mIndex++];\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldVector<T> getRowVector(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final T[] outData = buildArray(getField(), columns);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outIndex      = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            System.arraycopy(block, iRow * jWidth, outData, outIndex, jWidth);\n+            outIndex += jWidth;\n+        }\n+\n+        return new ArrayFieldVector<T>(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setRowVector(final int row, final FieldVector<T> vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setRow(row, ((ArrayFieldVector<T>) vector).getDataRef());\n+        } catch (ClassCastException cce) {\n+            super.setRowVector(row, vector);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldVector<T> getColumnVector(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final T[] outData = buildArray(getField(), rows);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outIndex      = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                outData[outIndex++] = block[i * jWidth + jColumn];\n+            }\n+        }\n+\n+        return new ArrayFieldVector<T>(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setColumnVector(final int column, final FieldVector<T> vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setColumn(column, ((ArrayFieldVector<T>) vector).getDataRef());\n+        } catch (ClassCastException cce) {\n+            super.setColumnVector(column, vector);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[] getRow(final int row)\n+        throws MatrixIndexException {\n+\n+        checkRowIndex(row);\n+        final T[] out = buildArray(getField(), columns);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outIndex      = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            System.arraycopy(block, iRow * jWidth, out, outIndex, jWidth);\n+            outIndex += jWidth;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setRow(final int row, final T[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkRowIndex(row);\n+        final int nCols = getColumnDimension();\n+        if (array.length != nCols) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    1, array.length, 1, nCols);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outIndex      = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            System.arraycopy(array, outIndex, block, iRow * jWidth, jWidth);\n+            outIndex += jWidth;\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[] getColumn(final int column)\n+        throws MatrixIndexException {\n+\n+        checkColumnIndex(column);\n+        final T[] out = buildArray(getField(), rows);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outIndex      = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                out[outIndex++] = block[i * jWidth + jColumn];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setColumn(final int column, final T[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        checkColumnIndex(column);\n+        final int nRows = getRowDimension();\n+        if (array.length != nRows) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    array.length, 1, nRows, 1);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outIndex      = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final T[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                block[i * jWidth + jColumn] = array[outIndex++];\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T getEntry(final int row, final int column)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            return blocks[iBlock * blockColumns + jBlock][k];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(final int row, final int column, final T value)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            blocks[iBlock * blockColumns + jBlock][k] = value;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(final int row, final int column, final T increment)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            final T[] blockIJ = blocks[iBlock * blockColumns + jBlock];\n+            blockIJ[k] = blockIJ[k].add(increment);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(final int row, final int column, final T factor)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            final T[] blockIJ = blocks[iBlock * blockColumns + jBlock];\n+            blockIJ[k] = blockIJ[k].multiply(factor);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> transpose() {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n+\n+        // perform transpose block-wise, to ensure good cache behavior\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n+            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n+\n+                // transpose current block\n+                final T[] outBlock = out.blocks[blockIndex];\n+                final T[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n+                final int      pStart   = iBlock * BLOCK_SIZE;\n+                final int      pEnd     = Math.min(pStart + BLOCK_SIZE, columns);\n+                final int      qStart   = jBlock * BLOCK_SIZE;\n+                final int      qEnd     = Math.min(qStart + BLOCK_SIZE, rows);\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    final int lInc = pEnd - pStart;\n+                    for (int q = qStart, l = p - pStart; q < qEnd; ++q, l+= lInc) {\n+                        outBlock[k++] = tBlock[l];\n+                    }\n+                }\n+\n+                // go to next block\n+                ++blockIndex;\n+\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return rows;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return columns;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[] operate(final T[] v)\n+        throws IllegalArgumentException {\n+\n+        if (v.length != columns) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, columns);\n+        }\n+        final T[] out = buildArray(getField(), rows);\n+        final T zero = getField().getZero();\n+\n+        // perform multiplication block-wise, to ensure good cache behavior\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+                final T[] block  = blocks[iBlock * blockColumns + jBlock];\n+                final int      qStart = jBlock * BLOCK_SIZE;\n+                final int      qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    T sum = zero;\n+                    int q = qStart;\n+                    while (q < qEnd - 3) {\n+                        sum = sum.\n+                              add(block[k].multiply(v[q])).\n+                              add(block[k + 1].multiply(v[q + 1])).\n+                              add(block[k + 2].multiply(v[q + 2])).\n+                              add(block[k + 3].multiply(v[q + 3]));\n+                        k += 4;\n+                        q += 4;\n+                    }\n+                    while (q < qEnd) {\n+                        sum = sum.add(block[k++].multiply(v[q++]));\n+                    }\n+                    out[p] = out[p].add(sum);\n+                }\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T[] preMultiply(final T[] v)\n+        throws IllegalArgumentException {\n+\n+        if (v.length != rows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, rows);\n+        }\n+        final T[] out = buildArray(getField(), columns);\n+        final T zero = getField().getZero();\n+\n+        // perform multiplication block-wise, to ensure good cache behavior\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth  = blockWidth(jBlock);\n+            final int jWidth2 = jWidth  + jWidth;\n+            final int jWidth3 = jWidth2 + jWidth;\n+            final int jWidth4 = jWidth3 + jWidth;\n+            final int qStart = jBlock * BLOCK_SIZE;\n+            final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+            for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+                final T[] block  = blocks[iBlock * blockColumns + jBlock];\n+                final int      pStart = iBlock * BLOCK_SIZE;\n+                final int      pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+                for (int q = qStart; q < qEnd; ++q) {\n+                    int k = q - qStart;\n+                    T sum = zero;\n+                    int p = pStart;\n+                    while (p < pEnd - 3) {\n+                        sum = sum.\n+                              add(block[k].multiply(v[p])).\n+                              add(block[k + jWidth].multiply(v[p + 1])).\n+                              add(block[k + jWidth2].multiply(v[p + 2])).\n+                              add(block[k + jWidth3].multiply(v[p + 3]));\n+                        k += jWidth4;\n+                        p += 4;\n+                    }\n+                    while (p < pEnd) {\n+                        sum = sum.add(block[k].multiply(v[p++]));\n+                        k += jWidth;\n+                    }\n+                    out[q] = out[q].add(sum);\n+                }\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int q0     = jBlock * BLOCK_SIZE;\n+                    final int qStart = Math.max(startColumn, q0);\n+                    final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int q0     = jBlock * BLOCK_SIZE;\n+                    final int qStart = Math.max(startColumn, q0);\n+                    final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                    final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final T[] block = blocks[blockIndex];\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    for (int q = qStart; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final T[] block = blocks[blockIndex];\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    for (int q = qStart; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                final int jWidth = blockWidth(jBlock);\n+                final int q0     = jBlock * BLOCK_SIZE;\n+                final int qStart = Math.max(startColumn, q0);\n+                final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int p = pStart; p < pEnd; ++p) {\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                final int jWidth = blockWidth(jBlock);\n+                final int q0     = jBlock * BLOCK_SIZE;\n+                final int qStart = Math.max(startColumn, q0);\n+                final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                final T[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int p = pStart; p < pEnd; ++p) {\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /**\n+     * Get the height of a block.\n+     * @param blockRow row index (in block sense) of the block\n+     * @return height (number of rows) of the block\n+     */\n+    private int blockHeight(final int blockRow) {\n+        return (blockRow == blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE;\n+    }\n+\n+    /**\n+     * Get the width of a block.\n+     * @param blockColumn column index (in block sense) of the block\n+     * @return width (number of columns) of the block\n+     */\n+    private int blockWidth(final int blockColumn) {\n+        return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/BlockRealMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Cache-friendly implementation of RealMatrix using a flat arrays to store\n+ * square blocks of the matrix.\n+ * <p>\n+ * This implementation is specially designed to be cache-friendly. Square blocks are\n+ * stored as small arrays and allow efficient traversal of data both in row major direction\n+ * and columns major direction, one block at a time. This greatly increases performances\n+ * for algorithms that use crossed directions loops like multiplication or transposition.\n+ * </p>\n+ * <p>\n+ * The size of square blocks is a static parameter. It may be tuned according to the cache\n+ * size of the target computer processor. As a rule of thumbs, it should be the largest\n+ * value that allows three blocks to be simultaneously cached (this is necessary for example\n+ * for matrix multiplication). The default value is to use 52x52 blocks which is well suited\n+ * for processors with 64k L1 cache (one block holds 2704 values or 21632 bytes). This value\n+ * could be lowered to 36x36 for processors with 32k L1 cache.\n+ * </p>\n+ * <p>\n+ * The regular blocks represent {@link #BLOCK_SIZE} x {@link #BLOCK_SIZE} squares. Blocks\n+ * at right hand side and bottom side which may be smaller to fit matrix dimensions. The square\n+ * blocks are flattened in row major order in single dimension arrays which are therefore\n+ * {@link #BLOCK_SIZE}<sup>2</sup> elements long for regular blocks. The blocks are themselves\n+ * organized in row major order.\n+ * </p>\n+ * <p>\n+ * As an example, for a block size of 52x52, a 100x60 matrix would be stored in 4 blocks.\n+ * Block 0 would be a double[2704] array holding the upper left 52x52 square, block 1 would be\n+ * a double[416] array holding the upper right 52x8 rectangle, block 2 would be a double[2496]\n+ * array holding the lower left 48x52 rectangle and block 3 would be a double[384] array\n+ * holding the lower right 48x8 rectangle.\n+ * </p>\n+ * <p>\n+ * The layout complexity overhead versus simple mapping of matrices to java\n+ * arrays is negligible for small matrices (about 1%). The gain from cache efficiency leads\n+ * to up to 3-fold improvements for matrices of moderate to large size.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class BlockRealMatrix extends AbstractRealMatrix implements Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 4991895511313664478L;\n+\n+    /** Block size. */\n+    public static final int BLOCK_SIZE = 52;\n+\n+    /** Blocks of matrix entries. */\n+    private final double blocks[][];\n+\n+    /** Number of rows of the matrix. */\n+    private final int rows;\n+\n+    /** Number of columns of the matrix. */\n+    private final int columns;\n+\n+    /** Number of block rows of the matrix. */\n+    private final int blockRows;\n+\n+    /** Number of block columns of the matrix. */\n+    private final int blockColumns;\n+\n+    /**\n+     * Create a new matrix with the supplied row and column dimensions.\n+     *\n+     * @param rows  the number of rows in the new matrix\n+     * @param columns  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not\n+     *  positive\n+     */\n+    public BlockRealMatrix(final int rows, final int columns)\n+        throws IllegalArgumentException {\n+\n+        super(rows, columns);\n+        this.rows    = rows;\n+        this.columns = columns;\n+\n+        // number of blocks\n+        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        // allocate storage blocks, taking care of smaller ones at right and bottom\n+        blocks = createBlocksLayout(rows, columns);\n+\n+    }\n+\n+    /**\n+     * Create a new dense matrix copying entries from raw layout data.\n+     * <p>The input array <em>must</em> already be in raw layout.</p>\n+     * <p>Calling this constructor is equivalent to call:\n+     * <pre>matrix = new BlockRealMatrix(rawData.length, rawData[0].length,\n+     *                                   toBlocksLayout(rawData), false);</pre>\n+     * </p>\n+     * @param rawData data for new matrix, in raw layout\n+     *\n+     * @exception IllegalArgumentException if <code>blockData</code> shape is\n+     * inconsistent with block layout\n+     * @see #BlockRealMatrix(int, int, double[][], boolean)\n+     */\n+    public BlockRealMatrix(final double[][] rawData)\n+        throws IllegalArgumentException {\n+        this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n+    }\n+\n+    /**\n+     * Create a new dense matrix copying entries from block layout data.\n+     * <p>The input array <em>must</em> already be in blocks layout.</p>\n+     * @param rows  the number of rows in the new matrix\n+     * @param columns  the number of columns in the new matrix\n+     * @param blockData data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     *\n+     * @exception IllegalArgumentException if <code>blockData</code> shape is\n+     * inconsistent with block layout\n+     * @see #createBlocksLayout(int, int)\n+     * @see #toBlocksLayout(double[][])\n+     * @see #BlockRealMatrix(double[][])\n+     */\n+    public BlockRealMatrix(final int rows, final int columns,\n+                           final double[][] blockData, final boolean copyArray)\n+        throws IllegalArgumentException {\n+\n+        super(rows, columns);\n+        this.rows    = rows;\n+        this.columns = columns;\n+\n+        // number of blocks\n+        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        if (copyArray) {\n+            // allocate storage blocks, taking care of smaller ones at right and bottom\n+            blocks = new double[blockRows * blockColumns][];\n+        } else {\n+            // reference existing array\n+            blocks = blockData;\n+        }\n+\n+        int index = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n+                if (blockData[index].length != iHeight * blockWidth(jBlock)) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"wrong array shape (block length = {0}, expected {1})\",\n+                            blockData[index].length, iHeight * blockWidth(jBlock));\n+                }\n+                if (copyArray) {\n+                    blocks[index] = blockData[index].clone();\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    /**\n+     * Convert a data array from raw layout to blocks layout.\n+     * <p>\n+     * Raw layout is the straightforward layout where element at row i and\n+     * column j is in array element <code>rawData[i][j]</code>. Blocks layout\n+     * is the layout used in {@link BlockRealMatrix} instances, where the matrix\n+     * is split in square blocks (except at right and bottom side where blocks may\n+     * be rectangular to fit matrix size) and each block is stored in a flattened\n+     * one-dimensional array.\n+     * </p>\n+     * <p>\n+     * This method creates an array in blocks layout from an input array in raw layout.\n+     * It can be used to provide the array argument of the {@link\n+     * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n+     * </p>\n+     * @param rawData data array in raw layout\n+     * @return a new data array containing the same entries but in blocks layout\n+     * @exception IllegalArgumentException if <code>rawData</code> is not rectangular\n+     *  (not all rows have the same length)\n+     * @see #createBlocksLayout(int, int)\n+     * @see #BlockRealMatrix(int, int, double[][], boolean)\n+     */\n+    public static double[][] toBlocksLayout(final double[][] rawData)\n+        throws IllegalArgumentException {\n+\n+        final int rows         = rawData.length;\n+        final int columns      = rawData[0].length;\n+        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        // safety checks\n+        for (int i = 0; i < rawData.length; ++i) {\n+            final int length = rawData[i].length;\n+            if (length != columns) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some rows have length {0} while others have length {1}\",\n+                        columns, length); \n+            }\n+        }\n+\n+        // convert array\n+        final double[][] blocks = new double[blockRows * blockColumns][];\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart  = iBlock * BLOCK_SIZE;\n+            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int iHeight = pEnd - pStart;\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int jWidth = qEnd - qStart;\n+\n+                // allocate new block\n+                final double[] block = new double[iHeight * jWidth];\n+                blocks[blockIndex] = block;\n+\n+                // copy data\n+                for (int p = pStart, index = 0; p < pEnd; ++p, index += jWidth) {\n+                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n+                }\n+\n+            }\n+        }\n+\n+        return blocks;\n+\n+    }\n+\n+    /**\n+     * Create a data array in blocks layout.\n+     * <p>\n+     * This method can be used to create the array argument of the {@link\n+     * #BlockRealMatrix(int, int, double[][], boolean)} constructor.\n+     * </p>\n+     * @param rows  the number of rows in the new matrix\n+     * @param columns  the number of columns in the new matrix\n+     * @return a new data array in blocks layout\n+     * @see #toBlocksLayout(double[][])\n+     * @see #BlockRealMatrix(int, int, double[][], boolean)\n+     */\n+    public static double[][] createBlocksLayout(final int rows, final int columns) {\n+\n+        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n+\n+        final double[][] blocks = new double[blockRows * blockColumns][];\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart  = iBlock * BLOCK_SIZE;\n+            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n+            final int iHeight = pEnd - pStart;\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final int jWidth = qEnd - qStart;\n+                blocks[blockIndex] = new double[iHeight * jWidth];\n+            }\n+        }\n+\n+        return blocks;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix createMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        return new BlockRealMatrix(rowDimension, columnDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix copy() {\n+\n+        // create an empty matrix\n+        BlockRealMatrix copied = new BlockRealMatrix(rows, columns);\n+\n+        // copy the blocks\n+        for (int i = 0; i < blocks.length; ++i) {\n+            System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);\n+        }\n+\n+        return copied;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix add(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return add((BlockRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            MatrixUtils.checkAdditionCompatible(this, m);\n+\n+            final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n+\n+            // perform addition block-wise, to ensure good cache behavior\n+            int blockIndex = 0;\n+            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+\n+                    // perform addition on the current block\n+                    final double[] outBlock = out.blocks[blockIndex];\n+                    final double[] tBlock   = blocks[blockIndex];\n+                    final int      pStart   = iBlock * BLOCK_SIZE;\n+                    final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n+                    final int      qStart   = jBlock * BLOCK_SIZE;\n+                    final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n+                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        for (int q = qStart; q < qEnd; ++q, ++k) {\n+                            outBlock[k] = tBlock[k] + m.getEntry(p, q);\n+                        }\n+                    }\n+\n+                    // go to next block\n+                    ++blockIndex;\n+\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public BlockRealMatrix add(final BlockRealMatrix m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkAdditionCompatible(this, m);\n+\n+        final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n+\n+        // perform addition block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final double[] outBlock = out.blocks[blockIndex];\n+            final double[] tBlock   = blocks[blockIndex];\n+            final double[] mBlock   = m.blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k] + mBlock[k];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix subtract(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return subtract((BlockRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            MatrixUtils.checkSubtractionCompatible(this, m);\n+\n+            final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n+\n+            // perform subtraction block-wise, to ensure good cache behavior\n+            int blockIndex = 0;\n+            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+\n+                    // perform subtraction on the current block\n+                    final double[] outBlock = out.blocks[blockIndex];\n+                    final double[] tBlock   = blocks[blockIndex];\n+                    final int      pStart   = iBlock * BLOCK_SIZE;\n+                    final int      pEnd     = Math.min(pStart + BLOCK_SIZE, rows);\n+                    final int      qStart   = jBlock * BLOCK_SIZE;\n+                    final int      qEnd     = Math.min(qStart + BLOCK_SIZE, columns);\n+                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        for (int q = qStart; q < qEnd; ++q, ++k) {\n+                            outBlock[k] = tBlock[k] - m.getEntry(p, q);\n+                        }\n+                    }\n+\n+                    // go to next block\n+                    ++blockIndex;\n+\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Compute this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this - m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public BlockRealMatrix subtract(final BlockRealMatrix m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkSubtractionCompatible(this, m);\n+\n+        final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n+\n+        // perform subtraction block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final double[] outBlock = out.blocks[blockIndex];\n+            final double[] tBlock   = blocks[blockIndex];\n+            final double[] mBlock   = m.blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k] - mBlock[k];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix scalarAdd(final double d)\n+        throws IllegalArgumentException {\n+\n+        final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n+\n+        // perform subtraction block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final double[] outBlock = out.blocks[blockIndex];\n+            final double[] tBlock   = blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k] + d;\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix scalarMultiply(final double d)\n+        throws IllegalArgumentException {\n+\n+        final BlockRealMatrix out = new BlockRealMatrix(rows, columns);\n+\n+        // perform subtraction block-wise, to ensure good cache behavior\n+        for (int blockIndex = 0; blockIndex < out.blocks.length; ++blockIndex) {\n+            final double[] outBlock = out.blocks[blockIndex];\n+            final double[] tBlock   = blocks[blockIndex];\n+            for (int k = 0; k < outBlock.length; ++k) {\n+                outBlock[k] = tBlock[k] * d;\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix multiply(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return multiply((BlockRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            MatrixUtils.checkMultiplicationCompatible(this, m);\n+\n+            final BlockRealMatrix out = new BlockRealMatrix(rows, m.getColumnDimension());\n+\n+            // perform multiplication block-wise, to ensure good cache behavior\n+            int blockIndex = 0;\n+            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+\n+                final int pStart = iBlock * BLOCK_SIZE;\n+                final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+\n+                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n+\n+                    // select current block\n+                    final double[] outBlock = out.blocks[blockIndex];\n+\n+                    // perform multiplication on current block\n+                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n+                        final int kWidth      = blockWidth(kBlock);\n+                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n+                        final int rStart      = kBlock * BLOCK_SIZE;\n+                        for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                            final int lStart = (p - pStart) * kWidth;\n+                            final int lEnd   = lStart + kWidth;\n+                            for (int q = qStart; q < qEnd; ++q) {\n+                                double sum = 0;\n+                                for (int l = lStart, r = rStart; l < lEnd; ++l, ++r) {\n+                                    sum += tBlock[l] * m.getEntry(r, q);\n+                                }\n+                                outBlock[k++] += sum;\n+                            }\n+                        }\n+                    }\n+\n+                    // go to next block\n+                    ++blockIndex;\n+\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by m.\n+     *\n+     * @param m    matrix to postmultiply by\n+     * @return     this * m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public BlockRealMatrix multiply(BlockRealMatrix m) throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkMultiplicationCompatible(this, m);\n+\n+        final BlockRealMatrix out = new BlockRealMatrix(rows, m.columns);\n+\n+        // perform multiplication block-wise, to ensure good cache behavior\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n+\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+\n+            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n+                final int jWidth = out.blockWidth(jBlock);\n+                final int jWidth2 = jWidth  + jWidth;\n+                final int jWidth3 = jWidth2 + jWidth;\n+                final int jWidth4 = jWidth3 + jWidth;\n+\n+                // select current block\n+                final double[] outBlock = out.blocks[blockIndex];\n+\n+                // perform multiplication on current block\n+                for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n+                    final int kWidth = blockWidth(kBlock);\n+                    final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n+                    final double[] mBlock = m.blocks[kBlock * m.blockColumns + jBlock];\n+                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                        final int lStart = (p - pStart) * kWidth;\n+                        final int lEnd   = lStart + kWidth;\n+                        for (int nStart = 0; nStart < jWidth; ++nStart) {\n+                            double sum = 0;\n+                            int l = lStart;\n+                            int n = nStart;\n+                            while (l < lEnd - 3) {\n+                                sum += tBlock[l] * mBlock[n] +\n+                                       tBlock[l + 1] * mBlock[n + jWidth] +\n+                                       tBlock[l + 2] * mBlock[n + jWidth2] +\n+                                       tBlock[l + 3] * mBlock[n + jWidth3];\n+                                l += 4;\n+                                n += jWidth4;\n+                            }\n+                            while (l < lEnd) {\n+                                sum += tBlock[l++] * mBlock[n];\n+                                n += jWidth;\n+                            }\n+                            outBlock[k++] += sum;\n+                        }\n+                    }\n+                }\n+\n+                // go to next block\n+                ++blockIndex;\n+\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[][] getData() {\n+\n+        final double[][] data = new double[getRowDimension()][getColumnDimension()];\n+        final int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE;\n+\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            int regularPos   = 0;\n+            int lastPos      = 0;\n+            for (int p = pStart; p < pEnd; ++p) {\n+                final double[] dataP = data[p];\n+                int blockIndex = iBlock * blockColumns;\n+                int dataPos    = 0;\n+                for (int jBlock = 0; jBlock < blockColumns - 1; ++jBlock) {\n+                    System.arraycopy(blocks[blockIndex++], regularPos, dataP, dataPos, BLOCK_SIZE);\n+                    dataPos += BLOCK_SIZE;\n+                }\n+                System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);\n+                regularPos += BLOCK_SIZE;\n+                lastPos    += lastColumns;\n+            }\n+        }\n+\n+        return data;\n+        \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double getNorm() {\n+        final double[] colSums = new double[BLOCK_SIZE];\n+        double maxColSum = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; jBlock++) {\n+            final int jWidth = blockWidth(jBlock);\n+            Arrays.fill(colSums, 0, jWidth, 0.0);\n+            for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+                final int iHeight = blockHeight(iBlock);\n+                final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int j = 0; j < jWidth; ++j) {\n+                    double sum = 0;\n+                    for (int i = 0; i < iHeight; ++i) {\n+                        sum += Math.abs(block[i * jWidth + j]);\n+                    }\n+                    colSums[j] += sum;\n+                }\n+            }\n+            for (int j = 0; j < jWidth; ++j) {\n+                maxColSum = Math.max(maxColSum, colSums[j]);\n+            }\n+        }\n+        return maxColSum;\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Override\n+    public double getFrobeniusNorm() {\n+        double sum2 = 0;\n+        for (int blockIndex = 0; blockIndex < blocks.length; ++blockIndex) {\n+            for (final double entry : blocks[blockIndex]) {\n+                sum2 += entry * entry;\n+            }\n+        }\n+        return Math.sqrt(sum2);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix getSubMatrix(final int startRow, final int endRow,\n+                                   final int startColumn, final int endColumn)\n+        throws MatrixIndexException {\n+\n+        // safety checks\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+\n+        // create the output matrix\n+        final BlockRealMatrix out =\n+            new BlockRealMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n+\n+        // compute blocks shifts\n+        final int blockStartRow    = startRow    / BLOCK_SIZE;\n+        final int rowsShift        = startRow    % BLOCK_SIZE;\n+        final int blockStartColumn = startColumn / BLOCK_SIZE;\n+        final int columnsShift     = startColumn % BLOCK_SIZE;\n+\n+        // perform extraction block-wise, to ensure good cache behavior\n+        for (int iBlock = 0, pBlock = blockStartRow; iBlock < out.blockRows; ++iBlock, ++pBlock) {\n+            final int iHeight = out.blockHeight(iBlock);\n+            for (int jBlock = 0, qBlock = blockStartColumn; jBlock < out.blockColumns; ++jBlock, ++qBlock) {\n+                final int jWidth = out.blockWidth(jBlock);\n+\n+                // handle one block of the output matrix\n+                final int      outIndex = iBlock * out.blockColumns + jBlock;\n+                final double[] outBlock = out.blocks[outIndex];\n+                final int      index    = pBlock * blockColumns + qBlock;\n+                final int      width    = blockWidth(qBlock);\n+\n+                final int heightExcess = iHeight + rowsShift - BLOCK_SIZE;\n+                final int widthExcess  = jWidth + columnsShift - BLOCK_SIZE;\n+                if (heightExcess > 0) {\n+                    // the submatrix block spans on two blocks rows from the original matrix\n+                    if (widthExcess > 0) {\n+                        // the submatrix block spans on two blocks columns from the original matrix\n+                        final int width2 = blockWidth(qBlock + 1);\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, BLOCK_SIZE,\n+                                      columnsShift, BLOCK_SIZE,\n+                                      outBlock, jWidth, 0, 0);\n+                        copyBlockPart(blocks[index + 1], width2,\n+                                      rowsShift, BLOCK_SIZE,\n+                                      0, widthExcess,\n+                                      outBlock, jWidth, 0, jWidth - widthExcess);\n+                        copyBlockPart(blocks[index + blockColumns], width,\n+                                      0, heightExcess,\n+                                      columnsShift, BLOCK_SIZE,\n+                                      outBlock, jWidth, iHeight - heightExcess, 0);\n+                        copyBlockPart(blocks[index + blockColumns + 1], width2,\n+                                      0, heightExcess,\n+                                      0, widthExcess,\n+                                      outBlock, jWidth, iHeight - heightExcess, jWidth - widthExcess);\n+                    } else {\n+                        // the submatrix block spans on one block column from the original matrix\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, BLOCK_SIZE,\n+                                      columnsShift, jWidth + columnsShift,\n+                                      outBlock, jWidth, 0, 0);\n+                        copyBlockPart(blocks[index + blockColumns], width,\n+                                      0, heightExcess,\n+                                      columnsShift, jWidth + columnsShift,\n+                                      outBlock, jWidth, iHeight - heightExcess, 0);\n+                    }\n+                } else {\n+                    // the submatrix block spans on one block row from the original matrix\n+                    if (widthExcess > 0) {\n+                        // the submatrix block spans on two blocks columns from the original matrix\n+                        final int width2 = blockWidth(qBlock + 1);\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, iHeight + rowsShift,\n+                                      columnsShift, BLOCK_SIZE,\n+                                      outBlock, jWidth, 0, 0);\n+                        copyBlockPart(blocks[index + 1], width2,\n+                                      rowsShift, iHeight + rowsShift,\n+                                      0, widthExcess,\n+                                      outBlock, jWidth, 0, jWidth - widthExcess);\n+                    } else {\n+                        // the submatrix block spans on one block column from the original matrix\n+                        copyBlockPart(blocks[index], width,\n+                                      rowsShift, iHeight + rowsShift,\n+                                      columnsShift, jWidth + columnsShift,\n+                                      outBlock, jWidth, 0, 0);\n+                    }\n+               }\n+\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /**\n+     * Copy a part of a block into another one\n+     * <p>This method can be called only when the specified part fits in both\n+     * blocks, no verification is done here.</p>\n+     * @param srcBlock source block\n+     * @param srcWidth source block width ({@link #BLOCK_SIZE} or smaller)\n+     * @param srcStartRow start row in the source block\n+     * @param srcEndRow end row (exclusive) in the source block\n+     * @param srcStartColumn start column in the source block\n+     * @param srcEndColumn end column (exclusive) in the source block\n+     * @param dstBlock destination block\n+     * @param dstWidth destination block width ({@link #BLOCK_SIZE} or smaller)\n+     * @param dstStartRow start row in the destination block\n+     * @param dstStartColumn start column in the destination block\n+     */\n+    private void copyBlockPart(final double[] srcBlock, final int srcWidth,\n+                               final int srcStartRow, final int srcEndRow,\n+                               final int srcStartColumn, final int srcEndColumn,\n+                               final double[] dstBlock, final int dstWidth,\n+                               final int dstStartRow, final int dstStartColumn) {\n+        final int length = srcEndColumn - srcStartColumn;\n+        int srcPos = srcStartRow * srcWidth + srcStartColumn;\n+        int dstPos = dstStartRow * dstWidth + dstStartColumn;\n+        for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {\n+            System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);\n+            srcPos += srcWidth;\n+            dstPos += dstWidth;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setSubMatrix(final double[][] subMatrix, final int row, final int column)\n+        throws MatrixIndexException {\n+\n+        // safety checks\n+        final int refLength = subMatrix[0].length;\n+        if (refLength < 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");             \n+        }\n+        final int endRow    = row + subMatrix.length - 1;\n+        final int endColumn = column + refLength - 1;\n+        MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);\n+        for (final double[] subRow : subMatrix) {\n+            if (subRow.length != refLength) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some rows have length {0} while others have length {1}\",\n+                        refLength, subRow.length); \n+            }\n+        }\n+\n+        // compute blocks bounds\n+        final int blockStartRow    = row / BLOCK_SIZE;\n+        final int blockEndRow      = (endRow + BLOCK_SIZE) / BLOCK_SIZE;\n+        final int blockStartColumn = column / BLOCK_SIZE;\n+        final int blockEndColumn   = (endColumn + BLOCK_SIZE) / BLOCK_SIZE;\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {\n+            final int iHeight  = blockHeight(iBlock);\n+            final int firstRow = iBlock * BLOCK_SIZE;\n+            final int iStart   = Math.max(row,    firstRow);\n+            final int iEnd     = Math.min(endRow + 1, firstRow + iHeight);\n+\n+            for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {\n+                final int jWidth      = blockWidth(jBlock);\n+                final int firstColumn = jBlock * BLOCK_SIZE;\n+                final int jStart      = Math.max(column,    firstColumn);\n+                final int jEnd        = Math.min(endColumn + 1, firstColumn + jWidth);\n+                final int jLength     = jEnd - jStart;\n+\n+                // handle one block, row by row\n+                final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int i = iStart; i < iEnd; ++i) {\n+                    System.arraycopy(subMatrix[i - row], jStart - column,\n+                                     block, (i - firstRow) * jWidth + (jStart - firstColumn),\n+                                     jLength);\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix getRowMatrix(final int row)\n+        throws MatrixIndexException {\n+\n+        MatrixUtils.checkRowIndex(this, row);\n+        final BlockRealMatrix out = new BlockRealMatrix(1, columns);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outBlockIndex = 0;\n+        int outIndex      = 0;\n+        double[] outBlock = out.blocks[outBlockIndex];\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            final int available  = outBlock.length - outIndex;\n+            if (jWidth > available) {\n+                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, available);\n+                outBlock = out.blocks[++outBlockIndex];\n+                System.arraycopy(block, iRow * jWidth, outBlock, 0, jWidth - available);\n+                outIndex = jWidth - available;\n+            } else {\n+                System.arraycopy(block, iRow * jWidth, outBlock, outIndex, jWidth);\n+                outIndex += jWidth;\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setRowMatrix(final int row, final RealMatrix matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setRowMatrix(row, (BlockRealMatrix) matrix);\n+        } catch (ClassCastException cce) {\n+            super.setRowMatrix(row, matrix);\n+        }\n+    }\n+\n+    /**\n+     * Sets the entries in row number <code>row</code>\n+     * as a row matrix.  Row indices start at 0.\n+     *\n+     * @param row the row to be set\n+     * @param matrix row matrix (must have one row and the same number of columns\n+     * as the instance)\n+     * @throws MatrixIndexException if the specified row index is invalid\n+     * @throws InvalidMatrixException if the matrix dimensions do not match one\n+     * instance row\n+     */\n+    public void setRowMatrix(final int row, final BlockRealMatrix matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        MatrixUtils.checkRowIndex(this, row);\n+        final int nCols = getColumnDimension();\n+        if ((matrix.getRowDimension() != 1) ||\n+            (matrix.getColumnDimension() != nCols)) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(),\n+                    1, nCols);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock = row / BLOCK_SIZE;\n+        final int iRow   = row - iBlock * BLOCK_SIZE;\n+        int mBlockIndex  = 0;\n+        int mIndex       = 0;\n+        double[] mBlock  = matrix.blocks[mBlockIndex];\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            final int available  = mBlock.length - mIndex;\n+            if (jWidth > available) {\n+                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, available);\n+                mBlock = matrix.blocks[++mBlockIndex];\n+                System.arraycopy(mBlock, 0, block, iRow * jWidth, jWidth - available);\n+                mIndex = jWidth - available;\n+            } else {\n+                System.arraycopy(mBlock, mIndex, block, iRow * jWidth, jWidth);\n+                mIndex += jWidth;\n+           }\n+        }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix getColumnMatrix(final int column)\n+        throws MatrixIndexException {\n+\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final BlockRealMatrix out = new BlockRealMatrix(rows, 1);\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outBlockIndex = 0;\n+        int outIndex      = 0;\n+        double[] outBlock = out.blocks[outBlockIndex];\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                if (outIndex >= outBlock.length) {\n+                    outBlock = out.blocks[++outBlockIndex];\n+                    outIndex = 0;\n+                }\n+                outBlock[outIndex++] = block[i * jWidth + jColumn];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setColumnMatrix(final int column, final RealMatrix matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setColumnMatrix(column, (BlockRealMatrix) matrix);\n+        } catch (ClassCastException cce) {\n+            super.setColumnMatrix(column, matrix);\n+        }\n+    }\n+\n+    /**\n+     * Sets the entries in column number <code>column</code>\n+     * as a column matrix.  Column indices start at 0.\n+     *\n+     * @param column the column to be set\n+     * @param matrix column matrix (must have one column and the same number of rows\n+     * as the instance)\n+     * @throws MatrixIndexException if the specified column index is invalid\n+     * @throws InvalidMatrixException if the matrix dimensions do not match one\n+     * instance column\n+     */\n+    void setColumnMatrix(final int column, final BlockRealMatrix matrix)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final int nRows = getRowDimension();\n+        if ((matrix.getRowDimension() != nRows) ||\n+            (matrix.getColumnDimension() != 1)) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    matrix.getRowDimension(), matrix.getColumnDimension(),\n+                    nRows, 1);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int mBlockIndex = 0;\n+        int mIndex      = 0;\n+        double[] mBlock = matrix.blocks[mBlockIndex];\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                if (mIndex >= mBlock.length) {\n+                    mBlock = matrix.blocks[++mBlockIndex];\n+                    mIndex = 0;\n+                }\n+                block[i * jWidth + jColumn] = mBlock[mIndex++];\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealVector getRowVector(final int row)\n+        throws MatrixIndexException {\n+\n+        MatrixUtils.checkRowIndex(this, row);\n+        final double[] outData = new double[columns];\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outIndex      = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            System.arraycopy(block, iRow * jWidth, outData, outIndex, jWidth);\n+            outIndex += jWidth;\n+        }\n+\n+        return new ArrayRealVector(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setRowVector(final int row, final RealVector vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setRow(row, ((ArrayRealVector) vector).getDataRef());\n+        } catch (ClassCastException cce) {\n+            super.setRowVector(row, vector);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealVector getColumnVector(final int column)\n+        throws MatrixIndexException {\n+\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final double[] outData = new double[rows];\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outIndex      = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                outData[outIndex++] = block[i * jWidth + jColumn];\n+            }\n+        }\n+\n+        return new ArrayRealVector(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setColumnVector(final int column, final RealVector vector)\n+        throws MatrixIndexException, InvalidMatrixException {\n+        try {\n+            setColumn(column, ((ArrayRealVector) vector).getDataRef());\n+        } catch (ClassCastException cce) {\n+            super.setColumnVector(column, vector);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[] getRow(final int row)\n+        throws MatrixIndexException {\n+\n+        MatrixUtils.checkRowIndex(this, row);\n+        final double[] out = new double[columns];\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outIndex      = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            System.arraycopy(block, iRow * jWidth, out, outIndex, jWidth);\n+            outIndex += jWidth;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setRow(final int row, final double[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        MatrixUtils.checkRowIndex(this, row);\n+        final int nCols = getColumnDimension();\n+        if (array.length != nCols) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    1, array.length, 1, nCols);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int iBlock  = row / BLOCK_SIZE;\n+        final int iRow    = row - iBlock * BLOCK_SIZE;\n+        int outIndex      = 0;\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth     = blockWidth(jBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            System.arraycopy(array, outIndex, block, iRow * jWidth, jWidth);\n+            outIndex += jWidth;\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[] getColumn(final int column)\n+        throws MatrixIndexException {\n+\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final double[] out = new double[rows];\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outIndex      = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                out[outIndex++] = block[i * jWidth + jColumn];\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setColumn(final int column, final double[] array)\n+        throws MatrixIndexException, InvalidMatrixException {\n+\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final int nRows = getRowDimension();\n+        if (array.length != nRows) {\n+            throw new InvalidMatrixException(\n+                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                    array.length, 1, nRows, 1);\n+        }\n+\n+        // perform copy block-wise, to ensure good cache behavior\n+        final int jBlock  = column / BLOCK_SIZE;\n+        final int jColumn = column - jBlock * BLOCK_SIZE;\n+        final int jWidth  = blockWidth(jBlock);\n+        int outIndex      = 0;\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int iHeight = blockHeight(iBlock);\n+            final double[] block = blocks[iBlock * blockColumns + jBlock];\n+            for (int i = 0; i < iHeight; ++i) {\n+                block[i * jWidth + jColumn] = array[outIndex++];\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double getEntry(final int row, final int column)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            return blocks[iBlock * blockColumns + jBlock][k];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(final int row, final int column, final double value)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            blocks[iBlock * blockColumns + jBlock][k] = value;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(final int row, final int column, final double increment)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            blocks[iBlock * blockColumns + jBlock][k] += increment;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(final int row, final int column, final double factor)\n+        throws MatrixIndexException {\n+        try {\n+            final int iBlock = row    / BLOCK_SIZE;\n+            final int jBlock = column / BLOCK_SIZE;\n+            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+                               (column - jBlock * BLOCK_SIZE);\n+            blocks[iBlock * blockColumns + jBlock][k] *= factor;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public BlockRealMatrix transpose() {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        final BlockRealMatrix out = new BlockRealMatrix(nCols, nRows);\n+\n+        // perform transpose block-wise, to ensure good cache behavior\n+        int blockIndex = 0;\n+        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n+            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n+\n+                // transpose current block\n+                final double[] outBlock = out.blocks[blockIndex];\n+                final double[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n+                final int      pStart   = iBlock * BLOCK_SIZE;\n+                final int      pEnd     = Math.min(pStart + BLOCK_SIZE, columns);\n+                final int      qStart   = jBlock * BLOCK_SIZE;\n+                final int      qEnd     = Math.min(qStart + BLOCK_SIZE, rows);\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    final int lInc = pEnd - pStart;\n+                    for (int q = qStart, l = p - pStart; q < qEnd; ++q, l+= lInc) {\n+                        outBlock[k++] = tBlock[l];\n+                    }\n+                }\n+\n+                // go to next block\n+                ++blockIndex;\n+\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return rows;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return columns;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[] operate(final double[] v)\n+        throws IllegalArgumentException {\n+\n+        if (v.length != columns) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, columns);\n+        }\n+        final double[] out = new double[rows];\n+\n+        // perform multiplication block-wise, to ensure good cache behavior\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+                final double[] block  = blocks[iBlock * blockColumns + jBlock];\n+                final int      qStart = jBlock * BLOCK_SIZE;\n+                final int      qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    double sum = 0;\n+                    int q = qStart;\n+                    while (q < qEnd - 3) {\n+                        sum += block[k]     * v[q]     +\n+                               block[k + 1] * v[q + 1] +\n+                               block[k + 2] * v[q + 2] +\n+                               block[k + 3] * v[q + 3];\n+                        k += 4;\n+                        q += 4;\n+                    }\n+                    while (q < qEnd) {\n+                        sum += block[k++] * v[q++];\n+                    }\n+                    out[p] += sum;\n+                }\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[] preMultiply(final double[] v)\n+        throws IllegalArgumentException {\n+\n+        if (v.length != rows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, rows);\n+        }\n+        final double[] out = new double[columns];\n+\n+        // perform multiplication block-wise, to ensure good cache behavior\n+        for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+            final int jWidth  = blockWidth(jBlock);\n+            final int jWidth2 = jWidth  + jWidth;\n+            final int jWidth3 = jWidth2 + jWidth;\n+            final int jWidth4 = jWidth3 + jWidth;\n+            final int qStart = jBlock * BLOCK_SIZE;\n+            final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+            for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+                final double[] block  = blocks[iBlock * blockColumns + jBlock];\n+                final int      pStart = iBlock * BLOCK_SIZE;\n+                final int      pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+                for (int q = qStart; q < qEnd; ++q) {\n+                    int k = q - qStart;\n+                    double sum = 0;\n+                    int p = pStart;\n+                    while (p < pEnd - 3) {\n+                        sum += block[k]           * v[p]     +\n+                               block[k + jWidth]  * v[p + 1] +\n+                               block[k + jWidth2] * v[p + 2] +\n+                               block[k + jWidth3] * v[p + 3];\n+                        k += jWidth4;\n+                        p += 4;\n+                    }\n+                    while (p < pEnd) {\n+                        sum += block[k] * v[p++];\n+                        k += jWidth;\n+                    }\n+                    out[q] += sum;\n+                }\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int qStart = jBlock * BLOCK_SIZE;\n+                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int q0     = jBlock * BLOCK_SIZE;\n+                    final int qStart = Math.max(startColumn, q0);\n+                    final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int p = pStart; p < pEnd; ++p) {\n+                for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                    final int jWidth = blockWidth(jBlock);\n+                    final int q0     = jBlock * BLOCK_SIZE;\n+                    final int qStart = Math.max(startColumn, q0);\n+                    final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                    final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+             }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final double[] block = blocks[blockIndex];\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    for (int q = qStart; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n+            final int pStart = iBlock * BLOCK_SIZE;\n+            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n+            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n+                final int qStart = jBlock * BLOCK_SIZE;\n+                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n+                final double[] block = blocks[blockIndex];\n+                for (int p = pStart, k = 0; p < pEnd; ++p) {\n+                    for (int q = qStart; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInOptimizedOrder(final RealMatrixChangingVisitor visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                final int jWidth = blockWidth(jBlock);\n+                final int q0     = jBlock * BLOCK_SIZE;\n+                final int qStart = Math.max(startColumn, q0);\n+                final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int p = pStart; p < pEnd; ++p) {\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        block[k] = visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor,\n+                                       final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n+        for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n+            final int p0     = iBlock * BLOCK_SIZE;\n+            final int pStart = Math.max(startRow, p0);\n+            final int pEnd   = Math.min((iBlock + 1) * BLOCK_SIZE, 1 + endRow);\n+            for (int jBlock = startColumn / BLOCK_SIZE; jBlock < 1 + endColumn / BLOCK_SIZE; ++jBlock) {\n+                final int jWidth = blockWidth(jBlock);\n+                final int q0     = jBlock * BLOCK_SIZE;\n+                final int qStart = Math.max(startColumn, q0);\n+                final int qEnd   = Math.min((jBlock + 1) * BLOCK_SIZE, 1 + endColumn);\n+                final double[] block = blocks[iBlock * blockColumns + jBlock];\n+                for (int p = pStart; p < pEnd; ++p) {\n+                    for (int q = qStart, k = (p - p0) * jWidth + qStart - q0; q < qEnd; ++q, ++k) {\n+                        visitor.visit(p, q, block[k]);\n+                    }\n+                }\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /**\n+     * Get the height of a block.\n+     * @param blockRow row index (in block sense) of the block\n+     * @return height (number of rows) of the block\n+     */\n+    private int blockHeight(final int blockRow) {\n+        return (blockRow == blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE;\n+    }\n+\n+    /**\n+     * Get the width of a block.\n+     * @param blockColumn column index (in block sense) of the block\n+     * @return width (number of columns) of the block\n+     */\n+    private int blockWidth(final int blockColumn) {\n+        return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/CholeskyDecomposition.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+\n+/**\n+ * An interface to classes that implement an algorithm to calculate the \n+ * Cholesky decomposition of a real symmetric positive-definite matrix.\n+ * <p>This interface is based on the class with similar name from the now defunct\n+ * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n+ * following changes:</p>\n+ * <ul>\n+ *   <li>a {@link #getLT() getLT} method has been added,</li>\n+ *   <li>the <code>isspd</code> method has been removed, the constructors of\n+ *   implementation classes being expected to throw {@link\n+ *   NotPositiveDefiniteMatrixException} when a matrix cannot be decomposed,</li>\n+ *   <li>a {@link #getDeterminant() getDeterminant} method has been added,</li>\n+ *   <li>the <code>solve</code> method has been replaced by a {@link\n+ *   #getSolver() getSolver} method and the equivalent method provided by\n+ *   the returned {@link DecompositionSolver}.</li>\n+ * </ul>\n+ *   \n+ * @see <a href=\"http://mathworld.wolfram.com/CholeskyDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Cholesky_decomposition\">Wikipedia</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface CholeskyDecomposition {\n+\n+    /**\n+     * Returns the matrix L of the decomposition. \n+     * <p>L is an lower-triangular matrix</p>\n+     * @return the L matrix\n+     */\n+    RealMatrix getL();\n+\n+    /**\n+     * Returns the transpose of the matrix L of the decomposition.\n+     * <p>L<sup>T</sup> is an upper-triangular matrix</p>\n+     * @return the transpose of the matrix L of the decomposition\n+     */\n+    RealMatrix getLT();\n+\n+    /**\n+     * Return the determinant of the matrix\n+     * @return determinant of the matrix\n+     */\n+    double getDeterminant();\n+\n+    /**\n+     * Get a solver for finding the A &times; X = B solution in least square sense.\n+     * @return a solver\n+     */\n+    DecompositionSolver getSolver();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+\n+/**\n+ * Calculates the Cholesky decomposition of a matrix.\n+ * <p>The Cholesky decomposition of a real symmetric positive-definite\n+ * matrix A consists of a lower triangular matrix L with same size that\n+ * satisfy: A = LL<sup>T</sup>Q = I). In a sense, this is the square root of A.</p>\n+ *\n+ * @see <a href=\"http://mathworld.wolfram.com/CholeskyDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Cholesky_decomposition\">Wikipedia</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class CholeskyDecompositionImpl implements CholeskyDecomposition {\n+\n+    /** Default threshold above which off-diagonal elements are considered too different\n+     * and matrix not symmetric. */\n+    public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0e-15;\n+\n+    /** Default threshold below which diagonal elements are considered null\n+     * and matrix not positive definite. */\n+    public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0e-10;\n+\n+    /** Row-oriented storage for L<sup>T</sup> matrix data. */\n+    private double[][] lTData;\n+\n+    /** Cached value of L. */\n+    private RealMatrix cachedL;\n+\n+    /** Cached value of LT. */\n+    private RealMatrix cachedLT;\n+\n+    /**\n+     * Calculates the Cholesky decomposition of the given matrix.\n+     * <p>\n+     * Calling this constructor is equivalent to call {@link\n+     * #CholeskyDecompositionImpl(RealMatrix, double, double)} with the\n+     * thresholds set to the default values {@link\n+     * #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD} and {@link\n+     * #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD}\n+     * </p>\n+     * @param matrix the matrix to decompose\n+     * @exception NonSquareMatrixException if matrix is not square\n+     * @exception NotSymmetricMatrixException if matrix is not symmetric\n+     * @exception NotPositiveDefiniteMatrixException if the matrix is not\n+     * strictly positive definite\n+     * @see #CholeskyDecompositionImpl(RealMatrix, double, double)\n+     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n+     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n+     */\n+    public CholeskyDecompositionImpl(final RealMatrix matrix)\n+        throws NonSquareMatrixException,\n+               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n+        this(matrix, DEFAULT_RELATIVE_SYMMETRY_THRESHOLD,\n+             DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);\n+    }\n+\n+    /**\n+     * Calculates the Cholesky decomposition of the given matrix.\n+     * @param matrix the matrix to decompose\n+     * @param relativeSymmetryThreshold threshold above which off-diagonal\n+     * elements are considered too different and matrix not symmetric\n+     * @param absolutePositivityThreshold threshold below which diagonal\n+     * elements are considered null and matrix not positive definite\n+     * @exception NonSquareMatrixException if matrix is not square\n+     * @exception NotSymmetricMatrixException if matrix is not symmetric\n+     * @exception NotPositiveDefiniteMatrixException if the matrix is not\n+     * strictly positive definite\n+     * @see #CholeskyDecompositionImpl(RealMatrix)\n+     * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n+     * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n+     */\n+    public CholeskyDecompositionImpl(final RealMatrix matrix,\n+                                     final double relativeSymmetryThreshold,\n+                                     final double absolutePositivityThreshold)\n+        throws NonSquareMatrixException,\n+               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n+\n+        if (!matrix.isSquare()) {\n+            throw new NonSquareMatrixException(matrix.getRowDimension(),\n+                                               matrix.getColumnDimension());\n+        }\n+\n+        final int order = matrix.getRowDimension();\n+        lTData   = matrix.getData();\n+        cachedL  = null;\n+        cachedLT = null;\n+\n+        // check the matrix before transformation\n+        for (int i = 0; i < order; ++i) {\n+\n+            final double[] lI = lTData[i];\n+\n+            // check off-diagonal elements (and reset them to 0)\n+            for (int j = i + 1; j < order; ++j) {\n+                final double[] lJ = lTData[j];\n+                final double lIJ = lI[j];\n+                final double lJI = lJ[i];\n+                final double maxDelta =\n+                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n+                if (Math.abs(lIJ - lJI) > maxDelta) {\n+                    throw new NotSymmetricMatrixException();\n+                }\n+                lJ[i] = 0;\n+           }\n+        }\n+\n+        // transform the matrix\n+        for (int i = 0; i < order; ++i) {\n+\n+            final double[] ltI = lTData[i];\n+\n+            // check diagonal element\n+            if (ltI[i] < absolutePositivityThreshold) {\n+                throw new NotPositiveDefiniteMatrixException();\n+            }\n+\n+            ltI[i] = Math.sqrt(ltI[i]);\n+            final double inverse = 1.0 / ltI[i];\n+\n+            for (int q = order - 1; q > i; --q) {\n+                ltI[q] *= inverse;\n+                final double[] ltQ = lTData[q];\n+                for (int p = q; p < order; ++p) {\n+                    ltQ[p] -= ltI[q] * ltI[p];\n+                }\n+            }\n+\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getL() {\n+        if (cachedL == null) {\n+            cachedL = getLT().transpose();\n+        }\n+        return cachedL;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getLT() {\n+\n+        if (cachedLT == null) {\n+            cachedLT = MatrixUtils.createRealMatrix(lTData);\n+        }\n+\n+        // return the cached matrix\n+        return cachedLT;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDeterminant() {\n+        double determinant = 1.0;\n+        for (int i = 0; i < lTData.length; ++i) {\n+            double lTii = lTData[i][i];\n+            determinant *= lTii * lTii;\n+        }\n+        return determinant;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DecompositionSolver getSolver() {\n+        return new Solver(lTData);\n+    }\n+\n+    /** Specialized solver. */\n+    private static class Solver implements DecompositionSolver {\n+    \n+        /** Row-oriented storage for L<sup>T</sup> matrix data. */\n+        private final double[][] lTData;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         * @param lTData row-oriented storage for L<sup>T</sup> matrix data\n+         */\n+        private Solver(final double[][] lTData) {\n+            this.lTData = lTData;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean isNonSingular() {\n+            // if we get this far, the matrix was positive definite, hence non-singular\n+            return true;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[] solve(double[] b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            final int m = lTData.length;\n+            if (b.length != m) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"vector length mismatch: got {0} but expected {1}\",\n+                        b.length, m);\n+            }\n+\n+            final double[] x = b.clone();\n+\n+            // Solve LY = b\n+            for (int j = 0; j < m; j++) {\n+                final double[] lJ = lTData[j];\n+                x[j] /= lJ[j];\n+                final double xJ = x[j];\n+                for (int i = j + 1; i < m; i++) {\n+                    x[i] -= xJ * lJ[i];\n+                }\n+            }\n+\n+            // Solve LTX = Y\n+            for (int j = m - 1; j >= 0; j--) {\n+                x[j] /= lTData[j][j];\n+                final double xJ = x[j];\n+                for (int i = 0; i < j; i++) {\n+                    x[i] -= xJ * lTData[i][j];\n+                }\n+            }\n+\n+            return x;\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector solve(RealVector b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+            try {\n+                return solve((ArrayRealVector) b);\n+            } catch (ClassCastException cce) {\n+\n+                final int m = lTData.length;\n+                if (b.getDimension() != m) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"vector length mismatch: got {0} but expected {1}\",\n+                            b.getDimension(), m);\n+                }\n+\n+                final double[] x = b.getData();\n+\n+                // Solve LY = b\n+                for (int j = 0; j < m; j++) {\n+                    final double[] lJ = lTData[j];\n+                    x[j] /= lJ[j];\n+                    final double xJ = x[j];\n+                    for (int i = j + 1; i < m; i++) {\n+                        x[i] -= xJ * lJ[i];\n+                    }\n+                }\n+\n+                // Solve LTX = Y\n+                for (int j = m - 1; j >= 0; j--) {\n+                    x[j] /= lTData[j][j];\n+                    final double xJ = x[j];\n+                    for (int i = 0; i < j; i++) {\n+                        x[i] -= xJ * lTData[i][j];\n+                    }\n+                }\n+\n+                return new ArrayRealVector(x, false);\n+\n+            }\n+        }\n+\n+        /** Solve the linear equation A &times; X = B.\n+         * <p>The A matrix is implicit here. It is </p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a vector X such that A &times; X = B\n+         * @exception IllegalArgumentException if matrices dimensions don't match\n+         * @exception InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public ArrayRealVector solve(ArrayRealVector b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+            return new ArrayRealVector(solve(b.getDataRef()), false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix solve(RealMatrix b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            final int m = lTData.length;\n+            if (b.getRowDimension() != m) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n+            }\n+\n+            final int nColB = b.getColumnDimension();\n+            double[][] x = b.getData();\n+\n+            // Solve LY = b\n+            for (int j = 0; j < m; j++) {\n+                final double[] lJ = lTData[j];\n+                final double lJJ = lJ[j];\n+                final double[] xJ = x[j];\n+                for (int k = 0; k < nColB; ++k) {\n+                    xJ[k] /= lJJ;\n+                }\n+                for (int i = j + 1; i < m; i++) {\n+                    final double[] xI = x[i];\n+                    final double lJI = lJ[i];\n+                    for (int k = 0; k < nColB; ++k) {\n+                        xI[k] -= xJ[k] * lJI;\n+                    }\n+                }\n+            }\n+\n+            // Solve LTX = Y\n+            for (int j = m - 1; j >= 0; j--) {\n+                final double lJJ = lTData[j][j];\n+                final double[] xJ = x[j];\n+                for (int k = 0; k < nColB; ++k) {\n+                    xJ[k] /= lJJ;\n+                }\n+                for (int i = 0; i < j; i++) {\n+                    final double[] xI = x[i];\n+                    final double lIJ = lTData[i][j];\n+                    for (int k = 0; k < nColB; ++k) {\n+                        xI[k] -= xJ[k] * lIJ;\n+                    }\n+                }\n+            }\n+\n+            return new Array2DRowRealMatrix(x, false);\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix getInverse() throws InvalidMatrixException {\n+            return solve(MatrixUtils.createRealIdentityMatrix(lTData.length));\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/DecompositionSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+\n+\n+/**\n+ * Interface handling decomposition algorithms that can solve A &times; X = B.\n+ * <p>Decomposition algorithms decompose an A matrix has a product of several specific\n+ * matrices from which they can solve A &times; X = B in least squares sense: they find X\n+ * such that ||A &times; X - B|| is minimal.</p>\n+ * <p>Some solvers like {@link LUDecomposition} can only find the solution for\n+ * square matrices and when the solution is an exact linear solution, i.e. when\n+ * ||A &times; X - B|| is exactly 0. Other solvers can also find solutions\n+ * with non-square matrix A and with non-null minimal norm. If an exact linear\n+ * solution exists it is also the minimal norm solution.</p>\n+ *   \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface DecompositionSolver {\n+\n+    /** Solve the linear equation A &times; X = B for matrices A.\n+     * <p>The A matrix is implicit, it is provided by the underlying\n+     * decomposition algorithm.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    double[] solve(final double[] b)\n+        throws IllegalArgumentException, InvalidMatrixException;\n+\n+    /** Solve the linear equation A &times; X = B for matrices A.\n+     * <p>The A matrix is implicit, it is provided by the underlying\n+     * decomposition algorithm.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    RealVector solve(final RealVector b)\n+        throws IllegalArgumentException, InvalidMatrixException;\n+\n+    /** Solve the linear equation A &times; X = B for matrices A.\n+     * <p>The A matrix is implicit, it is provided by the underlying\n+     * decomposition algorithm.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a matrix X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    RealMatrix solve(final RealMatrix b)\n+        throws IllegalArgumentException, InvalidMatrixException;\n+\n+    /**\n+     * Check if the decomposed matrix is non-singular.\n+     * @return true if the decomposed matrix is non-singular\n+     */\n+    boolean isNonSingular();\n+\n+    /** Get the inverse (or pseudo-inverse) of the decomposed matrix.\n+     * @return inverse matrix\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    RealMatrix getInverse()\n+        throws InvalidMatrixException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/DefaultFieldMatrixChangingVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.FieldElement;\n+\n+/**\n+ * Default implementation of the {@link FieldMatrixChangingVisitor} interface.\n+ * <p>\n+ * This class is a convenience to create custom visitors without defining all\n+ * methods. This class provides default implementations that do nothing.\n+ * </p>\n+ * \n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class DefaultFieldMatrixChangingVisitor<T extends FieldElement<T>>\n+    implements FieldMatrixChangingVisitor<T> {\n+\n+    /** Zero element of the field. */\n+    private final T zero;\n+\n+    /** Build a new instance.\n+     * @param zero additive identity of the field\n+     */\n+    public DefaultFieldMatrixChangingVisitor(final T zero) {\n+        this.zero = zero;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void start(int rows, int columns,\n+                      int startRow, int endRow, int startColumn, int endColumn) {\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T visit(int row, int column, T value)\n+        throws MatrixVisitorException {\n+        return value;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T end() {\n+        return zero;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/DefaultFieldMatrixPreservingVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.FieldElement;\n+\n+/**\n+ * Default implementation of the {@link FieldMatrixPreservingVisitor} interface.\n+ * <p>\n+ * This class is a convenience to create custom visitors without defining all\n+ * methods. This class provides default implementations that do nothing.\n+ * </p>\n+ * \n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class DefaultFieldMatrixPreservingVisitor<T extends FieldElement<T>>\n+    implements FieldMatrixPreservingVisitor<T> {\n+\n+    /** Zero element of the field. */\n+    private final T zero;\n+\n+    /** Build a new instance.\n+     * @param zero additive identity of the field\n+     */\n+    public DefaultFieldMatrixPreservingVisitor(final T zero) {\n+        this.zero = zero;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void start(int rows, int columns,\n+                      int startRow, int endRow, int startColumn, int endColumn) {\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void visit(int row, int column, T value)\n+        throws MatrixVisitorException {\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T end() {\n+        return zero;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/DefaultRealMatrixChangingVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Default implementation of the {@link RealMatrixChangingVisitor} interface.\n+ * <p>\n+ * This class is a convenience to create custom visitors without defining all\n+ * methods. This class provides default implementations that do nothing.\n+ * </p>\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class DefaultRealMatrixChangingVisitor implements RealMatrixChangingVisitor {\n+\n+    /** {@inheritDoc} */\n+    public void start(int rows, int columns,\n+                      int startRow, int endRow, int startColumn, int endColumn) {\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double visit(int row, int column, double value)\n+        throws MatrixVisitorException {\n+        return value;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double end() {\n+        return 0;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/DefaultRealMatrixPreservingVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Default implementation of the {@link RealMatrixPreservingVisitor} interface.\n+ * <p>\n+ * This class is a convenience to create custom visitors without defining all\n+ * methods. This class provides default implementations that do nothing.\n+ * </p>\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class DefaultRealMatrixPreservingVisitor implements RealMatrixPreservingVisitor {\n+\n+    /** {@inheritDoc} */\n+    public void start(int rows, int columns,\n+                      int startRow, int endRow, int startColumn, int endColumn) {\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void visit(int row, int column, double value)\n+        throws MatrixVisitorException {\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double end() {\n+        return 0;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecomposition.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+\n+/**\n+ * An interface to classes that implement an algorithm to calculate the \n+ * eigen decomposition of a real matrix.\n+ * <p>The eigen decomposition of matrix A is a set of two matrices:\n+ * V and D such that A = V &times; D &times; V<sup>T</sup>.\n+ * A, V and D are all m &times; m matrices.</p>\n+ * <p>This interface is similar in spirit to the <code>EigenvalueDecomposition</code>\n+ * class from the now defunct <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a>\n+ * library, with the following changes:</p>\n+ * <ul>\n+ *   <li>a {@link #getVT() getVt} method has been added,</li>\n+ *   <li>two {@link #getRealEigenvalue(int) getRealEigenvalue} and {@link #getImagEigenvalue(int)\n+ *   getImagEigenvalue} methods to pick up a single eigenvalue have been added,</li>\n+ *   <li>a {@link #getEigenvector(int) getEigenvector} method to pick up a single\n+ *   eigenvector has been added,</li>\n+ *   <li>a {@link #getDeterminant() getDeterminant} method has been added.</li>\n+ *   <li>a {@link #getSolver() getSolver} method has been added.</li>\n+ * </ul>\n+ * @see <a href=\"http://mathworld.wolfram.com/EigenDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix\">Wikipedia</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface EigenDecomposition {\n+\n+    /**\n+     * Returns the matrix V of the decomposition. \n+     * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * <p>The columns of V are the eigenvectors of the original matrix.</p>\n+     * @return the V matrix\n+     */\n+    RealMatrix getV();\n+\n+    /**\n+     * Returns the block diagonal matrix D of the decomposition. \n+     * <p>D is a block diagonal matrix.</p>\n+     * <p>Real eigenvalues are on the diagonal while complex values are on\n+     * 2x2 blocks { {real +imaginary}, {-imaginary, real} }.</p>\n+     * @return the D matrix\n+     * @see #getRealEigenvalues()\n+     * @see #getImagEigenvalues()\n+     */\n+    RealMatrix getD();\n+\n+    /**\n+     * Returns the transpose of the matrix V of the decomposition. \n+     * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * <p>The columns of V are the eigenvectors of the original matrix.</p>\n+     * @return the transpose of the V matrix\n+     */\n+    RealMatrix getVT();\n+\n+    /**\n+     * Returns a copy of the real parts of the eigenvalues of the original matrix.\n+     * @return a copy of the real parts of the eigenvalues of the original matrix\n+     * @see #getD()\n+     * @see #getRealEigenvalue(int)\n+     * @see #getImagEigenvalues()\n+     */\n+    double[] getRealEigenvalues();\n+\n+    /**\n+     * Returns the real part of the i<sup>th</sup> eigenvalue of the original matrix.\n+     * @param i index of the eigenvalue (counting from 0)\n+     * @return real part of the i<sup>th</sup> eigenvalue of the original matrix\n+     * @see #getD()\n+     * @see #getRealEigenvalues()\n+     * @see #getImagEigenvalue(int)\n+     */\n+    double getRealEigenvalue(int i);\n+\n+    /**\n+     * Returns a copy of the imaginary parts of the eigenvalues of the original matrix.\n+     * @return a copy of the imaginary parts of the eigenvalues of the original matrix\n+     * @see #getD()\n+     * @see #getImagEigenvalue(int)\n+     * @see #getRealEigenvalues()\n+     */\n+    double[] getImagEigenvalues();\n+\n+    /**\n+     * Returns the imaginary part of the i<sup>th</sup> eigenvalue of the original matrix.\n+     * @param i index of the eigenvalue (counting from 0)\n+     * @return imaginary part of the i<sup>th</sup> eigenvalue of the original matrix\n+     * @see #getD()\n+     * @see #getImagEigenvalues()\n+     * @see #getRealEigenvalue(int)\n+     */\n+    double getImagEigenvalue(int i);\n+\n+    /**\n+     * Returns a copy of the i<sup>th</sup> eigenvector of the original matrix.\n+     * @param i index of the eigenvector (counting from 0)\n+     * @return copy of the i<sup>th</sup> eigenvector of the original matrix\n+     * @see #getD()\n+     */\n+    RealVector getEigenvector(int i);\n+\n+    /**\n+     * Return the determinant of the matrix\n+     * @return determinant of the matrix\n+     */\n+    double getDeterminant();\n+\n+    /**\n+     * Get a solver for finding the A &times; X = B solution in exact linear sense.\n+     * @return a solver\n+     */\n+    DecompositionSolver getSolver();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Calculates the eigen decomposition of a <strong>symmetric</strong> matrix.\n+ * <p>The eigen decomposition of matrix A is a set of two matrices:\n+ * V and D such that A = V D V<sup>T</sup>. A, V and D are all m &times; m\n+ * matrices.</p>\n+ * <p>As of 2.0, this class supports only <strong>symmetric</strong> matrices,\n+ * and hence computes only real realEigenvalues. This implies the D matrix returned by\n+ * {@link #getD()} is always diagonal and the imaginary values returned {@link\n+ * #getImagEigenvalue(int)} and {@link #getImagEigenvalues()} are always null.</p>\n+ * <p>When called with a {@link RealMatrix} argument, this implementation only uses\n+ * the upper part of the matrix, the part below the diagonal is not accessed at all.</p>\n+ * <p>Eigenvalues are computed as soon as the matrix is decomposed, but eigenvectors\n+ * are computed only when required, i.e. only when one of the {@link #getEigenvector(int)},\n+ * {@link #getV()}, {@link #getVT()}, {@link #getSolver()} methods is called.</p>\n+ * <p>This implementation is based on Inderjit Singh Dhillon thesis\n+ * <a href=\"http://www.cs.utexas.edu/users/inderjit/public_papers/thesis.pdf\">A\n+ * New O(n<sup>2</sup>) Algorithm for the Symmetric Tridiagonal Eigenvalue/Eigenvector\n+ * Problem</a>, on Beresford N. Parlett and Osni A. Marques paper <a\n+ * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An Implementation of the\n+ * dqds Algorithm (Positive Case)</a> and on the corresponding LAPACK routines (DLARRE,\n+ * DLASQ2, DLAZQ3, DLAZQ4, DLASQ5 and DLASQ6).</p>\n+ * @author Beresford Parlett, University of California, Berkeley, USA (fortran version)\n+ * @author Jim Demmel, University of California, Berkeley, USA (fortran version)\n+ * @author Inderjit Dhillon, University of Texas, Austin, USA(fortran version)\n+ * @author Osni Marques, LBNL/NERSC, USA (fortran version)\n+ * @author Christof Voemel, University of California, Berkeley, USA(fortran version)\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class EigenDecompositionImpl implements EigenDecomposition {\n+\n+    /** Tolerance. */\n+    private static final double TOLERANCE = 100 * MathUtils.EPSILON;\n+\n+    /** Squared tolerance. */\n+    private static final double TOLERANCE_2 = TOLERANCE * TOLERANCE;\n+\n+    /** Split tolerance. */\n+    private double splitTolerance;\n+\n+    /** Main diagonal of the tridiagonal matrix. */\n+    private double[] main;\n+\n+    /** Secondary diagonal of the tridiagonal matrix. */\n+    private double[] secondary;\n+\n+    /** Squared secondary diagonal of the tridiagonal matrix. */\n+    private double[] squaredSecondary;\n+\n+    /** Transformer to tridiagonal (may be null if matrix is already tridiagonal). */\n+    private TriDiagonalTransformer transformer;\n+\n+    /** Lower bound of spectra. */\n+    private double lowerSpectra;\n+\n+    /** Upper bound of spectra. */\n+    private double upperSpectra;\n+\n+    /** Minimum pivot in the Sturm sequence. */\n+    private double minPivot;\n+\n+    /** Current shift. */\n+    private double sigma;\n+\n+    /** Low part of the current shift. */\n+    private double sigmaLow;\n+\n+    /** Shift increment to apply. */\n+    private double tau;\n+\n+    /** Work array for all decomposition algorithms. */\n+    private double[] work;\n+\n+    /** Shift within qd array for ping-pong implementation. */\n+    private int pingPong;\n+\n+    /** Max value of diagonal elements in current segment. */\n+    private double qMax;\n+\n+    /** Min value of off-diagonal elements in current segment. */\n+    private double eMin;\n+\n+    /** Type of the last dqds shift. */\n+    private int    tType;\n+\n+    /** Minimal value on current state of the diagonal. */\n+    private double dMin;\n+\n+    /** Minimal value on current state of the diagonal, excluding last element. */\n+    private double dMin1;\n+\n+    /** Minimal value on current state of the diagonal, excluding last two elements. */\n+    private double dMin2;\n+\n+    /** Last value on current state of the diagonal. */\n+    private double dN;\n+\n+    /** Last but one value on current state of the diagonal. */\n+    private double dN1;\n+\n+    /** Last but two on current state of the diagonal. */\n+    private double dN2;\n+\n+    /** Shift ratio with respect to dMin used when tType == 6. */\n+    private double g;\n+\n+    /** Real part of the realEigenvalues. */\n+    private double[] realEigenvalues;\n+\n+    /** Imaginary part of the realEigenvalues. */\n+    private double[] imagEigenvalues;\n+\n+    /** Eigenvectors. */\n+    private ArrayRealVector[] eigenvectors;\n+\n+    /** Cached value of V. */\n+    private RealMatrix cachedV;\n+\n+    /** Cached value of D. */\n+    private RealMatrix cachedD;\n+\n+    /** Cached value of Vt. */\n+    private RealMatrix cachedVt;\n+\n+    /**\n+     * Calculates the eigen decomposition of the given symmetric matrix. \n+     * @param matrix The <strong>symmetric</strong> matrix to decompose.\n+     * @param splitTolerance tolerance on the off-diagonal elements relative to the\n+     * geometric mean to split the tridiagonal matrix (a suggested value is\n+     * {@link MathUtils#SAFE_MIN})\n+     * @exception InvalidMatrixException (wrapping a {@link ConvergenceException}\n+     * if algorithm fails to converge\n+     */\n+    public EigenDecompositionImpl(final RealMatrix matrix,\n+                                  final double splitTolerance)\n+        throws InvalidMatrixException {\n+        if (isSymmetric(matrix)) {\n+            this.splitTolerance = splitTolerance;\n+            transformToTridiagonal(matrix);\n+            decompose();\n+        } else {\n+            // as of 2.0, non-symmetric matrices (i.e. complex eigenvalues) are NOT supported\n+            // see issue https://issues.apache.org/jira/browse/MATH-235\n+            throw new InvalidMatrixException(\"eigen decomposition of assymetric matrices not supported yet\");\n+        }\n+    }\n+\n+    /**\n+     * Calculates the eigen decomposition of the given tridiagonal symmetric matrix. \n+     * @param main the main diagonal of the matrix (will be copied)\n+     * @param secondary the secondary diagonal of the matrix (will be copied)\n+     * @param splitTolerance tolerance on the off-diagonal elements relative to the\n+     * geometric mean to split the tridiagonal matrix (a suggested value is\n+     * {@link MathUtils#SAFE_MIN})\n+     * @exception InvalidMatrixException (wrapping a {@link ConvergenceException}\n+     * if algorithm fails to converge\n+     */\n+    public EigenDecompositionImpl(final double[] main, double[] secondary,\n+            final double splitTolerance)\n+        throws InvalidMatrixException {\n+\n+        this.main      = main.clone();\n+        this.secondary = secondary.clone();\n+        transformer    = null;\n+\n+        // pre-compute some elements\n+        squaredSecondary = new double[secondary.length];\n+        for (int i = 0; i < squaredSecondary.length; ++i) {\n+            final double s = secondary[i];\n+            squaredSecondary[i] = s * s;\n+        }\n+\n+        this.splitTolerance = splitTolerance;\n+        decompose();\n+\n+    }\n+\n+    /**\n+     * Check if a matrix is symmetric.\n+     * @param matrix matrix to check\n+     * @return true if matrix is symmetric\n+     */\n+    private boolean isSymmetric(final RealMatrix matrix) {\n+        final int rows    = matrix.getRowDimension();\n+        final int columns = matrix.getColumnDimension();\n+        final double eps  = 10 * rows * columns * MathUtils.EPSILON;\n+        for (int i = 0; i < rows; ++i) {\n+            for (int j = i + 1; j < columns; ++j) {\n+                final double mij = matrix.getEntry(i, j);\n+                final double mji = matrix.getEntry(j, i);\n+                if (Math.abs(mij - mji) > (Math.max(Math.abs(mij), Math.abs(mji)) * eps)) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Decompose a tridiagonal symmetric matrix. \n+     * @exception InvalidMatrixException (wrapping a {@link ConvergenceException}\n+     * if algorithm fails to converge\n+     */\n+    private void decompose() {\n+\n+        cachedV  = null;\n+        cachedD  = null;\n+        cachedVt = null;\n+        work     = new double[6 * main.length];\n+\n+        // compute the Gershgorin circles\n+        computeGershgorinCircles();\n+\n+        // find all the realEigenvalues\n+        findEigenvalues();\n+\n+        // we will search for eigenvectors only if required\n+        eigenvectors = null;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getV()\n+        throws InvalidMatrixException {\n+\n+        if (cachedV == null) {\n+\n+            if (eigenvectors == null) {\n+                findEigenVectors();\n+            }\n+\n+            final int m = eigenvectors.length;\n+            cachedV = MatrixUtils.createRealMatrix(m, m);\n+            for (int k = 0; k < m; ++k) {\n+                cachedV.setColumnVector(k, eigenvectors[k]);\n+            }\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedV;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getD()\n+        throws InvalidMatrixException {\n+        if (cachedD == null) {\n+            // cache the matrix for subsequent calls\n+            cachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\n+        }\n+        return cachedD;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getVT()\n+        throws InvalidMatrixException {\n+\n+        if (cachedVt == null) {\n+\n+            if (eigenvectors == null) {\n+                findEigenVectors();\n+            }\n+\n+            final int m = eigenvectors.length;\n+            cachedVt = MatrixUtils.createRealMatrix(m, m);\n+            for (int k = 0; k < m; ++k) {\n+                cachedVt.setRowVector(k, eigenvectors[k]);\n+            }\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedVt;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getRealEigenvalues()\n+        throws InvalidMatrixException {\n+        return realEigenvalues.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getRealEigenvalue(final int i)\n+        throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n+        return realEigenvalues[i];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getImagEigenvalues()\n+        throws InvalidMatrixException {\n+        return imagEigenvalues.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getImagEigenvalue(final int i)\n+        throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n+        return imagEigenvalues[i];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector getEigenvector(final int i)\n+        throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n+        if (eigenvectors == null) {\n+            findEigenVectors();\n+        }\n+        return eigenvectors[i].copy();\n+    }\n+\n+    /**\n+     * Return the determinant of the matrix\n+     * @return determinant of the matrix\n+     */\n+    public double getDeterminant() {\n+        double determinant = 1;\n+        for (double lambda : realEigenvalues) {\n+            determinant *= lambda;\n+        }\n+        return determinant;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DecompositionSolver getSolver() {\n+        if (eigenvectors == null) {\n+            findEigenVectors();\n+        }\n+        return new Solver(realEigenvalues, imagEigenvalues, eigenvectors);\n+    }\n+\n+    /** Specialized solver. */\n+    private static class Solver implements DecompositionSolver {\n+    \n+        /** Real part of the realEigenvalues. */\n+        private double[] realEigenvalues;\n+\n+        /** Imaginary part of the realEigenvalues. */\n+        private double[] imagEigenvalues;\n+\n+        /** Eigenvectors. */\n+        private final ArrayRealVector[] eigenvectors;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         * @param realEigenvalues real parts of the eigenvalues\n+         * @param imagEigenvalues imaginary parts of the eigenvalues\n+         * @param eigenvectors eigenvectors\n+         */\n+        private Solver(final double[] realEigenvalues, final double[] imagEigenvalues,\n+                       final ArrayRealVector[] eigenvectors) {\n+            this.realEigenvalues = realEigenvalues;\n+            this.imagEigenvalues = imagEigenvalues;\n+            this.eigenvectors    = eigenvectors; \n+        }\n+\n+        /** Solve the linear equation A &times; X = B for symmetric matrices A.\n+         * <p>This method only find exact linear solutions, i.e. solutions for\n+         * which ||A &times; X - B|| is exactly 0.</p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a vector X that minimizes the two norm of A &times; X - B\n+         * @exception IllegalArgumentException if matrices dimensions don't match\n+         * @exception InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public double[] solve(final double[] b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            if (!isNonSingular()) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final int m = realEigenvalues.length;\n+            if (b.length != m) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"vector length mismatch: got {0} but expected {1}\",\n+                        b.length, m);\n+            }\n+\n+            final double[] bp = new double[m];\n+            for (int i = 0; i < m; ++i) {\n+                final ArrayRealVector v = eigenvectors[i];\n+                final double[] vData = v.getDataRef();\n+                final double s = v.dotProduct(b) / realEigenvalues[i];\n+                for (int j = 0; j < m; ++j) {\n+                    bp[j] += s * vData[j];\n+                }\n+            }\n+\n+            return bp;\n+\n+        }\n+\n+        /** Solve the linear equation A &times; X = B for symmetric matrices A.\n+         * <p>This method only find exact linear solutions, i.e. solutions for\n+         * which ||A &times; X - B|| is exactly 0.</p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a vector X that minimizes the two norm of A &times; X - B\n+         * @exception IllegalArgumentException if matrices dimensions don't match\n+         * @exception InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public RealVector solve(final RealVector b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            if (!isNonSingular()) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final int m = realEigenvalues.length;\n+            if (b.getDimension() != m) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"vector length mismatch: got {0} but expected {1}\",\n+                        b.getDimension(), m);\n+            }\n+\n+            final double[] bp = new double[m];\n+            for (int i = 0; i < m; ++i) {\n+                final ArrayRealVector v = eigenvectors[i];\n+                final double[] vData = v.getDataRef();\n+                final double s = v.dotProduct(b) / realEigenvalues[i];\n+                for (int j = 0; j < m; ++j) {\n+                    bp[j] += s * vData[j];\n+                }\n+            }\n+\n+            return new ArrayRealVector(bp, false);\n+\n+        }\n+\n+        /** Solve the linear equation A &times; X = B for symmetric matrices A.\n+         * <p>This method only find exact linear solutions, i.e. solutions for\n+         * which ||A &times; X - B|| is exactly 0.</p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a matrix X that minimizes the two norm of A &times; X - B\n+         * @exception IllegalArgumentException if matrices dimensions don't match\n+         * @exception InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public RealMatrix solve(final RealMatrix b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            if (!isNonSingular()) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final int m = realEigenvalues.length;\n+            if (b.getRowDimension() != m) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n+            }\n+\n+            final int nColB = b.getColumnDimension();\n+            final double[][] bp = new double[m][nColB];\n+            for (int k = 0; k < nColB; ++k) {\n+                for (int i = 0; i < m; ++i) {\n+                    final ArrayRealVector v = eigenvectors[i];\n+                    final double[] vData = v.getDataRef();\n+                    double s = 0;\n+                    for (int j = 0; j < m; ++j) {\n+                        s += v.getEntry(j) * b.getEntry(j, k);\n+                    }\n+                    s /= realEigenvalues[i];\n+                    for (int j = 0; j < m; ++j) {\n+                        bp[j][k] += s * vData[j];\n+                    }\n+                }\n+            }\n+\n+            return MatrixUtils.createRealMatrix(bp);\n+\n+        }\n+\n+        /**\n+         * Check if the decomposed matrix is non-singular.\n+         * @return true if the decomposed matrix is non-singular\n+         */\n+        public boolean isNonSingular() {\n+            for (int i = 0; i < realEigenvalues.length; ++i) {\n+                if ((realEigenvalues[i] == 0) && (imagEigenvalues[i] == 0)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        /** Get the inverse of the decomposed matrix.\n+         * @return inverse matrix\n+         * @throws InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public RealMatrix getInverse()\n+            throws InvalidMatrixException {\n+\n+            if (!isNonSingular()) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final int m = realEigenvalues.length;\n+            final double[][] invData = new double[m][m];\n+\n+            for (int i = 0; i < m; ++i) {\n+                final double[] invI = invData[i];\n+                for (int j = 0; j < m; ++j) {\n+                    double invIJ = 0;\n+                    for (int k = 0; k < m; ++k) {\n+                        final double[] vK = eigenvectors[k].getDataRef();\n+                        invIJ += vK[i] * vK[j] / realEigenvalues[k];\n+                    }\n+                    invI[j] = invIJ;\n+                }\n+            }\n+            return MatrixUtils.createRealMatrix(invData);\n+\n+        }\n+\n+    }\n+\n+    /**\n+     * Transform matrix to tridiagonal.\n+     * @param matrix matrix to transform\n+     */\n+    private void transformToTridiagonal(final RealMatrix matrix) {\n+\n+        // transform the matrix to tridiagonal\n+        transformer = new TriDiagonalTransformer(matrix);\n+        main      = transformer.getMainDiagonalRef();\n+        secondary = transformer.getSecondaryDiagonalRef();\n+\n+        // pre-compute some elements\n+        squaredSecondary = new double[secondary.length];\n+        for (int i = 0; i < squaredSecondary.length; ++i) {\n+            final double s = secondary[i];\n+            squaredSecondary[i] = s * s;\n+        }\n+\n+    }\n+\n+    /**\n+     * Compute the Gershgorin circles for all rows.\n+     */\n+    private void computeGershgorinCircles() {\n+\n+        final int m     = main.length;\n+        final int lowerStart = 4 * m;\n+        final int upperStart = 5 * m;\n+        lowerSpectra = Double.POSITIVE_INFINITY;\n+        upperSpectra = Double.NEGATIVE_INFINITY;\n+        double eMax = 0;\n+\n+        double eCurrent = 0;\n+        for (int i = 0; i < m - 1; ++i) {\n+\n+            final double dCurrent = main[i];\n+            final double ePrevious = eCurrent;\n+            eCurrent = Math.abs(secondary[i]);\n+            eMax = Math.max(eMax, eCurrent);\n+            final double radius = ePrevious + eCurrent;\n+\n+            final double lower = dCurrent - radius;\n+            work[lowerStart + i] = lower;\n+            lowerSpectra = Math.min(lowerSpectra, lower);\n+\n+            final double upper = dCurrent + radius;\n+            work[upperStart + i] = upper;\n+            upperSpectra = Math.max(upperSpectra, upper);\n+            \n+        }\n+\n+        final double dCurrent = main[m - 1];\n+        work[lowerStart + m - 1] = dCurrent - eCurrent;\n+        work[upperStart + m - 1] = dCurrent + eCurrent;\n+        minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n+\n+    }\n+\n+    /**\n+     * Find the realEigenvalues.\n+     * @exception InvalidMatrixException if a block cannot be diagonalized\n+     */\n+    private void findEigenvalues()\n+        throws InvalidMatrixException {\n+\n+        // compute splitting points\n+        List<Integer> splitIndices = computeSplits();\n+\n+        // find realEigenvalues in each block\n+        realEigenvalues = new double[main.length];\n+        imagEigenvalues = new double[main.length];\n+        int begin = 0;\n+        for (final int end : splitIndices) {\n+            final int n = end - begin;\n+            switch (n) {\n+\n+            case 1:\n+                // apply dedicated method for dimension 1\n+                process1RowBlock(begin);\n+                break;\n+\n+            case 2:\n+                // apply dedicated method for dimension 2\n+                process2RowsBlock(begin);\n+                break;\n+\n+            case 3:\n+                // apply dedicated method for dimension 3\n+                process3RowsBlock(begin);\n+                break;\n+\n+            default:\n+\n+                // choose an initial shift for LDL<sup>T</sup> decomposition\n+                final double[] range       = eigenvaluesRange(begin, n);\n+                final double oneFourth     = 0.25 * (3 * range[0] + range[1]);\n+                final int oneFourthCount   = countEigenValues(oneFourth, begin, n);\n+                final double threeFourth   = 0.25 * (range[0] + 3 * range[1]);\n+                final int threeFourthCount = countEigenValues(threeFourth, begin, n);\n+                final boolean chooseLeft   = (oneFourthCount - 1) >= (n - threeFourthCount);\n+                final double lambda        = chooseLeft ? range[0] : range[1];\n+\n+                tau = (range[1] - range[0]) * MathUtils.EPSILON * n + 2 * minPivot;\n+\n+                // decompose T&lambda;I as LDL<sup>T</sup>\n+                ldlTDecomposition(lambda, begin, n);\n+\n+                // apply general dqd/dqds method\n+                processGeneralBlock(n);\n+\n+                // extract realEigenvalues\n+                if (chooseLeft) {\n+                    for (int i = 0; i < n; ++i) {\n+                        realEigenvalues[begin + i] = lambda + work[4 * i];\n+                    }\n+                } else {\n+                    for (int i = 0; i < n; ++i) {\n+                        realEigenvalues[begin + i] = lambda - work[4 * i];\n+                    }                    \n+                }\n+\n+            }\n+            begin = end;\n+        }\n+\n+        // sort the realEigenvalues in decreasing order\n+        Arrays.sort(realEigenvalues);\n+        for (int i = 0, j = realEigenvalues.length - 1; i < j; ++i, --j) {\n+            final double tmp = realEigenvalues[i];\n+            realEigenvalues[i] = realEigenvalues[j];\n+            realEigenvalues[j] = tmp;\n+        }\n+\n+    }\n+\n+    /**\n+     * Compute splitting points.\n+     * @return list of indices after matrix can be split\n+     */\n+    private List<Integer> computeSplits() {\n+\n+        final List<Integer> list = new ArrayList<Integer>();\n+\n+        // splitting preserving relative accuracy\n+        double absDCurrent = Math.abs(main[0]);\n+        for (int i = 0; i < secondary.length; ++i) {\n+            final double absDPrevious = absDCurrent;\n+            absDCurrent = Math.abs(main[i + 1]);\n+            final double max = splitTolerance * Math.sqrt(absDPrevious * absDCurrent);\n+            if (Math.abs(secondary[i]) <= max) {\n+                list.add(i + 1);\n+                secondary[i] = 0;\n+                squaredSecondary[i] = 0;\n+            }\n+        }\n+\n+        list.add(secondary.length + 1);\n+        return list;\n+\n+    }\n+\n+    /**\n+     * Find eigenvalue in a block with 1 row.\n+     * <p>In low dimensions, we simply solve the characteristic polynomial.</p>\n+     * @param index index of the first row of the block\n+     */\n+    private void process1RowBlock(final int index) {\n+        realEigenvalues[index] = main[index];\n+    }\n+\n+    /**\n+     * Find realEigenvalues in a block with 2 rows.\n+     * <p>In low dimensions, we simply solve the characteristic polynomial.</p>\n+     * @param index index of the first row of the block\n+     * @exception InvalidMatrixException if characteristic polynomial cannot be solved\n+     */\n+    private void process2RowsBlock(final int index)\n+        throws InvalidMatrixException {\n+\n+        // the characteristic polynomial is\n+        // X^2 - (q0 + q1) X + q0 q1 - e1^2\n+        final double q0   = main[index];\n+        final double q1   = main[index + 1];\n+        final double e12  = squaredSecondary[index];\n+\n+        final double s     = q0 + q1;\n+        final double p     = q0 * q1 - e12;\n+        final double delta = s * s - 4 * p;\n+        if (delta < 0) {\n+            throw new InvalidMatrixException(\"cannot solve degree {0} equation\", 2);\n+        }\n+\n+        final double largestRoot = 0.5 * (s + Math.sqrt(delta));\n+        realEigenvalues[index]     = largestRoot;\n+        realEigenvalues[index + 1] = p / largestRoot;\n+\n+    }\n+\n+    /**\n+     * Find realEigenvalues in a block with 3 rows.\n+     * <p>In low dimensions, we simply solve the characteristic polynomial.</p>\n+     * @param index index of the first row of the block\n+     * @exception InvalidMatrixException if diagonal elements are not positive\n+     */\n+    private void process3RowsBlock(final int index)\n+        throws InvalidMatrixException {\n+\n+        // the characteristic polynomial is\n+        // X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2\n+        final double q0       = main[index];\n+        final double q1       = main[index + 1];\n+        final double q2       = main[index + 2];\n+        final double e12      = squaredSecondary[index];\n+        final double q1q2Me22 = q1 * q2 - squaredSecondary[index + 1];\n+\n+        // compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0\n+        final double b        = -(q0 + q1 + q2);\n+        final double c        = q0 * q1 + q0 * q2 + q1q2Me22 - e12;\n+        final double d        = q2 * e12 - q0 * q1q2Me22;\n+\n+        // solve cubic equation\n+        final double b2       = b * b;\n+        final double q        = (3 * c - b2) / 9;\n+        final double r        = ((9 * c - 2 * b2) * b - 27 * d) / 54;\n+        final double delta    = q * q * q + r * r;\n+        if (delta >= 0) {\n+            // in fact, there are solutions to the equation, but in the context\n+            // of symmetric realEigenvalues problem, there should be three distinct\n+            // real roots, so we throw an error if this condition is not met\n+            throw new InvalidMatrixException(\"cannot solve degree {0} equation\", 3);           \n+        }\n+        final double sqrtMq = Math.sqrt(-q);\n+        final double theta  = Math.acos(r / (-q * sqrtMq));\n+        final double alpha  = 2 * sqrtMq;\n+        final double beta   = b / 3;\n+\n+        double z0 = alpha * Math.cos(theta / 3) - beta;\n+        double z1 = alpha * Math.cos((theta + 2 * Math.PI) / 3) - beta;\n+        double z2 = alpha * Math.cos((theta + 4 * Math.PI) / 3) - beta;\n+        if (z0 < z1) {\n+            final double t = z0;\n+            z0 = z1;\n+            z1 = t;\n+        }\n+        if (z1 < z2) {\n+            final double t = z1;\n+            z1 = z2;\n+            z2 = t;\n+        }\n+        if (z0 < z1) {\n+            final double t = z0;\n+            z0 = z1;\n+            z1 = t;\n+        }\n+        realEigenvalues[index]     = z0;\n+        realEigenvalues[index + 1] = z1;\n+        realEigenvalues[index + 2] = z2;\n+\n+    }\n+\n+    /**\n+     * Find realEigenvalues using dqd/dqds algorithms.\n+     * <p>This implementation is based on Beresford N. Parlett\n+     * and Osni A. Marques paper <a\n+     * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An\n+     * Implementation of the dqds Algorithm (Positive Case)</a> and on the\n+     * corresponding LAPACK routine DLASQ2.</p>\n+     * @param n number of rows of the block\n+     * @exception InvalidMatrixException if block cannot be diagonalized\n+     * after 30 * n iterations\n+     */\n+    private void processGeneralBlock(final int n)\n+        throws InvalidMatrixException {\n+\n+        // check decomposed matrix data range\n+        double sumOffDiag = 0;\n+        for (int i = 0; i < n - 1; ++i) {\n+            final int fourI = 4 * i;\n+            final double ei = work[fourI + 2];\n+            sumOffDiag += ei;\n+        }\n+\n+        if (sumOffDiag == 0) {\n+            // matrix is already diagonal\n+            return;\n+        }\n+\n+        // initial checks for splits (see Parlett & Marques section 3.3)\n+        flipIfWarranted(n, 2);\n+\n+        // two iterations with Li's test for initial splits\n+        initialSplits(n);\n+\n+        // initialize parameters used by goodStep\n+        tType = 0;\n+        dMin1 = 0;\n+        dMin2 = 0;\n+        dN    = 0;\n+        dN1   = 0;\n+        dN2   = 0;\n+        tau   = 0;\n+\n+        // process split segments\n+        int i0 = 0;\n+        int n0 = n;\n+        while (n0 > 0) {\n+\n+            // retrieve shift that was temporarily stored as a negative off-diagonal element\n+            sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];\n+            sigmaLow = 0;\n+\n+            // find start of a new split segment to process\n+            double eMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\n+            double eMax = 0;\n+            double qMax = work[4 * n0 - 4];\n+            double qMin = qMax;\n+            i0 = 0;\n+            for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n+                if (work[i + 2] <= 0) {\n+                    i0 = 1 + i / 4;\n+                    break;\n+                }\n+                if (qMin >= 4 * eMax) {\n+                    qMin = Math.min(qMin, work[i + 4]);\n+                    eMax = Math.max(eMax, work[i + 2]);\n+                }\n+                qMax = Math.max(qMax, work[i] + work[i + 2]);\n+                eMin = Math.min(eMin, work[i + 2]);\n+            }\n+            work[4 * n0 - 2] = eMin;\n+\n+            // lower bound of Gershgorin disk\n+            dMin = -Math.max(0, qMin - 2 * Math.sqrt(qMin * eMax));\n+\n+            pingPong = 0;\n+            int maxIter = 30 * (n0 - i0);\n+            for (int k = 0; i0 < n0; ++k) {\n+                if (k >= maxIter) {\n+                    throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\n+                }\n+\n+                // perform one step\n+                n0 = goodStep(i0, n0);\n+                pingPong = 1 - pingPong;\n+\n+                // check for new splits after \"ping\" steps\n+                // when the last elements of qd array are very small\n+                if ((pingPong == 0) && (n0 - i0 > 3) &&\n+                    (work[4 * n0 - 1] <= TOLERANCE_2 * qMax) &&\n+                    (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\n+                    int split = i0 - 1;\n+                    qMax = work[4 * i0];\n+                    eMin = work[4 * i0 + 2];\n+                    double previousEMin = work[4 * i0 + 3];\n+                    for (int i = 4 * i0; i < 4 * n0 - 11; i += 4) {\n+                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) &&\n+                            (work[i + 2] <= TOLERANCE_2 * sigma)) {\n+                            // insert a split\n+                            work[i + 2]  = -sigma;\n+                            split        = i / 4;\n+                            qMax         = 0;\n+                            eMin         = work[i + 6];\n+                            previousEMin = work[i + 7];\n+                        } else {\n+                            qMax         = Math.max(qMax, work[i + 4]);\n+                            eMin         = Math.min(eMin, work[i + 2]);\n+                            previousEMin = Math.min(previousEMin, work[i + 3]);\n+                        }\n+                    }\n+                    work[4 * n0 - 2] = eMin;\n+                    work[4 * n0 - 1] = previousEMin;\n+                    i0 = split + 1;\n+                }\n+            }\n+\n+        }\n+\n+    }\n+\n+    /**\n+     * Perform two iterations with Li's tests for initial splits.\n+     * @param n number of rows of the matrix to process\n+     */\n+    private void initialSplits(final int n) {\n+\n+        pingPong = 0;\n+        for (int k = 0; k < 2; ++k) {\n+\n+            // apply Li's reverse test\n+            double d = work[4 * (n - 1) + pingPong];\n+            for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) {\n+                if (work[i + 2] <= TOLERANCE_2 * d) {\n+                    work[i + 2] = -0.0;\n+                    d = work[i];\n+                } else {\n+                    d *= work[i] / (d + work[i + 2]);\n+                }\n+            }\n+\n+            // apply dqd plus Li's forward test.\n+            d = work[pingPong];\n+            for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) {\n+                final int j = i - 2 * pingPong - 1;\n+                work[j] = d + work[i];\n+                if (work[i] <= TOLERANCE_2 * d) {\n+                    work[i]     = -0.0;\n+                    work[j]     = d;\n+                    work[j + 2] = 0.0;\n+                    d = work[i + 2];\n+                } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&\n+                           (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {\n+                    final double tmp = work[i + 2] / work[j];\n+                    work[j + 2] = work[i] * tmp;\n+                    d *= tmp;\n+                } else {\n+                    work[j + 2] = work[i + 2] * (work[i] / work[j]);\n+                    d *= work[i + 2] / work[j];\n+               }\n+            }\n+            work[4 * n - 3 - pingPong] = d;\n+\n+            // from ping to pong\n+            pingPong = 1 - pingPong;\n+\n+        }\n+\n+    }\n+\n+    /**\n+     * Perform one \"good\" dqd/dqds step.\n+     * <p>This implementation is based on Beresford N. Parlett\n+     * and Osni A. Marques paper <a\n+     * href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An\n+     * Implementation of the dqds Algorithm (Positive Case)</a> and on the\n+     * corresponding LAPACK routine DLAZQ3.</p>\n+     * @param start start index\n+     * @param end end index\n+     * @return new end (maybe deflated)\n+     */\n+    private int goodStep(final int start, final int end) {\n+\n+        g = 0.0;\n+\n+        // step 1: accepting realEigenvalues\n+        int deflatedEnd = end;\n+        for (boolean deflating = true; deflating;) {\n+\n+            if (start >= deflatedEnd) {\n+                // the array has been completely deflated\n+                return deflatedEnd;\n+            }\n+\n+            final int k = 4 * deflatedEnd + pingPong - 1;\n+\n+            if ((start == deflatedEnd - 1) ||\n+                ((start != deflatedEnd - 2) &&\n+                 ((work[k - 5] <= TOLERANCE_2 * (sigma + work[k - 3])) ||\n+                  (work[k - 2 * pingPong - 4] <= TOLERANCE_2 * work[k - 7])))) {\n+\n+                // one eigenvalue found, deflate array\n+                work[4 * deflatedEnd - 4] = sigma + work[4 * deflatedEnd - 4 + pingPong];\n+                deflatedEnd -= 1;\n+\n+            } else if ((start == deflatedEnd - 2) ||\n+                (work[k - 9] <= TOLERANCE_2 * sigma) ||\n+                (work[k - 2 * pingPong - 8] <= TOLERANCE_2 * work[k - 11])) {\n+\n+                // two realEigenvalues found, deflate array\n+                if (work[k - 3] > work[k - 7]) {\n+                    final double tmp = work[k - 3];\n+                    work[k - 3] = work[k - 7];\n+                    work[k - 7] = tmp;\n+                }\n+\n+                if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {\n+                    double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);\n+                    double s = work[k - 3] * (work[k - 5] / t);\n+                    if (s <= t) {\n+                        s = work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));\n+                    } else {\n+                        s = work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));                      \n+                    }\n+                    t = work[k - 7] + (s + work[k - 5]);\n+                    work[k - 3] *= work[k - 7] / t;\n+                    work[k - 7]  = t;\n+                }\n+                work[4 * deflatedEnd - 8] = sigma + work[k - 7];\n+                work[4 * deflatedEnd - 4] = sigma + work[k - 3];\n+                deflatedEnd -= 2;\n+            } else {\n+\n+                // no more realEigenvalues found, we need to iterate\n+                deflating = false;\n+\n+            }\n+\n+        }\n+\n+        final int l = 4 * deflatedEnd + pingPong - 1;\n+\n+        // step 2: flip array if needed\n+        if ((dMin <= 0) || (deflatedEnd < end)) {\n+            if (flipIfWarranted(deflatedEnd, 1)) {\n+                dMin2 = Math.min(dMin2, work[l - 1]);\n+                work[l - 1] =\n+                    Math.min(work[l - 1],\n+                             Math.min(work[3 + pingPong], work[7 + pingPong]));\n+                work[l - 2 * pingPong] =\n+                    Math.min(work[l - 2 * pingPong],\n+                             Math.min(work[6 + pingPong], work[6 + pingPong]));\n+                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));\n+                dMin  = -0.0;\n+            }\n+        }\n+\n+        if ((dMin < 0) ||\n+            (MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1],\n+                                                  Math.min(work[l - 9],\n+                                                           dMin2 + work[l - 2 * pingPong])))) {\n+            // step 3: choose a shift\n+            computeShiftIncrement(start, deflatedEnd, end - deflatedEnd);\n+\n+            // step 4a: dqds\n+            for (boolean loop = true; loop;) {\n+\n+                // perform one dqds step with the chosen shift\n+                dqds(start, deflatedEnd);\n+\n+                // check result of the dqds step\n+                if ((dMin >= 0) && (dMin1 > 0)) {\n+                    // the shift was good\n+                    updateSigma(tau);\n+                    return deflatedEnd;\n+                } else if ((dMin < 0.0) &&\n+                           (dMin1 > 0.0) &&\n+                           (work[4 * deflatedEnd - 5 - pingPong] < TOLERANCE * (sigma + dN1)) &&\n+                           (Math.abs(dN) < TOLERANCE * sigma)) {\n+                   // convergence hidden by negative DN.\n+                    work[4 * deflatedEnd - 3 - pingPong] = 0.0;\n+                    dMin = 0.0;\n+                    updateSigma(tau);\n+                    return deflatedEnd;\n+                } else if (dMin < 0.0) {\n+                    // tau too big. Select new tau and try again.\n+                    if (tType < -22) {\n+                        // failed twice. Play it safe.\n+                        tau = 0.0;\n+                    } else if (dMin1 > 0.0) {\n+                        // late failure. Gives excellent shift.\n+                        tau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);\n+                        tType -= 11;\n+                    } else {\n+                        // early failure. Divide by 4.\n+                        tau *= 0.25;\n+                        tType -= 12;\n+                    }\n+                } else if (Double.isNaN(dMin)) {\n+                    tau = 0.0;\n+                } else {\n+                    // possible underflow. Play it safe.\n+                    loop = false;\n+                }\n+            }\n+\n+        }\n+\n+        // perform a dqd step (i.e. no shift)\n+        dqd(start, deflatedEnd);\n+\n+        return deflatedEnd;\n+\n+    }\n+\n+    /**\n+     * Flip qd array if warranted.\n+     * @param n number of rows in the block\n+     * @param step within the array (1 for flipping all elements, 2 for flipping\n+     * only every other element)\n+     * @return true if qd array was flipped\n+     */\n+    private boolean flipIfWarranted(final int n, final int step) {\n+        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n+            // flip array\n+            for (int i = 0, j = 4 * n - 1; i < j; i += 4, j -= 4) {\n+                for (int k = 0; k < 4; k += step) {\n+                    final double tmp = work[i + k];\n+                    work[i + k] = work[j - k];\n+                    work[j - k] = tmp;\n+                }\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Compute an interval containing all realEigenvalues of a block.\n+     * @param index index of the first row of the block\n+     * @param n number of rows of the block\n+     * @return an interval containing the realEigenvalues\n+     */\n+    private double[] eigenvaluesRange(final int index, final int n) {\n+\n+        // find the bounds of the spectra of the local block\n+        final int lowerStart = 4 * main.length;\n+        final int upperStart = 5 * main.length;\n+        double lower = Double.POSITIVE_INFINITY;\n+        double upper = Double.NEGATIVE_INFINITY;\n+        for (int i = 0; i < n; ++i) {\n+            lower = Math.min(lower, work[lowerStart + index +i]);\n+            upper = Math.max(upper, work[upperStart + index +i]);\n+        }\n+\n+        // set thresholds\n+        final double tNorm = Math.max(Math.abs(lower), Math.abs(upper));\n+        final double relativeTolerance = Math.sqrt(MathUtils.EPSILON);\n+        final double absoluteTolerance = 4 * minPivot;\n+        final int maxIter =\n+            2 + (int) ((Math.log(tNorm + minPivot) - Math.log(minPivot)) / Math.log(2.0));\n+        final double margin = 2 * (tNorm * MathUtils.EPSILON * n + 2 * minPivot);\n+\n+        // search lower eigenvalue\n+        double left  = lower - margin;\n+        double right = upper + margin;\n+        for (int i = 0; i < maxIter; ++i) {\n+\n+            final double range = right - left;\n+            if ((range < absoluteTolerance) ||\n+                (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) {\n+                // search has converged\n+                break;\n+            }\n+\n+            final double middle = 0.5 * (left + right);\n+            if (countEigenValues(middle, index, n) >= 1) {\n+                right = middle;\n+            } else {\n+                left = middle;\n+            }\n+\n+        }\n+        lower = Math.max(lower, left - 100 * MathUtils.EPSILON * Math.abs(left));\n+\n+        // search upper eigenvalue\n+        left  = lower - margin;\n+        right = upper + margin;\n+        for (int i = 0; i < maxIter; ++i) {\n+\n+            final double range = right - left;\n+            if ((range < absoluteTolerance) ||\n+                (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) {\n+                // search has converged\n+                break;\n+            }\n+\n+            final double middle = 0.5 * (left + right);\n+            if (countEigenValues(middle, index, n) >= n) {\n+                right = middle;\n+            } else {\n+                left = middle;\n+            }\n+\n+        }\n+        upper = Math.min(upper, right + 100 * MathUtils.EPSILON * Math.abs(right));\n+\n+        return new double[] { lower, upper };\n+\n+    }\n+\n+    /**\n+     * Count the number of realEigenvalues below a point.\n+     * @param t value below which we must count the number of realEigenvalues\n+     * @param index index of the first row of the block\n+     * @param n number of rows of the block\n+     * @return number of realEigenvalues smaller than t\n+     */\n+    private int countEigenValues(final double t, final int index, final int n) {\n+        double ratio = main[index] - t;\n+        int count = (ratio > 0) ? 0 : 1;\n+        for (int i = 1; i < n; ++i) {\n+            ratio = main[index + i] - squaredSecondary[index + i - 1] / ratio - t;\n+            if (ratio <= 0) {\n+                ++count;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Decompose the shifted tridiagonal matrix T-&lambda;I as LDL<sup>T</sup>.\n+     * <p>A shifted symmetric tridiagonal matrix T can be decomposed as\n+     * LDL<sup>T</sup> where L is a lower bidiagonal matrix with unit diagonal\n+     * and D is a diagonal matrix. This method is an implementation of\n+     * algorithm 4.4.7 from Dhillon's thesis.</p>\n+     * @param lambda shift to add to the matrix before decomposing it\n+     * to ensure it is positive definite\n+     * @param index index of the first row of the block\n+     * @param n number of rows of the block\n+     */\n+    private void ldlTDecomposition(final double lambda, final int index, final int n) {\n+        double di = main[index] - lambda;\n+        work[0] = Math.abs(di);\n+        for (int i = 1; i < n; ++i) {\n+            final int    fourI = 4 * i;\n+            final double eiM1  = secondary[index + i - 1];\n+            final double ratio = eiM1 / di;\n+            work[fourI - 2] = ratio * ratio * Math.abs(di);\n+            di = (main[index + i] - lambda) - eiM1 * ratio;\n+            work[fourI] = Math.abs(di);\n+        }\n+    }\n+\n+    /**\n+     * Perform a dqds step, using current shift increment.\n+     * <p>This implementation is a translation of the LAPACK routine DLASQ5.</p>\n+     * @param start start index\n+     * @param end end index\n+     */\n+    private void dqds(final int start, final int end) {\n+\n+        eMin = work[4 * start + pingPong + 4];\n+        double d = work[4 * start + pingPong] - tau;\n+        dMin = d;\n+        dMin1 = -work[4 * start + pingPong];\n+\n+        if (pingPong == 0) {\n+            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {\n+                work[j4 - 2] = d + work[j4 - 1];\n+                final double tmp = work[j4 + 1] / work[j4 - 2];\n+                d = d * tmp - tau;\n+                dMin = Math.min(dMin, d);\n+                work[j4] = work[j4 - 1] * tmp;\n+                eMin = Math.min(work[j4], eMin);\n+            }\n+        } else {\n+            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {\n+                work[j4 - 3] = d + work[j4];\n+                final double tmp = work[j4 + 2] / work[j4 - 3];\n+                d = d * tmp - tau;\n+                dMin = Math.min(dMin, d);\n+                work[j4 - 1] = work[j4] * tmp;\n+                eMin = Math.min(work[j4 - 1], eMin);\n+            }\n+        }\n+\n+        // unroll last two steps.\n+        dN2 = d;\n+        dMin2 = dMin;\n+        int j4 = 4 * (end - 2) - pingPong - 1;\n+        int j4p2 = j4 + 2 * pingPong - 1;\n+        work[j4 - 2] = dN2 + work[j4p2];\n+        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n+        dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]) - tau;\n+        dMin = Math.min(dMin, dN1);\n+\n+        dMin1 = dMin;\n+        j4 = j4 + 4;\n+        j4p2 = j4 + 2 * pingPong - 1;\n+        work[j4 - 2] = dN1 + work[j4p2];\n+        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n+        dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]) - tau;\n+        dMin = Math.min(dMin, dN);\n+\n+        work[j4 + 2] = dN;\n+        work[4 * end - pingPong - 1] = eMin;\n+\n+    }\n+\n+\n+    /**\n+     * Perform a dqd step.\n+     * <p>This implementation is a translation of the LAPACK routine DLASQ6.</p>\n+     * @param start start index\n+     * @param end end index\n+     */\n+    private void dqd(final int start, final int end) {\n+\n+        eMin = work[4 * start + pingPong + 4];\n+        double d = work[4 * start + pingPong];\n+        dMin = d;\n+\n+        if (pingPong == 0) {\n+            for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {\n+                work[j4 - 2] = d + work[j4 - 1];\n+                if (work[j4 - 2] == 0.0) {\n+                    work[j4] = 0.0;\n+                    d = work[j4 + 1];\n+                    dMin = d;\n+                    eMin = 0.0;\n+                } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&\n+                           (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {\n+                    final double tmp = work[j4 + 1] / work[j4 - 2];\n+                    work[j4] = work[j4 - 1] * tmp;\n+                    d *= tmp;\n+                } else {\n+                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);\n+                    d *= work[j4 + 1] / work[j4 - 2];\n+                }\n+                dMin = Math.min(dMin, d);\n+                eMin = Math.min(eMin, work[j4]);\n+            }\n+        } else {\n+            for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {\n+                work[j4 - 3] = d + work[j4];\n+                if (work[j4 - 3] == 0.0) {\n+                    work[j4 - 1] = 0.0;\n+                    d = work[j4 + 2];\n+                    dMin = d;\n+                    eMin = 0.0;\n+                } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&\n+                           (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {\n+                    final double tmp = work[j4 + 2] / work[j4 - 3];\n+                    work[j4 - 1] = work[j4] * tmp;\n+                    d *= tmp;\n+                } else {\n+                    work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);\n+                    d *= work[j4 + 2] / work[j4 - 3];\n+                }\n+                dMin = Math.min(dMin, d);\n+                eMin = Math.min(eMin, work[j4 - 1]);\n+            }\n+        }\n+\n+        // Unroll last two steps\n+        dN2   = d;\n+        dMin2 = dMin;\n+        int j4 = 4 * (end - 2) - pingPong - 1;\n+        int j4p2 = j4 + 2 * pingPong - 1;\n+        work[j4 - 2] = dN2 + work[j4p2];\n+        if (work[j4 - 2] == 0.0) {\n+            work[j4] = 0.0;\n+            dN1  = work[j4p2 + 2];\n+            dMin = dN1;\n+            eMin = 0.0;\n+        } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&\n+                   (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {\n+            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n+            work[j4] = work[j4p2] * tmp;\n+            dN1 = dN2 * tmp;\n+        } else {\n+            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n+            dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);\n+        }\n+        dMin = Math.min(dMin, dN1);\n+\n+        dMin1 = dMin;\n+        j4 = j4 + 4;\n+        j4p2 = j4 + 2 * pingPong - 1;\n+        work[j4 - 2] = dN1 + work[j4p2];\n+        if (work[j4 - 2] == 0.0) {\n+            work[j4] = 0.0;\n+            dN   = work[j4p2 + 2];\n+            dMin = dN;\n+            eMin = 0.0;\n+        } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&\n+                   (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {\n+            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n+            work[j4] = work[j4p2] * tmp;\n+            dN = dN1 * tmp;\n+        } else {\n+            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n+            dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);\n+        }\n+        dMin = Math.min(dMin, dN);\n+\n+        work[j4 + 2] = dN;\n+        work[4 * end - pingPong - 1] = eMin;\n+\n+    }\n+\n+    /**\n+     * Compute the shift increment as an estimate of the smallest eigenvalue.\n+     * <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p>\n+     * @param start start index\n+     * @param end end index\n+     * @param deflated number of realEigenvalues just deflated\n+     */\n+    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n+\n+        final double cnst1 = 0.563;\n+        final double cnst2 = 1.010;\n+        final double cnst3 = 1.05;\n+\n+        // a negative dMin forces the shift to take that absolute value\n+        // tType records the type of shift.\n+        if (dMin <= 0.0) {\n+            tau = -dMin;\n+            tType = -1;\n+            return;\n+        }\n+\n+        int nn = 4 * end + pingPong - 1;\n+        switch (deflated) {\n+\n+        case 0 : // no realEigenvalues deflated. \n+            if (dMin == dN || dMin == dN1) {\n+\n+                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n+                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n+                double a2 = work[nn - 7] + work[nn - 5];\n+\n+                if (dMin == dN && dMin1 == dN1) {\n+                    // cases 2 and 3. \n+                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n+                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n+                    if (gap1 > 0.0 && gap1 > b1) {\n+                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n+                        tType = -2;\n+                    } else {\n+                        double s = 0.0;\n+                        if (dN > b1) {\n+                            s = dN - b1;\n+                        }\n+                        if (a2 > (b1 + b2)) {\n+                            s = Math.min(s, a2 - (b1 + b2));\n+                        }\n+                        tau   = Math.max(s, 0.333 * dMin);\n+                        tType = -3;\n+                    }\n+                } else {\n+                    // case 4.\n+                    tType = -4;\n+                    double s = 0.25 * dMin;\n+                    double gam;\n+                    int np;\n+                    if (dMin == dN) {\n+                        gam = dN;\n+                        a2 = 0.0;\n+                        if (work[nn - 5]  >  work[nn - 7]) {\n+                            return;\n+                        }\n+                        b2 = work[nn - 5] / work[nn - 7];\n+                        np = nn - 9;\n+                    } else {\n+                        np = nn - 2 * pingPong;\n+                        b2 = work[np - 2];\n+                        gam = dN1;\n+                        if (work[np - 4]  >  work[np - 2]) {\n+                            return;\n+                        }\n+                        a2 = work[np - 4] / work[np - 2];\n+                        if (work[nn - 9]  >  work[nn - 11]) {\n+                            return;\n+                        }\n+                        b2 = work[nn - 9] / work[nn - 11];\n+                        np = nn - 13;\n+                    }\n+\n+                    // approximate contribution to norm squared from i < nn-1.\n+                    a2 = a2 + b2;\n+                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n+                        if(b2 == 0.0) {\n+                            break;\n+                        }\n+                        b1 = b2;\n+                        if (work[i4]  >  work[i4 - 2]) {\n+                            return;\n+                        }\n+                        b2 = b2 * (work[i4] / work[i4 - 2]);\n+                        a2 = a2 + b2;\n+                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n+                            break;\n+                        }\n+                    }\n+                    a2 = cnst3 * a2;\n+\n+                    // rayleigh quotient residual bound.\n+                    if (a2 < cnst1) {\n+                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n+                    }\n+                    tau = s;\n+\n+                }\n+            } else if (dMin == dN2) {\n+\n+                // case 5.\n+                tType = -5;\n+                double s = 0.25 * dMin;\n+\n+                // compute contribution to norm squared from i > nn-2.\n+                final int np = nn - 2 * pingPong;\n+                double b1 = work[np - 2];\n+                double b2 = work[np - 6];\n+                final double gam = dN2;\n+                if (work[np - 8] > b2 || work[np - 4] > b1) {\n+                    return;\n+                }\n+                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n+\n+                // approximate contribution to norm squared from i < nn-2.\n+                if (end - start > 2) {\n+                    b2 = work[nn - 13] / work[nn - 15];\n+                    a2 = a2 + b2;\n+                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n+                        if (b2 == 0.0) {\n+                            break;\n+                        }\n+                        b1 = b2;\n+                        if (work[i4]  >  work[i4 - 2]) {\n+                            return;\n+                        }\n+                        b2 = b2 * (work[i4] / work[i4 - 2]);\n+                        a2 = a2 + b2;\n+                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n+                            break;\n+                        }\n+                    }\n+                    a2 = cnst3 * a2;\n+                }\n+\n+                if (a2 < cnst1) {\n+                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n+                } else {\n+                    tau = s;\n+                }\n+\n+            } else {\n+\n+                // case 6, no information to guide us.\n+                if (tType == -6) {\n+                    g += 0.333 * (1 - g);\n+                } else if (tType == -18) {\n+                    g = 0.25 * 0.333;\n+                } else {\n+                    g = 0.25;\n+                }\n+                tau   = g * dMin;\n+                tType = -6;\n+\n+            }\n+            break;\n+\n+        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n+            if (dMin1 == dN1 && dMin2 == dN2) { \n+\n+                // cases 7 and 8.\n+                tType = -7;\n+                double s = 0.333 * dMin1;\n+                if (work[nn - 5] > work[nn - 7]) {\n+                    return;\n+                }\n+                double b1 = work[nn - 5] / work[nn - 7];\n+                double b2 = b1;\n+                if (b2 != 0.0) {\n+                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n+                        final double oldB1 = b1;\n+                        if (work[i4] > work[i4 - 2]) {\n+                            return;\n+                        }\n+                        b1 = b1 * (work[i4] / work[i4 - 2]);\n+                        b2 = b2 + b1;\n+                        if (100 * Math.max(b1, oldB1) < b2) {\n+                            break;\n+                        }\n+                    }\n+                }\n+                b2 = Math.sqrt(cnst3 * b2);\n+                final double a2 = dMin1 / (1 + b2 * b2);\n+                final double gap2 = 0.5 * dMin2 - a2;\n+                if (gap2 > 0.0 && gap2 > b2 * a2) {\n+                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n+                } else {\n+                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n+                    tType = -8;\n+                }\n+            } else {\n+\n+                // case 9.\n+                tau = 0.25 * dMin1;\n+                if (dMin1 == dN1) {\n+                    tau = 0.5 * dMin1;\n+                }\n+                tType = -9;\n+            }\n+            break;\n+\n+        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n+\n+            // cases 10 and 11.\n+            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) { \n+                tType = -10;\n+                final double s = 0.333 * dMin2;\n+                if (work[nn - 5] > work[nn - 7]) {\n+                    return;\n+                }\n+                double b1 = work[nn - 5] / work[nn - 7];\n+                double b2 = b1;\n+                if (b2 != 0.0){\n+                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n+                        if (work[i4] > work[i4 - 2]) {\n+                            return;\n+                        }\n+                        b1 *= work[i4] / work[i4 - 2];\n+                        b2 += b1;\n+                        if (100 * b1 < b2) {\n+                            break;\n+                        }\n+                    }\n+                }\n+                b2 = Math.sqrt(cnst3 * b2);\n+                final double a2 = dMin2 / (1 + b2 * b2);\n+                final double gap2 = work[nn - 7] + work[nn - 9] -\n+                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n+                if (gap2 > 0.0 && gap2 > b2 * a2) {\n+                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n+                } else {\n+                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n+                }\n+            } else {\n+                tau   = 0.25 * dMin2;\n+                tType = -11;\n+            }\n+            break;\n+\n+        default : // case 12, more than two realEigenvalues deflated. no information.\n+            tau   = 0.0;\n+            tType = -12;\n+        }\n+\n+    }\n+\n+    /**\n+     * Update sigma.\n+     * @param tau shift to apply to sigma\n+     */\n+    private void updateSigma(final double tau) {\n+        // BEWARE: do NOT attempt to simplify the following statements\n+        // the expressions below take care to accumulate the part of sigma\n+        // that does not fit within a double variable into sigmaLow\n+        if (tau < sigma) {\n+            sigmaLow += tau;\n+            final double t = sigma + sigmaLow;\n+            sigmaLow -= t - sigma;\n+            sigma = t;\n+        } else {\n+            final double t = sigma + tau;\n+            sigmaLow += sigma - (t - tau);\n+            sigma = t;\n+        }\n+    }\n+\n+    /**\n+     * Find eigenvectors.\n+     */\n+    private void findEigenVectors() {\n+\n+        final int m = main.length;\n+        eigenvectors = new ArrayRealVector[m];\n+\n+        // perform an initial non-shifted LDLt decomposition\n+        final double[] d = new double[m];\n+        final double[] l = new double[m - 1];\n+        double di = main[0];\n+        d[0] = di;\n+        for (int i = 1; i < m; ++i) {\n+            final double eiM1  = secondary[i - 1];\n+            final double ratio = eiM1 / di;\n+            di       = main[i] - eiM1 * ratio;\n+            l[i - 1] = ratio;\n+            d[i]     = di;\n+        }\n+\n+        // compute eigenvectors\n+        for (int i = 0; i < m; ++i) {\n+            eigenvectors[i] = findEigenvector(realEigenvalues[i], d, l);\n+        }\n+\n+    }\n+\n+    /**\n+     * Find an eigenvector corresponding to an eigenvalue, using bidiagonals.\n+     * <p>This method corresponds to algorithm X from Dhillon's thesis.</p>\n+     * \n+     * @param eigenvalue eigenvalue for which eigenvector is desired\n+     * @param d diagonal elements of the initial non-shifted D matrix\n+     * @param l off-diagonal elements of the initial non-shifted L matrix\n+     * @return an eigenvector\n+     */\n+    private ArrayRealVector findEigenvector(final double eigenvalue,\n+                                           final double[] d, final double[] l) {\n+\n+        // compute the LDLt and UDUt decompositions of the\n+        // perfectly shifted tridiagonal matrix\n+        final int m = main.length;\n+        stationaryQuotientDifferenceWithShift(d, l, eigenvalue);\n+        progressiveQuotientDifferenceWithShift(d, l, eigenvalue);\n+\n+        // select the twist index leading to\n+        // the least diagonal element in the twisted factorization\n+        int r = m - 1;\n+        double minG = Math.abs(work[6 * r] + work[6 * r + 3] + eigenvalue);\n+        for (int i = 0, sixI = 0; i < m - 1; ++i, sixI += 6) {\n+            final double g = work[sixI] + d[i] * work[sixI + 9] / work[sixI + 10];\n+            final double absG = Math.abs(g);\n+            if (absG < minG) {\n+                r = i;\n+                minG = absG;\n+            }\n+        }\n+\n+        // solve the singular system by ignoring the equation\n+        // at twist index and propagating upwards and downwards\n+        double[] eigenvector = new double[m];\n+        double n2 = 1;\n+        eigenvector[r] = 1;\n+        double z = 1;\n+        for (int i = r - 1; i >= 0; --i) {\n+            z *= -work[6 * i + 2];\n+            eigenvector[i] = z;\n+            n2 += z * z;\n+        }\n+        z = 1;\n+        for (int i = r + 1; i < m; ++i) {\n+            z *= -work[6 * i - 1];\n+            eigenvector[i] = z;\n+            n2 += z * z;\n+        }\n+\n+        // normalize vector\n+        final double inv = 1.0 / Math.sqrt(n2);\n+        for (int i = 0; i < m; ++i) {\n+            eigenvector[i] *= inv;\n+        }\n+\n+        return (transformer == null) ?\n+               new ArrayRealVector(eigenvector, false) :\n+               new ArrayRealVector(transformer.getQ().operate(eigenvector), false);\n+\n+    }\n+\n+    /**\n+     * Decompose matrix LDL<sup>T</sup> - &lambda; I as\n+     * L<sub>+</sub>D<sub>+</sub>L<sub>+</sub><sup>T</sup>.\n+     * <p>This method corresponds to algorithm 4.4.3 (dstqds) from Dhillon's thesis.</p>\n+     * @param d diagonal elements of D,\n+     * @param l off-diagonal elements of L\n+     * @param lambda shift to apply\n+     */\n+    private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l,\n+                                                       final double lambda) {\n+        final int nM1 = d.length - 1;\n+        double si = -lambda;\n+        for (int i = 0, sixI = 0; i < nM1; ++i, sixI += 6) {\n+            final double di   = d[i];\n+            final double li   = l[i];\n+            final double diP1 = di + si;\n+            final double liP1 = li * di / diP1;\n+            work[sixI]        = si;\n+            work[sixI + 1]    = diP1;\n+            work[sixI + 2]    = liP1;\n+            si = li * liP1 * si - lambda;\n+        }\n+        work[6 * nM1 + 1] = d[nM1] + si;\n+        work[6 * nM1]     = si;\n+    }\n+\n+    /**\n+     * Decompose matrix LDL<sup>T</sup> - &lambda; I as\n+     * U<sub>-</sub>D<sub>-</sub>U<sub>-</sub><sup>T</sup>.\n+     * <p>This method corresponds to algorithm 4.4.5 (dqds) from Dhillon's thesis.</p>\n+     * @param d diagonal elements of D\n+     * @param l off-diagonal elements of L\n+     * @param lambda shift to apply\n+     */\n+    private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l,\n+                                                        final double lambda) {\n+        final int nM1 = d.length - 1;\n+        double pi = d[nM1] - lambda;\n+        for (int i = nM1 - 1, sixI = 6 * i; i >= 0; --i, sixI -= 6) {\n+            final double di   = d[i];\n+            final double li   = l[i];\n+            final double diP1 = di * li * li + pi;\n+            final double t    = di / diP1;\n+            work[sixI +  9]   = pi;\n+            work[sixI + 10]   = diP1;\n+            work[sixI +  5]   = li * t;\n+            pi = pi * t - lambda;\n+        }\n+        work[3] = pi;\n+        work[4] = pi;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/FieldDecompositionSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.FieldElement;\n+\n+\n+/**\n+ * Interface handling decomposition algorithms that can solve A &times; X = B.\n+ * <p>Decomposition algorithms decompose an A matrix has a product of several specific\n+ * matrices from which they can solve A &times; X = B in least squares sense: they find X\n+ * such that ||A &times; X - B|| is minimal.</p>\n+ * <p>Some solvers like {@link LUDecomposition} can only find the solution for\n+ * square matrices and when the solution is an exact linear solution, i.e. when\n+ * ||A &times; X - B|| is exactly 0. Other solvers can also find solutions\n+ * with non-square matrix A and with non-null minimal norm. If an exact linear\n+ * solution exists it is also the minimal norm solution.</p>\n+ *\n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface FieldDecompositionSolver<T extends FieldElement<T>> {\n+\n+    /** Solve the linear equation A &times; X = B for matrices A.\n+     * <p>The A matrix is implicit, it is provided by the underlying\n+     * decomposition algorithm.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    T[] solve(final T[] b)\n+        throws IllegalArgumentException, InvalidMatrixException;\n+\n+    /** Solve the linear equation A &times; X = B for matrices A.\n+     * <p>The A matrix is implicit, it is provided by the underlying\n+     * decomposition algorithm.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    FieldVector<T> solve(final FieldVector<T> b)\n+        throws IllegalArgumentException, InvalidMatrixException;\n+\n+    /** Solve the linear equation A &times; X = B for matrices A.\n+     * <p>The A matrix is implicit, it is provided by the underlying\n+     * decomposition algorithm.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @return a matrix X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    FieldMatrix<T> solve(final FieldMatrix<T> b)\n+        throws IllegalArgumentException, InvalidMatrixException;\n+\n+    /**\n+     * Check if the decomposed matrix is non-singular.\n+     * @return true if the decomposed matrix is non-singular\n+     */\n+    boolean isNonSingular();\n+\n+    /** Get the inverse (or pseudo-inverse) of the decomposed matrix.\n+     * @return inverse matrix\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    FieldMatrix<T> getInverse()\n+        throws InvalidMatrixException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/FieldLUDecomposition.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.FieldElement;\n+\n+/**\n+ * An interface to classes that implement an algorithm to calculate the \n+ * LU-decomposition of a real matrix.\n+ * <p>The LU-decomposition of matrix A is a set of three matrices: P, L and U\n+ * such that P&times;A = L&times;U. P is a rows permutation matrix that is used\n+ * to rearrange the rows of A before so that it can be decomposed. L is a lower\n+ * triangular matrix with unit diagonal terms and U is an upper triangular matrix.</p>\n+ * <p>This interface is based on the class with similar name from the now defunct\n+ * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library.</p>\n+ * <ul>\n+ *   <li>a {@link #getP() getP} method has been added,</li>\n+ *   <li>the <code>det</code> method has been renamed as {@link #getDeterminant()\n+ *   getDeterminant},</li>\n+ *   <li>the <code>getDoublePivot</code> method has been removed (but the int based\n+ *   {@link #getPivot() getPivot} method has been kept),</li>\n+ *   <li>the <code>solve</code> and <code>isNonSingular</code> methods have been replaced\n+ *   by a {@link #getSolver() getSolver} method and the equivalent methods provided by\n+ *   the returned {@link DecompositionSolver}.</li>\n+ * </ul>\n+ *   \n+ * @param <T> the type of the field elements\n+ * @see <a href=\"http://mathworld.wolfram.com/LUDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/LU_decomposition\">Wikipedia</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface FieldLUDecomposition<T extends FieldElement<T>> {\n+\n+    /**\n+     * Returns the matrix L of the decomposition. \n+     * <p>L is an lower-triangular matrix</p>\n+     * @return the L matrix (or null if decomposed matrix is singular)\n+     */\n+    FieldMatrix<T> getL();\n+\n+    /**\n+     * Returns the matrix U of the decomposition. \n+     * <p>U is an upper-triangular matrix</p>\n+     * @return the U matrix (or null if decomposed matrix is singular)\n+     */\n+    FieldMatrix<T> getU();\n+\n+    /**\n+     * Returns the P rows permutation matrix.\n+     * <p>P is a sparse matrix with exactly one element set to 1.0 in\n+     * each row and each column, all other elements being set to 0.0.</p>\n+     * <p>The positions of the 1 elements are given by the {@link #getPivot()\n+     * pivot permutation vector}.</p>\n+     * @return the P rows permutation matrix (or null if decomposed matrix is singular)\n+     * @see #getPivot()\n+     */\n+    FieldMatrix<T> getP();\n+\n+    /**\n+     * Returns the pivot permutation vector.\n+     * @return the pivot permutation vector\n+     * @see #getP()\n+     */\n+    int[] getPivot();\n+\n+    /**\n+     * Return the determinant of the matrix\n+     * @return determinant of the matrix\n+     */\n+    T getDeterminant();\n+\n+    /**\n+     * Get a solver for finding the A &times; X = B solution in exact linear sense.\n+     * @return a solver\n+     */\n+    FieldDecompositionSolver<T> getSolver();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.lang.reflect.Array;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Calculates the LUP-decomposition of a square matrix.\n+ * <p>The LUP-decomposition of a matrix A consists of three matrices\n+ * L, U and P that satisfy: PA = LU, L is lower triangular, and U is\n+ * upper triangular and P is a permutation matrix. All matrices are\n+ * m&times;m.</p>\n+ * <p>Since {@link FieldElement field elements} do not provide an ordering\n+ * operator, the permutation matrix is computed here only in order to avoid\n+ * a zero pivot element, no attempt is done to get the largest pivot element.</p>\n+ *\n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class FieldLUDecompositionImpl<T extends FieldElement<T>> implements FieldLUDecomposition<T> {\n+\n+    /** Field to which the elements belong. */\n+    private final Field<T> field;\n+\n+    /** Entries of LU decomposition. */\n+    private T lu[][];\n+\n+    /** Pivot permutation associated with LU decomposition */\n+    private int[] pivot;\n+\n+    /** Parity of the permutation associated with the LU decomposition */\n+    private boolean even;\n+\n+    /** Singularity indicator. */\n+    private boolean singular;\n+\n+    /** Cached value of L. */\n+    private FieldMatrix<T> cachedL;\n+\n+    /** Cached value of U. */\n+    private FieldMatrix<T> cachedU;\n+\n+    /** Cached value of P. */\n+    private FieldMatrix<T> cachedP;\n+\n+    /**\n+     * Calculates the LU-decomposition of the given matrix. \n+     * @param matrix The matrix to decompose.\n+     * @exception NonSquareMatrixException if matrix is not square\n+     */\n+    public FieldLUDecompositionImpl(FieldMatrix<T> matrix)\n+        throws NonSquareMatrixException {\n+\n+        if (!matrix.isSquare()) {\n+            throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n+        }\n+\n+        final int m = matrix.getColumnDimension();\n+        field = matrix.getField();\n+        lu = matrix.getData();\n+        pivot = new int[m];\n+        cachedL = null;\n+        cachedU = null;\n+        cachedP = null;\n+\n+        // Initialize permutation array and parity\n+        for (int row = 0; row < m; row++) {\n+            pivot[row] = row;\n+        }\n+        even     = true;\n+        singular = false;\n+\n+        // Loop over columns\n+        for (int col = 0; col < m; col++) {\n+\n+            T sum = field.getZero();\n+\n+            // upper\n+            for (int row = 0; row < col; row++) {\n+                final T[] luRow = lu[row];\n+                sum = luRow[col];\n+                for (int i = 0; i < row; i++) {\n+                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n+                }\n+                luRow[col] = sum;\n+            }\n+\n+            // lower\n+            int nonZero = col; // permutation row\n+            for (int row = col; row < m; row++) {\n+                final T[] luRow = lu[row];\n+                sum = luRow[col];\n+                for (int i = 0; i < col; i++) {\n+                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n+                }\n+                luRow[col] = sum;\n+\n+                if (lu[nonZero][col].equals(field.getZero())) {\n+                    // try to select a better permutation choice\n+                    ++nonZero;\n+                }\n+            }\n+\n+            // Singularity check\n+            if (nonZero >= m) {\n+                singular = true;\n+                return;\n+            }\n+\n+            // Pivot if necessary\n+            if (nonZero != col) {\n+                T tmp = field.getZero();\n+                for (int i = 0; i < m; i++) {\n+                    tmp = lu[nonZero][i];\n+                    lu[nonZero][i] = lu[col][i];\n+                    lu[col][i] = tmp;\n+                }\n+                int temp = pivot[nonZero];\n+                pivot[nonZero] = pivot[col];\n+                pivot[col] = temp;\n+                even = !even;\n+            }\n+\n+            // Divide the lower elements by the \"winning\" diagonal elt.\n+            final T luDiag = lu[col][col];\n+            for (int row = col + 1; row < m; row++) {\n+                final T[] luRow = lu[row];\n+                luRow[col] = luRow[col].divide(luDiag);\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> getL() {\n+        if ((cachedL == null) && !singular) {\n+            final int m = pivot.length;\n+            cachedL = new Array2DRowFieldMatrix<T>(field, m, m);\n+            for (int i = 0; i < m; ++i) {\n+                final T[] luI = lu[i];\n+                for (int j = 0; j < i; ++j) {\n+                    cachedL.setEntry(i, j, luI[j]);\n+                }\n+                cachedL.setEntry(i, i, field.getOne());\n+            }\n+        }\n+        return cachedL;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> getU() {\n+        if ((cachedU == null) && !singular) {\n+            final int m = pivot.length;\n+            cachedU = new Array2DRowFieldMatrix<T>(field, m, m);\n+            for (int i = 0; i < m; ++i) {\n+                final T[] luI = lu[i];\n+                for (int j = i; j < m; ++j) {\n+                    cachedU.setEntry(i, j, luI[j]);\n+                }\n+            }\n+        }\n+        return cachedU;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> getP() {\n+        if ((cachedP == null) && !singular) {\n+            final int m = pivot.length;\n+            cachedP = new Array2DRowFieldMatrix<T>(field, m, m);\n+            for (int i = 0; i < m; ++i) {\n+                cachedP.setEntry(i, pivot[i], field.getOne());\n+            }\n+        }\n+        return cachedP;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int[] getPivot() {\n+        return pivot.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T getDeterminant() {\n+        if (singular) {\n+            return field.getZero();\n+        } else {\n+            final int m = pivot.length;\n+            T determinant = even ? field.getOne() : field.getZero().subtract(field.getOne());\n+            for (int i = 0; i < m; i++) {\n+                determinant = determinant.multiply(lu[i][i]);\n+            }\n+            return determinant;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldDecompositionSolver<T> getSolver() {\n+        return new Solver<T>(field, lu, pivot, singular);\n+    }\n+\n+    /** Specialized solver. */\n+    private static class Solver<T extends FieldElement<T>> implements FieldDecompositionSolver<T> {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = -6353105415121373022L;\n+\n+        /** Field to which the elements belong. */\n+        private final Field<T> field;\n+\n+        /** Entries of LU decomposition. */\n+        private final T lu[][];\n+\n+        /** Pivot permutation associated with LU decomposition. */\n+        private final int[] pivot;\n+\n+        /** Singularity indicator. */\n+        private final boolean singular;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         * @param field field to which the matrix elements belong\n+         * @param lu entries of LU decomposition\n+         * @param pivot pivot permutation associated with LU decomposition\n+         * @param singular singularity indicator\n+         */\n+        private Solver(final Field<T> field, final T[][] lu,\n+                       final int[] pivot, final boolean singular) {\n+            this.field    = field;\n+            this.lu       = lu;\n+            this.pivot    = pivot;\n+            this.singular = singular;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean isNonSingular() {\n+            return !singular;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @SuppressWarnings(\"unchecked\")\n+        public T[] solve(T[] b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            final int m = pivot.length;\n+            if (b.length != m) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"vector length mismatch: got {0} but expected {1}\",\n+                        b.length, m);\n+            }\n+            if (singular) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final T[] bp = (T[]) Array.newInstance(field.getZero().getClass(), m);\n+\n+            // Apply permutations to b\n+            for (int row = 0; row < m; row++) {\n+                bp[row] = b[pivot[row]];\n+            }\n+\n+            // Solve LY = b\n+            for (int col = 0; col < m; col++) {\n+                final T bpCol = bp[col];\n+                for (int i = col + 1; i < m; i++) {\n+                    bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));\n+                }\n+            }\n+\n+            // Solve UX = Y\n+            for (int col = m - 1; col >= 0; col--) {\n+                bp[col] = bp[col].divide(lu[col][col]);\n+                final T bpCol = bp[col];\n+                for (int i = 0; i < col; i++) {\n+                    bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));\n+                }\n+            }\n+\n+            return bp;\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        @SuppressWarnings(\"unchecked\")\n+        public FieldVector<T> solve(FieldVector<T> b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+            try {\n+                return solve((ArrayFieldVector<T>) b);\n+            } catch (ClassCastException cce) {\n+\n+                final int m = pivot.length;\n+                if (b.getDimension() != m) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"vector length mismatch: got {0} but expected {1}\",\n+                            b.getDimension(), m);\n+                }\n+                if (singular) {\n+                    throw new SingularMatrixException();\n+                }\n+\n+                final T[] bp = (T[]) Array.newInstance(field.getZero().getClass(), m);\n+\n+                // Apply permutations to b\n+                for (int row = 0; row < m; row++) {\n+                    bp[row] = b.getEntry(pivot[row]);\n+                }\n+\n+                // Solve LY = b\n+                for (int col = 0; col < m; col++) {\n+                    final T bpCol = bp[col];\n+                    for (int i = col + 1; i < m; i++) {\n+                        bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));\n+                    }\n+                }\n+\n+                // Solve UX = Y\n+                for (int col = m - 1; col >= 0; col--) {\n+                    bp[col] = bp[col].divide(lu[col][col]);\n+                    final T bpCol = bp[col];\n+                    for (int i = 0; i < col; i++) {\n+                        bp[i] = bp[i].subtract(bpCol.multiply(lu[i][col]));\n+                    }\n+                }\n+\n+                return new ArrayFieldVector<T>(bp, false);\n+\n+            }\n+        }\n+\n+        /** Solve the linear equation A &times; X = B.\n+         * <p>The A matrix is implicit here. It is </p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a vector X such that A &times; X = B\n+         * @exception IllegalArgumentException if matrices dimensions don't match\n+         * @exception InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public ArrayFieldVector<T> solve(ArrayFieldVector<T> b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+            return new ArrayFieldVector<T>(solve(b.getDataRef()), false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @SuppressWarnings(\"unchecked\")\n+        public FieldMatrix<T> solve(FieldMatrix<T> b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            final int m = pivot.length;\n+            if (b.getRowDimension() != m) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n+            }\n+            if (singular) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final int nColB = b.getColumnDimension();\n+\n+            // Apply permutations to b\n+            final T[][] bp = (T[][]) Array.newInstance(field.getZero().getClass(), new int[] { m, nColB });\n+            for (int row = 0; row < m; row++) {\n+                final T[] bpRow = bp[row];\n+                final int pRow = pivot[row];\n+                for (int col = 0; col < nColB; col++) {\n+                    bpRow[col] = b.getEntry(pRow, col);\n+                }\n+            }\n+\n+            // Solve LY = b\n+            for (int col = 0; col < m; col++) {\n+                final T[] bpCol = bp[col];\n+                for (int i = col + 1; i < m; i++) {\n+                    final T[] bpI = bp[i];\n+                    final T luICol = lu[i][col];\n+                    for (int j = 0; j < nColB; j++) {\n+                        bpI[j] = bpI[j].subtract(bpCol[j].multiply(luICol));\n+                    }\n+                }\n+            }\n+\n+            // Solve UX = Y\n+            for (int col = m - 1; col >= 0; col--) {\n+                final T[] bpCol = bp[col];\n+                final T luDiag = lu[col][col];\n+                for (int j = 0; j < nColB; j++) {\n+                    bpCol[j] = bpCol[j].divide(luDiag);\n+                }\n+                for (int i = 0; i < col; i++) {\n+                    final T[] bpI = bp[i];\n+                    final T luICol = lu[i][col];\n+                    for (int j = 0; j < nColB; j++) {\n+                        bpI[j] = bpI[j].subtract(bpCol[j].multiply(luICol));\n+                    }\n+                }\n+            }\n+\n+            return new Array2DRowFieldMatrix<T>(bp, false);\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public FieldMatrix<T> getInverse() throws InvalidMatrixException {\n+            final int m = pivot.length;\n+            final T one = field.getOne();\n+            FieldMatrix<T> identity = new Array2DRowFieldMatrix<T>(field, m, m);\n+            for (int i = 0; i < m; ++i) {\n+                identity.setEntry(i, i, one);\n+            }\n+            return solve(identity);\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+\n+/**\n+ * Interface defining field-valued matrix with basic algebraic operations.\n+ * <p>\n+ * Matrix element indexing is 0-based -- e.g., <code>getEntry(0, 0)</code>\n+ * returns the element in the first row, first column of the matrix.</p>\n+ * \n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ */\n+public interface FieldMatrix<T extends FieldElement<T>> extends AnyMatrix {\n+\n+    /**\n+     * Get the type of field elements of the matrix.\n+     * @return type of field elements of the matrix\n+     */\n+    Field<T> getField();\n+\n+    /**\n+     * Create a new FieldMatrix<T> of the same type as the instance with the supplied\n+     * row and column dimensions.\n+     *\n+     * @param rowDimension  the number of rows in the new matrix\n+     * @param columnDimension  the number of columns in the new matrix\n+     * @return a new matrix of the same type as the instance\n+     * @throws IllegalArgumentException if row or column dimension is not positive\n+     * @since 2.0\n+     */\n+    FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension);\n+\n+    /**\n+     * Returns a (deep) copy of this.\n+     *\n+     * @return matrix copy\n+     */\n+    FieldMatrix<T> copy();\n+\n+    /**\n+     * Compute the sum of this and m.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    FieldMatrix<T> add(FieldMatrix<T> m) throws IllegalArgumentException;\n+\n+    /**\n+     * Compute this minus m.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    FieldMatrix<T> subtract(FieldMatrix<T> m) throws IllegalArgumentException;\n+\n+     /**\n+     * Returns the result of adding d to each entry of this.\n+     *\n+     * @param d    value to be added to each entry\n+     * @return     d + this\n+     */\n+    FieldMatrix<T> scalarAdd(T d);\n+\n+    /**\n+     * Returns the result multiplying each entry of this by d.\n+     *\n+     * @param d    value to multiply all entries by\n+     * @return     d * this\n+     */\n+    FieldMatrix<T> scalarMultiply(T d);\n+\n+    /**\n+     * Returns the result of postmultiplying this by m.\n+     *\n+     * @param m    matrix to postmultiply by\n+     * @return     this * m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    FieldMatrix<T> multiply(FieldMatrix<T> m) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the result premultiplying this by <code>m</code>.\n+     * @param m    matrix to premultiply by\n+     * @return     m * this\n+     * @throws     IllegalArgumentException\n+     *             if rowDimension(this) != columnDimension(m)\n+     */\n+    public FieldMatrix<T> preMultiply(FieldMatrix<T> m) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns matrix entries as a two-dimensional array.\n+     *\n+     * @return    2-dimensional array of entries\n+     */\n+    T[][] getData();\n+\n+    /**\n+     * Gets a submatrix. Rows and columns are indicated\n+     * counting from 0 to n-1.\n+     *\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     * @return The subMatrix containing the data of the\n+     *         specified rows and columns\n+     * @exception MatrixIndexException  if the indices are not valid\n+     */\n+   FieldMatrix<T> getSubMatrix(int startRow, int endRow, int startColumn, int endColumn)\n+       throws MatrixIndexException;\n+   \n+   /**\n+    * Gets a submatrix. Rows and columns are indicated\n+    * counting from 0 to n-1.\n+    *\n+    * @param selectedRows Array of row indices.\n+    * @param selectedColumns Array of column indices.\n+    * @return The subMatrix containing the data in the\n+    *         specified rows and columns\n+    * @exception MatrixIndexException if row or column selections are not valid\n+    */\n+   FieldMatrix<T> getSubMatrix(int[] selectedRows, int[] selectedColumns)\n+       throws MatrixIndexException;\n+\n+   /**\n+    * Copy a submatrix. Rows and columns are indicated\n+    * counting from 0 to n-1.\n+    *\n+    * @param startRow Initial row index\n+    * @param endRow Final row index (inclusive)\n+    * @param startColumn Initial column index\n+    * @param endColumn Final column index (inclusive)\n+    * @param destination The arrays where the submatrix data should be copied\n+    * (if larger than rows/columns counts, only the upper-left part will be used)\n+    * @exception MatrixIndexException if the indices are not valid\n+    * @exception IllegalArgumentException if the destination array is too small\n+    */\n+  void copySubMatrix(int startRow, int endRow, int startColumn, int endColumn,\n+                     T[][] destination)\n+      throws MatrixIndexException, IllegalArgumentException;\n+  \n+  /**\n+   * Copy a submatrix. Rows and columns are indicated\n+   * counting from 0 to n-1.\n+   *\n+    * @param selectedRows Array of row indices.\n+    * @param selectedColumns Array of column indices.\n+   * @param destination The arrays where the submatrix data should be copied\n+   * (if larger than rows/columns counts, only the upper-left part will be used)\n+   * @exception MatrixIndexException if the indices are not valid\n+   * @exception IllegalArgumentException if the destination array is too small\n+   */\n+  void copySubMatrix(int[] selectedRows, int[] selectedColumns, T[][] destination)\n+      throws MatrixIndexException, IllegalArgumentException;\n+ \n+   /**\n+    * Replace the submatrix starting at <code>row, column</code> using data in\n+    * the input <code>subMatrix</code> array. Indexes are 0-based.\n+    * <p> \n+    * Example:<br>\n+    * Starting with <pre>\n+    * 1  2  3  4\n+    * 5  6  7  8\n+    * 9  0  1  2\n+    * </pre>\n+    * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking \n+    * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>\n+    * 1  2  3  4\n+    * 5  3  4  8\n+    * 9  5  6  2\n+    * </pre></p>\n+    * \n+    * @param subMatrix  array containing the submatrix replacement data\n+    * @param row  row coordinate of the top, left element to be replaced\n+    * @param column  column coordinate of the top, left element to be replaced\n+    * @throws MatrixIndexException  if subMatrix does not fit into this \n+    *    matrix from element in (row, column) \n+    * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular\n+    *  (not all rows have the same length) or empty\n+    * @throws NullPointerException if <code>subMatrix</code> is null\n+    * @since 2.0\n+    */\n+   void setSubMatrix(T[][] subMatrix, int row, int column) \n+       throws MatrixIndexException;\n+\n+   /**\n+    * Returns the entries in row number <code>row</code>\n+    * as a row matrix.  Row indices start at 0.\n+    *\n+    * @param row the row to be fetched\n+    * @return row matrix\n+    * @throws MatrixIndexException if the specified row index is invalid\n+    */\n+   FieldMatrix<T> getRowMatrix(int row) throws MatrixIndexException;\n+   \n+   /**\n+    * Sets the entries in row number <code>row</code>\n+    * as a row matrix.  Row indices start at 0.\n+    *\n+    * @param row the row to be set\n+    * @param matrix row matrix (must have one row and the same number of columns\n+    * as the instance)\n+    * @throws MatrixIndexException if the specified row index is invalid\n+    * @throws InvalidMatrixException if the matrix dimensions do not match one\n+    * instance row\n+    */\n+   void setRowMatrix(int row, FieldMatrix<T> matrix)\n+       throws MatrixIndexException, InvalidMatrixException;\n+   \n+   /**\n+    * Returns the entries in column number <code>column</code>\n+    * as a column matrix.  Column indices start at 0.\n+    *\n+    * @param column the column to be fetched\n+    * @return column matrix\n+    * @throws MatrixIndexException if the specified column index is invalid\n+    */\n+   FieldMatrix<T> getColumnMatrix(int column) throws MatrixIndexException;\n+\n+   /**\n+    * Sets the entries in column number <code>column</code>\n+    * as a column matrix.  Column indices start at 0.\n+    *\n+    * @param column the column to be set\n+    * @param matrix column matrix (must have one column and the same number of rows\n+    * as the instance)\n+    * @throws MatrixIndexException if the specified column index is invalid\n+    * @throws InvalidMatrixException if the matrix dimensions do not match one\n+    * instance column\n+    */\n+   void setColumnMatrix(int column, FieldMatrix<T> matrix)\n+       throws MatrixIndexException, InvalidMatrixException;\n+   \n+   /**\n+    * Returns the entries in row number <code>row</code>\n+    * as a vector.  Row indices start at 0.\n+    *\n+    * @param row the row to be fetched\n+    * @return row vector\n+    * @throws MatrixIndexException if the specified row index is invalid\n+    */\n+   FieldVector<T> getRowVector(int row) throws MatrixIndexException;\n+\n+   /**\n+    * Sets the entries in row number <code>row</code>\n+    * as a vector.  Row indices start at 0.\n+    *\n+    * @param row the row to be set\n+    * @param vector row vector (must have the same number of columns\n+    * as the instance)\n+    * @throws MatrixIndexException if the specified row index is invalid\n+    * @throws InvalidMatrixException if the vector dimension does not match one\n+    * instance row\n+    */\n+   void setRowVector(int row, FieldVector<T> vector)\n+       throws MatrixIndexException, InvalidMatrixException;\n+   \n+   /**\n+    * Returns the entries in column number <code>column</code>\n+    * as a vector.  Column indices start at 0.\n+    *\n+    * @param column the column to be fetched\n+    * @return column vector\n+    * @throws MatrixIndexException if the specified column index is invalid\n+    */\n+   FieldVector<T> getColumnVector(int column) throws MatrixIndexException;\n+\n+   /**\n+    * Sets the entries in column number <code>column</code>\n+    * as a vector.  Column indices start at 0.\n+    *\n+    * @param column the column to be set\n+    * @param vector column vector (must have the same number of rows as the instance)\n+    * @throws MatrixIndexException if the specified column index is invalid\n+    * @throws InvalidMatrixException if the vector dimension does not match one\n+    * instance column\n+    */\n+   void setColumnVector(int column, FieldVector<T> vector)\n+       throws MatrixIndexException, InvalidMatrixException;\n+   \n+    /**\n+     * Returns the entries in row number <code>row</code> as an array.\n+     * <p>\n+     * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown\n+     * unless <code>0 <= row < rowDimension.</code></p>\n+     *\n+     * @param row the row to be fetched\n+     * @return array of entries in the row\n+     * @throws MatrixIndexException if the specified row index is not valid\n+     */\n+    T[] getRow(int row) throws MatrixIndexException;\n+\n+    /**\n+     * Sets the entries in row number <code>row</code>\n+     * as a row matrix.  Row indices start at 0.\n+     *\n+     * @param row the row to be set\n+     * @param array row matrix (must have the same number of columns as the instance)\n+     * @throws MatrixIndexException if the specified row index is invalid\n+     * @throws InvalidMatrixException if the array size does not match one\n+     * instance row\n+     */\n+    void setRow(int row, T[] array)\n+        throws MatrixIndexException, InvalidMatrixException;\n+    \n+    /**\n+     * Returns the entries in column number <code>col</code> as an array.\n+     * <p>\n+     * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown\n+     * unless <code>0 <= column < columnDimension.</code></p>\n+     *\n+     * @param column the column to be fetched\n+     * @return array of entries in the column\n+     * @throws MatrixIndexException if the specified column index is not valid\n+     */\n+    T[] getColumn(int column) throws MatrixIndexException;\n+\n+    /**\n+     * Sets the entries in column number <code>column</code>\n+     * as a column matrix.  Column indices start at 0.\n+     *\n+     * @param column the column to be set\n+     * @param array column array (must have the same number of rows as the instance)\n+     * @throws MatrixIndexException if the specified column index is invalid\n+     * @throws InvalidMatrixException if the array size does not match one\n+     * instance column\n+     */\n+    void setColumn(int column, T[] array)\n+        throws MatrixIndexException, InvalidMatrixException;\n+    \n+    /**\n+     * Returns the entry in the specified row and column.\n+     * <p>\n+     * Row and column indices start at 0 and must satisfy \n+     * <ul>\n+     * <li><code>0 <= row < rowDimension</code></li>\n+     * <li><code> 0 <= column < columnDimension</code></li>\n+     * </ul>\n+     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n+     * \n+     * @param row  row location of entry to be fetched\n+     * @param column  column location of entry to be fetched\n+     * @return matrix entry in row,column\n+     * @throws MatrixIndexException if the row or column index is not valid\n+     */\n+    T getEntry(int row, int column) throws MatrixIndexException;\n+\n+    /**\n+     * Set the entry in the specified row and column.\n+     * <p>\n+     * Row and column indices start at 0 and must satisfy \n+     * <ul>\n+     * <li><code>0 <= row < rowDimension</code></li>\n+     * <li><code> 0 <= column < columnDimension</code></li>\n+     * </ul>\n+     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n+     * \n+     * @param row  row location of entry to be set\n+     * @param column  column location of entry to be set\n+     * @param value matrix entry to be set in row,column\n+     * @throws MatrixIndexException if the row or column index is not valid\n+     * @since 2.0\n+     */\n+    void setEntry(int row, int column, T value) throws MatrixIndexException;\n+\n+    /**\n+     * Change an entry in the specified row and column.\n+     * <p>\n+     * Row and column indices start at 0 and must satisfy \n+     * <ul>\n+     * <li><code>0 <= row < rowDimension</code></li>\n+     * <li><code> 0 <= column < columnDimension</code></li>\n+     * </ul>\n+     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n+     * \n+     * @param row  row location of entry to be set\n+     * @param column  column location of entry to be set\n+     * @param increment value to add to the current matrix entry in row,column\n+     * @throws MatrixIndexException if the row or column index is not valid\n+     * @since 2.0\n+     */\n+    void addToEntry(int row, int column, T increment) throws MatrixIndexException;\n+\n+    /**\n+     * Change an entry in the specified row and column.\n+     * <p>\n+     * Row and column indices start at 0 and must satisfy \n+     * <ul>\n+     * <li><code>0 <= row < rowDimension</code></li>\n+     * <li><code> 0 <= column < columnDimension</code></li>\n+     * </ul>\n+     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n+     * \n+     * @param row  row location of entry to be set\n+     * @param column  column location of entry to be set\n+     * @param factor multiplication factor for the current matrix entry in row,column\n+     * @throws MatrixIndexException if the row or column index is not valid\n+     * @since 2.0\n+     */\n+    void multiplyEntry(int row, int column, T factor) throws MatrixIndexException;\n+\n+    /**\n+     * Returns the transpose of this matrix.\n+     *\n+     * @return transpose matrix\n+     */\n+    FieldMatrix<T> transpose();\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/MatrixTrace.html\">\n+     * trace</a> of the matrix (the sum of the elements on the main diagonal).\n+     *\n+     * @return trace\n+     * @throws NonSquareMatrixException if the matrix is not square\n+     */\n+    T getTrace() throws NonSquareMatrixException;\n+\n+    /**\n+     * Returns the result of multiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the vector to operate on\n+     * @return this*v\n+     * @throws IllegalArgumentException if columnDimension != v.size()\n+     */\n+    T[] operate(T[] v) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the result of multiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the vector to operate on\n+     * @return this*v\n+     * @throws IllegalArgumentException if columnDimension != v.size()\n+     */\n+    FieldVector<T> operate(FieldVector<T> v) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the row vector to premultiply by\n+     * @return v*this\n+     * @throws IllegalArgumentException if rowDimension != v.size()\n+     */\n+    T[] preMultiply(T[] v) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the row vector to premultiply by\n+     * @return v*this\n+     * @throws IllegalArgumentException if rowDimension != v.size()\n+     */\n+    FieldVector<T> preMultiply(FieldVector<T> v) throws IllegalArgumentException;\n+\n+    /**\n+     * Visit (and possibly change) all matrix entries in row order.\n+     * <p>Row order starts at upper left and iterating through all elements\n+     * of a row from left to right before going to the leftmost element\n+     * of the next row.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInRowOrder(FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) all matrix entries in row order.\n+     * <p>Row order starts at upper left and iterating through all elements\n+     * of a row from left to right before going to the leftmost element\n+     * of the next row.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInRowOrder(FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) some matrix entries in row order.\n+     * <p>Row order starts at upper left and iterating through all elements\n+     * of a row from left to right before going to the leftmost element\n+     * of the next row.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInRowOrder(FieldMatrixChangingVisitor<T> visitor,\n+                          int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) some matrix entries in row order.\n+     * <p>Row order starts at upper left and iterating through all elements\n+     * of a row from left to right before going to the leftmost element\n+     * of the next row.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInRowOrder(FieldMatrixPreservingVisitor<T> visitor,\n+                          int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) all matrix entries in column order.\n+     * <p>Column order starts at upper left and iterating through all elements\n+     * of a column from top to bottom before going to the topmost element\n+     * of the next column.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInColumnOrder(FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) all matrix entries in column order.\n+     * <p>Column order starts at upper left and iterating through all elements\n+     * of a column from top to bottom before going to the topmost element\n+     * of the next column.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInColumnOrder(FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) some matrix entries in column order.\n+     * <p>Column order starts at upper left and iterating through all elements\n+     * of a column from top to bottom before going to the topmost element\n+     * of the next column.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInColumnOrder(FieldMatrixChangingVisitor<T> visitor,\n+                             int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) some matrix entries in column order.\n+     * <p>Column order starts at upper left and iterating through all elements\n+     * of a column from top to bottom before going to the topmost element\n+     * of the next column.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInColumnOrder(FieldMatrixPreservingVisitor<T> visitor,\n+                             int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) all matrix entries using the fastest possible order.\n+     * <p>The fastest walking order depends on the exact matrix class. It may be\n+     * different from traditional row or column orders.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInOptimizedOrder(FieldMatrixChangingVisitor<T> visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) all matrix entries using the fastest possible order.\n+     * <p>The fastest walking order depends on the exact matrix class. It may be\n+     * different from traditional row or column orders.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInOptimizedOrder(FieldMatrixPreservingVisitor<T> visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) some matrix entries using the fastest possible order.\n+     * <p>The fastest walking order depends on the exact matrix class. It may be\n+     * different from traditional row or column orders.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInOptimizedOrder(FieldMatrixChangingVisitor<T> visitor,\n+                                int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) some matrix entries using the fastest possible order.\n+     * <p>The fastest walking order depends on the exact matrix class. It may be\n+     * different from traditional row or column orders.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(FieldMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(FieldMatrixChangingVisitor, int, int, int, int)\n+     * @return the value returned by {@link FieldMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    T walkInOptimizedOrder(FieldMatrixPreservingVisitor<T> visitor,\n+                                int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrixChangingVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.FieldElement;\n+\n+/**\n+ * Interface defining a visitor for matrix entries.\n+ * \n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface FieldMatrixChangingVisitor<T extends FieldElement<?>> {\n+\n+    /**\n+     * Start visiting a matrix.\n+     * <p>This method is called once before any entry of the matrix is visited.</p>\n+     * @param rows number of rows of the matrix\n+     * @param columns number of columns of the matrix\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     */\n+    void start(int rows, int columns,\n+               int startRow, int endRow, int startColumn, int endColumn);\n+\n+    /**\n+     * Visit one matrix entry.\n+     * @param row row index of the entry\n+     * @param column column index of the entry\n+     * @param value current value of the entry\n+     * @return the new value to be set for the entry\n+     * @throws MatrixVisitorException if something wrong occurs\n+     */\n+    T visit(int row, int column, T value)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * End visiting a matrix.\n+     * <p>This method is called once after all entries of the matrix have been visited.</p>\n+     * @return the value that the <code>walkInXxxOrder</code> must return\n+     */\n+    T end();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/FieldMatrixPreservingVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.FieldElement;\n+\n+/**\n+ * Interface defining a visitor for matrix entries.\n+ * \n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface FieldMatrixPreservingVisitor<T extends FieldElement<?>> {\n+\n+    /**\n+     * Start visiting a matrix.\n+     * <p>This method is called once before any entry of the matrix is visited.</p>\n+     * @param rows number of rows of the matrix\n+     * @param columns number of columns of the matrix\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     */\n+    void start(int rows, int columns,\n+               int startRow, int endRow, int startColumn, int endColumn);\n+\n+    /**\n+     * Visit one matrix entry.\n+     * @param row row index of the entry\n+     * @param column column index of the entry\n+     * @param value current value of the entry\n+     * @throws MatrixVisitorException if something wrong occurs\n+     */\n+    void visit(int row, int column, T value)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * End visiting a matrix.\n+     * <p>This method is called once after all entries of the matrix have been visited.</p>\n+     * @return the value that the <code>walkInXxxOrder</code> must return\n+     */\n+    T end();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/FieldVector.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+\n+/**\n+ * Interface defining a field-valued vector with basic algebraic operations.\n+ * <p>\n+ * vector element indexing is 0-based -- e.g., <code>getEntry(0)</code>\n+ * returns the first element of the vector.\n+ * </p>\n+ * <p>\n+ * The various <code>mapXxx</code> and <code>mapXxxToSelf</code> methods operate\n+ * on vectors element-wise, i.e. they perform the same operation (adding a scalar,\n+ * applying a function ...) on each element in turn. The <code>mapXxx</code>\n+ * versions create a new vector to hold the result and do not change the instance.\n+ * The <code>mapXxxToSelf</code> versions use the instance itself to store the\n+ * results, so the instance is changed by these methods. In both cases, the result\n+ * vector is returned by the methods, this allows to use the <i>fluent API</i>\n+ * style, like this:\n+ * </p>\n+ * <pre>\n+ *   RealVector result = v.mapAddToSelf(3.0).mapTanToSelf().mapSquareToSelf();\n+ * </pre>\n+ * \n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface FieldVector<T extends FieldElement<T>>  {\n+\n+    /**\n+     * Get the type of field elements of the vector.\n+     * @return type of field elements of the vector\n+     */\n+    Field<T> getField();\n+\n+    /**\n+     * Returns a (deep) copy of this.\n+     * @return vector copy\n+     */\n+    FieldVector<T> copy();\n+\n+    /**\n+     * Compute the sum of this and v.\n+     * @param v vector to be added\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    FieldVector<T> add(FieldVector<T> v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute the sum of this and v.\n+     * @param v vector to be added\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    FieldVector<T> add(T[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute this minus v.\n+     * @param v vector to be subtracted\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    FieldVector<T> subtract(FieldVector<T> v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute this minus v.\n+     * @param v vector to be subtracted\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    FieldVector<T> subtract(T[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Map an addition operation to each entry.\n+     * @param d value to be added to each entry\n+     * @return this + d\n+     */\n+    FieldVector<T> mapAdd(T d);\n+\n+    /**\n+     * Map an addition operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to be added to each entry\n+     * @return for convenience, return this\n+     */\n+    FieldVector<T> mapAddToSelf(T d);\n+\n+    /**\n+     * Map a subtraction operation to each entry.\n+     * @param d value to be subtracted to each entry\n+     * @return this - d\n+     */\n+    FieldVector<T> mapSubtract(T d);\n+\n+    /**\n+     * Map a subtraction operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to be subtracted to each entry\n+     * @return for convenience, return this\n+     */\n+    FieldVector<T> mapSubtractToSelf(T d);\n+\n+    /**\n+     * Map a multiplication operation to each entry.\n+     * @param d value to multiply all entries by\n+     * @return this * d\n+     */\n+    FieldVector<T> mapMultiply(T d);\n+\n+    /**\n+     * Map a multiplication operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to multiply all entries by\n+     * @return for convenience, return this\n+     */\n+    FieldVector<T> mapMultiplyToSelf(T d);\n+\n+    /**\n+     * Map a division operation to each entry.\n+     * @param d value to divide all entries by\n+     * @return this / d\n+     */\n+    FieldVector<T> mapDivide(T d);\n+\n+    /**\n+     * Map a division operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to divide all entries by\n+     * @return for convenience, return this\n+     */\n+    FieldVector<T> mapDivideToSelf(T d);\n+\n+    /**\n+     * Map the 1/x function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    FieldVector<T> mapInv();\n+\n+    /**\n+     * Map the 1/x function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    FieldVector<T> mapInvToSelf();\n+\n+    /**\n+     * Element-by-element multiplication.\n+     * @param v vector by which instance elements must be multiplied\n+     * @return a vector containing this[i] * v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public FieldVector<T> ebeMultiply(FieldVector<T> v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Element-by-element multiplication.\n+     * @param v vector by which instance elements must be multiplied\n+     * @return a vector containing this[i] * v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public FieldVector<T> ebeMultiply(T[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Element-by-element division.\n+     * @param v vector by which instance elements must be divided\n+     * @return a vector containing this[i] / v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public FieldVector<T> ebeDivide(FieldVector<T> v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Element-by-element division.\n+     * @param v vector by which instance elements must be divided\n+     * @return a vector containing this[i] / v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public FieldVector<T> ebeDivide(T[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Returns vector entries as a T array.\n+     * @return T array of entries\n+     */\n+     T[] getData();\n+\n+    /**\n+     * Compute the dot product.\n+     * @param v vector with which dot product should be computed\n+     * @return the scalar dot product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    T dotProduct(FieldVector<T> v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute the dot product.\n+     * @param v vector with which dot product should be computed\n+     * @return the scalar dot product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    T dotProduct(T[] v)\n+        throws IllegalArgumentException;\n+\n+    /** Find the orthogonal projection of this vector onto another vector.\n+     * @param v vector onto which instance must be projected\n+     * @return projection of the instance onto v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    FieldVector<T> projection(FieldVector<T> v)\n+        throws IllegalArgumentException;\n+\n+    /** Find the orthogonal projection of this vector onto another vector.\n+     * @param v vector onto which instance must be projected\n+     * @return projection of the instance onto v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    FieldVector<T> projection(T[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute the outer product.\n+     * @param v vector with which outer product should be computed\n+     * @return the square matrix outer product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    FieldMatrix<T> outerProduct(FieldVector<T> v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute the outer product.\n+     * @param v vector with which outer product should be computed\n+     * @return the square matrix outer product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    FieldMatrix<T> outerProduct(T[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the entry in the specified index.\n+     * <p>\n+     * The index start at 0 and must be lesser than the size,\n+     * otherwise a {@link MatrixIndexException} is thrown.\n+     * </p>\n+     * @param index  index location of entry to be fetched\n+     * @return vector entry at index\n+     * @throws MatrixIndexException if the index is not valid\n+     * @see #setEntry(int, FieldElement)\n+     */\n+    T getEntry(int index)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set a single element.\n+     * @param index element index.\n+     * @param value new value for the element.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     * @see #getEntry(int)\n+     */\n+    void setEntry(int index, T value)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Returns the size of the vector.\n+     * @return size\n+     */\n+    int getDimension();\n+\n+    /**\n+     * Construct a vector by appending a vector to this vector.\n+     * @param v vector to append to this one.\n+     * @return a new vector\n+     */\n+    FieldVector<T> append(FieldVector<T> v);\n+\n+    /**\n+     * Construct a vector by appending a T to this vector.\n+     * @param d T to append.\n+     * @return a new vector\n+     */\n+    FieldVector<T> append(T d);\n+\n+    /**\n+     * Construct a vector by appending a T array to this vector.\n+     * @param a T array to append.\n+     * @return a new vector\n+     */\n+    FieldVector<T> append(T[] a);\n+\n+    /**\n+     * Get a subvector from consecutive elements.\n+     * @param index index of first element.\n+     * @param n number of elements to be retrieved.\n+     * @return a vector containing n elements.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     */\n+    FieldVector<T> getSubVector(int index, int n)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set a set of consecutive elements.\n+     * @param index index of first element to be set.\n+     * @param v vector containing the values to set.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     * @see #setSubVector(int, FieldElement[])\n+     */\n+    void setSubVector(int index, FieldVector<T> v)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set a set of consecutive elements.\n+     * @param index index of first element to be set.\n+     * @param v vector containing the values to set.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     * @see #setSubVector(int, FieldVector)\n+     */\n+    void setSubVector(int index, T[] v)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set all elements to a single value.\n+     * @param value single value to set for all elements\n+     */\n+    void set(T value);\n+\n+    /**\n+     * Convert the vector to a T array.\n+     * <p>The array is independent from vector data, it's elements\n+     * are copied.</p>\n+     * @return array containing a copy of vector elements\n+     */\n+    T[] toArray();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/InvalidMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Thrown when a system attempts an operation on a matrix, and\n+ * that matrix does not satisfy the preconditions for the\n+ * aforementioned operation.\n+ * @version $Revision$ $Date$\n+ */\n+public class InvalidMatrixException extends MathRuntimeException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 1135533765052675495L;\n+\n+    /**\n+     * Construct an exception with the given message.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     * @since 2.0\n+     */\n+    public InvalidMatrixException(final String pattern, final Object ... arguments) {\n+        super(pattern, arguments);\n+    }\n+\n+    /**\n+     * Construct an exception with the given message.\n+     * @param cause the exception or error that caused this exception\n+     * to be thrown.\n+     * @since 2.0\n+     */\n+    public InvalidMatrixException(final Throwable cause) {\n+        super(cause);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/LUDecomposition.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+\n+/**\n+ * An interface to classes that implement an algorithm to calculate the \n+ * LU-decomposition of a real matrix.\n+ * <p>The LU-decomposition of matrix A is a set of three matrices: P, L and U\n+ * such that P&times;A = L&times;U. P is a rows permutation matrix that is used\n+ * to rearrange the rows of A before so that it can be decomposed. L is a lower\n+ * triangular matrix with unit diagonal terms and U is an upper triangular matrix.</p>\n+ * <p>This interface is based on the class with similar name from the now defunct\n+ * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library.</p>\n+ * <ul>\n+ *   <li>a {@link #getP() getP} method has been added,</li>\n+ *   <li>the <code>det</code> method has been renamed as {@link #getDeterminant()\n+ *   getDeterminant},</li>\n+ *   <li>the <code>getDoublePivot</code> method has been removed (but the int based\n+ *   {@link #getPivot() getPivot} method has been kept),</li>\n+ *   <li>the <code>solve</code> and <code>isNonSingular</code> methods have been replaced\n+ *   by a {@link #getSolver() getSolver} method and the equivalent methods provided by\n+ *   the returned {@link DecompositionSolver}.</li>\n+ * </ul>\n+ *   \n+ * @see <a href=\"http://mathworld.wolfram.com/LUDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/LU_decomposition\">Wikipedia</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface LUDecomposition {\n+\n+    /**\n+     * Returns the matrix L of the decomposition. \n+     * <p>L is an lower-triangular matrix</p>\n+     * @return the L matrix (or null if decomposed matrix is singular)\n+     */\n+    RealMatrix getL();\n+\n+    /**\n+     * Returns the matrix U of the decomposition. \n+     * <p>U is an upper-triangular matrix</p>\n+     * @return the U matrix (or null if decomposed matrix is singular)\n+     */\n+    RealMatrix getU();\n+\n+    /**\n+     * Returns the P rows permutation matrix.\n+     * <p>P is a sparse matrix with exactly one element set to 1.0 in\n+     * each row and each column, all other elements being set to 0.0.</p>\n+     * <p>The positions of the 1 elements are given by the {@link #getPivot()\n+     * pivot permutation vector}.</p>\n+     * @return the P rows permutation matrix (or null if decomposed matrix is singular)\n+     * @see #getPivot()\n+     */\n+    RealMatrix getP();\n+\n+    /**\n+     * Returns the pivot permutation vector.\n+     * @return the pivot permutation vector\n+     * @see #getP()\n+     */\n+    int[] getPivot();\n+\n+    /**\n+     * Return the determinant of the matrix\n+     * @return determinant of the matrix\n+     */\n+    double getDeterminant();\n+\n+    /**\n+     * Get a solver for finding the A &times; X = B solution in exact linear sense.\n+     * @return a solver\n+     */\n+    DecompositionSolver getSolver();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Calculates the LUP-decomposition of a square matrix.\n+ * <p>The LUP-decomposition of a matrix A consists of three matrices\n+ * L, U and P that satisfy: PA = LU, L is lower triangular, and U is\n+ * upper triangular and P is a permutation matrix. All matrices are\n+ * m&times;m.</p>\n+ * <p>As shown by the presence of the P matrix, this decomposition is\n+ * implemented using partial pivoting.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class LUDecompositionImpl implements LUDecomposition {\n+\n+    /** Entries of LU decomposition. */\n+    private double lu[][];\n+\n+    /** Pivot permutation associated with LU decomposition */\n+    private int[] pivot;\n+\n+    /** Parity of the permutation associated with the LU decomposition */\n+    private boolean even;\n+\n+    /** Singularity indicator. */\n+    private boolean singular;\n+\n+    /** Cached value of L. */\n+    private RealMatrix cachedL;\n+\n+    /** Cached value of U. */\n+    private RealMatrix cachedU;\n+\n+    /** Cached value of P. */\n+    private RealMatrix cachedP;\n+\n+    /** Default bound to determine effective singularity in LU decomposition */\n+    private static final double DEFAULT_TOO_SMALL = 10E-12;\n+\n+    /**\n+     * Calculates the LU-decomposition of the given matrix. \n+     * @param matrix The matrix to decompose.\n+     * @exception InvalidMatrixException if matrix is not square\n+     */\n+    public LUDecompositionImpl(RealMatrix matrix)\n+        throws InvalidMatrixException {\n+        this(matrix, DEFAULT_TOO_SMALL);\n+    }\n+\n+    /**\n+     * Calculates the LU-decomposition of the given matrix. \n+     * @param matrix The matrix to decompose.\n+     * @param singularityThreshold threshold (based on partial row norm)\n+     * under which a matrix is considered singular\n+     * @exception NonSquareMatrixException if matrix is not square\n+     */\n+    public LUDecompositionImpl(RealMatrix matrix, double singularityThreshold)\n+        throws NonSquareMatrixException {\n+\n+        if (!matrix.isSquare()) {\n+            throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n+        }\n+\n+        final int m = matrix.getColumnDimension();\n+        lu = matrix.getData();\n+        pivot = new int[m];\n+        cachedL = null;\n+        cachedU = null;\n+        cachedP = null;\n+\n+        // Initialize permutation array and parity\n+        for (int row = 0; row < m; row++) {\n+            pivot[row] = row;\n+        }\n+        even     = true;\n+        singular = false;\n+\n+        // Loop over columns\n+        for (int col = 0; col < m; col++) {\n+\n+            double sum = 0;\n+\n+            // upper\n+            for (int row = 0; row < col; row++) {\n+                final double[] luRow = lu[row];\n+                sum = luRow[col];\n+                for (int i = 0; i < row; i++) {\n+                    sum -= luRow[i] * lu[i][col];\n+                }\n+                luRow[col] = sum;\n+            }\n+\n+            // lower\n+            int max = col; // permutation row\n+            double largest = Double.NEGATIVE_INFINITY;\n+            for (int row = col; row < m; row++) {\n+                final double[] luRow = lu[row];\n+                sum = luRow[col];\n+                for (int i = 0; i < col; i++) {\n+                    sum -= luRow[i] * lu[i][col];\n+                }\n+                luRow[col] = sum;\n+\n+                // maintain best permutation choice\n+                if (Math.abs(sum) > largest) {\n+                    largest = Math.abs(sum);\n+                    max = row;\n+                }\n+            }\n+\n+            // Singularity check\n+            if (Math.abs(lu[max][col]) < singularityThreshold) {\n+                singular = true;\n+                return;\n+            }\n+\n+            // Pivot if necessary\n+            if (max != col) {\n+                double tmp = 0;\n+                final double[] luMax = lu[max];\n+                final double[] luCol = lu[col];\n+                for (int i = 0; i < m; i++) {\n+                    tmp = luMax[i];\n+                    luMax[i] = luCol[i];\n+                    luCol[i] = tmp;\n+                }\n+                int temp = pivot[max];\n+                pivot[max] = pivot[col];\n+                pivot[col] = temp;\n+                even = !even;\n+            }\n+\n+            // Divide the lower elements by the \"winning\" diagonal elt.\n+            final double luDiag = lu[col][col];\n+            for (int row = col + 1; row < m; row++) {\n+                lu[row][col] /= luDiag;\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getL() {\n+        if ((cachedL == null) && !singular) {\n+            final int m = pivot.length;\n+            cachedL = MatrixUtils.createRealMatrix(m, m);\n+            for (int i = 0; i < m; ++i) {\n+                final double[] luI = lu[i];\n+                for (int j = 0; j < i; ++j) {\n+                    cachedL.setEntry(i, j, luI[j]);\n+                }\n+                cachedL.setEntry(i, i, 1.0);\n+            }\n+        }\n+        return cachedL;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getU() {\n+        if ((cachedU == null) && !singular) {\n+            final int m = pivot.length;\n+            cachedU = MatrixUtils.createRealMatrix(m, m);\n+            for (int i = 0; i < m; ++i) {\n+                final double[] luI = lu[i];\n+                for (int j = i; j < m; ++j) {\n+                    cachedU.setEntry(i, j, luI[j]);\n+                }\n+            }\n+        }\n+        return cachedU;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getP() {\n+        if ((cachedP == null) && !singular) {\n+            final int m = pivot.length;\n+            cachedP = MatrixUtils.createRealMatrix(m, m);\n+            for (int i = 0; i < m; ++i) {\n+                cachedP.setEntry(i, pivot[i], 1.0);\n+            }\n+        }\n+        return cachedP;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int[] getPivot() {\n+        return pivot.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDeterminant() {\n+        if (singular) {\n+            return 0;\n+        } else {\n+            final int m = pivot.length;\n+            double determinant = even ? 1 : -1;\n+            for (int i = 0; i < m; i++) {\n+                determinant *= lu[i][i];\n+            }\n+            return determinant;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DecompositionSolver getSolver() {\n+        return new Solver(lu, pivot, singular);\n+    }\n+\n+    /** Specialized solver. */\n+    private static class Solver implements DecompositionSolver {\n+    \n+        /** Entries of LU decomposition. */\n+        private final double lu[][];\n+\n+        /** Pivot permutation associated with LU decomposition. */\n+        private final int[] pivot;\n+\n+        /** Singularity indicator. */\n+        private final boolean singular;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         * @param lu entries of LU decomposition\n+         * @param pivot pivot permutation associated with LU decomposition\n+         * @param singular singularity indicator\n+         */\n+        private Solver(final double[][] lu, final int[] pivot, final boolean singular) {\n+            this.lu       = lu;\n+            this.pivot    = pivot;\n+            this.singular = singular;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean isNonSingular() {\n+            return !singular;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[] solve(double[] b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            final int m = pivot.length;\n+            if (b.length != m) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"vector length mismatch: got {0} but expected {1}\",\n+                        b.length, m);\n+            }\n+            if (singular) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final double[] bp = new double[m];\n+\n+            // Apply permutations to b\n+            for (int row = 0; row < m; row++) {\n+                bp[row] = b[pivot[row]];\n+            }\n+\n+            // Solve LY = b\n+            for (int col = 0; col < m; col++) {\n+                final double bpCol = bp[col];\n+                for (int i = col + 1; i < m; i++) {\n+                    bp[i] -= bpCol * lu[i][col];\n+                }\n+            }\n+\n+            // Solve UX = Y\n+            for (int col = m - 1; col >= 0; col--) {\n+                bp[col] /= lu[col][col];\n+                final double bpCol = bp[col];\n+                for (int i = 0; i < col; i++) {\n+                    bp[i] -= bpCol * lu[i][col];\n+                }\n+            }\n+\n+            return bp;\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector solve(RealVector b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+            try {\n+                return solve((ArrayRealVector) b);\n+            } catch (ClassCastException cce) {\n+\n+                final int m = pivot.length;\n+                if (b.getDimension() != m) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"vector length mismatch: got {0} but expected {1}\",\n+                            b.getDimension(), m);\n+                }\n+                if (singular) {\n+                    throw new SingularMatrixException();\n+                }\n+\n+                final double[] bp = new double[m];\n+\n+                // Apply permutations to b\n+                for (int row = 0; row < m; row++) {\n+                    bp[row] = b.getEntry(pivot[row]);\n+                }\n+\n+                // Solve LY = b\n+                for (int col = 0; col < m; col++) {\n+                    final double bpCol = bp[col];\n+                    for (int i = col + 1; i < m; i++) {\n+                        bp[i] -= bpCol * lu[i][col];\n+                    }\n+                }\n+\n+                // Solve UX = Y\n+                for (int col = m - 1; col >= 0; col--) {\n+                    bp[col] /= lu[col][col];\n+                    final double bpCol = bp[col];\n+                    for (int i = 0; i < col; i++) {\n+                        bp[i] -= bpCol * lu[i][col];\n+                    }\n+                }\n+\n+                return new ArrayRealVector(bp, false);\n+\n+            }\n+        }\n+\n+        /** Solve the linear equation A &times; X = B.\n+         * <p>The A matrix is implicit here. It is </p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a vector X such that A &times; X = B\n+         * @exception IllegalArgumentException if matrices dimensions don't match\n+         * @exception InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public ArrayRealVector solve(ArrayRealVector b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+            return new ArrayRealVector(solve(b.getDataRef()), false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix solve(RealMatrix b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            final int m = pivot.length;\n+            if (b.getRowDimension() != m) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n+            }\n+            if (singular) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final int nColB = b.getColumnDimension();\n+\n+            // Apply permutations to b\n+            final double[][] bp = new double[m][nColB];\n+            for (int row = 0; row < m; row++) {\n+                final double[] bpRow = bp[row];\n+                final int pRow = pivot[row];\n+                for (int col = 0; col < nColB; col++) {\n+                    bpRow[col] = b.getEntry(pRow, col);\n+                }\n+            }\n+\n+            // Solve LY = b\n+            for (int col = 0; col < m; col++) {\n+                final double[] bpCol = bp[col];\n+                for (int i = col + 1; i < m; i++) {\n+                    final double[] bpI = bp[i];\n+                    final double luICol = lu[i][col];\n+                    for (int j = 0; j < nColB; j++) {\n+                        bpI[j] -= bpCol[j] * luICol;\n+                    }\n+                }\n+            }\n+\n+            // Solve UX = Y\n+            for (int col = m - 1; col >= 0; col--) {\n+                final double[] bpCol = bp[col];\n+                final double luDiag = lu[col][col];\n+                for (int j = 0; j < nColB; j++) {\n+                    bpCol[j] /= luDiag;\n+                }\n+                for (int i = 0; i < col; i++) {\n+                    final double[] bpI = bp[i];\n+                    final double luICol = lu[i][col];\n+                    for (int j = 0; j < nColB; j++) {\n+                        bpI[j] -= bpCol[j] * luICol;\n+                    }\n+                }\n+            }\n+\n+            return new Array2DRowRealMatrix(bp, false);\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix getInverse() throws InvalidMatrixException {\n+            return solve(MatrixUtils.createRealIdentityMatrix(pivot.length));\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/MatrixIndexException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Thrown when an operation addresses a matrix coordinate (row, col)\n+ * which is outside of the dimensions of a matrix.\n+ * @version $Revision$ $Date$\n+ */\n+public class MatrixIndexException extends MathRuntimeException {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -2382324504109300625L;\n+\n+    /**\n+     * Constructs a new instance with specified formatted detail message.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public MatrixIndexException(final String pattern, final Object ... arguments) {\n+      super(pattern, arguments);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/MatrixUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.lang.reflect.Array;\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.fraction.BigFraction;\n+import org.apache.commons.math.fraction.Fraction;\n+\n+/**\n+ * A collection of static methods that operate on or return matrices.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class MatrixUtils {\n+\n+    /**\n+     * Default constructor.\n+     */\n+    public MatrixUtils() {\n+        super();\n+    }\n+    \n+    /**\n+     * Returns a {@link RealMatrix} with specified dimensions.\n+     * <p>The type of matrix returned depends on the dimension. Below\n+     * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n+     * square matrix) which can be stored in a 32kB array, a {@link\n+     * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n+     * BlockRealMatrix} instance is built.</p>\n+     * <p>The matrix elements are all set to 0.0.</p>\n+     * @param rows number of rows of the matrix\n+     * @param columns number of columns of the matrix\n+     * @return  RealMatrix with specified dimensions\n+     * @see #createRealMatrix(double[][])\n+     */\n+    public static RealMatrix createRealMatrix(final int rows, final int columns) {\n+        return (rows * columns <= 4096) ?\n+                new Array2DRowRealMatrix(rows, columns) : new BlockRealMatrix(rows, columns);\n+    }\n+\n+    /**\n+     * Returns a {@link FieldMatrix} with specified dimensions.\n+     * <p>The type of matrix returned depends on the dimension. Below\n+     * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n+     * square matrix), a {@link FieldMatrix} instance is built. Above\n+     * this threshold a {@link BlockFieldMatrix} instance is built.</p>\n+     * <p>The matrix elements are all set to field.getZero().</p>\n+     * @param <T> the type of the field elements\n+     * @param field field to which the matrix elements belong\n+     * @param rows number of rows of the matrix\n+     * @param columns number of columns of the matrix\n+     * @return  FieldMatrix with specified dimensions\n+     * @see #createFieldMatrix(FieldElement[][])\n+     * @since 2.0\n+     */\n+    public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(final Field<T> field,\n+                                                                               final int rows,\n+                                                                               final int columns) {\n+        return (rows * columns <= 4096) ?\n+                new Array2DRowFieldMatrix<T>(field, rows, columns) : new BlockFieldMatrix<T>(field, rows, columns);\n+    }\n+\n+    /**\n+     * Returns a {@link RealMatrix} whose entries are the the values in the\n+     * the input array.\n+     * <p>The type of matrix returned depends on the dimension. Below\n+     * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n+     * square matrix) which can be stored in a 32kB array, a {@link\n+     * Array2DRowRealMatrix} instance is built. Above this threshold a {@link\n+     * BlockRealMatrix} instance is built.</p>\n+     * <p>The input array is copied, not referenced.</p>\n+     * \n+     * @param data input array\n+     * @return  RealMatrix containing the values of the array\n+     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if either <code>data</code> or\n+     * <code>data[0]</code> is null\n+     * @see #createRealMatrix(int, int)\n+     */\n+    public static RealMatrix createRealMatrix(double[][] data) {\n+        return (data.length * data[0].length <= 4096) ?\n+                new Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n+    }\n+\n+    /**\n+     * Returns a {@link FieldMatrix} whose entries are the the values in the\n+     * the input array.\n+     * <p>The type of matrix returned depends on the dimension. Below\n+     * 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a\n+     * square matrix), a {@link FieldMatrix} instance is built. Above\n+     * this threshold a {@link BlockFieldMatrix} instance is built.</p>\n+     * <p>The input array is copied, not referenced.</p>\n+     * @param <T> the type of the field elements\n+     * @param data input array\n+     * @return  RealMatrix containing the values of the array\n+     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if either <code>data</code> or\n+     * <code>data[0]</code> is null\n+     * @see #createFieldMatrix(Field, int, int)\n+     * @since 2.0\n+     */\n+    public static <T extends FieldElement<T>> FieldMatrix<T> createFieldMatrix(T[][] data) {\n+        return (data.length * data[0].length <= 4096) ?\n+                new Array2DRowFieldMatrix<T>(data) : new BlockFieldMatrix<T>(data);\n+    }\n+\n+    /**\n+     * Returns <code>dimension x dimension</code> identity matrix.\n+     *\n+     * @param dimension dimension of identity matrix to generate\n+     * @return identity matrix\n+     * @throws IllegalArgumentException if dimension is not positive\n+     * @since 1.1\n+     */\n+    public static RealMatrix createRealIdentityMatrix(int dimension) {\n+        final RealMatrix m = createRealMatrix(dimension, dimension);\n+        for (int i = 0; i < dimension; ++i) {\n+            m.setEntry(i, i, 1.0);\n+        }\n+        return m;\n+    }\n+\n+    /**\n+     * Returns <code>dimension x dimension</code> identity matrix.\n+     *\n+     * @param <T> the type of the field elements\n+     * @param field field to which the elements belong\n+     * @param dimension dimension of identity matrix to generate\n+     * @return identity matrix\n+     * @throws IllegalArgumentException if dimension is not positive\n+     * @since 2.0\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T extends FieldElement<T>> FieldMatrix<T>\n+        createFieldIdentityMatrix(final Field<T> field, final int dimension) {\n+        final T zero = field.getZero();\n+        final T one  = field.getOne();\n+        final T[][] d = (T[][]) Array.newInstance(zero.getClass(), new int[] { dimension, dimension });\n+        for (int row = 0; row < dimension; row++) {\n+            final T[] dRow = d[row];\n+            Arrays.fill(dRow, zero);\n+            dRow[row] = one;\n+        }\n+        return new Array2DRowFieldMatrix<T>(d, false);\n+    }\n+\n+    /**\n+     * Returns <code>dimension x dimension</code> identity matrix.\n+     *\n+     * @param dimension dimension of identity matrix to generate\n+     * @return identity matrix\n+     * @throws IllegalArgumentException if dimension is not positive\n+     * @since 1.1\n+     * @deprecated since 2.0, replaced by {@link #createFieldIdentityMatrix(Field, int)}\n+     */\n+    @Deprecated\n+    public static BigMatrix createBigIdentityMatrix(int dimension) {\n+        final BigDecimal[][] d = new BigDecimal[dimension][dimension];\n+        for (int row = 0; row < dimension; row++) {\n+            final BigDecimal[] dRow = d[row];\n+            Arrays.fill(dRow, BigMatrixImpl.ZERO);\n+            dRow[row] = BigMatrixImpl.ONE;\n+        }\n+        return new BigMatrixImpl(d, false);\n+    }\n+    \n+    /**\n+     * Returns a diagonal matrix with specified elements.\n+     *\n+     * @param diagonal diagonal elements of the matrix (the array elements\n+     * will be copied)\n+     * @return diagonal matrix\n+     * @since 2.0\n+     */\n+    public static RealMatrix createRealDiagonalMatrix(final double[] diagonal) {\n+        final RealMatrix m = createRealMatrix(diagonal.length, diagonal.length);\n+        for (int i = 0; i < diagonal.length; ++i) {\n+            m.setEntry(i, i, diagonal[i]);\n+        }\n+        return m;\n+    }\n+    \n+    /**\n+     * Returns a diagonal matrix with specified elements.\n+     *\n+     * @param <T> the type of the field elements\n+     * @param diagonal diagonal elements of the matrix (the array elements\n+     * will be copied)\n+     * @return diagonal matrix\n+     * @since 2.0\n+     */\n+    public static <T extends FieldElement<T>> FieldMatrix<T>\n+        createFieldDiagonalMatrix(final T[] diagonal) {\n+        final FieldMatrix<T> m =\n+            createFieldMatrix(diagonal[0].getField(), diagonal.length, diagonal.length);\n+        for (int i = 0; i < diagonal.length; ++i) {\n+            m.setEntry(i, i, diagonal[i]);\n+        }\n+        return m;\n+    }\n+    \n+    /**\n+     * Returns a {@link BigMatrix} whose entries are the the values in the\n+     * the input array.  The input array is copied, not referenced.\n+     * \n+     * @param data input array\n+     * @return  RealMatrix containing the values of the array\n+     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if data is null\n+     * @deprecated since 2.0 replaced by {@link #createFieldMatrix(FieldElement[][])}\n+     */\n+    @Deprecated\n+    public static BigMatrix createBigMatrix(double[][] data) {\n+        return new BigMatrixImpl(data);\n+    }\n+    \n+    /**\n+     * Returns a {@link BigMatrix} whose entries are the the values in the\n+     * the input array.  The input array is copied, not referenced.\n+     * \n+     * @param data input array\n+     * @return  RealMatrix containing the values of the array\n+     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if data is null\n+     * @deprecated since 2.0 replaced by {@link #createFieldMatrix(FieldElement[][])}\n+     */\n+    @Deprecated\n+    public static BigMatrix createBigMatrix(BigDecimal[][] data) {\n+        return new BigMatrixImpl(data);\n+    }\n+\n+    /**\n+     * Returns a {@link BigMatrix} whose entries are the the values in the\n+     * the input array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * BigMatrix and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param data data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @return  BigMatrix containing the values of the array\n+     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>data</code> is null\n+     * @see #createRealMatrix(double[][])\n+     * @deprecated since 2.0 replaced by {@link #createFieldMatrix(FieldElement[][])}\n+     */\n+    @Deprecated\n+    public static BigMatrix createBigMatrix(BigDecimal[][] data, boolean copyArray) {\n+        return new BigMatrixImpl(data, copyArray);\n+    }\n+\n+    /**\n+     * Returns a {@link BigMatrix} whose entries are the the values in the\n+     * the input array.  The input array is copied, not referenced.\n+     * \n+     * @param data input array\n+     * @return  RealMatrix containing the values of the array\n+     * @throws IllegalArgumentException if <code>data</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if data is null\n+     * @deprecated since 2.0 replaced by {@link #createFieldMatrix(FieldElement[][])}\n+     */\n+    @Deprecated\n+    public static BigMatrix createBigMatrix(String[][] data) {\n+        return new BigMatrixImpl(data);\n+    }\n+    \n+    /**\n+     * Creates a {@link RealVector} using the data from the input array. \n+     * \n+     * @param data the input data\n+     * @return a data.length RealVector\n+     * @throws IllegalArgumentException if <code>data</code> is empty\n+     * @throws NullPointerException if <code>data</code>is null\n+     */\n+    public static RealVector createRealVector(double[] data) {\n+        return new ArrayRealVector(data, true);\n+    }\n+    \n+    /**\n+     * Creates a {@link FieldVector} using the data from the input array. \n+     * \n+     * @param <T> the type of the field elements\n+     * @param data the input data\n+     * @return a data.length FieldVector\n+     * @throws IllegalArgumentException if <code>data</code> is empty\n+     * @throws NullPointerException if <code>data</code>is null\n+     */\n+    public static <T extends FieldElement<T>> FieldVector<T> createFieldVector(final T[] data) {\n+        return new ArrayFieldVector<T>(data, true);\n+    }\n+    \n+    /**\n+     * Creates a row {@link RealMatrix} using the data from the input\n+     * array. \n+     * \n+     * @param rowData the input row data\n+     * @return a 1 x rowData.length RealMatrix\n+     * @throws IllegalArgumentException if <code>rowData</code> is empty\n+     * @throws NullPointerException if <code>rowData</code>is null\n+     */\n+    public static RealMatrix createRowRealMatrix(double[] rowData) {\n+        final int nCols = rowData.length;\n+        final RealMatrix m = createRealMatrix(1, nCols);\n+        for (int i = 0; i < nCols; ++i) {\n+            m.setEntry(0, i, rowData[i]);\n+        }\n+        return m;\n+    }\n+    \n+    /**\n+     * Creates a row {@link FieldMatrix} using the data from the input\n+     * array. \n+     * \n+     * @param <T> the type of the field elements\n+     * @param rowData the input row data\n+     * @return a 1 x rowData.length FieldMatrix\n+     * @throws IllegalArgumentException if <code>rowData</code> is empty\n+     * @throws NullPointerException if <code>rowData</code>is null\n+     */\n+    public static <T extends FieldElement<T>> FieldMatrix<T>\n+        createRowFieldMatrix(final T[] rowData) {\n+        final int nCols = rowData.length;\n+        if (nCols == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+        }\n+        final FieldMatrix<T> m = createFieldMatrix(rowData[0].getField(), 1, nCols);\n+        for (int i = 0; i < nCols; ++i) {\n+            m.setEntry(0, i, rowData[i]);\n+        }\n+        return m;\n+    }\n+    \n+    /**\n+     * Creates a row {@link BigMatrix} using the data from the input\n+     * array. \n+     * \n+     * @param rowData the input row data\n+     * @return a 1 x rowData.length BigMatrix\n+     * @throws IllegalArgumentException if <code>rowData</code> is empty\n+     * @throws NullPointerException if <code>rowData</code>is null\n+     * @deprecated since 2.0 replaced by {@link #createRowFieldMatrix(FieldElement[])}\n+     */\n+    @Deprecated\n+    public static BigMatrix createRowBigMatrix(double[] rowData) {\n+        final int nCols = rowData.length;\n+        final BigDecimal[][] data = new BigDecimal[1][nCols];\n+        for (int i = 0; i < nCols; ++i) {\n+            data[0][i] = new BigDecimal(rowData[i]);\n+        }\n+        return new BigMatrixImpl(data, false);\n+    }\n+    \n+    /**\n+     * Creates a row {@link BigMatrix} using the data from the input\n+     * array. \n+     * \n+     * @param rowData the input row data\n+     * @return a 1 x rowData.length BigMatrix\n+     * @throws IllegalArgumentException if <code>rowData</code> is empty\n+     * @throws NullPointerException if <code>rowData</code>is null\n+     * @deprecated since 2.0 replaced by {@link #createRowFieldMatrix(FieldElement[])}\n+     */\n+    @Deprecated\n+    public static BigMatrix createRowBigMatrix(BigDecimal[] rowData) {\n+        final int nCols = rowData.length;\n+        final BigDecimal[][] data = new BigDecimal[1][nCols];\n+        System.arraycopy(rowData, 0, data[0], 0, nCols);\n+        return new BigMatrixImpl(data, false);\n+    }\n+    \n+    /**\n+     * Creates a row {@link BigMatrix} using the data from the input\n+     * array. \n+     * \n+     * @param rowData the input row data\n+     * @return a 1 x rowData.length BigMatrix\n+     * @throws IllegalArgumentException if <code>rowData</code> is empty\n+     * @throws NullPointerException if <code>rowData</code>is null\n+     * @deprecated since 2.0 replaced by {@link #createRowFieldMatrix(FieldElement[])}\n+     */\n+    @Deprecated\n+    public static BigMatrix createRowBigMatrix(String[] rowData) {\n+        final int nCols = rowData.length;\n+        final BigDecimal[][] data = new BigDecimal[1][nCols];\n+        for (int i = 0; i < nCols; ++i) {\n+            data[0][i] = new BigDecimal(rowData[i]);\n+        }\n+        return new BigMatrixImpl(data, false);\n+    }\n+    \n+    /**\n+     * Creates a column {@link RealMatrix} using the data from the input\n+     * array.\n+     * \n+     * @param columnData  the input column data\n+     * @return a columnData x 1 RealMatrix\n+     * @throws IllegalArgumentException if <code>columnData</code> is empty\n+     * @throws NullPointerException if <code>columnData</code>is null\n+     */\n+    public static RealMatrix createColumnRealMatrix(double[] columnData) {\n+        final int nRows = columnData.length;\n+        final RealMatrix m = createRealMatrix(nRows, 1);\n+        for (int i = 0; i < nRows; ++i) {\n+            m.setEntry(i, 0, columnData[i]);\n+        }\n+        return m;\n+    }\n+    \n+    /**\n+     * Creates a column {@link FieldMatrix} using the data from the input\n+     * array.\n+     * \n+     * @param <T> the type of the field elements\n+     * @param columnData  the input column data\n+     * @return a columnData x 1 FieldMatrix\n+     * @throws IllegalArgumentException if <code>columnData</code> is empty\n+     * @throws NullPointerException if <code>columnData</code>is null\n+     */\n+    public static <T extends FieldElement<T>> FieldMatrix<T>\n+        createColumnFieldMatrix(final T[] columnData) {\n+        final int nRows = columnData.length;\n+        if (nRows == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+        }\n+        final FieldMatrix<T> m = createFieldMatrix(columnData[0].getField(), nRows, 1);\n+        for (int i = 0; i < nRows; ++i) {\n+            m.setEntry(i, 0, columnData[i]);\n+        }\n+        return m;\n+    }\n+    \n+    /**\n+     * Creates a column {@link BigMatrix} using the data from the input\n+     * array.\n+     * \n+     * @param columnData  the input column data\n+     * @return a columnData x 1 BigMatrix\n+     * @throws IllegalArgumentException if <code>columnData</code> is empty\n+     * @throws NullPointerException if <code>columnData</code>is null\n+     * @deprecated since 2.0 replaced by {@link #createColumnFieldMatrix(FieldElement[])}\n+     */\n+    @Deprecated\n+    public static BigMatrix createColumnBigMatrix(double[] columnData) {\n+        final int nRows = columnData.length;\n+        final BigDecimal[][] data = new BigDecimal[nRows][1];\n+        for (int row = 0; row < nRows; row++) {\n+            data[row][0] = new BigDecimal(columnData[row]);\n+        }\n+        return new BigMatrixImpl(data, false);\n+    }\n+    \n+    /**\n+     * Creates a column {@link BigMatrix} using the data from the input\n+     * array.\n+     * \n+     * @param columnData  the input column data\n+     * @return a columnData x 1 BigMatrix\n+     * @throws IllegalArgumentException if <code>columnData</code> is empty\n+     * @throws NullPointerException if <code>columnData</code>is null\n+     * @deprecated since 2.0 replaced by {@link #createColumnFieldMatrix(FieldElement[])}\n+     */\n+    @Deprecated\n+    public static BigMatrix createColumnBigMatrix(BigDecimal[] columnData) {\n+        final int nRows = columnData.length;\n+        final BigDecimal[][] data = new BigDecimal[nRows][1];\n+        for (int row = 0; row < nRows; row++) {\n+            data[row][0] = columnData[row];\n+        }\n+        return new BigMatrixImpl(data, false);\n+    }\n+    \n+    /**\n+     * Creates a column {@link BigMatrix} using the data from the input\n+     * array.\n+     * \n+     * @param columnData  the input column data\n+     * @return a columnData x 1 BigMatrix\n+     * @throws IllegalArgumentException if <code>columnData</code> is empty\n+     * @throws NullPointerException if <code>columnData</code>is null\n+     * @deprecated since 2.0 replaced by {@link #createColumnFieldMatrix(FieldElement[])}\n+     */\n+    @Deprecated\n+    public static BigMatrix createColumnBigMatrix(String[] columnData) {\n+        int nRows = columnData.length;\n+        final BigDecimal[][] data = new BigDecimal[nRows][1];\n+        for (int row = 0; row < nRows; row++) {\n+            data[row][0] = new BigDecimal(columnData[row]);\n+        }\n+        return new BigMatrixImpl(data, false);\n+    }\n+\n+    /**\n+     * Check if a row index is valid.\n+     * @param m matrix containing the submatrix\n+     * @param row row index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    public static void checkRowIndex(final AnyMatrix m, final int row) {\n+        if (row < 0 || row >= m.getRowDimension()) {\n+            throw new MatrixIndexException(\"row index {0} out of allowed range [{1}, {2}]\",\n+                                           row, 0, m.getRowDimension() - 1);\n+        }\n+    }\n+\n+    /**\n+     * Check if a column index is valid.\n+     * @param m matrix containing the submatrix\n+     * @param column column index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    public static void checkColumnIndex(final AnyMatrix m, final int column)\n+        throws MatrixIndexException {\n+        if (column < 0 || column >= m.getColumnDimension()) {\n+            throw new MatrixIndexException(\"column index {0} out of allowed range [{1}, {2}]\",\n+                                           column, 0, m.getColumnDimension() - 1);\n+        }\n+    }\n+\n+    /**\n+     * Check if submatrix ranges indices are valid.\n+     * Rows and columns are indicated counting from 0 to n-1.\n+     *\n+     * @param m matrix containing the submatrix\n+     * @param startRow Initial row index\n+     * @param endRow Final row index\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception MatrixIndexException  if the indices are not valid\n+     */\n+    public static void checkSubMatrixIndex(final AnyMatrix m,\n+                                           final int startRow, final int endRow,\n+                                           final int startColumn, final int endColumn) {\n+        checkRowIndex(m, startRow);\n+        checkRowIndex(m, endRow);\n+        if (startRow > endRow) {\n+            throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n+                                           startRow, endRow);\n+        }\n+\n+        checkColumnIndex(m, startColumn);\n+        checkColumnIndex(m, endColumn);\n+        if (startColumn > endColumn) {\n+            throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n+                                           startColumn, endColumn);\n+        }\n+\n+    \n+    }\n+\n+    /**\n+     * Check if submatrix ranges indices are valid.\n+     * Rows and columns are indicated counting from 0 to n-1.\n+     *\n+     * @param m matrix containing the submatrix\n+     * @param selectedRows Array of row indices.\n+     * @param selectedColumns Array of column indices.\n+     * @exception MatrixIndexException if row or column selections are not valid\n+     */\n+    public static void checkSubMatrixIndex(final AnyMatrix m,\n+                                           final int[] selectedRows, final int[] selectedColumns)\n+        throws MatrixIndexException {\n+        if (selectedRows.length * selectedColumns.length == 0) {\n+            if (selectedRows.length == 0) {\n+                throw new MatrixIndexException(\"empty selected row index array\");\n+            }\n+            throw new MatrixIndexException(\"empty selected column index array\");\n+        }\n+\n+        for (final int row : selectedRows) {\n+            checkRowIndex(m, row);\n+        }\n+        for (final int column : selectedColumns) {\n+            checkColumnIndex(m, column);\n+        }\n+    }\n+\n+    /**\n+     * Check if matrices are addition compatible\n+     * @param left left hand side matrix\n+     * @param right right hand side matrix\n+     * @exception IllegalArgumentException if matrices are not addition compatible\n+     */\n+    public static void checkAdditionCompatible(final AnyMatrix left, final AnyMatrix right)\n+        throws IllegalArgumentException {\n+        if ((left.getRowDimension()    != right.getRowDimension()) ||\n+            (left.getColumnDimension() != right.getColumnDimension())) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0}x{1} and {2}x{3} matrices are not addition compatible\",\n+                    left.getRowDimension(), left.getColumnDimension(),\n+                    right.getRowDimension(), right.getColumnDimension());\n+        }\n+    }\n+\n+    /**\n+     * Check if matrices are subtraction compatible\n+     * @param left left hand side matrix\n+     * @param right right hand side matrix\n+     * @exception IllegalArgumentException if matrices are not subtraction compatible\n+     */\n+    public static void checkSubtractionCompatible(final AnyMatrix left, final AnyMatrix right)\n+        throws IllegalArgumentException {\n+        if ((left.getRowDimension()    != right.getRowDimension()) ||\n+            (left.getColumnDimension() != right.getColumnDimension())) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0}x{1} and {2}x{3} matrices are not subtraction compatible\",\n+                    left.getRowDimension(), left.getColumnDimension(),\n+                    right.getRowDimension(), right.getColumnDimension());\n+        }\n+    }\n+\n+    /**\n+     * Check if matrices are multiplication compatible\n+     * @param left left hand side matrix\n+     * @param right right hand side matrix\n+     * @exception IllegalArgumentException if matrices are not multiplication compatible\n+     */\n+    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\n+        throws IllegalArgumentException {\n+        if (left.getColumnDimension() != right.getRowDimension()) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n+                    left.getRowDimension(), left.getColumnDimension(),\n+                    right.getRowDimension(), right.getColumnDimension());\n+        }\n+    }\n+\n+    /**\n+     * Convert a {@link FieldMatrix}/{@link Fraction} matrix to a {@link RealMatrix}.\n+     * @param m matrix to convert\n+     * @return converted matrix\n+     */\n+    public static Array2DRowRealMatrix fractionMatrixToRealMatrix(final FieldMatrix<Fraction> m) {\n+        final FractionMatrixConverter converter = new FractionMatrixConverter();\n+        m.walkInOptimizedOrder(converter);\n+        return converter.getConvertedMatrix();\n+    }\n+\n+    /** Converter for {@link FieldMatrix}/{@link Fraction}. */\n+    private static class FractionMatrixConverter extends DefaultFieldMatrixPreservingVisitor<Fraction> {\n+\n+        /** Converted array. */\n+        private double[][] data;\n+\n+        /** Simple constructor. */\n+        public FractionMatrixConverter() {\n+            super(Fraction.ZERO);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void start(int rows, int columns,\n+                          int startRow, int endRow, int startColumn, int endColumn) {\n+            data = new double[rows][columns];\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void visit(int row, int column, Fraction value) {\n+            data[row][column] = value.doubleValue();\n+        }\n+\n+        /** Get the converted matrix.\n+         * @return converted matrix\n+         */\n+        Array2DRowRealMatrix getConvertedMatrix() {\n+            return new Array2DRowRealMatrix(data, false);\n+        }\n+\n+    }\n+\n+    /**\n+     * Convert a {@link FieldMatrix}/{@link BigFraction} matrix to a {@link RealMatrix}.\n+     * @param m matrix to convert\n+     * @return converted matrix\n+     */\n+    public static Array2DRowRealMatrix bigFractionMatrixToRealMatrix(final FieldMatrix<BigFraction> m) {\n+        final BigFractionMatrixConverter converter = new BigFractionMatrixConverter();\n+        m.walkInOptimizedOrder(converter);\n+        return converter.getConvertedMatrix();\n+    }\n+\n+    /** Converter for {@link FieldMatrix}/{@link BigFraction}. */\n+    private static class BigFractionMatrixConverter extends DefaultFieldMatrixPreservingVisitor<BigFraction> {\n+\n+        /** Converted array. */\n+        private double[][] data;\n+\n+        /** Simple constructor. */\n+        public BigFractionMatrixConverter() {\n+            super(BigFraction.ZERO);\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void start(int rows, int columns,\n+                          int startRow, int endRow, int startColumn, int endColumn) {\n+            data = new double[rows][columns];\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public void visit(int row, int column, BigFraction value) {\n+            data[row][column] = value.doubleValue();\n+        }\n+\n+        /** Get the converted matrix.\n+         * @return converted matrix\n+         */\n+        Array2DRowRealMatrix getConvertedMatrix() {\n+            return new Array2DRowRealMatrix(data, false);\n+        }\n+\n+    }\n+\n+    /** Serialize a {@link RealVector}.\n+     * <p>\n+     * This method is intended to be called from within a private\n+     * <code>writeObject</code> method (after a call to\n+     * <code>oos.defaultWriteObject()</code>) in a class that has a\n+     * {@link RealVector} field, which should be declared <code>transient</code>.\n+     * This way, the default handling does not serialize the vector (the {@link\n+     * RealVector} interface is not serializable by default) but this method does\n+     * serialize it specifically.\n+     * </p>\n+     * <p>\n+     * The following example shows how a simple class with a name and a real vector\n+     * should be written:\n+     * <pre><code>\n+     * public class NamedVector implements Serializable {\n+     *\n+     *     private final String name;\n+     *     private final transient RealVector coefficients;\n+     *\n+     *     // omitted constructors, getters ...\n+     *\n+     *     private void writeObject(ObjectOutputStream oos) throws IOException {\n+     *         oos.defaultWriteObject();  // takes care of name field\n+     *         MatrixUtils.serializeRealVector(coefficients, oos);\n+     *     }\n+     *\n+     *     private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {\n+     *         ois.defaultReadObject();  // takes care of name field\n+     *         MatrixUtils.deserializeRealVector(this, \"coefficients\", ois);\n+     *     }\n+     *\n+     * }\n+     * </code></pre>\n+     * </p>\n+     * \n+     * @param vector real vector to serialize\n+     * @param oos stream where the real vector should be written\n+     * @exception IOException if object cannot be written to stream\n+     * @see #deserializeRealVector(Object, String, ObjectInputStream)\n+     */\n+    public static void serializeRealVector(final RealVector vector,\n+                                           final ObjectOutputStream oos)\n+        throws IOException {\n+        final int n = vector.getDimension();\n+        oos.writeInt(n);\n+        for (int i = 0; i < n; ++i) {\n+            oos.writeDouble(vector.getEntry(i));\n+        }\n+    }\n+\n+    /** Deserialize  a {@link RealVector} field in a class.\n+     * <p>\n+     * This method is intended to be called from within a private\n+     * <code>readObject</code> method (after a call to\n+     * <code>ois.defaultReadObject()</code>) in a class that has a\n+     * {@link RealVector} field, which should be declared <code>transient</code>.\n+     * This way, the default handling does not deserialize the vector (the {@link\n+     * RealVector} interface is not serializable by default) but this method does\n+     * deserialize it specifically.\n+     * </p>\n+     * @param instance instance in which the field must be set up\n+     * @param fieldName name of the field within the class (may be private and final)\n+     * @param ois stream from which the real vector should be read\n+     * @exception ClassNotFoundException if a class in the stream cannot be found\n+     * @exception IOException if object cannot be read from the stream\n+     * @see #serializeRealVector(RealVector, ObjectOutputStream)\n+     */\n+    public static void deserializeRealVector(final Object instance,\n+                                             final String fieldName,\n+                                             final ObjectInputStream ois)\n+      throws ClassNotFoundException, IOException {\n+        try {\n+\n+            // read the vector data\n+            final int n = ois.readInt();\n+            final double[] data = new double[n];\n+            for (int i = 0; i < n; ++i) {\n+                data[i] = ois.readDouble();\n+            }\n+\n+            // create the instance\n+            final RealVector vector = new ArrayRealVector(data, false);\n+\n+            // set up the field\n+            final java.lang.reflect.Field f =\n+                instance.getClass().getDeclaredField(fieldName);\n+            f.setAccessible(true);\n+            f.set(instance, vector);\n+\n+        } catch (NoSuchFieldException nsfe) {\n+            IOException ioe = new IOException();\n+            ioe.initCause(nsfe);\n+            throw ioe;\n+        } catch (IllegalAccessException iae) {\n+            IOException ioe = new IOException();\n+            ioe.initCause(iae);\n+            throw ioe;\n+        }\n+\n+    }\n+\n+    /** Serialize a {@link RealMatrix}.\n+     * <p>\n+     * This method is intended to be called from within a private\n+     * <code>writeObject</code> method (after a call to\n+     * <code>oos.defaultWriteObject()</code>) in a class that has a\n+     * {@link RealMatrix} field, which should be declared <code>transient</code>.\n+     * This way, the default handling does not serialize the matrix (the {@link\n+     * RealMatrix} interface is not serializable by default) but this method does\n+     * serialize it specifically.\n+     * </p>\n+     * <p>\n+     * The following example shows how a simple class with a name and a real matrix\n+     * should be written:\n+     * <pre><code>\n+     * public class NamedMatrix implements Serializable {\n+     *\n+     *     private final String name;\n+     *     private final transient RealMatrix coefficients;\n+     *\n+     *     // omitted constructors, getters ...\n+     *\n+     *     private void writeObject(ObjectOutputStream oos) throws IOException {\n+     *         oos.defaultWriteObject();  // takes care of name field\n+     *         MatrixUtils.serializeRealMatrix(coefficients, oos);\n+     *     }\n+     *\n+     *     private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {\n+     *         ois.defaultReadObject();  // takes care of name field\n+     *         MatrixUtils.deserializeRealMatrix(this, \"coefficients\", ois);\n+     *     }\n+     *\n+     * }\n+     * </code></pre>\n+     * </p>\n+     * \n+     * @param matrix real matrix to serialize\n+     * @param oos stream where the real matrix should be written\n+     * @exception IOException if object cannot be written to stream\n+     * @see #deserializeRealMatrix(Object, String, ObjectInputStream)\n+     */\n+    public static void serializeRealMatrix(final RealMatrix matrix,\n+                                           final ObjectOutputStream oos)\n+        throws IOException {\n+        final int n = matrix.getRowDimension();\n+        final int m = matrix.getColumnDimension();\n+        oos.writeInt(n);\n+        oos.writeInt(m);\n+        for (int i = 0; i < n; ++i) {\n+            for (int j = 0; j < m; ++j) {\n+                oos.writeDouble(matrix.getEntry(i, j));\n+            }\n+        }\n+    }\n+\n+    /** Deserialize  a {@link RealMatrix} field in a class.\n+     * <p>\n+     * This method is intended to be called from within a private\n+     * <code>readObject</code> method (after a call to\n+     * <code>ois.defaultReadObject()</code>) in a class that has a\n+     * {@link RealMatrix} field, which should be declared <code>transient</code>.\n+     * This way, the default handling does not deserialize the matrix (the {@link\n+     * RealMatrix} interface is not serializable by default) but this method does\n+     * deserialize it specifically.\n+     * </p>\n+     * @param instance instance in which the field must be set up\n+     * @param fieldName name of the field within the class (may be private and final)\n+     * @param ois stream from which the real matrix should be read\n+     * @exception ClassNotFoundException if a class in the stream cannot be found\n+     * @exception IOException if object cannot be read from the stream\n+     * @see #serializeRealMatrix(RealMatrix, ObjectOutputStream)\n+     */\n+    public static void deserializeRealMatrix(final Object instance,\n+                                             final String fieldName,\n+                                             final ObjectInputStream ois)\n+      throws ClassNotFoundException, IOException {\n+        try {\n+\n+            // read the matrix data\n+            final int n = ois.readInt();\n+            final int m = ois.readInt();\n+            final double[][] data = new double[n][m];\n+            for (int i = 0; i < n; ++i) {\n+                final double[] dataI = data[i];\n+                for (int j = 0; j < m; ++j) {\n+                    dataI[j] = ois.readDouble();\n+                }\n+            }\n+\n+            // create the instance\n+            final RealMatrix matrix = new Array2DRowRealMatrix(data, false);\n+\n+            // set up the field\n+            final java.lang.reflect.Field f =\n+                instance.getClass().getDeclaredField(fieldName);\n+            f.setAccessible(true);\n+            f.set(instance, matrix);\n+\n+        } catch (NoSuchFieldException nsfe) {\n+            IOException ioe = new IOException();\n+            ioe.initCause(nsfe);\n+            throw ioe;\n+        } catch (IllegalAccessException iae) {\n+            IOException ioe = new IOException();\n+            ioe.initCause(iae);\n+            throw ioe;\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/MatrixVisitorException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Thrown when a visitor encounters an error while processing a matrix entry.\n+ * @version $Revision$ $Date$\n+ */\n+public class MatrixVisitorException extends MathRuntimeException {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 3814333035048617048L;\n+\n+    /**\n+     * Constructs a new instance with specified formatted detail message.\n+     * @param pattern format specifier\n+     * @param arguments format arguments\n+     */\n+    public MatrixVisitorException(final String pattern, final Object[] arguments) {\n+      super(pattern, arguments);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/NonSquareMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+\n+/**\n+ * Thrown when an operation defined only for square matrices is applied to non-square ones.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class NonSquareMatrixException extends InvalidMatrixException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 8996207526636673730L;\n+\n+    /**\n+     * Construct an exception with the given message.\n+     * @param rows number of rows of the faulty matrix\n+     * @param columns number of columns of the faulty matrix\n+     */\n+    public NonSquareMatrixException(final int rows, final int columns) {\n+        super(\"a {0}x{1} matrix was provided instead of a square matrix\",\n+              rows, columns);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/NotPositiveDefiniteMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.MathException;\n+\n+/** \n+ * This class represents exceptions thrown when a matrix expected to\n+ * be positive definite is not.\n+ * \n+ * @since 1.2\n+ * @version $Revision$ $Date$\n+ */\n+\n+public class NotPositiveDefiniteMatrixException extends MathException {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 4122929125438624648L;\n+\n+    /** Simple constructor.\n+     * build an exception with a default message.\n+     */\n+    public NotPositiveDefiniteMatrixException() {\n+        super(\"not positive definite matrix\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/NotSymmetricMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.MathException;\n+\n+/** \n+ * This class represents exceptions thrown when a matrix expected to\n+ * be symmetric is not\n+ * \n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+\n+public class NotSymmetricMatrixException extends MathException {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -7012803946709786097L;\n+\n+    /** Simple constructor.\n+     * build an exception with a default message.\n+     */\n+    public NotSymmetricMatrixException() {\n+        super(\"not symmetric matrix\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.util.OpenIntToDoubleHashMap;\n+\n+/**\n+ * Sparse matrix implementation based on an open addressed map.\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class OpenMapRealMatrix extends AbstractRealMatrix implements SparseRealMatrix, Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -5962461716457143437L;\n+\n+    /** Number of rows of the matrix. */\n+    private final int rowDimension;\n+\n+    /** Number of columns of the matrix. */\n+    private final int columnDimension;\n+\n+    /** Storage for (sparse) matrix elements. */\n+    private final OpenIntToDoubleHashMap entries;\n+\n+    /**\n+     * Build a sparse matrix with the supplied row and column dimensions.\n+     * @param rowDimension number of rows of the matrix\n+     * @param columnDimension number of columns of the matrix\n+     */\n+    public OpenMapRealMatrix(int rowDimension, int columnDimension) {\n+        super(rowDimension, columnDimension);\n+        this.rowDimension = rowDimension;\n+        this.columnDimension = columnDimension;\n+        this.entries = new OpenIntToDoubleHashMap(0.0);\n+    }\n+  \n+    /**\n+     * Build a matrix by copying another one.\n+     * @param matrix matrix to copy\n+     */\n+    public OpenMapRealMatrix(OpenMapRealMatrix matrix) {\n+        this.rowDimension = matrix.rowDimension;\n+        this.columnDimension = matrix.columnDimension;\n+        this.entries = new OpenIntToDoubleHashMap(matrix.entries);\n+    }\n+  \n+    /** {@inheritDoc} */\n+    @Override\n+    public OpenMapRealMatrix copy() {\n+        return new OpenMapRealMatrix(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public OpenMapRealMatrix createMatrix(int rowDimension, int columnDimension)\n+            throws IllegalArgumentException {\n+        return new OpenMapRealMatrix(rowDimension, columnDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return columnDimension;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public OpenMapRealMatrix add(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return add((OpenMapRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+            return (OpenMapRealMatrix) super.add(m);\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public OpenMapRealMatrix add(OpenMapRealMatrix m) throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkAdditionCompatible(this, m);\n+\n+        final OpenMapRealMatrix out = new OpenMapRealMatrix(this);\n+        for (OpenIntToDoubleHashMap.Iterator iterator = m.entries.iterator(); iterator.hasNext();) {\n+            iterator.advance();\n+            final int row = iterator.key() / columnDimension;\n+            final int col = iterator.key() - row * columnDimension;\n+            out.setEntry(row, col, getEntry(row, col) + iterator.value());\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public OpenMapRealMatrix subtract(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return subtract((OpenMapRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+            return (OpenMapRealMatrix) super.subtract(m);\n+        }\n+    }\n+\n+    /**\n+     * Compute this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this - m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public OpenMapRealMatrix subtract(OpenMapRealMatrix m) throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkAdditionCompatible(this, m);\n+\n+        final OpenMapRealMatrix out = new OpenMapRealMatrix(this);\n+        for (OpenIntToDoubleHashMap.Iterator iterator = m.entries.iterator(); iterator.hasNext();) {\n+            iterator.advance();\n+            final int row = iterator.key() / columnDimension;\n+            final int col = iterator.key() - row * columnDimension;\n+            out.setEntry(row, col, getEntry(row, col) - iterator.value());\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix multiply(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return multiply((OpenMapRealMatrix) m);\n+        } catch (ClassCastException cce) {\n+\n+            // safety check\n+            MatrixUtils.checkMultiplicationCompatible(this, m);\n+\n+            final int outCols = m.getColumnDimension();\n+            final BlockRealMatrix out = new BlockRealMatrix(rowDimension, outCols);\n+            for (OpenIntToDoubleHashMap.Iterator iterator = entries.iterator(); iterator.hasNext();) {\n+                iterator.advance();\n+                final double value = iterator.value();\n+                final int key      = iterator.key();\n+                final int i        = key / columnDimension;\n+                final int k        = key % columnDimension;\n+                for (int j = 0; j < outCols; ++j) {\n+                    out.addToEntry(i, j, value * m.getEntry(k, j));\n+                }\n+            }\n+\n+            return out;\n+\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by m.\n+     *\n+     * @param m    matrix to postmultiply by\n+     * @return     this * m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public OpenMapRealMatrix multiply(OpenMapRealMatrix m) throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkMultiplicationCompatible(this, m);\n+\n+        final int outCols = m.getColumnDimension();\n+        OpenMapRealMatrix out = new OpenMapRealMatrix(rowDimension, outCols);\n+        for (OpenIntToDoubleHashMap.Iterator iterator = entries.iterator(); iterator.hasNext();) {\n+            iterator.advance();\n+            final double value = iterator.value();\n+            final int key      = iterator.key();\n+            final int i        = key / columnDimension;\n+            final int k        = key % columnDimension;\n+            for (int j = 0; j < outCols; ++j) {\n+                final int rightKey = m.computeKey(k, j);\n+                if (m.entries.containsKey(rightKey)) {\n+                    final int outKey = out.computeKey(i, j);\n+                    final double outValue =\n+                        out.entries.get(outKey) + value * m.entries.get(rightKey);\n+                    if (outValue == 0.0) {\n+                        out.entries.remove(outKey);\n+                    } else {\n+                        out.entries.put(outKey, outValue);\n+                    }\n+                }\n+            }\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double getEntry(int row, int column) throws MatrixIndexException {\n+        MatrixUtils.checkRowIndex(this, row);\n+        MatrixUtils.checkColumnIndex(this, column);\n+        return entries.get(computeKey(row, column));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return rowDimension;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(int row, int column, double value)\n+            throws MatrixIndexException {\n+        MatrixUtils.checkRowIndex(this, row);\n+        MatrixUtils.checkColumnIndex(this, column);\n+        if (value == 0.0) {\n+            entries.remove(computeKey(row, column));\n+        } else {\n+            entries.put(computeKey(row, column), value);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(int row, int column, double increment)\n+            throws MatrixIndexException {\n+        MatrixUtils.checkRowIndex(this, row);\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final int key = computeKey(row, column);\n+        final double value = entries.get(key) + increment;\n+        if (value == 0.0) {\n+            entries.remove(key);\n+        } else {\n+            entries.put(key, value);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(int row, int column, double factor)\n+            throws MatrixIndexException {\n+        MatrixUtils.checkRowIndex(this, row);\n+        MatrixUtils.checkColumnIndex(this, column);\n+        final int key = computeKey(row, column);\n+        final double value = entries.get(key) * factor;\n+        if (value == 0.0) {\n+            entries.remove(key);\n+        } else {\n+            entries.put(key, value);\n+        }\n+    }\n+\n+    /**\n+     * Compute the key to access a matrix element\n+     * @param row row index of the matrix element\n+     * @param column column index of the matrix element\n+     * @return key within the map to access the matrix element\n+     */\n+    private int computeKey(int row, int column) {\n+        return row * columnDimension + column;\n+    }\n+\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/OpenMapRealVector.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.OpenIntToDoubleHashMap;\n+import org.apache.commons.math.util.OpenIntToDoubleHashMap.Iterator;\n+\n+/**\n+ * This class implements the {@link RealVector} interface with a {@link OpenIntToDoubleHashMap} backing store.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+*/\n+public class OpenMapRealVector implements SparseRealVector, Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 8772222695580707260L;\n+\n+    /** Default Tolerance for having a value considered zero. */\n+    public static final double DEFAULT_ZERO_TOLERANCE = 1.0e-12;\n+\n+    /** Entries of the vector. */\n+    private final OpenIntToDoubleHashMap entries;\n+\n+    /** Dimension of the vector. */\n+    private final int virtualSize;\n+\n+    /** Tolerance for having a value considered zero. */\n+    private double epsilon;\n+\n+    /**\n+     * Build a 0-length vector.\n+     * <p>Zero-length vectors may be used to initialized construction of vectors\n+     * by data gathering. We start with zero-length and use either the {@link\n+     * #OpenMapRealVector(OpenMapRealVector, int)} constructor\n+     * or one of the <code>append</code> method ({@link #append(double)}, {@link\n+     * #append(double[])}, {@link #append(RealVector)}) to gather data\n+     * into this vector.</p>\n+     */\n+    public OpenMapRealVector() {\n+        this(0, DEFAULT_ZERO_TOLERANCE);\n+    }\n+\n+    /**\n+     * Construct a (dimension)-length vector of zeros.\n+     * @param dimension size of the vector\n+     */\n+    public OpenMapRealVector(int dimension) {\n+        this(dimension, DEFAULT_ZERO_TOLERANCE);\n+    }\n+\n+    /**\n+     * Construct a (dimension)-length vector of zeros, specifying zero tolerance.\n+     * @param dimension Size of the vector\n+     * @param epsilon The tolerance for having a value considered zero\n+     */\n+    public OpenMapRealVector(int dimension, double epsilon) {\n+        virtualSize = dimension;\n+        entries = new OpenIntToDoubleHashMap(0.0);\n+        this.epsilon = epsilon;\n+    }\n+\n+    /**\n+     * Build a resized vector, for use with append.\n+     * @param v The original vector\n+     * @param resize The amount to resize it\n+     */\n+    protected OpenMapRealVector(OpenMapRealVector v, int resize) {\n+        virtualSize = v.getDimension() + resize;\n+        entries = new OpenIntToDoubleHashMap(v.entries);\n+        epsilon = v.getEpsilon();\n+    }\n+\n+    /**\n+     * Build a vector with known the sparseness (for advanced use only).\n+     * @param dimension The size of the vector\n+     * @param expectedSize The expected number of non-zero entries\n+     */\n+    public OpenMapRealVector(int dimension, int expectedSize) {\n+        this(dimension, expectedSize, DEFAULT_ZERO_TOLERANCE);\n+    }\n+\n+    /**\n+     * Build a vector with known the sparseness and zero tolerance setting (for advanced use only).\n+     * @param dimension The size of the vector\n+     * @param expectedSize The expected number of non-zero entries\n+     * @param epsilon The tolerance for having a value considered zero\n+     */\n+    public OpenMapRealVector(int dimension, int expectedSize, double epsilon) {\n+        virtualSize = dimension;\n+        entries = new OpenIntToDoubleHashMap(expectedSize, 0.0);\n+        this.epsilon = epsilon;\n+    }\n+\n+    /**\n+     * Create from a double array.\n+     * Only non-zero entries will be stored\n+     * @param values The set of values to create from\n+     */\n+    public OpenMapRealVector(double[] values) {\n+        this(values, DEFAULT_ZERO_TOLERANCE);\n+    }\n+\n+    /**\n+     * Create from a double array, specifying zero tolerance.\n+     * Only non-zero entries will be stored\n+     * @param values The set of values to create from\n+     * @param epsilon The tolerance for having a value considered zero\n+     */\n+    public OpenMapRealVector(double[] values, double epsilon) {\n+        virtualSize = values.length;\n+        entries = new OpenIntToDoubleHashMap(0.0);\n+        this.epsilon = epsilon;\n+        for (int key = 0; key < values.length; key++) {\n+            double value = values[key];\n+            if (!isZero(value)) {\n+                entries.put(key, value);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Create from a Double array.\n+     * Only non-zero entries will be stored\n+     * @param values The set of values to create from\n+     */\n+    public OpenMapRealVector(Double[] values) {\n+        this(values, DEFAULT_ZERO_TOLERANCE);\n+    }\n+\n+    /**\n+     * Create from a Double array.\n+     * Only non-zero entries will be stored\n+     * @param values The set of values to create from\n+     * @param epsilon The tolerance for having a value considered zero\n+     */\n+    public OpenMapRealVector(Double[] values, double epsilon) {\n+        virtualSize = values.length;\n+        entries = new OpenIntToDoubleHashMap(0.0);\n+        this.epsilon = epsilon;\n+        for (int key = 0; key < values.length; key++) {\n+            double value = values[key].doubleValue();\n+            if (!isZero(value)) {\n+                entries.put(key, value);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Copy constructor.\n+     * @param v The instance to copy from\n+     */\n+    public OpenMapRealVector(OpenMapRealVector v) {\n+        virtualSize = v.getDimension();\n+        entries = new OpenIntToDoubleHashMap(v.getEntries());\n+        epsilon = v.getEpsilon();\n+    }\n+\n+    /**\n+     * Generic copy constructor.\n+     * @param v The instance to copy from\n+     */\n+    public OpenMapRealVector(RealVector v) {\n+        virtualSize = v.getDimension();\n+        entries = new OpenIntToDoubleHashMap(0.0);\n+        epsilon = DEFAULT_ZERO_TOLERANCE;\n+        for (int key = 0; key < virtualSize; key++) {\n+            double value = v.getEntry(key);\n+            if (!isZero(value)) {\n+                entries.put(key, value);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get the entries of this instance.\n+     * @return entries of this instance\n+     */\n+    private OpenIntToDoubleHashMap getEntries() {\n+        return entries;\n+    }\n+\n+    /**\n+     * Determine if this value is zero.\n+     * @param value The value to test\n+     * @return <code>true</code> if this value is zero, <code>false</code> otherwise\n+     */\n+    protected boolean isZero(double value) {\n+        return value > -epsilon && value < epsilon;\n+    }\n+\n+    /**\n+     * Get the tolerance for having a value considered zero.\n+     * @return The test range for testing if a value is zero\n+     */\n+    public double getEpsilon() {\n+        return epsilon;\n+    }\n+\n+    /**\n+     * Set the tolerance for having a value considered zero.\n+     * @param epsilon The test range for testing if a value is zero\n+     */\n+    public void setEpsilon(double epsilon) {\n+        this.epsilon = epsilon;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector add(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        if (v instanceof OpenMapRealVector) {\n+            return add((OpenMapRealVector) v);\n+        }\n+        return add(v.getData());\n+    }\n+\n+    /**\n+     * Optimized method to add two OpenMapRealVectors.\n+     * @param v Vector to add with\n+     * @return The sum of <code>this</code> with <code>v</code>\n+     * @throws IllegalArgumentException If the dimensions don't match\n+     */\n+    public OpenMapRealVector add(OpenMapRealVector v) throws IllegalArgumentException{\n+        checkVectorDimensions(v.getDimension());\n+        OpenMapRealVector res = (OpenMapRealVector)copy();\n+        Iterator iter = v.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (entries.containsKey(key)) {\n+                res.setEntry(key, entries.get(key) + iter.value());\n+            } else {\n+                res.setEntry(key, iter.value());\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector add(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        OpenMapRealVector res = new OpenMapRealVector(getDimension());\n+        for (int i = 0; i < v.length; i++) {\n+            res.setEntry(i, v[i] + getEntry(i));\n+        }\n+        return res;\n+    }\n+\n+    /**\n+     * Optimized method to append a OpenMapRealVector.\n+     * @param v vector to append\n+     * @return The result of appending <code>v</code> to self\n+     */\n+    public OpenMapRealVector append(OpenMapRealVector v) {\n+        OpenMapRealVector res = new OpenMapRealVector(this, v.getDimension());\n+        Iterator iter = v.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key() + virtualSize, iter.value());\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector append(RealVector v) {\n+        if (v instanceof OpenMapRealVector) {\n+            return append((OpenMapRealVector) v);\n+        }\n+        return append(v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector append(double d) {\n+        OpenMapRealVector res = new OpenMapRealVector(this, 1);\n+        res.setEntry(virtualSize, d);\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector append(double[] a) {\n+        OpenMapRealVector res = new OpenMapRealVector(this, a.length);\n+        for (int i = 0; i < a.length; i++) {\n+            res.setEntry(i + virtualSize, a[i]);\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector copy() {\n+        return new OpenMapRealVector(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double dotProduct(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        double res = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res += v.getEntry(iter.key()) * iter.value();\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double dotProduct(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double res = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            int idx = iter.key();\n+            double value = 0;\n+            if (idx < v.length) {\n+                value = v[idx];\n+            }\n+            res += value * iter.value();\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector ebeDivide(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        OpenMapRealVector res = new OpenMapRealVector(this);\n+        Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector ebeDivide(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        OpenMapRealVector res = new OpenMapRealVector(this);\n+        Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector ebeMultiply(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        OpenMapRealVector res = new OpenMapRealVector(this);\n+        Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector ebeMultiply(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        OpenMapRealVector res = new OpenMapRealVector(this);\n+        Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector getSubVector(int index, int n) throws MatrixIndexException {\n+        checkIndex(index);\n+        checkIndex(index + n - 1);\n+        OpenMapRealVector res = new OpenMapRealVector(n);\n+        int end = index + n;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (key >= index && key < end) {\n+                res.setEntry(key - index, iter.value());\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getData() {\n+        double[] res = new double[virtualSize];\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res[iter.key()] = iter.value();\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getDimension() {\n+        return virtualSize;\n+    }\n+\n+    /**\n+     * Optimized method to compute distance.\n+     * @param v The vector to compute distance to\n+     * @return The distance from <code>this</code> and <code>v</code>\n+     * @throws IllegalArgumentException If the dimensions don't match\n+     */\n+    public double getDistance(OpenMapRealVector v) throws IllegalArgumentException {\n+        Iterator iter = entries.iterator();\n+        double res = 0;\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            double delta;\n+            delta = iter.value() - v.getEntry(key);\n+            res += delta * delta;\n+        }\n+        iter = v.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (!entries.containsKey(key)) {\n+                final double value = iter.value();\n+                res += value * value;\n+            }\n+        }\n+        return Math.sqrt(res);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDistance(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        if (v instanceof OpenMapRealVector) {\n+            return getDistance((OpenMapRealVector) v);\n+        }\n+        return getDistance(v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getDistance(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double res = 0;\n+        for (int i = 0; i < v.length; i++) {\n+            double delta = entries.get(i) - v[i];\n+            res += delta * delta;\n+        }\n+        return Math.sqrt(res);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getEntry(int index) throws MatrixIndexException {\n+        checkIndex(index);\n+        return entries.get(index);\n+    }\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     */\n+    public double getL1Distance(OpenMapRealVector v) {\n+        double max = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            double delta = Math.abs(iter.value() - v.getEntry(iter.key()));\n+            max += delta;\n+        }\n+        iter = v.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (!entries.containsKey(key)) {\n+                double delta = Math.abs(iter.value());\n+                max +=  Math.abs(delta);\n+            }\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Distance(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        if (v instanceof OpenMapRealVector) {\n+            return getL1Distance((OpenMapRealVector) v);\n+        }\n+        return getL1Distance(v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Distance(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double max = 0;\n+        for (int i = 0; i < v.length; i++) {\n+            double delta = Math.abs(getEntry(i) - v[i]);\n+            max += delta;\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getL1Norm() {\n+        double res = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res += Math.abs(iter.value());\n+        }\n+        return res;\n+    }\n+\n+    /**\n+     * Optimized method to compute LInfDistance.\n+     * @param v The vector to compute from\n+     * @return the LInfDistance\n+     */\n+    private double getLInfDistance(OpenMapRealVector v) {\n+        double max = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            double delta = Math.abs(iter.value() - v.getEntry(iter.key()));\n+            if (delta > max) {\n+                max = delta;\n+            }\n+        }\n+        iter = v.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (!entries.containsKey(key)) {\n+                if (iter.value() > max) {\n+                    max = iter.value();\n+                }\n+            }\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfDistance(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        if (v instanceof OpenMapRealVector) {\n+            return getLInfDistance((OpenMapRealVector) v);\n+        }\n+        return getLInfDistance(v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfDistance(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        double max = 0;\n+        for (int i = 0; i < v.length; i++) {\n+            double delta = Math.abs(getEntry(i) - v[i]);\n+            if (delta > max) {\n+                max = delta;\n+            }\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getLInfNorm() {\n+        double max = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            max += iter.value();\n+        }\n+        return max;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNorm() {\n+        double res = 0;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res += iter.value() * iter.value();\n+        }\n+        return Math.sqrt(res);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isInfinite() {\n+        boolean infiniteFound = false;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            final double value = iter.value();\n+            if (Double.isNaN(value)) {\n+                return false;\n+            }\n+            if (Double.isInfinite(value)) {\n+                infiniteFound = true;\n+            }\n+        }\n+        return infiniteFound;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isNaN() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            if (Double.isNaN(iter.value())) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapAbs() {\n+        return copy().mapAbsToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapAbsToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.abs(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapAcos() {\n+        return copy().mapAcosToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapAcosToSelf() {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, Math.acos(getEntry(i)));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapAdd(double d) {\n+        return copy().mapAddToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapAddToSelf(double d) {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, getEntry(i) + d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapAsin() {\n+        return copy().mapAsinToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapAsinToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.asin(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapAtan() {\n+        return copy().mapAtanToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapAtanToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.atan(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapCbrt() {\n+        return copy().mapCbrtToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapCbrtToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.cbrt(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapCeil() {\n+        return copy().mapCeilToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapCeilToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.ceil(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapCos() {\n+        return copy().mapCosToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapCosToSelf() {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, Math.cos(getEntry(i)));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapCosh() {\n+        return copy().mapCoshToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapCoshToSelf() {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, Math.cosh(getEntry(i)));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapDivide(double d) {\n+        return copy().mapDivideToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapDivideToSelf(double d) {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), iter.value() / d);\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapExp() {\n+        return copy().mapExpToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapExpToSelf() {\n+        for (int i = 0; i < virtualSize; i++) {\n+            entries.put(i, Math.exp(entries.get(i)));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapExpm1() {\n+        return copy().mapExpm1ToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapExpm1ToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.expm1(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapFloor() {\n+        return copy().mapFloorToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapFloorToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.floor(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapInv() {\n+        return copy().mapInvToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapInvToSelf() {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, 1.0/getEntry(i));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapLog() {\n+        return copy().mapLogToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapLog10() {\n+        return copy().mapLog10ToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapLog10ToSelf() {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, Math.log10(getEntry(i)));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapLog1p() {\n+        return copy().mapLog1pToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapLog1pToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.log1p(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapLogToSelf() {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, Math.log(getEntry(i)));\n+        }\n+       return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapMultiply(double d) {\n+        return copy().mapMultiplyToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapMultiplyToSelf(double d) {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), iter.value() * d);\n+        }\n+        return this;\n+    }\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapPow(double d) {\n+        return copy().mapPowToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapPowToSelf(double d) {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.pow(iter.value(), d));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapRint() {\n+        return copy().mapRintToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapRintToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.rint(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapSignum() {\n+        return copy().mapSignumToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapSignumToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.signum(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapSin() {\n+        return copy().mapSinToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapSinToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.sin(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapSinh() {\n+        return copy().mapSinhToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapSinhToSelf() {\n+\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.sinh(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapSqrt() {\n+        return copy().mapSqrtToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapSqrtToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.sqrt(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapSubtract(double d) {\n+        return copy().mapSubtractToSelf(d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapSubtractToSelf(double d) {\n+        return mapAddToSelf(-d);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapTan() {\n+        return copy().mapTanToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapTanToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.tan(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapTanh() {\n+        return copy().mapTanhToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapTanhToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.tanh(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapUlp() {\n+        return copy().mapUlpToSelf();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector mapUlpToSelf() {\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), Math.ulp(iter.value()));\n+        }\n+        return this;\n+    }\n+\n+    /**\n+     * Optimized method to compute the outer product.\n+     * @param v The vector to comput the outer product on\n+     * @return The outer product of <code>this</code> and <code>v</code>\n+     * @throws IllegalArgumentException If the dimensions don't match\n+     */\n+    public OpenMapRealMatrix outerproduct(OpenMapRealVector v) throws IllegalArgumentException{\n+        checkVectorDimensions(v.getDimension());\n+        OpenMapRealMatrix res = new OpenMapRealMatrix(virtualSize, virtualSize);\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            Iterator iter2 = v.getEntries().iterator();\n+            while (iter2.hasNext()) {\n+                iter2.advance();\n+                res.setEntry(iter.key(), iter2.key(), iter.value()*iter2.value());\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix outerProduct(RealVector v)\n+            throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        if (v instanceof OpenMapRealVector) {\n+            return outerproduct((OpenMapRealVector)v);\n+        }\n+        RealMatrix res = new OpenMapRealMatrix(virtualSize, virtualSize);\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int row = iter.key();\n+            for (int col = 0; col < virtualSize; col++) {\n+                res.setEntry(row, col, iter.value()*v.getEntry(col));\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix outerProduct(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        RealMatrix res = new OpenMapRealMatrix(virtualSize, virtualSize);\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int row = iter.key();\n+            double value = iter.value();\n+            for (int col = 0; col < virtualSize; col++) {\n+                res.setEntry(row, col, value * v[col]);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector projection(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        return v.mapMultiply(dotProduct(v) / v.dotProduct(v));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector projection(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        return (OpenMapRealVector) projection(new OpenMapRealVector(v));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setEntry(int index, double value) throws MatrixIndexException {\n+        checkIndex(index);\n+        if (!isZero(value)) {\n+            entries.put(index, value);\n+        } else if (entries.containsKey(index)) {\n+            entries.remove(index);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, RealVector v) throws MatrixIndexException {\n+        checkIndex(index);\n+        checkIndex(index + v.getDimension() - 1);\n+        setSubVector(index, v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, double[] v) throws MatrixIndexException {\n+        checkIndex(index);\n+        checkIndex(index + v.length - 1);\n+        for (int i = 0; i < v.length; i++) {\n+            setEntry(i + index, v[i]);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(double value) {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, value);\n+        }\n+    }\n+\n+    /**\n+     * Optimized method to subtract OpenMapRealVectors.\n+     * @param v The vector to subtract from <code>this</code>\n+     * @return The difference of <code>this</code> and <code>v</code>\n+     * @throws IllegalArgumentException If the dimensions don't match\n+     */\n+    public OpenMapRealVector subtract(OpenMapRealVector v) throws IllegalArgumentException{\n+        checkVectorDimensions(v.getDimension());\n+        OpenMapRealVector res = (OpenMapRealVector)copy();\n+        Iterator iter = v.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (entries.containsKey(key)) {\n+                res.setEntry(key, entries.get(key) - iter.value());\n+            } else {\n+                res.setEntry(key, -iter.value());\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector subtract(RealVector v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        if (v instanceof OpenMapRealVector) {\n+            return subtract((OpenMapRealVector) v);\n+        }\n+        return subtract(v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector subtract(double[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        OpenMapRealVector res = new OpenMapRealVector(this);\n+        for (int i = 0; i < v.length; i++) {\n+            if (entries.containsKey(i)) {\n+                res.setEntry(i, entries.get(i) - v[i]);\n+            } else {\n+                res.setEntry(i, -v[i]);\n+            }\n+        }\n+        return res;\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    public OpenMapRealVector unitVector() {\n+        OpenMapRealVector res = copy();\n+        res.unitize();\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void unitize() {\n+        double norm = getNorm();\n+        if (isZero(norm)) {\n+            throw  MathRuntimeException.createArithmeticException(\"cannot normalize a zero norm vector\");\n+        }\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), iter.value() / norm);\n+        }\n+\n+    }\n+\n+    /**\n+     * Check if an index is valid.\n+     *\n+     * @param index\n+     *            index to check\n+     * @exception MatrixIndexException\n+     *                if index is not valid\n+     */\n+    private void checkIndex(final int index) throws MatrixIndexException {\n+        if (index < 0 || index >= getDimension()) {\n+            throw new MatrixIndexException(\n+                    \"index {0} out of allowed range [{1}, {2}]\",\n+                    index, 0, getDimension() - 1);\n+        }\n+    }\n+\n+    /**\n+     * Check if instance dimension is equal to some expected value.\n+     *\n+     * @param n\n+     *            expected dimension.\n+     * @exception IllegalArgumentException\n+     *                if the dimension is inconsistent with vector size\n+     */\n+    protected void checkVectorDimensions(int n) throws IllegalArgumentException {\n+        if (getDimension() != n) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    getDimension(), n);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] toArray() {\n+        return getData();\n+    }\n+\n+    /** {@inheritDoc} \n+     * <p> Implementation Note: This works on exact values, and as a result\n+     * it is possible for {@code a.subtract(b)} to be the zero vector, while\n+     * {@code a.hashCode() != b.hashCode()}.</p>\n+     */\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        long temp;\n+        temp = Double.doubleToLongBits(epsilon);\n+        result = prime * result + (int) (temp ^ (temp >>> 32));\n+        result = prime * result + virtualSize;\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            temp = Double.doubleToLongBits(iter.value());\n+            result = prime * result + (int) (temp ^ (temp >>32));\n+        }\n+        return result;\n+    }\n+\n+    /**  \n+     * <p> Implementation Note: This performs an exact comparison, and as a result\n+     * it is possible for {@code a.subtract(b}} to be the zero vector, while \n+     * {@code  a.equals(b) == false}.</p>\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (!(obj instanceof OpenMapRealVector)) {\n+            return false;\n+        }\n+        OpenMapRealVector other = (OpenMapRealVector) obj;\n+        if (virtualSize != other.virtualSize) {\n+            return false;\n+        }\n+        if (Double.doubleToLongBits(epsilon) !=\n+            Double.doubleToLongBits(other.epsilon)) {\n+            return false;\n+        }\n+        Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            double test = other.getEntry(iter.key());\n+            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(iter.value())) {\n+                return false;\n+            }\n+        }\n+        iter = other.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            double test = iter.value();\n+            if (Double.doubleToLongBits(test) != Double.doubleToLongBits(getEntry(iter.key()))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * \n+     * @return the percentage of none zero elements as a decimal percent.\n+     */\n+    public double getSparcity() {\n+        return (double)entries.size()/(double)getDimension();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/QRDecomposition.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+\n+/**\n+ * An interface to classes that implement an algorithm to calculate the \n+ * QR-decomposition of a real matrix.\n+ * <p>This interface is based on the class with similar name from the now defunct\n+ * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n+ * following changes:</p>\n+ * <ul>\n+ *   <li>a {@link #getQT() getQT} method has been added,</li>\n+ *   <li>the <code>solve</code> and <code>isFullRank</code> methods have been replaced\n+ *   by a {@link #getSolver() getSolver} method and the equivalent methods provided by\n+ *   the returned {@link DecompositionSolver}.</li>\n+ * </ul>\n+ *   \n+ * @see <a href=\"http://mathworld.wolfram.com/QRDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/QR_decomposition\">Wikipedia</a>\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public interface QRDecomposition {\n+\n+    /**\n+     * Returns the matrix R of the decomposition. \n+     * <p>R is an upper-triangular matrix</p>\n+     * @return the R matrix\n+     */\n+    RealMatrix getR();\n+\n+    /**\n+     * Returns the matrix Q of the decomposition.\n+     * <p>Q is an orthogonal matrix</p>\n+     * @return the Q matrix\n+     */\n+    RealMatrix getQ();\n+\n+    /**\n+     * Returns the transpose of the matrix Q of the decomposition.\n+     * <p>Q is an orthogonal matrix</p>\n+     * @return the Q matrix\n+     */\n+    RealMatrix getQT();\n+\n+    /**\n+     * Returns the Householder reflector vectors.\n+     * <p>H is a lower trapezoidal matrix whose columns represent\n+     * each successive Householder reflector vector. This matrix is used\n+     * to compute Q.</p>\n+     * @return a matrix containing the Householder reflector vectors\n+     */\n+    RealMatrix getH();\n+\n+    /**\n+     * Get a solver for finding the A &times; X = B solution in least square sense.\n+     * @return a solver\n+     */\n+    DecompositionSolver getSolver();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+\n+/**\n+ * Calculates the QR-decomposition of a matrix.\n+ * <p>The QR-decomposition of a matrix A consists of two matrices Q and R\n+ * that satisfy: A = QR, Q is orthogonal (Q<sup>T</sup>Q = I), and R is\n+ * upper triangular. If A is m&times;n, Q is m&times;m and R m&times;n.</p>\n+ * <p>This class compute the decomposition using Householder reflectors.</p>\n+ * <p>For efficiency purposes, the decomposition in packed form is transposed.\n+ * This allows inner loop to iterate inside rows, which is much more cache-efficient\n+ * in Java.</p>\n+ *\n+ * @see <a href=\"http://mathworld.wolfram.com/QRDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/QR_decomposition\">Wikipedia</a>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class QRDecompositionImpl implements QRDecomposition {\n+\n+    /**\n+     * A packed TRANSPOSED representation of the QR decomposition.\n+     * <p>The elements BELOW the diagonal are the elements of the UPPER triangular\n+     * matrix R, and the rows ABOVE the diagonal are the Householder reflector vectors\n+     * from which an explicit form of Q can be recomputed if desired.</p>\n+     */\n+    private double[][] qrt;\n+\n+    /** The diagonal elements of R. */\n+    private double[] rDiag;\n+\n+    /** Cached value of Q. */\n+    private RealMatrix cachedQ;\n+\n+    /** Cached value of QT. */\n+    private RealMatrix cachedQT;\n+\n+    /** Cached value of R. */\n+    private RealMatrix cachedR;\n+\n+    /** Cached value of H. */\n+    private RealMatrix cachedH;\n+\n+    /**\n+     * Calculates the QR-decomposition of the given matrix. \n+     * @param matrix The matrix to decompose.\n+     */\n+    public QRDecompositionImpl(RealMatrix matrix) {\n+\n+        final int m = matrix.getRowDimension();\n+        final int n = matrix.getColumnDimension();\n+        qrt = matrix.transpose().getData();\n+        rDiag = new double[Math.min(m, n)];\n+        cachedQ  = null;\n+        cachedQT = null;\n+        cachedR  = null;\n+        cachedH  = null;\n+\n+        /*\n+         * The QR decomposition of a matrix A is calculated using Householder\n+         * reflectors by repeating the following operations to each minor\n+         * A(minor,minor) of A:\n+         */\n+        for (int minor = 0; minor < Math.min(m, n); minor++) {\n+\n+            final double[] qrtMinor = qrt[minor];\n+\n+            /*\n+             * Let x be the first column of the minor, and a^2 = |x|^2.\n+             * x will be in the positions qr[minor][minor] through qr[m][minor].\n+             * The first column of the transformed minor will be (a,0,0,..)'\n+             * The sign of a is chosen to be opposite to the sign of the first\n+             * component of x. Let's find a:\n+             */\n+            double xNormSqr = 0;\n+            for (int row = minor; row < m; row++) {\n+                final double c = qrtMinor[row];\n+                xNormSqr += c * c;\n+            }\n+            final double a = (qrtMinor[minor] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+            rDiag[minor] = a;\n+\n+            if (a != 0.0) {\n+\n+                /*\n+                 * Calculate the normalized reflection vector v and transform\n+                 * the first column. We know the norm of v beforehand: v = x-ae\n+                 * so |v|^2 = <x-ae,x-ae> = <x,x>-2a<x,e>+a^2<e,e> =\n+                 * a^2+a^2-2a<x,e> = 2a*(a - <x,e>).\n+                 * Here <x, e> is now qr[minor][minor].\n+                 * v = x-ae is stored in the column at qr:\n+                 */\n+                qrtMinor[minor] -= a; // now |v|^2 = -2a*(qr[minor][minor])\n+\n+                /*\n+                 * Transform the rest of the columns of the minor:\n+                 * They will be transformed by the matrix H = I-2vv'/|v|^2.\n+                 * If x is a column vector of the minor, then\n+                 * Hx = (I-2vv'/|v|^2)x = x-2vv'x/|v|^2 = x - 2<x,v>/|v|^2 v.\n+                 * Therefore the transformation is easily calculated by\n+                 * subtracting the column vector (2<x,v>/|v|^2)v from x.\n+                 *\n+                 * Let 2<x,v>/|v|^2 = alpha. From above we have\n+                 * |v|^2 = -2a*(qr[minor][minor]), so\n+                 * alpha = -<x,v>/(a*qr[minor][minor])\n+                 */\n+                for (int col = minor+1; col < n; col++) {\n+                    final double[] qrtCol = qrt[col];\n+                    double alpha = 0;\n+                    for (int row = minor; row < m; row++) {\n+                        alpha -= qrtCol[row] * qrtMinor[row];\n+                    }\n+                    alpha /= a * qrtMinor[minor];\n+\n+                    // Subtract the column vector alpha*v from x.\n+                    for (int row = minor; row < m; row++) {\n+                        qrtCol[row] -= alpha * qrtMinor[row];\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getR() {\n+\n+        if (cachedR == null) {\n+\n+            // R is supposed to be m x n\n+            final int n = qrt.length;\n+            final int m = qrt[0].length;\n+            cachedR = MatrixUtils.createRealMatrix(m, n);\n+\n+            // copy the diagonal from rDiag and the upper triangle of qr\n+            for (int row = Math.min(m, n) - 1; row >= 0; row--) {\n+                cachedR.setEntry(row, row, rDiag[row]);\n+                for (int col = row + 1; col < n; col++) {\n+                    cachedR.setEntry(row, col, qrt[col][row]);\n+                }\n+            }\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedR;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getQ() {\n+        if (cachedQ == null) {\n+            cachedQ = getQT().transpose();\n+        }\n+        return cachedQ;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getQT() {\n+\n+        if (cachedQT == null) {\n+\n+            // QT is supposed to be m x m\n+            final int n = qrt.length;\n+            final int m = qrt[0].length;\n+            cachedQT = MatrixUtils.createRealMatrix(m, m);\n+\n+            /* \n+             * Q = Q1 Q2 ... Q_m, so Q is formed by first constructing Q_m and then \n+             * applying the Householder transformations Q_(m-1),Q_(m-2),...,Q1 in \n+             * succession to the result \n+             */ \n+            for (int minor = m - 1; minor >= Math.min(m, n); minor--) {\n+                cachedQT.setEntry(minor, minor, 1.0);\n+            }\n+\n+            for (int minor = Math.min(m, n)-1; minor >= 0; minor--){\n+                final double[] qrtMinor = qrt[minor];\n+                cachedQT.setEntry(minor, minor, 1.0);\n+                if (qrtMinor[minor] != 0.0) {\n+                    for (int col = minor; col < m; col++) {\n+                        double alpha = 0;\n+                        for (int row = minor; row < m; row++) {\n+                            alpha -= cachedQT.getEntry(col, row) * qrtMinor[row];\n+                        }\n+                        alpha /= rDiag[minor] * qrtMinor[minor];\n+\n+                        for (int row = minor; row < m; row++) {\n+                            cachedQT.addToEntry(col, row, -alpha * qrtMinor[row]);\n+                        }\n+                    }\n+                }\n+            }\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedQT;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getH() {\n+\n+        if (cachedH == null) {\n+\n+            final int n = qrt.length;\n+            final int m = qrt[0].length;\n+            cachedH = MatrixUtils.createRealMatrix(m, n);\n+            for (int i = 0; i < m; ++i) {\n+                for (int j = 0; j < Math.min(i + 1, n); ++j) {\n+                    cachedH.setEntry(i, j, qrt[j][i] / -rDiag[j]);\n+                }\n+            }\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedH;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DecompositionSolver getSolver() {\n+        return new Solver(qrt, rDiag);\n+    }\n+\n+    /** Specialized solver. */\n+    private static class Solver implements DecompositionSolver {\n+    \n+        /**\n+         * A packed TRANSPOSED representation of the QR decomposition.\n+         * <p>The elements BELOW the diagonal are the elements of the UPPER triangular\n+         * matrix R, and the rows ABOVE the diagonal are the Householder reflector vectors\n+         * from which an explicit form of Q can be recomputed if desired.</p>\n+         */\n+        private final double[][] qrt;\n+\n+        /** The diagonal elements of R. */\n+        private final double[] rDiag;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         * @param qrt packed TRANSPOSED representation of the QR decomposition\n+         * @param rDiag diagonal elements of R\n+         */\n+        private Solver(final double[][] qrt, final double[] rDiag) {\n+            this.qrt   = qrt;\n+            this.rDiag = rDiag;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean isNonSingular() {\n+\n+            for (double diag : rDiag) {\n+                if (diag == 0) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[] solve(double[] b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+            final int n = qrt.length;\n+            final int m = qrt[0].length;\n+            if (b.length != m) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"vector length mismatch: got {0} but expected {1}\",\n+                        b.length, m);\n+            }\n+            if (!isNonSingular()) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final double[] x = new double[n];\n+            final double[] y = b.clone();\n+\n+            // apply Householder transforms to solve Q.y = b\n+            for (int minor = 0; minor < Math.min(m, n); minor++) {\n+\n+                final double[] qrtMinor = qrt[minor];\n+                double dotProduct = 0;\n+                for (int row = minor; row < m; row++) {\n+                    dotProduct += y[row] * qrtMinor[row];\n+                }\n+                dotProduct /= rDiag[minor] * qrtMinor[minor];\n+\n+                for (int row = minor; row < m; row++) {\n+                    y[row] += dotProduct * qrtMinor[row];\n+                }\n+\n+            }\n+\n+            // solve triangular system R.x = y\n+            for (int row = rDiag.length - 1; row >= 0; --row) {\n+                y[row] /= rDiag[row];\n+                final double yRow   = y[row];\n+                final double[] qrtRow = qrt[row];\n+                x[row] = yRow;\n+                for (int i = 0; i < row; i++) {\n+                    y[i] -= yRow * qrtRow[i];\n+                }\n+            }\n+\n+            return x;\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealVector solve(RealVector b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+            try {\n+                return solve((ArrayRealVector) b);\n+            } catch (ClassCastException cce) {\n+                return new ArrayRealVector(solve(b.getData()), false);\n+            }\n+        }\n+\n+        /** Solve the linear equation A &times; X = B.\n+         * <p>The A matrix is implicit here. It is </p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a vector X that minimizes the two norm of A &times; X - B\n+         * @throws IllegalArgumentException if matrices dimensions don't match\n+         * @throws InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public ArrayRealVector solve(ArrayRealVector b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+            return new ArrayRealVector(solve(b.getDataRef()), false);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix solve(RealMatrix b)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+            final int n = qrt.length;\n+            final int m = qrt[0].length;\n+            if (b.getRowDimension() != m) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n+            }\n+            if (!isNonSingular()) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            final int columns        = b.getColumnDimension();\n+            final int blockSize      = BlockRealMatrix.BLOCK_SIZE;\n+            final int cBlocks        = (columns + blockSize - 1) / blockSize;\n+            final double[][] xBlocks = BlockRealMatrix.createBlocksLayout(n, columns);\n+            final double[][] y       = new double[b.getRowDimension()][blockSize];\n+            final double[]   alpha   = new double[blockSize];\n+\n+            for (int kBlock = 0; kBlock < cBlocks; ++kBlock) {\n+                final int kStart = kBlock * blockSize;\n+                final int kEnd   = Math.min(kStart + blockSize, columns);\n+                final int kWidth = kEnd - kStart;\n+\n+                // get the right hand side vector\n+                b.copySubMatrix(0, m - 1, kStart, kEnd - 1, y);\n+\n+                // apply Householder transforms to solve Q.y = b\n+                for (int minor = 0; minor < Math.min(m, n); minor++) {\n+                    final double[] qrtMinor = qrt[minor];\n+                    final double factor     = 1.0 / (rDiag[minor] * qrtMinor[minor]); \n+\n+                    Arrays.fill(alpha, 0, kWidth, 0.0);\n+                    for (int row = minor; row < m; ++row) {\n+                        final double   d    = qrtMinor[row];\n+                        final double[] yRow = y[row];\n+                        for (int k = 0; k < kWidth; ++k) {\n+                            alpha[k] += d * yRow[k];\n+                        }\n+                    }\n+                    for (int k = 0; k < kWidth; ++k) {\n+                        alpha[k] *= factor;\n+                    }\n+\n+                    for (int row = minor; row < m; ++row) {\n+                        final double   d    = qrtMinor[row];\n+                        final double[] yRow = y[row];\n+                        for (int k = 0; k < kWidth; ++k) {\n+                            yRow[k] += alpha[k] * d;\n+                        }\n+                    }\n+\n+                }\n+\n+                // solve triangular system R.x = y\n+                for (int j = rDiag.length - 1; j >= 0; --j) {\n+                    final int      jBlock = j / blockSize;\n+                    final int      jStart = jBlock * blockSize;\n+                    final double   factor = 1.0 / rDiag[j];\n+                    final double[] yJ     = y[j];\n+                    final double[] xBlock = xBlocks[jBlock * cBlocks + kBlock];\n+                    for (int k = 0, index = (j - jStart) * kWidth; k < kWidth; ++k, ++index) {\n+                        yJ[k]        *= factor;\n+                        xBlock[index] = yJ[k];\n+                    }\n+\n+                    final double[] qrtJ = qrt[j];\n+                    for (int i = 0; i < j; ++i) {\n+                        final double rIJ  = qrtJ[i];\n+                        final double[] yI = y[i];\n+                        for (int k = 0; k < kWidth; ++k) {\n+                            yI[k] -= yJ[k] * rIJ;\n+                        }\n+                    }\n+\n+                }\n+\n+            }\n+\n+            return new BlockRealMatrix(n, columns, xBlocks, false);\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public RealMatrix getInverse()\n+        throws InvalidMatrixException {\n+            return solve(MatrixUtils.createRealIdentityMatrix(rDiag.length));\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+\n+/**\n+ * Interface defining a real-valued matrix with basic algebraic operations.\n+ * <p>\n+ * Matrix element indexing is 0-based -- e.g., <code>getEntry(0, 0)</code>\n+ * returns the element in the first row, first column of the matrix.</p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public interface RealMatrix extends AnyMatrix {\n+\n+    /**\n+     * Create a new RealMatrix of the same type as the instance with the supplied\n+     * row and column dimensions.\n+     *\n+     * @param rowDimension  the number of rows in the new matrix\n+     * @param columnDimension  the number of columns in the new matrix\n+     * @return a new matrix of the same type as the instance\n+     * @throws IllegalArgumentException if row or column dimension is not positive\n+     * @since 2.0\n+     */\n+    RealMatrix createMatrix(final int rowDimension, final int columnDimension);\n+\n+    /**\n+     * Returns a (deep) copy of this.\n+     *\n+     * @return matrix copy\n+     */\n+    RealMatrix copy();\n+\n+    /**\n+     * Compute the sum of this and m.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    RealMatrix add(RealMatrix m) throws IllegalArgumentException;\n+\n+    /**\n+     * Compute this minus m.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    RealMatrix subtract(RealMatrix m) throws IllegalArgumentException;\n+\n+     /**\n+     * Returns the result of adding d to each entry of this.\n+     *\n+     * @param d    value to be added to each entry\n+     * @return     d + this\n+     */\n+    RealMatrix scalarAdd(double d);\n+\n+    /**\n+     * Returns the result multiplying each entry of this by d.\n+     *\n+     * @param d    value to multiply all entries by\n+     * @return     d * this\n+     */\n+    RealMatrix scalarMultiply(double d);\n+\n+    /**\n+     * Returns the result of postmultiplying this by m.\n+     *\n+     * @param m    matrix to postmultiply by\n+     * @return     this * m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    RealMatrix multiply(RealMatrix m) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the result premultiplying this by <code>m</code>.\n+     * @param m    matrix to premultiply by\n+     * @return     m * this\n+     * @throws     IllegalArgumentException\n+     *             if rowDimension(this) != columnDimension(m)\n+     */\n+    public RealMatrix preMultiply(RealMatrix m) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns matrix entries as a two-dimensional array.\n+     *\n+     * @return    2-dimensional array of entries\n+     */\n+    double[][] getData();\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/MaximumAbsoluteRowSumNorm.html\">\n+     * maximum absolute row sum norm</a> of the matrix.\n+     *\n+     * @return norm\n+     */\n+    double getNorm();\n+    \n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/FrobeniusNorm.html\">\n+     * Frobenius norm</a> of the matrix.\n+     *\n+     * @return norm\n+     */\n+    double getFrobeniusNorm();\n+    \n+    /**\n+     * Gets a submatrix. Rows and columns are indicated\n+     * counting from 0 to n-1.\n+     *\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     * @return The subMatrix containing the data of the\n+     *         specified rows and columns\n+     * @exception MatrixIndexException  if the indices are not valid\n+     */\n+   RealMatrix getSubMatrix(int startRow, int endRow, int startColumn, int endColumn)\n+       throws MatrixIndexException;\n+   \n+   /**\n+    * Gets a submatrix. Rows and columns are indicated\n+    * counting from 0 to n-1.\n+    *\n+    * @param selectedRows Array of row indices.\n+    * @param selectedColumns Array of column indices.\n+    * @return The subMatrix containing the data in the\n+    *         specified rows and columns\n+    * @exception MatrixIndexException if row or column selections are not valid\n+    */\n+   RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n+       throws MatrixIndexException;\n+\n+   /**\n+    * Copy a submatrix. Rows and columns are indicated\n+    * counting from 0 to n-1.\n+    *\n+    * @param startRow Initial row index\n+    * @param endRow Final row index (inclusive)\n+    * @param startColumn Initial column index\n+    * @param endColumn Final column index (inclusive)\n+    * @param destination The arrays where the submatrix data should be copied\n+    * (if larger than rows/columns counts, only the upper-left part will be used)\n+    * @exception MatrixIndexException if the indices are not valid\n+    * @exception IllegalArgumentException if the destination array is too small\n+    */\n+  void copySubMatrix(int startRow, int endRow, int startColumn, int endColumn,\n+                     double[][] destination)\n+      throws MatrixIndexException, IllegalArgumentException;\n+  \n+  /**\n+   * Copy a submatrix. Rows and columns are indicated\n+   * counting from 0 to n-1.\n+   *\n+    * @param selectedRows Array of row indices.\n+    * @param selectedColumns Array of column indices.\n+   * @param destination The arrays where the submatrix data should be copied\n+   * (if larger than rows/columns counts, only the upper-left part will be used)\n+   * @exception MatrixIndexException if the indices are not valid\n+   * @exception IllegalArgumentException if the destination array is too small\n+   */\n+  void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination)\n+      throws MatrixIndexException, IllegalArgumentException;\n+ \n+   /**\n+    * Replace the submatrix starting at <code>row, column</code> using data in\n+    * the input <code>subMatrix</code> array. Indexes are 0-based.\n+    * <p> \n+    * Example:<br>\n+    * Starting with <pre>\n+    * 1  2  3  4\n+    * 5  6  7  8\n+    * 9  0  1  2\n+    * </pre>\n+    * and <code>subMatrix = {{3, 4} {5,6}}</code>, invoking \n+    * <code>setSubMatrix(subMatrix,1,1))</code> will result in <pre>\n+    * 1  2  3  4\n+    * 5  3  4  8\n+    * 9  5  6  2\n+    * </pre></p>\n+    * \n+    * @param subMatrix  array containing the submatrix replacement data\n+    * @param row  row coordinate of the top, left element to be replaced\n+    * @param column  column coordinate of the top, left element to be replaced\n+    * @throws MatrixIndexException  if subMatrix does not fit into this \n+    *    matrix from element in (row, column) \n+    * @throws IllegalArgumentException if <code>subMatrix</code> is not rectangular\n+    *  (not all rows have the same length) or empty\n+    * @throws NullPointerException if <code>subMatrix</code> is null\n+    * @since 2.0\n+    */\n+   void setSubMatrix(double[][] subMatrix, int row, int column) \n+       throws MatrixIndexException;\n+\n+   /**\n+    * Returns the entries in row number <code>row</code>\n+    * as a row matrix.  Row indices start at 0.\n+    *\n+    * @param row the row to be fetched\n+    * @return row matrix\n+    * @throws MatrixIndexException if the specified row index is invalid\n+    */\n+   RealMatrix getRowMatrix(int row) throws MatrixIndexException;\n+   \n+   /**\n+    * Sets the entries in row number <code>row</code>\n+    * as a row matrix.  Row indices start at 0.\n+    *\n+    * @param row the row to be set\n+    * @param matrix row matrix (must have one row and the same number of columns\n+    * as the instance)\n+    * @throws MatrixIndexException if the specified row index is invalid\n+    * @throws InvalidMatrixException if the matrix dimensions do not match one\n+    * instance row\n+    */\n+   void setRowMatrix(int row, RealMatrix matrix)\n+       throws MatrixIndexException, InvalidMatrixException;\n+   \n+   /**\n+    * Returns the entries in column number <code>column</code>\n+    * as a column matrix.  Column indices start at 0.\n+    *\n+    * @param column the column to be fetched\n+    * @return column matrix\n+    * @throws MatrixIndexException if the specified column index is invalid\n+    */\n+   RealMatrix getColumnMatrix(int column) throws MatrixIndexException;\n+\n+   /**\n+    * Sets the entries in column number <code>column</code>\n+    * as a column matrix.  Column indices start at 0.\n+    *\n+    * @param column the column to be set\n+    * @param matrix column matrix (must have one column and the same number of rows\n+    * as the instance)\n+    * @throws MatrixIndexException if the specified column index is invalid\n+    * @throws InvalidMatrixException if the matrix dimensions do not match one\n+    * instance column\n+    */\n+   void setColumnMatrix(int column, RealMatrix matrix)\n+       throws MatrixIndexException, InvalidMatrixException;\n+   \n+   /**\n+    * Returns the entries in row number <code>row</code>\n+    * as a vector.  Row indices start at 0.\n+    *\n+    * @param row the row to be fetched\n+    * @return row vector\n+    * @throws MatrixIndexException if the specified row index is invalid\n+    */\n+   RealVector getRowVector(int row) throws MatrixIndexException;\n+\n+   /**\n+    * Sets the entries in row number <code>row</code>\n+    * as a vector.  Row indices start at 0.\n+    *\n+    * @param row the row to be set\n+    * @param vector row vector (must have the same number of columns\n+    * as the instance)\n+    * @throws MatrixIndexException if the specified row index is invalid\n+    * @throws InvalidMatrixException if the vector dimension does not match one\n+    * instance row\n+    */\n+   void setRowVector(int row, RealVector vector)\n+       throws MatrixIndexException, InvalidMatrixException;\n+   \n+   /**\n+    * Returns the entries in column number <code>column</code>\n+    * as a vector.  Column indices start at 0.\n+    *\n+    * @param column the column to be fetched\n+    * @return column vector\n+    * @throws MatrixIndexException if the specified column index is invalid\n+    */\n+   RealVector getColumnVector(int column) throws MatrixIndexException;\n+\n+   /**\n+    * Sets the entries in column number <code>column</code>\n+    * as a vector.  Column indices start at 0.\n+    *\n+    * @param column the column to be set\n+    * @param vector column vector (must have the same number of rows as the instance)\n+    * @throws MatrixIndexException if the specified column index is invalid\n+    * @throws InvalidMatrixException if the vector dimension does not match one\n+    * instance column\n+    */\n+   void setColumnVector(int column, RealVector vector)\n+       throws MatrixIndexException, InvalidMatrixException;\n+   \n+    /**\n+     * Returns the entries in row number <code>row</code> as an array.\n+     * <p>\n+     * Row indices start at 0.  A <code>MatrixIndexException</code> is thrown\n+     * unless <code>0 <= row < rowDimension.</code></p>\n+     *\n+     * @param row the row to be fetched\n+     * @return array of entries in the row\n+     * @throws MatrixIndexException if the specified row index is not valid\n+     */\n+    double[] getRow(int row) throws MatrixIndexException;\n+\n+    /**\n+     * Sets the entries in row number <code>row</code>\n+     * as a row matrix.  Row indices start at 0.\n+     *\n+     * @param row the row to be set\n+     * @param array row matrix (must have the same number of columns as the instance)\n+     * @throws MatrixIndexException if the specified row index is invalid\n+     * @throws InvalidMatrixException if the array size does not match one\n+     * instance row\n+     */\n+    void setRow(int row, double[] array)\n+        throws MatrixIndexException, InvalidMatrixException;\n+    \n+    /**\n+     * Returns the entries in column number <code>col</code> as an array.\n+     * <p>\n+     * Column indices start at 0.  A <code>MatrixIndexException</code> is thrown\n+     * unless <code>0 <= column < columnDimension.</code></p>\n+     *\n+     * @param column the column to be fetched\n+     * @return array of entries in the column\n+     * @throws MatrixIndexException if the specified column index is not valid\n+     */\n+    double[] getColumn(int column) throws MatrixIndexException;\n+\n+    /**\n+     * Sets the entries in column number <code>column</code>\n+     * as a column matrix.  Column indices start at 0.\n+     *\n+     * @param column the column to be set\n+     * @param array column array (must have the same number of rows as the instance)\n+     * @throws MatrixIndexException if the specified column index is invalid\n+     * @throws InvalidMatrixException if the array size does not match one\n+     * instance column\n+     */\n+    void setColumn(int column, double[] array)\n+        throws MatrixIndexException, InvalidMatrixException;\n+    \n+    /**\n+     * Returns the entry in the specified row and column.\n+     * <p>\n+     * Row and column indices start at 0 and must satisfy \n+     * <ul>\n+     * <li><code>0 <= row < rowDimension</code></li>\n+     * <li><code> 0 <= column < columnDimension</code></li>\n+     * </ul>\n+     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n+     * \n+     * @param row  row location of entry to be fetched\n+     * @param column  column location of entry to be fetched\n+     * @return matrix entry in row,column\n+     * @throws MatrixIndexException if the row or column index is not valid\n+     */\n+    double getEntry(int row, int column) throws MatrixIndexException;\n+\n+    /**\n+     * Set the entry in the specified row and column.\n+     * <p>\n+     * Row and column indices start at 0 and must satisfy \n+     * <ul>\n+     * <li><code>0 <= row < rowDimension</code></li>\n+     * <li><code> 0 <= column < columnDimension</code></li>\n+     * </ul>\n+     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n+     * \n+     * @param row  row location of entry to be set\n+     * @param column  column location of entry to be set\n+     * @param value matrix entry to be set in row,column\n+     * @throws MatrixIndexException if the row or column index is not valid\n+     * @since 2.0\n+     */\n+    void setEntry(int row, int column, double value) throws MatrixIndexException;\n+\n+    /**\n+     * Change an entry in the specified row and column.\n+     * <p>\n+     * Row and column indices start at 0 and must satisfy \n+     * <ul>\n+     * <li><code>0 <= row < rowDimension</code></li>\n+     * <li><code> 0 <= column < columnDimension</code></li>\n+     * </ul>\n+     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n+     * \n+     * @param row  row location of entry to be set\n+     * @param column  column location of entry to be set\n+     * @param increment value to add to the current matrix entry in row,column\n+     * @throws MatrixIndexException if the row or column index is not valid\n+     * @since 2.0\n+     */\n+    void addToEntry(int row, int column, double increment) throws MatrixIndexException;\n+\n+    /**\n+     * Change an entry in the specified row and column.\n+     * <p>\n+     * Row and column indices start at 0 and must satisfy \n+     * <ul>\n+     * <li><code>0 <= row < rowDimension</code></li>\n+     * <li><code> 0 <= column < columnDimension</code></li>\n+     * </ul>\n+     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n+     * \n+     * @param row  row location of entry to be set\n+     * @param column  column location of entry to be set\n+     * @param factor multiplication factor for the current matrix entry in row,column\n+     * @throws MatrixIndexException if the row or column index is not valid\n+     * @since 2.0\n+     */\n+    void multiplyEntry(int row, int column, double factor) throws MatrixIndexException;\n+\n+    /**\n+     * Returns the transpose of this matrix.\n+     *\n+     * @return transpose matrix\n+     */\n+    RealMatrix transpose();\n+\n+    /**\n+     * Returns the inverse of this matrix.\n+     *\n+     * @return inverse matrix\n+     * @throws InvalidMatrixException if  this is not invertible\n+     * @deprecated as of release 2.0, replaced by <code>\n+     * {@link LUDecompositionImpl#LUDecompositionImpl(RealMatrix)\n+     * new LUDecompositionImpl(m)}.{@link LUDecomposition#getSolver()\n+     * getSolver()}.{@link DecompositionSolver#getInverse()\n+     * getInverse()}</code>\n+     */\n+    @Deprecated\n+    RealMatrix inverse() throws InvalidMatrixException;\n+\n+    /**\n+     * Returns the determinant of this matrix.\n+     *\n+     * @return determinant\n+     * @deprecated as of release 2.0, replaced by <code>\n+     * {@link LUDecompositionImpl#LUDecompositionImpl(RealMatrix)\n+     * new LUDecompositionImpl(m)}.{@link LUDecomposition#getDeterminant()\n+     * getDeterminant()}</code>\n+     */\n+    @Deprecated\n+    double getDeterminant();\n+\n+    /**\n+     * Is this a singular matrix?\n+     * @return true if the matrix is singular\n+     * @deprecated as of release 2.0, replaced by the boolean negation of\n+     * <code>{@link LUDecompositionImpl#LUDecompositionImpl(RealMatrix)\n+     * new LUDecompositionImpl(m)}.{@link LUDecomposition#getSolver()\n+     * getSolver()}.{@link DecompositionSolver#isNonSingular()\n+     * isNonSingular()}</code>\n+     */\n+    @Deprecated\n+    boolean isSingular();\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/MatrixTrace.html\">\n+     * trace</a> of the matrix (the sum of the elements on the main diagonal).\n+     *\n+     * @return trace\n+     * @throws NonSquareMatrixException if the matrix is not square\n+     */\n+    double getTrace() throws NonSquareMatrixException;\n+\n+    /**\n+     * Returns the result of multiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the vector to operate on\n+     * @return this*v\n+     * @throws IllegalArgumentException if columnDimension != v.size()\n+     */\n+    double[] operate(double[] v) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the result of multiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the vector to operate on\n+     * @return this*v\n+     * @throws IllegalArgumentException if columnDimension != v.size()\n+     */\n+    RealVector operate(RealVector v) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the row vector to premultiply by\n+     * @return v*this\n+     * @throws IllegalArgumentException if rowDimension != v.size()\n+     */\n+    double[] preMultiply(double[] v) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the row vector to premultiply by\n+     * @return v*this\n+     * @throws IllegalArgumentException if rowDimension != v.size()\n+     */\n+    RealVector preMultiply(RealVector v) throws IllegalArgumentException;\n+\n+    /**\n+     * Visit (and possibly change) all matrix entries in row order.\n+     * <p>Row order starts at upper left and iterating through all elements\n+     * of a row from left to right before going to the leftmost element\n+     * of the next row.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInRowOrder(RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) all matrix entries in row order.\n+     * <p>Row order starts at upper left and iterating through all elements\n+     * of a row from left to right before going to the leftmost element\n+     * of the next row.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInRowOrder(RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) some matrix entries in row order.\n+     * <p>Row order starts at upper left and iterating through all elements\n+     * of a row from left to right before going to the leftmost element\n+     * of the next row.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInRowOrder(RealMatrixChangingVisitor visitor,\n+                          int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) some matrix entries in row order.\n+     * <p>Row order starts at upper left and iterating through all elements\n+     * of a row from left to right before going to the leftmost element\n+     * of the next row.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInRowOrder(RealMatrixPreservingVisitor visitor,\n+                          int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) all matrix entries in column order.\n+     * <p>Column order starts at upper left and iterating through all elements\n+     * of a column from top to bottom before going to the topmost element\n+     * of the next column.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInColumnOrder(RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) all matrix entries in column order.\n+     * <p>Column order starts at upper left and iterating through all elements\n+     * of a column from top to bottom before going to the topmost element\n+     * of the next column.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInColumnOrder(RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) some matrix entries in column order.\n+     * <p>Column order starts at upper left and iterating through all elements\n+     * of a column from top to bottom before going to the topmost element\n+     * of the next column.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInColumnOrder(RealMatrixChangingVisitor visitor,\n+                             int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) some matrix entries in column order.\n+     * <p>Column order starts at upper left and iterating through all elements\n+     * of a column from top to bottom before going to the topmost element\n+     * of the next column.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInColumnOrder(RealMatrixPreservingVisitor visitor,\n+                             int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) all matrix entries using the fastest possible order.\n+     * <p>The fastest walking order depends on the exact matrix class. It may be\n+     * different from traditional row or column orders.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInOptimizedOrder(RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) all matrix entries using the fastest possible order.\n+     * <p>The fastest walking order depends on the exact matrix class. It may be\n+     * different from traditional row or column orders.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInOptimizedOrder(RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * Visit (and possibly change) some matrix entries using the fastest possible order.\n+     * <p>The fastest walking order depends on the exact matrix class. It may be\n+     * different from traditional row or column orders.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixChangingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInOptimizedOrder(RealMatrixChangingVisitor visitor,\n+                                int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Visit (but don't change) some matrix entries using the fastest possible order.\n+     * <p>The fastest walking order depends on the exact matrix class. It may be\n+     * different from traditional row or column orders.</p>\n+     * @param visitor visitor used to process all matrix entries\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     * @exception  MatrixVisitorException if the visitor cannot process an entry\n+     * @exception MatrixIndexException  if the indices are not valid\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInRowOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInRowOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInColumnOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @see #walkInColumnOrder(RealMatrixPreservingVisitor, int, int, int, int)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixPreservingVisitor)\n+     * @see #walkInOptimizedOrder(RealMatrixChangingVisitor, int, int, int, int)\n+     * @return the value returned by {@link RealMatrixPreservingVisitor#end()} at the end\n+     * of the walk\n+     */\n+    double walkInOptimizedOrder(RealMatrixPreservingVisitor visitor,\n+                                int startRow, int endRow, int startColumn, int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException;\n+\n+    /**\n+     * Returns the solution vector for a linear system with coefficient\n+     * matrix = this and constant vector = <code>b</code>.\n+     *\n+     * @param b  constant vector\n+     * @return vector of solution values to AX = b, where A is *this\n+     * @throws IllegalArgumentException if this.rowDimension != b.length\n+     * @throws InvalidMatrixException if this matrix is not square or is singular\n+     * @deprecated as of release 2.0, replaced by {@link DecompositionSolver#solve(double[])}\n+     */\n+    @Deprecated\n+    double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException;\n+\n+    /**\n+     * Returns a matrix of (column) solution vectors for linear systems with\n+     * coefficient matrix = this and constant vectors = columns of\n+     * <code>b</code>.\n+     *\n+     * @param b  matrix of constant vectors forming RHS of linear systems to\n+     * to solve\n+     * @return matrix of solution vectors\n+     * @throws IllegalArgumentException if this.rowDimension != row dimension\n+     * @throws InvalidMatrixException if this matrix is not square or is singular\n+     * @deprecated as of release 2.0, replaced by {@link DecompositionSolver#solve(RealMatrix)}\n+     */\n+    @Deprecated\n+    RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrixChangingVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Interface defining a visitor for matrix entries.\n+ * \n+ * @see DefaultRealMatrixChangingVisitor\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface RealMatrixChangingVisitor {\n+\n+    /**\n+     * Start visiting a matrix.\n+     * <p>This method is called once before any entry of the matrix is visited.</p>\n+     * @param rows number of rows of the matrix\n+     * @param columns number of columns of the matrix\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     */\n+    void start(int rows, int columns,\n+               int startRow, int endRow, int startColumn, int endColumn);\n+\n+    /**\n+     * Visit one matrix entry.\n+     * @param row row index of the entry\n+     * @param column column index of the entry\n+     * @param value current value of the entry\n+     * @return the new value to be set for the entry\n+     * @throws MatrixVisitorException if something wrong occurs\n+     */\n+    double visit(int row, int column, double value)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * End visiting a matrix.\n+     * <p>This method is called once after all entries of the matrix have been visited.</p>\n+     * @return the value that the <code>walkInXxxOrder</code> must return\n+     */\n+    double end();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Implementation of RealMatrix using a double[][] array to store entries and\n+ * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n+ * LU decomposition</a> to support linear system\n+ * solution and inverse.\n+ * <p>\n+ * The LU decomposition is performed as needed, to support the following operations: <ul>\n+ * <li>solve</li>\n+ * <li>isSingular</li>\n+ * <li>getDeterminant</li>\n+ * <li>inverse</li> </ul></p>\n+ * <p>\n+ * <strong>Usage notes</strong>:<br>\n+ * <ul><li>\n+ * The LU decomposition is cached and reused on subsequent calls.   \n+ * If data are modified via references to the underlying array obtained using\n+ * <code>getDataRef()</code>, then the stored LU decomposition will not be\n+ * discarded.  In this case, you need to explicitly invoke \n+ * <code>LUDecompose()</code> to recompute the decomposition\n+ * before using any of the methods above.</li>\n+ * <li>\n+ * As specified in the {@link RealMatrix} interface, matrix element indexing\n+ * is 0-based -- e.g., <code>getEntry(0, 0)</code>\n+ * returns the element in the first row, first column of the matrix.</li></ul>\n+ * </p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @deprecated as of 2.0 replaced by {@link Array2DRowRealMatrix}\n+ */\n+@Deprecated\n+public class RealMatrixImpl extends AbstractRealMatrix implements Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -1067294169172445528L;\n+\n+    /** Entries of the matrix */\n+    protected double data[][];\n+\n+    /**\n+     * Creates a matrix with no data\n+     */\n+    public RealMatrixImpl() {\n+    }\n+\n+    /**\n+     * Create a new RealMatrix with the supplied row and column dimensions.\n+     *\n+     * @param rowDimension  the number of rows in the new matrix\n+     * @param columnDimension  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not\n+     *  positive\n+     */\n+    public RealMatrixImpl(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        super(rowDimension, columnDimension);\n+        data = new double[rowDimension][columnDimension];\n+    }\n+\n+    /**\n+     * Create a new RealMatrix using the input array as the underlying\n+     * data array.\n+     * <p>The input array is copied, not referenced. This constructor has\n+     * the same effect as calling {@link #RealMatrixImpl(double[][], boolean)}\n+     * with the second argument set to <code>true</code>.</p>\n+     *\n+     * @param d data for new matrix\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #RealMatrixImpl(double[][], boolean)\n+     */\n+    public RealMatrixImpl(final double[][] d)\n+        throws IllegalArgumentException, NullPointerException {\n+        copyIn(d);\n+    }\n+\n+    /**\n+     * Create a new RealMatrix using the input array as the underlying\n+     * data array.\n+     * <p>If an array is built specially in order to be embedded in a\n+     * RealMatrix and not used directly, the <code>copyArray</code> may be\n+     * set to <code>false</code. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.</p>\n+     * @param d data for new matrix\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     * @throws IllegalArgumentException if <code>d</code> is not rectangular\n+     *  (not all rows have the same length) or empty\n+     * @throws NullPointerException if <code>d</code> is null\n+     * @see #RealMatrixImpl(double[][])\n+     */\n+    public RealMatrixImpl(final double[][] d, final boolean copyArray)\n+        throws IllegalArgumentException, NullPointerException {\n+        if (copyArray) {\n+            copyIn(d);\n+        } else {\n+            if (d == null) {\n+                throw new NullPointerException();\n+            }   \n+            final int nRows = d.length;\n+            if (nRows == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            }\n+            final int nCols = d[0].length;\n+            if (nCols == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            }\n+            for (int r = 1; r < nRows; r++) {\n+                if (d[r].length != nCols) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"some rows have length {0} while others have length {1}\",\n+                            nCols, d[r].length);\n+                }\n+            }       \n+            data = d;\n+        }\n+    }\n+\n+    /**\n+     * Create a new (column) RealMatrix using <code>v</code> as the\n+     * data for the unique column of the <code>v.length x 1</code> matrix\n+     * created.\n+     * <p>The input array is copied, not referenced.</p>\n+     *\n+     * @param v column vector holding data for new matrix\n+     */\n+    public RealMatrixImpl(final double[] v) {\n+        final int nRows = v.length;\n+        data = new double[nRows][1];\n+        for (int row = 0; row < nRows; row++) {\n+            data[row][0] = v[row];\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix createMatrix(final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        return new RealMatrixImpl(rowDimension, columnDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix copy() {\n+        return new RealMatrixImpl(copyOut(), false);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix add(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return add((RealMatrixImpl) m);\n+        } catch (ClassCastException cce) {\n+            return super.add(m);\n+        }\n+    }\n+\n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public RealMatrixImpl add(final RealMatrixImpl m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkAdditionCompatible(this, m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final double[][] outData = new double[rowCount][columnCount];\n+        for (int row = 0; row < rowCount; row++) {\n+            final double[] dataRow    = data[row];\n+            final double[] mRow       = m.data[row];\n+            final double[] outDataRow = outData[row];\n+            for (int col = 0; col < columnCount; col++) {\n+                outDataRow[col] = dataRow[col] + mRow[col];\n+            }\n+        }\n+\n+        return new RealMatrixImpl(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix subtract(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return subtract((RealMatrixImpl) m);\n+        } catch (ClassCastException cce) {\n+            return super.subtract(m);\n+        }\n+    }\n+\n+    /**\n+     * Compute  this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @throws  IllegalArgumentException if m is not the same size as this\n+     */\n+    public RealMatrixImpl subtract(final RealMatrixImpl m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkSubtractionCompatible(this, m);\n+\n+        final int rowCount    = getRowDimension();\n+        final int columnCount = getColumnDimension();\n+        final double[][] outData = new double[rowCount][columnCount];\n+        for (int row = 0; row < rowCount; row++) {\n+            final double[] dataRow    = data[row];\n+            final double[] mRow       = m.data[row];\n+            final double[] outDataRow = outData[row];\n+            for (int col = 0; col < columnCount; col++) {\n+                outDataRow[col] = dataRow[col] - mRow[col];\n+            }\n+        }\n+\n+        return new RealMatrixImpl(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix multiply(final RealMatrix m)\n+        throws IllegalArgumentException {\n+        try {\n+            return multiply((RealMatrixImpl) m);\n+        } catch (ClassCastException cce) {\n+            return super.multiply(m);\n+        }\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying this by <code>m</code>.\n+     * @param m    matrix to postmultiply by\n+     * @return     this*m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public RealMatrixImpl multiply(final RealMatrixImpl m)\n+        throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkMultiplicationCompatible(this, m);\n+\n+        final int nRows = this.getRowDimension();\n+        final int nCols = m.getColumnDimension();\n+        final int nSum = this.getColumnDimension();\n+        final double[][] outData = new double[nRows][nCols];\n+        for (int row = 0; row < nRows; row++) {\n+            final double[] dataRow    = data[row];\n+            final double[] outDataRow = outData[row];\n+            for (int col = 0; col < nCols; col++) {\n+                double sum = 0;\n+                for (int i = 0; i < nSum; i++) {\n+                    sum += dataRow[i] * m.data[i][col];\n+                }\n+                outDataRow[col] = sum;\n+            }\n+        }\n+\n+        return new RealMatrixImpl(outData, false);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[][] getData() {\n+        return copyOut();\n+    }\n+\n+    /**\n+     * Returns a reference to the underlying data array.\n+     * <p>\n+     * Does <strong>not</strong> make a fresh copy of the underlying data.</p>\n+     *\n+     * @return 2-dimensional array of entries\n+     */\n+    public double[][] getDataRef() {\n+        return data;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setSubMatrix(final double[][] subMatrix, final int row, final int column) \n+    throws MatrixIndexException {\n+        if (data == null) {\n+            if (row > 0) {\n+                throw MathRuntimeException.createIllegalStateException(\n+                        \"first {0} rows are not initialized yet\",\n+                        row);\n+            }\n+            if (column > 0) {\n+                throw MathRuntimeException.createIllegalStateException(\n+                        \"first {0} columns are not initialized yet\",\n+                        column);\n+            }\n+            final int nRows = subMatrix.length;\n+            if (nRows == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            }\n+\n+            final int nCols = subMatrix[0].length;\n+            if (nCols == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n+            }\n+            data = new double[subMatrix.length][nCols];\n+            for (int i = 0; i < data.length; ++i) {\n+                if (subMatrix[i].length != nCols) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"some rows have length {0} while others have length {1}\",\n+                            nCols, subMatrix[i].length); \n+                }\n+                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n+            }\n+        } else {\n+            super.setSubMatrix(subMatrix, row, column);\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double getEntry(final int row, final int column)\n+        throws MatrixIndexException {\n+        try {\n+            return data[row][column];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(final int row, final int column, final double value)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] = value;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(final int row, final int column, final double increment)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] += increment;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }      \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(final int row, final int column, final double factor)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] *= factor;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\n+                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                    row, column, getRowDimension(), getColumnDimension());\n+        }      \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return (data == null) ? 0 : data.length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[] operate(final double[] v)\n+        throws IllegalArgumentException {\n+        final int nRows = this.getRowDimension();\n+        final int nCols = this.getColumnDimension();\n+        if (v.length != nCols) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nCols);\n+        }\n+        final double[] out = new double[nRows];\n+        for (int row = 0; row < nRows; row++) {\n+            final double[] dataRow = data[row];\n+            double sum = 0;\n+            for (int i = 0; i < nCols; i++) {\n+                sum += dataRow[i] * v[i];\n+            }\n+            out[row] = sum;\n+        }\n+        return out;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[] preMultiply(final double[] v)\n+        throws IllegalArgumentException {\n+\n+        final int nRows = getRowDimension();\n+        final int nCols = getColumnDimension();\n+        if (v.length != nRows) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    v.length, nRows);\n+        }\n+\n+        final double[] out = new double[nCols];\n+        for (int col = 0; col < nCols; ++col) {\n+            double sum = 0;\n+            for (int i = 0; i < nRows; ++i) {\n+                sum += data[i][col] * v[i];\n+            }\n+            out[col] = sum;\n+        }\n+\n+        return out;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int i = 0; i < rows; ++i) {\n+            final double[] rowI = data[i];\n+            for (int j = 0; j < columns; ++j) {\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int i = 0; i < rows; ++i) {\n+            final double[] rowI = data[i];\n+            for (int j = 0; j < columns; ++j) {\n+                visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int i = startRow; i <= endRow; ++i) {\n+            final double[] rowI = data[i];\n+            for (int j = startColumn; j <= endColumn; ++j) {\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int i = startRow; i <= endRow; ++i) {\n+            final double[] rowI = data[i];\n+            for (int j = startColumn; j <= endColumn; ++j) {\n+                visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int j = 0; j < columns; ++j) {\n+            for (int i = 0; i < rows; ++i) {\n+                final double[] rowI = data[i];\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MatrixVisitorException {\n+        final int rows    = getRowDimension();\n+        final int columns = getColumnDimension();\n+        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n+        for (int j = 0; j < columns; ++j) {\n+            for (int i = 0; i < rows; ++i) {\n+                visitor.visit(i, j, data[i][j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,\n+                                    final int startRow, final int endRow,\n+                                    final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int j = startColumn; j <= endColumn; ++j) {\n+            for (int i = startRow; i <= endRow; ++i) {\n+                final double[] rowI = data[i];\n+                rowI[j] = visitor.visit(i, j, rowI[j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,\n+                                    final int startRow, final int endRow,\n+                                    final int startColumn, final int endColumn)\n+        throws MatrixIndexException, MatrixVisitorException {\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n+        visitor.start(getRowDimension(), getColumnDimension(),\n+                      startRow, endRow, startColumn, endColumn);\n+        for (int j = startColumn; j <= endColumn; ++j) {\n+            for (int i = startRow; i <= endRow; ++i) {\n+                visitor.visit(i, j, data[i][j]);\n+            }\n+        }\n+        return visitor.end();\n+    }\n+\n+    /**\n+     * Returns a fresh copy of the underlying data array.\n+     *\n+     * @return a copy of the underlying data array.\n+     */\n+    private double[][] copyOut() {\n+        final int nRows = this.getRowDimension();\n+        final double[][] out = new double[nRows][this.getColumnDimension()];\n+        // can't copy 2-d array in one shot, otherwise get row references\n+        for (int i = 0; i < nRows; i++) {\n+            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n+        }\n+        return out;\n+    }\n+\n+    /**\n+     * Replaces data with a fresh copy of the input array.\n+     * <p>\n+     * Verifies that the input array is rectangular and non-empty.</p>\n+     *\n+     * @param in data to copy in\n+     * @throws IllegalArgumentException if input array is empty or not\n+     *    rectangular\n+     * @throws NullPointerException if input array is null\n+     */\n+    private void copyIn(final double[][] in) {\n+        setSubMatrix(in, 0, 0);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/RealMatrixPreservingVisitor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Interface defining a visitor for matrix entries.\n+ * \n+ * @see DefaultRealMatrixPreservingVisitor\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface RealMatrixPreservingVisitor {\n+\n+    /**\n+     * Start visiting a matrix.\n+     * <p>This method is called once before any entry of the matrix is visited.</p>\n+     * @param rows number of rows of the matrix\n+     * @param columns number of columns of the matrix\n+     * @param startRow Initial row index\n+     * @param endRow Final row index (inclusive)\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index (inclusive)\n+     */\n+    void start(int rows, int columns,\n+               int startRow, int endRow, int startColumn, int endColumn);\n+\n+    /**\n+     * Visit one matrix entry.\n+     * @param row row index of the entry\n+     * @param column column index of the entry\n+     * @param value current value of the entry\n+     * @throws MatrixVisitorException if something wrong occurs\n+     */\n+    void visit(int row, int column, double value)\n+        throws MatrixVisitorException;\n+\n+    /**\n+     * End visiting a matrix.\n+     * <p>This method is called once after all entries of the matrix have been visited.</p>\n+     * @return the value that the <code>walkInXxxOrder</code> must return\n+     */\n+    double end();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/RealVector.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Interface defining a real-valued vector with basic algebraic operations.\n+ * <p>\n+ * vector element indexing is 0-based -- e.g., <code>getEntry(0)</code>\n+ * returns the first element of the vector.\n+ * </p>\n+ * <p>\n+ * The various <code>mapXxx</code> and <code>mapXxxToSelf</code> methods operate\n+ * on vectors element-wise, i.e. they perform the same operation (adding a scalar,\n+ * applying a function ...) on each element in turn. The <code>mapXxx</code>\n+ * versions create a new vector to hold the result and do not change the instance.\n+ * The <code>mapXxxToSelf</code> versions use the instance itself to store the\n+ * results, so the instance is changed by these methods. In both cases, the result\n+ * vector is returned by the methods, this allows to use the <i>fluent API</i>\n+ * style, like this:\n+ * </p>\n+ * <pre>\n+ *   RealVector result = v.mapAddToSelf(3.0).mapTanToSelf().mapSquareToSelf();\n+ * </pre>\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface RealVector {\n+\n+    /**\n+     * Returns a (deep) copy of this.\n+     * @return vector copy\n+     */\n+    RealVector copy();\n+\n+    /**\n+     * Compute the sum of this and v.\n+     * @param v vector to be added\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    RealVector add(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute the sum of this and v.\n+     * @param v vector to be added\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    RealVector add(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute this minus v.\n+     * @param v vector to be subtracted\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    RealVector subtract(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute this minus v.\n+     * @param v vector to be subtracted\n+     * @return this + v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    RealVector subtract(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Map an addition operation to each entry.\n+     * @param d value to be added to each entry\n+     * @return this + d\n+     */\n+    RealVector mapAdd(double d);\n+\n+    /**\n+     * Map an addition operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to be added to each entry\n+     * @return for convenience, return this\n+     */\n+    RealVector mapAddToSelf(double d);\n+\n+    /**\n+     * Map a subtraction operation to each entry.\n+     * @param d value to be subtracted to each entry\n+     * @return this - d\n+     */\n+    RealVector mapSubtract(double d);\n+\n+    /**\n+     * Map a subtraction operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to be subtracted to each entry\n+     * @return for convenience, return this\n+     */\n+    RealVector mapSubtractToSelf(double d);\n+\n+    /**\n+     * Map a multiplication operation to each entry.\n+     * @param d value to multiply all entries by\n+     * @return this * d\n+     */\n+    RealVector mapMultiply(double d);\n+\n+    /**\n+     * Map a multiplication operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to multiply all entries by\n+     * @return for convenience, return this\n+     */\n+    RealVector mapMultiplyToSelf(double d);\n+\n+    /**\n+     * Map a division operation to each entry.\n+     * @param d value to divide all entries by\n+     * @return this / d\n+     */\n+    RealVector mapDivide(double d);\n+\n+    /**\n+     * Map a division operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to divide all entries by\n+     * @return for convenience, return this\n+     */\n+    RealVector mapDivideToSelf(double d);\n+\n+    /**\n+     * Map a power operation to each entry.\n+     * @param d value to raise all entries to\n+     * @return this ^ d\n+     */\n+    RealVector mapPow(double d);\n+\n+    /**\n+     * Map a power operation to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @param d value to raise all entries to\n+     * @return for convenience, return this\n+     */\n+    RealVector mapPowToSelf(double d);\n+\n+    /**\n+     * Map the {@link Math#exp(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapExp();\n+\n+    /**\n+     * Map the {@link Math#exp(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapExpToSelf();\n+\n+    /**\n+     * Map the {@link Math#expm1(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapExpm1();\n+\n+    /**\n+     * Map the {@link Math#expm1(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapExpm1ToSelf();\n+\n+    /**\n+     * Map the {@link Math#log(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapLog();\n+\n+    /**\n+     * Map the {@link Math#log(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapLogToSelf();\n+\n+    /**\n+     * Map the {@link Math#log10(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapLog10();\n+\n+    /**\n+     * Map the {@link Math#log10(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapLog10ToSelf();\n+\n+    /**\n+     * Map the {@link Math#log1p(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapLog1p();\n+\n+    /**\n+     * Map the {@link Math#log1p(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapLog1pToSelf();\n+\n+    /**\n+     * Map the {@link Math#cosh(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapCosh();\n+\n+    /**\n+     * Map the {@link Math#cosh(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapCoshToSelf();\n+\n+    /**\n+     * Map the {@link Math#sinh(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapSinh();\n+\n+    /**\n+     * Map the {@link Math#sinh(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapSinhToSelf();\n+\n+    /**\n+     * Map the {@link Math#tanh(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapTanh();\n+\n+    /**\n+     * Map the {@link Math#tanh(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapTanhToSelf();\n+\n+    /**\n+     * Map the {@link Math#cos(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapCos();\n+\n+    /**\n+     * Map the {@link Math#cos(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapCosToSelf();\n+\n+    /**\n+     * Map the {@link Math#sin(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapSin();\n+\n+    /**\n+     * Map the {@link Math#sin(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapSinToSelf();\n+\n+    /**\n+     * Map the {@link Math#tan(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapTan();\n+\n+    /**\n+     * Map the {@link Math#tan(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapTanToSelf();\n+\n+    /**\n+     * Map the {@link Math#acos(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapAcos();\n+\n+    /**\n+     * Map the {@link Math#acos(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapAcosToSelf();\n+\n+    /**\n+     * Map the {@link Math#asin(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapAsin();\n+\n+    /**\n+     * Map the {@link Math#asin(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapAsinToSelf();\n+\n+    /**\n+     * Map the {@link Math#atan(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapAtan();\n+\n+    /**\n+     * Map the {@link Math#atan(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapAtanToSelf();\n+\n+    /**\n+     * Map the 1/x function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapInv();\n+\n+    /**\n+     * Map the 1/x function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapInvToSelf();\n+\n+    /**\n+     * Map the {@link Math#abs(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapAbs();\n+\n+    /**\n+     * Map the {@link Math#abs(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapAbsToSelf();\n+\n+    /**\n+     * Map the {@link Math#sqrt(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapSqrt();\n+\n+    /**\n+     * Map the {@link Math#sqrt(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapSqrtToSelf();\n+\n+    /**\n+     * Map the {@link Math#cbrt(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapCbrt();\n+\n+    /**\n+     * Map the {@link Math#cbrt(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapCbrtToSelf();\n+\n+    /**\n+     * Map the {@link Math#ceil(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapCeil();\n+\n+    /**\n+     * Map the {@link Math#ceil(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapCeilToSelf();\n+\n+    /**\n+     * Map the {@link Math#floor(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapFloor();\n+\n+    /**\n+     * Map the {@link Math#floor(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapFloorToSelf();\n+\n+    /**\n+     * Map the {@link Math#rint(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapRint();\n+\n+    /**\n+     * Map the {@link Math#rint(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapRintToSelf();\n+\n+    /**\n+     * Map the {@link Math#signum(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapSignum();\n+\n+    /**\n+     * Map the {@link Math#signum(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapSignumToSelf();\n+\n+    /**\n+     * Map the {@link Math#ulp(double)} function to each entry.\n+     * @return a vector containing the result of applying the function to each entry\n+     */\n+    RealVector mapUlp();\n+\n+    /**\n+     * Map the {@link Math#ulp(double)} function to each entry.\n+     * <p>The instance <strong>is</strong> changed by this method.</p>\n+     * @return for convenience, return this\n+     */\n+    RealVector mapUlpToSelf();\n+\n+    /**\n+     * Element-by-element multiplication.\n+     * @param v vector by which instance elements must be multiplied\n+     * @return a vector containing this[i] * v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVector ebeMultiply(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Element-by-element multiplication.\n+     * @param v vector by which instance elements must be multiplied\n+     * @return a vector containing this[i] * v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVector ebeMultiply(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Element-by-element division.\n+     * @param v vector by which instance elements must be divided\n+     * @return a vector containing this[i] / v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVector ebeDivide(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Element-by-element division.\n+     * @param v vector by which instance elements must be divided\n+     * @return a vector containing this[i] / v[i] for all i\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    public RealVector ebeDivide(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Returns vector entries as a double array.\n+     * @return double array of entries\n+     */\n+     double[] getData();\n+\n+    /**\n+     * Compute the dot product.\n+     * @param v vector with which dot product should be computed\n+     * @return the scalar dot product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    double dotProduct(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute the dot product.\n+     * @param v vector with which dot product should be computed\n+     * @return the scalar dot product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    double dotProduct(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the L<sub>2</sub> norm of the vector.\n+     * <p>The L<sub>2</sub> norm is the root of the sum of\n+     * the squared elements.</p>\n+     * @return norm\n+     * @see #getL1Norm()\n+     * @see #getLInfNorm()\n+     * @see #getDistance(RealVector)\n+     */\n+    double getNorm();\n+\n+    /**\n+     * Returns the L<sub>1</sub> norm of the vector.\n+     * <p>The L<sub>1</sub> norm is the sum of the absolute\n+     * values of elements.</p>\n+     * @return norm\n+     * @see #getNorm()\n+     * @see #getLInfNorm()\n+     * @see #getL1Distance(RealVector)\n+     */\n+    double getL1Norm();\n+\n+    /**\n+     * Returns the L<sub>&infin;</sub> norm of the vector.\n+     * <p>The L<sub>&infin;</sub> norm is the max of the absolute\n+     * values of elements.</p>\n+     * @return norm\n+     * @see #getNorm()\n+     * @see #getL1Norm()\n+     * @see #getLInfDistance(RealVector)\n+     */\n+    double getLInfNorm();\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with the\n+     * L<sub>2</sub> norm, i.e. the square root of the sum of\n+     * elements differences, or euclidian distance.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getL1Distance(RealVector)\n+     * @see #getLInfDistance(RealVector)\n+     * @see #getNorm()\n+     */\n+    double getDistance(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with the\n+     * L<sub>2</sub> norm, i.e. the square root of the sum of\n+     * elements differences, or euclidian distance.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getL1Distance(double[])\n+     * @see #getLInfDistance(double[])\n+     * @see #getNorm()\n+     */\n+    double getDistance(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(RealVector)\n+     * @see #getLInfDistance(RealVector)\n+     * @see #getL1Norm()\n+     */\n+    double getL1Distance(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>1</sub> norm, i.e. the sum of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(double[])\n+     * @see #getLInfDistance(double[])\n+     * @see #getL1Norm()\n+     */\n+    double getL1Distance(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>&infin;</sub> norm, i.e. the max of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(RealVector)\n+     * @see #getL1Distance(RealVector)\n+     * @see #getLInfNorm()\n+     */\n+    double getLInfDistance(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Distance between two vectors.\n+     * <p>This method computes the distance consistent with\n+     * L<sub>&infin;</sub> norm, i.e. the max of the absolute values of\n+     * elements differences.</p>\n+     * @param v vector to which distance is requested\n+     * @return distance between two vectors.\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     * @see #getDistance(double[])\n+     * @see #getL1Distance(double[])\n+     * @see #getLInfNorm()\n+     */\n+    double getLInfDistance(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /** Creates a unit vector pointing in the direction of this vector.\n+     * <p>The instance is not changed by this method.</p>\n+     * @return a unit vector pointing in direction of this vector\n+     * @exception ArithmeticException if the norm is null\n+     */\n+    RealVector unitVector();\n+\n+    /** Converts this vector into a unit vector.\n+     * <p>The instance itself is changed by this method.</p>\n+     * @exception ArithmeticException if the norm is null\n+     */\n+    void unitize();\n+\n+    /** Find the orthogonal projection of this vector onto another vector.\n+     * @param v vector onto which instance must be projected\n+     * @return projection of the instance onto v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    RealVector projection(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /** Find the orthogonal projection of this vector onto another vector.\n+     * @param v vector onto which instance must be projected\n+     * @return projection of the instance onto v\n+     * @throws IllegalArgumentException if v is not the same size as this\n+     */\n+    RealVector projection(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute the outer product.\n+     * @param v vector with which outer product should be computed\n+     * @return the square matrix outer product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    RealMatrix outerProduct(RealVector v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Compute the outer product.\n+     * @param v vector with which outer product should be computed\n+     * @return the square matrix outer product between instance and v\n+     * @exception IllegalArgumentException if v is not the same size as this\n+     */\n+    RealMatrix outerProduct(double[] v)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the entry in the specified index.\n+     * <p>\n+     * The index start at 0 and must be lesser than the size,\n+     * otherwise a {@link MatrixIndexException} is thrown.\n+     * </p>\n+     * @param index  index location of entry to be fetched\n+     * @return vector entry at index\n+     * @throws MatrixIndexException if the index is not valid\n+     * @see #setEntry(int, double)\n+     */\n+    double getEntry(int index)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set a single element.\n+     * @param index element index.\n+     * @param value new value for the element.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     * @see #getEntry(int)\n+     */\n+    void setEntry(int index, double value)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Returns the size of the vector.\n+     * @return size\n+     */\n+    int getDimension();\n+\n+    /**\n+     * Construct a vector by appending a vector to this vector.\n+     * @param v vector to append to this one.\n+     * @return a new vector\n+     */\n+    RealVector append(RealVector v);\n+\n+    /**\n+     * Construct a vector by appending a double to this vector.\n+     * @param d double to append.\n+     * @return a new vector\n+     */\n+    RealVector append(double d);\n+\n+    /**\n+     * Construct a vector by appending a double array to this vector.\n+     * @param a double array to append.\n+     * @return a new vector\n+     */\n+    RealVector append(double[] a);\n+\n+    /**\n+     * Get a subvector from consecutive elements.\n+     * @param index index of first element.\n+     * @param n number of elements to be retrieved.\n+     * @return a vector containing n elements.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     */\n+    RealVector getSubVector(int index, int n)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set a set of consecutive elements.\n+     * @param index index of first element to be set.\n+     * @param v vector containing the values to set.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     * @see #setSubVector(int, double[])\n+     */\n+    void setSubVector(int index, RealVector v)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set a set of consecutive elements.\n+     * @param index index of first element to be set.\n+     * @param v vector containing the values to set.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     * @see #setSubVector(int, RealVector)\n+     */\n+    void setSubVector(int index, double[] v)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set all elements to a single value.\n+     * @param value single value to set for all elements\n+     */\n+    void set(double value);\n+\n+    /**\n+     * Convert the vector to a double array.\n+     * <p>The array is independent from vector data, it's elements\n+     * are copied.</p>\n+     * @return array containing a copy of vector elements\n+     */\n+    double[] toArray();\n+\n+    /**\n+     * Returns true if any coordinate of this vector is NaN; false otherwise\n+     * @return  true if any coordinate of this vector is NaN; false otherwise\n+     */\n+    public boolean isNaN();\n+    \n+    /**\n+     * Returns true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     * @return  true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     */\n+    public boolean isInfinite();\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/RealVectorFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.CompositeFormat;\n+\n+/**\n+ * Formats a vector in components list format \"{v0; v1; ...; vk-1}\".\n+ * <p>The prefix and suffix \"{\" and \"}\" and the separator \"; \" can be replaced by\n+ * any user-defined strings. The number format for components can be configured.</p>\n+ * <p>White space is ignored at parse time, even if it is in the prefix, suffix\n+ * or separator specifications. So even if the default separator does include a space\n+ * character that is used at format time, both input string \"{1;1;1}\" and\n+ * \" { 1 ; 1 ; 1 } \" will be parsed without error and the same vector will be\n+ * returned. In the second case, however, the parse position after parsing will be\n+ * just after the closing curly brace, i.e. just before the trailing space.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class RealVectorFormat extends CompositeFormat {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -708767813036157690L;\n+\n+    /** The default prefix: \"{\". */\n+    private static final String DEFAULT_PREFIX = \"{\";\n+\n+    /** The default suffix: \"}\". */\n+    private static final String DEFAULT_SUFFIX = \"}\";\n+\n+    /** The default separator: \", \". */\n+    private static final String DEFAULT_SEPARATOR = \"; \";\n+\n+    /** Prefix. */\n+    private final String prefix;\n+\n+    /** Suffix. */\n+    private final String suffix;\n+\n+    /** Separator. */\n+    private final String separator;\n+\n+    /** Trimmed prefix. */\n+    private final String trimmedPrefix;\n+\n+    /** Trimmed suffix. */\n+    private final String trimmedSuffix;\n+\n+    /** Trimmed separator. */\n+    private final String trimmedSeparator;\n+\n+    /** The format used for components. */\n+    private NumberFormat format;\n+\n+    /**\n+     * Create an instance with default settings.\n+     * <p>The instance uses the default prefix, suffix and separator:\n+     * \"{\", \"}\", and \"; \" and the default number format for components.</p>\n+     */\n+    public RealVectorFormat() {\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with a custom number format for components.\n+     * @param format the custom format for components.\n+     */\n+    public RealVectorFormat(final NumberFormat format) {\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix and separator.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param separator separator to use instead of the default \"; \"\n+     */\n+    public RealVectorFormat(final String prefix, final String suffix,\n+                            final String separator) {\n+        this(prefix, suffix, separator, getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix, separator and format\n+     * for components.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param separator separator to use instead of the default \"; \"\n+     * @param format the custom format for components.\n+     */\n+    public RealVectorFormat(final String prefix, final String suffix,\n+                            final String separator, final NumberFormat format) {\n+        this.prefix      = prefix;\n+        this.suffix      = suffix;\n+        this.separator   = separator;\n+        trimmedPrefix    = prefix.trim();\n+        trimmedSuffix    = suffix.trim();\n+        trimmedSeparator = separator.trim();\n+        this.format      = format;\n+    }\n+\n+    /**\n+     * Get the set of locales for which real vectors formats are available.\n+     * <p>This is the same set as the {@link NumberFormat} set.</p>\n+     * @return available real vector format locales.\n+     */\n+    public static Locale[] getAvailableLocales() {\n+        return NumberFormat.getAvailableLocales();\n+    }\n+\n+    /**\n+     * Get the format prefix.\n+     * @return format prefix.\n+     */\n+    public String getPrefix() {\n+        return prefix;\n+    }\n+\n+    /**\n+     * Get the format suffix.\n+     * @return format suffix.\n+     */\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    /**\n+     * Get the format separator between components.\n+     * @return format separator.\n+     */\n+    public String getSeparator() {\n+        return separator;\n+    }\n+\n+    /**\n+     * Get the components format.\n+     * @return components format.\n+     */\n+    public NumberFormat getFormat() {\n+        return format;\n+    }\n+\n+    /**\n+     * Returns the default real vector format for the current locale.\n+     * @return the default real vector format.\n+     */\n+    public static RealVectorFormat getInstance() {\n+        return getInstance(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Returns the default real vector format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the real vector format specific to the given locale.\n+     */\n+    public static RealVectorFormat getInstance(final Locale locale) {\n+        return new RealVectorFormat(getDefaultNumberFormat(locale));\n+    }\n+\n+    /**\n+     * This static method calls {@link #format(Object)} on a default instance of\n+     * RealVectorFormat.\n+     *\n+     * @param v RealVector object to format\n+     * @return A formatted vector\n+     */\n+    public static String formatRealVector(RealVector v) {\n+        return getInstance().format(v);\n+    }\n+\n+    /**\n+     * Formats a {@link RealVector} object to produce a string.\n+     * @param vector the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public StringBuffer format(RealVector vector, StringBuffer toAppendTo,\n+                               FieldPosition pos) {\n+\n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        // format prefix\n+        toAppendTo.append(prefix);\n+\n+        // format components\n+        for (int i = 0; i < vector.getDimension(); ++i) {\n+            if (i > 0) {\n+                toAppendTo.append(separator);\n+            }\n+            formatDouble(vector.getEntry(i), format, toAppendTo, pos);\n+        }\n+\n+        // format suffix\n+        toAppendTo.append(suffix);\n+\n+        return toAppendTo;\n+\n+    }\n+\n+    /**\n+     * Formats a object to produce a string.\n+     * <p><code>obj</code> must be a  {@link RealVector} object. Any other type of\n+     * object will result in an {@link IllegalArgumentException} being thrown.</p>\n+     * @param obj the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     * @see java.text.Format#format(java.lang.Object, java.lang.StringBuffer, java.text.FieldPosition)\n+     * @throws IllegalArgumentException is <code>obj</code> is not a valid type.\n+     */\n+    @Override\n+    public StringBuffer format(Object obj, StringBuffer toAppendTo,\n+                               FieldPosition pos) {\n+\n+        if (obj instanceof RealVector) {\n+            return format( (RealVector)obj, toAppendTo, pos);\n+        }\n+\n+        throw MathRuntimeException.createIllegalArgumentException(\n+              \"cannot format a {0} instance as a real vector\",\n+              obj.getClass().getName());\n+\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link RealVector} object.\n+     * @param source the string to parse\n+     * @return the parsed {@link RealVector} object.\n+     * @exception ParseException if the beginning of the specified string\n+     *            cannot be parsed.\n+     */\n+    public ArrayRealVector parse(String source) throws ParseException {\n+        ParsePosition parsePosition = new ParsePosition(0);\n+        ArrayRealVector result = parse(source, parsePosition);\n+        if (parsePosition.getIndex() == 0) {\n+            throw MathRuntimeException.createParseException(\n+                    parsePosition.getErrorIndex(),\n+                    \"unparseable real vector: \\\"{0}\\\"\", source);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link RealVector} object.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link RealVector} object.\n+     */\n+    public ArrayRealVector parse(String source, ParsePosition pos) {\n+        int initialIndex = pos.getIndex();\n+\n+        // parse prefix\n+        parseAndIgnoreWhitespace(source, pos);\n+        if (!parseFixedstring(source, trimmedPrefix, pos)) {\n+            return null;\n+        }\n+\n+        // parse components\n+        List<Number> components = new ArrayList<Number>();\n+        for (boolean loop = true; loop;){\n+\n+            if (!components.isEmpty()) {\n+                parseAndIgnoreWhitespace(source, pos);\n+                if (!parseFixedstring(source, trimmedSeparator, pos)) {\n+                    loop = false;\n+                }\n+            }\n+\n+            if (loop) {\n+                parseAndIgnoreWhitespace(source, pos);\n+                Number component = parseNumber(source, format, pos);\n+                if (component != null) {\n+                    components.add(component);\n+                } else {\n+                    // invalid component\n+                    // set index back to initial, error index should already be set\n+                    pos.setIndex(initialIndex);\n+                    return null;\n+                }\n+            }\n+\n+        }\n+\n+        // parse suffix\n+        parseAndIgnoreWhitespace(source, pos);\n+        if (!parseFixedstring(source, trimmedSuffix, pos)) {\n+            return null;\n+        }\n+\n+        // build vector\n+        double[] data = new double[components.size()];\n+        for (int i = 0; i < data.length; ++i) {\n+            data[i] = components.get(i).doubleValue();\n+        }\n+        return new ArrayRealVector(data, false);\n+\n+    }\n+\n+    /**\n+     * Parses a string to produce a object.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed object.\n+     * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)\n+     */\n+    @Override\n+    public Object parseObject(String source, ParsePosition pos) {\n+        return parse(source, pos);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/SingularMatrixException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+\n+/**\n+ * Thrown when a matrix is singular.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class SingularMatrixException extends InvalidMatrixException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -7379143356784298432L;\n+\n+    /**\n+     * Construct an exception with a default message.\n+     */\n+    public SingularMatrixException() {\n+        super(\"matrix is singular\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+\n+\n+/**\n+ * An interface to classes that implement an algorithm to calculate the \n+ * Singular Value Decomposition of a real matrix.\n+ * <p>The Singular Value Decomposition of matrix A is a set of three matrices:\n+ * U, &Sigma; and V such that A = U &times; &Sigma; &times; V<sup>T</sup>.\n+ * Let A be an m &times; n matrix, then U is an m &times; m orthogonal matrix,\n+ * &Sigma; is a m &times; n diagonal matrix with positive diagonal elements,\n+ * and V is an n &times; n orthogonal matrix.</p>\n+ * <p>This interface is similar to the class with similar name from the now defunct\n+ * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n+ * following changes:</p>\n+ * <ul>\n+ *   <li>the <code>norm2</code> method which has been renamed as {@link #getNorm()\n+ *   getNorm},</li>\n+ *   <li>the <code>cond</code> method which has been renamed as {@link\n+ *   #getConditionNumber() getConditionNumber},</li>\n+ *   <li>the <code>rank</code> method which has been renamed as {@link #getRank()\n+ *   getRank},</li>\n+ *   <li>a {@link #getUT() getUT} method has been added,</li>\n+ *   <li>a {@link #getVT() getVT} method has been added,</li>\n+ *   <li>a {@link #getSolver() getSolver} method has been added,</li>\n+ *   <li>a {@link #getCovariance(double) getCovariance} method has been added.</li>\n+ * </ul>\n+ * @see <a href=\"http://mathworld.wolfram.com/SingularValueDecomposition.html\">MathWorld</a>\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Singular_value_decomposition\">Wikipedia</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface SingularValueDecomposition {\n+\n+    /**\n+     * Returns the matrix U of the decomposition. \n+     * <p>U is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the U matrix\n+     * @see #getUT()\n+     */\n+    RealMatrix getU();\n+\n+    /**\n+     * Returns the transpose of the matrix U of the decomposition. \n+     * <p>U is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the U matrix (or null if decomposed matrix is singular)\n+     * @see #getU()\n+     */\n+    RealMatrix getUT();\n+\n+    /**\n+     * Returns the diagonal matrix &Sigma; of the decomposition. \n+     * <p>&Sigma; is a diagonal matrix. The singular values are provided in\n+     * non-increasing order, for compatibility with Jama.</p>\n+     * @return the &Sigma; matrix\n+     */\n+    RealMatrix getS();\n+\n+    /**\n+     * Returns the diagonal elements of the matrix &Sigma; of the decomposition.\n+     * <p>The singular values are provided in non-increasing order, for\n+     * compatibility with Jama.</p>\n+     * @return the diagonal elements of the &Sigma; matrix\n+     */\n+    double[] getSingularValues();\n+\n+    /**\n+     * Returns the matrix V of the decomposition. \n+     * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the V matrix (or null if decomposed matrix is singular)\n+     * @see #getVT()\n+     */\n+    RealMatrix getV();\n+\n+    /**\n+     * Returns the transpose of the matrix V of the decomposition. \n+     * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the V matrix (or null if decomposed matrix is singular)\n+     * @see #getV()\n+     */\n+    RealMatrix getVT();\n+\n+    /**\n+     * Returns the n &times; n covariance matrix.\n+     * <p>The covariance matrix is V &times; J &times; V<sup>T</sup>\n+     * where J is the diagonal matrix of the inverse of the squares of\n+     * the singular values.</p>\n+     * @param minSingularValue value below which singular values are ignored\n+     * (a 0 or negative value implies all singular value will be used)\n+     * @return covariance matrix\n+     * @exception IllegalArgumentException if minSingularValue is larger than\n+     * the largest singular value, meaning all singular values are ignored\n+     */\n+    RealMatrix getCovariance(double minSingularValue) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the L<sub>2</sub> norm of the matrix.\n+     * <p>The L<sub>2</sub> norm is max(|A &times; u|<sub>2</sub> /\n+     * |u|<sub>2</sub>), where |.|<sub>2</sub> denotes the vectorial 2-norm\n+     * (i.e. the traditional euclidian norm).</p>\n+     * @return norm\n+     */\n+    double getNorm();\n+\n+    /**\n+     * Return the condition number of the matrix.\n+     * @return condition number of the matrix\n+     */\n+    double getConditionNumber();\n+\n+    /**\n+     * Return the effective numerical matrix rank.\n+     * <p>The effective numerical rank is the number of non-negligible\n+     * singular values. The threshold used to identify non-negligible\n+     * terms is max(m,n) &times; ulp(s<sub>1</sub>) where ulp(s<sub>1</sub>)\n+     * is the least significant bit of the largest singular value.</p>\n+     * @return effective numerical matrix rank\n+     */\n+    int getRank();\n+\n+    /**\n+     * Get a solver for finding the A &times; X = B solution in least square sense.\n+     * @return a solver\n+     */\n+    DecompositionSolver getSolver();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Calculates the Singular Value Decomposition of a matrix.\n+ * <p>The Singular Value Decomposition of matrix A is a set of three matrices:\n+ * U, &Sigma; and V such that A = U &times; &Sigma; &times; V<sup>T</sup>.\n+ * Let A be an m &times; n matrix, then U is an m &times; m orthogonal matrix,\n+ * &Sigma; is a m &times; n diagonal matrix with positive diagonal elements,\n+ * and V is an n &times; n orthogonal matrix.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class SingularValueDecompositionImpl implements SingularValueDecomposition {\n+\n+    /** Number of rows of the initial matrix. */\n+    private int m;\n+\n+    /** Number of columns of the initial matrix. */\n+    private int n;\n+\n+    /** Transformer to bidiagonal. */\n+    private BiDiagonalTransformer transformer;\n+\n+    /** Main diagonal of the bidiagonal matrix. */\n+    private double[] mainBidiagonal;\n+\n+    /** Secondary diagonal of the bidiagonal matrix. */\n+    private double[] secondaryBidiagonal;\n+\n+    /** Main diagonal of the tridiagonal matrix. */\n+    private double[] mainTridiagonal;\n+\n+    /** Secondary diagonal of the tridiagonal matrix. */\n+    private double[] secondaryTridiagonal;\n+\n+    /** Eigen decomposition of the tridiagonal matrix. */\n+    private EigenDecomposition eigenDecomposition;\n+\n+    /** Singular values. */\n+    private double[] singularValues;\n+\n+    /** Cached value of U. */\n+    private RealMatrix cachedU;\n+\n+    /** Cached value of U<sup>T</sup>. */\n+    private RealMatrix cachedUt;\n+\n+    /** Cached value of S. */\n+    private RealMatrix cachedS;\n+\n+    /** Cached value of V. */\n+    private RealMatrix cachedV;\n+\n+    /** Cached value of V<sup>T</sup>. */\n+    private RealMatrix cachedVt;\n+\n+    /**\n+     * Calculates the Singular Value Decomposition of the given matrix. \n+     * @param matrix The matrix to decompose.\n+     * @exception InvalidMatrixException (wrapping a {@link ConvergenceException}\n+     * if algorithm fails to converge\n+     */\n+    public SingularValueDecompositionImpl(RealMatrix matrix)\n+        throws InvalidMatrixException {\n+\n+        m = matrix.getRowDimension();\n+        n = matrix.getColumnDimension();\n+\n+        cachedU  = null;\n+        cachedS  = null;\n+        cachedV  = null;\n+        cachedVt = null;\n+\n+        // transform the matrix to bidiagonal\n+        transformer         = new BiDiagonalTransformer(matrix);\n+        mainBidiagonal      = transformer.getMainDiagonalRef();\n+        secondaryBidiagonal = transformer.getSecondaryDiagonalRef();\n+\n+        // compute Bt.B (if upper diagonal) or B.Bt (if lower diagonal)\n+        mainTridiagonal      = new double[mainBidiagonal.length];\n+        secondaryTridiagonal = new double[mainBidiagonal.length - 1];\n+        double a = mainBidiagonal[0];\n+        mainTridiagonal[0] = a * a;\n+        for (int i = 1; i < mainBidiagonal.length; ++i) {\n+            final double b  = secondaryBidiagonal[i - 1];\n+            secondaryTridiagonal[i - 1] = a * b;\n+            a = mainBidiagonal[i];\n+            mainTridiagonal[i] = a * a + b * b;\n+        }\n+\n+        // compute singular values\n+        eigenDecomposition =\n+            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal,\n+                                       MathUtils.SAFE_MIN);\n+        singularValues = eigenDecomposition.getRealEigenvalues();\n+        for (int i = 0; i < singularValues.length; ++i) {\n+            singularValues[i] = Math.sqrt(singularValues[i]);\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getU()\n+        throws InvalidMatrixException {\n+\n+        if (cachedU == null) {\n+\n+            if (m >= n) {\n+                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n+                final double[][] eData = eigenDecomposition.getV().getData();\n+                final double[][] iData = new double[m][];\n+                double[] ei1 = eData[0];\n+                iData[0] = ei1;\n+                for (int i = 0; i < n - 1; ++i) {\n+                    // compute Bt.E.S^(-1) where E is the eigenvectors matrix\n+                    // we reuse the array from matrix E to store the result \n+                    final double[] ei0 = ei1;\n+                    ei1 = eData[i + 1];\n+                    iData[i + 1] = ei1;\n+                    for (int j = 0; j < n; ++j) {\n+                        ei0[j] = (mainBidiagonal[i] * ei0[j] +\n+                                  secondaryBidiagonal[i] * ei1[j]) / singularValues[j];\n+                    }\n+                }\n+                // last row\n+                final double lastMain = mainBidiagonal[n - 1];\n+                for (int j = 0; j < n; ++j) {\n+                    ei1[j] *= lastMain / singularValues[j];\n+                }\n+                for (int i = n; i < m; ++i) {\n+                    iData[i] = new double[n];\n+                }\n+                cachedU =\n+                    transformer.getU().multiply(MatrixUtils.createRealMatrix(iData));\n+            } else {\n+                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n+                cachedU = transformer.getU().multiply(eigenDecomposition.getV());\n+            }\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedU;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getUT()\n+        throws InvalidMatrixException {\n+\n+        if (cachedUt == null) {\n+            cachedUt = getU().transpose();\n+        }\n+\n+        // return the cached matrix\n+        return cachedUt;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getS()\n+        throws InvalidMatrixException {\n+\n+        if (cachedS == null) {\n+\n+            // cache the matrix for subsequent calls\n+            cachedS = MatrixUtils.createRealDiagonalMatrix(singularValues);\n+\n+        }\n+        return cachedS;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] getSingularValues()\n+        throws InvalidMatrixException {\n+        return singularValues.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getV()\n+        throws InvalidMatrixException {\n+\n+        if (cachedV == null) {\n+\n+            if (m >= n) {\n+                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n+                cachedV = transformer.getV().multiply(eigenDecomposition.getV());\n+            } else {\n+                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n+                final double[][] eData = eigenDecomposition.getV().getData();\n+                final double[][] iData = new double[n][];\n+                double[] ei1 = eData[0];\n+                iData[0] = ei1;\n+                for (int i = 0; i < m - 1; ++i) {\n+                    // compute Bt.E.S^(-1) where E is the eigenvectors matrix\n+                    // we reuse the array from matrix E to store the result \n+                    final double[] ei0 = ei1;\n+                    ei1 = eData[i + 1];\n+                    iData[i + 1] = ei1;\n+                    for (int j = 0; j < m; ++j) {\n+                        ei0[j] = (mainBidiagonal[i] * ei0[j] +\n+                                  secondaryBidiagonal[i] * ei1[j]) / singularValues[j];\n+                    }\n+                }\n+                // last row\n+                final double lastMain = mainBidiagonal[m - 1];\n+                for (int j = 0; j < m; ++j) {\n+                    ei1[j] *= lastMain / singularValues[j];\n+                }\n+                for (int i = m; i < n; ++i) {\n+                    iData[i] = new double[m];\n+                }\n+                cachedV =\n+                    transformer.getV().multiply(MatrixUtils.createRealMatrix(iData));\n+            }\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedV;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getVT()\n+        throws InvalidMatrixException {\n+\n+        if (cachedVt == null) {\n+            cachedVt = getV().transpose();\n+        }\n+\n+        // return the cached matrix\n+        return cachedVt;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealMatrix getCovariance(final double minSingularValue) {\n+\n+        // get the number of singular values to consider\n+        int dimension = 0;\n+        while ((dimension < n) && (singularValues[dimension] >= minSingularValue)) {\n+            ++dimension;\n+        }\n+\n+        if (dimension == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"cutoff singular value is {0}, should be at most {1}\",\n+                  minSingularValue, singularValues[0]);\n+        }\n+\n+        final double[][] data = new double[dimension][n];\n+        getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n+            /** {@inheritDoc} */\n+            @Override\n+            public void visit(final int row, final int column, final double value) {\n+                data[row][column] = value / singularValues[row];\n+            }\n+        }, 0, dimension - 1, 0, n - 1);\n+\n+        RealMatrix jv = new Array2DRowRealMatrix(data, false);\n+        return jv.transpose().multiply(jv);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNorm()\n+        throws InvalidMatrixException {\n+        return singularValues[0];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getConditionNumber()\n+        throws InvalidMatrixException {\n+        return singularValues[0] / singularValues[singularValues.length - 1];\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getRank()\n+        throws IllegalStateException {\n+\n+        final double threshold = Math.max(m, n) * Math.ulp(singularValues[0]);\n+\n+        for (int i = singularValues.length - 1; i >= 0; --i) {\n+           if (singularValues[i] > threshold) {\n+              return i + 1;\n+           }\n+        }\n+        return 0;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public DecompositionSolver getSolver() {\n+        return new Solver(singularValues, getUT(), getV(),\n+                          getRank() == singularValues.length);\n+    }\n+\n+    /** Specialized solver. */\n+    private static class Solver implements DecompositionSolver {\n+        \n+        /** Singular values. */\n+        private final double[] singularValues;\n+\n+        /** U<sup>T</sup> matrix of the decomposition. */\n+        private final RealMatrix uT;\n+\n+        /** V matrix of the decomposition. */\n+        private final RealMatrix v;\n+\n+        /** Singularity indicator. */\n+        private boolean nonSingular;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         * @param singularValues singularValues\n+         * @param uT U<sup>T</sup> matrix of the decomposition\n+         * @param v V matrix of the decomposition\n+         * @param nonSingular singularity indicator\n+         */\n+        private Solver(final double[] singularValues, final RealMatrix uT, final RealMatrix v,\n+                       final boolean nonSingular) {\n+            this.singularValues = singularValues;\n+            this.uT             = uT;\n+            this.v              = v;\n+            this.nonSingular    = nonSingular;\n+        }\n+\n+        /** Solve the linear equation A &times; X = B in least square sense.\n+         * <p>The m&times;n matrix A may not be square, the solution X is\n+         * such that ||A &times; X - B|| is minimal.</p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a vector X that minimizes the two norm of A &times; X - B\n+         * @exception IllegalArgumentException if matrices dimensions don't match\n+         * @exception InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public double[] solve(final double[] b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            if (b.length != singularValues.length) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"vector length mismatch: got {0} but expected {1}\",\n+                        b.length, singularValues.length);\n+            }\n+\n+            final double[] w = uT.operate(b);\n+            for (int i = 0; i < singularValues.length; ++i) {\n+                final double si = singularValues[i];\n+                if (si == 0) {\n+                    throw new SingularMatrixException();\n+                }\n+                w[i] /= si;\n+            }\n+            return v.operate(w);\n+\n+        }\n+\n+        /** Solve the linear equation A &times; X = B in least square sense.\n+         * <p>The m&times;n matrix A may not be square, the solution X is\n+         * such that ||A &times; X - B|| is minimal.</p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a vector X that minimizes the two norm of A &times; X - B\n+         * @exception IllegalArgumentException if matrices dimensions don't match\n+         * @exception InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public RealVector solve(final RealVector b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            if (b.getDimension() != singularValues.length) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"vector length mismatch: got {0} but expected {1}\",\n+                         b.getDimension(), singularValues.length);\n+            }\n+\n+            final RealVector w = uT.operate(b);\n+            for (int i = 0; i < singularValues.length; ++i) {\n+                final double si = singularValues[i];\n+                if (si == 0) {\n+                    throw new SingularMatrixException();\n+                }\n+                w.setEntry(i, w.getEntry(i) / si);\n+            }\n+            return v.operate(w);\n+\n+        }\n+\n+        /** Solve the linear equation A &times; X = B in least square sense.\n+         * <p>The m&times;n matrix A may not be square, the solution X is\n+         * such that ||A &times; X - B|| is minimal.</p>\n+         * @param b right-hand side of the equation A &times; X = B\n+         * @return a matrix X that minimizes the two norm of A &times; X - B\n+         * @exception IllegalArgumentException if matrices dimensions don't match\n+         * @exception InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public RealMatrix solve(final RealMatrix b)\n+            throws IllegalArgumentException, InvalidMatrixException {\n+\n+            if (b.getRowDimension() != singularValues.length) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n+                        b.getRowDimension(), b.getColumnDimension(),\n+                        singularValues.length, \"n\");\n+            }\n+\n+            final RealMatrix w = uT.multiply(b);\n+            for (int i = 0; i < singularValues.length; ++i) {\n+                final double si  = singularValues[i];\n+                if (si == 0) {\n+                    throw new SingularMatrixException();\n+                }\n+                final double inv = 1.0 / si;\n+                for (int j = 0; j < b.getColumnDimension(); ++j) {\n+                    w.multiplyEntry(i, j, inv);\n+                }\n+            }\n+            return v.multiply(w);\n+\n+        }\n+\n+        /**\n+         * Check if the decomposed matrix is non-singular.\n+         * @return true if the decomposed matrix is non-singular\n+         */\n+        public boolean isNonSingular() {\n+            return nonSingular;\n+        }\n+\n+        /** Get the pseudo-inverse of the decomposed matrix.\n+         * @return inverse matrix\n+         * @throws InvalidMatrixException if decomposed matrix is singular\n+         */\n+        public RealMatrix getInverse()\n+            throws InvalidMatrixException {\n+\n+            if (!isNonSingular()) {\n+                throw new SingularMatrixException();\n+            }\n+\n+            return solve(MatrixUtils.createRealIdentityMatrix(singularValues.length));\n+\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/SparseFieldMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.util.OpenIntToFieldHashMap;\n+\n+/**\n+ * Sparse matrix implementation based on an open addressed map.\n+ * \n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class SparseFieldMatrix<T extends FieldElement<T>> extends AbstractFieldMatrix<T> {\n+    /**\n+     *  Serial id\n+     */\n+    private static final long serialVersionUID = 9078068119297757342L;\n+    /** Storage for (sparse) matrix elements. */\n+    private final OpenIntToFieldHashMap<T> entries;\n+    /**\n+     * row dimension\n+     */\n+    private final int rowDimension;\n+    /**\n+     * column dimension\n+     */\n+    private final int columnDimension;\n+    \n+\n+    /**\n+     * Creates a matrix with no data.\n+     * @param field field to which the elements belong\n+     */\n+    public SparseFieldMatrix(final Field<T> field) {\n+        super(field);\n+        rowDimension = 0;\n+        columnDimension= 0;\n+        entries = new OpenIntToFieldHashMap<T>(field);\n+    }\n+\n+    /**\n+     * Create a new SparseFieldMatrix<T> with the supplied row and column dimensions.\n+     *\n+     * @param field field to which the elements belong\n+     * @param rowDimension  the number of rows in the new matrix\n+     * @param columnDimension  the number of columns in the new matrix\n+     * @throws IllegalArgumentException if row or column dimension is not positive\n+     */\n+    public SparseFieldMatrix(final Field<T> field,\n+                             final int rowDimension, final int columnDimension)\n+        throws IllegalArgumentException {\n+        super(field, rowDimension, columnDimension);\n+        this.rowDimension = rowDimension;\n+        this.columnDimension = columnDimension;\n+        entries = new OpenIntToFieldHashMap<T>(field);\n+    }\n+    \n+    /**\n+     * Copy constructor.\n+     * @param other The instance to copy\n+     */\n+    public SparseFieldMatrix(SparseFieldMatrix<T> other) {\n+        super(other.getField(), other.getRowDimension(), other.getColumnDimension());\n+        rowDimension = other.getRowDimension();\n+        columnDimension = other.getColumnDimension();\n+        entries = new OpenIntToFieldHashMap<T>(other.entries);\n+    }\n+\n+    /**\n+     * Generic copy constructor.\n+     * @param other The instance to copy\n+     */\n+    public SparseFieldMatrix(FieldMatrix<T> other){\n+        super(other.getField(), other.getRowDimension(), other.getColumnDimension());\n+        rowDimension = other.getRowDimension();\n+        columnDimension = other.getColumnDimension();\n+        entries = new OpenIntToFieldHashMap<T>(getField());\n+        for (int i = 0; i < rowDimension; i++) {\n+            for (int j = 0; j < columnDimension; j++) {\n+                setEntry(i, j, other.getEntry(i, j));\n+            }\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(int row, int column, T increment)\n+            throws MatrixIndexException {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+        final int key = computeKey(row, column);\n+        final T value = entries.get(key).add(increment);\n+        if (getField().getZero().equals(value)) {\n+            entries.remove(key);\n+        } else {\n+            entries.put(key, value);\n+        }\n+       \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> copy() {\n+        return new SparseFieldMatrix<T>(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> createMatrix(int rowDimension, int columnDimension)\n+            throws IllegalArgumentException {\n+        return new SparseFieldMatrix<T>(getField(), rowDimension, columnDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return columnDimension;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public T getEntry(int row, int column) throws MatrixIndexException {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+        return entries.get(computeKey(row, column));\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return rowDimension;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(int row, int column, T factor)\n+            throws MatrixIndexException {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+        final int key = computeKey(row, column);\n+        final T value = entries.get(key).multiply(factor);\n+        if (getField().getZero().equals(value)) {\n+            entries.remove(key);\n+        } else {\n+            entries.put(key, value);\n+        }\n+        \n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(int row, int column, T value)\n+            throws MatrixIndexException {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+        if (getField().getZero().equals(value)) {\n+            entries.remove(computeKey(row, column));\n+        } else {\n+            entries.put(computeKey(row, column), value);\n+        }\n+        \n+    }\n+    /**\n+     * Compute the key to access a matrix element\n+     * @param row row index of the matrix element\n+     * @param column column index of the matrix element\n+     * @return key within the map to access the matrix element\n+     */\n+    private int computeKey(int row, int column) {\n+        return row * columnDimension + column;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/SparseFieldVector.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.OpenIntToFieldHashMap;\n+\n+/**\n+ * This class implements the {@link FieldVector} interface with a {@link OpenIntToFieldHashMap} backing store.\n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class SparseFieldVector<T extends FieldElement<T>> implements FieldVector<T>, Serializable {\n+    \n+    /**\n+     *  Serial version id\n+     */\n+    private static final long serialVersionUID = 7841233292190413362L;\n+    /** Field to which the elements belong. */\n+    private final Field<T> field;\n+    /** Entries of the vector. */\n+    private final OpenIntToFieldHashMap<T> entries;\n+    /** Dimension of the vector. */\n+    private final int virtualSize;\n+\n+    /**\n+     * Build a 0-length vector.\n+     * <p>Zero-length vectors may be used to initialize construction of vectors\n+     * by data gathering. We start with zero-length and use either the {@link\n+     * #SparseFieldVector(SparseFieldVector, int)} constructor\n+     * or one of the <code>append</code> method ({@link #append(FieldElement)},\n+     * {@link #append(FieldElement[])}, {@link #append(FieldVector)},\n+     * {@link #append(SparseFieldVector)}) to gather data into this vector.</p>\n+     * @param field field to which the elements belong\n+     */\n+    public SparseFieldVector(Field<T> field) {\n+        this(field, 0);\n+    }\n+\n+    \n+    /**\n+     * Construct a (dimension)-length vector of zeros.\n+     * @param field field to which the elements belong\n+     * @param dimension Size of the vector\n+     */\n+    public SparseFieldVector(Field<T> field, int dimension) {\n+        this.field = field;\n+        virtualSize = dimension;\n+        entries = new OpenIntToFieldHashMap<T>(field);\n+    }\n+\n+    /**\n+     * Build a resized vector, for use with append.\n+     * @param v The original vector\n+     * @param resize The amount to resize it\n+     */\n+    protected SparseFieldVector(SparseFieldVector<T> v, int resize) {\n+        field = v.field;\n+        virtualSize = v.getDimension() + resize;\n+        entries = new OpenIntToFieldHashMap<T>(v.entries);\n+    }\n+\n+    \n+    /**\n+     * Build a vector with known the sparseness (for advanced use only).\n+     * @param field field to which the elements belong\n+     * @param dimension The size of the vector\n+     * @param expectedSize The expected number of non-zero entries\n+     */\n+    public SparseFieldVector(Field<T> field, int dimension, int expectedSize) {\n+        this.field = field;\n+        virtualSize = dimension;\n+        entries = new OpenIntToFieldHashMap<T>(field,expectedSize);\n+    }\n+\n+    /**\n+     * Create from a Field array.\n+     * Only non-zero entries will be stored\n+     * @param field field to which the elements belong\n+     * @param values The set of values to create from\n+     */\n+    public SparseFieldVector(Field<T> field, T[] values) {\n+        this.field = field;\n+        virtualSize = values.length;\n+        entries = new OpenIntToFieldHashMap<T>(field);\n+        for (int key = 0; key < values.length; key++) {\n+            T value = values[key];\n+            entries.put(key, value);\n+        }\n+    }\n+\n+     \n+\n+    /**\n+     * Copy constructor.\n+     * @param v The instance to copy from\n+     */\n+    public SparseFieldVector(SparseFieldVector<T> v) {\n+        field = v.field;\n+        virtualSize = v.getDimension();\n+        entries = new OpenIntToFieldHashMap<T>(v.getEntries());\n+    }\n+\n+    /**\n+     * Get the entries of this instance.\n+     * @return entries of this instance\n+     */\n+    private OpenIntToFieldHashMap<T> getEntries() {\n+        return entries;\n+    }\n+    \n+    /**\n+     * Optimized method to add sparse vectors.\n+     * @param v vector to add\n+     * @return The sum of <code>this</code> and <code>v</code>\n+     * @throws IllegalArgumentException If the dimensions don't match\n+     */\n+    public FieldVector<T> add(SparseFieldVector<T> v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        SparseFieldVector<T> res = (SparseFieldVector<T>)copy();\n+        OpenIntToFieldHashMap<T>.Iterator iter = v.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            T value = iter.value();\n+            if (entries.containsKey(key)) {\n+                res.setEntry(key, entries.get(key).add(value));\n+            } else {\n+                res.setEntry(key, value);\n+            }\n+        }\n+        return res;\n+\n+    }\n+\n+    \n+    /** {@inheritDoc} */\n+    public FieldVector<T> add(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        SparseFieldVector<T> res = new SparseFieldVector<T>(field,getDimension());\n+        for (int i = 0; i < v.length; i++) {\n+            res.setEntry(i, v[i].add(getEntry(i)));\n+        }\n+        return res;\n+    }\n+\n+    /**\n+     * Construct a vector by appending a vector to this vector.\n+     * @param v vector to append to this one.\n+     * @return a new vector\n+     */\n+    public FieldVector<T> append(SparseFieldVector<T> v) {\n+        SparseFieldVector<T> res = new SparseFieldVector<T>(this, v.getDimension());\n+        OpenIntToFieldHashMap<T>.Iterator iter = v.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key() + virtualSize, iter.value());\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> append(FieldVector<T> v) {\n+        if (v instanceof SparseFieldVector<?>) {\n+            return append((SparseFieldVector<T>) v);\n+        } else {\n+            return append(v.toArray());\n+        }   \n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> append(T d) {\n+        FieldVector<T> res = new SparseFieldVector<T>(this, 1);\n+        res.setEntry(virtualSize, d);\n+        return res;\n+     }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> append(T[] a) {\n+        FieldVector<T> res = new SparseFieldVector<T>(this, a.length);\n+        for (int i = 0; i < a.length; i++) {\n+            res.setEntry(i + virtualSize, a[i]);\n+        }\n+        return res;\n+     }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> copy() {\n+        return new SparseFieldVector<T>(this);\n+   }\n+\n+    /** {@inheritDoc} */\n+    public T dotProduct(FieldVector<T> v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        T res = field.getZero();\n+        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res = res.add(v.getEntry(iter.key()).multiply(iter.value()));\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T dotProduct(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        T res = field.getZero();\n+        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            int idx = iter.key();\n+            T value = field.getZero();\n+            if (idx < v.length) {\n+                value = v[idx];\n+            }\n+            res = res.add(value.multiply(iter.value()));\n+        }\n+        return res;\n+     }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> ebeDivide(FieldVector<T> v)\n+        throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n+        OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key(), iter.value().divide(v.getEntry(iter.key())));\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> ebeDivide(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n+        OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key(), iter.value().divide(v[iter.key()]));\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> ebeMultiply(FieldVector<T> v)throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n+        OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key(), iter.value().multiply(v.getEntry(iter.key())));\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+     public FieldVector<T> ebeMultiply(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n+        OpenIntToFieldHashMap<T>.Iterator iter = res.entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res.setEntry(iter.key(), iter.value().multiply(v[iter.key()]));\n+        }\n+        return res;\n+    }\n+\n+     /** {@inheritDoc} */\n+     public T[] getData() {\n+        T[] res = buildArray(virtualSize);\n+        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            res[iter.key()] = iter.value();\n+        }\n+        return res;\n+     }\n+\n+     /** {@inheritDoc} */\n+     public int getDimension() {\n+        return virtualSize;\n+    }\n+\n+     /** {@inheritDoc} */\n+     public T getEntry(int index) throws MatrixIndexException {\n+        checkIndex(index);\n+        return entries.get(index);\n+   }\n+\n+     /** {@inheritDoc} */\n+     public Field<T> getField() {\n+        return field;\n+    }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> getSubVector(int index, int n)\n+            throws MatrixIndexException {\n+        checkIndex(index);\n+        checkIndex(index + n - 1);\n+        SparseFieldVector<T> res = new SparseFieldVector<T>(field,n);\n+        int end = index + n;\n+        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (key >= index && key < end) {\n+                res.setEntry(key - index, iter.value());\n+            }\n+        }\n+        return res;\n+    }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapAdd(T d) {\n+        return copy().mapAddToSelf(d);\n+   }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapAddToSelf(T d) {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, getEntry(i).add(d));\n+        }\n+        return this;\n+    }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapDivide(T d) {\n+        return copy().mapDivideToSelf(d);\n+    }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapDivideToSelf(T d) {\n+        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), iter.value().divide(d));\n+        }\n+        return this;\n+   }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapInv() {\n+        return copy().mapInvToSelf();\n+   }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapInvToSelf() {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, field.getOne().divide(getEntry(i)));\n+        }\n+        return this;\n+   }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapMultiply(T d) {\n+        return copy().mapMultiplyToSelf(d);\n+    }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapMultiplyToSelf(T d) {\n+        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            entries.put(iter.key(), iter.value().multiply(d));\n+        }\n+        return this;\n+   }\n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapSubtract(T d) {\n+        return copy().mapSubtractToSelf(d);\n+    }    \n+\n+     /** {@inheritDoc} */\n+     public FieldVector<T> mapSubtractToSelf(T d) {\n+        return mapAddToSelf(field.getZero().subtract(d));\n+    }\n+\n+     /**\n+      * Optimized method to compute outer product when both vectors are sparse.\n+      * @param v vector with which outer product should be computed\n+      * @return the square matrix outer product between instance and v\n+      * @throws IllegalArgumentException if v is not the same size as {@code this}\n+      */\n+    public FieldMatrix<T> outerProduct(SparseFieldVector<T> v)\n+            throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        SparseFieldMatrix<T> res = new SparseFieldMatrix<T>(field, virtualSize, virtualSize);\n+        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            OpenIntToFieldHashMap<T>.Iterator iter2 = v.entries.iterator();\n+            while (iter2.hasNext()) {\n+                iter2.advance();\n+                res.setEntry(iter.key(), iter2.key(), iter.value().multiply(iter2.value()));\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> outerProduct(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        FieldMatrix<T> res = new SparseFieldMatrix<T>(field, virtualSize, virtualSize);\n+        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int row = iter.key();\n+            FieldElement<T>value = iter.value();\n+            for (int col = 0; col < virtualSize; col++) {\n+                res.setEntry(row, col, value.multiply(v[col]));\n+            }\n+        }\n+        return res;\n+     }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> outerProduct(FieldVector<T> v)\n+    throws IllegalArgumentException {\n+        if(v instanceof SparseFieldVector<?>)\n+            return outerProduct((SparseFieldVector<T>)v);\n+        else\n+            return outerProduct(v.toArray());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> projection(FieldVector<T> v)\n+    throws IllegalArgumentException {\n+        checkVectorDimensions(v.getDimension());\n+        return v.mapMultiply(dotProduct(v).divide(v.dotProduct(v)));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> projection(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        return projection(new SparseFieldVector<T>(field,v));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void set(T value) {\n+        for (int i = 0; i < virtualSize; i++) {\n+            setEntry(i, value);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setEntry(int index, T value) throws MatrixIndexException {\n+        checkIndex(index);\n+        entries.put(index, value);\n+   }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, FieldVector<T> v)\n+            throws MatrixIndexException {\n+        checkIndex(index);\n+        checkIndex(index + v.getDimension() - 1);\n+        setSubVector(index, v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, T[] v) throws MatrixIndexException {\n+        checkIndex(index);\n+        checkIndex(index + v.length - 1);\n+        for (int i = 0; i < v.length; i++) {\n+            setEntry(i + index, v[i]);\n+        }\n+        \n+    }\n+\n+    /**\n+     * Optimized method to subtract SparseRealVectors.\n+     * @param v The vector to subtract from <code>this</code>\n+     * @return The difference of <code>this</code> and <code>v</code>\n+     * @throws IllegalArgumentException If the dimensions don't match\n+     */\n+    public SparseFieldVector<T> subtract(SparseFieldVector<T> v) throws IllegalArgumentException{\n+        checkVectorDimensions(v.getDimension());\n+        SparseFieldVector<T> res = (SparseFieldVector<T>)copy();\n+        OpenIntToFieldHashMap<T>.Iterator iter = v.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int key = iter.key();\n+            if (entries.containsKey(key)) {\n+                res.setEntry(key, entries.get(key).subtract(iter.value()));\n+            } else {\n+                res.setEntry(key, field.getZero().subtract(iter.value()));\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> subtract(FieldVector<T> v)\n+           throws IllegalArgumentException {\n+        if(v instanceof SparseFieldVector<?>)\n+            return subtract((SparseFieldVector<T>)v);\n+        else\n+            return subtract(v.toArray());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> subtract(T[] v) throws IllegalArgumentException {\n+        checkVectorDimensions(v.length);\n+        SparseFieldVector<T> res = new SparseFieldVector<T>(this);\n+        for (int i = 0; i < v.length; i++) {\n+            if (entries.containsKey(i)) {\n+                res.setEntry(i, entries.get(i).subtract(v[i]));\n+            } else {\n+                res.setEntry(i, field.getZero().subtract(v[i]));\n+            }\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public T[] toArray() {\n+        return getData();\n+    }\n+    \n+    /**\n+     * Check if an index is valid.\n+     *\n+     * @param index\n+     *            index to check\n+     * @exception MatrixIndexException\n+     *                if index is not valid\n+     */\n+    private void checkIndex(final int index) throws MatrixIndexException {\n+        if (index < 0 || index >= getDimension()) {\n+            throw new MatrixIndexException(\n+                    \"index {0} out of allowed range [{1}, {2}]\",\n+                    index, 0, getDimension() - 1);\n+        }\n+    }\n+\n+    /**\n+     * Check if instance dimension is equal to some expected value.\n+     *\n+     * @param n\n+     *            expected dimension.\n+     * @exception IllegalArgumentException\n+     *                if the dimension is inconsistent with vector size\n+     */\n+    protected void checkVectorDimensions(int n) throws IllegalArgumentException {\n+        if (getDimension() != n) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"vector length mismatch: got {0} but expected {1}\",\n+                    getDimension(), n);\n+        }\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    public FieldVector<T> add(FieldVector<T> v) throws IllegalArgumentException {\n+        if (v instanceof SparseFieldVector<?>) {\n+            return add((SparseFieldVector<T>)v);\n+        } else {\n+            return add(v.toArray());\n+        }\n+    }\n+\n+    /** Build an array of elements.\n+     * @param length size of the array to build\n+     * @return a new array\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private T[] buildArray(final int length) {\n+        return (T[]) Array.newInstance(field.getZero().getClass(), length);\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + ((field == null) ? 0 : field.hashCode());\n+        result = prime * result + virtualSize;\n+        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            int temp = iter.value().hashCode();\n+            result = prime * result + temp;\n+        }\n+        return result;\n+    }\n+\n+\n+    /** {@inheritDoc} */\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public boolean equals(Object obj) {\n+\n+        if (this == obj) {\n+            return true;\n+        }\n+\n+        if (obj == null) {\n+            return false;\n+        }\n+\n+        if (!(obj instanceof SparseFieldVector)) {\n+            return false;\n+        }\n+\n+        SparseFieldVector<T> other = (SparseFieldVector<T>) obj;\n+        if (field == null) {\n+            if (other.field != null) {\n+                return false;\n+            }\n+        } else if (!field.equals(other.field)) {\n+            return false;\n+        }\n+        if (virtualSize != other.virtualSize) {\n+            return false;\n+        }\n+\n+        OpenIntToFieldHashMap<T>.Iterator iter = entries.iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            T test = other.getEntry(iter.key());\n+            if (!test.equals(iter.value())) {\n+                return false;\n+            }\n+        }\n+        iter = other.getEntries().iterator();\n+        while (iter.hasNext()) {\n+            iter.advance();\n+            T test = iter.value();\n+            if (!test.equals(getEntry(iter.key()))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/SparseRealMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Marker interface for {@link RealMatrix} implementations that require sparse backing storage\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ *\n+ */\n+public interface SparseRealMatrix extends RealMatrix {\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/SparseRealVector.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+/**\n+ * Marker interface for RealVectors that require sparse backing storage\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ *\n+ */\n+public interface SparseRealVector extends RealVector {\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/linear/TriDiagonalTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Arrays;\n+\n+\n+/**\n+ * Class transforming a symmetrical matrix to tridiagonal shape.\n+ * <p>A symmetrical m &times; m matrix A can be written as the product of three matrices:\n+ * A = Q &times; T &times; Q<sup>T</sup> with Q an orthogonal matrix and T a symmetrical\n+ * tridiagonal matrix. Both Q and T are m &times; m matrices.</p>\n+ * <p>This implementation only uses the upper part of the matrix, the part below the\n+ * diagonal is not accessed at all.</p>\n+ * <p>Transformation to tridiagonal shape is often not a goal by itself, but it is\n+ * an intermediate step in more general decomposition algorithms like {@link\n+ * EigenDecomposition eigen decomposition}. This class is therefore intended for internal\n+ * use by the library and is not public. As a consequence of this explicitly limited scope,\n+ * many methods directly returns references to internal arrays, not copies.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+class TriDiagonalTransformer {\n+\n+    /** Householder vectors. */\n+    private final double householderVectors[][];\n+\n+    /** Main diagonal. */\n+    private final double[] main;\n+\n+    /** Secondary diagonal. */\n+    private final double[] secondary;\n+\n+    /** Cached value of Q. */\n+    private RealMatrix cachedQ;\n+\n+    /** Cached value of Qt. */\n+    private RealMatrix cachedQt;\n+\n+    /** Cached value of T. */\n+    private RealMatrix cachedT;\n+\n+    /**\n+     * Build the transformation to tridiagonal shape of a symmetrical matrix.\n+     * <p>The specified matrix is assumed to be symmetrical without any check.\n+     * Only the upper triangular part of the matrix is used.</p>\n+     * @param matrix the symmetrical matrix to transform.\n+     * @exception InvalidMatrixException if matrix is not square\n+     */\n+    public TriDiagonalTransformer(RealMatrix matrix)\n+        throws InvalidMatrixException {\n+        if (!matrix.isSquare()) {\n+            throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n+        }\n+\n+        final int m = matrix.getRowDimension();\n+        householderVectors = matrix.getData();\n+        main      = new double[m];\n+        secondary = new double[m - 1];\n+        cachedQ   = null;\n+        cachedQt  = null;\n+        cachedT   = null;\n+\n+        // transform matrix\n+        transform();\n+\n+    }\n+\n+    /**\n+     * Returns the matrix Q of the transform. \n+     * <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the Q matrix\n+     */\n+    public RealMatrix getQ() {\n+        if (cachedQ == null) {\n+            cachedQ = getQT().transpose();\n+        }\n+        return cachedQ;\n+    }\n+\n+    /**\n+     * Returns the transpose of the matrix Q of the transform. \n+     * <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n+     * @return the Q matrix\n+     */\n+    public RealMatrix getQT() {\n+\n+        if (cachedQt == null) {\n+\n+            final int m = householderVectors.length;\n+            cachedQt = MatrixUtils.createRealMatrix(m, m);\n+\n+            // build up first part of the matrix by applying Householder transforms\n+            for (int k = m - 1; k >= 1; --k) {\n+                final double[] hK = householderVectors[k - 1];\n+                final double inv = 1.0 / (secondary[k - 1] * hK[k]);\n+                cachedQt.setEntry(k, k, 1);\n+                if (hK[k] != 0.0) {\n+                    double beta = 1.0 / secondary[k - 1];\n+                    cachedQt.setEntry(k, k, 1 + beta * hK[k]);\n+                    for (int i = k + 1; i < m; ++i) {\n+                        cachedQt.setEntry(k, i, beta * hK[i]);\n+                    }\n+                    for (int j = k + 1; j < m; ++j) {\n+                        beta = 0;\n+                        for (int i = k + 1; i < m; ++i) {\n+                            beta += cachedQt.getEntry(j, i) * hK[i];\n+                        }\n+                        beta *= inv;\n+                        cachedQt.setEntry(j, k, beta * hK[k]);\n+                        for (int i = k + 1; i < m; ++i) {\n+                            cachedQt.addToEntry(j, i, beta * hK[i]);\n+                        }\n+                    }\n+                }\n+            }\n+            cachedQt.setEntry(0, 0, 1);\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedQt;\n+\n+    }\n+\n+    /**\n+     * Returns the tridiagonal matrix T of the transform. \n+     * @return the T matrix\n+     */\n+    public RealMatrix getT() {\n+\n+        if (cachedT == null) {\n+\n+            final int m = main.length;\n+            cachedT = MatrixUtils.createRealMatrix(m, m);\n+            for (int i = 0; i < m; ++i) {\n+                cachedT.setEntry(i, i, main[i]);\n+                if (i > 0) {\n+                    cachedT.setEntry(i, i - 1, secondary[i - 1]);\n+                }\n+                if (i < main.length - 1) {\n+                    cachedT.setEntry(i, i + 1, secondary[i]);\n+                }\n+            }\n+\n+        }\n+\n+        // return the cached matrix\n+        return cachedT;\n+\n+    }\n+\n+    /**\n+     * Get the Householder vectors of the transform.\n+     * <p>Note that since this class is only intended for internal use,\n+     * it returns directly a reference to its internal arrays, not a copy.</p>\n+     * @return the main diagonal elements of the B matrix\n+     */\n+    double[][] getHouseholderVectorsRef() {\n+        return householderVectors;\n+    }\n+\n+    /**\n+     * Get the main diagonal elements of the matrix T of the transform.\n+     * <p>Note that since this class is only intended for internal use,\n+     * it returns directly a reference to its internal arrays, not a copy.</p>\n+     * @return the main diagonal elements of the T matrix\n+     */\n+    double[] getMainDiagonalRef() {\n+        return main;\n+    }\n+\n+    /**\n+     * Get the secondary diagonal elements of the matrix T of the transform.\n+     * <p>Note that since this class is only intended for internal use,\n+     * it returns directly a reference to its internal arrays, not a copy.</p>\n+     * @return the secondary diagonal elements of the T matrix\n+     */\n+    double[] getSecondaryDiagonalRef() {\n+        return secondary;\n+    }\n+\n+    /**\n+     * Transform original matrix to tridiagonal form.\n+     * <p>Transformation is done using Householder transforms.</p>\n+     */\n+    private void transform() {\n+\n+        final int m = householderVectors.length;\n+        final double[] z = new double[m];\n+        for (int k = 0; k < m - 1; k++) {\n+\n+            //zero-out a row and a column simultaneously\n+            final double[] hK = householderVectors[k];\n+            main[k] = hK[k];\n+            double xNormSqr = 0;\n+            for (int j = k + 1; j < m; ++j) {\n+                final double c = hK[j];\n+                xNormSqr += c * c;\n+            }\n+            final double a = (hK[k + 1] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n+            secondary[k] = a;\n+            if (a != 0.0) {\n+                // apply Householder transform from left and right simultaneously\n+\n+                hK[k + 1] -= a;\n+                final double beta = -1 / (a * hK[k + 1]);\n+\n+                // compute a = beta A v, where v is the Householder vector\n+                // this loop is written in such a way\n+                //   1) only the upper triangular part of the matrix is accessed\n+                //   2) access is cache-friendly for a matrix stored in rows\n+                Arrays.fill(z, k + 1, m, 0);\n+                for (int i = k + 1; i < m; ++i) {\n+                    final double[] hI = householderVectors[i];\n+                    final double hKI = hK[i];\n+                    double zI = hI[i] * hKI;\n+                    for (int j = i + 1; j < m; ++j) {\n+                        final double hIJ = hI[j];\n+                        zI   += hIJ * hK[j];\n+                        z[j] += hIJ * hKI;\n+                    }\n+                    z[i] = beta * (z[i] + zI);\n+                }\n+\n+                // compute gamma = beta vT z / 2\n+                double gamma = 0;\n+                for (int i = k + 1; i < m; ++i) {\n+                    gamma += z[i] * hK[i];\n+                }\n+                gamma *= beta / 2;\n+\n+                // compute z = z - gamma v\n+                for (int i = k + 1; i < m; ++i) {\n+                    z[i] -= gamma * hK[i];\n+                }\n+\n+                // update matrix: A = A - v zT - z vT\n+                // only the upper triangular part of the matrix is updated\n+                for (int i = k + 1; i < m; ++i) {\n+                    final double[] hI = householderVectors[i];\n+                    for (int j = i; j < m; ++j) {\n+                        hI[j] -= hK[i] * z[j] + z[i] * hK[j];\n+                    }\n+                }\n+\n+            }\n+\n+        }\n+        main[m - 1] = householderVectors[m - 1][m - 1];\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/AbstractIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+\n+import org.apache.commons.math.MaxEvaluationsExceededException;\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.events.EventState;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+/**\n+ * Base class managing common boilerplate for all integrators.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n+\n+    \n+    /** Name of the method. */\n+    private final String name;\n+\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n+    /** Number of evaluations already performed. */\n+    private int evaluations;\n+\n+    /** Differential equations to integrate. */\n+    private transient FirstOrderDifferentialEquations equations;\n+\n+    /** Step handler. */\n+    protected Collection<StepHandler> stepHandlers;\n+\n+    /** Current step start time. */\n+    protected double stepStart;\n+\n+    /** Current stepsize. */\n+    protected double stepSize;\n+\n+    /** Events handlers manager. */\n+    protected CombinedEventsManager eventsHandlersManager;\n+\n+    /** Build an instance.\n+     * @param name name of the method\n+     */\n+    public AbstractIntegrator(final String name) {\n+        this.name = name;\n+        stepHandlers = new ArrayList<StepHandler>();\n+        stepStart = Double.NaN;\n+        stepSize  = Double.NaN;\n+        eventsHandlersManager = new CombinedEventsManager();\n+        setMaxEvaluations(-1);\n+        resetEvaluations();\n+    }\n+\n+    /** Build an instance with a null name.\n+     */\n+    protected AbstractIntegrator() {\n+        this(null);\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void addStepHandler(final StepHandler handler) {\n+        stepHandlers.add(handler);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Collection<StepHandler> getStepHandlers() {\n+        return Collections.unmodifiableCollection(stepHandlers);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void clearStepHandlers() {\n+        stepHandlers.clear();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void addEventHandler(final EventHandler function,\n+                                final double maxCheckInterval,\n+                                final double convergence,\n+                                final int maxIterationCount) {\n+        eventsHandlersManager.addEventHandler(function, maxCheckInterval,\n+                                              convergence, maxIterationCount);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Collection<EventHandler> getEventHandlers() {\n+        return eventsHandlersManager.getEventsHandlers();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void clearEventHandlers() {\n+        eventsHandlersManager.clearEventsHandlers();\n+    }\n+\n+    /** Check if one of the step handlers requires dense output.\n+     * @return true if one of the step handlers requires dense output\n+     */\n+    protected boolean requiresDenseOutput() {\n+        for (StepHandler handler : stepHandlers) {\n+            if (handler.requiresDenseOutput()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getCurrentStepStart() {\n+        return stepStart;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getCurrentSignedStepsize() {\n+        return stepSize;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = (maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return evaluations;\n+    }\n+\n+    /** Reset the number of evaluations to zero.\n+     */\n+    protected void resetEvaluations() {\n+        evaluations = 0;\n+    }\n+\n+    /** Set the differential equations.\n+     * @param equations differential equations to integrate\n+     * @see #computeDerivatives(double, double[], double[])\n+     */\n+    protected void setEquations(final FirstOrderDifferentialEquations equations) {\n+        this.equations = equations;\n+    }\n+\n+    /** Compute the derivatives and check the number of evaluations.\n+     * @param t current value of the independent <I>time</I> variable\n+     * @param y array containing the current value of the state vector\n+     * @param yDot placeholder array where to put the time derivative of the state vector\n+     * @throws DerivativeException this exception is propagated to the caller if the\n+     * underlying user function triggers one\n+     */\n+    public void computeDerivatives(final double t, final double[] y, final double[] yDot)\n+        throws DerivativeException {\n+        if (++evaluations > maxEvaluations) {\n+            throw new DerivativeException(new MaxEvaluationsExceededException(maxEvaluations));\n+        }\n+        equations.computeDerivatives(t, y, yDot);\n+    }\n+\n+    /** Perform some sanity checks on the integration parameters.\n+     * @param equations differential equations set\n+     * @param t0 start time\n+     * @param y0 state vector at t0\n+     * @param t target time for the integration\n+     * @param y placeholder where to put the state vector\n+     * @exception IntegratorException if some inconsistency is detected\n+     */\n+    protected void sanityChecks(final FirstOrderDifferentialEquations equations,\n+                                final double t0, final double[] y0,\n+                                final double t, final double[] y)\n+        throws IntegratorException {\n+\n+        if (equations.getDimension() != y0.length) {\n+            throw new IntegratorException(\n+                    \"dimensions mismatch: ODE problem has dimension {0},\" +\n+                    \" initial state vector has dimension {1}\",\n+                    equations.getDimension(), y0.length);\n+        }\n+\n+        if (equations.getDimension() != y.length) {\n+            throw new IntegratorException(\n+                    \"dimensions mismatch: ODE problem has dimension {0},\" +\n+                    \" final state vector has dimension {1}\",\n+                    equations.getDimension(), y.length);\n+        }\n+\n+        if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\n+            throw new IntegratorException(\n+                    \"too small integration interval: length = {0}\",\n+                    Math.abs(t - t0));\n+        }\n+\n+    }\n+\n+    /** Add an event handler for end time checking.\n+     * <p>This method can be used to simplify handling of integration end time.\n+     * It leverages the nominal stop condition with the exceptional stop\n+     * conditions.</p>\n+     * @param startTime integration start time\n+     * @param endTime desired end time\n+     * @param manager manager containing the user-defined handlers\n+     * @return a new manager containing all the user-defined handlers plus a\n+     * dedicated manager triggering a stop event at entTime\n+     */\n+    protected CombinedEventsManager addEndTimeChecker(final double startTime,\n+                                                      final double endTime,\n+                                                      final CombinedEventsManager manager) {\n+        CombinedEventsManager newManager = new CombinedEventsManager();\n+        for (final EventState state : manager.getEventsStates()) {\n+            newManager.addEventHandler(state.getEventHandler(),\n+                                       state.getMaxCheckInterval(),\n+                                       state.getConvergence(),\n+                                       state.getMaxIterationCount());\n+        }\n+        newManager.addEventHandler(new EndTimeChecker(endTime),\n+                                   Double.POSITIVE_INFINITY,\n+                                   Math.ulp(Math.max(Math.abs(startTime), Math.abs(endTime))),\n+                                   100);\n+        return newManager;\n+    }\n+\n+    /** Specialized event handler to stop integration. */\n+    private static class EndTimeChecker implements EventHandler {\n+\n+        /** Desired end time. */\n+        private final double endTime;\n+\n+        /** Build an instance.\n+         * @param endTime desired time\n+         */\n+        public EndTimeChecker(final double endTime) {\n+            this.endTime = endTime;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int eventOccurred(double t, double[] y, boolean increasing) {\n+            return STOP;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double g(double t, double[] y) {\n+            return t - endTime;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void resetState(double t, double[] y) {\n+        }\n+        \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class stores all information provided by an ODE integrator\n+ * during the integration process and build a continuous model of the\n+ * solution from this.\n+ *\n+ * <p>This class act as a step handler from the integrator point of\n+ * view. It is called iteratively during the integration process and\n+ * stores a copy of all steps information in a sorted collection for\n+ * later use. Once the integration process is over, the user can use\n+ * the {@link #setInterpolatedTime setInterpolatedTime} and {@link\n+ * #getInterpolatedState getInterpolatedState} to retrieve this\n+ * information at any time. It is important to wait for the\n+ * integration to be over before attempting to call {@link\n+ * #setInterpolatedTime setInterpolatedTime} because some internal\n+ * variables are set only once the last step has been handled.</p>\n+ *\n+ * <p>This is useful for example if the main loop of the user\n+ * application should remain independent from the integration process\n+ * or if one needs to mimic the behaviour of an analytical model\n+ * despite a numerical model is used (i.e. one needs the ability to\n+ * get the model value at any time or to navigate through the\n+ * data).</p>\n+ *\n+ * <p>If problem modeling is done with several separate\n+ * integration phases for contiguous intervals, the same\n+ * ContinuousOutputModel can be used as step handler for all\n+ * integration phases as long as they are performed in order and in\n+ * the same direction. As an example, one can extrapolate the\n+ * trajectory of a satellite with one model (i.e. one set of\n+ * differential equations) up to the beginning of a maneuver, use\n+ * another more complex model including thrusters modeling and\n+ * accurate attitude control during the maneuver, and revert to the\n+ * first model after the end of the maneuver. If the same continuous\n+ * output model handles the steps of all integration phases, the user\n+ * do not need to bother when the maneuver begins or ends, he has all\n+ * the data available in a transparent manner.</p>\n+ *\n+ * <p>An important feature of this class is that it implements the\n+ * <code>Serializable</code> interface. This means that the result of\n+ * an integration can be serialized and reused later (if stored into a\n+ * persistent medium like a filesystem or a database) or elsewhere (if\n+ * sent to another application). Only the result of the integration is\n+ * stored, there is no reference to the integrated problem by\n+ * itself.</p>\n+ *\n+ * <p>One should be aware that the amount of data stored in a\n+ * ContinuousOutputModel instance can be important if the state vector\n+ * is large, if the integration interval is long or if the steps are\n+ * small (which can result from small tolerance settings in {@link\n+ * AdaptiveStepsizeIntegrator adaptive step size integrators}).</p>\n+ *\n+ * @see StepHandler\n+ * @see StepInterpolator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class ContinuousOutputModel\n+  implements StepHandler, Serializable {\n+\n+  /** Simple constructor.\n+   * Build an empty continuous output model.\n+   */\n+  public ContinuousOutputModel() {\n+    steps = new ArrayList<StepInterpolator>();\n+    reset();\n+  }\n+\n+  /** Append another model at the end of the instance.\n+   * @param model model to add at the end of the instance\n+   * @exception DerivativeException if some step interpolators from\n+   * the appended model cannot be copied\n+   * @exception IllegalArgumentException if the model to append is not\n+   * compatible with the instance (dimension of the state vector,\n+   * propagation direction, hole between the dates)\n+   */\n+  public void append(final ContinuousOutputModel model)\n+    throws DerivativeException {\n+\n+    if (model.steps.size() == 0) {\n+      return;\n+    }\n+\n+    if (steps.size() == 0) {\n+      initialTime = model.initialTime;\n+      forward     = model.forward;\n+    } else {\n+\n+      if (getInterpolatedState().length != model.getInterpolatedState().length) {\n+          throw MathRuntimeException.createIllegalArgumentException(\n+                \"dimension mismatch {0} != {1}\",\n+                getInterpolatedState().length, model.getInterpolatedState().length);\n+      }\n+\n+      if (forward ^ model.forward) {\n+          throw MathRuntimeException.createIllegalArgumentException(\n+                \"propagation direction mismatch\");\n+      }\n+\n+      final StepInterpolator lastInterpolator = steps.get(index);\n+      final double current  = lastInterpolator.getCurrentTime();\n+      final double previous = lastInterpolator.getPreviousTime();\n+      final double step = current - previous;\n+      final double gap = model.getInitialTime() - current;\n+      if (Math.abs(gap) > 1.0e-3 * Math.abs(step)) {\n+        throw MathRuntimeException.createIllegalArgumentException(\n+              \"{0} wide hole between models time ranges\", Math.abs(gap));\n+      }\n+\n+    }\n+\n+    for (StepInterpolator interpolator : model.steps) {\n+      steps.add(interpolator.copy());\n+    }\n+\n+    index = steps.size() - 1;\n+    finalTime = (steps.get(index)).getCurrentTime();\n+\n+  }\n+\n+  /** Determines whether this handler needs dense output.\n+   * <p>The essence of this class is to provide dense output over all\n+   * steps, hence it requires the internal steps to provide themselves\n+   * dense output. The method therefore returns always true.</p>\n+   * @return always true\n+   */\n+  public boolean requiresDenseOutput() {\n+    return true;\n+  }\n+\n+  /** Reset the step handler.\n+   * Initialize the internal data as required before the first step is\n+   * handled.\n+   */\n+  public void reset() {\n+    initialTime = Double.NaN;\n+    finalTime   = Double.NaN;\n+    forward     = true;\n+    index       = 0;\n+    steps.clear();\n+   }\n+\n+  /** Handle the last accepted step.\n+   * A copy of the information provided by the last step is stored in\n+   * the instance for later use.\n+   * @param interpolator interpolator for the last accepted step.\n+   * @param isLast true if the step is the last one\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+   */\n+  public void handleStep(final StepInterpolator interpolator, final boolean isLast)\n+    throws DerivativeException {\n+\n+    if (steps.size() == 0) {\n+      initialTime = interpolator.getPreviousTime();\n+      forward     = interpolator.isForward();\n+    }\n+\n+    steps.add(interpolator.copy());\n+\n+    if (isLast) {\n+      finalTime = interpolator.getCurrentTime();\n+      index     = steps.size() - 1;\n+    }\n+\n+  }\n+\n+  /**\n+   * Get the initial integration time.\n+   * @return initial integration time\n+   */\n+  public double getInitialTime() {\n+    return initialTime;\n+  }\n+    \n+  /**\n+   * Get the final integration time.\n+   * @return final integration time\n+   */\n+  public double getFinalTime() {\n+    return finalTime;\n+  }\n+\n+  /**\n+   * Get the time of the interpolated point.\n+   * If {@link #setInterpolatedTime} has not been called, it returns\n+   * the final integration time.\n+   * @return interpolation point time\n+   */\n+  public double getInterpolatedTime() {\n+    return steps.get(index).getInterpolatedTime();\n+  }\n+    \n+  /** Set the time of the interpolated point.\n+   * <p>This method should <strong>not</strong> be called before the\n+   * integration is over because some internal variables are set only\n+   * once the last step has been handled.</p>\n+   * <p>Setting the time outside of the integration interval is now\n+   * allowed (it was not allowed up to version 5.9 of Mantissa), but\n+   * should be used with care since the accuracy of the interpolator\n+   * will probably be very poor far from this interval. This allowance\n+   * has been added to simplify implementation of search algorithms\n+   * near the interval endpoints.</p>\n+   * @param time time of the interpolated point\n+   */\n+  public void setInterpolatedTime(final double time) {\n+\n+      // initialize the search with the complete steps table\n+      int iMin = 0;\n+      final StepInterpolator sMin = steps.get(iMin);\n+      double tMin = 0.5 * (sMin.getPreviousTime() + sMin.getCurrentTime());\n+\n+      int iMax = steps.size() - 1;\n+      final StepInterpolator sMax = steps.get(iMax);\n+      double tMax = 0.5 * (sMax.getPreviousTime() + sMax.getCurrentTime());\n+\n+      // handle points outside of the integration interval\n+      // or in the first and last step\n+      if (locatePoint(time, sMin) <= 0) {\n+        index = iMin;\n+        sMin.setInterpolatedTime(time);\n+        return;\n+      }\n+      if (locatePoint(time, sMax) >= 0) {\n+        index = iMax;\n+        sMax.setInterpolatedTime(time);\n+        return;\n+      }\n+\n+      // reduction of the table slice size\n+      while (iMax - iMin > 5) {\n+\n+        // use the last estimated index as the splitting index\n+        final StepInterpolator si = steps.get(index);\n+        final int location = locatePoint(time, si);\n+        if (location < 0) {\n+          iMax = index;\n+          tMax = 0.5 * (si.getPreviousTime() + si.getCurrentTime());\n+        } else if (location > 0) {\n+          iMin = index;\n+          tMin = 0.5 * (si.getPreviousTime() + si.getCurrentTime());\n+        } else {\n+          // we have found the target step, no need to continue searching\n+          si.setInterpolatedTime(time);\n+          return;\n+        }\n+\n+        // compute a new estimate of the index in the reduced table slice\n+        final int iMed = (iMin + iMax) / 2;\n+        final StepInterpolator sMed = steps.get(iMed);\n+        final double tMed = 0.5 * (sMed.getPreviousTime() + sMed.getCurrentTime());\n+\n+        if ((Math.abs(tMed - tMin) < 1e-6) || (Math.abs(tMax - tMed) < 1e-6)) {\n+          // too close to the bounds, we estimate using a simple dichotomy\n+          index = iMed;\n+        } else {\n+          // estimate the index using a reverse quadratic polynom\n+          // (reverse means we have i = P(t), thus allowing to simply\n+          // compute index = P(time) rather than solving a quadratic equation)\n+          final double d12 = tMax - tMed;\n+          final double d23 = tMed - tMin;\n+          final double d13 = tMax - tMin;\n+          final double dt1 = time - tMax;\n+          final double dt2 = time - tMed;\n+          final double dt3 = time - tMin;\n+          final double iLagrange = ((dt2 * dt3 * d23) * iMax -\n+                                    (dt1 * dt3 * d13) * iMed +\n+                                    (dt1 * dt2 * d12) * iMin) /\n+                                   (d12 * d23 * d13);\n+          index = (int) Math.rint(iLagrange);\n+        }\n+\n+        // force the next size reduction to be at least one tenth\n+        final int low  = Math.max(iMin + 1, (9 * iMin + iMax) / 10);\n+        final int high = Math.min(iMax - 1, (iMin + 9 * iMax) / 10);\n+        if (index < low) {\n+          index = low;\n+        } else if (index > high) {\n+          index = high;\n+        }\n+\n+      }\n+\n+      // now the table slice is very small, we perform an iterative search\n+      index = iMin;\n+      while ((index <= iMax) && (locatePoint(time, steps.get(index)) > 0)) {\n+        ++index;\n+      }\n+\n+      steps.get(index).setInterpolatedTime(time);\n+\n+  }\n+\n+  /**\n+   * Get the state vector of the interpolated point.\n+   * @return state vector at time {@link #getInterpolatedTime}\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   */\n+  public double[] getInterpolatedState() throws DerivativeException {\n+    return steps.get(index).getInterpolatedState();\n+  }\n+\n+  /** Compare a step interval and a double. \n+   * @param time point to locate\n+   * @param interval step interval\n+   * @return -1 if the double is before the interval, 0 if it is in\n+   * the interval, and +1 if it is after the interval, according to\n+   * the interval direction\n+   */\n+  private int locatePoint(final double time, final StepInterpolator interval) {\n+    if (forward) {\n+      if (time < interval.getPreviousTime()) {\n+        return -1;\n+      } else if (time > interval.getCurrentTime()) {\n+        return +1;\n+      } else {\n+        return 0;\n+      }\n+    }\n+    if (time > interval.getPreviousTime()) {\n+      return -1;\n+    } else if (time < interval.getCurrentTime()) {\n+      return +1;\n+    } else {\n+      return 0;\n+    }\n+  }\n+\n+  /** Initial integration time. */\n+  private double initialTime;\n+\n+  /** Final integration time. */\n+  private double finalTime;\n+\n+  /** Integration direction indicator. */\n+  private boolean forward;\n+\n+  /** Current interpolator index. */\n+  private int index;\n+\n+  /** Steps table. */\n+  private List<StepInterpolator> steps;\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -1417964919405031606L;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/DerivativeException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * This exception is made available to users to report\n+ * the error conditions that are triggered while computing\n+ * the differential equations.\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class DerivativeException\n+  extends MathException {\n+    \n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = 5666710788967425123L;\n+\n+  /** Simple constructor.\n+   * Build an exception by translating and formating a message\n+   * @param specifier format specifier (to be translated)\n+   * @param parts to insert in the format (no translation)\n+   */\n+  public DerivativeException(final String specifier, final Object ... parts) {\n+    super(specifier, parts);\n+  }\n+\n+  /** Build an instance from an underlying cause.\n+   * @param cause cause for the exception\n+   */\n+  public DerivativeException(final Throwable cause) {\n+    super(cause);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/FirstOrderConverter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+/** This class converts second order differential equations to first\n+ * order ones.\n+ *\n+ * <p>This class is a wrapper around a {@link\n+ * SecondOrderDifferentialEquations} which allow to use a {@link\n+ * FirstOrderIntegrator} to integrate it.</p>\n+ *\n+ * <p>The transformation is done by changing the n dimension state\n+ * vector to a 2n dimension vector, where the first n components are\n+ * the initial state variables and the n last components are their\n+ * first time derivative. The first time derivative of this state\n+ * vector then really contains both the first and second time\n+ * derivative of the initial state vector, which can be handled by the\n+ * underlying second order equations set.</p>\n+ *\n+ * <p>One should be aware that the data is duplicated during the\n+ * transformation process and that for each call to {@link\n+ * #computeDerivatives computeDerivatives}, this wrapper does copy 4n\n+ * scalars : 2n before the call to {@link\n+ * SecondOrderDifferentialEquations#computeSecondDerivatives\n+ * computeSecondDerivatives} in order to dispatch the y state vector\n+ * into z and zDot, and 2n after the call to gather zDot and zDDot\n+ * into yDot. Since the underlying problem by itself perhaps also\n+ * needs to copy data and dispatch the arrays into domain objects,\n+ * this has an impact on both memory and CPU usage. The only way to\n+ * avoid this duplication is to perform the transformation at the\n+ * problem level, i.e. to implement the problem as a first order one\n+ * and then avoid using this class.</p>\n+ *\n+ * @see FirstOrderIntegrator\n+ * @see FirstOrderDifferentialEquations\n+ * @see SecondOrderDifferentialEquations\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class FirstOrderConverter implements FirstOrderDifferentialEquations {\n+\n+  /** Simple constructor.\n+   * Build a converter around a second order equations set.\n+   * @param equations second order equations set to convert\n+   */\n+  public FirstOrderConverter (final SecondOrderDifferentialEquations equations) {\n+      this.equations = equations;\n+      dimension      = equations.getDimension();\n+      z              = new double[dimension];\n+      zDot           = new double[dimension];\n+      zDDot          = new double[dimension];\n+  }\n+\n+  /** Get the dimension of the problem.\n+   * <p>The dimension of the first order problem is twice the\n+   * dimension of the underlying second order problem.</p>\n+   * @return dimension of the problem\n+   */\n+  public int getDimension() {\n+    return 2 * dimension;\n+  }\n+\n+  /** Get the current time derivative of the state vector.\n+   * @param t current value of the independent <I>time</I> variable\n+   * @param y array containing the current value of the state vector\n+   * @param yDot placeholder array where to put the time derivative of the state vector\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  public void computeDerivatives(final double t, final double[] y, final double[] yDot)\n+      throws DerivativeException {\n+\n+    // split the state vector in two\n+    System.arraycopy(y, 0,         z,    0, dimension);\n+    System.arraycopy(y, dimension, zDot, 0, dimension);\n+\n+    // apply the underlying equations set\n+    equations.computeSecondDerivatives(t, z, zDot, zDDot);\n+\n+    // build the result state derivative\n+    System.arraycopy(zDot,  0, yDot, 0,         dimension);\n+    System.arraycopy(zDDot, 0, yDot, dimension, dimension);\n+    \n+  }\n+\n+  /** Underlying second order equations set. */\n+  private SecondOrderDifferentialEquations equations;\n+\n+  /** second order problem dimension. */\n+  private int dimension;\n+\n+  /** state vector. */\n+  private double[] z;\n+\n+  /** first time derivative of the state vector. */\n+  private double[] zDot;\n+\n+  /** second time derivative of the state vector. */\n+  private double[] zDDot;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/FirstOrderDifferentialEquations.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+\n+/** This interface represents a first order differential equations set.\n+ *\n+ * <p>This interface should be implemented by all real first order\n+ * differential equation problems before they can be handled by the\n+ * integrators {@link FirstOrderIntegrator#integrate} method.</p>\n+ *\n+ * <p>A first order differential equations problem, as seen by an\n+ * integrator is the time derivative <code>dY/dt</code> of a state\n+ * vector <code>Y</code>, both being one dimensional arrays. From the\n+ * integrator point of view, this derivative depends only on the\n+ * current time <code>t</code> and on the state vector\n+ * <code>Y</code>.</p>\n+ *\n+ * <p>For real problems, the derivative depends also on parameters\n+ * that do not belong to the state vector (dynamical model constants\n+ * for example). These constants are completely outside of the scope\n+ * of this interface, the classes that implement it are allowed to\n+ * handle them as they want.</p>\n+ *\n+ * @see FirstOrderIntegrator\n+ * @see FirstOrderConverter\n+ * @see SecondOrderDifferentialEquations\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public interface FirstOrderDifferentialEquations {\n+    \n+    /** Get the dimension of the problem.\n+     * @return dimension of the problem\n+     */\n+    public int getDimension();\n+    \n+    /** Get the current time derivative of the state vector.\n+     * @param t current value of the independent <I>time</I> variable\n+     * @param y array containing the current value of the state vector\n+     * @param yDot placeholder array where to put the time derivative of the state vector\n+     * @throws DerivativeException this exception is propagated to the caller if the\n+     * underlying user function triggers one\n+     */\n+    public void computeDerivatives(double t, double[] y, double[] yDot)\n+    throws DerivativeException;\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/FirstOrderIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+/** This interface represents a first order integrator for\n+ * differential equations.\n+\n+ * <p>The classes which are devoted to solve first order differential\n+ * equations should implement this interface. The problems which can\n+ * be handled should implement the {@link\n+ * FirstOrderDifferentialEquations} interface.</p>\n+ *\n+ * @see FirstOrderDifferentialEquations\n+ * @see StepHandler\n+ * @see EventHandler\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public interface FirstOrderIntegrator extends ODEIntegrator {\n+\n+  /** Integrate the differential equations up to the given time.\n+   * <p>This method solves an Initial Value Problem (IVP).</p>\n+   * <p>Since this method stores some internal state variables made\n+   * available in its public interface during integration ({@link\n+   * #getCurrentSignedStepsize()}), it is <em>not</em> thread-safe.</p>\n+   * @param equations differential equations to integrate\n+   * @param t0 initial time\n+   * @param y0 initial value of the state vector at t0\n+   * @param t target time for the integration\n+   * (can be set to a value smaller than <code>t0</code> for backward integration)\n+   * @param y placeholder where to put the state vector at each successful\n+   *  step (and hence at the end of integration), can be the same object as y0\n+   * @return stop time, will be the same as target time if integration reached its\n+   * target, but may be different if some {@link EventHandler} stops it at some point.\n+   * @throws IntegratorException if the integrator cannot perform integration\n+   * @throws DerivativeException this exception is propagated to the caller if\n+   * the underlying user function triggers one\n+   */\n+  public double integrate (FirstOrderDifferentialEquations equations,\n+                           double t0, double[] y0,\n+                           double t, double[] y)\n+    throws DerivativeException, IntegratorException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/IntegratorException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * This exception is made available to users to report\n+ * the error conditions that are triggered during integration\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class IntegratorException\n+  extends MathException {\n+\n+  /** Serializable version identifier */\n+    private static final long serialVersionUID = -1607588949778036796L;\n+\n+  /** Simple constructor.\n+   * Build an exception by translating and formating a message\n+   * @param specifier format specifier (to be translated)\n+   * @param parts to insert in the format (no translation)\n+   */\n+  public IntegratorException(final String specifier, final Object ... parts) {\n+    super(specifier, parts);\n+  }\n+\n+  /**\n+   * Create an exception with a given root cause.\n+   * @param cause  the exception or error that caused this exception to be thrown\n+   */\n+  public IntegratorException(final Throwable cause) {\n+    super(cause);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/MultistepIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator;\n+import org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class is the base class for multistep integrators for Ordinary\n+ * Differential Equations.\n+ * <p>We define scaled derivatives s<sub>i</sub>(n) at step n as:\n+ * <pre>\n+ * s<sub>1</sub>(n) = h y'<sub>n</sub> for first derivative\n+ * s<sub>2</sub>(n) = h<sup>2</sup>/2 y''<sub>n</sub> for second derivative\n+ * s<sub>3</sub>(n) = h<sup>3</sup>/6 y'''<sub>n</sub> for third derivative\n+ * ...\n+ * s<sub>k</sub>(n) = h<sup>k</sup>/k! y(k)<sub>n</sub> for k<sup>th</sup> derivative\n+ * </pre></p>\n+ * <p>Rather than storing several previous steps separately, this implementation uses\n+ * the Nordsieck vector with higher degrees scaled derivatives all taken at the same\n+ * step (y<sub>n</sub>, s<sub>1</sub>(n) and r<sub>n</sub>) where r<sub>n</sub> is defined as:\n+ * <pre>\n+ * r<sub>n</sub> = [ s<sub>2</sub>(n), s<sub>3</sub>(n) ... s<sub>k</sub>(n) ]<sup>T</sup>\n+ * </pre>\n+ * (we omit the k index in the notation for clarity)</p>\n+ * <p>\n+ * Multistep integrators with Nordsieck representation are highly sensitive to\n+ * large step changes because when the step is multiplied by a factor a, the\n+ * k<sup>th</sup> component of the Nordsieck vector is multiplied by a<sup>k</sup>\n+ * and the last components are the least accurate ones. The default max growth\n+ * factor is therefore set to a quite low value: 2<sup>1/order</sup>.\n+ * </p>\n+ *\n+ * @see org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator\n+ * @see org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class MultistepIntegrator extends AdaptiveStepsizeIntegrator {\n+\n+    /** Starter integrator. */\n+    private FirstOrderIntegrator starter;\n+\n+    /** Number of steps of the multistep method (excluding the one being computed). */\n+    private final int nSteps;\n+\n+    /** First scaled derivative (h y'). */\n+    protected double[] scaled;\n+\n+    /** Nordsieck matrix of the higher scaled derivatives.\n+     * <p>(h<sup>2</sup>/2 y'', h<sup>3</sup>/6 y''' ..., h<sup>k</sup>/k! y(k))</p>\n+     */\n+    protected Array2DRowRealMatrix nordsieck;\n+\n+    /** Stepsize control exponent. */\n+    private double exp;\n+\n+    /** Safety factor for stepsize control. */\n+    private double safety;\n+\n+    /** Minimal reduction factor for stepsize control. */\n+    private double minReduction;\n+\n+    /** Maximal growth factor for stepsize control. */\n+    private double maxGrowth;\n+\n+    /**\n+     * Build a multistep integrator with the given stepsize bounds.\n+     * <p>The default starter integrator is set to the {@link\n+     * DormandPrince853Integrator Dormand-Prince 8(5,3)} integrator with\n+     * some defaults settings.</p>\n+     * <p>\n+     * The default max growth factor is set to a quite low value: 2<sup>1/order</sup>.\n+     * </p>\n+     * @param name name of the method\n+     * @param nSteps number of steps of the multistep method\n+     * (excluding the one being computed)\n+     * @param order order of the method\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param scalAbsoluteTolerance allowed absolute error\n+     * @param scalRelativeTolerance allowed relative error\n+     */\n+    protected MultistepIntegrator(final String name, final int nSteps,\n+                                  final int order,\n+                                  final double minStep, final double maxStep,\n+                                  final double scalAbsoluteTolerance,\n+                                  final double scalRelativeTolerance) {\n+\n+        super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+\n+        if (nSteps <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} method needs at least one previous point\",\n+                  name);\n+        }\n+\n+        starter = new DormandPrince853Integrator(minStep, maxStep,\n+                                                 scalAbsoluteTolerance,\n+                                                 scalRelativeTolerance);\n+        this.nSteps = nSteps;\n+\n+        exp = -1.0 / order;\n+\n+        // set the default values of the algorithm control parameters\n+        setSafety(0.9);\n+        setMinReduction(0.2);\n+        setMaxGrowth(Math.pow(2.0, -exp));\n+\n+    }\n+\n+    /**\n+     * Build a multistep integrator with the given stepsize bounds.\n+     * <p>The default starter integrator is set to the {@link\n+     * DormandPrince853Integrator Dormand-Prince 8(5,3)} integrator with\n+     * some defaults settings.</p>\n+     * <p>\n+     * The default max growth factor is set to a quite low value: 2<sup>1/order</sup>.\n+     * </p>\n+     * @param name name of the method\n+     * @param nSteps number of steps of the multistep method\n+     * (excluding the one being computed)\n+     * @param order order of the method\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param vecAbsoluteTolerance allowed absolute error\n+     * @param vecRelativeTolerance allowed relative error\n+     */\n+    protected MultistepIntegrator(final String name, final int nSteps,\n+                                  final int order,\n+                                  final double minStep, final double maxStep,\n+                                  final double[] vecAbsoluteTolerance,\n+                                  final double[] vecRelativeTolerance) {\n+        super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+        starter = new DormandPrince853Integrator(minStep, maxStep,\n+                                                 vecAbsoluteTolerance,\n+                                                 vecRelativeTolerance);\n+        this.nSteps = nSteps;\n+\n+        exp = -1.0 / order;\n+\n+        // set the default values of the algorithm control parameters\n+        setSafety(0.9);\n+        setMinReduction(0.2);\n+        setMaxGrowth(Math.pow(2.0, -exp));\n+\n+    }\n+\n+    /**\n+     * Get the starter integrator.\n+     * @return starter integrator\n+     */\n+    public ODEIntegrator getStarterIntegrator() {\n+        return starter;\n+    }\n+\n+    /**\n+     * Set the starter integrator.\n+     * <p>The various step and event handlers for this starter integrator\n+     * will be managed automatically by the multi-step integrator. Any\n+     * user configuration for these elements will be cleared before use.</p>\n+     * @param starter starter integrator\n+     */\n+    public void setStarterIntegrator(FirstOrderIntegrator starter) {\n+        this.starter = starter;\n+    }\n+\n+    /** Start the integration.\n+     * <p>This method computes one step using the underlying starter integrator,\n+     * and initializes the Nordsieck vector at step start. The starter integrator\n+     * purpose is only to establish initial conditions, it does not really change\n+     * time by itself. The top level multistep integrator remains in charge of\n+     * handling time propagation and events handling as it will starts its own\n+     * computation right from the beginning. In a sense, the starter integrator\n+     * can be seen as a dummy one and so it will never trigger any user event nor\n+     * call any user step handler.</p>\n+     * @param t0 initial time\n+     * @param y0 initial value of the state vector at t0\n+     * @param t target time for the integration\n+     * (can be set to a value smaller than <code>t0</code> for backward integration)\n+     * @throws IntegratorException if the integrator cannot perform integration\n+     * @throws DerivativeException this exception is propagated to the caller if\n+     * the underlying user function triggers one\n+     */\n+    protected void start(final double t0, final double[] y0, final double t)\n+        throws DerivativeException, IntegratorException {\n+\n+        // make sure NO user event nor user step handler is triggered,\n+        // this is the task of the top level integrator, not the task\n+        // of the starter integrator\n+        starter.clearEventHandlers();\n+        starter.clearStepHandlers();\n+\n+        // set up one specific step handler to extract initial Nordsieck vector\n+        starter.addStepHandler(new NordsieckInitializer(y0.length));\n+\n+        // start integration, expecting a InitializationCompletedMarkerException\n+        try {\n+            starter.integrate(new CountingDifferentialEquations(y0.length),\n+                              t0, y0, t, new double[y0.length]);\n+        } catch (DerivativeException de) {\n+            if (!(de instanceof InitializationCompletedMarkerException)) {\n+                // this is not the expected nominal interruption of the start integrator\n+                throw de;\n+            }\n+        }\n+\n+        // remove the specific step handler\n+        starter.clearStepHandlers();\n+\n+    }\n+\n+    /** Initialize the high order scaled derivatives at step start.\n+     * @param first first scaled derivative at step start\n+     * @param multistep scaled derivatives after step start (hy'1, ..., hy'k-1)\n+     * will be modified\n+     * @return high order scaled derivatives at step start\n+     */\n+    protected abstract Array2DRowRealMatrix initializeHighOrderDerivatives(final double[] first,\n+                                                                           final double[][] multistep);\n+\n+    /** Get the minimal reduction factor for stepsize control.\n+     * @return minimal reduction factor\n+     */\n+    public double getMinReduction() {\n+        return minReduction;\n+    }\n+\n+    /** Set the minimal reduction factor for stepsize control.\n+     * @param minReduction minimal reduction factor\n+     */\n+    public void setMinReduction(final double minReduction) {\n+        this.minReduction = minReduction;\n+    }\n+\n+    /** Get the maximal growth factor for stepsize control.\n+     * @return maximal growth factor\n+     */\n+    public double getMaxGrowth() {\n+        return maxGrowth;\n+    }\n+\n+    /** Set the maximal growth factor for stepsize control.\n+     * @param maxGrowth maximal growth factor\n+     */\n+    public void setMaxGrowth(final double maxGrowth) {\n+        this.maxGrowth = maxGrowth;\n+    }\n+\n+    /** Get the safety factor for stepsize control.\n+     * @return safety factor\n+     */\n+    public double getSafety() {\n+      return safety;\n+    }\n+\n+    /** Set the safety factor for stepsize control.\n+     * @param safety safety factor\n+     */\n+    public void setSafety(final double safety) {\n+      this.safety = safety;\n+    }\n+\n+    /** Compute step grow/shrink factor according to normalized error.\n+     * @param error normalized error of the current step\n+     * @return grow/shrink factor for next step\n+     */\n+    protected double computeStepGrowShrinkFactor(final double error) {\n+        return Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\n+    }\n+\n+    /** Transformer used to convert the first step to Nordsieck representation. */\n+    public static interface NordsieckTransformer {\n+        /** Initialize the high order scaled derivatives at step start.\n+         * @param first first scaled derivative at step start\n+         * @param multistep scaled derivatives after step start (hy'1, ..., hy'k-1)\n+         * will be modified\n+         * @return high order derivatives at step start\n+         */\n+        RealMatrix initializeHighOrderDerivatives(double[] first, double[][] multistep);\n+    }\n+\n+    /** Specialized step handler storing the first step. */\n+    private class NordsieckInitializer implements StepHandler {\n+\n+        /** Problem dimension. */\n+        private final int n;\n+\n+        /** Simple constructor.\n+         * @param n problem dimension\n+         */\n+        public NordsieckInitializer(final int n) {\n+            this.n = n;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void handleStep(StepInterpolator interpolator, boolean isLast)\n+            throws DerivativeException {\n+\n+            final double prev = interpolator.getPreviousTime();\n+            final double curr = interpolator.getCurrentTime();\n+            stepStart = prev;\n+            stepSize  = (curr - prev) / (nSteps + 1);\n+\n+            // compute the first scaled derivative\n+            interpolator.setInterpolatedTime(prev);\n+            scaled = interpolator.getInterpolatedDerivatives().clone();\n+            for (int j = 0; j < n; ++j) {\n+                scaled[j] *= stepSize;\n+            }\n+\n+            // compute the high order scaled derivatives\n+            final double[][] multistep = new double[nSteps][];\n+            for (int i = 1; i <= nSteps; ++i) {\n+                interpolator.setInterpolatedTime(prev + stepSize * i);\n+                final double[] msI = interpolator.getInterpolatedDerivatives().clone();\n+                for (int j = 0; j < n; ++j) {\n+                    msI[j] *= stepSize;\n+                }\n+                multistep[i - 1] = msI;\n+            }\n+            nordsieck = initializeHighOrderDerivatives(scaled, multistep);\n+\n+            // stop the integrator after the first step has been handled\n+            throw new InitializationCompletedMarkerException();\n+\n+        }\n+\n+        /** {@inheritDoc} */\n+        public boolean requiresDenseOutput() {\n+            return true;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void reset() {\n+            // nothing to do\n+        }\n+\n+    }\n+\n+    /** Marker exception used ONLY to stop the starter integrator after first step. */\n+    private static class InitializationCompletedMarkerException\n+        extends DerivativeException {\n+\n+        /** Serializable version identifier. */\n+        private static final long serialVersionUID = -4105805787353488365L;\n+\n+        /** Simple constructor. */\n+        public InitializationCompletedMarkerException() {\n+            super((Throwable) null);\n+        }\n+\n+    }\n+\n+    /** Wrapper for differential equations, ensuring start evaluations are counted. */\n+    private class CountingDifferentialEquations implements FirstOrderDifferentialEquations {\n+\n+        /** Dimension of the problem. */\n+        private final int dimension;\n+\n+        /** Simple constructor.\n+         * @param dimension dimension of the problem\n+         */\n+        public CountingDifferentialEquations(final int dimension) {\n+            this.dimension = dimension;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void computeDerivatives(double t, double[] y, double[] dot)\n+                throws DerivativeException {\n+            MultistepIntegrator.this.computeDerivatives(t, y, dot);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public int getDimension() {\n+            return dimension;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/ODEIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+import java.util.Collection;\n+\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+/**\n+ * This interface defines the common parts shared by integrators\n+ * for first and second order differential equations.\n+ * @see FirstOrderIntegrator\n+ * @see SecondOrderIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface ODEIntegrator  {\n+\n+    /** Get the name of the method.\n+     * @return name of the method\n+     */\n+    String getName();\n+\n+    /** Add a step handler to this integrator.\n+     * <p>The handler will be called by the integrator for each accepted\n+     * step.</p>\n+     * @param handler handler for the accepted steps\n+     * @see #getStepHandlers()\n+     * @see #clearStepHandlers()\n+     * @since 2.0\n+     */\n+    void addStepHandler(StepHandler handler);\n+\n+    /** Get all the step handlers that have been added to the integrator.\n+     * @return an unmodifiable collection of the added events handlers\n+     * @see #addStepHandler(StepHandler)\n+     * @see #clearStepHandlers()\n+     * @since 2.0\n+     */\n+    Collection<StepHandler> getStepHandlers();\n+\n+    /** Remove all the step handlers that have been added to the integrator.\n+     * @see #addStepHandler(StepHandler)\n+     * @see #getStepHandlers()\n+     * @since 2.0\n+     */\n+    void clearStepHandlers();\n+\n+    /** Add an event handler to the integrator.\n+     * @param handler event handler\n+     * @param maxCheckInterval maximal time interval between switching\n+     * function checks (this interval prevents missing sign changes in\n+     * case the integration steps becomes very large)\n+     * @param convergence convergence threshold in the event time search\n+     * @param maxIterationCount upper limit of the iteration count in\n+     * the event time search\n+     * @see #getEventHandlers()\n+     * @see #clearEventHandlers()\n+     */\n+    void addEventHandler(EventHandler handler,\n+                                         double maxCheckInterval,\n+                                         double convergence,\n+                                         int maxIterationCount);\n+\n+    /** Get all the event handlers that have been added to the integrator.\n+     * @return an unmodifiable collection of the added events handlers\n+     * @see #addEventHandler(EventHandler, double, double, int)\n+     * @see #clearEventHandlers()\n+     */\n+    Collection<EventHandler> getEventHandlers();\n+\n+    /** Remove all the event handlers that have been added to the integrator.\n+     * @see #addEventHandler(EventHandler, double, double, int)\n+     * @see #getEventHandlers()\n+     */\n+    void clearEventHandlers();\n+\n+    /** Get the current value of the step start time t<sub>i</sub>.\n+     * <p>This method can be called during integration (typically by\n+     * the object implementing the {@link FirstOrderDifferentialEquations\n+     * differential equations} problem) if the value of the current step that\n+     * is attempted is needed.</p>\n+     * <p>The result is undefined if the method is called outside of\n+     * calls to <code>integrate</code>.</p>\n+     * @return current value of the step start time t<sub>i</sub>\n+     */\n+    double getCurrentStepStart();\n+\n+    /** Get the current signed value of the integration stepsize.\n+     * <p>This method can be called during integration (typically by\n+     * the object implementing the {@link FirstOrderDifferentialEquations\n+     * differential equations} problem) if the signed value of the current stepsize\n+     * that is tried is needed.</p>\n+     * <p>The result is undefined if the method is called outside of\n+     * calls to <code>integrate</code>.</p>\n+     * @return current signed value of the stepsize\n+     */\n+    double getCurrentSignedStepsize();\n+\n+    /** Set the maximal number of differential equations function evaluations.\n+     * <p>The purpose of this method is to avoid infinite loops which can occur\n+     * for example when stringent error constraints are set or when lots of\n+     * discrete events are triggered, thus leading to many rejected steps.</p>\n+     * @param maxEvaluations maximal number of function evaluations (negative\n+     * values are silently converted to maximal integer value, thus representing\n+     * almost unlimited evaluations)\n+     */\n+    void setMaxEvaluations(int maxEvaluations);\n+\n+    /** Get the maximal number of functions evaluations.\n+     * @return maximal number of functions evaluations\n+     */\n+    int getMaxEvaluations();\n+\n+    /** Get the number of evaluations of the differential equations function.\n+     * <p>\n+     * The number of evaluations corresponds to the last call to the\n+     * <code>integrate</code> method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the differential equations function\n+     */\n+    int getEvaluations();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/SecondOrderDifferentialEquations.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+/** This interface represents a second order differential equations set.\n+\n+ * <p>This interface should be implemented by all real second order\n+ * differential equation problems before they can be handled by the\n+ * integrators {@link SecondOrderIntegrator#integrate} method.</p>\n+ *\n+ * <p>A second order differential equations problem, as seen by an\n+ * integrator is the second time derivative <code>d2Y/dt^2</code> of a\n+ * state vector <code>Y</code>, both being one dimensional\n+ * arrays. From the integrator point of view, this derivative depends\n+ * only on the current time <code>t</code>, on the state vector\n+ * <code>Y</code> and on the first time derivative of the state\n+ * vector.</p>\n+ *\n+ * <p>For real problems, the derivative depends also on parameters\n+ * that do not belong to the state vector (dynamical model constants\n+ * for example). These constants are completely outside of the scope\n+ * of this interface, the classes that implement it are allowed to\n+ * handle them as they want.</p>\n+ *\n+ * @see SecondOrderIntegrator\n+ * @see FirstOrderConverter\n+ * @see FirstOrderDifferentialEquations\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public interface SecondOrderDifferentialEquations {\n+\n+  /** Get the dimension of the problem.\n+   * @return dimension of the problem\n+   */\n+  public int getDimension();\n+    \n+  /** Get the current time derivative of the state vector.\n+   * @param t current value of the independent <I>time</I> variable\n+   * @param y array containing the current value of the state vector\n+   * @param yDot array containing the current value of the first derivative\n+   * of the state vector\n+   * @param yDDot placeholder array where to put the second time derivative\n+   * of the state vector\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  public void computeSecondDerivatives(double t, double[] y, double[] yDot,\n+                                       double[] yDDot)\n+  throws DerivativeException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/SecondOrderIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode;\n+\n+\n+/** This interface represents a second order integrator for\n+ * differential equations.\n+ *\n+ * <p>The classes which are devoted to solve second order differential\n+ * equations should implement this interface. The problems which can\n+ * be handled should implement the {@link\n+ * SecondOrderDifferentialEquations} interface.</p>\n+ *\n+ * @see SecondOrderDifferentialEquations\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public interface SecondOrderIntegrator extends ODEIntegrator {\n+\n+  /** Integrate the differential equations up to the given time\n+   * @param equations differential equations to integrate\n+   * @param t0 initial time\n+   * @param y0 initial value of the state vector at t0\n+   * @param yDot0 initial value of the first derivative of the state\n+   * vector at t0\n+   * @param t target time for the integration\n+   * (can be set to a value smaller thant <code>t0</code> for backward integration)\n+   * @param y placeholder where to put the state vector at each\n+   * successful step (and hence at the end of integration), can be the\n+   * same object as y0\n+   * @param yDot placeholder where to put the first derivative of\n+   * the state vector at time t, can be the same object as yDot0\n+   * @throws IntegratorException if the integrator cannot perform integration\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  public void integrate(SecondOrderDifferentialEquations equations,\n+                        double t0, double[] y0, double[] yDot0,\n+                        double t, double[] y, double[] yDot)\n+  throws DerivativeException, IntegratorException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/events/CombinedEventsManager.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.events;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/** This class manages several {@link EventHandler event handlers} during integration.\n+ *\n+ * @see EventHandler\n+ * @see EventState\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class CombinedEventsManager {\n+\n+    /** Events states. */\n+    private final List<EventState> states;\n+\n+    /** First active event. */\n+    private EventState first;\n+\n+    /** Initialization indicator. */\n+    private boolean initialized;\n+\n+    /** Simple constructor.\n+     * Create an empty manager\n+     */\n+    public CombinedEventsManager() {\n+        states      = new ArrayList<EventState>();\n+        first       = null;\n+        initialized = false;\n+    }\n+\n+    /** Add an events handler.\n+     * @param handler event handler\n+     * @param maxCheckInterval maximal time interval between events\n+     * checks (this interval prevents missing sign changes in\n+     * case the integration steps becomes very large)\n+     * @param convergence convergence threshold in the event time search\n+     * @param maxIterationCount upper limit of the iteration count in\n+     * the event time search\n+     * @see #getEventsHandlers()\n+     * @see #clearEventsHandlers()\n+     */\n+    public void addEventHandler(final EventHandler handler, final double maxCheckInterval,\n+                                final double convergence, final int maxIterationCount) {\n+        states.add(new EventState(handler, maxCheckInterval,\n+                                  convergence, maxIterationCount));\n+    }\n+\n+    /** Get all the events handlers that have been added to the manager.\n+     * @return an unmodifiable collection of the added event handlers\n+     * @see #addEventHandler(EventHandler, double, double, int)\n+     * @see #clearEventsHandlers()\n+     * @see #getEventsStates()\n+     */\n+    public Collection<EventHandler> getEventsHandlers() {\n+        final List<EventHandler> list = new ArrayList<EventHandler>();\n+        for (EventState state : states) {\n+            list.add(state.getEventHandler());\n+        }\n+        return Collections.unmodifiableCollection(list);\n+    }\n+\n+    /** Remove all the events handlers that have been added to the manager.\n+     * @see #addEventHandler(EventHandler, double, double, int)\n+     * @see #getEventsHandlers()\n+     */\n+    public void clearEventsHandlers() {\n+        states.clear();\n+    }\n+\n+    /** Get all the events state wrapping the handlers that have been added to the manager.\n+     * @return a collection of the events states\n+     * @see #getEventsHandlers()\n+     */\n+    public Collection<EventState> getEventsStates() {\n+        return states;\n+    }\n+\n+    /** Check if the manager does not manage any event handlers.\n+     * @return true if manager is empty\n+     */\n+    public boolean isEmpty() {\n+        return states.isEmpty();\n+    }\n+\n+    /** Evaluate the impact of the proposed step on all managed\n+     * event handlers.\n+     * @param interpolator step interpolator for the proposed step\n+     * @return true if at least one event handler triggers an event\n+     * before the end of the proposed step (this implies the step should\n+     * be rejected)\n+     * @exception DerivativeException if the interpolator fails to\n+     * compute the function somewhere within the step\n+     * @exception IntegratorException if an event cannot be located\n+     */\n+    public boolean evaluateStep(final StepInterpolator interpolator)\n+    throws DerivativeException, IntegratorException {\n+\n+        try {\n+\n+            first = null;\n+            if (states.isEmpty()) {\n+                // there is nothing to do, return now to avoid setting the\n+                // interpolator time (and hence avoid unneeded calls to the\n+                // user function due to interpolator finalization)\n+                return false;\n+            }\n+\n+            if (! initialized) {\n+\n+                // initialize the events states\n+                final double t0 = interpolator.getPreviousTime();\n+                interpolator.setInterpolatedTime(t0);\n+                final double [] y = interpolator.getInterpolatedState();\n+                for (EventState state : states) {\n+                    state.reinitializeBegin(t0, y);\n+                }\n+\n+                initialized = true;\n+\n+            }\n+\n+            // check events occurrence\n+            for (EventState state : states) {\n+\n+                if (state.evaluateStep(interpolator)) {\n+                    if (first == null) {\n+                        first = state;\n+                    } else {\n+                        if (interpolator.isForward()) {\n+                            if (state.getEventTime() < first.getEventTime()) {\n+                                first = state;\n+                            }\n+                        } else {\n+                            if (state.getEventTime() > first.getEventTime()) {\n+                                first = state;\n+                            }\n+                        }\n+                    }\n+                }\n+\n+            }\n+\n+            return first != null;\n+\n+        } catch (EventException se) {\n+            throw new IntegratorException(se);\n+        } catch (ConvergenceException ce) {\n+            throw new IntegratorException(ce);\n+        }\n+\n+    }\n+\n+    /** Get the occurrence time of the first event triggered in the\n+     * last evaluated step.\n+     * @return occurrence time of the first event triggered in the last\n+     * evaluated step, or </code>Double.NaN</code> if no event is\n+     * triggered\n+     */\n+    public double getEventTime() {\n+        return (first == null) ? Double.NaN : first.getEventTime();\n+    }\n+\n+    /** Inform the event handlers that the step has been accepted\n+     * by the integrator.\n+     * @param t value of the independent <i>time</i> variable at the\n+     * end of the step\n+     * @param y array containing the current value of the state vector\n+     * at the end of the step\n+     * @exception IntegratorException if the value of one of the\n+     * events states cannot be evaluated\n+     */\n+    public void stepAccepted(final double t, final double[] y)\n+    throws IntegratorException {\n+        try {\n+            for (EventState state : states) {\n+                state.stepAccepted(t, y);\n+            }\n+        } catch (EventException se) {\n+            throw new IntegratorException(se);\n+        }\n+    }\n+\n+    /** Check if the integration should be stopped at the end of the\n+     * current step.\n+     * @return true if the integration should be stopped\n+     */\n+    public boolean stop() {\n+        for (EventState state : states) {\n+            if (state.stop()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /** Let the event handlers reset the state if they want.\n+     * @param t value of the independent <i>time</i> variable at the\n+     * beginning of the next step\n+     * @param y array were to put the desired state vector at the beginning\n+     * of the next step\n+     * @return true if the integrator should reset the derivatives too\n+     * @exception IntegratorException if one of the events states\n+     * that should reset the state fails to do it\n+     */\n+    public boolean reset(final double t, final double[] y)\n+        throws IntegratorException {\n+        try {\n+            boolean resetDerivatives = false;\n+            for (EventState state : states) {\n+                if (state.reset(t, y)) {\n+                    resetDerivatives = true;\n+                }\n+            }\n+            return resetDerivatives;\n+        } catch (EventException se) {\n+            throw new IntegratorException(se);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.events;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * This exception is made available to users to report\n+ * the error conditions that are triggered by {@link EventHandler}\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class EventException extends MathException {\n+\n+    /** Serialization UID. */\n+    private static final long serialVersionUID = -898215297400035290L;\n+\n+    /** Simple constructor.\n+     * Build an exception by translating and formating a message\n+     * @param specifier format specifier (to be translated)\n+     * @param parts to insert in the format (no translation)\n+     */\n+    public EventException(final String specifier, final Object ... parts) {\n+        super(specifier, parts);\n+    }\n+\n+    /**\n+     * Create an exception with a given root cause.\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     */\n+    public EventException(final Throwable cause) {\n+        super(cause);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventHandler.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.events;\n+\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+/** This interface represents a handler for discrete events triggered\n+ * during ODE integration.\n+ *\n+ * <p>Some events can be triggered at discrete times as an ODE problem\n+ * is solved. These occurs for example when the integration process\n+ * should be stopped as some state is reached (G-stop facility) when the\n+ * precise date is unknown a priori, or when the derivatives have\n+ * discontinuities, or simply when the user wants to monitor some\n+ * states boundaries crossings.\n+ * </p>\n+ * \n+ * <p>These events are defined as occurring when a <code>g</code>\n+ * switching function sign changes.</p>\n+ *\n+ * <p>Since events are only problem-dependent and are triggered by the\n+ * independent <i>time</i> variable and the state vector, they can\n+ * occur at virtually any time, unknown in advance. The integrators will\n+ * take care to avoid sign changes inside the steps, they will reduce\n+ * the step size when such an event is detected in order to put this\n+ * event exactly at the end of the current step. This guarantees that\n+ * step interpolation (which always has a one step scope) is relevant\n+ * even in presence of discontinuities. This is independent from the\n+ * stepsize control provided by integrators that monitor the local\n+ * error (this event handling feature is available for all integrators,\n+ * including fixed step ones).</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public interface EventHandler  {\n+\n+  /** Stop indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should be\n+   * stopped after the event ending the current step.</p>\n+   */\n+  public static final int STOP = 0;\n+\n+  /** Reset state indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should\n+   * go on after the event ending the current step, with a new state\n+   * vector (which will be retrieved thanks to the {@link #resetState\n+   * resetState} method).</p>\n+   */\n+  public static final int RESET_STATE = 1;\n+\n+  /** Reset derivatives indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should\n+   * go on after the event ending the current step, with a new derivatives\n+   * vector (which will be retrieved thanks to the {@link\n+   * FirstOrderDifferentialEquations#computeDerivatives} method).</p>\n+   */\n+  public static final int RESET_DERIVATIVES = 2;\n+\n+  /** Continue indicator.\n+   * <p>This value should be used as the return value of the {@link\n+   * #eventOccurred eventOccurred} method when the integration should go\n+   * on after the event ending the current step.</p>\n+   */\n+  public static final int CONTINUE = 3;\n+\n+  /** Compute the value of the switching function.\n+\n+   * <p>The discrete events are generated when the sign of this \n+   * switching function changes. The integrator will take care to change\n+   * the stepsize in such a way these events occur exactly at step boundaries.\n+   * The switching function must be continuous in its roots neighborhood\n+   * (but not necessarily smooth), as the integrator will need to find its\n+   * roots to locate precisely the events.</p>\n+\n+   * @param t current value of the independent <i>time</i> variable\n+   * @param y array containing the current value of the state vector\n+   * @return value of the g switching function\n+   * @exception EventException if the switching function cannot be evaluated\n+   */\n+  public double g(double t, double[] y) throws EventException;\n+\n+  /** Handle an event and choose what to do next.\n+\n+   * <p>This method is called when the integrator has accepted a step\n+   * ending exactly on a sign change of the function, just before the\n+   * step handler itself is called. It allows the user to update his\n+   * internal data to acknowledge the fact the event has been handled\n+   * (for example setting a flag in the {@link\n+   * FirstOrderDifferentialEquations differential equations} to switch\n+   * the derivatives computation in case of discontinuity), or to\n+   * direct the integrator to either stop or continue integration,\n+   * possibly with a reset state or derivatives.</p>\n+\n+   * <ul>\n+   *   <li>if {@link #STOP} is returned, the step handler will be called\n+   *   with the <code>isLast</code> flag of the {@link\n+   *   StepHandler#handleStep handleStep} method set to true and the\n+   *   integration will be stopped,</li>\n+   *   <li>if {@link #RESET_STATE} is returned, the {@link #resetState\n+   *   resetState} method will be called once the step handler has\n+   *   finished its task, and the integrator will also recompute the\n+   *   derivatives,</li>\n+   *   <li>if {@link #RESET_DERIVATIVES} is returned, the integrator\n+   *   will recompute the derivatives,\n+   *   <li>if {@link #CONTINUE} is returned, no specific action will\n+   *   be taken (apart from having called this method) and integration\n+   *   will continue.</li>\n+   * </ul>\n+\n+   * @param t current value of the independent <i>time</i> variable\n+   * @param y array containing the current value of the state vector\n+   * @param increasing if true, the value of the switching function increases\n+   * when times increases around event (note that increase is measured with respect\n+   * to physical time, not with respect to integration which may go backward in time)\n+   * @return indication of what the integrator should do next, this\n+   * value must be one of {@link #STOP}, {@link #RESET_STATE},\n+   * {@link #RESET_DERIVATIVES} or {@link #CONTINUE}\n+   * @exception EventException if the event occurrence triggers an error\n+   */\n+  public int eventOccurred(double t, double[] y, boolean increasing) throws EventException;\n+  \n+  /** Reset the state prior to continue the integration.\n+\n+   * <p>This method is called after the step handler has returned and\n+   * before the next step is started, but only when {@link\n+   * #eventOccurred} has itself returned the {@link #RESET_STATE}\n+   * indicator. It allows the user to reset the state vector for the\n+   * next step, without perturbing the step handler of the finishing\n+   * step. If the {@link #eventOccurred} never returns the {@link\n+   * #RESET_STATE} indicator, this function will never be called, and it is\n+   * safe to leave its body empty.</p>\n+\n+   * @param t current value of the independent <i>time</i> variable\n+   * @param y array containing the current value of the state vector\n+   * the new state should be put in the same array\n+   * @exception EventException if the state cannot be reseted\n+   */\n+  public void resetState(double t, double[] y) throws EventException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.events;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.solvers.BrentSolver;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/** This class handles the state for one {@link EventHandler\n+ * event handler} during integration steps.\n+ *\n+ * <p>Each time the integrator proposes a step, the event handler\n+ * switching function should be checked. This class handles the state\n+ * of one handler during one integration step, with references to the\n+ * state at the end of the preceding step. This information is used to\n+ * decide if the handler should trigger an event or not during the\n+ * proposed step (and hence the step should be reduced to ensure the\n+ * event occurs at a bound rather than inside the step).</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class EventState {\n+\n+    /** Event handler. */\n+    private final EventHandler handler;\n+\n+    /** Maximal time interval between events handler checks. */\n+    private final double maxCheckInterval;\n+\n+    /** Convergence threshold for event localization. */\n+    private final double convergence;\n+\n+    /** Upper limit in the iteration count for event localization. */\n+    private final int maxIterationCount;\n+\n+    /** Time at the beginning of the step. */\n+    private double t0;\n+\n+    /** Value of the events handler at the beginning of the step. */\n+    private double g0;\n+\n+    /** Simulated sign of g0 (we cheat when crossing events). */\n+    private boolean g0Positive;\n+\n+    /** Indicator of event expected during the step. */\n+    private boolean pendingEvent;\n+\n+    /** Occurrence time of the pending event. */\n+    private double pendingEventTime;\n+\n+    /** Occurrence time of the previous event. */\n+    private double previousEventTime;\n+\n+    /** Integration direction. */\n+    private boolean forward;\n+\n+    /** Variation direction around pending event.\n+     *  (this is considered with respect to the integration direction)\n+     */\n+    private boolean increasing;\n+\n+    /** Next action indicator. */\n+    private int nextAction;\n+\n+    /** Simple constructor.\n+     * @param handler event handler\n+     * @param maxCheckInterval maximal time interval between switching\n+     * function checks (this interval prevents missing sign changes in\n+     * case the integration steps becomes very large)\n+     * @param convergence convergence threshold in the event time search\n+     * @param maxIterationCount upper limit of the iteration count in\n+     * the event time search\n+     */\n+    public EventState(final EventHandler handler, final double maxCheckInterval,\n+                      final double convergence, final int maxIterationCount) {\n+        this.handler           = handler;\n+        this.maxCheckInterval  = maxCheckInterval;\n+        this.convergence       = Math.abs(convergence);\n+        this.maxIterationCount = maxIterationCount;\n+\n+        // some dummy values ...\n+        t0                = Double.NaN;\n+        g0                = Double.NaN;\n+        g0Positive        = true;\n+        pendingEvent      = false;\n+        pendingEventTime  = Double.NaN;\n+        previousEventTime = Double.NaN;\n+        increasing        = true;\n+        nextAction        = EventHandler.CONTINUE;\n+\n+    }\n+\n+    /** Get the underlying event handler.\n+     * @return underlying event handler\n+     */\n+    public EventHandler getEventHandler() {\n+        return handler;\n+    }\n+\n+    /** Get the maximal time interval between events handler checks.\n+     * @return maximal time interval between events handler checks\n+     */\n+    public double getMaxCheckInterval() {\n+        return maxCheckInterval;\n+    }\n+\n+    /** Get the convergence threshold for event localization.\n+     * @return convergence threshold for event localization\n+     */\n+    public double getConvergence() {\n+        return convergence;\n+    }\n+\n+    /** Get the upper limit in the iteration count for event localization.\n+     * @return upper limit in the iteration count for event localization\n+     */\n+    public int getMaxIterationCount() {\n+        return maxIterationCount;\n+    }\n+\n+    /** Reinitialize the beginning of the step.\n+     * @param t0 value of the independent <i>time</i> variable at the\n+     * beginning of the step\n+     * @param y0 array containing the current value of the state vector\n+     * at the beginning of the step\n+     * @exception EventException if the event handler\n+     * value cannot be evaluated at the beginning of the step\n+     */\n+    public void reinitializeBegin(final double t0, final double[] y0)\n+        throws EventException {\n+        this.t0 = t0;\n+        g0 = handler.g(t0, y0);\n+        g0Positive = (g0 >= 0);\n+    }\n+\n+    /** Evaluate the impact of the proposed step on the event handler.\n+     * @param interpolator step interpolator for the proposed step\n+     * @return true if the event handler triggers an event before\n+     * the end of the proposed step (this implies the step should be\n+     * rejected)\n+     * @exception DerivativeException if the interpolator fails to\n+     * compute the switching function somewhere within the step\n+     * @exception EventException if the switching function\n+     * cannot be evaluated\n+     * @exception ConvergenceException if an event cannot be located\n+     */\n+    public boolean evaluateStep(final StepInterpolator interpolator)\n+        throws DerivativeException, EventException, ConvergenceException {\n+\n+        try {\n+\n+            forward = interpolator.isForward();\n+            final double t1 = interpolator.getCurrentTime();\n+            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n+            final double h  = (t1 - t0) / n;\n+\n+            double ta = t0;\n+            double ga = g0;\n+            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n+            for (int i = 0; i < n; ++i) {\n+\n+                // evaluate handler value at the end of the substep\n+                tb += h;\n+                interpolator.setInterpolatedTime(tb);\n+                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n+\n+                // check events occurrence\n+                if (g0Positive ^ (gb >= 0)) {\n+                    // there is a sign change: an event is expected during this step\n+\n+                    // variation direction, with respect to the integration direction\n+                    increasing = (gb >= ga);\n+\n+                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                        public double value(final double t) throws FunctionEvaluationException {\n+                            try {\n+                                interpolator.setInterpolatedTime(t);\n+                                return handler.g(t, interpolator.getInterpolatedState());\n+                            } catch (DerivativeException e) {\n+                                throw new FunctionEvaluationException(e, t);\n+                            } catch (EventException e) {\n+                                throw new FunctionEvaluationException(e, t);\n+                            }\n+                        }\n+                    };\n+                    final BrentSolver solver = new BrentSolver();\n+                    solver.setAbsoluteAccuracy(convergence);\n+                    solver.setMaximalIterationCount(maxIterationCount);\n+                    double root;\n+                    try {\n+                        root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n+                    } catch (IllegalArgumentException iae) {\n+                        // the interval did not really bracket a root\n+                        root = Double.NaN;\n+                    }\n+                    if (Double.isNaN(root) ||\n+                        ((Math.abs(root - ta) <= convergence) &&\n+                         (Math.abs(root - previousEventTime) <= convergence))) {\n+                        // we have either found nothing or found (again ?) a past event, we simply ignore it\n+                        ta = tb;\n+                        ga = gb;\n+                    } else if (Double.isNaN(previousEventTime) ||\n+                               (Math.abs(previousEventTime - root) > convergence)) {\n+                        pendingEventTime = root;\n+                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n+                            // we were already waiting for this event which was\n+                            // found during a previous call for a step that was\n+                            // rejected, this step must now be accepted since it\n+                            // properly ends exactly at the event occurrence\n+                            return false;\n+                        }\n+                        // either we were not waiting for the event or it has\n+                        // moved in such a way the step cannot be accepted\n+                        pendingEvent = true;\n+                        return true;\n+                    }\n+\n+                } else {\n+                    // no sign change: there is no event for now\n+                    ta = tb;\n+                    ga = gb;\n+                }\n+\n+            }\n+\n+            // no event during the whole step\n+            pendingEvent     = false;\n+            pendingEventTime = Double.NaN;\n+            return false;\n+\n+        } catch (FunctionEvaluationException e) {\n+            final Throwable cause = e.getCause();\n+            if ((cause != null) && (cause instanceof DerivativeException)) {\n+                throw (DerivativeException) cause;\n+            } else if ((cause != null) && (cause instanceof EventException)) {\n+                throw (EventException) cause;\n+            }\n+            throw new EventException(e);\n+        }\n+\n+    }\n+\n+    /** Get the occurrence time of the event triggered in the current\n+     * step.\n+     * @return occurrence time of the event triggered in the current\n+     * step.\n+     */\n+    public double getEventTime() {\n+        return pendingEventTime;\n+    }\n+\n+    /** Acknowledge the fact the step has been accepted by the integrator.\n+     * @param t value of the independent <i>time</i> variable at the\n+     * end of the step\n+     * @param y array containing the current value of the state vector\n+     * at the end of the step\n+     * @exception EventException if the value of the event\n+     * handler cannot be evaluated\n+     */\n+    public void stepAccepted(final double t, final double[] y)\n+        throws EventException {\n+\n+        t0 = t;\n+        g0 = handler.g(t, y);\n+\n+        if (pendingEvent) {\n+            // force the sign to its value \"just after the event\"\n+            previousEventTime = t;\n+            g0Positive        = increasing;\n+            nextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n+        } else {\n+            g0Positive = (g0 >= 0);\n+            nextAction = EventHandler.CONTINUE;\n+        }\n+    }\n+\n+    /** Check if the integration should be stopped at the end of the\n+     * current step.\n+     * @return true if the integration should be stopped\n+     */\n+    public boolean stop() {\n+        return nextAction == EventHandler.STOP;\n+    }\n+\n+    /** Let the event handler reset the state if it wants.\n+     * @param t value of the independent <i>time</i> variable at the\n+     * beginning of the next step\n+     * @param y array were to put the desired state vector at the beginning\n+     * of the next step\n+     * @return true if the integrator should reset the derivatives too\n+     * @exception EventException if the state cannot be reseted by the event\n+     * handler\n+     */\n+    public boolean reset(final double t, final double[] y)\n+        throws EventException {\n+\n+        if (! pendingEvent) {\n+            return false;\n+        }\n+\n+        if (nextAction == EventHandler.RESET_STATE) {\n+            handler.resetState(t, y);\n+        }\n+        pendingEvent      = false;\n+        pendingEventTime  = Double.NaN;\n+\n+        return (nextAction == EventHandler.RESET_STATE) ||\n+               (nextAction == EventHandler.RESET_DERIVATIVES);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsBashforthIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.sampling.NordsieckStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+\n+/**\n+ * This class implements explicit Adams-Bashforth integrators for Ordinary\n+ * Differential Equations.\n+ *\n+ * <p>Adams-Bashforth methods (in fact due to Adams alone) are explicit\n+ * multistep ODE solvers. This implementation is a variation of the classical\n+ * one: it uses adaptive stepsize to implement error control, whereas\n+ * classical implementations are fixed step size. The value of state vector\n+ * at step n+1 is a simple combination of the value at step n and of the\n+ * derivatives at steps n, n-1, n-2 ... Depending on the number k of previous\n+ * steps one wants to use for computing the next value, different formulas\n+ * are available:</p>\n+ * <ul>\n+ *   <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + h y'<sub>n</sub></li>\n+ *   <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + h (3y'<sub>n</sub>-y'<sub>n-1</sub>)/2</li>\n+ *   <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + h (23y'<sub>n</sub>-16y'<sub>n-1</sub>+5y'<sub>n-2</sub>)/12</li>\n+ *   <li>k = 4: y<sub>n+1</sub> = y<sub>n</sub> + h (55y'<sub>n</sub>-59y'<sub>n-1</sub>+37y'<sub>n-2</sub>-9y'<sub>n-3</sub>)/24</li>\n+ *   <li>...</li>\n+ * </ul>\n+ *\n+ * <p>A k-steps Adams-Bashforth method is of order k.</p>\n+ *\n+ * <h3>Implementation details</h3>\n+ *\n+ * <p>We define scaled derivatives s<sub>i</sub>(n) at step n as:\n+ * <pre>\n+ * s<sub>1</sub>(n) = h y'<sub>n</sub> for first derivative\n+ * s<sub>2</sub>(n) = h<sup>2</sup>/2 y''<sub>n</sub> for second derivative\n+ * s<sub>3</sub>(n) = h<sup>3</sup>/6 y'''<sub>n</sub> for third derivative\n+ * ...\n+ * s<sub>k</sub>(n) = h<sup>k</sup>/k! y(k)<sub>n</sub> for k<sup>th</sup> derivative\n+ * </pre></p>\n+ *\n+ * <p>The definitions above use the classical representation with several previous first\n+ * derivatives. Lets define\n+ * <pre>\n+ *   q<sub>n</sub> = [ s<sub>1</sub>(n-1) s<sub>1</sub>(n-2) ... s<sub>1</sub>(n-(k-1)) ]<sup>T</sup>\n+ * </pre>\n+ * (we omit the k index in the notation for clarity). With these definitions,\n+ * Adams-Bashforth methods can be written:\n+ * <ul>\n+ *   <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n)</li>\n+ *   <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + 3/2 s<sub>1</sub>(n) + [ -1/2 ] q<sub>n</sub></li>\n+ *   <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + 23/12 s<sub>1</sub>(n) + [ -16/12 5/12 ] q<sub>n</sub></li>\n+ *   <li>k = 4: y<sub>n+1</sub> = y<sub>n</sub> + 55/24 s<sub>1</sub>(n) + [ -59/24 37/24 -9/24 ] q<sub>n</sub></li>\n+ *   <li>...</li>\n+ * </ul></p>\n+ *\n+ * <p>Instead of using the classical representation with first derivatives only (y<sub>n</sub>,\n+ * s<sub>1</sub>(n) and q<sub>n</sub>), our implementation uses the Nordsieck vector with\n+ * higher degrees scaled derivatives all taken at the same step (y<sub>n</sub>, s<sub>1</sub>(n)\n+ * and r<sub>n</sub>) where r<sub>n</sub> is defined as:\n+ * <pre>\n+ * r<sub>n</sub> = [ s<sub>2</sub>(n), s<sub>3</sub>(n) ... s<sub>k</sub>(n) ]<sup>T</sup>\n+ * </pre>\n+ * (here again we omit the k index in the notation for clarity)\n+ * </p>\n+ *\n+ * <p>Taylor series formulas show that for any index offset i, s<sub>1</sub>(n-i) can be\n+ * computed from s<sub>1</sub>(n), s<sub>2</sub>(n) ... s<sub>k</sub>(n), the formula being exact\n+ * for degree k polynomials.\n+ * <pre>\n+ * s<sub>1</sub>(n-i) = s<sub>1</sub>(n) + &sum;<sub>j</sub> j (-i)<sup>j-1</sup> s<sub>j</sub>(n)\n+ * </pre>\n+ * The previous formula can be used with several values for i to compute the transform between\n+ * classical representation and Nordsieck vector. The transform between r<sub>n</sub>\n+ * and q<sub>n</sub> resulting from the Taylor series formulas above is:\n+ * <pre>\n+ * q<sub>n</sub> = s<sub>1</sub>(n) u + P r<sub>n</sub>\n+ * </pre>\n+ * where u is the [ 1 1 ... 1 ]<sup>T</sup> vector and P is the (k-1)&times;(k-1) matrix built\n+ * with the j (-i)<sup>j-1</sup> terms:\n+ * <pre>\n+ *        [  -2   3   -4    5  ... ]\n+ *        [  -4  12  -32   80  ... ]\n+ *   P =  [  -6  27 -108  405  ... ]\n+ *        [  -8  48 -256 1280  ... ]\n+ *        [          ...           ]\n+ * </pre></p>\n+ * \n+ * <p>Using the Nordsieck vector has several advantages:\n+ * <ul>\n+ *   <li>it greatly simplifies step interpolation as the interpolator mainly applies\n+ *   Taylor series formulas,</li>\n+ *   <li>it simplifies step changes that occur when discrete events that truncate\n+ *   the step are triggered,</li>\n+ *   <li>it allows to extend the methods in order to support adaptive stepsize.</li>\n+ * </ul></p>\n+ * \n+ * <p>The Nordsieck vector at step n+1 is computed from the Nordsieck vector at step n as follows:\n+ * <ul>\n+ *   <li>y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n) + u<sup>T</sup> r<sub>n</sub></li>\n+ *   <li>s<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, y<sub>n+1</sub>)</li>\n+ *   <li>r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub></li>\n+ * </ul>\n+ * where A is a rows shifting matrix (the lower left part is an identity matrix):\n+ * <pre>\n+ *        [ 0 0   ...  0 0 | 0 ]\n+ *        [ ---------------+---]\n+ *        [ 1 0   ...  0 0 | 0 ]\n+ *    A = [ 0 1   ...  0 0 | 0 ]\n+ *        [       ...      | 0 ]\n+ *        [ 0 0   ...  1 0 | 0 ]\n+ *        [ 0 0   ...  0 1 | 0 ]\n+ * </pre></p>\n+ *\n+ * <p>The P<sup>-1</sup>u vector and the P<sup>-1</sup> A P matrix do not depend on the state,\n+ * they only depend on k and therefore are precomputed once for all.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class AdamsBashforthIntegrator extends AdamsIntegrator {\n+\n+    /**\n+     * Build an Adams-Bashforth integrator with the given order and step control parameters.\n+     * @param nSteps number of steps of the method excluding the one being computed\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param scalAbsoluteTolerance allowed absolute error\n+     * @param scalRelativeTolerance allowed relative error\n+     * @exception IllegalArgumentException if order is 1 or less\n+     */\n+    public AdamsBashforthIntegrator(final int nSteps,\n+                                    final double minStep, final double maxStep,\n+                                    final double scalAbsoluteTolerance,\n+                                    final double scalRelativeTolerance)\n+        throws IllegalArgumentException {\n+        super(\"Adams-Bashforth\", nSteps, nSteps, minStep, maxStep,\n+              scalAbsoluteTolerance, scalRelativeTolerance);\n+    }\n+\n+    /**\n+     * Build an Adams-Bashforth integrator with the given order and step control parameters.\n+     * @param nSteps number of steps of the method excluding the one being computed\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param vecAbsoluteTolerance allowed absolute error\n+     * @param vecRelativeTolerance allowed relative error\n+     * @exception IllegalArgumentException if order is 1 or less\n+     */\n+    public AdamsBashforthIntegrator(final int nSteps,\n+                                    final double minStep, final double maxStep,\n+                                    final double[] vecAbsoluteTolerance,\n+                                    final double[] vecRelativeTolerance)\n+        throws IllegalArgumentException {\n+        super(\"Adams-Bashforth\", nSteps, nSteps, minStep, maxStep,\n+              vecAbsoluteTolerance, vecRelativeTolerance);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double integrate(final FirstOrderDifferentialEquations equations,\n+                            final double t0, final double[] y0,\n+                            final double t, final double[] y)\n+        throws DerivativeException, IntegratorException {\n+\n+        final int n = y0.length;\n+        sanityChecks(equations, t0, y0, t, y);\n+        setEquations(equations);\n+        resetEvaluations();\n+        final boolean forward = (t > t0);\n+\n+        // initialize working arrays\n+        if (y != y0) {\n+            System.arraycopy(y0, 0, y, 0, n);\n+        }\n+        final double[] yDot = new double[n];\n+        final double[] yTmp = new double[y0.length];\n+\n+        // set up an interpolator sharing the integrator arrays\n+        final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\n+        interpolator.reinitialize(y, forward);\n+        final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();\n+        interpolatorTmp.reinitialize(yTmp, forward);\n+\n+        // set up integration control objects\n+        for (StepHandler handler : stepHandlers) {\n+            handler.reset();\n+        }\n+        CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n+\n+        // compute the initial Nordsieck vector using the configured starter integrator\n+        start(t0, y, t);\n+        interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n+        interpolator.storeTime(stepStart);\n+        final int lastRow = nordsieck.getRowDimension() - 1;\n+\n+        // reuse the step that was chosen by the starter integrator\n+        double hNew = stepSize;\n+        interpolator.rescale(hNew);\n+        \n+        boolean lastStep = false;\n+        while (!lastStep) {\n+\n+            // shift all data\n+            interpolator.shift();\n+\n+            double error = 0;\n+            for (boolean loop = true; loop;) {\n+\n+                stepSize = hNew;\n+\n+                // evaluate error using the last term of the Taylor expansion\n+                error = 0;\n+                for (int i = 0; i < y0.length; ++i) {\n+                    final double yScale = Math.abs(y[i]);\n+                    final double tol = (vecAbsoluteTolerance == null) ?\n+                                       (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n+                                       (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);\n+                    final double ratio  = nordsieck.getEntry(lastRow, i) / tol;\n+                    error += ratio * ratio;\n+                }\n+                error = Math.sqrt(error / y0.length);\n+\n+                if (error <= 1.0) {\n+\n+                    // predict a first estimate of the state at step end\n+                    final double stepEnd = stepStart + stepSize;\n+                    interpolator.setInterpolatedTime(stepEnd);\n+                    System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\n+\n+                    // evaluate the derivative\n+                    computeDerivatives(stepEnd, yTmp, yDot);\n+\n+                    // update Nordsieck vector\n+                    final double[] predictedScaled = new double[y0.length];\n+                    for (int j = 0; j < y0.length; ++j) {\n+                        predictedScaled[j] = stepSize * yDot[j];\n+                    }\n+                    final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\n+                    updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\n+\n+                    // discrete events handling\n+                    interpolatorTmp.reinitialize(stepEnd, stepSize, predictedScaled, nordsieckTmp);\n+                    interpolatorTmp.storeTime(stepStart);\n+                    interpolatorTmp.shift();\n+                    interpolatorTmp.storeTime(stepEnd);\n+                    if (manager.evaluateStep(interpolatorTmp)) {\n+                        final double dt = manager.getEventTime() - stepStart;\n+                        if (Math.abs(dt) <= Math.ulp(stepStart)) {\n+                            // rejecting the step would lead to a too small next step, we accept it\n+                            loop = false;\n+                        } else {\n+                            // reject the step to match exactly the next switch time\n+                            hNew = dt;\n+                            interpolator.rescale(hNew);\n+                        }\n+                    } else {\n+                        // accept the step\n+                        scaled    = predictedScaled;\n+                        nordsieck = nordsieckTmp;\n+                        interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\n+                        loop = false;\n+                    }\n+\n+                } else {\n+                    // reject the step and attempt to reduce error by stepsize control\n+                    final double factor = computeStepGrowShrinkFactor(error);\n+                    hNew = filterStep(stepSize * factor, forward, false);\n+                    interpolator.rescale(hNew);\n+                }\n+\n+            }\n+\n+            // the step has been accepted (may have been truncated)\n+            final double nextStep = stepStart + stepSize;\n+            System.arraycopy(yTmp, 0, y, 0, n);\n+            interpolator.storeTime(nextStep);\n+            manager.stepAccepted(nextStep, y);\n+            lastStep = manager.stop();\n+\n+            // provide the step data to the step handler\n+            for (StepHandler handler : stepHandlers) {\n+                interpolator.setInterpolatedTime(nextStep);\n+                handler.handleStep(interpolator, lastStep);\n+            }\n+            stepStart = nextStep;\n+\n+            if (!lastStep && manager.reset(stepStart, y)) {\n+\n+                // some events handler has triggered changes that\n+                // invalidate the derivatives, we need to restart from scratch\n+                start(stepStart, y, t);\n+                interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n+\n+            }\n+\n+            if (! lastStep) {\n+                // in some rare cases we may get here with stepSize = 0, for example\n+                // when an event occurs at integration start, reducing the first step\n+                // to zero; we have to reset the step to some safe non zero value\n+                stepSize = filterStep(stepSize, forward, true);\n+\n+                // stepsize control for next step\n+                final double  factor     = computeStepGrowShrinkFactor(error);\n+                final double  scaledH    = stepSize * factor;\n+                final double  nextT      = stepStart + scaledH;\n+                final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n+                hNew = filterStep(scaledH, forward, nextIsLast);\n+                interpolator.rescale(hNew);\n+            }\n+\n+        }\n+\n+        final double stopTime  = stepStart;\n+        stepStart = Double.NaN;\n+        stepSize  = Double.NaN;\n+        return stopTime;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.MultistepIntegrator;\n+\n+\n+/** Base class for {@link AdamsBashforthIntegrator Adams-Bashforth} and\n+ * {@link AdamsMoultonIntegrator Adams-Moulton} integrators.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class AdamsIntegrator extends MultistepIntegrator {\n+\n+    /** Transformer. */\n+    private final AdamsNordsieckTransformer transformer;\n+\n+    /**\n+     * Build an Adams integrator with the given order and step control prameters.\n+     * @param name name of the method\n+     * @param nSteps number of steps of the method excluding the one being computed\n+     * @param order order of the method\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param scalAbsoluteTolerance allowed absolute error\n+     * @param scalRelativeTolerance allowed relative error\n+     * @exception IllegalArgumentException if order is 1 or less\n+     */\n+    public AdamsIntegrator(final String name, final int nSteps, final int order,\n+                           final double minStep, final double maxStep,\n+                           final double scalAbsoluteTolerance,\n+                           final double scalRelativeTolerance)\n+        throws IllegalArgumentException {\n+        super(name, nSteps, order, minStep, maxStep,\n+              scalAbsoluteTolerance, scalRelativeTolerance);\n+        transformer = AdamsNordsieckTransformer.getInstance(nSteps);\n+    }\n+\n+    /**\n+     * Build an Adams integrator with the given order and step control parameters.\n+     * @param name name of the method\n+     * @param nSteps number of steps of the method excluding the one being computed\n+     * @param order order of the method\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param vecAbsoluteTolerance allowed absolute error\n+     * @param vecRelativeTolerance allowed relative error\n+     * @exception IllegalArgumentException if order is 1 or less\n+     */\n+    public AdamsIntegrator(final String name, final int nSteps, final int order,\n+                           final double minStep, final double maxStep,\n+                           final double[] vecAbsoluteTolerance,\n+                           final double[] vecRelativeTolerance)\n+        throws IllegalArgumentException {\n+        super(name, nSteps, order, minStep, maxStep,\n+              vecAbsoluteTolerance, vecRelativeTolerance);\n+        transformer = AdamsNordsieckTransformer.getInstance(nSteps);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public abstract double integrate(final FirstOrderDifferentialEquations equations,\n+                                     final double t0, final double[] y0,\n+                                     final double t, final double[] y)\n+        throws DerivativeException, IntegratorException;\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected Array2DRowRealMatrix initializeHighOrderDerivatives(final double[] first,\n+                                                        final double[][] multistep) {\n+        return transformer.initializeHighOrderDerivatives(first, multistep);\n+    }\n+\n+    /** Update the high order scaled derivatives for Adams integrators (phase 1).\n+     * <p>The complete update of high order derivatives has a form similar to:\n+     * <pre>\n+     * r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub>\n+     * </pre>\n+     * this method computes the P<sup>-1</sup> A P r<sub>n</sub> part.</p>\n+     * @param highOrder high order scaled derivatives\n+     * (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\n+     * @return updated high order derivatives\n+     * @see #updateHighOrderDerivativesPhase2(double[], double[], Array2DRowRealMatrix)\n+     */\n+    public Array2DRowRealMatrix updateHighOrderDerivativesPhase1(final Array2DRowRealMatrix highOrder) {\n+        return transformer.updateHighOrderDerivativesPhase1(highOrder);\n+    }\n+\n+    /** Update the high order scaled derivatives Adams integrators (phase 2).\n+     * <p>The complete update of high order derivatives has a form similar to:\n+     * <pre>\n+     * r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub>\n+     * </pre>\n+     * this method computes the (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u part.</p>\n+     * <p>Phase 1 of the update must already have been performed.</p>\n+     * @param start first order scaled derivatives at step start\n+     * @param end first order scaled derivatives at step end\n+     * @param highOrder high order scaled derivatives, will be modified\n+     * (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\n+     * @see #updateHighOrderDerivativesPhase1(Array2DRowRealMatrix)\n+     */\n+    public void updateHighOrderDerivativesPhase2(final double[] start,\n+                                                 final double[] end,\n+                                                 final Array2DRowRealMatrix highOrder) {\n+        transformer.updateHighOrderDerivativesPhase2(start, end, highOrder);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.linear.MatrixVisitorException;\n+import org.apache.commons.math.linear.RealMatrixPreservingVisitor;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.sampling.NordsieckStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+\n+/**\n+ * This class implements implicit Adams-Moulton integrators for Ordinary\n+ * Differential Equations.\n+ *\n+ * <p>Adams-Moulton methods (in fact due to Adams alone) are implicit\n+ * multistep ODE solvers. This implementation is a variation of the classical\n+ * one: it uses adaptive stepsize to implement error control, whereas\n+ * classical implementations are fixed step size. The value of state vector\n+ * at step n+1 is a simple combination of the value at step n and of the\n+ * derivatives at steps n+1, n, n-1 ... Since y'<sub>n+1</sub> is needed to\n+ * compute y<sub>n+1</sub>,another method must be used to compute a first\n+ * estimate of y<sub>n+1</sub>, then compute y'<sub>n+1</sub>, then compute\n+ * a final estimate of y<sub>n+1</sub> using the following formulas. Depending\n+ * on the number k of previous steps one wants to use for computing the next\n+ * value, different formulas are available for the final estimate:</p>\n+ * <ul>\n+ *   <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + h y'<sub>n+1</sub></li>\n+ *   <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + h (y'<sub>n+1</sub>+y'<sub>n</sub>)/2</li>\n+ *   <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + h (5y'<sub>n+1</sub>+8y'<sub>n</sub>-y'<sub>n-1</sub>)/12</li>\n+ *   <li>k = 4: y<sub>n+1</sub> = y<sub>n</sub> + h (9y'<sub>n+1</sub>+19y'<sub>n</sub>-5y'<sub>n-1</sub>+y'<sub>n-2</sub>)/24</li>\n+ *   <li>...</li>\n+ * </ul>\n+ *\n+ * <p>A k-steps Adams-Moulton method is of order k+1.</p>\n+ *\n+ * <h3>Implementation details</h3>\n+ *\n+ * <p>We define scaled derivatives s<sub>i</sub>(n) at step n as:\n+ * <pre>\n+ * s<sub>1</sub>(n) = h y'<sub>n</sub> for first derivative\n+ * s<sub>2</sub>(n) = h<sup>2</sup>/2 y''<sub>n</sub> for second derivative\n+ * s<sub>3</sub>(n) = h<sup>3</sup>/6 y'''<sub>n</sub> for third derivative\n+ * ...\n+ * s<sub>k</sub>(n) = h<sup>k</sup>/k! y(k)<sub>n</sub> for k<sup>th</sup> derivative\n+ * </pre></p>\n+ *\n+ * <p>The definitions above use the classical representation with several previous first\n+ * derivatives. Lets define\n+ * <pre>\n+ *   q<sub>n</sub> = [ s<sub>1</sub>(n-1) s<sub>1</sub>(n-2) ... s<sub>1</sub>(n-(k-1)) ]<sup>T</sup>\n+ * </pre>\n+ * (we omit the k index in the notation for clarity). With these definitions,\n+ * Adams-Moulton methods can be written:\n+ * <ul>\n+ *   <li>k = 1: y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n+1)</li>\n+ *   <li>k = 2: y<sub>n+1</sub> = y<sub>n</sub> + 1/2 s<sub>1</sub>(n+1) + [ 1/2 ] q<sub>n+1</sub></li>\n+ *   <li>k = 3: y<sub>n+1</sub> = y<sub>n</sub> + 5/12 s<sub>1</sub>(n+1) + [ 8/12 -1/12 ] q<sub>n+1</sub></li>\n+ *   <li>k = 4: y<sub>n+1</sub> = y<sub>n</sub> + 9/24 s<sub>1</sub>(n+1) + [ 19/24 -5/24 1/24 ] q<sub>n+1</sub></li>\n+ *   <li>...</li>\n+ * </ul></p>\n+ *\n+ * <p>Instead of using the classical representation with first derivatives only (y<sub>n</sub>,\n+ * s<sub>1</sub>(n+1) and q<sub>n+1</sub>), our implementation uses the Nordsieck vector with\n+ * higher degrees scaled derivatives all taken at the same step (y<sub>n</sub>, s<sub>1</sub>(n)\n+ * and r<sub>n</sub>) where r<sub>n</sub> is defined as:\n+ * <pre>\n+ * r<sub>n</sub> = [ s<sub>2</sub>(n), s<sub>3</sub>(n) ... s<sub>k</sub>(n) ]<sup>T</sup>\n+ * </pre>\n+ * (here again we omit the k index in the notation for clarity)\n+ * </p>\n+ *\n+ * <p>Taylor series formulas show that for any index offset i, s<sub>1</sub>(n-i) can be\n+ * computed from s<sub>1</sub>(n), s<sub>2</sub>(n) ... s<sub>k</sub>(n), the formula being exact\n+ * for degree k polynomials.\n+ * <pre>\n+ * s<sub>1</sub>(n-i) = s<sub>1</sub>(n) + &sum;<sub>j</sub> j (-i)<sup>j-1</sup> s<sub>j</sub>(n)\n+ * </pre>\n+ * The previous formula can be used with several values for i to compute the transform between\n+ * classical representation and Nordsieck vector. The transform between r<sub>n</sub>\n+ * and q<sub>n</sub> resulting from the Taylor series formulas above is:\n+ * <pre>\n+ * q<sub>n</sub> = s<sub>1</sub>(n) u + P r<sub>n</sub>\n+ * </pre>\n+ * where u is the [ 1 1 ... 1 ]<sup>T</sup> vector and P is the (k-1)&times;(k-1) matrix built\n+ * with the j (-i)<sup>j-1</sup> terms:\n+ * <pre>\n+ *        [  -2   3   -4    5  ... ]\n+ *        [  -4  12  -32   80  ... ]\n+ *   P =  [  -6  27 -108  405  ... ]\n+ *        [  -8  48 -256 1280  ... ]\n+ *        [          ...           ]\n+ * </pre></p>\n+ * \n+ * <p>Using the Nordsieck vector has several advantages:\n+ * <ul>\n+ *   <li>it greatly simplifies step interpolation as the interpolator mainly applies\n+ *   Taylor series formulas,</li>\n+ *   <li>it simplifies step changes that occur when discrete events that truncate\n+ *   the step are triggered,</li>\n+ *   <li>it allows to extend the methods in order to support adaptive stepsize.</li>\n+ * </ul></p>\n+ * \n+ * <p>The predicted Nordsieck vector at step n+1 is computed from the Nordsieck vector at step\n+ * n as follows:\n+ * <ul>\n+ *   <li>Y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n) + u<sup>T</sup> r<sub>n</sub></li>\n+ *   <li>S<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, Y<sub>n+1</sub>)</li>\n+ *   <li>R<sub>n+1</sub> = (s<sub>1</sub>(n) - S<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub></li>\n+ * </ul>\n+ * where A is a rows shifting matrix (the lower left part is an identity matrix):\n+ * <pre>\n+ *        [ 0 0   ...  0 0 | 0 ]\n+ *        [ ---------------+---]\n+ *        [ 1 0   ...  0 0 | 0 ]\n+ *    A = [ 0 1   ...  0 0 | 0 ]\n+ *        [       ...      | 0 ]\n+ *        [ 0 0   ...  1 0 | 0 ]\n+ *        [ 0 0   ...  0 1 | 0 ]\n+ * </pre>\n+ * From this predicted vector, the corrected vector is computed as follows:\n+ * <ul>\n+ *   <li>y<sub>n+1</sub> = y<sub>n</sub> + S<sub>1</sub>(n+1) + [ -1 +1 -1 +1 ... &plusmn;1 ] r<sub>n+1</sub></li>\n+ *   <li>s<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, y<sub>n+1</sub>)</li>\n+ *   <li>r<sub>n+1</sub> = R<sub>n+1</sub> + (s<sub>1</sub>(n+1) - S<sub>1</sub>(n+1)) P<sup>-1</sup> u</li>\n+ * </ul>\n+ * where the upper case Y<sub>n+1</sub>, S<sub>1</sub>(n+1) and R<sub>n+1</sub> represent the\n+ * predicted states whereas the lower case y<sub>n+1</sub>, s<sub>n+1</sub> and r<sub>n+1</sub>\n+ * represent the corrected states.</p>\n+ *\n+ * <p>The P<sup>-1</sup>u vector and the P<sup>-1</sup> A P matrix do not depend on the state,\n+ * they only depend on k and therefore are precomputed once for all.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class AdamsMoultonIntegrator extends AdamsIntegrator {\n+\n+    /**\n+     * Build an Adams-Moulton integrator with the given order and error control parameters.\n+     * @param nSteps number of steps of the method excluding the one being computed\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param scalAbsoluteTolerance allowed absolute error\n+     * @param scalRelativeTolerance allowed relative error\n+     * @exception IllegalArgumentException if order is 1 or less\n+     */\n+    public AdamsMoultonIntegrator(final int nSteps,\n+                                  final double minStep, final double maxStep,\n+                                  final double scalAbsoluteTolerance,\n+                                  final double scalRelativeTolerance)\n+        throws IllegalArgumentException {\n+        super(\"Adams-Moulton\", nSteps, nSteps + 1, minStep, maxStep,\n+              scalAbsoluteTolerance, scalRelativeTolerance);\n+    }\n+\n+    /**\n+     * Build an Adams-Moulton integrator with the given order and error control parameters.\n+     * @param nSteps number of steps of the method excluding the one being computed\n+     * @param minStep minimal step (must be positive even for backward\n+     * integration), the last step can be smaller than this\n+     * @param maxStep maximal step (must be positive even for backward\n+     * integration)\n+     * @param vecAbsoluteTolerance allowed absolute error\n+     * @param vecRelativeTolerance allowed relative error\n+     * @exception IllegalArgumentException if order is 1 or less\n+     */\n+    public AdamsMoultonIntegrator(final int nSteps,\n+                                  final double minStep, final double maxStep,\n+                                  final double[] vecAbsoluteTolerance,\n+                                  final double[] vecRelativeTolerance)\n+        throws IllegalArgumentException {\n+        super(\"Adams-Moulton\", nSteps, nSteps + 1, minStep, maxStep,\n+              vecAbsoluteTolerance, vecRelativeTolerance);\n+    }\n+      \n+    \n+    /** {@inheritDoc} */\n+    @Override\n+    public double integrate(final FirstOrderDifferentialEquations equations,\n+                            final double t0, final double[] y0,\n+                            final double t, final double[] y)\n+        throws DerivativeException, IntegratorException {\n+\n+        final int n = y0.length;\n+        sanityChecks(equations, t0, y0, t, y);\n+        setEquations(equations);\n+        resetEvaluations();\n+        final boolean forward = (t > t0);\n+\n+        // initialize working arrays\n+        if (y != y0) {\n+            System.arraycopy(y0, 0, y, 0, n);\n+        }\n+        final double[] yDot = new double[y0.length];\n+        final double[] yTmp = new double[y0.length];\n+\n+        // set up two interpolators sharing the integrator arrays\n+        final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\n+        interpolator.reinitialize(y, forward);\n+        final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();\n+        interpolatorTmp.reinitialize(yTmp, forward);\n+\n+        // set up integration control objects\n+        for (StepHandler handler : stepHandlers) {\n+            handler.reset();\n+        }\n+        CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n+\n+\n+        // compute the initial Nordsieck vector using the configured starter integrator\n+        start(t0, y, t);\n+        interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n+        interpolator.storeTime(stepStart);\n+\n+        double hNew = stepSize;\n+        interpolator.rescale(hNew);\n+        \n+        boolean lastStep = false;\n+        while (!lastStep) {\n+\n+            // shift all data\n+            interpolator.shift();\n+\n+            double error = 0;\n+            for (boolean loop = true; loop;) {\n+\n+                stepSize = hNew;\n+\n+                // predict a first estimate of the state at step end (P in the PECE sequence)\n+                final double stepEnd = stepStart + stepSize;\n+                interpolator.setInterpolatedTime(stepEnd);\n+                System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\n+\n+                // evaluate a first estimate of the derivative (first E in the PECE sequence)\n+                computeDerivatives(stepEnd, yTmp, yDot);\n+\n+                // update Nordsieck vector\n+                final double[] predictedScaled = new double[y0.length];\n+                for (int j = 0; j < y0.length; ++j) {\n+                    predictedScaled[j] = stepSize * yDot[j];\n+                }\n+                final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\n+                updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\n+\n+                // apply correction (C in the PECE sequence)\n+                error = nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp));\n+\n+                if (error <= 1.0) {\n+\n+                    // evaluate a final estimate of the derivative (second E in the PECE sequence)\n+                    computeDerivatives(stepEnd, yTmp, yDot);\n+\n+                    // update Nordsieck vector\n+                    final double[] correctedScaled = new double[y0.length];\n+                    for (int j = 0; j < y0.length; ++j) {\n+                        correctedScaled[j] = stepSize * yDot[j];\n+                    }\n+                    updateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp);\n+\n+                    // discrete events handling\n+                    interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);\n+                    interpolatorTmp.storeTime(stepStart);\n+                    interpolatorTmp.shift();\n+                    interpolatorTmp.storeTime(stepEnd);\n+                    if (manager.evaluateStep(interpolatorTmp)) {\n+                        final double dt = manager.getEventTime() - stepStart;\n+                        if (Math.abs(dt) <= Math.ulp(stepStart)) {\n+                            // rejecting the step would lead to a too small next step, we accept it\n+                            loop = false;\n+                        } else {\n+                            // reject the step to match exactly the next switch time\n+                            hNew = dt;\n+                            interpolator.rescale(hNew);\n+                        }\n+                    } else {\n+                        // accept the step\n+                        scaled    = correctedScaled;\n+                        nordsieck = nordsieckTmp;\n+                        interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\n+                        loop = false;\n+                    }\n+\n+                } else {\n+                    // reject the step and attempt to reduce error by stepsize control\n+                    final double factor = computeStepGrowShrinkFactor(error);\n+                    hNew = filterStep(stepSize * factor, forward, false);\n+                    interpolator.rescale(hNew);\n+                }\n+\n+            }\n+\n+            // the step has been accepted (may have been truncated)\n+            final double nextStep = stepStart + stepSize;\n+            System.arraycopy(yTmp, 0, y, 0, n);\n+            interpolator.storeTime(nextStep);\n+            manager.stepAccepted(nextStep, y);\n+            lastStep = manager.stop();\n+\n+            // provide the step data to the step handler\n+            for (StepHandler handler : stepHandlers) {\n+                interpolator.setInterpolatedTime(nextStep);\n+                handler.handleStep(interpolator, lastStep);\n+            }\n+            stepStart = nextStep;\n+\n+            if (!lastStep && manager.reset(stepStart, y)) {\n+\n+                // some events handler has triggered changes that\n+                // invalidate the derivatives, we need to restart from scratch\n+                start(stepStart, y, t);\n+                interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n+\n+            }\n+\n+            if (! lastStep) {\n+                // in some rare cases we may get here with stepSize = 0, for example\n+                // when an event occurs at integration start, reducing the first step\n+                // to zero; we have to reset the step to some safe non zero value\n+                stepSize = filterStep(stepSize, forward, true);\n+\n+                // stepsize control for next step\n+                final double  factor     = computeStepGrowShrinkFactor(error);\n+                final double  scaledH    = stepSize * factor;\n+                final double  nextT      = stepStart + scaledH;\n+                final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n+                hNew = filterStep(scaledH, forward, nextIsLast);\n+                interpolator.rescale(hNew);\n+            }\n+\n+        }\n+\n+        final double stopTime  = stepStart;\n+        stepStart = Double.NaN;\n+        stepSize  = Double.NaN;\n+        return stopTime;\n+\n+    }\n+\n+    /** Corrector for current state in Adams-Moulton method.\n+     * <p>\n+     * This visitor implements the Taylor series formula:\n+     * <pre>\n+     * Y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n+1) + [ -1 +1 -1 +1 ... &plusmn;1 ] r<sub>n+1</sub>\n+     * </pre>\n+     * </p>\n+     */\n+    private class Corrector implements RealMatrixPreservingVisitor {\n+\n+        /** Previous state. */\n+        private final double[] previous;\n+\n+        /** Current scaled first derivative. */\n+        private final double[] scaled;\n+\n+        /** Current state before correction. */\n+        private final double[] before;\n+\n+        /** Current state after correction. */\n+        private final double[] after;\n+\n+        /** Simple constructor.\n+         * @param previous previous state\n+         * @param scaled current scaled first derivative\n+         * @param state state to correct (will be overwritten after visit)\n+         */\n+        public Corrector(final double[] previous, final double[] scaled, final double[] state) {\n+            this.previous = previous;\n+            this.scaled   = scaled;\n+            this.after    = state;\n+            this.before   = state.clone();\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void start(int rows, int columns,\n+                          int startRow, int endRow, int startColumn, int endColumn) {\n+            Arrays.fill(after, 0.0);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void visit(int row, int column, double value)\n+            throws MatrixVisitorException {\n+            if ((row & 0x1) == 0) {\n+                after[column] -= value;\n+            } else {\n+                after[column] += value;\n+            }\n+        }\n+\n+        /**\n+         * End visiting te Nordsieck vector.\n+         * <p>The correction is used to control stepsize. So its amplitude is\n+         * considered to be an error, which must be normalized according to\n+         * error control settings. If the normalized value is greater than 1,\n+         * the correction was too large and the step must be rejected.</p>\n+         * @return the normalized correction, if greater than 1, the step\n+         * must be rejected\n+         */\n+        public double end() {\n+\n+            double error = 0;\n+            for (int i = 0; i < after.length; ++i) {\n+                after[i] += previous[i] + scaled[i];\n+                final double yScale = Math.max(Math.abs(previous[i]), Math.abs(after[i]));\n+                final double tol = (vecAbsoluteTolerance == null) ?\n+                                   (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n+                                   (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);\n+                final double ratio  = (after[i] - before[i]) / tol;\n+                error += ratio * ratio;\n+            }\n+\n+            return Math.sqrt(error / after.length);\n+\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.math.fraction.BigFraction;\n+import org.apache.commons.math.linear.Array2DRowFieldMatrix;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor;\n+import org.apache.commons.math.linear.FieldDecompositionSolver;\n+import org.apache.commons.math.linear.FieldLUDecompositionImpl;\n+import org.apache.commons.math.linear.FieldMatrix;\n+import org.apache.commons.math.linear.MatrixUtils;\n+\n+/** Transformer to Nordsieck vectors for Adams integrators.\n+ * <p>This class i used by {@link AdamsBashforthIntegrator Adams-Bashforth} and\n+ * {@link AdamsMoultonIntegrator Adams-Moulton} integrators to convert between\n+ * classical representation with several previous first derivatives and Nordsieck\n+ * representation with higher order scaled derivatives.</p>\n+ *\n+ * <p>We define scaled derivatives s<sub>i</sub>(n) at step n as:\n+ * <pre>\n+ * s<sub>1</sub>(n) = h y'<sub>n</sub> for first derivative\n+ * s<sub>2</sub>(n) = h<sup>2</sup>/2 y''<sub>n</sub> for second derivative\n+ * s<sub>3</sub>(n) = h<sup>3</sup>/6 y'''<sub>n</sub> for third derivative\n+ * ...\n+ * s<sub>k</sub>(n) = h<sup>k</sup>/k! y(k)<sub>n</sub> for k<sup>th</sup> derivative\n+ * </pre></p>\n+ *\n+ * <p>With the previous definition, the classical representation of multistep methods\n+ * uses first derivatives only, i.e. it handles y<sub>n</sub>, s<sub>1</sub>(n) and\n+ * q<sub>n</sub> where q<sub>n</sub> is defined as:\n+ * <pre>\n+ *   q<sub>n</sub> = [ s<sub>1</sub>(n-1) s<sub>1</sub>(n-2) ... s<sub>1</sub>(n-(k-1)) ]<sup>T</sup>\n+ * </pre>\n+ * (we omit the k index in the notation for clarity).</p>\n+ *\n+ * <p>Another possible representation uses the Nordsieck vector with\n+ * higher degrees scaled derivatives all taken at the same step, i.e it handles y<sub>n</sub>,\n+ * s<sub>1</sub>(n) and r<sub>n</sub>) where r<sub>n</sub> is defined as:\n+ * <pre>\n+ * r<sub>n</sub> = [ s<sub>2</sub>(n), s<sub>3</sub>(n) ... s<sub>k</sub>(n) ]<sup>T</sup>\n+ * </pre>\n+ * (here again we omit the k index in the notation for clarity)\n+ * </p>\n+ *\n+ * <p>Taylor series formulas show that for any index offset i, s<sub>1</sub>(n-i) can be\n+ * computed from s<sub>1</sub>(n), s<sub>2</sub>(n) ... s<sub>k</sub>(n), the formula being exact\n+ * for degree k polynomials.\n+ * <pre>\n+ * s<sub>1</sub>(n-i) = s<sub>1</sub>(n) + &sum;<sub>j</sub> j (-i)<sup>j-1</sup> s<sub>j</sub>(n)\n+ * </pre>\n+ * The previous formula can be used with several values for i to compute the transform between\n+ * classical representation and Nordsieck vector at step end. The transform between r<sub>n</sub>\n+ * and q<sub>n</sub> resulting from the Taylor series formulas above is:\n+ * <pre>\n+ * q<sub>n</sub> = s<sub>1</sub>(n) u + P r<sub>n</sub>\n+ * </pre>\n+ * where u is the [ 1 1 ... 1 ]<sup>T</sup> vector and P is the (k-1)&times;(k-1) matrix built\n+ * with the j (-i)<sup>j-1</sup> terms:\n+ * <pre>\n+ *        [  -2   3   -4    5  ... ]\n+ *        [  -4  12  -32   80  ... ]\n+ *   P =  [  -6  27 -108  405  ... ]\n+ *        [  -8  48 -256 1280  ... ]\n+ *        [          ...           ]\n+ * </pre></p>\n+ *\n+ * <p>Changing -i into +i in the formula above can be used to compute a similar transform between\n+ * classical representation and Nordsieck vector at step start. The resulting matrix is simply\n+ * the absolute value of matrix P.</p>\n+ *\n+ * <p>For {@link AdamsBashforthIntegrator Adams-Bashforth} method, the Nordsieck vector\n+ * at step n+1 is computed from the Nordsieck vector at step n as follows:\n+ * <ul>\n+ *   <li>y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n) + u<sup>T</sup> r<sub>n</sub></li>\n+ *   <li>s<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, y<sub>n+1</sub>)</li>\n+ *   <li>r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub></li>\n+ * </ul>\n+ * where A is a rows shifting matrix (the lower left part is an identity matrix):\n+ * <pre>\n+ *        [ 0 0   ...  0 0 | 0 ]\n+ *        [ ---------------+---]\n+ *        [ 1 0   ...  0 0 | 0 ]\n+ *    A = [ 0 1   ...  0 0 | 0 ]\n+ *        [       ...      | 0 ]\n+ *        [ 0 0   ...  1 0 | 0 ]\n+ *        [ 0 0   ...  0 1 | 0 ]\n+ * </pre></p>\n+ *\n+ * <p>For {@link AdamsMoultonIntegrator Adams-Moulton} method, the predicted Nordsieck vector\n+ * at step n+1 is computed from the Nordsieck vector at step n as follows:\n+ * <ul>\n+ *   <li>Y<sub>n+1</sub> = y<sub>n</sub> + s<sub>1</sub>(n) + u<sup>T</sup> r<sub>n</sub></li>\n+ *   <li>S<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, Y<sub>n+1</sub>)</li>\n+ *   <li>R<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub></li>\n+ * </ul>\n+ * From this predicted vector, the corrected vector is computed as follows:\n+ * <ul>\n+ *   <li>y<sub>n+1</sub> = y<sub>n</sub> + S<sub>1</sub>(n+1) + [ -1 +1 -1 +1 ... &plusmn;1 ] r<sub>n+1</sub></li>\n+ *   <li>s<sub>1</sub>(n+1) = h f(t<sub>n+1</sub>, y<sub>n+1</sub>)</li>\n+ *   <li>r<sub>n+1</sub> = R<sub>n+1</sub> + (s<sub>1</sub>(n+1) - S<sub>1</sub>(n+1)) P<sup>-1</sup> u</li>\n+ * </ul>\n+ * where the upper case Y<sub>n+1</sub>, S<sub>1</sub>(n+1) and R<sub>n+1</sub> represent the\n+ * predicted states whereas the lower case y<sub>n+1</sub>, s<sub>n+1</sub> and r<sub>n+1</sub>\n+ * represent the corrected states.</p>\n+ *\n+ * <p>We observe that both methods use similar update formulas. In both cases a P<sup>-1</sup>u\n+ * vector and a P<sup>-1</sup> A P matrix are used that do not depend on the state,\n+ * they only depend on k. This class handles these transformations.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class AdamsNordsieckTransformer {\n+\n+    /** Cache for already computed coefficients. */\n+    private static final Map<Integer, AdamsNordsieckTransformer> cache =\n+        new HashMap<Integer, AdamsNordsieckTransformer>();\n+\n+    /** Initialization matrix for the higher order derivatives wrt y'', y''' ... */\n+    private final Array2DRowRealMatrix initialization;\n+\n+    /** Update matrix for the higher order derivatives h<sup>2</sup>/2y'', h<sup>3</sup>/6 y''' ... */\n+    private final Array2DRowRealMatrix update;\n+\n+    /** Update coefficients of the higher order derivatives wrt y'. */\n+    private final double[] c1;\n+\n+    /** Simple constructor.\n+     * @param nSteps number of steps of the multistep method\n+     * (excluding the one being computed)\n+     */\n+    private AdamsNordsieckTransformer(final int nSteps) {\n+\n+        // compute exact coefficients\n+        FieldMatrix<BigFraction> bigP = buildP(nSteps);\n+        FieldDecompositionSolver<BigFraction> pSolver =\n+            new FieldLUDecompositionImpl<BigFraction>(bigP).getSolver();\n+\n+        BigFraction[] u = new BigFraction[nSteps];\n+        Arrays.fill(u, BigFraction.ONE);\n+        BigFraction[] bigC1 = pSolver.solve(u);\n+\n+        // update coefficients are computed by combining transform from\n+        // Nordsieck to multistep, then shifting rows to represent step advance\n+        // then applying inverse transform\n+        BigFraction[][] shiftedP = bigP.getData();\n+        for (int i = shiftedP.length - 1; i > 0; --i) {\n+            // shift rows\n+            shiftedP[i] = shiftedP[i - 1];\n+        }\n+        shiftedP[0] = new BigFraction[nSteps];\n+        Arrays.fill(shiftedP[0], BigFraction.ZERO);\n+        FieldMatrix<BigFraction> bigMSupdate =\n+            pSolver.solve(new Array2DRowFieldMatrix<BigFraction>(shiftedP, false));\n+\n+        // initialization coefficients, computed from a R matrix = abs(P)\n+        bigP.walkInOptimizedOrder(new DefaultFieldMatrixChangingVisitor<BigFraction>(BigFraction.ZERO) {\n+            /** {@inheritDoc} */\n+            @Override\n+            public BigFraction visit(int row, int column, BigFraction value) {\n+                return ((column & 0x1) == 0x1) ? value : value.negate();\n+            }\n+        });\n+        FieldMatrix<BigFraction> bigRInverse =\n+            new FieldLUDecompositionImpl<BigFraction>(bigP).getSolver().getInverse();\n+\n+        // convert coefficients to double\n+        initialization = MatrixUtils.bigFractionMatrixToRealMatrix(bigRInverse);\n+        update         = MatrixUtils.bigFractionMatrixToRealMatrix(bigMSupdate);\n+        c1             = new double[nSteps];\n+        for (int i = 0; i < nSteps; ++i) {\n+            c1[i] = bigC1[i].doubleValue();\n+        }\n+\n+    }\n+\n+    /** Get the Nordsieck transformer for a given number of steps.\n+     * @param nSteps number of steps of the multistep method\n+     * (excluding the one being computed)\n+     * @return Nordsieck transformer for the specified number of steps\n+     */\n+    public static AdamsNordsieckTransformer getInstance(final int nSteps) {\n+        synchronized(cache) {\n+            AdamsNordsieckTransformer t = cache.get(nSteps);\n+            if (t == null) {\n+                t = new AdamsNordsieckTransformer(nSteps);\n+                cache.put(nSteps, t);\n+            }\n+            return t;\n+        }\n+    }\n+\n+    /** Get the number of steps of the method\n+     * (excluding the one being computed).\n+     * @return number of steps of the method\n+     * (excluding the one being computed)\n+     */\n+    public int getNSteps() {\n+        return c1.length;\n+    }\n+\n+    /** Build the P matrix.\n+     * <p>The P matrix general terms are shifted j (-i)<sup>j-1</sup> terms:\n+     * <pre>\n+     *        [  -2   3   -4    5  ... ]\n+     *        [  -4  12  -32   80  ... ]\n+     *   P =  [  -6  27 -108  405  ... ]\n+     *        [  -8  48 -256 1280  ... ]\n+     *        [          ...           ]\n+     * </pre></p>\n+     * @param nSteps number of steps of the multistep method\n+     * (excluding the one being computed)\n+     * @return P matrix\n+     */\n+    private FieldMatrix<BigFraction> buildP(final int nSteps) {\n+\n+        final BigFraction[][] pData = new BigFraction[nSteps][nSteps];\n+\n+        for (int i = 0; i < pData.length; ++i) {\n+            // build the P matrix elements from Taylor series formulas\n+            final BigFraction[] pI = pData[i];\n+            final int factor = -(i + 1);\n+            int aj = factor;\n+            for (int j = 0; j < pI.length; ++j) {\n+                pI[j] = new BigFraction(aj * (j + 2));\n+                aj *= factor;\n+            }\n+        }\n+\n+        return new Array2DRowFieldMatrix<BigFraction>(pData, false);\n+\n+    }\n+\n+    /** Initialize the high order scaled derivatives at step start.\n+     * @param first first scaled derivative at step start\n+     * @param multistep scaled derivatives after step start (hy'1, ..., hy'k-1)\n+     * will be modified\n+     * @return high order derivatives at step start\n+     */\n+    public Array2DRowRealMatrix initializeHighOrderDerivatives(final double[] first,\n+                                                     final double[][] multistep) {\n+        for (int i = 0; i < multistep.length; ++i) {\n+            final double[] msI = multistep[i];\n+            for (int j = 0; j < first.length; ++j) {\n+                msI[j] -= first[j];\n+            }\n+        }\n+        return initialization.multiply(new Array2DRowRealMatrix(multistep, false));\n+    }\n+\n+    /** Update the high order scaled derivatives for Adams integrators (phase 1).\n+     * <p>The complete update of high order derivatives has a form similar to:\n+     * <pre>\n+     * r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub>\n+     * </pre>\n+     * this method computes the P<sup>-1</sup> A P r<sub>n</sub> part.</p>\n+     * @param highOrder high order scaled derivatives\n+     * (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\n+     * @return updated high order derivatives\n+     * @see #updateHighOrderDerivativesPhase2(double[], double[], Array2DRowRealMatrix)\n+     */\n+    public Array2DRowRealMatrix updateHighOrderDerivativesPhase1(final Array2DRowRealMatrix highOrder) {\n+        return update.multiply(highOrder);\n+    }\n+\n+    /** Update the high order scaled derivatives Adams integrators (phase 2).\n+     * <p>The complete update of high order derivatives has a form similar to:\n+     * <pre>\n+     * r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub>\n+     * </pre>\n+     * this method computes the (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u part.</p>\n+     * <p>Phase 1 of the update must already have been performed.</p>\n+     * @param start first order scaled derivatives at step start\n+     * @param end first order scaled derivatives at step end\n+     * @param highOrder high order scaled derivatives, will be modified\n+     * (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k))\n+     * @see #updateHighOrderDerivativesPhase1(Array2DRowRealMatrix)\n+     */\n+    public void updateHighOrderDerivativesPhase2(final double[] start,\n+                                                 final double[] end,\n+                                                 final Array2DRowRealMatrix highOrder) {\n+        final double[][] data = highOrder.getDataRef();\n+        for (int i = 0; i < data.length; ++i) {\n+            final double[] dataI = data[i];\n+            final double c1I = c1[i];\n+            for (int j = 0; j < dataI.length; ++j) {\n+                dataI[j] += c1I * (start[j] - end[j]);\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/AdaptiveStepsizeIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.AbstractIntegrator;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+\n+/**\n+ * This abstract class holds the common part of all adaptive\n+ * stepsize integrators for Ordinary Differential Equations.\n+ *\n+ * <p>These algorithms perform integration with stepsize control, which\n+ * means the user does not specify the integration step but rather a\n+ * tolerance on error. The error threshold is computed as\n+ * <pre>\n+ * threshold_i = absTol_i + relTol_i * max (abs (ym), abs (ym+1))\n+ * </pre>\n+ * where absTol_i is the absolute tolerance for component i of the\n+ * state vector and relTol_i is the relative tolerance for the same\n+ * component. The user can also use only two scalar values absTol and\n+ * relTol which will be used for all components.</p>\n+ *\n+ * <p>If the estimated error for ym+1 is such that\n+ * <pre>\n+ * sqrt((sum (errEst_i / threshold_i)^2 ) / n) < 1\n+ * </pre>\n+ *\n+ * (where n is the state vector dimension) then the step is accepted,\n+ * otherwise the step is rejected and a new attempt is made with a new\n+ * stepsize.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ *\n+ */\n+\n+public abstract class AdaptiveStepsizeIntegrator\n+  extends AbstractIntegrator {\n+\n+  \n+  /** Build an integrator with the given stepsize bounds.\n+   * The default step handler does nothing.\n+   * @param name name of the method\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public AdaptiveStepsizeIntegrator(final String name,\n+                                    final double minStep, final double maxStep,\n+                                    final double scalAbsoluteTolerance,\n+                                    final double scalRelativeTolerance) {\n+\n+    super(name);\n+\n+    this.minStep     = Math.abs(minStep);\n+    this.maxStep     = Math.abs(maxStep);\n+    this.initialStep = -1.0;\n+\n+    this.scalAbsoluteTolerance = scalAbsoluteTolerance;\n+    this.scalRelativeTolerance = scalRelativeTolerance;\n+    this.vecAbsoluteTolerance  = null;\n+    this.vecRelativeTolerance  = null;\n+\n+    resetInternalState();\n+\n+  }\n+\n+  /** Build an integrator with the given stepsize bounds.\n+   * The default step handler does nothing.\n+   * @param name name of the method\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public AdaptiveStepsizeIntegrator(final String name,\n+                                    final double minStep, final double maxStep,\n+                                    final double[] vecAbsoluteTolerance,\n+                                    final double[] vecRelativeTolerance) {\n+\n+    super(name);\n+\n+    this.minStep     = minStep;\n+    this.maxStep     = maxStep;\n+    this.initialStep = -1.0;\n+\n+    this.scalAbsoluteTolerance = 0;\n+    this.scalRelativeTolerance = 0;\n+    this.vecAbsoluteTolerance  = vecAbsoluteTolerance.clone();\n+    this.vecRelativeTolerance  = vecRelativeTolerance.clone();\n+\n+    resetInternalState();\n+\n+  }\n+\n+  /** Set the initial step size.\n+   * <p>This method allows the user to specify an initial positive\n+   * step size instead of letting the integrator guess it by\n+   * itself. If this method is not called before integration is\n+   * started, the initial step size will be estimated by the\n+   * integrator.</p>\n+   * @param initialStepSize initial step size to use (must be positive even\n+   * for backward integration ; providing a negative value or a value\n+   * outside of the min/max step interval will lead the integrator to\n+   * ignore the value and compute the initial step size by itself)\n+   */\n+  public void setInitialStepSize(final double initialStepSize) {\n+    if ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\n+      initialStep = -1.0;\n+    } else {\n+      initialStep = initialStepSize;\n+    }\n+  }\n+\n+  /** Perform some sanity checks on the integration parameters.\n+   * @param equations differential equations set\n+   * @param t0 start time\n+   * @param y0 state vector at t0\n+   * @param t target time for the integration\n+   * @param y placeholder where to put the state vector\n+   * @exception IntegratorException if some inconsistency is detected\n+   */\n+  @Override\n+  protected void sanityChecks(final FirstOrderDifferentialEquations equations,\n+                              final double t0, final double[] y0,\n+                              final double t, final double[] y)\n+      throws IntegratorException {\n+\n+      super.sanityChecks(equations, t0, y0, t, y);\n+\n+      if ((vecAbsoluteTolerance != null) && (vecAbsoluteTolerance.length != y0.length)) {\n+          throw new IntegratorException(\n+                  \"dimensions mismatch: state vector has dimension {0},\" +\n+                  \" absolute tolerance vector has dimension {1}\",\n+                  y0.length, vecAbsoluteTolerance.length);\n+      }\n+\n+      if ((vecRelativeTolerance != null) && (vecRelativeTolerance.length != y0.length)) {\n+          throw new IntegratorException(\n+                  \"dimensions mismatch: state vector has dimension {0},\" +\n+                  \" relative tolerance vector has dimension {1}\",\n+                  y0.length, vecRelativeTolerance.length);\n+      }\n+\n+  }\n+\n+  /** Initialize the integration step.\n+   * @param equations differential equations set\n+   * @param forward forward integration indicator\n+   * @param order order of the method\n+   * @param scale scaling vector for the state vector\n+   * @param t0 start time\n+   * @param y0 state vector at t0\n+   * @param yDot0 first time derivative of y0\n+   * @param y1 work array for a state vector\n+   * @param yDot1 work array for the first time derivative of y1\n+   * @return first integration step\n+   * @exception DerivativeException this exception is propagated to\n+   * the caller if the underlying user function triggers one\n+   */\n+  public double initializeStep(final FirstOrderDifferentialEquations equations,\n+                               final boolean forward, final int order, final double[] scale,\n+                               final double t0, final double[] y0, final double[] yDot0,\n+                               final double[] y1, final double[] yDot1)\n+      throws DerivativeException {\n+\n+    if (initialStep > 0) {\n+      // use the user provided value\n+      return forward ? initialStep : -initialStep;\n+    }\n+\n+    // very rough first guess : h = 0.01 * ||y/scale|| / ||y'/scale||\n+    // this guess will be used to perform an Euler step\n+    double ratio;\n+    double yOnScale2 = 0;\n+    double yDotOnScale2 = 0;\n+    for (int j = 0; j < y0.length; ++j) {\n+      ratio         = y0[j] / scale[j];\n+      yOnScale2    += ratio * ratio;\n+      ratio         = yDot0[j] / scale[j];\n+      yDotOnScale2 += ratio * ratio;\n+    }\n+\n+    double h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10)) ?\n+               1.0e-6 : (0.01 * Math.sqrt(yOnScale2 / yDotOnScale2));\n+    if (! forward) {\n+      h = -h;\n+    }\n+\n+    // perform an Euler step using the preceding rough guess\n+    for (int j = 0; j < y0.length; ++j) {\n+      y1[j] = y0[j] + h * yDot0[j];\n+    }\n+    computeDerivatives(t0 + h, y1, yDot1);\n+\n+    // estimate the second derivative of the solution\n+    double yDDotOnScale = 0;\n+    for (int j = 0; j < y0.length; ++j) {\n+      ratio         = (yDot1[j] - yDot0[j]) / scale[j];\n+      yDDotOnScale += ratio * ratio;\n+    }\n+    yDDotOnScale = Math.sqrt(yDDotOnScale) / h;\n+\n+    // step size is computed such that\n+    // h^order * max (||y'/tol||, ||y''/tol||) = 0.01\n+    final double maxInv2 = Math.max(Math.sqrt(yDotOnScale2), yDDotOnScale);\n+    final double h1 = (maxInv2 < 1.0e-15) ?\n+                      Math.max(1.0e-6, 0.001 * Math.abs(h)) :\n+                      Math.pow(0.01 / maxInv2, 1.0 / order);\n+    h = Math.min(100.0 * Math.abs(h), h1);\n+    h = Math.max(h, 1.0e-12 * Math.abs(t0));  // avoids cancellation when computing t1 - t0\n+    if (h < getMinStep()) {\n+      h = getMinStep();\n+    }\n+    if (h > getMaxStep()) {\n+      h = getMaxStep();\n+    }\n+    if (! forward) {\n+      h = -h;\n+    }\n+\n+    return h;\n+\n+  }\n+\n+  /** Filter the integration step.\n+   * @param h signed step\n+   * @param forward forward integration indicator\n+   * @param acceptSmall if true, steps smaller than the minimal value\n+   * are silently increased up to this value, if false such small\n+   * steps generate an exception\n+   * @return a bounded integration step (h if no bound is reach, or a bounded value)\n+   * @exception IntegratorException if the step is too small and acceptSmall is false\n+   */\n+  protected double filterStep(final double h, final boolean forward, final boolean acceptSmall)\n+    throws IntegratorException {\n+\n+      double filteredH = h;\n+      if (Math.abs(h) < minStep) {\n+          if (acceptSmall) {\n+              filteredH = forward ? minStep : -minStep;\n+          } else {\n+              throw new IntegratorException(\n+                      \"minimal step size ({0}) reached, integration needs {1}\",\n+                      minStep, Math.abs(h));\n+          }\n+      }\n+\n+      if (filteredH > maxStep) {\n+          filteredH = maxStep;\n+      } else if (filteredH < -maxStep) {\n+          filteredH = -maxStep;\n+      }\n+\n+      return filteredH;\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public abstract double integrate (FirstOrderDifferentialEquations equations,\n+                                    double t0, double[] y0,\n+                                    double t, double[] y)\n+    throws DerivativeException, IntegratorException;\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public double getCurrentStepStart() {\n+    return stepStart;\n+  }\n+\n+  /** Reset internal state to dummy values. */\n+  protected void resetInternalState() {\n+    stepStart = Double.NaN;\n+    stepSize  = Math.sqrt(minStep * maxStep);\n+  }\n+\n+  /** Get the minimal step.\n+   * @return minimal step\n+   */\n+  public double getMinStep() {\n+    return minStep;\n+  }\n+\n+  /** Get the maximal step.\n+   * @return maximal step\n+   */\n+  public double getMaxStep() {\n+    return maxStep;\n+  }\n+\n+  /** Minimal step. */\n+  private double minStep;\n+\n+  /** Maximal step. */\n+  private double maxStep;\n+\n+  /** User supplied initial step. */\n+  private double initialStep;\n+\n+  /** Allowed absolute scalar error. */\n+  protected double scalAbsoluteTolerance;\n+\n+  /** Allowed relative scalar error. */\n+  protected double scalRelativeTolerance;\n+\n+  /** Allowed absolute vectorial error. */\n+  protected double[] vecAbsoluteTolerance;\n+\n+  /** Allowed relative vectorial error. */\n+  protected double[] vecRelativeTolerance;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+\n+/**\n+ * This class implements the classical fourth order Runge-Kutta\n+ * integrator for Ordinary Differential Equations (it is the most\n+ * often used Runge-Kutta method).\n+ *\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |  0    0    0    0\n+ *   1/2 | 1/2   0    0    0\n+ *   1/2 |  0   1/2   0    0\n+ *    1  |  0    0    1    0\n+ *       |--------------------\n+ *       | 1/6  1/3  1/3  1/6\n+ * </pre>\n+ * </p>\n+ *\n+ * @see EulerIntegrator\n+ * @see GillIntegrator\n+ * @see MidpointIntegrator\n+ * @see ThreeEighthesIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class ClassicalRungeKuttaIntegrator extends RungeKuttaIntegrator {\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] c = {\n+    1.0 / 2.0, 1.0 / 2.0, 1.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] a = {\n+    { 1.0 / 2.0 },\n+    { 0.0, 1.0 / 2.0 },\n+    { 0.0, 0.0, 1.0 }\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] b = {\n+    1.0 / 6.0, 1.0 / 3.0, 1.0 / 3.0, 1.0 / 6.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a fourth-order Runge-Kutta integrator with the given\n+   * step.\n+   * @param step integration step\n+   */\n+  public ClassicalRungeKuttaIntegrator(final double step) {\n+    super(\"classical Runge-Kutta\", c, a, b,\n+          new ClassicalRungeKuttaStepInterpolator(), step);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/ClassicalRungeKuttaStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements a step interpolator for the classical fourth\n+ * order Runge-Kutta integrator.\n+ *\n+ * <p>This interpolator allows to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h)\n+ *                    + (1 - theta) (h/6) [ (-4 theta^2 + 5 theta - 1) y'_1\n+ *                                          +(4 theta^2 - 2 theta - 2) (y'_2 + y'_3)\n+ *                                          -(4 theta^2 +   theta + 1) y'_4\n+ *                                        ]\n+ * </pre>\n+ *\n+ * where theta belongs to [0 ; 1] and where y'_1 to y'_4 are the four\n+ * evaluations of the derivatives already computed during the\n+ * step.</p>\n+ *\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class ClassicalRungeKuttaStepInterpolator\n+    extends RungeKuttaStepInterpolator {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -6576285612589783992L;\n+\n+    /** Simple constructor.\n+     * This constructor builds an instance that is not usable yet, the\n+     * {@link RungeKuttaStepInterpolator#reinitialize} method should be\n+     * called before using the instance in order to initialize the\n+     * internal arrays. This constructor is used only in order to delay\n+     * the initialization in some cases. The {@link RungeKuttaIntegrator}\n+     * class uses the prototyping design pattern to create the step\n+     * interpolators by cloning an uninitialized model and latter initializing\n+     * the copy.\n+     */\n+    public ClassicalRungeKuttaStepInterpolator() {\n+    }\n+\n+    /** Copy constructor.\n+     * @param interpolator interpolator to copy from. The copy is a deep\n+     * copy: its arrays are separated from the original arrays of the\n+     * instance\n+     */\n+    public ClassicalRungeKuttaStepInterpolator(final ClassicalRungeKuttaStepInterpolator interpolator) {\n+        super(interpolator);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected StepInterpolator doCopy() {\n+        return new ClassicalRungeKuttaStepInterpolator(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected void computeInterpolatedStateAndDerivatives(final double theta,\n+                                            final double oneMinusThetaH)\n+        throws DerivativeException {\n+\n+        final double fourTheta      = 4 * theta;\n+        final double oneMinusTheta  = 1 - theta;\n+        final double oneMinus2Theta = 1 - 2 * theta;\n+        final double s             = oneMinusThetaH / 6.0;\n+        final double coeff1        = s * ((-fourTheta + 5) * theta - 1);\n+        final double coeff23       = s * (( fourTheta - 2) * theta - 2);\n+        final double coeff4        = s * ((-fourTheta - 1) * theta - 1);\n+        final double coeffDot1     = oneMinusTheta * oneMinus2Theta;\n+        final double coeffDot23    = 2 * theta * oneMinusTheta;\n+        final double coeffDot4     = -theta * oneMinus2Theta;\n+        for (int i = 0; i < interpolatedState.length; ++i) {\n+            final double yDot1  = yDotK[0][i];\n+            final double yDot23 = yDotK[1][i] + yDotK[2][i];\n+            final double yDot4  = yDotK[3][i];\n+            interpolatedState[i] =\n+                currentState[i] + coeff1  * yDot1 + coeff23 * yDot23 + coeff4  * yDot4;\n+            interpolatedDerivatives[i] =\n+                coeffDot1 * yDot1 + coeffDot23 * yDot23 + coeffDot4 * yDot4;\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54Integrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+\n+/**\n+ * This class implements the 5(4) Dormand-Prince integrator for Ordinary\n+ * Differential Equations.\n+\n+ * <p>This integrator is an embedded Runge-Kutta integrator\n+ * of order 5(4) used in local extrapolation mode (i.e. the solution\n+ * is computed using the high order formula) with stepsize control\n+ * (and automatic step initialization) and continuous output. This\n+ * method uses 7 functions evaluations per step. However, since this\n+ * is an <i>fsal</i>, the last evaluation of one step is the same as\n+ * the first evaluation of the next step and hence can be avoided. So\n+ * the cost is really 6 functions evaluations per step.</p>\n+ *\n+ * <p>This method has been published (whithout the continuous output\n+ * that was added by Shampine in 1986) in the following article :\n+ * <pre>\n+ *  A family of embedded Runge-Kutta formulae\n+ *  J. R. Dormand and P. J. Prince\n+ *  Journal of Computational and Applied Mathematics\n+ *  volume 6, no 1, 1980, pp. 19-26\n+ * </pre></p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class DormandPrince54Integrator extends EmbeddedRungeKuttaIntegrator {\n+\n+  /** Integrator method name. */\n+  private static final String METHOD_NAME = \"Dormand-Prince 5(4)\";\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] staticC = {\n+    1.0/5.0, 3.0/10.0, 4.0/5.0, 8.0/9.0, 1.0, 1.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] staticA = {\n+    {1.0/5.0},\n+    {3.0/40.0, 9.0/40.0},\n+    {44.0/45.0, -56.0/15.0, 32.0/9.0},\n+    {19372.0/6561.0, -25360.0/2187.0, 64448.0/6561.0,  -212.0/729.0},\n+    {9017.0/3168.0, -355.0/33.0, 46732.0/5247.0, 49.0/176.0, -5103.0/18656.0},\n+    {35.0/384.0, 0.0, 500.0/1113.0, 125.0/192.0, -2187.0/6784.0, 11.0/84.0}\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] staticB = {\n+    35.0/384.0, 0.0, 500.0/1113.0, 125.0/192.0, -2187.0/6784.0, 11.0/84.0, 0.0\n+  };\n+\n+  /** Error array, element 1. */\n+  private static final double e1 =     71.0 / 57600.0;\n+\n+  // element 2 is zero, so it is neither stored nor used\n+\n+  /** Error array, element 3. */\n+  private static final double e3 =    -71.0 / 16695.0;\n+\n+  /** Error array, element 4. */\n+  private static final double e4 =     71.0 / 1920.0;\n+\n+  /** Error array, element 5. */\n+  private static final double e5 = -17253.0 / 339200.0;\n+\n+  /** Error array, element 6. */\n+  private static final double e6 =     22.0 / 525.0;\n+\n+  /** Error array, element 7. */\n+  private static final double e7 =     -1.0 / 40.0;\n+\n+  /** Simple constructor.\n+   * Build a fifth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince54Integrator(final double minStep, final double maxStep,\n+                                   final double scalAbsoluteTolerance,\n+                                   final double scalRelativeTolerance) {\n+    super(METHOD_NAME, true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),\n+          minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a fifth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince54Integrator(final double minStep, final double maxStep,\n+                                   final double[] vecAbsoluteTolerance,\n+                                   final double[] vecRelativeTolerance) {\n+    super(METHOD_NAME, true, staticC, staticA, staticB, new DormandPrince54StepInterpolator(),\n+          minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public int getOrder() {\n+    return 5;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  protected double estimateError(final double[][] yDotK,\n+                                 final double[] y0, final double[] y1,\n+                                 final double h) {\n+\n+    double error = 0;\n+\n+    for (int j = 0; j < y0.length; ++j) {\n+        final double errSum = e1 * yDotK[0][j] +  e3 * yDotK[2][j] +\n+                              e4 * yDotK[3][j] +  e5 * yDotK[4][j] +\n+                              e6 * yDotK[5][j] +  e7 * yDotK[6][j];\n+\n+        final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n+        final double tol = (vecAbsoluteTolerance == null) ?\n+                           (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n+                               (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n+        final double ratio  = h * errSum / tol;\n+        error += ratio * ratio;\n+\n+    }\n+\n+    return Math.sqrt(error / y0.length);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince54StepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.AbstractIntegrator;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class represents an interpolator over the last step during an\n+ * ODE integration for the 5(4) Dormand-Prince integrator.\n+ *\n+ * @see DormandPrince54Integrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class DormandPrince54StepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link EmbeddedRungeKuttaIntegrator} uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public DormandPrince54StepInterpolator() {\n+    super();\n+    v1 = null;\n+    v2 = null;\n+    v3 = null;\n+    v4 = null;\n+    vectorsInitialized = false;\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public DormandPrince54StepInterpolator(final DormandPrince54StepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    if (interpolator.v1 == null) {\n+\n+      v1 = null;\n+      v2 = null;\n+      v3 = null;\n+      v4 = null;\n+      vectorsInitialized = false;\n+\n+    } else {\n+\n+      v1 = interpolator.v1.clone();\n+      v2 = interpolator.v2.clone();\n+      v3 = interpolator.v3.clone();\n+      v4 = interpolator.v4.clone();\n+      vectorsInitialized = interpolator.vectorsInitialized;\n+\n+    }\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  protected StepInterpolator doCopy() {\n+    return new DormandPrince54StepInterpolator(this);\n+  }\n+\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public void reinitialize(final AbstractIntegrator integrator,\n+                           final double[] y, final double[][] yDotK, final boolean forward) {\n+    super.reinitialize(integrator, y, yDotK, forward);\n+    v1 = null;\n+    v2 = null;\n+    v3 = null;\n+    v4 = null;\n+    vectorsInitialized = false;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public void storeTime(final double t) {\n+    super.storeTime(t);\n+    vectorsInitialized = false;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  protected void computeInterpolatedStateAndDerivatives(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    if (! vectorsInitialized) {\n+\n+      if (v1 == null) {\n+        v1 = new double[interpolatedState.length];\n+        v2 = new double[interpolatedState.length];\n+        v3 = new double[interpolatedState.length];\n+        v4 = new double[interpolatedState.length];\n+      }\n+\n+      // no step finalization is needed for this interpolator\n+\n+      // we need to compute the interpolation vectors for this time step\n+      for (int i = 0; i < interpolatedState.length; ++i) {\n+          final double yDot0 = yDotK[0][i];\n+          final double yDot2 = yDotK[2][i];\n+          final double yDot3 = yDotK[3][i];\n+          final double yDot4 = yDotK[4][i];\n+          final double yDot5 = yDotK[5][i];\n+          final double yDot6 = yDotK[6][i];\n+          v1[i] = a70 * yDot0 + a72 * yDot2 + a73 * yDot3 + a74 * yDot4 + a75 * yDot5;\n+          v2[i] = yDot0 - v1[i];\n+          v3[i] = v1[i] - v2[i] - yDot6;\n+          v4[i] = d0 * yDot0 + d2 * yDot2 + d3 * yDot3 + d4 * yDot4 + d5 * yDot5 + d6 * yDot6;\n+      }\n+\n+      vectorsInitialized = true;\n+\n+    }\n+\n+    // interpolate\n+    final double eta = 1 - theta;\n+    final double twoTheta = 2 * theta;\n+    final double dot2 = 1 - twoTheta;\n+    final double dot3 = theta * (2 - 3 * theta);\n+    final double dot4 = twoTheta * (1 + theta * (twoTheta - 3));\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] =\n+          currentState[i] - oneMinusThetaH * (v1[i] - theta * (v2[i] + theta * (v3[i] + eta * v4[i])));\n+      interpolatedDerivatives[i] = v1[i] + dot2 * v2[i] + dot3 * v3[i] + dot4 * v4[i];\n+    }\n+\n+  }\n+\n+  /** First vector for interpolation. */\n+  private double[] v1;\n+\n+  /** Second vector for interpolation. */\n+  private double[] v2;\n+\n+  /** Third vector for interpolation. */\n+  private double[] v3;\n+\n+  /** Fourth vector for interpolation. */\n+  private double[] v4;\n+\n+  /** Initialization indicator for the interpolation vectors. */\n+  private boolean vectorsInitialized;\n+\n+  /** Last row of the Butcher-array internal weights, element 0. */\n+  private static final double a70 =    35.0 /  384.0;\n+\n+  // element 1 is zero, so it is neither stored nor used\n+\n+  /** Last row of the Butcher-array internal weights, element 2. */\n+  private static final double a72 =   500.0 / 1113.0;\n+\n+  /** Last row of the Butcher-array internal weights, element 3. */\n+  private static final double a73 =   125.0 /  192.0;\n+\n+  /** Last row of the Butcher-array internal weights, element 4. */\n+  private static final double a74 = -2187.0 / 6784.0;\n+\n+  /** Last row of the Butcher-array internal weights, element 5. */\n+  private static final double a75 =    11.0 /   84.0;\n+\n+  /** Shampine (1986) Dense output, element 0. */\n+  private static final double d0 =  -12715105075.0 /  11282082432.0;\n+\n+  // element 1 is zero, so it is neither stored nor used\n+\n+  /** Shampine (1986) Dense output, element 2. */\n+  private static final double d2 =   87487479700.0 /  32700410799.0;\n+\n+  /** Shampine (1986) Dense output, element 3. */\n+  private static final double d3 =  -10690763975.0 /   1880347072.0;\n+\n+  /** Shampine (1986) Dense output, element 4. */\n+  private static final double d4 =  701980252875.0 / 199316789632.0;\n+\n+  /** Shampine (1986) Dense output, element 5. */\n+  private static final double d5 =   -1453857185.0 /    822651844.0;\n+\n+  /** Shampine (1986) Dense output, element 6. */\n+  private static final double d6 =      69997945.0 /     29380423.0;\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = 4104157279605906956L;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853Integrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+\n+/**\n+ * This class implements the 8(5,3) Dormand-Prince integrator for Ordinary\n+ * Differential Equations.\n+ *\n+ * <p>This integrator is an embedded Runge-Kutta integrator\n+ * of order 8(5,3) used in local extrapolation mode (i.e. the solution\n+ * is computed using the high order formula) with stepsize control\n+ * (and automatic step initialization) and continuous output. This\n+ * method uses 12 functions evaluations per step for integration and 4\n+ * evaluations for interpolation. However, since the first\n+ * interpolation evaluation is the same as the first integration\n+ * evaluation of the next step, we have included it in the integrator\n+ * rather than in the interpolator and specified the method was an\n+ * <i>fsal</i>. Hence, despite we have 13 stages here, the cost is\n+ * really 12 evaluations per step even if no interpolation is done,\n+ * and the overcost of interpolation is only 3 evaluations.</p>\n+ *\n+ * <p>This method is based on an 8(6) method by Dormand and Prince\n+ * (i.e. order 8 for the integration and order 6 for error estimation)\n+ * modified by Hairer and Wanner to use a 5th order error estimator\n+ * with 3rd order correction. This modification was introduced because\n+ * the original method failed in some cases (wrong steps can be\n+ * accepted when step size is too large, for example in the\n+ * Brusselator problem) and also had <i>severe difficulties when\n+ * applied to problems with discontinuities</i>. This modification is\n+ * explained in the second edition of the first volume (Nonstiff\n+ * Problems) of the reference book by Hairer, Norsett and Wanner:\n+ * <i>Solving Ordinary Differential Equations</i> (Springer-Verlag,\n+ * ISBN 3-540-56670-8).</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class DormandPrince853Integrator extends EmbeddedRungeKuttaIntegrator {\n+\n+  /** Integrator method name. */\n+  private static final String METHOD_NAME = \"Dormand-Prince 8 (5, 3)\";\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] staticC = {\n+    (12.0 - 2.0 * Math.sqrt(6.0)) / 135.0, (6.0 - Math.sqrt(6.0)) / 45.0, (6.0 - Math.sqrt(6.0)) / 30.0,\n+    (6.0 + Math.sqrt(6.0)) / 30.0, 1.0/3.0, 1.0/4.0, 4.0/13.0, 127.0/195.0, 3.0/5.0,\n+    6.0/7.0, 1.0, 1.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] staticA = {\n+\n+    // k2\n+    {(12.0 - 2.0 * Math.sqrt(6.0)) / 135.0},\n+\n+    // k3\n+    {(6.0 - Math.sqrt(6.0)) / 180.0, (6.0 - Math.sqrt(6.0)) / 60.0},\n+\n+    // k4\n+    {(6.0 - Math.sqrt(6.0)) / 120.0, 0.0, (6.0 - Math.sqrt(6.0)) / 40.0},\n+\n+    // k5\n+    {(462.0 + 107.0 * Math.sqrt(6.0)) / 3000.0, 0.0,\n+     (-402.0 - 197.0 * Math.sqrt(6.0)) / 1000.0, (168.0 + 73.0 * Math.sqrt(6.0)) / 375.0},\n+\n+    // k6\n+    {1.0 / 27.0, 0.0, 0.0, (16.0 + Math.sqrt(6.0)) / 108.0, (16.0 - Math.sqrt(6.0)) / 108.0},\n+\n+    // k7\n+    {19.0 / 512.0, 0.0, 0.0, (118.0 + 23.0 * Math.sqrt(6.0)) / 1024.0,\n+     (118.0 - 23.0 * Math.sqrt(6.0)) / 1024.0, -9.0 / 512.0},\n+\n+    // k8\n+    {13772.0 / 371293.0, 0.0, 0.0, (51544.0 + 4784.0 * Math.sqrt(6.0)) / 371293.0,\n+     (51544.0 - 4784.0 * Math.sqrt(6.0)) / 371293.0, -5688.0 / 371293.0, 3072.0 / 371293.0},\n+\n+    // k9\n+    {58656157643.0 / 93983540625.0, 0.0, 0.0,\n+     (-1324889724104.0 - 318801444819.0 * Math.sqrt(6.0)) / 626556937500.0,\n+     (-1324889724104.0 + 318801444819.0 * Math.sqrt(6.0)) / 626556937500.0,\n+     96044563816.0 / 3480871875.0, 5682451879168.0 / 281950621875.0,\n+     -165125654.0 / 3796875.0},\n+\n+    // k10\n+    {8909899.0 / 18653125.0, 0.0, 0.0,\n+     (-4521408.0 - 1137963.0 * Math.sqrt(6.0)) / 2937500.0,\n+     (-4521408.0 + 1137963.0 * Math.sqrt(6.0)) / 2937500.0,\n+     96663078.0 / 4553125.0, 2107245056.0 / 137915625.0,\n+     -4913652016.0 / 147609375.0, -78894270.0 / 3880452869.0},\n+\n+    // k11\n+    {-20401265806.0 / 21769653311.0, 0.0, 0.0,\n+     (354216.0 + 94326.0 * Math.sqrt(6.0)) / 112847.0,\n+     (354216.0 - 94326.0 * Math.sqrt(6.0)) / 112847.0,\n+     -43306765128.0 / 5313852383.0, -20866708358144.0 / 1126708119789.0,\n+     14886003438020.0 / 654632330667.0, 35290686222309375.0 / 14152473387134411.0,\n+     -1477884375.0 / 485066827.0},\n+\n+    // k12\n+    {39815761.0 / 17514443.0, 0.0, 0.0,\n+     (-3457480.0 - 960905.0 * Math.sqrt(6.0)) / 551636.0,\n+     (-3457480.0 + 960905.0 * Math.sqrt(6.0)) / 551636.0,\n+     -844554132.0 / 47026969.0, 8444996352.0 / 302158619.0,\n+     -2509602342.0 / 877790785.0, -28388795297996250.0 / 3199510091356783.0,\n+     226716250.0 / 18341897.0, 1371316744.0 / 2131383595.0},\n+\n+    // k13 should be for interpolation only, but since it is the same\n+    // stage as the first evaluation of the next step, we perform it\n+    // here at no cost by specifying this is an fsal method\n+    {104257.0/1920240.0, 0.0, 0.0, 0.0, 0.0, 3399327.0/763840.0,\n+     66578432.0/35198415.0, -1674902723.0/288716400.0,\n+     54980371265625.0/176692375811392.0, -734375.0/4826304.0,\n+     171414593.0/851261400.0, 137909.0/3084480.0}\n+\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] staticB = {\n+      104257.0/1920240.0,\n+      0.0,\n+      0.0,\n+      0.0,\n+      0.0,\n+      3399327.0/763840.0,\n+      66578432.0/35198415.0,\n+      -1674902723.0/288716400.0,\n+      54980371265625.0/176692375811392.0,\n+      -734375.0/4826304.0,\n+      171414593.0/851261400.0,\n+      137909.0/3084480.0,\n+      0.0\n+  };\n+\n+  /** First error weights array, element 1. */\n+  private static final double e1_01 =         116092271.0 / 8848465920.0;\n+\n+  // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+  /** First error weights array, element 6. */\n+  private static final double e1_06 =          -1871647.0 / 1527680.0;\n+\n+  /** First error weights array, element 7. */\n+  private static final double e1_07 =         -69799717.0 / 140793660.0;\n+\n+  /** First error weights array, element 8. */\n+  private static final double e1_08 =     1230164450203.0 / 739113984000.0;\n+\n+  /** First error weights array, element 9. */\n+  private static final double e1_09 = -1980813971228885.0 / 5654156025964544.0;\n+\n+  /** First error weights array, element 10. */\n+  private static final double e1_10 =         464500805.0 / 1389975552.0;\n+\n+  /** First error weights array, element 11. */\n+  private static final double e1_11 =     1606764981773.0 / 19613062656000.0;\n+\n+  /** First error weights array, element 12. */\n+  private static final double e1_12 =           -137909.0 / 6168960.0;\n+\n+\n+  /** Second error weights array, element 1. */\n+  private static final double e2_01 =           -364463.0 / 1920240.0;\n+\n+  // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+  /** Second error weights array, element 6. */\n+  private static final double e2_06 =           3399327.0 / 763840.0;\n+\n+  /** Second error weights array, element 7. */\n+  private static final double e2_07 =          66578432.0 / 35198415.0;\n+\n+  /** Second error weights array, element 8. */\n+  private static final double e2_08 =       -1674902723.0 / 288716400.0;\n+\n+  /** Second error weights array, element 9. */\n+  private static final double e2_09 =   -74684743568175.0 / 176692375811392.0;\n+\n+  /** Second error weights array, element 10. */\n+  private static final double e2_10 =           -734375.0 / 4826304.0;\n+\n+  /** Second error weights array, element 11. */\n+  private static final double e2_11 =         171414593.0 / 851261400.0;\n+\n+  /** Second error weights array, element 12. */\n+  private static final double e2_12 =             69869.0 / 3084480.0;\n+\n+  /** Simple constructor.\n+   * Build an eighth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince853Integrator(final double minStep, final double maxStep,\n+                                    final double scalAbsoluteTolerance,\n+                                    final double scalRelativeTolerance) {\n+    super(METHOD_NAME, true, staticC, staticA, staticB,\n+          new DormandPrince853StepInterpolator(),\n+          minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+  }\n+\n+  /** Simple constructor.\n+   * Build an eighth order Dormand-Prince integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public DormandPrince853Integrator(final double minStep, final double maxStep,\n+                                    final double[] vecAbsoluteTolerance,\n+                                    final double[] vecRelativeTolerance) {\n+    super(METHOD_NAME, true, staticC, staticA, staticB,\n+          new DormandPrince853StepInterpolator(),\n+          minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public int getOrder() {\n+    return 8;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  protected double estimateError(final double[][] yDotK,\n+                                 final double[] y0, final double[] y1,\n+                                 final double h) {\n+    double error1 = 0;\n+    double error2 = 0;\n+\n+    for (int j = 0; j < y0.length; ++j) {\n+      final double errSum1 = e1_01 * yDotK[0][j]  + e1_06 * yDotK[5][j] +\n+                             e1_07 * yDotK[6][j]  + e1_08 * yDotK[7][j] +\n+                             e1_09 * yDotK[8][j]  + e1_10 * yDotK[9][j] +\n+                             e1_11 * yDotK[10][j] + e1_12 * yDotK[11][j];\n+      final double errSum2 = e2_01 * yDotK[0][j]  + e2_06 * yDotK[5][j] +\n+                             e2_07 * yDotK[6][j]  + e2_08 * yDotK[7][j] +\n+                             e2_09 * yDotK[8][j]  + e2_10 * yDotK[9][j] +\n+                             e2_11 * yDotK[10][j] + e2_12 * yDotK[11][j];\n+\n+      final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n+      final double tol = (vecAbsoluteTolerance == null) ?\n+                         (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n+                         (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n+      final double ratio1  = errSum1 / tol;\n+      error1        += ratio1 * ratio1;\n+      final double ratio2  = errSum2 / tol;\n+      error2        += ratio2 * ratio2;\n+    }\n+\n+    double den = error1 + 0.01 * error2;\n+    if (den <= 0.0) {\n+      den = 1.0;\n+    }\n+\n+    return Math.abs(h) * error1 / Math.sqrt(y0.length * den);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.ode.AbstractIntegrator;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class represents an interpolator over the last step during an\n+ * ODE integration for the 8(5,3) Dormand-Prince integrator.\n+ *\n+ * @see DormandPrince853Integrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class DormandPrince853StepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link EmbeddedRungeKuttaIntegrator} uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public DormandPrince853StepInterpolator() {\n+    super();\n+    yDotKLast = null;\n+    v         = null;\n+    vectorsInitialized = false;\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public DormandPrince853StepInterpolator(final DormandPrince853StepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    if (interpolator.currentState == null) {\n+\n+      yDotKLast = null;\n+      v         = null;\n+      vectorsInitialized = false;\n+\n+    } else {\n+\n+      final int dimension = interpolator.currentState.length;\n+\n+      yDotKLast    = new double[3][];\n+      for (int k = 0; k < yDotKLast.length; ++k) {\n+        yDotKLast[k] = new double[dimension];\n+        System.arraycopy(interpolator.yDotKLast[k], 0, yDotKLast[k], 0,\n+                         dimension);\n+      }\n+\n+      v = new double[7][];\n+      for (int k = 0; k < v.length; ++k) {\n+        v[k] = new double[dimension];\n+        System.arraycopy(interpolator.v[k], 0, v[k], 0, dimension);\n+      }\n+\n+      vectorsInitialized = interpolator.vectorsInitialized;\n+\n+    }\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  protected StepInterpolator doCopy() {\n+    return new DormandPrince853StepInterpolator(this);\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public void reinitialize(final AbstractIntegrator integrator,\n+                           final double[] y, final double[][] yDotK, final boolean forward) {\n+\n+    super.reinitialize(integrator, y, yDotK, forward);\n+\n+    final int dimension = currentState.length;\n+\n+    yDotKLast = new double[3][];\n+    for (int k = 0; k < yDotKLast.length; ++k) {\n+      yDotKLast[k] = new double[dimension];\n+    }\n+\n+    v = new double[7][];\n+    for (int k = 0; k < v.length; ++k) {\n+      v[k]  = new double[dimension];\n+    }\n+\n+    vectorsInitialized = false;\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public void storeTime(final double t) {\n+    super.storeTime(t);\n+    vectorsInitialized = false;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  protected void computeInterpolatedStateAndDerivatives(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    if (! vectorsInitialized) {\n+\n+      if (v == null) {\n+        v = new double[7][];\n+        for (int k = 0; k < 7; ++k) {\n+          v[k] = new double[interpolatedState.length];\n+        }\n+      }\n+\n+      // perform the last evaluations if they have not been done yet\n+      finalizeStep();\n+\n+      // compute the interpolation vectors for this time step\n+      for (int i = 0; i < interpolatedState.length; ++i) {\n+          final double yDot1  = yDotK[0][i];\n+          final double yDot6  = yDotK[5][i];\n+          final double yDot7  = yDotK[6][i];\n+          final double yDot8  = yDotK[7][i];\n+          final double yDot9  = yDotK[8][i];\n+          final double yDot10 = yDotK[9][i];\n+          final double yDot11 = yDotK[10][i];\n+          final double yDot12 = yDotK[11][i];\n+          final double yDot13 = yDotK[12][i];\n+          final double yDot14 = yDotKLast[0][i];\n+          final double yDot15 = yDotKLast[1][i];\n+          final double yDot16 = yDotKLast[2][i];\n+          v[0][i] = b_01 * yDot1  + b_06 * yDot6 + b_07 * yDot7 +\n+                    b_08 * yDot8  + b_09 * yDot9 + b_10 * yDot10 +\n+                    b_11 * yDot11 + b_12 * yDot12;\n+          v[1][i] = yDot1 - v[0][i];\n+          v[2][i] = v[0][i] - v[1][i] - yDotK[12][i];\n+          for (int k = 0; k < d.length; ++k) {\n+              v[k+3][i] = d[k][0] * yDot1  + d[k][1]  * yDot6  + d[k][2]  * yDot7  +\n+                          d[k][3] * yDot8  + d[k][4]  * yDot9  + d[k][5]  * yDot10 +\n+                          d[k][6] * yDot11 + d[k][7]  * yDot12 + d[k][8]  * yDot13 +\n+                          d[k][9] * yDot14 + d[k][10] * yDot15 + d[k][11] * yDot16;\n+          }\n+      }\n+\n+      vectorsInitialized = true;\n+\n+    }\n+\n+    final double eta      = 1 - theta;\n+    final double twoTheta = 2 * theta;\n+    final double theta2   = theta * theta;\n+    final double dot1 = 1 - twoTheta;\n+    final double dot2 = theta * (2 - 3 * theta);\n+    final double dot3 = twoTheta * (1 + theta * (twoTheta -3));\n+    final double dot4 = theta2 * (3 + theta * (5 * theta - 8));\n+    final double dot5 = theta2 * (3 + theta * (-12 + theta * (15 - 6 * theta)));\n+    final double dot6 = theta2 * theta * (4 + theta * (-15 + theta * (18 - 7 * theta)));\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i] -\n+                             oneMinusThetaH * (v[0][i] -\n+                                               theta * (v[1][i] +\n+                                                        theta * (v[2][i] +\n+                                                                 eta * (v[3][i] +\n+                                                                        theta * (v[4][i] +\n+                                                                                 eta * (v[5][i] +\n+                                                                                        theta * (v[6][i])))))));\n+      interpolatedDerivatives[i] =  v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] +\n+                                    dot3 * v[3][i] + dot4 * v[4][i] +\n+                                    dot5 * v[5][i] + dot6 * v[6][i];\n+    }\n+\n+  }\n+ \n+  /** {@inheritDoc} */\n+  @Override\n+  protected void doFinalize()\n+    throws DerivativeException {\n+\n+    if (currentState == null) {\n+      // we are finalizing an uninitialized instance\n+      return;\n+    }\n+\n+    double s;\n+    final double[] yTmp = new double[currentState.length];\n+\n+    // k14\n+    for (int j = 0; j < currentState.length; ++j) {\n+      s = k14_01 * yDotK[0][j]  + k14_06 * yDotK[5][j]  + k14_07 * yDotK[6][j] +\n+          k14_08 * yDotK[7][j]  + k14_09 * yDotK[8][j]  + k14_10 * yDotK[9][j] +\n+          k14_11 * yDotK[10][j] + k14_12 * yDotK[11][j] + k14_13 * yDotK[12][j];\n+      yTmp[j] = currentState[j] + h * s;\n+    }\n+    integrator.computeDerivatives(previousTime + c14 * h, yTmp, yDotKLast[0]);\n+\n+    // k15\n+    for (int j = 0; j < currentState.length; ++j) {\n+     s = k15_01 * yDotK[0][j]  + k15_06 * yDotK[5][j]  + k15_07 * yDotK[6][j] +\n+         k15_08 * yDotK[7][j]  + k15_09 * yDotK[8][j]  + k15_10 * yDotK[9][j] +\n+         k15_11 * yDotK[10][j] + k15_12 * yDotK[11][j] + k15_13 * yDotK[12][j] +\n+         k15_14 * yDotKLast[0][j];\n+     yTmp[j] = currentState[j] + h * s;\n+    }\n+    integrator.computeDerivatives(previousTime + c15 * h, yTmp, yDotKLast[1]);\n+\n+    // k16\n+    for (int j = 0; j < currentState.length; ++j) {\n+      s = k16_01 * yDotK[0][j]  + k16_06 * yDotK[5][j]  + k16_07 * yDotK[6][j] +\n+          k16_08 * yDotK[7][j]  + k16_09 * yDotK[8][j]  + k16_10 * yDotK[9][j] +\n+          k16_11 * yDotK[10][j] + k16_12 * yDotK[11][j] + k16_13 * yDotK[12][j] +\n+          k16_14 * yDotKLast[0][j] +  k16_15 * yDotKLast[1][j];\n+      yTmp[j] = currentState[j] + h * s;\n+    }\n+    integrator.computeDerivatives(previousTime + c16 * h, yTmp, yDotKLast[2]);\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public void writeExternal(final ObjectOutput out)\n+    throws IOException {\n+\n+    try {\n+      // save the local attributes\n+      finalizeStep();\n+    } catch (DerivativeException e) {\n+      throw MathRuntimeException.createIOException(e);\n+    }\n+    final int dimension = (currentState == null) ? -1 : currentState.length;\n+    out.writeInt(dimension);\n+    for (int i = 0; i < dimension; ++i) {\n+      out.writeDouble(yDotKLast[0][i]);\n+      out.writeDouble(yDotKLast[1][i]);\n+      out.writeDouble(yDotKLast[2][i]);\n+    }\n+\n+    // save the state of the base class\n+    super.writeExternal(out);\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public void readExternal(final ObjectInput in)\n+    throws IOException {\n+\n+    // read the local attributes\n+    yDotKLast = new double[3][];\n+    final int dimension = in.readInt();\n+    yDotKLast[0] = (dimension < 0) ? null : new double[dimension];\n+    yDotKLast[1] = (dimension < 0) ? null : new double[dimension];\n+    yDotKLast[2] = (dimension < 0) ? null : new double[dimension];\n+\n+    for (int i = 0; i < dimension; ++i) {\n+      yDotKLast[0][i] = in.readDouble();\n+      yDotKLast[1][i] = in.readDouble();\n+      yDotKLast[2][i] = in.readDouble();\n+    }\n+\n+    // read the base state\n+    super.readExternal(in);\n+\n+  }\n+\n+  /** Last evaluations. */\n+  private double[][] yDotKLast;\n+\n+  /** Vectors for interpolation. */\n+  private double[][] v;\n+\n+  /** Initialization indicator for the interpolation vectors. */\n+  private boolean vectorsInitialized;\n+\n+  /** Propagation weights, element 1. */\n+  private static final double b_01 =         104257.0 / 1920240.0;\n+\n+  // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+  /** Propagation weights, element 6. */\n+  private static final double b_06 =        3399327.0 / 763840.0;\n+\n+  /** Propagation weights, element 7. */\n+  private static final double b_07 =       66578432.0 / 35198415.0;\n+\n+  /** Propagation weights, element 8. */\n+  private static final double b_08 =    -1674902723.0 / 288716400.0;\n+\n+  /** Propagation weights, element 9. */\n+  private static final double b_09 = 54980371265625.0 / 176692375811392.0;\n+\n+  /** Propagation weights, element 10. */\n+  private static final double b_10 =        -734375.0 / 4826304.0;\n+\n+  /** Propagation weights, element 11. */\n+  private static final double b_11 =      171414593.0 / 851261400.0;\n+\n+  /** Propagation weights, element 12. */\n+  private static final double b_12 =         137909.0 / 3084480.0;\n+\n+  /** Time step for stage 14 (interpolation only). */\n+  private static final double c14    = 1.0 / 10.0;\n+\n+  /** Internal weights for stage 14, element 1. */\n+  private static final double k14_01 =       13481885573.0 / 240030000000.0      - b_01;\n+\n+  // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+  /** Internal weights for stage 14, element 6. */\n+  private static final double k14_06 =                 0.0                       - b_06;\n+\n+  /** Internal weights for stage 14, element 7. */\n+  private static final double k14_07 =      139418837528.0 / 549975234375.0      - b_07;\n+\n+  /** Internal weights for stage 14, element 8. */\n+  private static final double k14_08 =   -11108320068443.0 / 45111937500000.0    - b_08;\n+\n+  /** Internal weights for stage 14, element 9. */\n+  private static final double k14_09 = -1769651421925959.0 / 14249385146080000.0 - b_09;\n+\n+  /** Internal weights for stage 14, element 10. */\n+  private static final double k14_10 =          57799439.0 / 377055000.0         - b_10;\n+\n+  /** Internal weights for stage 14, element 11. */\n+  private static final double k14_11 =      793322643029.0 / 96734250000000.0    - b_11;\n+\n+  /** Internal weights for stage 14, element 12. */\n+  private static final double k14_12 =        1458939311.0 / 192780000000.0      - b_12;\n+\n+  /** Internal weights for stage 14, element 13. */\n+  private static final double k14_13 =             -4149.0 / 500000.0;\n+\n+  /** Time step for stage 15 (interpolation only). */\n+  private static final double c15    = 1.0 / 5.0;\n+\n+\n+  /** Internal weights for stage 15, element 1. */\n+  private static final double k15_01 =     1595561272731.0 / 50120273500000.0    - b_01;\n+\n+  // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+  /** Internal weights for stage 15, element 6. */\n+  private static final double k15_06 =      975183916491.0 / 34457688031250.0    - b_06;\n+\n+  /** Internal weights for stage 15, element 7. */\n+  private static final double k15_07 =    38492013932672.0 / 718912673015625.0   - b_07;\n+\n+  /** Internal weights for stage 15, element 8. */\n+  private static final double k15_08 = -1114881286517557.0 / 20298710767500000.0 - b_08;\n+\n+  /** Internal weights for stage 15, element 9. */\n+  private static final double k15_09 =                 0.0                       - b_09;\n+\n+  /** Internal weights for stage 15, element 10. */\n+  private static final double k15_10 =                 0.0                       - b_10;\n+\n+  /** Internal weights for stage 15, element 11. */\n+  private static final double k15_11 =    -2538710946863.0 / 23431227861250000.0 - b_11;\n+\n+  /** Internal weights for stage 15, element 12. */\n+  private static final double k15_12 =        8824659001.0 / 23066716781250.0    - b_12;\n+\n+  /** Internal weights for stage 15, element 13. */\n+  private static final double k15_13 =      -11518334563.0 / 33831184612500.0;\n+\n+  /** Internal weights for stage 15, element 14. */\n+  private static final double k15_14 =        1912306948.0 / 13532473845.0;\n+\n+  /** Time step for stage 16 (interpolation only). */\n+  private static final double c16    = 7.0 / 9.0;\n+\n+\n+  /** Internal weights for stage 16, element 1. */\n+  private static final double k16_01 =      -13613986967.0 / 31741908048.0       - b_01;\n+\n+  // elements 2 to 5 are zero, so they are neither stored nor used\n+\n+  /** Internal weights for stage 16, element 6. */\n+  private static final double k16_06 =       -4755612631.0 / 1012344804.0        - b_06;\n+\n+  /** Internal weights for stage 16, element 7. */\n+  private static final double k16_07 =    42939257944576.0 / 5588559685701.0     - b_07;\n+\n+  /** Internal weights for stage 16, element 8. */\n+  private static final double k16_08 =    77881972900277.0 / 19140370552944.0    - b_08;\n+\n+  /** Internal weights for stage 16, element 9. */\n+  private static final double k16_09 =    22719829234375.0 / 63689648654052.0    - b_09;\n+\n+  /** Internal weights for stage 16, element 10. */\n+  private static final double k16_10 =                 0.0                       - b_10;\n+\n+  /** Internal weights for stage 16, element 11. */\n+  private static final double k16_11 =                 0.0                       - b_11;\n+\n+  /** Internal weights for stage 16, element 12. */\n+  private static final double k16_12 =                 0.0                       - b_12;\n+\n+  /** Internal weights for stage 16, element 13. */\n+  private static final double k16_13 =       -1199007803.0 / 857031517296.0;\n+\n+  /** Internal weights for stage 16, element 14. */\n+  private static final double k16_14 =      157882067000.0 / 53564469831.0;\n+\n+  /** Internal weights for stage 16, element 15. */\n+  private static final double k16_15 =     -290468882375.0 / 31741908048.0;\n+\n+  /** Interpolation weights.\n+   * (beware that only the non-null values are in the table)\n+   */\n+  private static final double[][] d = {\n+\n+    {        -17751989329.0 / 2106076560.0,               4272954039.0 / 7539864640.0,\n+            -118476319744.0 / 38604839385.0,            755123450731.0 / 316657731600.0,\n+      3692384461234828125.0 / 1744130441634250432.0,     -4612609375.0 / 5293382976.0,\n+            2091772278379.0 / 933644586600.0,             2136624137.0 / 3382989120.0,\n+                  -126493.0 / 1421424.0,                    98350000.0 / 5419179.0,\n+                -18878125.0 / 2053168.0,                 -1944542619.0 / 438351368.0},\n+\n+    {         32941697297.0 / 3159114840.0,             456696183123.0 / 1884966160.0,\n+           19132610714624.0 / 115814518155.0,       -177904688592943.0 / 474986597400.0,\n+     -4821139941836765625.0 / 218016305204281304.0,      30702015625.0 / 3970037232.0,\n+          -85916079474274.0 / 2800933759800.0,           -5919468007.0 / 634310460.0,\n+                  2479159.0 / 157936.0,                    -18750000.0 / 602131.0,\n+                -19203125.0 / 2053168.0,                 15700361463.0 / 438351368.0},\n+\n+    {         12627015655.0 / 631822968.0,              -72955222965.0 / 188496616.0,\n+          -13145744952320.0 / 69488710893.0,          30084216194513.0 / 56998391688.0,\n+      -296858761006640625.0 / 25648977082856624.0,         569140625.0 / 82709109.0,\n+             -18684190637.0 / 18672891732.0,                69644045.0 / 89549712.0,\n+                -11847025.0 / 4264272.0,                  -978650000.0 / 16257537.0,\n+                519371875.0 / 6159504.0,                  5256837225.0 / 438351368.0},\n+\n+    {          -450944925.0 / 17550638.0,               -14532122925.0 / 94248308.0,\n+            -595876966400.0 / 2573655959.0,             188748653015.0 / 527762886.0,\n+      2545485458115234375.0 / 27252038150535163.0,       -1376953125.0 / 36759604.0,\n+              53995596795.0 / 518691437.0,                 210311225.0 / 7047894.0,\n+                 -1718875.0 / 39484.0,                      58000000.0 / 602131.0,\n+                 -1546875.0 / 39484.0,                   -1262172375.0 / 8429834.0}\n+\n+  };\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = 7152276390558450974L;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+/**\n+ * This class implements the common part of all embedded Runge-Kutta\n+ * integrators for Ordinary Differential Equations.\n+ *\n+ * <p>These methods are embedded explicit Runge-Kutta methods with two\n+ * sets of coefficients allowing to estimate the error, their Butcher\n+ * arrays are as follows :\n+ * <pre>\n+ *    0  |\n+ *   c2  | a21\n+ *   c3  | a31  a32\n+ *   ... |        ...\n+ *   cs  | as1  as2  ...  ass-1\n+ *       |--------------------------\n+ *       |  b1   b2  ...   bs-1  bs\n+ *       |  b'1  b'2 ...   b's-1 b's\n+ * </pre>\n+ * </p>\n+ *\n+ * <p>In fact, we rather use the array defined by ej = bj - b'j to\n+ * compute directly the error rather than computing two estimates and\n+ * then comparing them.</p>\n+ *\n+ * <p>Some methods are qualified as <i>fsal</i> (first same as last)\n+ * methods. This means the last evaluation of the derivatives in one\n+ * step is the same as the first in the next step. Then, this\n+ * evaluation can be reused from one step to the next one and the cost\n+ * of such a method is really s-1 evaluations despite the method still\n+ * has s stages. This behaviour is true only for successful steps, if\n+ * the step is rejected after the error estimation phase, no\n+ * evaluation is saved. For an <i>fsal</i> method, we have cs = 1 and\n+ * asi = bi for all i.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public abstract class EmbeddedRungeKuttaIntegrator\n+  extends AdaptiveStepsizeIntegrator {\n+\n+  /** Build a Runge-Kutta integrator with the given Butcher array.\n+   * @param name name of the method\n+   * @param fsal indicate that the method is an <i>fsal</i>\n+   * @param c time steps from Butcher array (without the first zero)\n+   * @param a internal weights from Butcher array (without the first empty row)\n+   * @param b propagation weights for the high order method from Butcher array\n+   * @param prototype prototype of the step interpolator to use\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n+                                         final double[] c, final double[][] a, final double[] b,\n+                                         final RungeKuttaStepInterpolator prototype,\n+                                         final double minStep, final double maxStep,\n+                                         final double scalAbsoluteTolerance,\n+                                         final double scalRelativeTolerance) {\n+\n+    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+\n+    this.fsal      = fsal;\n+    this.c         = c;\n+    this.a         = a;\n+    this.b         = b;\n+    this.prototype = prototype;\n+\n+    exp = -1.0 / getOrder();\n+\n+    // set the default values of the algorithm control parameters\n+    setSafety(0.9);\n+    setMinReduction(0.2);\n+    setMaxGrowth(10.0);\n+\n+  }\n+\n+  /** Build a Runge-Kutta integrator with the given Butcher array.\n+   * @param name name of the method\n+   * @param fsal indicate that the method is an <i>fsal</i>\n+   * @param c time steps from Butcher array (without the first zero)\n+   * @param a internal weights from Butcher array (without the first empty row)\n+   * @param b propagation weights for the high order method from Butcher array\n+   * @param prototype prototype of the step interpolator to use\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n+                                         final double[] c, final double[][] a, final double[] b,\n+                                         final RungeKuttaStepInterpolator prototype,\n+                                         final double   minStep, final double maxStep,\n+                                         final double[] vecAbsoluteTolerance,\n+                                         final double[] vecRelativeTolerance) {\n+\n+    super(name, minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+\n+    this.fsal      = fsal;\n+    this.c         = c;\n+    this.a         = a;\n+    this.b         = b;\n+    this.prototype = prototype;\n+\n+    exp = -1.0 / getOrder();\n+\n+    // set the default values of the algorithm control parameters\n+    setSafety(0.9);\n+    setMinReduction(0.2);\n+    setMaxGrowth(10.0);\n+\n+  }\n+\n+  /** Get the order of the method.\n+   * @return order of the method\n+   */\n+  public abstract int getOrder();\n+\n+  /** Get the safety factor for stepsize control.\n+   * @return safety factor\n+   */\n+  public double getSafety() {\n+    return safety;\n+  }\n+\n+  /** Set the safety factor for stepsize control.\n+   * @param safety safety factor\n+   */\n+  public void setSafety(final double safety) {\n+    this.safety = safety;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public double integrate(final FirstOrderDifferentialEquations equations,\n+                          final double t0, final double[] y0,\n+                          final double t, final double[] y)\n+  throws DerivativeException, IntegratorException {\n+\n+    sanityChecks(equations, t0, y0, t, y);\n+    setEquations(equations);\n+    resetEvaluations();\n+    final boolean forward = (t > t0);\n+\n+    // create some internal working arrays\n+    final int stages = c.length + 1;\n+    if (y != y0) {\n+      System.arraycopy(y0, 0, y, 0, y0.length);\n+    }\n+    final double[][] yDotK = new double[stages][y0.length];\n+    final double[] yTmp = new double[y0.length];\n+\n+    // set up an interpolator sharing the integrator arrays\n+    AbstractStepInterpolator interpolator;\n+    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n+      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n+      rki.reinitialize(this, yTmp, yDotK, forward);\n+      interpolator = rki;\n+    } else {\n+      interpolator = new DummyStepInterpolator(yTmp, forward);\n+    }\n+    interpolator.storeTime(t0);\n+\n+    // set up integration control objects\n+    stepStart         = t0;\n+    double  hNew      = 0;\n+    boolean firstTime = true;\n+    for (StepHandler handler : stepHandlers) {\n+        handler.reset();\n+    }\n+    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n+    boolean lastStep = false;\n+\n+    // main integration loop\n+    while (!lastStep) {\n+\n+      interpolator.shift();\n+\n+      double error = 0;\n+      for (boolean loop = true; loop;) {\n+\n+        if (firstTime || !fsal) {\n+          // first stage\n+          computeDerivatives(stepStart, y, yDotK[0]);\n+        }\n+\n+        if (firstTime) {\n+          final double[] scale;\n+          if (vecAbsoluteTolerance != null) {\n+            scale = vecAbsoluteTolerance;\n+          } else {\n+            scale = new double[y0.length];\n+            Arrays.fill(scale, scalAbsoluteTolerance);\n+          }\n+          hNew = initializeStep(equations, forward, getOrder(), scale,\n+                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n+          firstTime = false;\n+        }\n+\n+        stepSize = hNew;\n+\n+        // next stages\n+        for (int k = 1; k < stages; ++k) {\n+\n+          for (int j = 0; j < y0.length; ++j) {\n+            double sum = a[k-1][0] * yDotK[0][j];\n+            for (int l = 1; l < k; ++l) {\n+              sum += a[k-1][l] * yDotK[l][j];\n+            }\n+            yTmp[j] = y[j] + stepSize * sum;\n+          }\n+\n+          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n+\n+        }\n+\n+        // estimate the state at the end of the step\n+        for (int j = 0; j < y0.length; ++j) {\n+          double sum    = b[0] * yDotK[0][j];\n+          for (int l = 1; l < stages; ++l) {\n+            sum    += b[l] * yDotK[l][j];\n+          }\n+          yTmp[j] = y[j] + stepSize * sum;\n+        }\n+\n+        // estimate the error at the end of the step\n+        error = estimateError(yDotK, y, yTmp, stepSize);\n+        if (error <= 1.0) {\n+\n+          // discrete events handling\n+          interpolator.storeTime(stepStart + stepSize);\n+          if (manager.evaluateStep(interpolator)) {\n+              final double dt = manager.getEventTime() - stepStart;\n+              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n+                  // rejecting the step would lead to a too small next step, we accept it\n+                  loop = false;\n+              } else {\n+                  // reject the step to match exactly the next switch time\n+                  hNew = dt;\n+              }\n+          } else {\n+            // accept the step\n+            loop = false;\n+          }\n+\n+        } else {\n+          // reject the step and attempt to reduce error by stepsize control\n+          final double factor =\n+              Math.min(maxGrowth,\n+                       Math.max(minReduction, safety * Math.pow(error, exp)));\n+          hNew = filterStep(stepSize * factor, forward, false);\n+        }\n+\n+      }\n+\n+      // the step has been accepted\n+      final double nextStep = stepStart + stepSize;\n+      System.arraycopy(yTmp, 0, y, 0, y0.length);\n+      manager.stepAccepted(nextStep, y);\n+      lastStep = manager.stop();\n+\n+      // provide the step data to the step handler\n+      interpolator.storeTime(nextStep);\n+      for (StepHandler handler : stepHandlers) {\n+          handler.handleStep(interpolator, lastStep);\n+      }\n+      stepStart = nextStep;\n+\n+      if (fsal) {\n+        // save the last evaluation for the next step\n+        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n+      }\n+\n+      if (manager.reset(stepStart, y) && ! lastStep) {\n+        // some event handler has triggered changes that\n+        // invalidate the derivatives, we need to recompute them\n+        computeDerivatives(stepStart, y, yDotK[0]);\n+      }\n+\n+      if (! lastStep) {\n+        // in some rare cases we may get here with stepSize = 0, for example\n+        // when an event occurs at integration start, reducing the first step\n+        // to zero; we have to reset the step to some safe non zero value\n+          stepSize = filterStep(stepSize, forward, true);\n+\n+        // stepsize control for next step\n+        final double factor = Math.min(maxGrowth,\n+                                       Math.max(minReduction,\n+                                                safety * Math.pow(error, exp)));\n+        final double  scaledH    = stepSize * factor;\n+        final double  nextT      = stepStart + scaledH;\n+        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n+        hNew = filterStep(scaledH, forward, nextIsLast);\n+      }\n+\n+    }\n+\n+    final double stopTime = stepStart;\n+    resetInternalState();\n+    return stopTime;\n+\n+  }\n+\n+  /** Get the minimal reduction factor for stepsize control.\n+   * @return minimal reduction factor\n+   */\n+  public double getMinReduction() {\n+    return minReduction;\n+  }\n+\n+  /** Set the minimal reduction factor for stepsize control.\n+   * @param minReduction minimal reduction factor\n+   */\n+  public void setMinReduction(final double minReduction) {\n+    this.minReduction = minReduction;\n+  }\n+\n+  /** Get the maximal growth factor for stepsize control.\n+   * @return maximal growth factor\n+   */\n+  public double getMaxGrowth() {\n+    return maxGrowth;\n+  }\n+\n+  /** Set the maximal growth factor for stepsize control.\n+   * @param maxGrowth maximal growth factor\n+   */\n+  public void setMaxGrowth(final double maxGrowth) {\n+    this.maxGrowth = maxGrowth;\n+  }\n+\n+  /** Compute the error ratio.\n+   * @param yDotK derivatives computed during the first stages\n+   * @param y0 estimate of the step at the start of the step\n+   * @param y1 estimate of the step at the end of the step\n+   * @param h  current step\n+   * @return error ratio, greater than 1 if step should be rejected\n+   */\n+  protected abstract double estimateError(double[][] yDotK,\n+                                          double[] y0, double[] y1,\n+                                          double h);\n+\n+  /** Indicator for <i>fsal</i> methods. */\n+  private boolean fsal;\n+\n+  /** Time steps from Butcher array (without the first zero). */\n+  private double[] c;\n+\n+  /** Internal weights from Butcher array (without the first empty row). */\n+  private double[][] a;\n+\n+  /** External weights for the high order method from Butcher array. */\n+  private double[] b;\n+\n+  /** Prototype of the step interpolator. */\n+  private RungeKuttaStepInterpolator prototype;\n+                                         \n+  /** Stepsize control exponent. */\n+  private double exp;\n+\n+  /** Safety factor for stepsize control. */\n+  private double safety;\n+\n+  /** Minimal reduction factor for stepsize control. */\n+  private double minReduction;\n+\n+  /** Maximal growth factor for stepsize control. */\n+  private double maxGrowth;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EulerIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+\n+/**\n+ * This class implements a simple Euler integrator for Ordinary\n+ * Differential Equations.\n+ *\n+ * <p>The Euler algorithm is the simplest one that can be used to\n+ * integrate ordinary differential equations. It is a simple inversion\n+ * of the forward difference expression :\n+ * <code>f'=(f(t+h)-f(t))/h</code> which leads to\n+ * <code>f(t+h)=f(t)+hf'</code>. The interpolation scheme used for\n+ * dense output is the linear scheme already used for integration.</p>\n+ *\n+ * <p>This algorithm looks cheap because it needs only one function\n+ * evaluation per step. However, as it uses linear estimates, it needs\n+ * very small steps to achieve high accuracy, and small steps lead to\n+ * numerical errors and instabilities.</p>\n+ *\n+ * <p>This algorithm is almost never used and has been included in\n+ * this package only as a comparison reference for more useful\n+ * integrators.</p>\n+ *\n+ * @see MidpointIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+ * @see ThreeEighthesIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class EulerIntegrator extends RungeKuttaIntegrator {\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] c = {\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] a = {\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] b = {\n+    1.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build an Euler integrator with the given step.\n+   * @param step integration step\n+   */\n+  public EulerIntegrator(final double step) {\n+    super(\"Euler\", c, a, b, new EulerStepInterpolator(), step);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EulerStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements a linear interpolator for step.\n+ *\n+ * <p>This interpolator computes dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+ *\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h) - (1-theta) h y'\n+ * </pre>\n+ *\n+ * where theta belongs to [0 ; 1] and where y' is the evaluation of\n+ * the derivatives already computed during the step.</p>\n+ *\n+ * @see EulerIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class EulerStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -7179861704951334960L;\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public EulerStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public EulerStepInterpolator(final EulerStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  protected StepInterpolator doCopy() {\n+    return new EulerStepInterpolator(this);\n+  }\n+\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  protected void computeInterpolatedStateAndDerivatives(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      interpolatedState[i] = currentState[i] - oneMinusThetaH * yDotK[0][i];\n+    }\n+    System.arraycopy(yDotK[0], 0, interpolatedDerivatives, 0, interpolatedDerivatives.length);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GillIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+\n+/**\n+ * This class implements the Gill fourth order Runge-Kutta\n+ * integrator for Ordinary Differential Equations .\n+\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |    0        0       0      0\n+ *   1/2 |   1/2       0       0      0\n+ *   1/2 | (q-1)/2  (2-q)/2    0      0\n+ *    1  |    0       -q/2  (2+q)/2   0\n+ *       |-------------------------------\n+ *       |   1/6    (2-q)/6 (2+q)/6  1/6\n+ * </pre>\n+ * where q = sqrt(2)</p>\n+ *\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see MidpointIntegrator\n+ * @see ThreeEighthesIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class GillIntegrator extends RungeKuttaIntegrator {\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] c = {\n+    1.0 / 2.0, 1.0 / 2.0, 1.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] a = {\n+    { 1.0 / 2.0 },\n+    { (Math.sqrt(2.0) - 1.0) / 2.0, (2.0 - Math.sqrt(2.0)) / 2.0 },\n+    { 0.0, -Math.sqrt(2.0) / 2.0, (2.0 + Math.sqrt(2.0)) / 2.0 }\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] b = {\n+    1.0 / 6.0, (2.0 - Math.sqrt(2.0)) / 6.0, (2.0 + Math.sqrt(2.0)) / 6.0, 1.0 / 6.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a fourth-order Gill integrator with the given step.\n+   * @param step integration step\n+   */\n+  public GillIntegrator(final double step) {\n+    super(\"Gill\", c, a, b, new GillStepInterpolator(), step);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GillStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements a step interpolator for the Gill fourth\n+ * order Runge-Kutta integrator.\n+ *\n+ * <p>This interpolator allows to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+ *\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h)\n+ *                    - (1 - theta) (h/6) [ (1 - theta) (1 - 4 theta) y'_1\n+ *                                        + (1 - theta) (1 + 2 theta) ((2-q) y'_2 + (2+q) y'_3)\n+ *                                        + (1 + theta + 4 theta^2) y'_4\n+ *                                        ]\n+ * </pre>\n+ * where theta belongs to [0 ; 1], q = sqrt(2) and where y'_1 to y'_4\n+ * are the four evaluations of the derivatives already computed during\n+ * the step.</p>\n+ *\n+ * @see GillIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class GillStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+    \n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public GillStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public GillStepInterpolator(final GillStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  protected StepInterpolator doCopy() {\n+    return new GillStepInterpolator(this);\n+  }\n+\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  protected void computeInterpolatedStateAndDerivatives(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    final double twoTheta  = 2 * theta;\n+    final double fourTheta = 4 * theta;\n+    final double s         = oneMinusThetaH / 6.0;\n+    final double oMt       = 1 - theta;\n+    final double soMt      = s * oMt;\n+    final double c23       = soMt * (1 + twoTheta);\n+    final double coeff1    = soMt * (1 - fourTheta);\n+    final double coeff2    = c23  * tMq;\n+    final double coeff3    = c23  * tPq;\n+    final double coeff4    = s * (1 + theta * (1 + fourTheta));\n+    final double coeffDot1 = theta * (twoTheta - 3) + 1;\n+    final double cDot23    = theta * oMt;\n+    final double coeffDot2 = cDot23  * tMq;\n+    final double coeffDot3 = cDot23  * tPq;\n+    final double coeffDot4 = theta * (twoTheta - 1);\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+        final double yDot1 = yDotK[0][i];\n+        final double yDot2 = yDotK[1][i];\n+        final double yDot3 = yDotK[2][i];\n+        final double yDot4 = yDotK[3][i];\n+        interpolatedState[i] =\n+            currentState[i] - coeff1 * yDot1 - coeff2 * yDot2 - coeff3 * yDot3 - coeff4 * yDot4;\n+        interpolatedDerivatives[i] =\n+            coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;\n+     }\n+\n+  }\n+\n+  /** First Gill coefficient. */\n+  private static final double tMq = 2 - Math.sqrt(2.0);\n+\n+  /** Second Gill coefficient. */\n+  private static final double tPq = 2 + Math.sqrt(2.0);\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -107804074496313322L;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.EventHandler;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+/**\n+ * This class implements a Gragg-Bulirsch-Stoer integrator for\n+ * Ordinary Differential Equations.\n+ *\n+ * <p>The Gragg-Bulirsch-Stoer algorithm is one of the most efficient\n+ * ones currently available for smooth problems. It uses Richardson\n+ * extrapolation to estimate what would be the solution if the step\n+ * size could be decreased down to zero.</p>\n+ *\n+ * <p>\n+ * This method changes both the step size and the order during\n+ * integration, in order to minimize computation cost. It is\n+ * particularly well suited when a very high precision is needed. The\n+ * limit where this method becomes more efficient than high-order\n+ * embedded Runge-Kutta methods like {@link DormandPrince853Integrator\n+ * Dormand-Prince 8(5,3)} depends on the problem. Results given in the\n+ * Hairer, Norsett and Wanner book show for example that this limit\n+ * occurs for accuracy around 1e-6 when integrating Saltzam-Lorenz\n+ * equations (the authors note this problem is <i>extremely sensitive\n+ * to the errors in the first integration steps</i>), and around 1e-11\n+ * for a two dimensional celestial mechanics problems with seven\n+ * bodies (pleiades problem, involving quasi-collisions for which\n+ * <i>automatic step size control is essential</i>).\n+ * </p>\n+ *\n+ * <p>\n+ * This implementation is basically a reimplementation in Java of the\n+ * <a\n+ * href=\"http://www.unige.ch/math/folks/hairer/prog/nonstiff/odex.f\">odex</a>\n+ * fortran code by E. Hairer and G. Wanner. The redistribution policy\n+ * for this code is available <a\n+ * href=\"http://www.unige.ch/~hairer/prog/licence.txt\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+ * </p>\n+ *\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>Copyright (c) 2004, Ernst Hairer</td></tr>\n+ *\n+ * <tr><td>Redistribution and use in source and binary forms, with or\n+ * without modification, are permitted provided that the following\n+ * conditions are met:\n+ * <ul>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ *  <li>Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in the\n+ *      documentation and/or other materials provided with the distribution.</li>\n+ * </ul></td></tr>\n+ *\n+ * <tr><td><strong>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n+ * CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</strong></td></tr>\n+ * </table>\n+ *\n+ * @author E. Hairer and G. Wanner (fortran version)\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class GraggBulirschStoerIntegrator extends AdaptiveStepsizeIntegrator {\n+\n+  /** Integrator method name. */\n+  private static final String METHOD_NAME = \"Gragg-Bulirsch-Stoer\";\n+\n+  /** Simple constructor.\n+   * Build a Gragg-Bulirsch-Stoer integrator with the given step\n+   * bounds. All tuning parameters are set to their default\n+   * values. The default step handler does nothing.\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public GraggBulirschStoerIntegrator(final double minStep, final double maxStep,\n+                                      final double scalAbsoluteTolerance,\n+                                      final double scalRelativeTolerance) {\n+    super(METHOD_NAME, minStep, maxStep,\n+          scalAbsoluteTolerance, scalRelativeTolerance);\n+    denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());\n+    setStabilityCheck(true, -1, -1, -1);\n+    setStepsizeControl(-1, -1, -1, -1);\n+    setOrderControl(-1, -1, -1);\n+    setInterpolationControl(true, -1);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a Gragg-Bulirsch-Stoer integrator with the given step\n+   * bounds. All tuning parameters are set to their default\n+   * values. The default step handler does nothing.\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public GraggBulirschStoerIntegrator(final double minStep, final double maxStep,\n+                                      final double[] vecAbsoluteTolerance,\n+                                      final double[] vecRelativeTolerance) {\n+    super(METHOD_NAME, minStep, maxStep,\n+          vecAbsoluteTolerance, vecRelativeTolerance);\n+    denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());\n+    setStabilityCheck(true, -1, -1, -1);\n+    setStepsizeControl(-1, -1, -1, -1);\n+    setOrderControl(-1, -1, -1);\n+    setInterpolationControl(true, -1);\n+  }\n+\n+  /** Set the stability check controls.\n+   * <p>The stability check is performed on the first few iterations of\n+   * the extrapolation scheme. If this test fails, the step is rejected\n+   * and the stepsize is reduced.</p>\n+   * <p>By default, the test is performed, at most during two\n+   * iterations at each step, and at most once for each of these\n+   * iterations. The default stepsize reduction factor is 0.5.</p>\n+   * @param performTest if true, stability check will be performed,\n+     if false, the check will be skipped\n+   * @param maxIter maximal number of iterations for which checks are\n+   * performed (the number of iterations is reset to default if negative\n+   * or null)\n+   * @param maxChecks maximal number of checks for each iteration\n+   * (the number of checks is reset to default if negative or null)\n+   * @param stabilityReduction stepsize reduction factor in case of\n+   * failure (the factor is reset to default if lower than 0.0001 or\n+   * greater than 0.9999)\n+   */\n+  public void setStabilityCheck(final boolean performTest,\n+                                final int maxIter, final int maxChecks,\n+                                final double stabilityReduction) {\n+\n+    this.performTest = performTest;\n+    this.maxIter     = (maxIter   <= 0) ? 2 : maxIter;\n+    this.maxChecks   = (maxChecks <= 0) ? 1 : maxChecks;\n+\n+    if ((stabilityReduction < 0.0001) || (stabilityReduction > 0.9999)) {\n+      this.stabilityReduction = 0.5;\n+    } else {\n+      this.stabilityReduction = stabilityReduction;\n+    }\n+\n+  }\n+\n+  /** Set the step size control factors.\n+\n+   * <p>The new step size hNew is computed from the old one h by:\n+   * <pre>\n+   * hNew = h * stepControl2 / (err/stepControl1)^(1/(2k+1))\n+   * </pre>\n+   * where err is the scaled error and k the iteration number of the\n+   * extrapolation scheme (counting from 0). The default values are\n+   * 0.65 for stepControl1 and 0.94 for stepControl2.</p>\n+   * <p>The step size is subject to the restriction:\n+   * <pre>\n+   * stepControl3^(1/(2k+1))/stepControl4 <= hNew/h <= 1/stepControl3^(1/(2k+1))\n+   * </pre>\n+   * The default values are 0.02 for stepControl3 and 4.0 for\n+   * stepControl4.</p>\n+   * @param stepControl1 first stepsize control factor (the factor is\n+   * reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param stepControl2 second stepsize control factor (the factor\n+   * is reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param stepControl3 third stepsize control factor (the factor is\n+   * reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param stepControl4 fourth stepsize control factor (the factor\n+   * is reset to default if lower than 1.0001 or greater than 999.9)\n+   */\n+  public void setStepsizeControl(final double stepControl1, final double stepControl2,\n+                                 final double stepControl3, final double stepControl4) {\n+\n+    if ((stepControl1 < 0.0001) || (stepControl1 > 0.9999)) {\n+      this.stepControl1 = 0.65;\n+    } else {\n+      this.stepControl1 = stepControl1;\n+    }\n+\n+    if ((stepControl2 < 0.0001) || (stepControl2 > 0.9999)) {\n+      this.stepControl2 = 0.94;\n+    } else {\n+      this.stepControl2 = stepControl2;\n+    }\n+\n+    if ((stepControl3 < 0.0001) || (stepControl3 > 0.9999)) {\n+      this.stepControl3 = 0.02;\n+    } else {\n+      this.stepControl3 = stepControl3;\n+    }\n+\n+    if ((stepControl4 < 1.0001) || (stepControl4 > 999.9)) {\n+      this.stepControl4 = 4.0;\n+    } else {\n+      this.stepControl4 = stepControl4;\n+    }\n+\n+  }\n+\n+  /** Set the order control parameters.\n+   * <p>The Gragg-Bulirsch-Stoer method changes both the step size and\n+   * the order during integration, in order to minimize computation\n+   * cost. Each extrapolation step increases the order by 2, so the\n+   * maximal order that will be used is always even, it is twice the\n+   * maximal number of columns in the extrapolation table.</p>\n+   * <pre>\n+   * order is decreased if w(k-1) <= w(k)   * orderControl1\n+   * order is increased if w(k)   <= w(k-1) * orderControl2\n+   * </pre>\n+   * <p>where w is the table of work per unit step for each order\n+   * (number of function calls divided by the step length), and k is\n+   * the current order.</p>\n+   * <p>The default maximal order after construction is 18 (i.e. the\n+   * maximal number of columns is 9). The default values are 0.8 for\n+   * orderControl1 and 0.9 for orderControl2.</p>\n+   * @param maxOrder maximal order in the extrapolation table (the\n+   * maximal order is reset to default if order <= 6 or odd)\n+   * @param orderControl1 first order control factor (the factor is\n+   * reset to default if lower than 0.0001 or greater than 0.9999)\n+   * @param orderControl2 second order control factor (the factor\n+   * is reset to default if lower than 0.0001 or greater than 0.9999)\n+   */\n+  public void setOrderControl(final int maxOrder,\n+                              final double orderControl1, final double orderControl2) {\n+\n+    if ((maxOrder <= 6) || (maxOrder % 2 != 0)) {\n+      this.maxOrder = 18;\n+    }\n+\n+    if ((orderControl1 < 0.0001) || (orderControl1 > 0.9999)) {\n+      this.orderControl1 = 0.8;\n+    } else {\n+      this.orderControl1 = orderControl1;\n+    }\n+\n+    if ((orderControl2 < 0.0001) || (orderControl2 > 0.9999)) {\n+      this.orderControl2 = 0.9;\n+    } else {\n+      this.orderControl2 = orderControl2;\n+    }\n+\n+    // reinitialize the arrays\n+    initializeArrays();\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public void addStepHandler (final StepHandler handler) {\n+\n+    super.addStepHandler(handler);\n+    denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());\n+\n+    // reinitialize the arrays\n+    initializeArrays();\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public void addEventHandler(final EventHandler function,\n+                              final double maxCheckInterval,\n+                              final double convergence,\n+                              final int maxIterationCount) {\n+    super.addEventHandler(function, maxCheckInterval, convergence, maxIterationCount);\n+    denseOutput = requiresDenseOutput() || (! eventsHandlersManager.isEmpty());\n+\n+    // reinitialize the arrays\n+    initializeArrays();\n+\n+  }\n+\n+  /** Initialize the integrator internal arrays. */\n+  private void initializeArrays() {\n+\n+    final int size = maxOrder / 2;\n+\n+    if ((sequence == null) || (sequence.length != size)) {\n+      // all arrays should be reallocated with the right size\n+      sequence        = new int[size];\n+      costPerStep     = new int[size];\n+      coeff           = new double[size][];\n+      costPerTimeUnit = new double[size];\n+      optimalStep     = new double[size];\n+    }\n+\n+    if (denseOutput) {\n+      // step size sequence: 2, 6, 10, 14, ...\n+      for (int k = 0; k < size; ++k) {\n+        sequence[k] = 4 * k + 2;\n+      }\n+    } else {\n+      // step size sequence: 2, 4, 6, 8, ...\n+      for (int k = 0; k < size; ++k) {\n+        sequence[k] = 2 * (k + 1); \n+      }\n+    }\n+\n+    // initialize the order selection cost array\n+    // (number of function calls for each column of the extrapolation table)\n+    costPerStep[0] = sequence[0] + 1;\n+    for (int k = 1; k < size; ++k) {\n+      costPerStep[k] = costPerStep[k-1] + sequence[k];\n+    }\n+\n+    // initialize the extrapolation tables\n+    for (int k = 0; k < size; ++k) {\n+      coeff[k] = (k > 0) ? new double[k] : null;\n+      for (int l = 0; l < k; ++l) {\n+        final double ratio = ((double) sequence[k]) / sequence[k-l-1];\n+        coeff[k][l] = 1.0 / (ratio * ratio - 1.0);\n+      }\n+    }\n+\n+  }\n+\n+  /** Set the interpolation order control parameter.\n+   * The interpolation order for dense output is 2k - mudif + 1. The\n+   * default value for mudif is 4 and the interpolation error is used\n+   * in stepsize control by default.\n+\n+   * @param useInterpolationError if true, interpolation error is used\n+   * for stepsize control\n+   * @param mudif interpolation order control parameter (the parameter\n+   * is reset to default if <= 0 or >= 7)\n+   */\n+  public void setInterpolationControl(final boolean useInterpolationError,\n+                                      final int mudif) {\n+\n+    this.useInterpolationError = useInterpolationError;\n+\n+    if ((mudif <= 0) || (mudif >= 7)) {\n+      this.mudif = 4;\n+    } else {\n+      this.mudif = mudif;\n+    }\n+\n+  }\n+\n+  /** Update scaling array.\n+   * @param y1 first state vector to use for scaling\n+   * @param y2 second state vector to use for scaling\n+   * @param scale scaling array to update\n+   */\n+  private void rescale(final double[] y1, final double[] y2, final double[] scale) {\n+    if (vecAbsoluteTolerance == null) {\n+      for (int i = 0; i < scale.length; ++i) {\n+        final double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));\n+        scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * yi;\n+      }\n+    } else {\n+      for (int i = 0; i < scale.length; ++i) {\n+        final double yi = Math.max(Math.abs(y1[i]), Math.abs(y2[i]));\n+        scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yi;\n+      }\n+    }\n+  }\n+\n+  /** Perform integration over one step using substeps of a modified\n+   * midpoint method.\n+   * @param t0 initial time\n+   * @param y0 initial value of the state vector at t0\n+   * @param step global step\n+   * @param k iteration number (from 0 to sequence.length - 1)\n+   * @param scale scaling array\n+   * @param f placeholder where to put the state vector derivatives at each substep\n+   *          (element 0 already contains initial derivative)\n+   * @param yMiddle placeholder where to put the state vector at the middle of the step\n+   * @param yEnd placeholder where to put the state vector at the end\n+   * @param yTmp placeholder for one state vector\n+   * @return true if computation was done properly,\n+   *         false if stability check failed before end of computation\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  private boolean tryStep(final double t0, final double[] y0, final double step, final int k,\n+                          final double[] scale, final double[][] f,\n+                          final double[] yMiddle, final double[] yEnd,\n+                          final double[] yTmp)\n+    throws DerivativeException {\n+\n+    final int    n        = sequence[k];\n+    final double subStep  = step / n;\n+    final double subStep2 = 2 * subStep;\n+\n+    // first substep\n+    double t = t0 + subStep;\n+    for (int i = 0; i < y0.length; ++i) {\n+      yTmp[i] = y0[i];\n+      yEnd[i] = y0[i] + subStep * f[0][i];\n+    }\n+    computeDerivatives(t, yEnd, f[1]);\n+\n+    // other substeps\n+    for (int j = 1; j < n; ++j) {\n+\n+      if (2 * j == n) {\n+        // save the point at the middle of the step\n+        System.arraycopy(yEnd, 0, yMiddle, 0, y0.length);\n+      }\n+\n+      t += subStep;\n+      for (int i = 0; i < y0.length; ++i) {\n+        final double middle = yEnd[i];\n+        yEnd[i]       = yTmp[i] + subStep2 * f[j][i];\n+        yTmp[i]       = middle;\n+      }\n+\n+      computeDerivatives(t, yEnd, f[j+1]);\n+\n+      // stability check\n+      if (performTest && (j <= maxChecks) && (k < maxIter)) {\n+        double initialNorm = 0.0;\n+        for (int l = 0; l < y0.length; ++l) {\n+          final double ratio = f[0][l] / scale[l];\n+          initialNorm += ratio * ratio;\n+        }\n+        double deltaNorm = 0.0;\n+        for (int l = 0; l < y0.length; ++l) {\n+          final double ratio = (f[j+1][l] - f[0][l]) / scale[l];\n+          deltaNorm += ratio * ratio;\n+        }\n+        if (deltaNorm > 4 * Math.max(1.0e-15, initialNorm)) {\n+          return false;\n+        }\n+      }\n+\n+    }\n+\n+    // correction of the last substep (at t0 + step)\n+    for (int i = 0; i < y0.length; ++i) {\n+      yEnd[i] = 0.5 * (yTmp[i] + yEnd[i] + subStep * f[n][i]);\n+    }\n+\n+    return true;\n+\n+  }\n+\n+  /** Extrapolate a vector.\n+   * @param offset offset to use in the coefficients table\n+   * @param k index of the last updated point\n+   * @param diag working diagonal of the Aitken-Neville's\n+   * triangle, without the last element\n+   * @param last last element\n+   */\n+  private void extrapolate(final int offset, final int k,\n+                           final double[][] diag, final double[] last) {\n+\n+    // update the diagonal\n+    for (int j = 1; j < k; ++j) {\n+      for (int i = 0; i < last.length; ++i) {\n+        // Aitken-Neville's recursive formula\n+        diag[k-j-1][i] = diag[k-j][i] +\n+                         coeff[k+offset][j-1] * (diag[k-j][i] - diag[k-j-1][i]);\n+      }\n+    }\n+\n+    // update the last element\n+    for (int i = 0; i < last.length; ++i) {\n+      // Aitken-Neville's recursive formula\n+      last[i] = diag[0][i] + coeff[k+offset][k-1] * (diag[0][i] - last[i]);\n+    }\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public double integrate(final FirstOrderDifferentialEquations equations,\n+                          final double t0, final double[] y0, final double t, final double[] y)\n+  throws DerivativeException, IntegratorException {\n+\n+    sanityChecks(equations, t0, y0, t, y);\n+    setEquations(equations);\n+    resetEvaluations();\n+    final boolean forward = (t > t0);\n+\n+    // create some internal working arrays\n+    final double[] yDot0   = new double[y0.length];\n+    final double[] y1      = new double[y0.length];\n+    final double[] yTmp    = new double[y0.length];\n+    final double[] yTmpDot = new double[y0.length];\n+\n+    final double[][] diagonal = new double[sequence.length-1][];\n+    final double[][] y1Diag = new double[sequence.length-1][];\n+    for (int k = 0; k < sequence.length-1; ++k) {\n+      diagonal[k] = new double[y0.length];\n+      y1Diag[k] = new double[y0.length];\n+    }\n+\n+    final double[][][] fk  = new double[sequence.length][][];\n+    for (int k = 0; k < sequence.length; ++k) {\n+\n+      fk[k]    = new double[sequence[k] + 1][];\n+\n+      // all substeps start at the same point, so share the first array\n+      fk[k][0] = yDot0;\n+\n+      for (int l = 0; l < sequence[k]; ++l) {\n+        fk[k][l+1] = new double[y0.length];\n+      }\n+\n+    }\n+\n+    if (y != y0) {\n+      System.arraycopy(y0, 0, y, 0, y0.length);\n+    }\n+\n+    double[] yDot1      = null;\n+    double[][] yMidDots = null;\n+    if (denseOutput) {\n+      yDot1    = new double[y0.length];\n+      yMidDots = new double[1 + 2 * sequence.length][];\n+      for (int j = 0; j < yMidDots.length; ++j) {\n+        yMidDots[j] = new double[y0.length];\n+      }\n+    } else {\n+      yMidDots    = new double[1][];\n+      yMidDots[0] = new double[y0.length];\n+    }\n+\n+    // initial scaling\n+    final double[] scale = new double[y0.length];\n+    rescale(y, y, scale);\n+\n+    // initial order selection\n+    final double tol =\n+        (vecRelativeTolerance == null) ? scalRelativeTolerance : vecRelativeTolerance[0];\n+    final double log10R = Math.log(Math.max(1.0e-10, tol)) / Math.log(10.0);\n+    int targetIter = Math.max(1,\n+                              Math.min(sequence.length - 2,\n+                                       (int) Math.floor(0.5 - 0.6 * log10R)));\n+    // set up an interpolator sharing the integrator arrays\n+    AbstractStepInterpolator interpolator = null;\n+    if (denseOutput || (! eventsHandlersManager.isEmpty())) {\n+      interpolator = new GraggBulirschStoerStepInterpolator(y, yDot0,\n+                                                            y1, yDot1,\n+                                                            yMidDots, forward);\n+    } else {\n+      interpolator = new DummyStepInterpolator(y, forward);\n+    }\n+    interpolator.storeTime(t0);\n+\n+    stepStart = t0;\n+    double  hNew             = 0;\n+    double  maxError         = Double.MAX_VALUE;\n+    boolean previousRejected = false;\n+    boolean firstTime        = true;\n+    boolean newStep          = true;\n+    boolean lastStep         = false;\n+    boolean firstStepAlreadyComputed = false;\n+    for (StepHandler handler : stepHandlers) {\n+        handler.reset();\n+    }\n+    costPerTimeUnit[0] = 0;\n+    while (! lastStep) {\n+\n+      double error;\n+      boolean reject = false;\n+\n+      if (newStep) {\n+\n+        interpolator.shift();\n+\n+        // first evaluation, at the beginning of the step\n+        if (! firstStepAlreadyComputed) {\n+          computeDerivatives(stepStart, y, yDot0);\n+        }\n+\n+        if (firstTime) {\n+\n+          hNew = initializeStep(equations, forward,\n+                                2 * targetIter + 1, scale,\n+                                stepStart, y, yDot0, yTmp, yTmpDot);\n+\n+          if (! forward) {\n+            hNew = -hNew;\n+          }\n+\n+        }\n+\n+        newStep = false;\n+\n+      }\n+\n+      stepSize = hNew;\n+\n+      // step adjustment near bounds\n+      if ((forward && (stepStart + stepSize > t)) ||\n+          ((! forward) && (stepStart + stepSize < t))) {\n+        stepSize = t - stepStart;\n+      }\n+      final double nextT = stepStart + stepSize;\n+      lastStep = forward ? (nextT >= t) : (nextT <= t);\n+\n+      // iterate over several substep sizes\n+      int k = -1;\n+      for (boolean loop = true; loop; ) {\n+\n+        ++k;\n+\n+        // modified midpoint integration with the current substep\n+        if ( ! tryStep(stepStart, y, stepSize, k, scale, fk[k],\n+                       (k == 0) ? yMidDots[0] : diagonal[k-1],\n+                       (k == 0) ? y1 : y1Diag[k-1],\n+                       yTmp)) {\n+\n+          // the stability check failed, we reduce the global step\n+          hNew   = Math.abs(filterStep(stepSize * stabilityReduction, forward, false));\n+          reject = true;\n+          loop   = false;\n+\n+        } else {\n+\n+          // the substep was computed successfully\n+          if (k > 0) {\n+\n+            // extrapolate the state at the end of the step\n+            // using last iteration data\n+            extrapolate(0, k, y1Diag, y1);\n+            rescale(y, y1, scale);\n+\n+            // estimate the error at the end of the step.\n+            error = 0;\n+            for (int j = 0; j < y0.length; ++j) {\n+              final double e = Math.abs(y1[j] - y1Diag[0][j]) / scale[j];\n+              error += e * e;\n+            }\n+            error = Math.sqrt(error / y0.length);\n+\n+            if ((error > 1.0e15) || ((k > 1) && (error > maxError))) {\n+              // error is too big, we reduce the global step\n+              hNew   = Math.abs(filterStep(stepSize * stabilityReduction, forward, false));\n+              reject = true;\n+              loop   = false;\n+            } else {\n+\n+              maxError = Math.max(4 * error, 1.0);\n+\n+              // compute optimal stepsize for this order\n+              final double exp = 1.0 / (2 * k + 1);\n+              double fac = stepControl2 / Math.pow(error / stepControl1, exp);\n+              final double pow = Math.pow(stepControl3, exp);\n+              fac = Math.max(pow / stepControl4, Math.min(1 / pow, fac));\n+              optimalStep[k]     = Math.abs(filterStep(stepSize * fac, forward, true));\n+              costPerTimeUnit[k] = costPerStep[k] / optimalStep[k];\n+\n+              // check convergence\n+              switch (k - targetIter) {\n+\n+              case -1 :\n+                if ((targetIter > 1) && ! previousRejected) {\n+\n+                  // check if we can stop iterations now\n+                  if (error <= 1.0) {\n+                    // convergence have been reached just before targetIter\n+                    loop = false;\n+                  } else {\n+                    // estimate if there is a chance convergence will\n+                    // be reached on next iteration, using the\n+                    // asymptotic evolution of error\n+                    final double ratio = ((double) sequence [k] * sequence[k+1]) /\n+                                         (sequence[0] * sequence[0]);\n+                    if (error > ratio * ratio) {\n+                      // we don't expect to converge on next iteration\n+                      // we reject the step immediately and reduce order\n+                      reject = true;\n+                      loop   = false;\n+                      targetIter = k;\n+                      if ((targetIter > 1) &&\n+                          (costPerTimeUnit[targetIter-1] <\n+                           orderControl1 * costPerTimeUnit[targetIter])) {\n+                        --targetIter;\n+                      }\n+                      hNew = optimalStep[targetIter];\n+                    }\n+                  }\n+                }\n+                break;\n+\n+              case 0:\n+                if (error <= 1.0) {\n+                  // convergence has been reached exactly at targetIter\n+                  loop = false;\n+                } else {\n+                  // estimate if there is a chance convergence will\n+                  // be reached on next iteration, using the\n+                  // asymptotic evolution of error\n+                  final double ratio = ((double) sequence[k+1]) / sequence[0];\n+                  if (error > ratio * ratio) {\n+                    // we don't expect to converge on next iteration\n+                    // we reject the step immediately\n+                    reject = true;\n+                    loop = false;\n+                    if ((targetIter > 1) &&\n+                        (costPerTimeUnit[targetIter-1] <\n+                         orderControl1 * costPerTimeUnit[targetIter])) {\n+                      --targetIter;\n+                    }\n+                    hNew = optimalStep[targetIter];\n+                  }\n+                }\n+                break;\n+\n+              case 1 :\n+                if (error > 1.0) {\n+                  reject = true;\n+                  if ((targetIter > 1) &&\n+                      (costPerTimeUnit[targetIter-1] <\n+                       orderControl1 * costPerTimeUnit[targetIter])) {\n+                    --targetIter;\n+                  }\n+                  hNew = optimalStep[targetIter];\n+                }\n+                loop = false;\n+                break;\n+\n+              default :\n+                if ((firstTime || lastStep) && (error <= 1.0)) {\n+                  loop = false;\n+                }\n+                break;\n+\n+              }\n+\n+            }\n+          }\n+        }\n+      }\n+\n+      // dense output handling\n+      double hInt = getMaxStep();\n+      if (denseOutput && ! reject) {\n+\n+        // extrapolate state at middle point of the step\n+        for (int j = 1; j <= k; ++j) {\n+          extrapolate(0, j, diagonal, yMidDots[0]);\n+        }\n+\n+        // derivative at end of step\n+        computeDerivatives(stepStart + stepSize, y1, yDot1);\n+\n+        final int mu = 2 * k - mudif + 3;\n+\n+        for (int l = 0; l < mu; ++l) {\n+\n+          // derivative at middle point of the step\n+          final int l2 = l / 2;\n+          double factor = Math.pow(0.5 * sequence[l2], l);\n+          int middleIndex = fk[l2].length / 2;\n+          for (int i = 0; i < y0.length; ++i) {\n+            yMidDots[l+1][i] = factor * fk[l2][middleIndex + l][i];\n+          }\n+          for (int j = 1; j <= k - l2; ++j) {\n+            factor = Math.pow(0.5 * sequence[j + l2], l);\n+            middleIndex = fk[l2+j].length / 2;\n+            for (int i = 0; i < y0.length; ++i) {\n+              diagonal[j-1][i] = factor * fk[l2+j][middleIndex+l][i];\n+            }\n+            extrapolate(l2, j, diagonal, yMidDots[l+1]);\n+          }\n+          for (int i = 0; i < y0.length; ++i) {\n+            yMidDots[l+1][i] *= stepSize;\n+          }\n+\n+          // compute centered differences to evaluate next derivatives\n+          for (int j = (l + 1) / 2; j <= k; ++j) {\n+            for (int m = fk[j].length - 1; m >= 2 * (l + 1); --m) {\n+              for (int i = 0; i < y0.length; ++i) {\n+                fk[j][m][i] -= fk[j][m-2][i];\n+              }\n+            }\n+          }\n+\n+        }\n+\n+        if (mu >= 0) {\n+\n+          // estimate the dense output coefficients\n+          final GraggBulirschStoerStepInterpolator gbsInterpolator\n+            = (GraggBulirschStoerStepInterpolator) interpolator;\n+          gbsInterpolator.computeCoefficients(mu, stepSize);\n+\n+          if (useInterpolationError) {\n+            // use the interpolation error to limit stepsize\n+            final double interpError = gbsInterpolator.estimateError(scale);\n+            hInt = Math.abs(stepSize / Math.max(Math.pow(interpError, 1.0 / (mu+4)),\n+                                                0.01));\n+            if (interpError > 10.0) {\n+              hNew = hInt;\n+              reject = true;\n+            }\n+          }\n+\n+          // Discrete events handling\n+          if (!reject) {\n+            interpolator.storeTime(stepStart + stepSize);\n+            if (eventsHandlersManager.evaluateStep(interpolator)) {\n+                final double dt = eventsHandlersManager.getEventTime() - stepStart;\n+                if (Math.abs(dt) > Math.ulp(stepStart)) {\n+                    // reject the step to match exactly the next switch time\n+                    hNew = Math.abs(dt);\n+                    reject = true;\n+                }\n+            }\n+          }\n+\n+        }\n+\n+        if (!reject) {\n+          // we will reuse the slope for the beginning of next step\n+          firstStepAlreadyComputed = true;\n+          System.arraycopy(yDot1, 0, yDot0, 0, y0.length);\n+        }\n+\n+      }\n+\n+      if (! reject) {\n+\n+        // store end of step state\n+        final double nextStep = stepStart + stepSize;\n+        System.arraycopy(y1, 0, y, 0, y0.length);\n+\n+        eventsHandlersManager.stepAccepted(nextStep, y);\n+        if (eventsHandlersManager.stop()) {\n+          lastStep = true;\n+        }\n+\n+        // provide the step data to the step handler\n+        interpolator.storeTime(nextStep);\n+        for (StepHandler handler : stepHandlers) {\n+            handler.handleStep(interpolator, lastStep);\n+        }\n+        stepStart = nextStep;\n+\n+        if (eventsHandlersManager.reset(stepStart, y) && ! lastStep) {\n+          // some switching function has triggered changes that\n+          // invalidate the derivatives, we need to recompute them\n+          firstStepAlreadyComputed = false;\n+        }\n+\n+        int optimalIter;\n+        if (k == 1) {\n+          optimalIter = 2;\n+          if (previousRejected) {\n+            optimalIter = 1;\n+          }\n+        } else if (k <= targetIter) {\n+          optimalIter = k;\n+          if (costPerTimeUnit[k-1] < orderControl1 * costPerTimeUnit[k]) {\n+            optimalIter = k-1;\n+          } else if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1]) {\n+            optimalIter = Math.min(k+1, sequence.length - 2);\n+          }\n+        } else {\n+          optimalIter = k - 1;\n+          if ((k > 2) &&\n+              (costPerTimeUnit[k-2] < orderControl1 * costPerTimeUnit[k-1])) {\n+            optimalIter = k - 2;\n+          }\n+          if (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[optimalIter]) {\n+            optimalIter = Math.min(k, sequence.length - 2);\n+          }\n+        }\n+\n+        if (previousRejected) {\n+          // after a rejected step neither order nor stepsize\n+          // should increase\n+          targetIter = Math.min(optimalIter, k);\n+          hNew = Math.min(Math.abs(stepSize), optimalStep[targetIter]);\n+        } else {\n+          // stepsize control\n+          if (optimalIter <= k) {\n+            hNew = optimalStep[optimalIter];\n+          } else {\n+            if ((k < targetIter) &&\n+                (costPerTimeUnit[k] < orderControl2 * costPerTimeUnit[k-1])) {\n+              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter+1] / costPerStep[k],\n+                               forward, false);\n+            } else {\n+              hNew = filterStep(optimalStep[k] * costPerStep[optimalIter] / costPerStep[k],\n+                                forward, false);\n+            }\n+          }\n+\n+          targetIter = optimalIter;\n+\n+        }\n+\n+        newStep = true;\n+\n+      }\n+\n+      hNew = Math.min(hNew, hInt);\n+      if (! forward) {\n+        hNew = -hNew;\n+      }\n+\n+      firstTime = false;\n+\n+      if (reject) {\n+        lastStep = false;\n+        previousRejected = true;\n+      } else {\n+        previousRejected = false;\n+      }\n+\n+    }\n+\n+    return stepStart;\n+\n+  }\n+\n+  /** maximal order. */\n+  private int maxOrder;\n+\n+  /** step size sequence. */\n+  private int[] sequence;\n+\n+  /** overall cost of applying step reduction up to iteration k+1,\n+   *  in number of calls.\n+   */\n+  private int[] costPerStep;\n+\n+  /** cost per unit step. */\n+  private double[] costPerTimeUnit;\n+\n+  /** optimal steps for each order. */\n+  private double[] optimalStep;\n+\n+  /** extrapolation coefficients. */\n+  private double[][] coeff;\n+\n+  /** stability check enabling parameter. */\n+  private boolean performTest;\n+\n+  /** maximal number of checks for each iteration. */\n+  private int maxChecks;\n+\n+  /** maximal number of iterations for which checks are performed. */\n+  private int maxIter;\n+\n+  /** stepsize reduction factor in case of stability check failure. */\n+  private double stabilityReduction;\n+\n+  /** first stepsize control factor. */\n+  private double stepControl1;\n+\n+  /** second stepsize control factor. */\n+  private double stepControl2;\n+\n+  /** third stepsize control factor. */\n+  private double stepControl3;\n+\n+  /** fourth stepsize control factor. */\n+  private double stepControl4;\n+\n+  /** first order control factor. */\n+  private double orderControl1;\n+\n+  /** second order control factor. */\n+  private double orderControl2;\n+\n+  /** dense outpute required. */\n+  private boolean denseOutput;\n+\n+  /** use interpolation error in stepsize control. */\n+  private boolean useInterpolationError;\n+\n+  /** interpolation order control parameter. */\n+  private int mudif;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/GraggBulirschStoerStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements an interpolator for the Gragg-Bulirsch-Stoer\n+ * integrator.\n+ *\n+ * <p>This interpolator compute dense output inside the last step\n+ * produced by a Gragg-Bulirsch-Stoer integrator.</p>\n+ *\n+ * <p>\n+ * This implementation is basically a reimplementation in Java of the\n+ * <a\n+ * href=\"http://www.unige.ch/math/folks/hairer/prog/nonstiff/odex.f\">odex</a>\n+ * fortran code by E. Hairer and G. Wanner. The redistribution policy\n+ * for this code is available <a\n+ * href=\"http://www.unige.ch/~hairer/prog/licence.txt\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+ * </p>\n+ *\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>Copyright (c) 2004, Ernst Hairer</td></tr>\n+ *\n+ * <tr><td>Redistribution and use in source and binary forms, with or\n+ * without modification, are permitted provided that the following\n+ * conditions are met:\n+ * <ul>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ *  <li>Redistributions in binary form must reproduce the above copyright\n+ *      notice, this list of conditions and the following disclaimer in the\n+ *      documentation and/or other materials provided with the distribution.</li>\n+ * </ul></td></tr>\n+ *\n+ * <tr><td><strong>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n+ * CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+ * FOR A  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR\n+ * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</strong></td></tr>\n+ * </table>\n+ *\n+ * @see GraggBulirschStoerIntegrator\n+ * @version $Revision$ $Date$\n+ * @author E. Hairer and G. Wanner (fortran version)\n+ * @since 1.2\n+ */\n+\n+class GraggBulirschStoerStepInterpolator\n+  extends AbstractStepInterpolator {\n+\n+  /** Slope at the beginning of the step. */\n+  private double[] y0Dot;\n+\n+  /** State at the end of the step. */\n+  private double[] y1;\n+\n+  /** Slope at the end of the step. */\n+  private double[] y1Dot;\n+\n+  /** Derivatives at the middle of the step.\n+   * element 0 is state at midpoint, element 1 is first derivative ...\n+   */\n+  private double[][] yMidDots;\n+\n+  /** Interpolation polynoms. */\n+  private double[][] polynoms;\n+\n+  /** Error coefficients for the interpolation. */\n+  private double[] errfac;\n+\n+  /** Degree of the interpolation polynoms. */\n+  private int currentDegree;\n+\n+  /** Reallocate the internal tables.\n+   * Reallocate the internal tables in order to be able to handle\n+   * interpolation polynoms up to the given degree\n+   * @param maxDegree maximal degree to handle\n+   */\n+  private void resetTables(final int maxDegree) {\n+\n+    if (maxDegree < 0) {\n+      polynoms      = null;\n+      errfac        = null;\n+      currentDegree = -1;\n+    } else {\n+\n+      final double[][] newPols = new double[maxDegree + 1][];\n+      if (polynoms != null) {\n+        System.arraycopy(polynoms, 0, newPols, 0, polynoms.length);\n+        for (int i = polynoms.length; i < newPols.length; ++i) {\n+          newPols[i] = new double[currentState.length];\n+        }\n+      } else {\n+        for (int i = 0; i < newPols.length; ++i) {\n+          newPols[i] = new double[currentState.length];\n+        }\n+      }\n+      polynoms = newPols;\n+\n+      // initialize the error factors array for interpolation\n+      if (maxDegree <= 4) {\n+        errfac = null;\n+      } else {\n+        errfac = new double[maxDegree - 4];\n+        for (int i = 0; i < errfac.length; ++i) {\n+          final int ip5 = i + 5;\n+          errfac[i] = 1.0 / (ip5 * ip5);\n+          final double e = 0.5 * Math.sqrt (((double) (i + 1)) / ip5);\n+          for (int j = 0; j <= i; ++j) {\n+            errfac[i] *= e / (j + 1);\n+          }\n+        }\n+      }\n+\n+      currentDegree = 0;\n+\n+    }\n+\n+  }\n+\n+  /** Simple constructor.\n+   * This constructor should not be used directly, it is only intended\n+   * for the serialization process.\n+   */\n+  public GraggBulirschStoerStepInterpolator() {\n+    y0Dot    = null;\n+    y1       = null;\n+    y1Dot    = null;\n+    yMidDots = null;\n+    resetTables(-1);\n+  }\n+\n+  /** Simple constructor.\n+   * @param y reference to the integrator array holding the current state\n+   * @param y0Dot reference to the integrator array holding the slope\n+   * at the beginning of the step\n+   * @param y1 reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param y1Dot reference to the integrator array holding the slope\n+   * at theend of the step\n+   * @param yMidDots reference to the integrator array holding the\n+   * derivatives at the middle point of the step\n+   * @param forward integration direction indicator\n+   */\n+  public GraggBulirschStoerStepInterpolator(final double[] y, final double[] y0Dot,\n+                                            final double[] y1, final double[] y1Dot,\n+                                            final double[][] yMidDots,\n+                                            final boolean forward) {\n+\n+    super(y, forward);\n+    this.y0Dot    = y0Dot;\n+    this.y1       = y1;\n+    this.y1Dot    = y1Dot;\n+    this.yMidDots = yMidDots;\n+\n+    resetTables(yMidDots.length + 4);\n+\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public GraggBulirschStoerStepInterpolator\n+    (final GraggBulirschStoerStepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    final int dimension = currentState.length;\n+\n+    // the interpolator has been finalized,\n+    // the following arrays are not needed anymore\n+    y0Dot    = null;\n+    y1       = null;\n+    y1Dot    = null;\n+    yMidDots = null;\n+\n+    // copy the interpolation polynoms (up to the current degree only)\n+    if (interpolator.polynoms == null) {\n+      polynoms = null;\n+      currentDegree = -1;\n+    } else {\n+      resetTables(interpolator.currentDegree);\n+      for (int i = 0; i < polynoms.length; ++i) {\n+        polynoms[i] = new double[dimension];\n+        System.arraycopy(interpolator.polynoms[i], 0,\n+                         polynoms[i], 0, dimension);\n+      }\n+      currentDegree = interpolator.currentDegree;\n+    }\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  protected StepInterpolator doCopy() {\n+    return new GraggBulirschStoerStepInterpolator(this);\n+  }\n+\n+\n+  /** Compute the interpolation coefficients for dense output.\n+   * @param mu degree of the interpolation polynomial\n+   * @param h current step\n+   */\n+  public void computeCoefficients(final int mu, final double h) {\n+\n+    if ((polynoms == null) || (polynoms.length <= (mu + 4))) {\n+      resetTables(mu + 4);\n+    }\n+\n+    currentDegree = mu + 4;\n+\n+    for (int i = 0; i < currentState.length; ++i) {\n+\n+      final double yp0   = h * y0Dot[i];\n+      final double yp1   = h * y1Dot[i];\n+      final double ydiff = y1[i] - currentState[i];\n+      final double aspl  = ydiff - yp1;\n+      final double bspl  = yp0 - ydiff;\n+\n+      polynoms[0][i] = currentState[i];\n+      polynoms[1][i] = ydiff;\n+      polynoms[2][i] = aspl;\n+      polynoms[3][i] = bspl;\n+\n+      if (mu < 0) {\n+        return;\n+      }\n+\n+      // compute the remaining coefficients\n+      final double ph0 = 0.5 * (currentState[i] + y1[i]) + 0.125 * (aspl + bspl);\n+      polynoms[4][i] = 16 * (yMidDots[0][i] - ph0);\n+\n+      if (mu > 0) {\n+        final double ph1 = ydiff + 0.25 * (aspl - bspl);\n+        polynoms[5][i] = 16 * (yMidDots[1][i] - ph1);\n+\n+        if (mu > 1) {\n+          final double ph2 = yp1 - yp0;\n+          polynoms[6][i] = 16 * (yMidDots[2][i] - ph2 + polynoms[4][i]);\n+\n+          if (mu > 2) {\n+            final double ph3 = 6 * (bspl - aspl);\n+            polynoms[7][i] = 16 * (yMidDots[3][i] - ph3 + 3 * polynoms[5][i]);\n+\n+            for (int j = 4; j <= mu; ++j) {\n+              final double fac1 = 0.5 * j * (j - 1);\n+              final double fac2 = 2 * fac1 * (j - 2) * (j - 3);\n+              polynoms[j+4][i] =\n+                  16 * (yMidDots[j][i] + fac1 * polynoms[j+2][i] - fac2 * polynoms[j][i]);\n+            }\n+\n+          }\n+        }\n+      }\n+    }\n+\n+  }\n+\n+  /** Estimate interpolation error.\n+   * @param scale scaling array\n+   * @return estimate of the interpolation error\n+   */\n+  public double estimateError(final double[] scale) {\n+    double error = 0;\n+    if (currentDegree >= 5) {\n+      for (int i = 0; i < currentState.length; ++i) {\n+        final double e = polynoms[currentDegree][i] / scale[i];\n+        error += e * e;\n+      }\n+      error = Math.sqrt(error / currentState.length) * errfac[currentDegree-5];\n+    }\n+    return error;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  protected void computeInterpolatedStateAndDerivatives(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    final int dimension = currentState.length;\n+\n+    final double oneMinusTheta = 1.0 - theta;\n+    final double theta05       = theta - 0.5;\n+    final double tOmT          = theta * oneMinusTheta;\n+    final double t4            = tOmT * tOmT;\n+    final double t4Dot         = 2 * tOmT * (1 - 2 * theta);\n+    final double dot1          = 1.0 / h;\n+    final double dot2          = theta * (2 - 3 * theta) / h;\n+    final double dot3          = ((3 * theta - 4) * theta + 1) / h;\n+\n+    for (int i = 0; i < dimension; ++i) {\n+\n+        final double p0 = polynoms[0][i];\n+        final double p1 = polynoms[1][i];\n+        final double p2 = polynoms[2][i];\n+        final double p3 = polynoms[3][i];\n+        interpolatedState[i] = p0 + theta * (p1 + oneMinusTheta * (p2 * theta + p3 * oneMinusTheta));\n+        interpolatedDerivatives[i] = dot1 * p1 + dot2 * p2 + dot3 * p3;\n+\n+        if (currentDegree > 3) {\n+            double cDot = 0;\n+            double c = polynoms[currentDegree][i];\n+            for (int j = currentDegree - 1; j > 3; --j) {\n+                final double d = 1.0 / (j - 3);\n+                cDot = d * (theta05 * cDot + c);\n+                c = polynoms[j][i] + c * d * theta05;\n+            }\n+            interpolatedState[i]       += t4 * c;\n+            interpolatedDerivatives[i] += (t4 * cDot + t4Dot * c) / h;\n+        }\n+\n+    }\n+\n+    if (h == 0) {\n+        // in this degenerated case, the previous computation leads to NaN for derivatives\n+        // we fix this by using the derivatives at midpoint\n+        System.arraycopy(yMidDots[1], 0, interpolatedDerivatives, 0, dimension);\n+    }\n+\n+  }\n+    \n+  /** {@inheritDoc} */\n+  @Override\n+  public void writeExternal(final ObjectOutput out)\n+    throws IOException {\n+\n+    final int dimension = (currentState == null) ? -1 : currentState.length;\n+\n+    // save the state of the base class\n+    writeBaseExternal(out);\n+\n+    // save the local attributes (but not the temporary vectors)\n+    out.writeInt(currentDegree);\n+    for (int k = 0; k <= currentDegree; ++k) {\n+      for (int l = 0; l < dimension; ++l) {\n+        out.writeDouble(polynoms[k][l]);\n+      }\n+    }\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public void readExternal(final ObjectInput in)\n+    throws IOException {\n+\n+    // read the base class \n+    final double t = readBaseExternal(in);\n+    final int dimension = (currentState == null) ? -1 : currentState.length;\n+\n+    // read the local attributes\n+    final int degree = in.readInt();\n+    resetTables(degree);\n+    currentDegree = degree;\n+\n+    for (int k = 0; k <= currentDegree; ++k) {\n+      for (int l = 0; l < dimension; ++l) {\n+        polynoms[k][l] = in.readDouble();\n+      }\n+    }\n+\n+    // we can now set the interpolated time and state\n+    setInterpolatedTime(t);\n+\n+  }\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = 7320613236731409847L;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54Integrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+\n+/**\n+ * This class implements the 5(4) Higham and Hall integrator for\n+ * Ordinary Differential Equations.\n+ *\n+ * <p>This integrator is an embedded Runge-Kutta integrator\n+ * of order 5(4) used in local extrapolation mode (i.e. the solution\n+ * is computed using the high order formula) with stepsize control\n+ * (and automatic step initialization) and continuous output. This\n+ * method uses 7 functions evaluations per step.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class HighamHall54Integrator extends EmbeddedRungeKuttaIntegrator {\n+\n+  /** Integrator method name. */\n+  private static final String METHOD_NAME = \"Higham-Hall 5(4)\";\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] staticC = {\n+    2.0/9.0, 1.0/3.0, 1.0/2.0, 3.0/5.0, 1.0, 1.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] staticA = {\n+    {2.0/9.0},\n+    {1.0/12.0, 1.0/4.0},\n+    {1.0/8.0, 0.0, 3.0/8.0},\n+    {91.0/500.0, -27.0/100.0, 78.0/125.0, 8.0/125.0},\n+    {-11.0/20.0, 27.0/20.0, 12.0/5.0, -36.0/5.0, 5.0},\n+    {1.0/12.0, 0.0, 27.0/32.0, -4.0/3.0, 125.0/96.0, 5.0/48.0}\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] staticB = {\n+    1.0/12.0, 0.0, 27.0/32.0, -4.0/3.0, 125.0/96.0, 5.0/48.0, 0.0\n+  };\n+\n+  /** Error weights Butcher array. */\n+  private static final double[] staticE = {\n+    -1.0/20.0, 0.0, 81.0/160.0, -6.0/5.0, 25.0/32.0, 1.0/16.0, -1.0/10.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a fifth order Higham and Hall integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param scalAbsoluteTolerance allowed absolute error\n+   * @param scalRelativeTolerance allowed relative error\n+   */\n+  public HighamHall54Integrator(final double minStep, final double maxStep,\n+                                final double scalAbsoluteTolerance,\n+                                final double scalRelativeTolerance) {\n+    super(METHOD_NAME, false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),\n+          minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n+  }\n+\n+  /** Simple constructor.\n+   * Build a fifth order Higham and Hall integrator with the given step bounds\n+   * @param minStep minimal step (must be positive even for backward\n+   * integration), the last step can be smaller than this\n+   * @param maxStep maximal step (must be positive even for backward\n+   * integration)\n+   * @param vecAbsoluteTolerance allowed absolute error\n+   * @param vecRelativeTolerance allowed relative error\n+   */\n+  public HighamHall54Integrator(final double minStep, final double maxStep,\n+                                final double[] vecAbsoluteTolerance,\n+                                final double[] vecRelativeTolerance) {\n+    super(METHOD_NAME, false, staticC, staticA, staticB, new HighamHall54StepInterpolator(),\n+          minStep, maxStep, vecAbsoluteTolerance, vecRelativeTolerance);\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public int getOrder() {\n+    return 5;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  protected double estimateError(final double[][] yDotK,\n+                                 final double[] y0, final double[] y1,\n+                                 final double h) {\n+\n+    double error = 0;\n+\n+    for (int j = 0; j < y0.length; ++j) {\n+      double errSum = staticE[0] * yDotK[0][j];\n+      for (int l = 1; l < staticE.length; ++l) {\n+        errSum += staticE[l] * yDotK[l][j];\n+      }\n+\n+      final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n+      final double tol = (vecAbsoluteTolerance == null) ?\n+                         (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n+                         (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n+      final double ratio  = h * errSum / tol;\n+      error += ratio * ratio;\n+\n+    }\n+\n+    return Math.sqrt(error / y0.length);\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/HighamHall54StepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class represents an interpolator over the last step during an\n+ * ODE integration for the 5(4) Higham and Hall integrator.\n+ *\n+ * @see HighamHall54Integrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class HighamHall54StepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link EmbeddedRungeKuttaIntegrator} uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public HighamHall54StepInterpolator() {\n+    super();\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public HighamHall54StepInterpolator(final HighamHall54StepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  protected StepInterpolator doCopy() {\n+    return new HighamHall54StepInterpolator(this);\n+  }\n+\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  protected void computeInterpolatedStateAndDerivatives(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    final double theta2 = theta * theta;\n+\n+    final double b0 = h * (-1.0/12.0 + theta * (1.0 + theta * (-15.0/4.0 + theta * (16.0/3.0 + theta * -5.0/2.0))));\n+    final double b2 = h * (-27.0/32.0 + theta2 * (459.0/32.0 + theta * (-243.0/8.0 + theta * 135.0/8.0)));\n+    final double b3 = h * (4.0/3.0 + theta2 * (-22.0 + theta * (152.0/3.0  + theta * -30.0)));\n+    final double b4 = h * (-125.0/96.0 + theta2 * (375.0/32.0 + theta * (-625.0/24.0 + theta * 125.0/8.0)));\n+    final double b5 = h * (-5.0/48.0 + theta2 * (-5.0/16.0 + theta * 5.0/12.0));\n+    final double bDot0 = 1 + theta * (-15.0/2.0 + theta * (16.0 - 10.0 * theta));\n+    final double bDot2 = theta * (459.0/16.0 + theta * (-729.0/8.0 + 135.0/2.0 * theta));\n+    final double bDot3 = theta * (-44.0 + theta * (152.0 - 120.0 * theta));\n+    final double bDot4 = theta * (375.0/16.0 + theta * (-625.0/8.0 + 125.0/2.0 * theta));\n+    final double bDot5 = theta * 5.0/8.0 * (2 * theta - 1);\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+        final double yDot0 = yDotK[0][i];\n+        final double yDot2 = yDotK[2][i];\n+        final double yDot3 = yDotK[3][i];\n+        final double yDot4 = yDotK[4][i];\n+        final double yDot5 = yDotK[5][i];\n+        interpolatedState[i] =\n+            currentState[i] + b0 * yDot0 + b2 * yDot2 + b3 * yDot3 + b4 * yDot4 + b5 * yDot5;\n+        interpolatedDerivatives[i] =\n+            bDot0 * yDot0 + bDot2 * yDot2 + bDot3 * yDot3 + bDot4 * yDot4 + bDot5 * yDot5;\n+    }\n+\n+  }\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -3583240427587318654L;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+\n+/**\n+ * This class implements a second order Runge-Kutta integrator for\n+ * Ordinary Differential Equations.\n+ *\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |  0    0\n+ *   1/2 | 1/2   0\n+ *       |----------\n+ *       |  0    1\n+ * </pre>\n+ * </p>\n+ *\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class MidpointIntegrator extends RungeKuttaIntegrator {\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] c = {\n+    1.0 / 2.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] a = {\n+    { 1.0 / 2.0 }\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] b = {\n+    0.0, 1.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a midpoint integrator with the given step.\n+   * @param step integration step\n+   */\n+  public MidpointIntegrator(final double step) {\n+    super(\"midpoint\", c, a, b, new MidpointStepInterpolator(), step);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/MidpointStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements a step interpolator for second order\n+ * Runge-Kutta integrator.\n+ *\n+ * <p>This interpolator computes dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+ *\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h) + (1-theta) h [theta y'_1 - (1+theta) y'_2]\n+ * </pre>\n+ *\n+ * where theta belongs to [0 ; 1] and where y'_1 and y'_2 are the two\n+ * evaluations of the derivatives already computed during the\n+ * step.</p>\n+ *\n+ * @see MidpointIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class MidpointStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+    \n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public MidpointStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public MidpointStepInterpolator(final MidpointStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  protected StepInterpolator doCopy() {\n+    return new MidpointStepInterpolator(this);\n+  }\n+\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  protected void computeInterpolatedStateAndDerivatives(final double theta,\n+                                          final double oneMinusThetaH)\n+    throws DerivativeException {\n+\n+    final double coeff1    = oneMinusThetaH * theta;\n+    final double coeff2    = oneMinusThetaH * (1.0 + theta);\n+    final double coeffDot2 = 2 * theta;\n+    final double coeffDot1 = 1 - coeffDot2;\n+\n+    for (int i = 0; i < interpolatedState.length; ++i) {\n+      final double yDot1 = yDotK[0][i];\n+      final double yDot2 = yDotK[1][i];\n+      interpolatedState[i] = currentState[i] + coeff1 * yDot1 - coeff2 * yDot2;\n+      interpolatedDerivatives[i] = coeffDot1 * yDot1 + coeffDot2 * yDot2;\n+    }\n+\n+  }\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -865524111506042509L;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+\n+import org.apache.commons.math.ode.AbstractIntegrator;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math.ode.IntegratorException;\n+import org.apache.commons.math.ode.events.CombinedEventsManager;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.DummyStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepHandler;\n+\n+/**\n+ * This class implements the common part of all fixed step Runge-Kutta\n+ * integrators for Ordinary Differential Equations.\n+ *\n+ * <p>These methods are explicit Runge-Kutta methods, their Butcher\n+ * arrays are as follows :\n+ * <pre>\n+ *    0  |\n+ *   c2  | a21\n+ *   c3  | a31  a32\n+ *   ... |        ...\n+ *   cs  | as1  as2  ...  ass-1\n+ *       |--------------------------\n+ *       |  b1   b2  ...   bs-1  bs\n+ * </pre>\n+ * </p>\n+ *\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+ * @see MidpointIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public abstract class RungeKuttaIntegrator extends AbstractIntegrator {\n+\n+  /** Simple constructor.\n+   * Build a Runge-Kutta integrator with the given\n+   * step. The default step handler does nothing.\n+   * @param name name of the method\n+   * @param c time steps from Butcher array (without the first zero)\n+   * @param a internal weights from Butcher array (without the first empty row)\n+   * @param b propagation weights for the high order method from Butcher array\n+   * @param prototype prototype of the step interpolator to use\n+   * @param step integration step\n+   */\n+  protected RungeKuttaIntegrator(final String name,\n+                                 final double[] c, final double[][] a, final double[] b,\n+                                 final RungeKuttaStepInterpolator prototype,\n+                                 final double step) {\n+    super(name);\n+    this.c          = c;\n+    this.a          = a;\n+    this.b          = b;\n+    this.prototype  = prototype;\n+    this.step       = Math.abs(step);\n+  }\n+\n+  /** {@inheritDoc} */\n+  public double integrate(final FirstOrderDifferentialEquations equations,\n+                          final double t0, final double[] y0,\n+                          final double t, final double[] y)\n+  throws DerivativeException, IntegratorException {\n+\n+    sanityChecks(equations, t0, y0, t, y);\n+    setEquations(equations);\n+    resetEvaluations();\n+    final boolean forward = (t > t0);\n+\n+    // create some internal working arrays\n+    final int stages = c.length + 1;\n+    if (y != y0) {\n+      System.arraycopy(y0, 0, y, 0, y0.length);\n+    }\n+    final double[][] yDotK = new double[stages][];\n+    for (int i = 0; i < stages; ++i) {\n+      yDotK [i] = new double[y0.length];\n+    }\n+    final double[] yTmp = new double[y0.length];\n+\n+    // set up an interpolator sharing the integrator arrays\n+    AbstractStepInterpolator interpolator;\n+    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n+      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n+      rki.reinitialize(this, yTmp, yDotK, forward);\n+      interpolator = rki;\n+    } else {\n+      interpolator = new DummyStepInterpolator(yTmp, forward);\n+    }\n+    interpolator.storeTime(t0);\n+\n+    // set up integration control objects\n+    stepStart = t0;\n+    stepSize  = forward ? step : -step;\n+    for (StepHandler handler : stepHandlers) {\n+        handler.reset();\n+    }\n+    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n+    boolean lastStep = false;\n+\n+    // main integration loop\n+    while (!lastStep) {\n+\n+      interpolator.shift();\n+\n+      for (boolean loop = true; loop;) {\n+\n+        // first stage\n+        computeDerivatives(stepStart, y, yDotK[0]);\n+\n+        // next stages\n+        for (int k = 1; k < stages; ++k) {\n+\n+          for (int j = 0; j < y0.length; ++j) {\n+            double sum = a[k-1][0] * yDotK[0][j];\n+            for (int l = 1; l < k; ++l) {\n+              sum += a[k-1][l] * yDotK[l][j];\n+            }\n+            yTmp[j] = y[j] + stepSize * sum;\n+          }\n+\n+          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n+\n+        }\n+\n+        // estimate the state at the end of the step\n+        for (int j = 0; j < y0.length; ++j) {\n+          double sum    = b[0] * yDotK[0][j];\n+          for (int l = 1; l < stages; ++l) {\n+            sum    += b[l] * yDotK[l][j];\n+          }\n+          yTmp[j] = y[j] + stepSize * sum;\n+        }\n+\n+        // discrete events handling\n+        interpolator.storeTime(stepStart + stepSize);\n+        if (manager.evaluateStep(interpolator)) {\n+            final double dt = manager.getEventTime() - stepStart;\n+            if (Math.abs(dt) <= Math.ulp(stepStart)) {\n+                // rejecting the step would lead to a too small next step, we accept it\n+                loop = false;\n+            } else {\n+                // reject the step to match exactly the next switch time\n+                stepSize = dt;\n+            }\n+        } else {\n+          loop = false;\n+        }\n+\n+      }\n+\n+      // the step has been accepted\n+      final double nextStep = stepStart + stepSize;\n+      System.arraycopy(yTmp, 0, y, 0, y0.length);\n+      manager.stepAccepted(nextStep, y);\n+      lastStep = manager.stop();\n+\n+      // provide the step data to the step handler\n+      interpolator.storeTime(nextStep);\n+      for (StepHandler handler : stepHandlers) {\n+          handler.handleStep(interpolator, lastStep);\n+      }\n+      stepStart = nextStep;\n+\n+      if (manager.reset(stepStart, y) && ! lastStep) {\n+        // some events handler has triggered changes that\n+        // invalidate the derivatives, we need to recompute them\n+        computeDerivatives(stepStart, y, yDotK[0]);\n+      }\n+\n+      // make sure step size is set to default before next step\n+      stepSize = forward ? step : -step;\n+\n+    }\n+\n+    final double stopTime = stepStart;\n+    stepStart = Double.NaN;\n+    stepSize  = Double.NaN;\n+    return stopTime;\n+\n+  }\n+\n+  /** Time steps from Butcher array (without the first zero). */\n+  private double[] c;\n+\n+  /** Internal weights from Butcher array (without the first empty row). */\n+  private double[][] a;\n+\n+  /** External weights for the high order method from Butcher array. */\n+  private double[] b;\n+\n+  /** Prototype of the step interpolator. */\n+  private RungeKuttaStepInterpolator prototype;\n+                                         \n+  /** Integration step. */\n+  private double step;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.apache.commons.math.ode.AbstractIntegrator;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+\n+/** This class represents an interpolator over the last step during an\n+ * ODE integration for Runge-Kutta and embedded Runge-Kutta integrators.\n+ *\n+ * @see RungeKuttaIntegrator\n+ * @see EmbeddedRungeKuttaIntegrator\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+abstract class RungeKuttaStepInterpolator\n+  extends AbstractStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} and {@link\n+   * EmbeddedRungeKuttaIntegrator} classes use the prototyping design\n+   * pattern to create the step interpolators by cloning an\n+   * uninitialized model and latter initializing the copy.\n+   */\n+  protected RungeKuttaStepInterpolator() {\n+    super();\n+    yDotK      = null;\n+    integrator = null;\n+  }\n+\n+  /** Copy constructor.\n+\n+  * <p>The copied interpolator should have been finalized before the\n+  * copy, otherwise the copy will not be able to perform correctly any\n+  * interpolation and will throw a {@link NullPointerException}\n+  * later. Since we don't want this constructor to throw the\n+  * exceptions finalization may involve and since we don't want this\n+  * method to modify the state of the copied interpolator,\n+  * finalization is <strong>not</strong> done automatically, it\n+  * remains under user control.</p>\n+\n+  * <p>The copy is a deep copy: its arrays are separated from the\n+  * original arrays of the instance.</p>\n+\n+  * @param interpolator interpolator to copy from.\n+\n+  */\n+  public RungeKuttaStepInterpolator(final RungeKuttaStepInterpolator interpolator) {\n+\n+    super(interpolator);\n+\n+    if (interpolator.currentState != null) {\n+      final int dimension = currentState.length;\n+\n+      yDotK = new double[interpolator.yDotK.length][];\n+      for (int k = 0; k < interpolator.yDotK.length; ++k) {\n+        yDotK[k] = new double[dimension];\n+        System.arraycopy(interpolator.yDotK[k], 0,\n+                         yDotK[k], 0, dimension);\n+      }\n+\n+    } else {\n+      yDotK = null;\n+    }\n+\n+    // we cannot keep any reference to the equations in the copy\n+    // the interpolator should have been finalized before\n+    integrator = null;\n+\n+  }\n+\n+  /** Reinitialize the instance\n+   * <p>Some Runge-Kutta integrators need fewer functions evaluations\n+   * than their counterpart step interpolators. So the interpolator\n+   * should perform the last evaluations they need by themselves. The\n+   * {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link\n+   * EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator}\n+   * abstract classes call this method in order to let the step\n+   * interpolator perform the evaluations it needs. These evaluations\n+   * will be performed during the call to <code>doFinalize</code> if\n+   * any, i.e. only if the step handler either calls the {@link\n+   * AbstractStepInterpolator#finalizeStep finalizeStep} method or the\n+   * {@link AbstractStepInterpolator#getInterpolatedState\n+   * getInterpolatedState} method (for an interpolator which needs a\n+   * finalization) or if it clones the step interpolator.</p>\n+   * @param integrator integrator being used\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param yDotK reference to the integrator array holding all the\n+   * intermediate slopes\n+   * @param forward integration direction indicator\n+   */\n+  public void reinitialize(final AbstractIntegrator integrator,\n+                           final double[] y, final double[][] yDotK, final boolean forward) {\n+    reinitialize(y, forward);\n+    this.yDotK = yDotK;\n+    this.integrator = integrator;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public void writeExternal(final ObjectOutput out)\n+    throws IOException {\n+\n+    // save the state of the base class\n+    writeBaseExternal(out);\n+\n+    // save the local attributes\n+    final int n = (currentState == null) ? -1 : currentState.length;\n+    final int kMax = (yDotK == null) ? -1 : yDotK.length;\n+    out.writeInt(kMax);\n+    for (int k = 0; k < kMax; ++k) {\n+      for (int i = 0; i < n; ++i) {\n+        out.writeDouble(yDotK[k][i]);\n+      }\n+    }\n+\n+    // we do not save any reference to the equations\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public void readExternal(final ObjectInput in)\n+    throws IOException {\n+\n+    // read the base class \n+    final double t = readBaseExternal(in);\n+\n+    // read the local attributes\n+    final int n = (currentState == null) ? -1 : currentState.length;\n+    final int kMax = in.readInt();\n+    yDotK = (kMax < 0) ? null : new double[kMax][];\n+    for (int k = 0; k < kMax; ++k) {\n+      yDotK[k] = (n < 0) ? null : new double[n];\n+      for (int i = 0; i < n; ++i) {\n+        yDotK[k][i] = in.readDouble();\n+      }\n+    }\n+\n+    integrator = null;\n+\n+    if (currentState != null) {\n+        // we can now set the interpolated time and state\n+        setInterpolatedTime(t);\n+    } else {\n+        interpolatedTime = t;\n+    }\n+\n+  }\n+\n+  /** Slopes at the intermediate points */\n+  protected double[][] yDotK;\n+\n+  /** Reference to the integrator. */\n+  protected AbstractIntegrator integrator;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesIntegrator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+\n+/**\n+ * This class implements the 3/8 fourth order Runge-Kutta\n+ * integrator for Ordinary Differential Equations.\n+ *\n+ * <p>This method is an explicit Runge-Kutta method, its Butcher-array\n+ * is the following one :\n+ * <pre>\n+ *    0  |  0    0    0    0\n+ *   1/3 | 1/3   0    0    0\n+ *   2/3 |-1/3   1    0    0\n+ *    1  |  1   -1    1    0\n+ *       |--------------------\n+ *       | 1/8  3/8  3/8  1/8\n+ * </pre>\n+ * </p>\n+ *\n+ * @see EulerIntegrator\n+ * @see ClassicalRungeKuttaIntegrator\n+ * @see GillIntegrator\n+ * @see MidpointIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class ThreeEighthesIntegrator extends RungeKuttaIntegrator {\n+\n+  /** Time steps Butcher array. */\n+  private static final double[] c = {\n+    1.0 / 3.0, 2.0 / 3.0, 1.0\n+  };\n+\n+  /** Internal weights Butcher array. */\n+  private static final double[][] a = {\n+    {  1.0 / 3.0 },\n+    { -1.0 / 3.0, 1.0 },\n+    {  1.0, -1.0, 1.0 }\n+  };\n+\n+  /** Propagation weights Butcher array. */\n+  private static final double[] b = {\n+    1.0 / 8.0, 3.0 / 8.0, 3.0 / 8.0, 1.0 / 8.0\n+  };\n+\n+  /** Simple constructor.\n+   * Build a 3/8 integrator with the given step.\n+   * @param step integration step\n+   */\n+  public ThreeEighthesIntegrator(final double step) {\n+    super(\"3/8\", c, a, b, new ThreeEighthesStepInterpolator(), step);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/ThreeEighthesStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.nonstiff;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math.ode.sampling.StepInterpolator;\n+\n+/**\n+ * This class implements a step interpolator for the 3/8 fourth\n+ * order Runge-Kutta integrator.\n+ *\n+ * <p>This interpolator allows to compute dense output inside the last\n+ * step computed. The interpolation equation is consistent with the\n+ * integration scheme :\n+ *\n+ * <pre>\n+ *   y(t_n + theta h) = y (t_n + h)\n+ *                    - (1 - theta) (h/8) [ (1 - 7 theta + 8 theta^2) y'_1\n+ *                                      + 3 (1 +   theta - 4 theta^2) y'_2\n+ *                                      + 3 (1 +   theta)             y'_3\n+ *                                      +   (1 +   theta + 4 theta^2) y'_4\n+ *                                        ]\n+ * </pre>\n+ *\n+ * where theta belongs to [0 ; 1] and where y'_1 to y'_4 are the four\n+ * evaluations of the derivatives already computed during the\n+ * step.</p>\n+ *\n+ * @see ThreeEighthesIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+class ThreeEighthesStepInterpolator\n+  extends RungeKuttaStepInterpolator {\n+    \n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link AbstractStepInterpolator#reinitialize} method should be called\n+   * before using the instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. The {@link RungeKuttaIntegrator} class uses the\n+   * prototyping design pattern to create the step interpolators by\n+   * cloning an uninitialized model and latter initializing the copy.\n+   */\n+  public ThreeEighthesStepInterpolator() {\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public ThreeEighthesStepInterpolator(final ThreeEighthesStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  protected StepInterpolator doCopy() {\n+    return new ThreeEighthesStepInterpolator(this);\n+  }\n+\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  protected void computeInterpolatedStateAndDerivatives(final double theta,\n+                                          final double oneMinusThetaH)\n+      throws DerivativeException {\n+\n+      final double fourTheta2 = 4 * theta * theta;\n+      final double s          = oneMinusThetaH / 8.0;\n+      final double coeff1     = s * (1 - 7 * theta + 2 * fourTheta2);\n+      final double coeff2     = 3 * s * (1 + theta - fourTheta2);\n+      final double coeff3     = 3 * s * (1 + theta);\n+      final double coeff4     = s * (1 + theta + fourTheta2);\n+      final double coeffDot3  = 0.75 * theta;\n+      final double coeffDot1  = coeffDot3 * (4 * theta - 5) + 1;\n+      final double coeffDot2  = coeffDot3 * (5 - 6 * theta);\n+      final double coeffDot4  = coeffDot3 * (2 * theta - 1);\n+\n+      for (int i = 0; i < interpolatedState.length; ++i) {\n+          final double yDot1 = yDotK[0][i];\n+          final double yDot2 = yDotK[1][i];\n+          final double yDot3 = yDotK[2][i];\n+          final double yDot4 = yDotK[3][i];\n+          interpolatedState[i] =\n+              currentState[i] - coeff1 * yDot1 - coeff2 * yDot2 - coeff3 * yDot3 - coeff4 * yDot4;\n+          interpolatedDerivatives[i] =\n+              coeffDot1 * yDot1 + coeffDot2 * yDot2 + coeffDot3 * yDot3 + coeffDot4 * yDot4;\n+\n+      }\n+\n+  }\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -3345024435978721931L;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/AbstractStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.SecondOrderIntegrator;\n+import org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator;\n+\n+/** This abstract class represents an interpolator over the last step\n+ * during an ODE integration.\n+ *\n+ * <p>The various ODE integrators provide objects extending this class\n+ * to the step handlers. The handlers can use these objects to\n+ * retrieve the state vector at intermediate times between the\n+ * previous and the current grid points (dense output).</p>\n+ *\n+ * @see FirstOrderIntegrator\n+ * @see SecondOrderIntegrator\n+ * @see StepHandler\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ *\n+ */\n+\n+public abstract class AbstractStepInterpolator\n+  implements StepInterpolator {\n+\n+  /** previous time */\n+  protected double previousTime;\n+\n+  /** current time */\n+  protected double currentTime;\n+\n+  /** current time step */\n+  protected double h;\n+\n+  /** current state */\n+  protected double[] currentState;\n+\n+  /** interpolated time */\n+  protected double interpolatedTime;\n+\n+  /** interpolated state */\n+  protected double[] interpolatedState;\n+\n+  /** interpolated derivatives */\n+  protected double[] interpolatedDerivatives;\n+\n+  /** indicate if the step has been finalized or not. */\n+  private boolean finalized;\n+\n+  /** integration direction. */\n+  private boolean forward;\n+\n+  /** indicator for dirty state. */\n+  private boolean dirtyState;\n+\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * {@link #reinitialize} method should be called before using the\n+   * instance in order to initialize the internal arrays. This\n+   * constructor is used only in order to delay the initialization in\n+   * some cases. As an example, the {@link\n+   * EmbeddedRungeKuttaIntegrator} uses the prototyping design pattern\n+   * to create the step interpolators by cloning an uninitialized\n+   * model and latter initializing the copy.\n+   */\n+  protected AbstractStepInterpolator() {\n+    previousTime            = Double.NaN;\n+    currentTime             = Double.NaN;\n+    h                       = Double.NaN;\n+    interpolatedTime        = Double.NaN;\n+    currentState            = null;\n+    interpolatedState       = null;\n+    interpolatedDerivatives = null;\n+    finalized               = false;\n+    this.forward            = true;\n+    this.dirtyState         = true;\n+  }\n+\n+  /** Simple constructor.\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param forward integration direction indicator\n+   */\n+  protected AbstractStepInterpolator(final double[] y, final boolean forward) {\n+\n+    previousTime      = Double.NaN;\n+    currentTime       = Double.NaN;\n+    h                 = Double.NaN;\n+    interpolatedTime  = Double.NaN;\n+\n+    currentState            = y;\n+    interpolatedState       = new double[y.length];\n+    interpolatedDerivatives = new double[y.length];\n+\n+    finalized         = false;\n+    this.forward      = forward;\n+    this.dirtyState   = true;\n+\n+  }\n+\n+  /** Copy constructor.\n+\n+   * <p>The copied interpolator should have been finalized before the\n+   * copy, otherwise the copy will not be able to perform correctly\n+   * any derivative computation and will throw a {@link\n+   * NullPointerException} later. Since we don't want this constructor\n+   * to throw the exceptions finalization may involve and since we\n+   * don't want this method to modify the state of the copied\n+   * interpolator, finalization is <strong>not</strong> done\n+   * automatically, it remains under user control.</p>\n+\n+   * <p>The copy is a deep copy: its arrays are separated from the\n+   * original arrays of the instance.</p>\n+\n+   * @param interpolator interpolator to copy from.\n+\n+   */\n+  protected AbstractStepInterpolator(final AbstractStepInterpolator interpolator) {\n+\n+    previousTime      = interpolator.previousTime;\n+    currentTime       = interpolator.currentTime;\n+    h                 = interpolator.h;\n+    interpolatedTime  = interpolator.interpolatedTime;\n+\n+    if (interpolator.currentState != null) {\n+      currentState            = interpolator.currentState.clone();\n+      interpolatedState       = interpolator.interpolatedState.clone();\n+      interpolatedDerivatives = interpolator.interpolatedDerivatives.clone();\n+    } else {\n+      currentState            = null;\n+      interpolatedState       = null;\n+      interpolatedDerivatives = null;\n+    }\n+\n+    finalized  = interpolator.finalized;\n+    forward    = interpolator.forward;\n+    dirtyState = interpolator.dirtyState;\n+\n+  }\n+\n+  /** Reinitialize the instance\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param forward integration direction indicator\n+   */\n+  protected void reinitialize(final double[] y, final boolean forward) {\n+\n+    previousTime      = Double.NaN;\n+    currentTime       = Double.NaN;\n+    h                 = Double.NaN;\n+    interpolatedTime  = Double.NaN;\n+\n+    currentState            = y;\n+    interpolatedState       = new double[y.length];\n+    interpolatedDerivatives = new double[y.length];\n+\n+    finalized         = false;\n+    this.forward      = forward;\n+    this.dirtyState   = true;\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+   public StepInterpolator copy() throws DerivativeException {\n+\n+     // finalize the step before performing copy\n+     finalizeStep();\n+\n+     // create the new independent instance\n+     return doCopy();\n+\n+   }\n+\n+   /** Really copy the finalized instance.\n+    * <p>This method is called by {@link #copy()} after the\n+    * step has been finalized. It must perform a deep copy\n+    * to have an new instance completely independent for the\n+    * original instance.\n+    * @return a copy of the finalized instance\n+    */\n+   protected abstract StepInterpolator doCopy();\n+\n+  /** Shift one step forward.\n+   * Copy the current time into the previous time, hence preparing the\n+   * interpolator for future calls to {@link #storeTime storeTime}\n+   */\n+  public void shift() {\n+    previousTime = currentTime;\n+  }\n+\n+  /** Store the current step time.\n+   * @param t current time\n+   */\n+  public void storeTime(final double t) {\n+\n+    currentTime = t;\n+    h           = currentTime - previousTime;\n+    setInterpolatedTime(t);\n+\n+    // the step is not finalized anymore\n+    finalized  = false;\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public double getPreviousTime() {\n+    return previousTime;\n+  }\n+    \n+  /** {@inheritDoc} */\n+  public double getCurrentTime() {\n+    return currentTime;\n+  }\n+    \n+  /** {@inheritDoc} */\n+  public double getInterpolatedTime() {\n+    return interpolatedTime;\n+  }\n+    \n+  /** {@inheritDoc} */\n+  public void setInterpolatedTime(final double time) {\n+      interpolatedTime = time;\n+      dirtyState       = true;\n+  }\n+\n+  /** {@inheritDoc} */\n+  public boolean isForward() {\n+    return forward;\n+  }\n+\n+  /** Compute the state and derivatives at the interpolated time.\n+   * This is the main processing method that should be implemented by\n+   * the derived classes to perform the interpolation.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  protected abstract void computeInterpolatedStateAndDerivatives(double theta,\n+                                                                 double oneMinusThetaH)\n+    throws DerivativeException;\n+    \n+  /** {@inheritDoc} */\n+  public double[] getInterpolatedState() throws DerivativeException {\n+\n+      // lazy evaluation of the state\n+      if (dirtyState) {\n+          final double oneMinusThetaH = currentTime - interpolatedTime;\n+          final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\n+          computeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\n+          dirtyState = false;\n+      }\n+\n+      return interpolatedState;\n+\n+  }\n+\n+  /** {@inheritDoc} */\n+  public double[] getInterpolatedDerivatives() throws DerivativeException {\n+\n+      // lazy evaluation of the state\n+      if (dirtyState) {\n+          final double oneMinusThetaH = currentTime - interpolatedTime;\n+          final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\n+          computeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\n+          dirtyState = false;\n+      }\n+\n+      return interpolatedDerivatives;\n+\n+  }\n+\n+  /**\n+   * Finalize the step.\n+\n+   * <p>Some embedded Runge-Kutta integrators need fewer functions\n+   * evaluations than their counterpart step interpolators. These\n+   * interpolators should perform the last evaluations they need by\n+   * themselves only if they need them. This method triggers these\n+   * extra evaluations. It can be called directly by the user step\n+   * handler and it is called automatically if {@link\n+   * #setInterpolatedTime} is called.</p>\n+\n+   * <p>Once this method has been called, <strong>no</strong> other\n+   * evaluation will be performed on this step. If there is a need to\n+   * have some side effects between the step handler and the\n+   * differential equations (for example update some data in the\n+   * equations once the step has been done), it is advised to call\n+   * this method explicitly from the step handler before these side\n+   * effects are set up. If the step handler induces no side effect,\n+   * then this method can safely be ignored, it will be called\n+   * transparently as needed.</p>\n+\n+   * <p><strong>Warning</strong>: since the step interpolator provided\n+   * to the step handler as a parameter of the {@link\n+   * StepHandler#handleStep handleStep} is valid only for the duration\n+   * of the {@link StepHandler#handleStep handleStep} call, one cannot\n+   * simply store a reference and reuse it later. One should first\n+   * finalize the instance, then copy this finalized instance into a\n+   * new object that can be kept.</p>\n+\n+   * <p>This method calls the protected <code>doFinalize</code> method\n+   * if it has never been called during this step and set a flag\n+   * indicating that it has been called once. It is the <code>\n+   * doFinalize</code> method which should perform the evaluations.\n+   * This wrapping prevents from calling <code>doFinalize</code> several\n+   * times and hence evaluating the differential equations too often.\n+   * Therefore, subclasses are not allowed not reimplement it, they\n+   * should rather reimplement <code>doFinalize</code>.</p>\n+\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+   */\n+  public final void finalizeStep()\n+    throws DerivativeException {\n+    if (! finalized) {\n+      doFinalize();\n+      finalized = true;\n+    }\n+  }\n+\n+  /**\n+   * Really finalize the step.\n+   * The default implementation of this method does nothing.\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+   */\n+  protected void doFinalize()\n+    throws DerivativeException {\n+  }\n+\n+  /** {@inheritDoc} */\n+  public abstract void writeExternal(ObjectOutput out)\n+    throws IOException;\n+\n+  /** {@inheritDoc} */\n+  public abstract void readExternal(ObjectInput in)\n+    throws IOException, ClassNotFoundException;\n+\n+  /** Save the base state of the instance.\n+   * This method performs step finalization if it has not been done\n+   * before.\n+   * @param out stream where to save the state\n+   * @exception IOException in case of write error\n+   */\n+  protected void writeBaseExternal(final ObjectOutput out)\n+    throws IOException {\n+\n+    if (currentState == null) {\n+        out.writeInt(-1);\n+    } else {\n+        out.writeInt(currentState.length);\n+    }\n+    out.writeDouble(previousTime);\n+    out.writeDouble(currentTime);\n+    out.writeDouble(h);\n+    out.writeBoolean(forward);\n+\n+    if (currentState != null) {\n+        for (int i = 0; i < currentState.length; ++i) {\n+            out.writeDouble(currentState[i]);\n+        }\n+    }\n+\n+    out.writeDouble(interpolatedTime);\n+\n+    // we do not store the interpolated state,\n+    // it will be recomputed as needed after reading\n+\n+    // finalize the step (and don't bother saving the now true flag)\n+    try {\n+      finalizeStep();\n+    } catch (DerivativeException e) {\n+      throw MathRuntimeException.createIOException(e);\n+    }\n+\n+  }\n+\n+  /** Read the base state of the instance.\n+   * This method does <strong>neither</strong> set the interpolated\n+   * time nor state. It is up to the derived class to reset it\n+   * properly calling the {@link #setInterpolatedTime} method later,\n+   * once all rest of the object state has been set up properly.\n+   * @param in stream where to read the state from\n+   * @return interpolated time be set later by the caller\n+   * @exception IOException in case of read error\n+   */\n+  protected double readBaseExternal(final ObjectInput in)\n+    throws IOException {\n+\n+    final int dimension = in.readInt();\n+    previousTime  = in.readDouble();\n+    currentTime   = in.readDouble();\n+    h             = in.readDouble();\n+    forward       = in.readBoolean();\n+    dirtyState    = true;\n+\n+    if (dimension < 0) {\n+        currentState = null;\n+    } else {\n+        currentState  = new double[dimension];\n+        for (int i = 0; i < currentState.length; ++i) {\n+            currentState[i] = in.readDouble();\n+        }\n+    }\n+\n+    // we do NOT handle the interpolated time and state here\n+    interpolatedTime        = Double.NaN;\n+    interpolatedState       = (dimension < 0) ? null : new double[dimension];\n+    interpolatedDerivatives = (dimension < 0) ? null : new double[dimension];\n+\n+    finalized = true;\n+\n+    return in.readDouble();\n+\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/DummyStepHandler.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+\n+/**\n+ * This class is a step handler that does nothing.\n+\n+ * <p>This class is provided as a convenience for users who are only\n+ * interested in the final state of an integration and not in the\n+ * intermediate steps. Its handleStep method does nothing.</p>\n+ *\n+ * <p>Since this class has no internal state, it is implemented using\n+ * the Singleton design pattern. This means that only one instance is\n+ * ever created, which can be retrieved using the getInstance\n+ * method. This explains why there is no public constructor.</p>\n+ *\n+ * @see StepHandler\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class DummyStepHandler implements StepHandler {\n+\n+  /** Private constructor.\n+   * The constructor is private to prevent users from creating\n+   * instances (Singleton design-pattern).\n+   */\n+  private DummyStepHandler() {\n+  }\n+\n+  /** Get the only instance.\n+   * @return the only instance\n+   */\n+  public static DummyStepHandler getInstance() {\n+    return instance;\n+  }\n+\n+  /** Determines whether this handler needs dense output.\n+   * Since this handler does nothing, it does not require dense output.\n+   * @return always false\n+   */\n+  public boolean requiresDenseOutput() {\n+    return false;\n+  }\n+\n+  /** Reset the step handler.\n+   * Initialize the internal data as required before the first step is\n+   * handled.\n+   */\n+  public void reset() {\n+  }\n+\n+  /**\n+   * Handle the last accepted step.\n+   * This method does nothing in this class.\n+   * @param interpolator interpolator for the last accepted step. For\n+   * efficiency purposes, the various integrators reuse the same\n+   * object on each call, so if the instance wants to keep it across\n+   * all calls (for example to provide at the end of the integration a\n+   * continuous model valid throughout the integration range), it\n+   * should build a local copy using the clone method and store this\n+   * copy.\n+   * @param isLast true if the step is the last one\n+   */\n+  public void handleStep(final StepInterpolator interpolator, final boolean isLast) {\n+  }\n+\n+  /** The only instance. */\n+  private static final DummyStepHandler instance = new DummyStepHandler();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/DummyStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator;\n+\n+/** This class is a step interpolator that does nothing.\n+ *\n+ * <p>This class is used when the {@link StepHandler \"step handler\"}\n+ * set up by the user does not need step interpolation. It does not\n+ * recompute the state when {@link AbstractStepInterpolator#setInterpolatedTime\n+ * setInterpolatedTime} is called. This implies the interpolated state\n+ * is always the state at the end of the current step.</p>\n+ *\n+ * @see StepHandler\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class DummyStepInterpolator\n+  extends AbstractStepInterpolator {\n+\n+  /** Simple constructor.\n+   * This constructor builds an instance that is not usable yet, the\n+   * <code>AbstractStepInterpolator.reinitialize</code> protected method\n+   * should be called before using the instance in order to initialize\n+   * the internal arrays. This constructor is used only in order to delay\n+   * the initialization in some cases. As an example, the {@link\n+   * EmbeddedRungeKuttaIntegrator} uses the prototyping design pattern\n+   * to create the step interpolators by cloning an uninitialized\n+   * model and latter initializing the copy.\n+   */\n+  public DummyStepInterpolator() {\n+    super();\n+  }\n+\n+  /** Simple constructor.\n+   * @param y reference to the integrator array holding the state at\n+   * the end of the step\n+   * @param forward integration direction indicator\n+   */\n+  public DummyStepInterpolator(final double[] y, final boolean forward) {\n+    super(y, forward);\n+  }\n+\n+  /** Copy constructor.\n+   * @param interpolator interpolator to copy from. The copy is a deep\n+   * copy: its arrays are separated from the original arrays of the\n+   * instance\n+   */\n+  public DummyStepInterpolator(final DummyStepInterpolator interpolator) {\n+    super(interpolator);\n+  }\n+\n+  /** Really copy the finalized instance.\n+   * @return a copy of the finalized instance\n+   */\n+  @Override\n+  protected StepInterpolator doCopy() {\n+    return new DummyStepInterpolator(this);\n+  }\n+\n+  /** Compute the state at the interpolated time.\n+   * In this class, this method does nothing: the interpolated state\n+   * is always the state at the end of the current step.\n+   * @param theta normalized interpolation abscissa within the step\n+   * (theta is zero at the previous time step and one at the current time step)\n+   * @param oneMinusThetaH time gap between the interpolated time and\n+   * the current time\n+   * @throws DerivativeException this exception is propagated to the caller if the\n+   * underlying user function triggers one\n+   */\n+  @Override\n+  protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH)\n+    throws DerivativeException {\n+      System.arraycopy(currentState, 0, interpolatedState, 0, currentState.length);\n+  }\n+    \n+  /** Write the instance to an output channel.\n+   * @param out output channel\n+   * @exception IOException if the instance cannot be written\n+   */\n+  @Override\n+  public void writeExternal(final ObjectOutput out)\n+    throws IOException {\n+    // save the state of the base class\n+    writeBaseExternal(out);\n+  }\n+\n+  /** Read the instance from an input channel.\n+   * @param in input channel\n+   * @exception IOException if the instance cannot be read\n+   */\n+  @Override\n+  public void readExternal(final ObjectInput in)\n+    throws IOException {\n+\n+    // read the base class \n+    final double t = readBaseExternal(in);\n+\n+    // we can now set the interpolated time and state\n+    setInterpolatedTime(t);\n+\n+  }\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = 1708010296707839488L;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/FixedStepHandler.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+\n+/**\n+ * This interface represents a handler that should be called after\n+ * each successful fixed step.\n+\n+ * <p>This interface should be implemented by anyone who is interested\n+ * in getting the solution of an ordinary differential equation at\n+ * fixed time steps. Objects implementing this interface should be\n+ * wrapped within an instance of {@link StepNormalizer} that itself\n+ * is used as the general {@link StepHandler} by the integrator. The\n+ * {@link StepNormalizer} object is called according to the integrator\n+ * internal algorithms and it calls objects implementing this\n+ * interface as necessary at fixed time steps.</p>\n+ *\n+ * @see StepHandler\n+ * @see StepNormalizer\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public interface FixedStepHandler  {\n+\n+  /**\n+   * Handle the last accepted step\n+   * @param t time of the current step\n+   * @param y state vector at t. For efficiency purposes, the {@link\n+   * StepNormalizer} class reuses the same array on each call, so if\n+   * the instance wants to keep it across all calls (for example to\n+   * provide at the end of the integration a complete array of all\n+   * steps), it should build a local copy store this copy.\n+   * @param yDot derivatives of the state vector state vector at t.\n+   * For efficiency purposes, the {@link StepNormalizer} class reuses\n+   * the same array on each call, so if\n+   * the instance wants to keep it across all calls (for example to\n+   * provide at the end of the integration a complete array of all\n+   * steps), it should build a local copy store this copy.\n+   * @param isLast true if the step is the last one\n+   * @throws DerivativeException if some error condition is encountered\n+   */\n+  public void handleStep(double t, double[] y, double[] yDot, boolean isLast)\n+      throws DerivativeException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/NordsieckStepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.ode.DerivativeException;\n+\n+/**\n+ * This class implements an interpolator for integrators using Nordsieck representation.\n+ *\n+ * <p>This interpolator computes dense output around the current point.\n+ * The interpolation equation is based on Taylor series formulas.\n+ *\n+ * @see org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator\n+ * @see org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+\n+public class NordsieckStepInterpolator extends AbstractStepInterpolator {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -7179861704951334960L;\n+\n+    /** Step size used in the first scaled derivative and Nordsieck vector. */\n+    private double scalingH;\n+\n+    /** Reference time for all arrays.\n+     * <p>Sometimes, the reference time is the same as previousTime,\n+     * sometimes it is the same as currentTime, so we use a separate\n+     * field to avoid any confusion.\n+     * </p>\n+     */\n+    private double referenceTime;\n+\n+    /** First scaled derivative. */\n+    private double[] scaled;\n+\n+    /** Nordsieck vector. */\n+    private Array2DRowRealMatrix nordsieck;\n+\n+    /** State variation. */\n+    protected double[] stateVariation;\n+\n+    /** Simple constructor.\n+     * This constructor builds an instance that is not usable yet, the\n+     * {@link AbstractStepInterpolator#reinitialize} method should be called\n+     * before using the instance in order to initialize the internal arrays. This\n+     * constructor is used only in order to delay the initialization in\n+     * some cases.\n+     */\n+    public NordsieckStepInterpolator() {\n+    }\n+\n+    /** Copy constructor.\n+     * @param interpolator interpolator to copy from. The copy is a deep\n+     * copy: its arrays are separated from the original arrays of the\n+     * instance\n+     */\n+    public NordsieckStepInterpolator(final NordsieckStepInterpolator interpolator) {\n+        super(interpolator);\n+        scalingH      = interpolator.scalingH;\n+        referenceTime = interpolator.referenceTime;\n+        if (interpolator.scaled != null) {\n+            scaled = interpolator.scaled.clone();\n+        }\n+        if (interpolator.nordsieck != null) {\n+            nordsieck = new Array2DRowRealMatrix(interpolator.nordsieck.getDataRef(), true);\n+        }\n+        if (interpolator.stateVariation != null) {\n+            stateVariation = interpolator.stateVariation.clone();\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected StepInterpolator doCopy() {\n+        return new NordsieckStepInterpolator(this);\n+    }\n+\n+    /** Reinitialize the instance.\n+     * <p>Beware that all arrays <em>must</em> be references to integrator\n+     * arrays, in order to ensure proper update without copy.</p>\n+     * @param y reference to the integrator array holding the state at\n+     * the end of the step\n+     * @param forward integration direction indicator\n+     */\n+    @Override\n+    public void reinitialize(final double[] y, final boolean forward) {\n+        super.reinitialize(y, forward);\n+        stateVariation = new double[y.length];\n+    }\n+\n+    /** Reinitialize the instance.\n+     * <p>Beware that all arrays <em>must</em> be references to integrator\n+     * arrays, in order to ensure proper update without copy.</p>\n+     * @param referenceTime time at which all arrays are defined\n+     * @param scalingH step size used in the scaled and nordsieck arrays\n+     * @param scaled reference to the integrator array holding the first\n+     * scaled derivative\n+     * @param nordsieck reference to the integrator matrix holding the\n+     * nordsieck vector\n+     */\n+    public void reinitialize(final double referenceTime, final double scalingH,\n+                             final double[] scaled, final Array2DRowRealMatrix nordsieck) {\n+        this.referenceTime = referenceTime;\n+        this.scalingH      = scalingH;\n+        this.scaled        = scaled;\n+        this.nordsieck     = nordsieck;\n+\n+        // make sure the state and derivatives will depend on the new arrays\n+        setInterpolatedTime(getInterpolatedTime());\n+\n+    }\n+\n+    /** Rescale the instance.\n+     * <p>Since the scaled and Nordiseck arrays are shared with the caller,\n+     * this method has the side effect of rescaling this arrays in the caller too.</p>\n+     * @param scalingH new step size to use in the scaled and nordsieck arrays\n+     */\n+    public void rescale(final double scalingH) {\n+\n+        final double ratio = scalingH / this.scalingH;\n+        for (int i = 0; i < scaled.length; ++i) {\n+            scaled[i] *= ratio;\n+        }\n+\n+        final double[][] nData = nordsieck.getDataRef();\n+        double power = ratio;\n+        for (int i = 0; i < nData.length; ++i) {\n+            power *= ratio;\n+            final double[] nDataI = nData[i];\n+            for (int j = 0; j < nDataI.length; ++j) {\n+                nDataI[j] *= power;\n+            }\n+        }\n+\n+        this.scalingH = scalingH;\n+\n+    }\n+\n+    /**\n+     * Get the state vector variation from current to interpolated state.\n+     * <p>This method is aimed at computing y(t<sub>interpolation</sub>)\n+     * -y(t<sub>current</sub>) accurately by avoiding the cancellation errors\n+     * that would occur if the subtraction were performed explicitly.</p>\n+     * <p>The returned vector is a reference to a reused array, so\n+     * it should not be modified and it should be copied if it needs\n+     * to be preserved across several calls.</p>\n+     * @return state vector at time {@link #getInterpolatedTime}\n+     * @see #getInterpolatedDerivatives()\n+     * @throws DerivativeException if this call induces an automatic\n+     * step finalization that throws one\n+     */\n+    public double[] getInterpolatedStateVariation()\n+        throws DerivativeException {\n+        // compute and ignore interpolated state\n+        // to make sure state variation is computed as a side effect\n+        getInterpolatedState();\n+        return stateVariation;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH) {\n+\n+        final double x = interpolatedTime - referenceTime;\n+        final double normalizedAbscissa = x / scalingH;\n+\n+        Arrays.fill(stateVariation, 0.0);\n+        Arrays.fill(interpolatedDerivatives, 0.0);\n+\n+        // apply Taylor formula from high order to low order,\n+        // for the sake of numerical accuracy\n+        final double[][] nData = nordsieck.getDataRef();\n+        for (int i = nData.length - 1; i >= 0; --i) {\n+            final int order = i + 2;\n+            final double[] nDataI = nData[i];\n+            final double power = Math.pow(normalizedAbscissa, order);\n+            for (int j = 0; j < nDataI.length; ++j) {\n+                final double d = nDataI[j] * power;\n+                stateVariation[j]          += d;\n+                interpolatedDerivatives[j] += order * d;\n+            }\n+        }\n+\n+        for (int j = 0; j < currentState.length; ++j) {\n+            stateVariation[j] += scaled[j] * normalizedAbscissa;\n+            interpolatedState[j] = currentState[j] + stateVariation[j];\n+            interpolatedDerivatives[j] =\n+                (interpolatedDerivatives[j] + scaled[j] * normalizedAbscissa) / x;\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void writeExternal(final ObjectOutput out)\n+        throws IOException {\n+\n+        // save the state of the base class\n+        writeBaseExternal(out);\n+\n+        // save the local attributes\n+        out.writeDouble(scalingH);\n+        out.writeDouble(referenceTime);\n+\n+        final int n = (currentState == null) ? -1 : currentState.length;\n+        if (scaled == null) {\n+            out.writeBoolean(false);\n+        } else {\n+            out.writeBoolean(true);\n+            for (int j = 0; j < n; ++j) {\n+                out.writeDouble(scaled[j]);\n+            }\n+        }\n+\n+        if (nordsieck == null) {\n+            out.writeBoolean(false);\n+        } else {\n+            out.writeBoolean(true);\n+            out.writeObject(nordsieck);\n+        }\n+\n+        // we don't save state variation, it will be recomputed\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void readExternal(final ObjectInput in)\n+        throws IOException, ClassNotFoundException {\n+\n+        // read the base class \n+        final double t = readBaseExternal(in);\n+\n+        // read the local attributes\n+        scalingH      = in.readDouble();\n+        referenceTime = in.readDouble();\n+\n+        final int n = (currentState == null) ? -1 : currentState.length;\n+        final boolean hasScaled = in.readBoolean();\n+        if (hasScaled) {\n+            scaled = new double[n];\n+            for (int j = 0; j < n; ++j) {\n+                scaled[j] = in.readDouble();\n+            }\n+        } else {\n+            scaled = null;\n+        }\n+\n+        final boolean hasNordsieck = in.readBoolean();\n+        if (hasNordsieck) {\n+            nordsieck = (Array2DRowRealMatrix) in.readObject();\n+        } else {\n+            nordsieck = null;\n+        }\n+\n+        if (hasScaled && hasNordsieck) {\n+            // we can now set the interpolated time and state\n+            stateVariation = new double[n];\n+            setInterpolatedTime(t);\n+        } else {\n+            stateVariation = null;\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/StepHandler.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import org.apache.commons.math.ode.ContinuousOutputModel;\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.SecondOrderIntegrator;\n+\n+/**\n+ * This interface represents a handler that should be called after\n+ * each successful step.\n+ *\n+ * <p>The ODE integrators compute the evolution of the state vector at\n+ * some grid points that depend on their own internal algorithm. Once\n+ * they have found a new grid point (possibly after having computed\n+ * several evaluation of the derivative at intermediate points), they\n+ * provide it to objects implementing this interface. These objects\n+ * typically either ignore the intermediate steps and wait for the\n+ * last one, store the points in an ephemeris, or forward them to\n+ * specialized processing or output methods.</p>\n+ *\n+ * @see FirstOrderIntegrator\n+ * @see SecondOrderIntegrator\n+ * @see StepInterpolator\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public interface StepHandler {\n+\n+  /** Determines whether this handler needs dense output.\n+   * <p>This method allows the integrator to avoid performing extra\n+   * computation if the handler does not need dense output. If this\n+   * method returns false, the integrator will call the {@link\n+   * #handleStep} method with a {@link DummyStepInterpolator} rather\n+   * than a custom interpolator.</p>\n+   * @return true if the handler needs dense output\n+   */\n+  public boolean requiresDenseOutput();\n+\n+  /** Reset the step handler.\n+   * Initialize the internal data as required before the first step is\n+   * handled.\n+   */\n+  public void reset();\n+\n+  /**\n+   * Handle the last accepted step\n+   * @param interpolator interpolator for the last accepted step. For\n+   * efficiency purposes, the various integrators reuse the same\n+   * object on each call, so if the instance wants to keep it across\n+   * all calls (for example to provide at the end of the integration a\n+   * continuous model valid throughout the integration range, as the\n+   * {@link ContinuousOutputModel ContinuousOutputModel} class does),\n+   * it should build a local copy using the clone method of the\n+   * interpolator and store this copy. Keeping only a reference to the\n+   * interpolator and reusing it will result in unpredictable\n+   * behaviour (potentially crashing the application).\n+   * @param isLast true if the step is the last one\n+   * @throws DerivativeException this exception is propagated to the\n+   * caller if the underlying user function triggers one\n+   */\n+  public void handleStep(StepInterpolator interpolator, boolean isLast)\n+    throws DerivativeException;\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/StepInterpolator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import java.io.Externalizable;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+import org.apache.commons.math.ode.FirstOrderIntegrator;\n+import org.apache.commons.math.ode.SecondOrderIntegrator;\n+\n+/** This interface represents an interpolator over the last step\n+ * during an ODE integration.\n+ *\n+ * <p>The various ODE integrators provide objects implementing this\n+ * interface to the step handlers. These objects are often custom\n+ * objects tightly bound to the integrator internal algorithms. The\n+ * handlers can use these objects to retrieve the state vector at\n+ * intermediate times between the previous and the current grid points\n+ * (this feature is often called dense output).</p>\n+ * <p>One important thing to note is that the step handlers may be so\n+ * tightly bound to the integrators that they often share some internal\n+ * state arrays. This imply that one should <em>never</em> use a direct\n+ * reference to a step interpolator outside of the step handler, either\n+ * for future use or for use in another thread. If such a need arise, the\n+ * step interpolator <em>must</em> be copied using the dedicated\n+ * {@link #copy()} method.\n+ * </p>\n+ *\n+ * @see FirstOrderIntegrator\n+ * @see SecondOrderIntegrator\n+ * @see StepHandler\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public interface StepInterpolator\n+  extends Externalizable {\n+\n+  /**\n+   * Get the previous grid point time.\n+   * @return previous grid point time\n+   */\n+  public double getPreviousTime();\n+    \n+  /**\n+   * Get the current grid point time.\n+   * @return current grid point time\n+   */\n+  public double getCurrentTime();\n+    \n+  /**\n+   * Get the time of the interpolated point.\n+   * If {@link #setInterpolatedTime} has not been called, it returns\n+   * the current grid point time.\n+   * @return interpolation point time\n+   */\n+  public double getInterpolatedTime();\n+    \n+  /**\n+   * Set the time of the interpolated point.\n+   * <p>Setting the time outside of the current step is now allowed, but\n+   * should be used with care since the accuracy of the interpolator will\n+   * probably be very poor far from this step. This allowance has been\n+   * added to simplify implementation of search algorithms near the\n+   * step endpoints.</p>\n+   * <p>Setting the time changes the instance internal state. If a\n+   * specific state must be preserved, a copy of the instance must be\n+   * created using {@link #copy()}.</p>\n+   * @param time time of the interpolated point\n+   */\n+  public void setInterpolatedTime(double time);\n+\n+  /**\n+   * Get the state vector of the interpolated point.\n+   * <p>The returned vector is a reference to a reused array, so\n+   * it should not be modified and it should be copied if it needs\n+   * to be preserved across several calls.</p>\n+   * @return state vector at time {@link #getInterpolatedTime}\n+   * @see #getInterpolatedDerivatives()\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   */\n+  public double[] getInterpolatedState()\n+      throws DerivativeException;\n+\n+  /**\n+   * Get the derivatives of the state vector of the interpolated point.\n+   * <p>The returned vector is a reference to a reused array, so\n+   * it should not be modified and it should be copied if it needs\n+   * to be preserved across several calls.</p>\n+   * @return derivatives of the state vector at time {@link #getInterpolatedTime}\n+   * @see #getInterpolatedState()\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   * @since 2.0\n+   */\n+  public double[] getInterpolatedDerivatives()\n+      throws DerivativeException;\n+\n+  /** Check if the natural integration direction is forward.\n+   * <p>This method provides the integration direction as specified by\n+   * the integrator itself, it avoid some nasty problems in\n+   * degenerated cases like null steps due to cancellation at step\n+   * initialization, step control or discrete events\n+   * triggering.</p>\n+   * @return true if the integration variable (time) increases during\n+   * integration\n+   */\n+  public boolean isForward();\n+\n+  /** Copy the instance.\n+   * <p>The copied instance is guaranteed to be independent from the\n+   * original one. Both can be used with different settings for\n+   * interpolated time without any side effect.</p>\n+   * @return a deep copy of the instance, which can be used independently.\n+   * @throws DerivativeException if this call induces an automatic\n+   * step finalization that throws one\n+   * @see #setInterpolatedTime(double)\n+   */\n+   public StepInterpolator copy() throws DerivativeException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/ode/sampling/StepNormalizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.ode.sampling;\n+\n+import org.apache.commons.math.ode.DerivativeException;\n+\n+/**\n+ * This class wraps an object implementing {@link FixedStepHandler}\n+ * into a {@link StepHandler}.\n+\n+ * <p>This wrapper allows to use fixed step handlers with general\n+ * integrators which cannot guaranty their integration steps will\n+ * remain constant and therefore only accept general step\n+ * handlers.</p>\n+ *\n+ * <p>The stepsize used is selected at construction time. The {@link\n+ * FixedStepHandler#handleStep handleStep} method of the underlying\n+ * {@link FixedStepHandler} object is called at the beginning time of\n+ * the integration t0 and also at times t0+h, t0+2h, ... If the\n+ * integration range is an integer multiple of the stepsize, then the\n+ * last point handled will be the endpoint of the integration tend, if\n+ * not, the last point will belong to the interval [tend - h ;\n+ * tend].</p>\n+ *\n+ * <p>There is no constraint on the integrator, it can use any\n+ * timestep it needs (time steps longer or shorter than the fixed time\n+ * step and non-integer ratios are all allowed).</p>\n+ *\n+ * @see StepHandler\n+ * @see FixedStepHandler\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class StepNormalizer implements StepHandler {\n+\n+    /** Fixed time step. */\n+    private double h;\n+\n+    /** Underlying step handler. */\n+    private final FixedStepHandler handler;\n+\n+    /** Last step time. */\n+    private double lastTime;\n+\n+    /** Last State vector. */\n+    private double[] lastState;\n+\n+    /** Last Derivatives vector. */\n+    private double[] lastDerivatives;\n+\n+    /** Integration direction indicator. */\n+    private boolean forward;\n+\n+    /** Simple constructor.\n+     * @param h fixed time step (sign is not used)\n+     * @param handler fixed time step handler to wrap\n+     */\n+    public StepNormalizer(final double h, final FixedStepHandler handler) {\n+        this.h       = Math.abs(h);\n+        this.handler = handler;\n+        reset();\n+    }\n+\n+    /** Determines whether this handler needs dense output.\n+     * This handler needs dense output in order to provide data at\n+     * regularly spaced steps regardless of the steps the integrator\n+     * uses, so this method always returns true.\n+     * @return always true\n+     */\n+    public boolean requiresDenseOutput() {\n+        return true;\n+    }\n+\n+    /** Reset the step handler.\n+     * Initialize the internal data as required before the first step is\n+     * handled.\n+     */\n+    public void reset() {\n+        lastTime        = Double.NaN;\n+        lastState       = null;\n+        lastDerivatives = null;\n+        forward         = true;\n+    }\n+\n+    /**\n+     * Handle the last accepted step\n+     * @param interpolator interpolator for the last accepted step. For\n+     * efficiency purposes, the various integrators reuse the same\n+     * object on each call, so if the instance wants to keep it across\n+     * all calls (for example to provide at the end of the integration a\n+     * continuous model valid throughout the integration range), it\n+     * should build a local copy using the clone method and store this\n+     * copy.\n+     * @param isLast true if the step is the last one\n+     * @throws DerivativeException this exception is propagated to the\n+     * caller if the underlying user function triggers one\n+     */\n+    public void handleStep(final StepInterpolator interpolator, final boolean isLast)\n+        throws DerivativeException {\n+\n+        if (lastState == null) {\n+\n+            lastTime = interpolator.getPreviousTime();\n+            interpolator.setInterpolatedTime(lastTime);\n+            lastState = interpolator.getInterpolatedState().clone();\n+            lastDerivatives = interpolator.getInterpolatedDerivatives().clone();\n+\n+            // take the integration direction into account\n+            forward = (interpolator.getCurrentTime() >= lastTime);\n+            if (! forward) {\n+                h = -h;\n+            }\n+\n+        }\n+\n+        double nextTime = lastTime + h;\n+        boolean nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());\n+        while (nextInStep) {\n+\n+            // output the stored previous step\n+            handler.handleStep(lastTime, lastState, lastDerivatives, false);\n+\n+            // store the next step\n+            lastTime = nextTime;\n+            interpolator.setInterpolatedTime(lastTime);\n+            System.arraycopy(interpolator.getInterpolatedState(), 0,\n+                             lastState, 0, lastState.length);\n+            System.arraycopy(interpolator.getInterpolatedDerivatives(), 0,\n+                             lastDerivatives, 0, lastDerivatives.length);\n+\n+            nextTime  += h;\n+            nextInStep = forward ^ (nextTime > interpolator.getCurrentTime());\n+\n+        }\n+\n+        if (isLast) {\n+            // there will be no more steps,\n+            // the stored one should be flagged as being the last\n+            handler.handleStep(lastTime, lastState, lastDerivatives, true);\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n+\n+/** \n+ * This interface represents an optimization algorithm for {@link DifferentiableMultivariateRealFunction\n+ * scalar differentiable objective functions}.\n+ * <p>Optimization algorithms find the input point set that either {@link GoalType\n+ * maximize or minimize} an objective function.</p>\n+ * @see MultivariateRealOptimizer\n+ * @see DifferentiableMultivariateVectorialOptimizer\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface DifferentiableMultivariateRealOptimizer {\n+\n+    /** Set the maximal number of iterations of the algorithm.\n+     * @param maxIterations maximal number of function calls\n+     */\n+    void setMaxIterations(int maxIterations);\n+\n+    /** Get the maximal number of iterations of the algorithm.\n+     * @return maximal number of iterations\n+     */\n+    int getMaxIterations();\n+\n+    /** Get the number of iterations realized by the algorithm.\n+     * <p>\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(DifferentiableMultivariateRealFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of iterations\n+     */\n+    int getIterations();\n+\n+    /** Set the maximal number of functions evaluations.\n+     * @param maxEvaluations maximal number of function evaluations\n+     */\n+    void setMaxEvaluations(int maxEvaluations);\n+\n+    /** Get the maximal number of functions evaluations.\n+     * @return maximal number of functions evaluations\n+     */\n+    int getMaxEvaluations();\n+\n+    /** Get the number of evaluations of the objective function.\n+     * <p>\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(DifferentiableMultivariateRealFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the objective function\n+     */\n+    int getEvaluations();\n+\n+    /** Get the number of evaluations of the objective function gradient.\n+     * <p>\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(DifferentiableMultivariateRealFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the objective function gradient\n+     */\n+    int getGradientEvaluations();\n+\n+    /** Set the convergence checker.\n+     * @param checker object to use to check for convergence\n+     */\n+    void setConvergenceChecker(RealConvergenceChecker checker);\n+\n+    /** Get the convergence checker.\n+     * @return object used to check for convergence\n+     */\n+    RealConvergenceChecker getConvergenceChecker();\n+\n+    /** Optimizes an objective function.\n+     * @param f objective function\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param startPoint the start point for optimization\n+     * @return the point/value pair giving the optimal value for objective function\n+     * @exception FunctionEvaluationException if the objective function throws one during\n+     * the search\n+     * @exception OptimizationException if the algorithm failed to converge\n+     * @exception IllegalArgumentException if the start point dimension is wrong\n+     */\n+    RealPointValuePair optimize(DifferentiableMultivariateRealFunction f,\n+                                  GoalType goalType,\n+                                  double[] startPoint)\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/DifferentiableMultivariateVectorialOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n+\n+/** \n+ * This interface represents an optimization algorithm for {@link DifferentiableMultivariateVectorialFunction\n+ * vectorial differentiable objective functions}.\n+ * <p>Optimization algorithms find the input point set that either {@link GoalType\n+ * maximize or minimize} an objective function.</p>\n+ * @see MultivariateRealOptimizer\n+ * @see DifferentiableMultivariateRealOptimizer\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface DifferentiableMultivariateVectorialOptimizer {\n+\n+    /** Set the maximal number of iterations of the algorithm.\n+     * @param maxIterations maximal number of function calls\n+     * .\n+     */\n+    void setMaxIterations(int maxIterations);\n+\n+    /** Get the maximal number of iterations of the algorithm.\n+      * @return maximal number of iterations\n+     */\n+    int getMaxIterations();\n+\n+    /** Get the number of iterations realized by the algorithm.\n+     * @return number of iterations\n+    */\n+   int getIterations();\n+\n+   /** Set the maximal number of functions evaluations.\n+    * @param maxEvaluations maximal number of function evaluations\n+    */\n+   void setMaxEvaluations(int maxEvaluations);\n+\n+   /** Get the maximal number of functions evaluations.\n+    * @return maximal number of functions evaluations\n+    */\n+   int getMaxEvaluations();\n+\n+    /** Get the number of evaluations of the objective function.\n+     * <p>\n+     * The number of evaluation correspond to the last call to the\n+     * {@link #optimize(DifferentiableMultivariateVectorialFunction,\n+     * double[], double[], double[]) optimize} method. It is 0 if\n+     * the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the objective function\n+     */\n+    int getEvaluations();\n+\n+    /** Get the number of evaluations of the objective function jacobian .\n+     * <p>\n+     * The number of evaluation correspond to the last call to the\n+     * {@link #optimize(DifferentiableMultivariateVectorialFunction,\n+     * double[], double[], double[]) optimize} method. It is 0 if\n+     * the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the objective function jacobian\n+     */\n+    int getJacobianEvaluations();\n+\n+    /** Set the convergence checker.\n+     * @param checker object to use to check for convergence\n+     */\n+    void setConvergenceChecker(VectorialConvergenceChecker checker);\n+\n+    /** Get the convergence checker.\n+     * @return object used to check for convergence\n+     */\n+    VectorialConvergenceChecker getConvergenceChecker();\n+\n+    /** Optimizes an objective function.\n+     * <p>\n+     * Optimization is considered to be a weighted least-squares minimization.\n+     * The cost function to be minimized is\n+     * &sum;weight<sub>i</sub>(objective<sub>i</sub>-target<sub>i</sub>)<sup>2</sup>\n+     * </p>\n+     * @param f objective function\n+     * @param target target value for the objective functions at optimum\n+     * @param weights weight for the least squares cost computation\n+     * @param startPoint the start point for optimization\n+     * @return the point/value pair giving the optimal value for objective function\n+     * @exception FunctionEvaluationException if the objective function throws one during\n+     * the search\n+     * @exception OptimizationException if the algorithm failed to converge\n+     * @exception IllegalArgumentException if the start point dimension is wrong\n+     */\n+    VectorialPointValuePair optimize(DifferentiableMultivariateVectorialFunction f,\n+                                     double[] target, double[] weights,\n+                                     double[] startPoint)\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/GoalType.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.io.Serializable;\n+\n+/** \n+ * Goal type for an optimization problem.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public enum GoalType implements Serializable {\n+\n+    /** Maximization goal. */\n+    MAXIMIZE,\n+\n+    /** Minimization goal. */\n+    MINIMIZE\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+import org.apache.commons.math.linear.RealMatrix;\n+\n+/** This class converts {@link MultivariateVectorialFunction vectorial\n+ * objective functions} to {@link MultivariateRealFunction scalar objective functions}\n+ * when the goal is to minimize them.\n+ * <p>\n+ * This class is mostly used when the vectorial objective function represents\n+ * a theoretical result computed from a point set applied to a model and\n+ * the models point must be adjusted to fit the theoretical result to some\n+ * reference observations. The observations may be obtained for example from\n+ * physical measurements whether the model is built from theoretical\n+ * considerations.\n+ * </p>\n+ * <p>\n+ * This class computes a possibly weighted squared sum of the residuals, which is\n+ * a scalar value. The residuals are the difference between the theoretical model\n+ * (i.e. the output of the vectorial objective function) and the observations. The\n+ * class implements the {@link MultivariateRealFunction} interface and can therefore be\n+ * minimized by any optimizer supporting scalar objectives functions.This is one way\n+ * to perform a least square estimation. There are other ways to do this without using\n+ * this converter, as some optimization algorithms directly support vectorial objective\n+ * functions.\n+ * </p>\n+ * <p>\n+ * This class support combination of residuals with or without weights and correlations.\n+ * </p>\n+  *\n+ * @see MultivariateRealFunction\n+ * @see MultivariateVectorialFunction\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+\n+public class LeastSquaresConverter implements MultivariateRealFunction {\n+\n+    /** Underlying vectorial function. */\n+    private final MultivariateVectorialFunction function;\n+\n+    /** Observations to be compared to objective function to compute residuals. */\n+    private final double[] observations;\n+\n+    /** Optional weights for the residuals. */\n+    private final double[] weights;\n+\n+    /** Optional scaling matrix (weight and correlations) for the residuals. */\n+    private final RealMatrix scale;\n+\n+    /** Build a simple converter for uncorrelated residuals with the same weight.\n+     * @param function vectorial residuals function to wrap\n+     * @param observations observations to be compared to objective function to compute residuals\n+     */\n+    public LeastSquaresConverter(final MultivariateVectorialFunction function,\n+                                 final double[] observations) {\n+        this.function     = function;\n+        this.observations = observations.clone();\n+        this.weights      = null;\n+        this.scale        = null;\n+    }\n+\n+    /** Build a simple converter for uncorrelated residuals with the specific weights.\n+     * <p>\n+     * The scalar objective function value is computed as:\n+     * <pre>\n+     * objective = &sum;weight<sub>i</sub>(observation<sub>i</sub>-objective<sub>i</sub>)<sup>2</sup>\n+     * </pre>\n+     * </p>\n+     * <p>\n+     * Weights can be used for example to combine residuals with different standard\n+     * deviations. As an example, consider a residuals array in which even elements\n+     * are angular measurements in degrees with a 0.01&deg; standard deviation and\n+     * odd elements are distance measurements in meters with a 15m standard deviation.\n+     * In this case, the weights array should be initialized with value\n+     * 1.0/(0.01<sup>2</sup>) in the even elements and 1.0/(15.0<sup>2</sup>) in the\n+     * odd elements (i.e. reciprocals of variances). \n+     * </p>\n+     * <p>\n+     * The array computed by the objective function, the observations array and the\n+     * weights array must have consistent sizes or a {@link FunctionEvaluationException} will be\n+     * triggered while computing the scalar objective.\n+     * </p>\n+     * @param function vectorial residuals function to wrap\n+     * @param observations observations to be compared to objective function to compute residuals\n+     * @param weights weights to apply to the residuals\n+     * @exception IllegalArgumentException if the observations vector and the weights\n+     * vector dimensions don't match (objective function dimension is checked only when\n+     * the {@link #value(double[])} method is called)\n+     */\n+    public LeastSquaresConverter(final MultivariateVectorialFunction function,\n+                                 final double[] observations, final double[] weights)\n+        throws IllegalArgumentException {\n+        if (observations.length != weights.length) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"dimension mismatch {0} != {1}\",\n+                    observations.length, weights.length);\n+        }\n+        this.function     = function;\n+        this.observations = observations.clone();\n+        this.weights      = weights.clone();\n+        this.scale        = null;\n+    }\n+\n+    /** Build a simple converter for correlated residuals with the specific weights.\n+     * <p>\n+     * The scalar objective function value is computed as:\n+     * <pre>\n+     * objective = y<sup>T</sup>y with y = scale&times;(observation-objective)\n+     * </pre>\n+     * </p>\n+     * <p>\n+     * The array computed by the objective function, the observations array and the\n+     * the scaling matrix must have consistent sizes or a {@link FunctionEvaluationException}\n+     * will be triggered while computing the scalar objective.\n+     * </p>\n+     * @param function vectorial residuals function to wrap\n+     * @param observations observations to be compared to objective function to compute residuals\n+     * @param scale scaling matrix\n+     * @exception IllegalArgumentException if the observations vector and the scale\n+     * matrix dimensions don't match (objective function dimension is checked only when\n+     * the {@link #value(double[])} method is called)\n+     */\n+    public LeastSquaresConverter(final MultivariateVectorialFunction function,\n+                                 final double[] observations, final RealMatrix scale)\n+        throws IllegalArgumentException {\n+        if (observations.length != scale.getColumnDimension()) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"dimension mismatch {0} != {1}\",\n+                    observations.length, scale.getColumnDimension());\n+        }\n+        this.function     = function;\n+        this.observations = observations.clone();\n+        this.weights      = null;\n+        this.scale        = scale.copy();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double value(final double[] point) throws FunctionEvaluationException {\n+\n+        // compute residuals\n+        final double[] residuals = function.value(point);\n+        if (residuals.length != observations.length) {\n+            throw new FunctionEvaluationException(point, \"dimension mismatch {0} != {1}\",\n+                                                  residuals.length, observations.length);\n+        }\n+        for (int i = 0; i < residuals.length; ++i) {\n+            residuals[i] -= observations[i];\n+        }\n+\n+        // compute sum of squares\n+        double sumSquares = 0;\n+        if (weights != null) {\n+            for (int i = 0; i < residuals.length; ++i) {\n+                final double ri = residuals[i];\n+                sumSquares +=  weights[i] * ri * ri;\n+            }\n+        } else if (scale != null) {\n+            for (final double yi : scale.operate(residuals)) {\n+                sumSquares += yi * yi;\n+            }\n+        } else {\n+            for (final double ri : residuals) {\n+                sumSquares += ri * ri;\n+            }\n+        }\n+\n+        return sumSquares;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+\n+/** \n+ * Special implementation of the {@link DifferentiableMultivariateRealOptimizer} interface adding\n+ * multi-start features to an existing optimizer.\n+ * <p>\n+ * This class wraps a classical optimizer to use it several times in\n+ * turn with different starting points in order to avoid being trapped\n+ * into a local extremum when looking for a global one.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class MultiStartDifferentiableMultivariateRealOptimizer\n+    implements DifferentiableMultivariateRealOptimizer {\n+\n+    /** Underlying classical optimizer. */\n+    private final DifferentiableMultivariateRealOptimizer optimizer;\n+\n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Number of iterations already performed for all starts. */\n+    private int totalIterations;\n+\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n+    /** Number of evaluations already performed for all starts. */\n+    private int totalEvaluations;\n+\n+    /** Number of gradient evaluations already performed for all starts. */\n+    private int totalGradientEvaluations;\n+\n+    /** Number of starts to go. */\n+    private int starts;\n+\n+    /** Random generator for multi-start. */\n+    private RandomVectorGenerator generator;\n+\n+    /** Found optima. */\n+    private RealPointValuePair[] optima;\n+\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer\n+     * @param optimizer single-start optimizer to wrap\n+     * @param starts number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1\n+     * @param generator random vector generator to use for restarts\n+     */\n+    public MultiStartDifferentiableMultivariateRealOptimizer(final DifferentiableMultivariateRealOptimizer optimizer,\n+                                                             final int starts,\n+                                                             final RandomVectorGenerator generator) {\n+        this.optimizer                = optimizer;\n+        this.totalIterations          = 0;\n+        this.totalEvaluations         = 0;\n+        this.totalGradientEvaluations = 0;\n+        this.starts                   = starts;\n+        this.generator                = generator;\n+        this.optima                   = null;\n+        setMaxIterations(Integer.MAX_VALUE);\n+        setMaxEvaluations(Integer.MAX_VALUE);\n+    }\n+\n+    /** Get all the optima found during the last call to {@link\n+     * #optimize(DifferentiableMultivariateRealFunction, GoalType, double[])\n+     * optimize}.\n+     * <p>The optimizer stores all the optima found during a set of\n+     * restarts. The {@link #optimize(DifferentiableMultivariateRealFunction,\n+     * GoalType, double[]) optimize} method returns the best point only. This\n+     * method returns all the points found at the end of each starts,\n+     * including the best one already returned by the {@link\n+     * #optimize(DifferentiableMultivariateRealFunction, GoalType, double[])\n+     * optimize} method.\n+     * </p>\n+     * <p>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e in ascending order if minimizing and in\n+     * descending order if maximizing), followed by and null elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be null if the {@link #optimize(DifferentiableMultivariateRealFunction,\n+     * GoalType, double[]) optimize} method did throw a {@link\n+     * ConvergenceException ConvergenceException}). This also means that\n+     * if the first element is non null, it is the best point found across\n+     * all starts.</p>\n+     * @return array containing the optima\n+     * @exception IllegalStateException if {@link #optimize(DifferentiableMultivariateRealFunction,\n+     * GoalType, double[]) optimize} has not been called\n+     */\n+    public RealPointValuePair[] getOptima() throws IllegalStateException {\n+        if (optima == null) {\n+            throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n+        }\n+        return optima.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxIterations(int maxIterations) {\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() {\n+        return totalIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return totalEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getGradientEvaluations() {\n+        return totalGradientEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(RealConvergenceChecker checker) {\n+        optimizer.setConvergenceChecker(checker);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealConvergenceChecker getConvergenceChecker() {\n+        return optimizer.getConvergenceChecker();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealPointValuePair optimize(final DifferentiableMultivariateRealFunction f,\n+                                         final GoalType goalType,\n+                                         double[] startPoint)\n+        throws FunctionEvaluationException, OptimizationException {\n+\n+        optima                   = new RealPointValuePair[starts];\n+        totalIterations          = 0;\n+        totalEvaluations         = 0;\n+        totalGradientEvaluations = 0;\n+\n+        // multi-start loop\n+        for (int i = 0; i < starts; ++i) {\n+\n+            try {\n+                optimizer.setMaxIterations(maxIterations - totalIterations);\n+                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n+                optima[i] = optimizer.optimize(f, goalType,\n+                                               (i == 0) ? startPoint : generator.nextVector());\n+            } catch (FunctionEvaluationException fee) {\n+                optima[i] = null;\n+            } catch (OptimizationException oe) {\n+                optima[i] = null;\n+            }\n+\n+            totalIterations          += optimizer.getIterations();\n+            totalEvaluations         += optimizer.getEvaluations();\n+            totalGradientEvaluations += optimizer.getGradientEvaluations();\n+\n+        }\n+\n+        // sort the optima from best to worst, followed by null elements\n+        Arrays.sort(optima, new Comparator<RealPointValuePair>() {\n+            public int compare(final RealPointValuePair o1, final RealPointValuePair o2) {\n+                if (o1 == null) {\n+                    return (o2 == null) ? 0 : +1;\n+                } else if (o2 == null) {\n+                    return -1;\n+                }\n+                final double v1 = o1.getValue();\n+                final double v2 = o2.getValue();\n+                return (goalType == GoalType.MINIMIZE) ?\n+                        Double.compare(v1, v2) : Double.compare(v2, v1);\n+            }\n+        });\n+\n+        if (optima[0] == null) {\n+            throw new OptimizationException(\n+                    \"none of the {0} start points lead to convergence\",\n+                    starts);\n+        }\n+\n+        // return the found point given the best objective function value\n+        return optima[0];\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartDifferentiableMultivariateVectorialOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+\n+/** \n+ * Special implementation of the {@link DifferentiableMultivariateVectorialOptimizer} interface adding\n+ * multi-start features to an existing optimizer.\n+ * <p>\n+ * This class wraps a classical optimizer to use it several times in\n+ * turn with different starting points in order to avoid being trapped\n+ * into a local extremum when looking for a global one.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class MultiStartDifferentiableMultivariateVectorialOptimizer\n+    implements DifferentiableMultivariateVectorialOptimizer {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 9206382258980561530L;\n+\n+    /** Underlying classical optimizer. */\n+    private final DifferentiableMultivariateVectorialOptimizer optimizer;\n+\n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Number of iterations already performed for all starts. */\n+    private int totalIterations;\n+\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n+    /** Number of evaluations already performed for all starts. */\n+    private int totalEvaluations;\n+\n+    /** Number of jacobian evaluations already performed for all starts. */\n+    private int totalJacobianEvaluations;\n+\n+    /** Number of starts to go. */\n+    private int starts;\n+\n+    /** Random generator for multi-start. */\n+    private RandomVectorGenerator generator;\n+\n+    /** Found optima. */\n+    private VectorialPointValuePair[] optima;\n+\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer\n+     * @param optimizer single-start optimizer to wrap\n+     * @param starts number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1\n+     * @param generator random vector generator to use for restarts\n+     */\n+    public MultiStartDifferentiableMultivariateVectorialOptimizer(\n+                final DifferentiableMultivariateVectorialOptimizer optimizer,\n+                final int starts,\n+                final RandomVectorGenerator generator) {\n+        this.optimizer                = optimizer;\n+        this.totalIterations          = 0;\n+        this.totalEvaluations         = 0;\n+        this.totalJacobianEvaluations = 0;\n+        this.starts                   = starts;\n+        this.generator                = generator;\n+        this.optima                   = null;\n+        setMaxIterations(Integer.MAX_VALUE);\n+        setMaxEvaluations(Integer.MAX_VALUE);\n+    }\n+\n+    /** Get all the optima found during the last call to {@link\n+     * #optimize(DifferentiableMultivariateVectorialFunction,\n+     * double[], double[], double[]) optimize}.\n+     * <p>The optimizer stores all the optima found during a set of\n+     * restarts. The {@link #optimize(DifferentiableMultivariateVectorialFunction,\n+     * double[], double[], double[]) optimize} method returns the\n+     * best point only. This method returns all the points found at the\n+     * end of each starts, including the best one already returned by the {@link\n+     * #optimize(DifferentiableMultivariateVectorialFunction, double[],\n+     * double[], double[]) optimize} method.\n+     * </p>\n+     * <p>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e in ascending order if minimizing and in\n+     * descending order if maximizing), followed by and null elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be null if the {@link #optimize(DifferentiableMultivariateVectorialFunction,\n+     * double[], double[], double[]) optimize} method did throw a {@link\n+     * ConvergenceException ConvergenceException}). This also means that\n+     * if the first element is non null, it is the best point found across\n+     * all starts.</p>\n+     * @return array containing the optima\n+     * @exception IllegalStateException if {@link #optimize(DifferentiableMultivariateVectorialFunction,\n+     * double[], double[], double[]) optimize} has not been called\n+     */\n+    public VectorialPointValuePair[] getOptima() throws IllegalStateException {\n+        if (optima == null) {\n+            throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n+        }\n+        return optima.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxIterations(int maxIterations) {\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() {\n+        return totalIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return totalEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getJacobianEvaluations() {\n+        return totalJacobianEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(VectorialConvergenceChecker checker) {\n+        optimizer.setConvergenceChecker(checker);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public VectorialConvergenceChecker getConvergenceChecker() {\n+        return optimizer.getConvergenceChecker();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f,\n+                                            final double[] target, final double[] weights,\n+                                            final double[] startPoint)\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+\n+        optima                   = new VectorialPointValuePair[starts];\n+        totalIterations          = 0;\n+        totalEvaluations         = 0;\n+        totalJacobianEvaluations = 0;\n+\n+        // multi-start loop\n+        for (int i = 0; i < starts; ++i) {\n+\n+            try {\n+                optimizer.setMaxIterations(maxIterations - totalIterations);\n+                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n+                optima[i] = optimizer.optimize(f, target, weights,\n+                                               (i == 0) ? startPoint : generator.nextVector());\n+            } catch (FunctionEvaluationException fee) {\n+                optima[i] = null;\n+            } catch (OptimizationException oe) {\n+                optima[i] = null;\n+            }\n+\n+            totalIterations          += optimizer.getIterations();\n+            totalEvaluations         += optimizer.getEvaluations();\n+            totalJacobianEvaluations += optimizer.getJacobianEvaluations();\n+\n+        }\n+\n+        // sort the optima from best to worst, followed by null elements\n+        Arrays.sort(optima, new Comparator<VectorialPointValuePair>() {\n+            public int compare(final VectorialPointValuePair o1, final VectorialPointValuePair o2) {\n+                if (o1 == null) {\n+                    return (o2 == null) ? 0 : +1;\n+                } else if (o2 == null) {\n+                    return -1;\n+                }\n+                return Double.compare(weightedResidual(o1), weightedResidual(o2));\n+            }\n+            private double weightedResidual(final VectorialPointValuePair pv) {\n+                final double[] value = pv.getValueRef();\n+                double sum = 0;\n+                for (int i = 0; i < value.length; ++i) {\n+                    final double ri = value[i] - target[i];\n+                    sum += weights[i] * ri * ri;\n+                }\n+                return sum;\n+            }\n+        });\n+\n+        if (optima[0] == null) {\n+            throw new OptimizationException(\n+                    \"none of the {0} start points lead to convergence\",\n+                    starts);\n+        }\n+\n+        // return the found point given the best objective function value\n+        return optima[0];\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartMultivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.random.RandomVectorGenerator;\n+\n+/** \n+ * Special implementation of the {@link MultivariateRealOptimizer} interface adding\n+ * multi-start features to an existing optimizer.\n+ * <p>\n+ * This class wraps a classical optimizer to use it several times in\n+ * turn with different starting points in order to avoid being trapped\n+ * into a local extremum when looking for a global one.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class MultiStartMultivariateRealOptimizer\n+    implements MultivariateRealOptimizer {\n+\n+    /** Underlying classical optimizer. */\n+    private final MultivariateRealOptimizer optimizer;\n+\n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n+    /** Number of iterations already performed for all starts. */\n+    private int totalIterations;\n+\n+    /** Number of evaluations already performed for all starts. */\n+    private int totalEvaluations;\n+\n+    /** Number of starts to go. */\n+    private int starts;\n+\n+    /** Random generator for multi-start. */\n+    private RandomVectorGenerator generator;\n+\n+    /** Found optima. */\n+    private RealPointValuePair[] optima;\n+\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer\n+     * @param optimizer single-start optimizer to wrap\n+     * @param starts number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1\n+     * @param generator random vector generator to use for restarts\n+     */\n+    public MultiStartMultivariateRealOptimizer(final MultivariateRealOptimizer optimizer,\n+                                               final int starts,\n+                                               final RandomVectorGenerator generator) {\n+        this.optimizer        = optimizer;\n+        this.totalIterations  = 0;\n+        this.totalEvaluations = 0;\n+        this.starts           = starts;\n+        this.generator        = generator;\n+        this.optima           = null;\n+        setMaxIterations(Integer.MAX_VALUE);\n+        setMaxEvaluations(Integer.MAX_VALUE);\n+    }\n+\n+    /** Get all the optima found during the last call to {@link\n+     * #optimize(MultivariateRealFunction, GoalType, double[]) optimize}.\n+     * <p>The optimizer stores all the optima found during a set of\n+     * restarts. The {@link #optimize(MultivariateRealFunction, GoalType,\n+     * double[]) optimize} method returns the best point only. This\n+     * method returns all the points found at the end of each starts,\n+     * including the best one already returned by the {@link\n+     * #optimize(MultivariateRealFunction, GoalType, double[]) optimize}\n+     * method.\n+     * </p>\n+     * <p>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e in ascending order if minimizing and in\n+     * descending order if maximizing), followed by and null elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be null if the {@link #optimize(MultivariateRealFunction,\n+     * GoalType, double[]) optimize} method did throw a {@link\n+     * ConvergenceException ConvergenceException}). This also means that\n+     * if the first element is non null, it is the best point found across\n+     * all starts.</p>\n+     * @return array containing the optima\n+     * @exception IllegalStateException if {@link #optimize(MultivariateRealFunction,\n+     * GoalType, double[]) optimize} has not been called\n+     */\n+    public RealPointValuePair[] getOptima() throws IllegalStateException {\n+        if (optima == null) {\n+            throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n+        }\n+        return optima.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxIterations(int maxIterations) {\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() {\n+        return totalIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return totalEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(RealConvergenceChecker checker) {\n+        optimizer.setConvergenceChecker(checker);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealConvergenceChecker getConvergenceChecker() {\n+        return optimizer.getConvergenceChecker();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealPointValuePair optimize(final MultivariateRealFunction f,\n+                                         final GoalType goalType,\n+                                         double[] startPoint)\n+        throws FunctionEvaluationException, OptimizationException {\n+\n+        optima           = new RealPointValuePair[starts];\n+        totalIterations  = 0;\n+        totalEvaluations = 0;\n+\n+        // multi-start loop\n+        for (int i = 0; i < starts; ++i) {\n+\n+            try {\n+                optimizer.setMaxIterations(maxIterations - totalIterations);\n+                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n+                optima[i] = optimizer.optimize(f, goalType,\n+                                               (i == 0) ? startPoint : generator.nextVector());\n+            } catch (FunctionEvaluationException fee) {\n+                optima[i] = null;\n+            } catch (OptimizationException oe) {\n+                optima[i] = null;\n+            }\n+\n+            totalIterations  += optimizer.getIterations();\n+            totalEvaluations += optimizer.getEvaluations();\n+\n+        }\n+\n+        // sort the optima from best to worst, followed by null elements\n+        Arrays.sort(optima, new Comparator<RealPointValuePair>() {\n+            public int compare(final RealPointValuePair o1, final RealPointValuePair o2) {\n+                if (o1 == null) {\n+                    return (o2 == null) ? 0 : +1;\n+                } else if (o2 == null) {\n+                    return -1;\n+                }\n+                final double v1 = o1.getValue();\n+                final double v2 = o2.getValue();\n+                return (goalType == GoalType.MINIMIZE) ?\n+                        Double.compare(v1, v2) : Double.compare(v2, v1);\n+            }\n+        });\n+\n+        if (optima[0] == null) {\n+            throw new OptimizationException(\n+                    \"none of the {0} start points lead to convergence\",\n+                    starts);\n+        }\n+\n+        // return the found point given the best objective function value\n+        return optima[0];\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/MultiStartUnivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.random.RandomGenerator;\n+\n+/** \n+ * Special implementation of the {@link UnivariateRealOptimizer} interface adding\n+ * multi-start features to an existing optimizer.\n+ * <p>\n+ * This class wraps a classical optimizer to use it several times in\n+ * turn with different starting points in order to avoid being trapped\n+ * into a local extremum when looking for a global one.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class MultiStartUnivariateRealOptimizer implements UnivariateRealOptimizer {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 5983375963110961019L;\n+\n+    /** Underlying classical optimizer. */\n+    private final UnivariateRealOptimizer optimizer;\n+\n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n+    /** Number of iterations already performed for all starts. */\n+    private int totalIterations;\n+\n+    /** Number of evaluations already performed for all starts. */\n+    private int totalEvaluations;\n+\n+    /** Number of starts to go. */\n+    private int starts;\n+\n+    /** Random generator for multi-start. */\n+    private RandomGenerator generator;\n+\n+    /** Found optima. */\n+    private double[] optima;\n+\n+    /** Found function values at optima. */\n+    private double[] optimaValues;\n+\n+    /**\n+     * Create a multi-start optimizer from a single-start optimizer\n+     * @param optimizer single-start optimizer to wrap\n+     * @param starts number of starts to perform (including the\n+     * first one), multi-start is disabled if value is less than or\n+     * equal to 1\n+     * @param generator random generator to use for restarts\n+     */\n+    public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer,\n+                                             final int starts,\n+                                             final RandomGenerator generator) {\n+        this.optimizer        = optimizer;\n+        this.totalIterations  = 0;\n+        this.starts           = starts;\n+        this.generator        = generator;\n+        this.optima           = null;\n+        setMaximalIterationCount(Integer.MAX_VALUE);\n+        setMaxEvaluations(Integer.MAX_VALUE);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getFunctionValue() {\n+        return optimizer.getFunctionValue();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getResult() {\n+        return optimizer.getResult();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getAbsoluteAccuracy() {\n+        return optimizer.getAbsoluteAccuracy();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterationCount() {\n+        return totalIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaximalIterationCount() {\n+        return maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return totalEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getRelativeAccuracy() {\n+        return optimizer.getRelativeAccuracy();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void resetAbsoluteAccuracy() {\n+        optimizer.resetAbsoluteAccuracy();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void resetMaximalIterationCount() {\n+        optimizer.resetMaximalIterationCount();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void resetRelativeAccuracy() {\n+        optimizer.resetRelativeAccuracy();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setAbsoluteAccuracy(double accuracy) {\n+        optimizer.setAbsoluteAccuracy(accuracy);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaximalIterationCount(int count) {\n+        this.maxIterations = count;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setRelativeAccuracy(double accuracy) {\n+        optimizer.setRelativeAccuracy(accuracy);\n+    }\n+\n+    /** Get all the optima found during the last call to {@link\n+     * #optimize(UnivariateRealFunction, GoalType, double, double) optimize}.\n+     * <p>The optimizer stores all the optima found during a set of\n+     * restarts. The {@link #optimize(UnivariateRealFunction, GoalType,\n+     * double, double) optimize} method returns the best point only. This\n+     * method returns all the points found at the end of each starts,\n+     * including the best one already returned by the {@link\n+     * #optimize(UnivariateRealFunction, GoalType, double, double) optimize}\n+     * method.\n+     * </p>\n+     * <p>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e in ascending order if minimizing and in\n+     * descending order if maximizing), followed by Double.NaN elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be NaN if the {@link #optimize(UnivariateRealFunction,\n+     * GoalType, double, double) optimize} method did throw a {@link\n+     * ConvergenceException ConvergenceException}). This also means that\n+     * if the first element is not NaN, it is the best point found across\n+     * all starts.</p>\n+     * @return array containing the optima\n+     * @exception IllegalStateException if {@link #optimize(UnivariateRealFunction,\n+     * GoalType, double, double) optimize} has not been called\n+     * @see #getOptimaValues()\n+     */\n+    public double[] getOptima() throws IllegalStateException {\n+        if (optima == null) {\n+            throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n+        }\n+        return optima.clone();\n+    }\n+\n+    /** Get all the function values at optima found during the last call to {@link\n+     * #optimize(UnivariateRealFunction, GoalType, double, double) optimize}.\n+     * <p>\n+     * The returned array as one element for each start as specified\n+     * in the constructor. It is ordered with the results from the\n+     * runs that did converge first, sorted from best to worst\n+     * objective value (i.e in ascending order if minimizing and in\n+     * descending order if maximizing), followed by Double.NaN elements\n+     * corresponding to the runs that did not converge. This means all\n+     * elements will be NaN if the {@link #optimize(UnivariateRealFunction,\n+     * GoalType, double, double) optimize} method did throw a {@link\n+     * ConvergenceException ConvergenceException}). This also means that\n+     * if the first element is not NaN, it is the best point found across\n+     * all starts.</p>\n+     * @return array containing the optima\n+     * @exception IllegalStateException if {@link #optimize(UnivariateRealFunction,\n+     * GoalType, double, double) optimize} has not been called\n+     * @see #getOptima()\n+     */\n+    public double[] getOptimaValues() throws IllegalStateException {\n+        if (optimaValues == null) {\n+            throw MathRuntimeException.createIllegalStateException(\"no optimum computed yet\");\n+        }\n+        return optimaValues.clone();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n+                           final double min, final double max)\n+        throws ConvergenceException,\n+            FunctionEvaluationException {\n+\n+        optima           = new double[starts];\n+        optimaValues     = new double[starts];\n+        totalIterations  = 0;\n+        totalEvaluations = 0;\n+\n+        // multi-start loop\n+        for (int i = 0; i < starts; ++i) {\n+\n+            try {\n+                optimizer.setMaximalIterationCount(maxIterations - totalIterations);\n+                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n+                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n+                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n+                optima[i]       = optimizer.optimize(f, goalType,\n+                                                     Math.min(bound1, bound2),\n+                                                     Math.max(bound1, bound2));\n+                optimaValues[i] = optimizer.getFunctionValue();\n+            } catch (FunctionEvaluationException fee) {\n+                optima[i]       = Double.NaN;\n+                optimaValues[i] = Double.NaN;\n+            } catch (ConvergenceException ce) {\n+                optima[i]       = Double.NaN;\n+                optimaValues[i] = Double.NaN;\n+            }\n+\n+            totalIterations  += optimizer.getIterationCount();\n+            totalEvaluations += optimizer.getEvaluations();\n+\n+        }\n+\n+        // sort the optima from best to worst, followed by NaN elements\n+        int lastNaN = optima.length;\n+        for (int i = 0; i < lastNaN; ++i) {\n+            if (Double.isNaN(optima[i])) {\n+                optima[i] = optima[--lastNaN];\n+                optima[lastNaN + 1] = Double.NaN;\n+                optimaValues[i] = optimaValues[--lastNaN];\n+                optimaValues[lastNaN + 1] = Double.NaN;\n+            }\n+        }\n+\n+        double currX = optima[0];\n+        double currY = optimaValues[0];\n+        for (int j = 1; j < lastNaN; ++j) {\n+            final double prevY = currY;\n+            currX = optima[j];\n+            currY = optimaValues[j];\n+            if ((goalType == GoalType.MAXIMIZE) ^ (currY < prevY)) {\n+                // the current element should be inserted closer to the beginning\n+                int i = j - 1;\n+                double mIX = optima[i];\n+                double mIY = optimaValues[i];\n+                while ((i >= 0) && ((goalType == GoalType.MAXIMIZE) ^ (currY < mIY))) {\n+                    optima[i + 1]       = mIX;\n+                    optimaValues[i + 1] = mIY;\n+                    if (i-- != 0) {\n+                        mIX = optima[i];\n+                        mIY = optimaValues[i];\n+                    } else {\n+                        mIX = Double.NaN;\n+                        mIY = Double.NaN;\n+                    }\n+                }\n+                optima[i + 1]       = currX;\n+                optimaValues[i + 1] = currY;\n+                currX = optima[j];\n+                currY = optimaValues[j];\n+            }\n+        }\n+\n+        if (Double.isNaN(optima[0])) {\n+            throw new OptimizationException(\n+                    \"none of the {0} start points lead to convergence\",\n+                    starts);\n+        }\n+\n+        // return the found point given the best objective function value\n+        return optima[0];\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n+                           final double min, final double max, final double startValue)\n+            throws ConvergenceException, FunctionEvaluationException {\n+        return optimize(f, goalType, min, max);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/MultivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+\n+/** \n+ * This interface represents an optimization algorithm for {@link MultivariateRealFunction\n+ * scalar objective functions}.\n+ * <p>Optimization algorithms find the input point set that either {@link GoalType\n+ * maximize or minimize} an objective function.</p>\n+ * @see DifferentiableMultivariateRealOptimizer\n+ * @see DifferentiableMultivariateVectorialOptimizer\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface MultivariateRealOptimizer {\n+\n+    /** Set the maximal number of iterations of the algorithm.\n+     * @param maxIterations maximal number of algorithm iterations\n+     */\n+    void setMaxIterations(int maxIterations);\n+\n+    /** Get the maximal number of iterations of the algorithm.\n+     * @return maximal number of iterations\n+     */\n+    int getMaxIterations();\n+\n+    /** Set the maximal number of functions evaluations.\n+     * @param maxEvaluations maximal number of function evaluations\n+     */\n+    void setMaxEvaluations(int maxEvaluations);\n+\n+    /** Get the maximal number of functions evaluations.\n+     * @return maximal number of functions evaluations\n+     */\n+    int getMaxEvaluations();\n+\n+    /** Get the number of iterations realized by the algorithm.\n+     * <p>\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(MultivariateRealFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of iterations\n+     */\n+    int getIterations();\n+\n+    /** Get the number of evaluations of the objective function.\n+     * <p>\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(MultivariateRealFunction, GoalType, double[]) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the objective function\n+     */\n+    int getEvaluations();\n+\n+    /** Set the convergence checker.\n+     * @param checker object to use to check for convergence\n+     */\n+    void setConvergenceChecker(RealConvergenceChecker checker);\n+\n+    /** Get the convergence checker.\n+     * @return object used to check for convergence\n+     */\n+    RealConvergenceChecker getConvergenceChecker();\n+\n+    /** Optimizes an objective function.\n+     * @param f objective function\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param startPoint the start point for optimization\n+     * @return the point/value pair giving the optimal value for objective function\n+     * @exception FunctionEvaluationException if the objective function throws one during\n+     * the search\n+     * @exception OptimizationException if the algorithm failed to converge\n+     * @exception IllegalArgumentException if the start point dimension is wrong\n+     */\n+    RealPointValuePair optimize(MultivariateRealFunction f,\n+                                  GoalType goalType,\n+                                  double[] startPoint)\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/OptimizationException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.ConvergenceException;\n+\n+/** \n+ * This class represents exceptions thrown by optimizers.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ *\n+ */\n+\n+public class OptimizationException extends ConvergenceException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -357696069587075016L;\n+\n+    /** \n+     * Simple constructor.\n+     * Build an exception by translating and formating a message\n+     * @param specifier format specifier (to be translated)\n+     * @param parts to insert in the format (no translation)\n+     */\n+    public OptimizationException(String specifier, Object ... parts) {\n+        super(specifier, parts);\n+    }\n+\n+    /**\n+     * Create an exception with a given root cause.\n+     * @param cause  the exception or error that caused this exception to be thrown\n+     */\n+    public OptimizationException(Throwable cause) {\n+        super(cause);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/RealConvergenceChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+/** This interface specifies how to check if an {@link MultivariateRealOptimizer optimization\n+ * algorithm} has converged.\n+ *\n+ * <p>Deciding if convergence has been reached is a problem-dependent issue. The\n+ * user should provide a class implementing this interface to allow the optimization\n+ * algorithm to stop its search according to the problem at hand.</p>\n+ * <p>For convenience, two implementations that fit simple needs are already provided:\n+ * {@link SimpleScalarValueChecker} and {@link SimpleRealPointChecker}. The first\n+ * one considers convergence is reached when the objective function value does not\n+ * change much anymore, it does not use the point set at all. The second one\n+ * considers convergence is reached when the input point set does not change\n+ * much anymore, it does not use objective function value at all.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+\n+public interface RealConvergenceChecker {\n+\n+  /** Check if the optimization algorithm has converged considering the last points.\n+   * <p>\n+   * This method may be called several time from the same algorithm iteration with\n+   * different points. This can be detected by checking the iteration number at each\n+   * call if needed. Each time this method is called, the previous and current point\n+   * correspond to points with the same role at each iteration, so they can be\n+   * compared. As an example, simplex-based algorithms call this method for all\n+   * points of the simplex, not only for the best or worst ones.\n+   * </p>\n+   * @param iteration index of current iteration\n+   * @param previous point from previous iteration\n+   * @param current point from current iteration\n+   * @return true if the algorithm is considered to have converged\n+   */\n+  boolean converged(int iteration, RealPointValuePair previous, RealPointValuePair current);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/RealPointValuePair.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+\n+/** \n+ * This class holds a point and the value of an objective function at this point.\n+ * <p>This is a simple immutable container.</p>\n+ * @see VectorialPointValuePair\n+ * @see MultivariateRealFunction\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class RealPointValuePair implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 1003888396256744753L;\n+\n+    /** Point coordinates. */\n+    private final double[] point;\n+\n+    /** Value of the objective function at the point. */\n+    private final double value;\n+\n+    /** Build a point/objective function value pair.\n+     * @param point point coordinates (the built instance will store\n+     * a copy of the array, not the array passed as argument)\n+     * @param value value of an objective function at the point\n+     */\n+    public RealPointValuePair(final double[] point, final double value) {\n+        this.point = point.clone();\n+        this.value  = value;\n+    }\n+\n+    /** Build a point/objective function value pair.\n+     * @param point point coordinates (the built instance will store\n+     * a copy of the array, not the array passed as argument)\n+     * @param value value of an objective function at the point\n+     * @param copyArray if true, the input array will be copied, otherwise\n+     * it will be referenced\n+     */\n+    public RealPointValuePair(final double[] point, final double value,\n+                                final boolean copyArray) {\n+        this.point = copyArray ? point.clone() : point;\n+        this.value  = value;\n+    }\n+\n+    /** Get the point.\n+     * @return a copy of the stored point\n+     */\n+    public double[] getPoint() {\n+        return point.clone();\n+    }\n+\n+    /** Get a reference to the point.\n+     * <p>This method is provided as a convenience to avoid copying\n+     * the array, the elements of the array should <em>not</em> be modified.</p>\n+     * @return a reference to the internal array storing the point\n+     */\n+    public double[] getPointRef() {\n+        return point;\n+    }\n+\n+    /** Get the value of the objective function.\n+     * @return the stored value of the objective function\n+     */\n+    public double getValue() {\n+        return value;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleRealPointChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.util.MathUtils;\n+\n+/** \n+ * Simple implementation of the {@link RealConvergenceChecker} interface using\n+ * only point coordinates.\n+ * <p>\n+ * Convergence is considered to have been reached if either the relative\n+ * difference between each point coordinate are smaller than a threshold\n+ * or if either the absolute difference between the point coordinates are\n+ * smaller than another threshold.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class SimpleRealPointChecker implements RealConvergenceChecker {\n+\n+    /** Default relative threshold. */\n+    private static final double DEFAULT_RELATIVE_THRESHOLD = 100 * MathUtils.EPSILON;\n+\n+    /** Default absolute threshold. */\n+    private static final double DEFAULT_ABSOLUTE_THRESHOLD = 100 * MathUtils.SAFE_MIN;\n+\n+    /** Relative tolerance threshold. */\n+    private final double relativeThreshold;\n+\n+    /** Absolute tolerance threshold. */\n+    private final double absoluteThreshold;\n+\n+   /** Build an instance with default threshold.\n+     */\n+    public SimpleRealPointChecker() {\n+        this.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\n+        this.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n+    }\n+\n+    /** Build an instance with a specified threshold.\n+     * <p>\n+     * In order to perform only relative checks, the absolute tolerance\n+     * must be set to a negative value. In order to perform only absolute\n+     * checks, the relative tolerance must be set to a negative value.\n+     * </p>\n+     * @param relativeThreshold relative tolerance threshold\n+     * @param absoluteThreshold absolute tolerance threshold\n+     */\n+    public SimpleRealPointChecker(final double relativeThreshold,\n+                                 final double absoluteThreshold) {\n+        this.relativeThreshold = relativeThreshold;\n+        this.absoluteThreshold = absoluteThreshold;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean converged(final int iteration,\n+                             final RealPointValuePair previous,\n+                             final RealPointValuePair current) {\n+        final double[] p        = previous.getPoint();\n+        final double[] c        = current.getPoint();\n+        for (int i = 0; i < p.length; ++i) {\n+            final double difference = Math.abs(p[i] - c[i]);\n+            final double size       = Math.max(Math.abs(p[i]), Math.abs(c[i]));\n+            if ((difference > (size * relativeThreshold)) && (difference > absoluteThreshold)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleScalarValueChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.util.MathUtils;\n+\n+/** \n+ * Simple implementation of the {@link RealConvergenceChecker} interface using\n+ * only objective function values.\n+ * <p>\n+ * Convergence is considered to have been reached if either the relative\n+ * difference between the objective function values is smaller than a\n+ * threshold or if either the absolute difference between the objective\n+ * function values is smaller than another threshold.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class SimpleScalarValueChecker implements RealConvergenceChecker {\n+\n+    /** Default relative threshold. */\n+    private static final double DEFAULT_RELATIVE_THRESHOLD = 100 * MathUtils.EPSILON;\n+\n+    /** Default absolute threshold. */\n+    private static final double DEFAULT_ABSOLUTE_THRESHOLD = 100 * MathUtils.SAFE_MIN;\n+\n+    /** Relative tolerance threshold. */\n+    private final double relativeThreshold;\n+\n+    /** Absolute tolerance threshold. */\n+    private final double absoluteThreshold;\n+\n+   /** Build an instance with default threshold.\n+     */\n+    public SimpleScalarValueChecker() {\n+        this.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\n+        this.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n+    }\n+\n+    /** Build an instance with a specified threshold.\n+     * <p>\n+     * In order to perform only relative checks, the absolute tolerance\n+     * must be set to a negative value. In order to perform only absolute\n+     * checks, the relative tolerance must be set to a negative value.\n+     * </p>\n+     * @param relativeThreshold relative tolerance threshold\n+     * @param absoluteThreshold absolute tolerance threshold\n+     */\n+    public SimpleScalarValueChecker(final double relativeThreshold,\n+                                 final double absoluteThreshold) {\n+        this.relativeThreshold = relativeThreshold;\n+        this.absoluteThreshold = absoluteThreshold;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean converged(final int iteration,\n+                             final RealPointValuePair previous,\n+                             final RealPointValuePair current) {\n+        final double p          = previous.getValue();\n+        final double c          = current.getValue();\n+        final double difference = Math.abs(p - c);\n+        final double size       = Math.max(Math.abs(p), Math.abs(c));\n+        return (difference <= (size * relativeThreshold)) || (difference <= absoluteThreshold);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleVectorialPointChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.util.MathUtils;\n+\n+/** \n+ * Simple implementation of the {@link VectorialConvergenceChecker} interface using\n+ * only point coordinates.\n+ * <p>\n+ * Convergence is considered to have been reached if either the relative\n+ * difference between each point coordinate are smaller than a threshold\n+ * or if either the absolute difference between the point coordinates are\n+ * smaller than another threshold.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class SimpleVectorialPointChecker implements VectorialConvergenceChecker {\n+\n+    /** Default relative threshold. */\n+    private static final double DEFAULT_RELATIVE_THRESHOLD = 100 * MathUtils.EPSILON;\n+\n+    /** Default absolute threshold. */\n+    private static final double DEFAULT_ABSOLUTE_THRESHOLD = 100 * MathUtils.SAFE_MIN;\n+\n+    /** Relative tolerance threshold. */\n+    private final double relativeThreshold;\n+\n+    /** Absolute tolerance threshold. */\n+    private final double absoluteThreshold;\n+\n+   /** Build an instance with default threshold.\n+     */\n+    public SimpleVectorialPointChecker() {\n+        this.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\n+        this.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n+    }\n+\n+    /** Build an instance with a specified threshold.\n+     * <p>\n+     * In order to perform only relative checks, the absolute tolerance\n+     * must be set to a negative value. In order to perform only absolute\n+     * checks, the relative tolerance must be set to a negative value.\n+     * </p>\n+     * @param relativeThreshold relative tolerance threshold\n+     * @param absoluteThreshold absolute tolerance threshold\n+     */\n+    public SimpleVectorialPointChecker(final double relativeThreshold,\n+                                       final double absoluteThreshold) {\n+        this.relativeThreshold = relativeThreshold;\n+        this.absoluteThreshold = absoluteThreshold;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean converged(final int iteration,\n+                             final VectorialPointValuePair previous,\n+                             final VectorialPointValuePair current) {\n+        final double[] p = previous.getPointRef();\n+        final double[] c = current.getPointRef();\n+        for (int i = 0; i < p.length; ++i) {\n+            final double pi         = p[i];\n+            final double ci         = c[i];\n+            final double difference = Math.abs(pi - ci);\n+            final double size       = Math.max(Math.abs(pi), Math.abs(ci));\n+            if ((difference > (size * relativeThreshold)) &&\n+                (difference > absoluteThreshold)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/SimpleVectorialValueChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.util.MathUtils;\n+\n+/** \n+ * Simple implementation of the {@link VectorialConvergenceChecker} interface using\n+ * only objective function values.\n+ * <p>\n+ * Convergence is considered to have been reached if either the relative\n+ * difference between the objective function values is smaller than a\n+ * threshold or if either the absolute difference between the objective\n+ * function values is smaller than another threshold for all vectors elements.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class SimpleVectorialValueChecker implements VectorialConvergenceChecker {\n+\n+    /** Default relative threshold. */\n+    private static final double DEFAULT_RELATIVE_THRESHOLD = 100 * MathUtils.EPSILON;\n+\n+    /** Default absolute threshold. */\n+    private static final double DEFAULT_ABSOLUTE_THRESHOLD = 100 * MathUtils.SAFE_MIN;\n+\n+    /** Relative tolerance threshold. */\n+    private final double relativeThreshold;\n+\n+    /** Absolute tolerance threshold. */\n+    private final double absoluteThreshold;\n+\n+   /** Build an instance with default threshold.\n+     */\n+    public SimpleVectorialValueChecker() {\n+        this.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\n+        this.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n+    }\n+\n+    /** Build an instance with a specified threshold.\n+     * <p>\n+     * In order to perform only relative checks, the absolute tolerance\n+     * must be set to a negative value. In order to perform only absolute\n+     * checks, the relative tolerance must be set to a negative value.\n+     * </p>\n+     * @param relativeThreshold relative tolerance threshold\n+     * @param absoluteThreshold absolute tolerance threshold\n+     */\n+    public SimpleVectorialValueChecker(final double relativeThreshold,\n+                                       final double absoluteThreshold) {\n+        this.relativeThreshold = relativeThreshold;\n+        this.absoluteThreshold = absoluteThreshold;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean converged(final int iteration,\n+                             final VectorialPointValuePair previous,\n+                             final VectorialPointValuePair current) {\n+        final double[] p        = previous.getValueRef();\n+        final double[] c        = current.getValueRef();\n+        for (int i = 0; i < p.length; ++i) {\n+            final double pi         = p[i];\n+            final double ci         = c[i];\n+            final double difference = Math.abs(pi - ci);\n+            final double size       = Math.max(Math.abs(pi), Math.abs(ci));\n+            if ((difference > (size * relativeThreshold)) &&\n+                (difference > absoluteThreshold)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/UnivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.optimization;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.ConvergingAlgorithm;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+\n+/**\n+ * Interface for (univariate real) optimization algorithms.\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface UnivariateRealOptimizer extends ConvergingAlgorithm {\n+\n+    /** Set the maximal number of functions evaluations.\n+     * @param maxEvaluations maximal number of function evaluations\n+     */\n+    void setMaxEvaluations(int maxEvaluations);\n+\n+    /** Get the maximal number of functions evaluations.\n+     * @return maximal number of functions evaluations\n+     */\n+    int getMaxEvaluations();\n+\n+    /** Get the number of evaluations of the objective function.\n+     * <p>\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of evaluations of the objective function\n+     */\n+    int getEvaluations();\n+\n+    /**\n+     * Find an optimum in the given interval.\n+     * <p>\n+     * An optimizer may require that the interval brackets a single optimum.\n+     * </p>\n+     * @param f the function to optimize.\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @return a value where the function is optimum\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the optimizer detects convergence problems otherwise.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the endpoints do not\n+     * satisfy the requirements specified by the optimizer\n+     */\n+    double optimize(UnivariateRealFunction f, GoalType goalType,\n+                    double min, double max)\n+        throws ConvergenceException, FunctionEvaluationException;\n+\n+    /**\n+     * Find an optimum in the given interval, start at startValue.\n+     * <p>\n+     * An optimizer may require that the interval brackets a single optimum.\n+     * </p>\n+     * @param f the function to optimize.\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @param startValue the start value to use\n+     * @return a value where the function is optimum\n+     * @throws ConvergenceException if the maximum iteration count is exceeded\n+     * or the optimizer detects convergence problems otherwise.\n+     * @throws FunctionEvaluationException if an error occurs evaluating the\n+     * function\n+     * @throws IllegalArgumentException if min > max or the arguments do not\n+     * satisfy the requirements specified by the optimizer\n+     */\n+    double optimize(UnivariateRealFunction f, GoalType goalType,\n+                    double min, double max, double startValue)\n+        throws ConvergenceException, FunctionEvaluationException;\n+\n+    /**\n+     * Get the result of the last run of the optimizer.\n+     * \n+     * @return the last result.\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed.\n+     */\n+    double getResult();\n+\n+    /**\n+     * Get the result of the last run of the optimizer.\n+     * \n+     * @return the value of the function at the last result.\n+     * @throws IllegalStateException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed.\n+     */\n+    double getFunctionValue();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/VectorialConvergenceChecker.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+/** This interface specifies how to check if a {@link\n+ * DifferentiableMultivariateVectorialOptimizer optimization algorithm} has converged.\n+ *\n+ * <p>Deciding if convergence has been reached is a problem-dependent issue. The\n+ * user should provide a class implementing this interface to allow the optimization\n+ * algorithm to stop its search according to the problem at hand.</p>\n+ * <p>For convenience, two implementations that fit simple needs are already provided:\n+ * {@link SimpleVectorialValueChecker} and {@link SimpleVectorialPointChecker}. The first\n+ * one considers convergence is reached when the objective function value does not\n+ * change much anymore, it does not use the point set at all. The second one\n+ * considers convergence is reached when the input point set does not change\n+ * much anymore, it does not use objective function value at all.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+\n+public interface VectorialConvergenceChecker {\n+\n+  /** Check if the optimization algorithm has converged considering the last points.\n+   * <p>\n+   * This method may be called several time from the same algorithm iteration with\n+   * different points. This can be detected by checking the iteration number at each\n+   * call if needed. Each time this method is called, the previous and current point\n+   * correspond to points with the same role at each iteration, so they can be\n+   * compared. As an example, simplex-based algorithms call this method for all\n+   * points of the simplex, not only for the best or worst ones.\n+   * </p>\n+   * @param iteration index of current iteration\n+   * @param previous point from previous iteration\n+   * @param current point from current iteration\n+   * @return true if the algorithm is considered to have converged\n+   */\n+  boolean converged(int iteration, VectorialPointValuePair previous, VectorialPointValuePair current);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/VectorialPointValuePair.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+\n+/** \n+ * This class holds a point and the vectorial value of an objective function at this point.\n+ * <p>This is a simple immutable container.</p>\n+ * @see RealPointValuePair\n+ * @see MultivariateVectorialFunction\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class VectorialPointValuePair implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 1003888396256744753L;\n+\n+    /** Point coordinates. */\n+    private final double[] point;\n+\n+    /** Vectorial value of the objective function at the point. */\n+    private final double[] value;\n+\n+    /** Build a point/objective function value pair.\n+     * @param point point coordinates (the built instance will store\n+     * a copy of the array, not the array passed as argument)\n+     * @param value value of an objective function at the point\n+     */\n+    public VectorialPointValuePair(final double[] point, final double[] value) {\n+        this.point = point.clone();\n+        this.value = value.clone();\n+    }\n+\n+    /** Build a point/objective function value pair.\n+     * @param point point coordinates (the built instance will store\n+     * a copy of the array, not the array passed as argument)\n+     * @param value value of an objective function at the point\n+     * @param copyArray if true, the input arrays will be copied, otherwise\n+     * they will be referenced\n+     */\n+    public VectorialPointValuePair(final double[] point, final double[] value,\n+                                   final boolean copyArray) {\n+        this.point = copyArray ? point.clone() : point;\n+        this.value = copyArray ? value.clone() : value;\n+    }\n+\n+    /** Get the point.\n+     * @return a copy of the stored point\n+     */\n+    public double[] getPoint() {\n+        return point.clone();\n+    }\n+\n+    /** Get a reference to the point.\n+     * <p>This method is provided as a convenience to avoid copying\n+     * the array, the elements of the array should <em>not</em> be modified.</p>\n+     * @return a reference to the internal array storing the point\n+     */\n+    public double[] getPointRef() {\n+        return point;\n+    }\n+\n+    /** Get the value of the objective function.\n+     * @return a copy of the stored value of the objective function\n+     */\n+    public double[] getValue() {\n+        return value.clone();\n+    }\n+\n+    /** Get a reference to the value of the objective function.\n+     * <p>This method is provided as a convenience to avoid copying\n+     * the array, the elements of the array should <em>not</em> be modified.</p>\n+     * @return a reference to the internal array storing the value of the objective function\n+     */\n+    public double[] getValueRef() {\n+        return value;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/DirectSearchOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxEvaluationsExceededException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.RealConvergenceChecker;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+\n+/** \n+ * This class implements simplex-based direct search optimization\n+ * algorithms.\n+ *\n+ * <p>Direct search methods only use objective function values, they don't\n+ * need derivatives and don't either try to compute approximation of\n+ * the derivatives. According to a 1996 paper by Margaret H. Wright\n+ * (<a href=\"http://cm.bell-labs.com/cm/cs/doc/96/4-02.ps.gz\">Direct\n+ * Search Methods: Once Scorned, Now Respectable</a>), they are used\n+ * when either the computation of the derivative is impossible (noisy\n+ * functions, unpredictable discontinuities) or difficult (complexity,\n+ * computation cost). In the first cases, rather than an optimum, a\n+ * <em>not too bad</em> point is desired. In the latter cases, an\n+ * optimum is desired but cannot be reasonably found. In all cases\n+ * direct search methods can be useful.</p>\n+ *\n+ * <p>Simplex-based direct search methods are based on comparison of\n+ * the objective function values at the vertices of a simplex (which is a\n+ * set of n+1 points in dimension n) that is updated by the algorithms\n+ * steps.<p>\n+ *\n+ * <p>The initial configuration of the simplex can be set using either\n+ * {@link #setStartConfiguration(double[])} or {@link\n+ * #setStartConfiguration(double[][])}. If neither method has been called\n+ * before optimization is attempted, an explicit call to the first method\n+ * with all steps set to +1 is triggered, thus building a default\n+ * configuration from a unit hypercube. Each call to {@link\n+ * #optimize(MultivariateRealFunction, GoalType, double[]) optimize} will reuse\n+ * the current start configuration and move it such that its first vertex\n+ * is at the provided start point of the optimization. If the same optimizer\n+ * is used to solve different problems and the number of parameters change,\n+ * the start configuration <em>must</em> be reset or a dimension mismatch\n+ * will occur.</p>\n+ *\n+ * <p>If {@link #setConvergenceChecker(RealConvergenceChecker)} is not called,\n+ * a default {@link SimpleScalarValueChecker} is used.</p>\n+ *\n+ * <p>Convergence is checked by providing the <em>worst</em> points of\n+ * previous and current simplex to the convergence checker, not the best ones.</p>\n+ *\n+ * <p>This class is the base class performing the boilerplate simplex\n+ * initialization and handling. The simplex update by itself is\n+ * performed by the derived classes according to the implemented\n+ * algorithms.</p>\n+ *\n+ * implements MultivariateRealOptimizer since 2.0\n+ * \n+ * @see MultivariateRealFunction\n+ * @see NelderMead\n+ * @see MultiDirectional\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public abstract class DirectSearchOptimizer implements MultivariateRealOptimizer {\n+\n+    /** Simplex. */\n+    protected RealPointValuePair[] simplex;\n+\n+    /** Objective function. */\n+    private MultivariateRealFunction f;\n+\n+    /** Convergence checker. */\n+    private RealConvergenceChecker checker;\n+\n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Number of iterations already performed. */\n+    private int iterations;\n+\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n+    /** Number of evaluations already performed. */\n+    private int evaluations;\n+\n+    /** Start simplex configuration. */\n+    private double[][] startConfiguration;\n+\n+    /** Simple constructor.\n+     */\n+    protected DirectSearchOptimizer() {\n+        setConvergenceChecker(new SimpleScalarValueChecker());\n+        setMaxIterations(Integer.MAX_VALUE);\n+        setMaxEvaluations(Integer.MAX_VALUE);\n+    }\n+\n+    /** Set start configuration for simplex.\n+     * <p>The start configuration for simplex is built from a box parallel to\n+     * the canonical axes of the space. The simplex is the subset of vertices\n+     * of a box parallel to the canonical axes. It is built as the path followed\n+     * while traveling from one vertex of the box to the diagonally opposite\n+     * vertex moving only along the box edges. The first vertex of the box will\n+     * be located at the start point of the optimization.</p>\n+     * <p>As an example, in dimension 3 a simplex has 4 vertices. Setting the\n+     * steps to (1, 10, 2) and the start point to (1, 1, 1) would imply the\n+     * start simplex would be: { (1, 1, 1), (2, 1, 1), (2, 11, 1), (2, 11, 3) }.\n+     * The first vertex would be set to the start point at (1, 1, 1) and the\n+     * last vertex would be set to the diagonally opposite vertex at (2, 11, 3).</p>\n+     * @param steps steps along the canonical axes representing box edges,\n+     * they may be negative but not null\n+     * @exception IllegalArgumentException if one step is null\n+     */\n+    public void setStartConfiguration(final double[] steps)\n+        throws IllegalArgumentException {\n+        // only the relative position of the n final vertices with respect\n+        // to the first one are stored\n+        final int n = steps.length;\n+        startConfiguration = new double[n][n];\n+        for (int i = 0; i < n; ++i) {\n+            final double[] vertexI = startConfiguration[i];\n+            for (int j = 0; j < i + 1; ++j) {\n+                if (steps[j] == 0.0) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"equals vertices {0} and {1} in simplex configuration\",\n+                            j, j + 1);\n+                }\n+                System.arraycopy(steps, 0, vertexI, 0, j + 1);\n+            }\n+        }\n+    }\n+\n+    /** Set start configuration for simplex.\n+     * <p>The real initial simplex will be set up by moving the reference\n+     * simplex such that its first point is located at the start point of the\n+     * optimization.</p>\n+     * @param referenceSimplex reference simplex\n+     * @exception IllegalArgumentException if the reference simplex does not\n+     * contain at least one point, or if there is a dimension mismatch\n+     * in the reference simplex or if one of its vertices is duplicated\n+     */\n+    public void setStartConfiguration(final double[][] referenceSimplex)\n+        throws IllegalArgumentException {\n+\n+        // only the relative position of the n final vertices with respect\n+        // to the first one are stored\n+        final int n = referenceSimplex.length - 1;\n+        if (n < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"simplex must contain at least one point\");\n+        }\n+        startConfiguration = new double[n][n];\n+        final double[] ref0 = referenceSimplex[0];\n+\n+        // vertices loop\n+        for (int i = 0; i < n + 1; ++i) {\n+\n+            final double[] refI = referenceSimplex[i];\n+\n+            // safety checks\n+            if (refI.length != n) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"dimension mismatch {0} != {1}\",\n+                        refI.length, n);\n+            }\n+            for (int j = 0; j < i; ++j) {\n+                final double[] refJ = referenceSimplex[j];\n+                boolean allEquals = true;\n+                for (int k = 0; k < n; ++k) {\n+                    if (refI[k] != refJ[k]) {\n+                        allEquals = false;\n+                        break;\n+                    }\n+                }\n+                if (allEquals) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"equals vertices {0} and {1} in simplex configuration\",\n+                            i, j);\n+                }\n+            }\n+\n+            // store vertex i position relative to vertex 0 position\n+            if (i > 0) {\n+                final double[] confI = startConfiguration[i - 1];\n+                for (int k = 0; k < n; ++k) {\n+                    confI[k] = refI[k] - ref0[k];\n+                }\n+            }\n+\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxIterations(int maxIterations) {\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() {\n+        return iterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return evaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(RealConvergenceChecker checker) {\n+        this.checker = checker;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealConvergenceChecker getConvergenceChecker() {\n+        return checker;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealPointValuePair optimize(final MultivariateRealFunction f,\n+                                         final GoalType goalType,\n+                                         final double[] startPoint)\n+        throws FunctionEvaluationException, OptimizationException,\n+        IllegalArgumentException {\n+\n+        if (startConfiguration == null) {\n+            // no initial configuration has been set up for simplex\n+            // build a default one from a unit hypercube\n+            final double[] unit = new double[startPoint.length];\n+            Arrays.fill(unit, 1.0);\n+            setStartConfiguration(unit);\n+        }\n+\n+        this.f = f;\n+        final Comparator<RealPointValuePair> comparator =\n+            new Comparator<RealPointValuePair>() {\n+                public int compare(final RealPointValuePair o1,\n+                                   final RealPointValuePair o2) {\n+                    final double v1 = o1.getValue();\n+                    final double v2 = o2.getValue();\n+                    return (goalType == GoalType.MINIMIZE) ?\n+                            Double.compare(v1, v2) : Double.compare(v2, v1);\n+                }\n+            };\n+\n+        // initialize search\n+        iterations  = 0;\n+        evaluations = 0;\n+        buildSimplex(startPoint);\n+        evaluateSimplex(comparator);\n+\n+        RealPointValuePair[] previous = new RealPointValuePair[simplex.length];\n+        while (true) {\n+\n+            if (iterations > 0) {\n+                boolean converged = true;\n+                for (int i = 0; i < simplex.length; ++i) {\n+                    converged &= checker.converged(iterations, previous[i], simplex[i]);\n+                }\n+                if (converged) {\n+                    // we have found an optimum\n+                    return simplex[0];\n+                }\n+            }\n+\n+            // we still need to search\n+            System.arraycopy(simplex, 0, previous, 0, simplex.length);\n+            iterateSimplex(comparator);\n+\n+        }\n+\n+    }\n+\n+    /** Increment the iterations counter by 1.\n+     * @exception OptimizationException if the maximal number\n+     * of iterations is exceeded\n+     */\n+    protected void incrementIterationsCounter()\n+        throws OptimizationException {\n+        if (++iterations > maxIterations) {\n+            throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n+        }\n+    }\n+\n+    /** Compute the next simplex of the algorithm.\n+     * @param comparator comparator to use to sort simplex vertices from best to worst\n+     * @exception FunctionEvaluationException if the function cannot be evaluated at\n+     * some point\n+     * @exception OptimizationException if the algorithm fails to converge\n+     * @exception IllegalArgumentException if the start point dimension is wrong\n+     */\n+    protected abstract void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n+\n+    /** Evaluate the objective function on one point.\n+     * <p>A side effect of this method is to count the number of\n+     * function evaluations</p>\n+     * @param x point on which the objective function should be evaluated\n+     * @return objective function value at the given point\n+     * @exception FunctionEvaluationException if no value can be computed for the\n+     * parameters or if the maximal number of evaluations is exceeded\n+     * @exception IllegalArgumentException if the start point dimension is wrong\n+     */\n+    protected double evaluate(final double[] x)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n+        if (++evaluations > maxEvaluations) {\n+            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n+                                                  x);\n+        }\n+        return f.value(x);\n+    }\n+\n+    /** Build an initial simplex.\n+     * @param startPoint the start point for optimization\n+     * @exception IllegalArgumentException if the start point does not match\n+     * simplex dimension\n+     */\n+    private void buildSimplex(final double[] startPoint)\n+        throws IllegalArgumentException {\n+\n+        final int n = startPoint.length;\n+        if (n != startConfiguration.length) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"dimension mismatch {0} != {1}\",\n+                    n, startConfiguration.length);\n+        }\n+\n+        // set first vertex\n+        simplex = new RealPointValuePair[n + 1];\n+        simplex[0] = new RealPointValuePair(startPoint, Double.NaN);\n+\n+        // set remaining vertices\n+        for (int i = 0; i < n; ++i) {\n+            final double[] confI   = startConfiguration[i];\n+            final double[] vertexI = new double[n];\n+            for (int k = 0; k < n; ++k) {\n+                vertexI[k] = startPoint[k] + confI[k];\n+            }\n+            simplex[i + 1] = new RealPointValuePair(vertexI, Double.NaN);\n+        }\n+\n+    }\n+\n+    /** Evaluate all the non-evaluated points of the simplex.\n+     * @param comparator comparator to use to sort simplex vertices from best to worst\n+     * @exception FunctionEvaluationException if no value can be computed for the parameters\n+     * @exception OptimizationException if the maximal number of evaluations is exceeded\n+     */\n+    protected void evaluateSimplex(final Comparator<RealPointValuePair> comparator)\n+        throws FunctionEvaluationException, OptimizationException {\n+\n+        // evaluate the objective function at all non-evaluated simplex points\n+        for (int i = 0; i < simplex.length; ++i) {\n+            final RealPointValuePair vertex = simplex[i];\n+            final double[] point = vertex.getPointRef();\n+            if (Double.isNaN(vertex.getValue())) {\n+                simplex[i] = new RealPointValuePair(point, evaluate(point), false);\n+            }\n+        }\n+\n+        // sort the simplex from best to worst\n+        Arrays.sort(simplex, comparator);\n+\n+    }\n+\n+    /** Replace the worst point of the simplex by a new point.\n+     * @param pointValuePair point to insert\n+     * @param comparator comparator to use to sort simplex vertices from best to worst\n+     */\n+    protected void replaceWorstPoint(RealPointValuePair pointValuePair,\n+                                     final Comparator<RealPointValuePair> comparator) {\n+        int n = simplex.length - 1;\n+        for (int i = 0; i < n; ++i) {\n+            if (comparator.compare(simplex[i], pointValuePair) > 0) {\n+                RealPointValuePair tmp = simplex[i];\n+                simplex[i]         = pointValuePair;\n+                pointValuePair     = tmp;\n+            }\n+        }\n+        simplex[n] = pointValuePair;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+\n+/** \n+ * This class implements the multi-directional direct search method.\n+ *\n+ * @version $Revision$ $Date$\n+ * @see NelderMead\n+ * @since 1.2\n+ */\n+public class MultiDirectional extends DirectSearchOptimizer {\n+\n+    /** Expansion coefficient. */\n+    private final double khi;\n+\n+    /** Contraction coefficient. */\n+    private final double gamma;\n+\n+    /** Build a multi-directional optimizer with default coefficients.\n+     * <p>The default values are 2.0 for khi and 0.5 for gamma.</p>\n+     */\n+    public MultiDirectional() {\n+        this.khi   = 2.0;\n+        this.gamma = 0.5;\n+    }\n+\n+    /** Build a multi-directional optimizer with specified coefficients.\n+     * @param khi expansion coefficient\n+     * @param gamma contraction coefficient\n+     */\n+    public MultiDirectional(final double khi, final double gamma) {\n+        this.khi   = khi;\n+        this.gamma = gamma;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+\n+        while (true) {\n+\n+            incrementIterationsCounter();\n+\n+            // save the original vertex\n+            final RealPointValuePair[] original = simplex;\n+            final RealPointValuePair best = original[0];\n+\n+            // perform a reflection step\n+            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n+            if (comparator.compare(reflected, best) < 0) {\n+\n+                // compute the expanded simplex\n+                final RealPointValuePair[] reflectedSimplex = simplex;\n+                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n+                if (comparator.compare(reflected, expanded) <= 0) {\n+                    // accept the reflected simplex\n+                    simplex = reflectedSimplex;\n+                }\n+\n+                return;\n+\n+            }\n+\n+            // compute the contracted simplex\n+            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n+            if (comparator.compare(contracted, best) < 0) {\n+                // accept the contracted simplex\n+                return;\n+            }\n+\n+        }\n+\n+    }\n+\n+    /** Compute and evaluate a new simplex.\n+     * @param original original simplex (to be preserved)\n+     * @param coeff linear coefficient\n+     * @param comparator comparator to use to sort simplex vertices from best to poorest\n+     * @return best point in the transformed simplex\n+     * @exception FunctionEvaluationException if the function cannot be evaluated at\n+     * some point\n+     * @exception OptimizationException if the maximal number of evaluations is exceeded\n+     */\n+    private RealPointValuePair evaluateNewSimplex(final RealPointValuePair[] original,\n+                                              final double coeff,\n+                                              final Comparator<RealPointValuePair> comparator)\n+        throws FunctionEvaluationException, OptimizationException {\n+\n+        final double[] xSmallest = original[0].getPointRef();\n+        final int n = xSmallest.length;\n+\n+        // create the linearly transformed simplex\n+        simplex = new RealPointValuePair[n + 1];\n+        simplex[0] = original[0];\n+        for (int i = 1; i <= n; ++i) {\n+            final double[] xOriginal    = original[i].getPointRef();\n+            final double[] xTransformed = new double[n];\n+            for (int j = 0; j < n; ++j) {\n+                xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);\n+            }\n+            simplex[i] = new RealPointValuePair(xTransformed, Double.NaN, false);\n+        }\n+\n+        // evaluate it\n+        evaluateSimplex(comparator);\n+        return simplex[0];\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/NelderMead.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import java.util.Comparator;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+\n+/** \n+ * This class implements the Nelder-Mead direct search method.\n+ *\n+ * @version $Revision$ $Date$\n+ * @see MultiDirectional\n+ * @since 1.2\n+ */\n+public class NelderMead extends DirectSearchOptimizer {\n+\n+    /** Reflection coefficient. */\n+    private final double rho;\n+\n+    /** Expansion coefficient. */\n+    private final double khi;\n+\n+    /** Contraction coefficient. */\n+    private final double gamma;\n+\n+    /** Shrinkage coefficient. */\n+    private final double sigma;\n+\n+    /** Build a Nelder-Mead optimizer with default coefficients.\n+     * <p>The default coefficients are 1.0 for rho, 2.0 for khi and 0.5\n+     * for both gamma and sigma.</p>\n+     */\n+    public NelderMead() {\n+        this.rho   = 1.0;\n+        this.khi   = 2.0;\n+        this.gamma = 0.5;\n+        this.sigma = 0.5;\n+    }\n+\n+    /** Build a Nelder-Mead optimizer with specified coefficients.\n+     * @param rho reflection coefficient\n+     * @param khi expansion coefficient\n+     * @param gamma contraction coefficient\n+     * @param sigma shrinkage coefficient\n+     */\n+    public NelderMead(final double rho, final double khi,\n+                      final double gamma, final double sigma) {\n+        this.rho   = rho;\n+        this.khi   = khi;\n+        this.gamma = gamma;\n+        this.sigma = sigma;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n+        throws FunctionEvaluationException, OptimizationException {\n+\n+        incrementIterationsCounter();\n+\n+        // the simplex has n+1 point if dimension is n\n+        final int n = simplex.length - 1;\n+\n+        // interesting values\n+        final RealPointValuePair best       = simplex[0];\n+        final RealPointValuePair secondBest = simplex[n-1];\n+        final RealPointValuePair worst      = simplex[n];\n+        final double[] xWorst = worst.getPointRef();\n+\n+        // compute the centroid of the best vertices\n+        // (dismissing the worst point at index n)\n+        final double[] centroid = new double[n];\n+        for (int i = 0; i < n; ++i) {\n+            final double[] x = simplex[i].getPointRef();\n+            for (int j = 0; j < n; ++j) {\n+                centroid[j] += x[j];\n+            }\n+        }\n+        final double scaling = 1.0 / n;\n+        for (int j = 0; j < n; ++j) {\n+            centroid[j] *= scaling;\n+        }\n+\n+        // compute the reflection point\n+        final double[] xR = new double[n];\n+        for (int j = 0; j < n; ++j) {\n+            xR[j] = centroid[j] + rho * (centroid[j] - xWorst[j]);\n+        }\n+        final RealPointValuePair reflected = new RealPointValuePair(xR, evaluate(xR), false);\n+\n+        if ((comparator.compare(best, reflected) <= 0) &&\n+            (comparator.compare(reflected, secondBest) < 0)) {\n+\n+            // accept the reflected point\n+            replaceWorstPoint(reflected, comparator);\n+\n+        } else if (comparator.compare(reflected, best) < 0) {\n+\n+            // compute the expansion point\n+            final double[] xE = new double[n];\n+            for (int j = 0; j < n; ++j) {\n+                xE[j] = centroid[j] + khi * (xR[j] - centroid[j]);\n+            }\n+            final RealPointValuePair expanded = new RealPointValuePair(xE, evaluate(xE), false);\n+\n+            if (comparator.compare(expanded, reflected) < 0) {\n+                // accept the expansion point\n+                replaceWorstPoint(expanded, comparator);\n+            } else {\n+                // accept the reflected point\n+                replaceWorstPoint(reflected, comparator);\n+            }\n+\n+        } else {\n+\n+            if (comparator.compare(reflected, worst) < 0) {\n+\n+                // perform an outside contraction\n+                final double[] xC = new double[n];\n+                for (int j = 0; j < n; ++j) {\n+                    xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]);\n+                }\n+                final RealPointValuePair outContracted = new RealPointValuePair(xC, evaluate(xC), false);\n+\n+                if (comparator.compare(outContracted, reflected) <= 0) {\n+                    // accept the contraction point\n+                    replaceWorstPoint(outContracted, comparator);\n+                    return;\n+                }\n+\n+            } else {\n+\n+                // perform an inside contraction\n+                final double[] xC = new double[n];\n+                for (int j = 0; j < n; ++j) {\n+                    xC[j] = centroid[j] - gamma * (centroid[j] - xWorst[j]);\n+                }\n+                final RealPointValuePair inContracted = new RealPointValuePair(xC, evaluate(xC), false);\n+\n+                if (comparator.compare(inContracted, worst) < 0) {\n+                    // accept the contraction point\n+                    replaceWorstPoint(inContracted, comparator);\n+                    return;\n+                }\n+\n+            }\n+\n+            // perform a shrink\n+            final double[] xSmallest = simplex[0].getPointRef();\n+            for (int i = 1; i < simplex.length; ++i) {\n+                final double[] x = simplex[i].getPoint();\n+                for (int j = 0; j < n; ++j) {\n+                    x[j] = xSmallest[j] + sigma * (x[j] - xSmallest[j]);\n+                }\n+                simplex[i] = new RealPointValuePair(x, Double.NaN, false);\n+            }\n+            evaluateSimplex(comparator);\n+\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n+import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n+import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.VectorialPointValuePair;\n+\n+/** Fitter for parametric univariate real functions y = f(x).\n+ * <p>When a univariate real function y = f(x) does depend on some\n+ * unknown parameters p<sub>0</sub>, p<sub>1</sub> ... p<sub>n-1</sub>,\n+ * this class can be used to find these parameters. It does this\n+ * by <em>fitting</em> the curve so it remains very close to a set of\n+ * observed points (x<sub>0</sub>, y<sub>0</sub>), (x<sub>1</sub>,\n+ * y<sub>1</sub>) ... (x<sub>k-1</sub>, y<sub>k-1</sub>). This fitting\n+ * is done by finding the parameters values that minimizes the objective\n+ * function &sum;(y<sub>i</sub>-f(x<sub>i</sub>))<sup>2</sup>. This is\n+ * really a least squares problem.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class CurveFitter {\n+\n+    /** Optimizer to use for the fitting. */\n+    private final DifferentiableMultivariateVectorialOptimizer optimizer;\n+\n+    /** Observed points. */\n+    private final List<WeightedObservedPoint> observations;\n+\n+    /** Simple constructor.\n+     * @param optimizer optimizer to use for the fitting\n+     */\n+    public CurveFitter(final DifferentiableMultivariateVectorialOptimizer optimizer) {\n+        this.optimizer = optimizer;\n+        observations = new ArrayList<WeightedObservedPoint>();\n+    }\n+\n+    /** Add an observed (x,y) point to the sample with unit weight.\n+     * <p>Calling this method is equivalent to call\n+     * <code>addObservedPoint(1.0, x, y)</code>.</p>\n+     * @param x abscissa of the point\n+     * @param y observed value of the point at x, after fitting we should\n+     * have f(x) as close as possible to this value\n+     * @see #addObservedPoint(double, double, double)\n+     * @see #addObservedPoint(WeightedObservedPoint)\n+     * @see #getObservations()\n+     */\n+    public void addObservedPoint(double x, double y) {\n+        addObservedPoint(1.0, x, y);\n+    }\n+\n+    /** Add an observed weighted (x,y) point to the sample.\n+     * @param weight weight of the observed point in the fit\n+     * @param x abscissa of the point\n+     * @param y observed value of the point at x, after fitting we should\n+     * have f(x) as close as possible to this value\n+     * @see #addObservedPoint(double, double)\n+     * @see #addObservedPoint(WeightedObservedPoint)\n+     * @see #getObservations()\n+     */\n+    public void addObservedPoint(double weight, double x, double y) {\n+        observations.add(new WeightedObservedPoint(weight, x, y));\n+    }\n+\n+    /** Add an observed weighted (x,y) point to the sample.\n+     * @param observed observed point to add\n+     * @see #addObservedPoint(double, double)\n+     * @see #addObservedPoint(double, double, double)\n+     * @see #getObservations()\n+     */\n+    public void addObservedPoint(WeightedObservedPoint observed) {\n+        observations.add(observed);\n+    }\n+\n+    /** Get the observed points.\n+     * @return observed points\n+     * @see #addObservedPoint(double, double)\n+     * @see #addObservedPoint(double, double, double)\n+     * @see #addObservedPoint(WeightedObservedPoint)\n+     */\n+    public WeightedObservedPoint[] getObservations() {\n+        return observations.toArray(new WeightedObservedPoint[observations.size()]);\n+    }\n+\n+    /** Fit a curve.\n+     * <p>This method compute the coefficients of the curve that best\n+     * fit the sample of observed points previously given through calls\n+     * to the {@link #addObservedPoint(WeightedObservedPoint)\n+     * addObservedPoint} method.</p>\n+     * @param f parametric function to fit\n+     * @param initialGuess first guess of the function parameters\n+     * @return fitted parameters\n+     * @exception FunctionEvaluationException if the objective function throws one during\n+     * the search\n+     * @exception OptimizationException if the algorithm failed to converge\n+     * @exception IllegalArgumentException if the start point dimension is wrong\n+     */\n+    public double[] fit(final ParametricRealFunction f,\n+                        final double[] initialGuess)\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+\n+        // prepare least squares problem\n+        double[] target  = new double[observations.size()];\n+        double[] weights = new double[observations.size()];\n+        int i = 0;\n+        for (WeightedObservedPoint point : observations) {\n+            target[i]  = point.getY();\n+            weights[i] = point.getWeight();\n+            ++i;\n+        }\n+\n+        // perform the fit\n+        VectorialPointValuePair optimum =\n+            optimizer.optimize(new TheoreticalValuesFunction(f), target, weights, initialGuess);\n+\n+        // extract the coefficients\n+        return optimum.getPointRef();\n+\n+    }\n+\n+    /** Vectorial function computing function theoretical values. */\n+    private class TheoreticalValuesFunction\n+        implements DifferentiableMultivariateVectorialFunction {\n+\n+        /** Function to fit. */\n+        private final ParametricRealFunction f;\n+\n+        /** Simple constructor.\n+         * @param f function to fit.\n+         */\n+        public TheoreticalValuesFunction(final ParametricRealFunction f) {\n+            this.f = f;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public MultivariateMatrixFunction jacobian() {\n+            return new MultivariateMatrixFunction() {\n+                public double[][] value(double[] point)\n+                    throws FunctionEvaluationException, IllegalArgumentException {\n+\n+                    final double[][] jacobian = new double[observations.size()][];\n+\n+                    int i = 0;\n+                    for (WeightedObservedPoint observed : observations) {\n+                        jacobian[i++] = f.gradient(observed.getX(), point);\n+                    }\n+\n+                    return jacobian;\n+\n+                }\n+            };\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[] value(double[] point)\n+                throws FunctionEvaluationException, IllegalArgumentException {\n+\n+            // compute the residuals\n+            final double[] values = new double[observations.size()];\n+            int i = 0;\n+            for (WeightedObservedPoint observed : observations) {\n+                values[i++] = f.value(observed.getX(), point);\n+            }\n+\n+            return values;\n+\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicCoefficientsGuesser.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import org.apache.commons.math.optimization.OptimizationException;\n+\n+/** This class guesses harmonic coefficients from a sample.\n+\n+ * <p>The algorithm used to guess the coefficients is as follows:</p>\n+\n+ * <p>We know f (t) at some sampling points t<sub>i</sub> and want to find a,\n+ * &omega; and &phi; such that f (t) = a cos (&omega; t + &phi;).\n+ * </p>\n+ *\n+ * <p>From the analytical expression, we can compute two primitives :\n+ * <pre>\n+ *     If2  (t) = &int; f<sup>2</sup>  = a<sup>2</sup> &times; [t + S (t)] / 2\n+ *     If'2 (t) = &int; f'<sup>2</sup> = a<sup>2</sup> &omega;<sup>2</sup> &times; [t - S (t)] / 2\n+ *     where S (t) = sin (2 (&omega; t + &phi;)) / (2 &omega;)\n+ * </pre>\n+ * </p>\n+ *\n+ * <p>We can remove S between these expressions :\n+ * <pre>\n+ *     If'2 (t) = a<sup>2</sup> &omega;<sup>2</sup> t - &omega;<sup>2</sup> If2 (t)\n+ * </pre>\n+ * </p>\n+ *\n+ * <p>The preceding expression shows that If'2 (t) is a linear\n+ * combination of both t and If2 (t): If'2 (t) = A &times; t + B &times; If2 (t)\n+ * </p>\n+ *\n+ * <p>From the primitive, we can deduce the same form for definite\n+ * integrals between t<sub>1</sub> and t<sub>i</sub> for each t<sub>i</sub> :\n+ * <pre>\n+ *   If2 (t<sub>i</sub>) - If2 (t<sub>1</sub>) = A &times; (t<sub>i</sub> - t<sub>1</sub>) + B &times; (If2 (t<sub>i</sub>) - If2 (t<sub>1</sub>))\n+ * </pre>\n+ * </p>\n+ *\n+ * <p>We can find the coefficients A and B that best fit the sample\n+ * to this linear expression by computing the definite integrals for\n+ * each sample points.\n+ * </p>\n+ *\n+ * <p>For a bilinear expression z (x<sub>i</sub>, y<sub>i</sub>) = A &times; x<sub>i</sub> + B &times; y<sub>i</sub>, the\n+ * coefficients A and B that minimize a least square criterion\n+ * &sum; (z<sub>i</sub> - z (x<sub>i</sub>, y<sub>i</sub>))<sup>2</sup> are given by these expressions:</p>\n+ * <pre>\n+ *\n+ *         &sum;y<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n+ *     A = ------------------------\n+ *         &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>\n+ *\n+ *         &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub>\n+ *     B = ------------------------\n+ *         &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>\n+ * </pre>\n+ * </p>\n+ *\n+ *\n+ * <p>In fact, we can assume both a and &omega; are positive and\n+ * compute them directly, knowing that A = a<sup>2</sup> &omega;<sup>2</sup> and that\n+ * B = - &omega;<sup>2</sup>. The complete algorithm is therefore:</p>\n+ * <pre>\n+ *\n+ * for each t<sub>i</sub> from t<sub>1</sub> to t<sub>n-1</sub>, compute:\n+ *   f  (t<sub>i</sub>)\n+ *   f' (t<sub>i</sub>) = (f (t<sub>i+1</sub>) - f(t<sub>i-1</sub>)) / (t<sub>i+1</sub> - t<sub>i-1</sub>)\n+ *   x<sub>i</sub> = t<sub>i</sub> - t<sub>1</sub>\n+ *   y<sub>i</sub> = &int; f<sup>2</sup> from t<sub>1</sub> to t<sub>i</sub>\n+ *   z<sub>i</sub> = &int; f'<sup>2</sup> from t<sub>1</sub> to t<sub>i</sub>\n+ *   update the sums &sum;x<sub>i</sub>x<sub>i</sub>, &sum;y<sub>i</sub>y<sub>i</sub>, &sum;x<sub>i</sub>y<sub>i</sub>, &sum;x<sub>i</sub>z<sub>i</sub> and &sum;y<sub>i</sub>z<sub>i</sub>\n+ * end for\n+ *\n+ *            |--------------------------\n+ *         \\  | &sum;y<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n+ * a     =  \\ | ------------------------\n+ *           \\| &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n+ *\n+ *\n+ *            |--------------------------\n+ *         \\  | &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>z<sub>i</sub> - &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>z<sub>i</sub>\n+ * &omega;     =  \\ | ------------------------\n+ *           \\| &sum;x<sub>i</sub>x<sub>i</sub> &sum;y<sub>i</sub>y<sub>i</sub> - &sum;x<sub>i</sub>y<sub>i</sub> &sum;x<sub>i</sub>y<sub>i</sub>\n+ *\n+ * </pre>\n+ * </p>\n+\n+ * <p>Once we know &omega;, we can compute:\n+ * <pre>\n+ *    fc = &omega; f (t) cos (&omega; t) - f' (t) sin (&omega; t)\n+ *    fs = &omega; f (t) sin (&omega; t) + f' (t) cos (&omega; t)\n+ * </pre>\n+ * </p>\n+\n+ * <p>It appears that <code>fc = a &omega; cos (&phi;)</code> and\n+ * <code>fs = -a &omega; sin (&phi;)</code>, so we can use these\n+ * expressions to compute &phi;. The best estimate over the sample is\n+ * given by averaging these expressions.\n+ * </p>\n+\n+ * <p>Since integrals and means are involved in the preceding\n+ * estimations, these operations run in O(n) time, where n is the\n+ * number of measurements.</p>\n+\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+\n+ */\n+public class HarmonicCoefficientsGuesser {\n+\n+    /** Sampled observations. */\n+    private final WeightedObservedPoint[] observations;\n+\n+    /** Guessed amplitude. */\n+    private double a;\n+\n+    /** Guessed pulsation &omega;. */\n+    private double omega;\n+\n+    /** Guessed phase &phi;. */\n+    private double phi;\n+\n+    /** Simple constructor.\n+     * @param observations sampled observations\n+     */\n+    public HarmonicCoefficientsGuesser(WeightedObservedPoint[] observations) {\n+        this.observations = observations.clone();\n+        a                 = Double.NaN;\n+        omega             = Double.NaN;\n+    }\n+\n+    /** Estimate a first guess of the coefficients.\n+     * @exception OptimizationException if the sample is too short or if\n+     * the first guess cannot be computed (when the elements under the\n+     * square roots are negative).\n+     * */\n+    public void guess() throws OptimizationException {\n+        sortObservations();\n+        guessAOmega();\n+        guessPhi();\n+    }\n+\n+    /** Sort the observations with respect to the abscissa.\n+     */\n+    private void sortObservations() {\n+\n+        // Since the samples are almost always already sorted, this\n+        // method is implemented as an insertion sort that reorders the\n+        // elements in place. Insertion sort is very efficient in this case.\n+        WeightedObservedPoint curr = observations[0];\n+        for (int j = 1; j < observations.length; ++j) {\n+            WeightedObservedPoint prec = curr;\n+            curr = observations[j];\n+            if (curr.getX() < prec.getX()) {\n+                // the current element should be inserted closer to the beginning\n+                int i = j - 1;\n+                WeightedObservedPoint mI = observations[i];\n+                while ((i >= 0) && (curr.getX() < mI.getX())) {\n+                    observations[i + 1] = mI;\n+                    if (i-- != 0) {\n+                        mI = observations[i];\n+                    } else {\n+                        mI = null;\n+                    }\n+                }\n+                observations[i + 1] = curr;\n+                curr = observations[j];\n+            }\n+        }\n+\n+    }\n+\n+    /** Estimate a first guess of the a and &omega; coefficients.\n+     * @exception OptimizationException if the sample is too short or if\n+     * the first guess cannot be computed (when the elements under the\n+     * square roots are negative).\n+     */\n+    private void guessAOmega() throws OptimizationException {\n+\n+        // initialize the sums for the linear model between the two integrals\n+        double sx2 = 0.0;\n+        double sy2 = 0.0;\n+        double sxy = 0.0;\n+        double sxz = 0.0;\n+        double syz = 0.0;\n+\n+        double currentX        = observations[0].getX();\n+        double currentY        = observations[0].getY();\n+        double f2Integral      = 0;\n+        double fPrime2Integral = 0;\n+        final double startX = currentX;\n+        for (int i = 1; i < observations.length; ++i) {\n+\n+            // one step forward\n+            final double previousX = currentX;\n+            final double previousY = currentY;\n+            currentX = observations[i].getX();\n+            currentY = observations[i].getY();\n+\n+            // update the integrals of f<sup>2</sup> and f'<sup>2</sup>\n+            // considering a linear model for f (and therefore constant f')\n+            final double dx = currentX - previousX;\n+            final double dy = currentY - previousY;\n+            final double f2StepIntegral =\n+                dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n+            final double fPrime2StepIntegral = dy * dy / dx;\n+\n+            final double x   = currentX - startX;\n+            f2Integral      += f2StepIntegral;\n+            fPrime2Integral += fPrime2StepIntegral;\n+\n+            sx2 += x * x;\n+            sy2 += f2Integral * f2Integral;\n+            sxy += x * f2Integral;\n+            sxz += x * fPrime2Integral;\n+            syz += f2Integral * fPrime2Integral;\n+\n+        }\n+\n+        // compute the amplitude and pulsation coefficients\n+        double c1 = sy2 * sxz - sxy * syz;\n+        double c2 = sxy * sxz - sx2 * syz;\n+        double c3 = sx2 * sy2 - sxy * sxy;\n+        if ((c1 / c2 < 0.0) || (c2 / c3 < 0.0)) {\n+            throw new OptimizationException(\"unable to first guess the harmonic coefficients\");\n+        }\n+        a     = Math.sqrt(c1 / c2);\n+        omega = Math.sqrt(c2 / c3);\n+\n+    }\n+\n+    /** Estimate a first guess of the &phi; coefficient.\n+     */\n+    private void guessPhi() {\n+\n+        // initialize the means\n+        double fcMean = 0.0;\n+        double fsMean = 0.0;\n+\n+        double currentX = observations[0].getX();\n+        double currentY = observations[0].getY();\n+        for (int i = 1; i < observations.length; ++i) {\n+\n+            // one step forward\n+            final double previousX = currentX;\n+            final double previousY = currentY;\n+            currentX = observations[i].getX();\n+            currentY = observations[i].getY();\n+            final double currentYPrime = (currentY - previousY) / (currentX - previousX);\n+\n+            double   omegaX = omega * currentX;\n+            double   cosine = Math.cos(omegaX);\n+            double   sine   = Math.sin(omegaX);\n+            fcMean += omega * currentY * cosine - currentYPrime *   sine;\n+            fsMean += omega * currentY *   sine + currentYPrime * cosine;\n+\n+        }\n+\n+        phi = Math.atan2(-fsMean, fcMean);\n+\n+    }\n+\n+    /** Get the guessed amplitude a.\n+     * @return guessed amplitude a;\n+     */\n+    public double getGuessedAmplitude() {\n+        return a;\n+    }\n+\n+    /** Get the guessed pulsation &omega;.\n+     * @return guessed pulsation &omega;\n+     */\n+    public double getGuessedPulsation() {\n+        return omega;\n+    }\n+\n+    /** Get the guessed phase &phi;.\n+     * @return guessed phase &phi;\n+     */\n+    public double getGuessedPhase() {\n+        return phi;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n+import org.apache.commons.math.optimization.OptimizationException;\n+\n+/** This class implements a curve fitting specialized for sinusoids.\n+ * <p>Harmonic fitting is a very simple case of curve fitting. The\n+ * estimated coefficients are the amplitude a, the pulsation &omega; and\n+ * the phase &phi;: <code>f (t) = a cos (&omega; t + &phi;)</code>. They are\n+ * searched by a least square estimator initialized with a rough guess\n+ * based on integrals.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class HarmonicFitter {\n+\n+    /** Fitter for the coefficients. */\n+    private final CurveFitter fitter;\n+\n+    /** Values for amplitude, pulsation &omega; and phase &phi;. */\n+    private double[] parameters;\n+\n+    /** Simple constructor.\n+     * @param optimizer optimizer to use for the fitting\n+     */\n+    public HarmonicFitter(final DifferentiableMultivariateVectorialOptimizer optimizer) {\n+        this.fitter = new CurveFitter(optimizer);\n+        parameters  = null;\n+    }\n+\n+    /** Simple constructor.\n+     * <p>This constructor can be used when a first guess of the\n+     * coefficients is already known.</p>\n+     * @param optimizer optimizer to use for the fitting\n+     * @param initialGuess guessed values for amplitude (index 0),\n+     * pulsation &omega; (index 1) and phase &phi; (index 2)\n+     */\n+    public HarmonicFitter(final DifferentiableMultivariateVectorialOptimizer optimizer,\n+                          final double[] initialGuess) {\n+        this.fitter     = new CurveFitter(optimizer);\n+        this.parameters = initialGuess.clone();\n+    }\n+\n+    /** Add an observed weighted (x,y) point to the sample.\n+     * @param weight weight of the observed point in the fit\n+     * @param x abscissa of the point\n+     * @param y observed value of the point at x, after fitting we should\n+     * have P(x) as close as possible to this value\n+     */\n+    public void addObservedPoint(double weight, double x, double y) {\n+        fitter.addObservedPoint(weight, x, y);\n+    }\n+\n+    /** Fit an harmonic function to the observed points.\n+     * @return harmonic function best fitting the observed points\n+     * @throws OptimizationException if the sample is too short or if\n+     * the first guess cannot be computed\n+     */\n+    public HarmonicFunction fit() throws OptimizationException {\n+        try {\n+\n+            // shall we compute the first guess of the parameters ourselves ?\n+            if (parameters == null) {\n+                final WeightedObservedPoint[] observations = fitter.getObservations();\n+                if (observations.length < 4) {\n+                    throw new OptimizationException(\"sample contains {0} observed points, at least {1} are required\",\n+                                                    observations.length, 4);\n+                }\n+\n+                HarmonicCoefficientsGuesser guesser = new HarmonicCoefficientsGuesser(observations);\n+                guesser.guess();\n+                parameters = new double[] {\n+                                 guesser.getGuessedAmplitude(),\n+                                 guesser.getGuessedPulsation(),\n+                                 guesser.getGuessedPhase()\n+                            };\n+\n+            }\n+\n+            double[] fitted = fitter.fit(new ParametricHarmonicFunction(), parameters);\n+            return new HarmonicFunction(fitted[0], fitted[1], fitted[2]);\n+\n+        } catch (FunctionEvaluationException fee) {\n+            // this should never happen\n+            throw MathRuntimeException.createInternalError(fee);\n+        }\n+    }\n+\n+    /** Parametric harmonic function. */\n+    private static class ParametricHarmonicFunction implements ParametricRealFunction {\n+\n+        /** {@inheritDoc} */\n+        public double value(double x, double[] parameters) {\n+            final double a     = parameters[0];\n+            final double omega = parameters[1];\n+            final double phi   = parameters[2];\n+            return a * Math.cos(omega * x + phi);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[] gradient(double x, double[] parameters) {\n+            final double a     = parameters[0];\n+            final double omega = parameters[1];\n+            final double phi   = parameters[2];\n+            final double alpha = omega * x + phi;\n+            final double cosAlpha = Math.cos(alpha);\n+            final double sinAlpha = Math.sin(alpha);\n+            return new double[] { cosAlpha, -a * x * sinAlpha, -a * sinAlpha };\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+\n+/** Harmonic function of the form <code>f (t) = a cos (&omega; t + &phi;)</code>.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class HarmonicFunction implements DifferentiableUnivariateRealFunction {\n+\n+    /** Amplitude a. */\n+    private final double a;\n+\n+    /** Pulsation &omega;. */\n+    private final double omega;\n+\n+    /** Phase &phi;. */\n+    private final double phi;\n+\n+    /** Simple constructor.\n+     * @param a amplitude\n+     * @param omega pulsation\n+     * @param phi phase\n+     */\n+    public HarmonicFunction(double a, double omega, double phi) {\n+        this.a     = a;\n+        this.omega = omega;\n+        this.phi   = phi;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double value(double x) {\n+        return a * Math.cos(omega * x + phi);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public HarmonicFunction derivative() {\n+        return new HarmonicFunction(a * omega, omega, phi + Math.PI / 2);\n+    }\n+\n+    /** Get the amplitude a.\n+     * @return amplitude a;\n+     */\n+    public double getAmplitude() {\n+        return a;\n+    }\n+\n+    /** Get the pulsation &omega;.\n+     * @return pulsation &omega;\n+     */\n+    public double getPulsation() {\n+        return omega;\n+    }\n+\n+    /** Get the phase &phi;.\n+     * @return phase &phi;\n+     */\n+    public double getPhase() {\n+        return phi;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/ParametricRealFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/**\n+ * An interface representing a real function that depends on one independent\n+ * variable plus some extra parameters.\n+ *  \n+ * @version $Revision$ $Date$\n+ */\n+public interface ParametricRealFunction {\n+\n+    /**\n+     * Compute the value of the function.\n+     * @param x the point for which the function value should be computed\n+     * @param parameters function parameters\n+     * @return the value\n+     * @throws FunctionEvaluationException if the function evaluation fails\n+     */\n+    public double value(double x, double[] parameters)\n+        throws FunctionEvaluationException;\n+\n+    /**\n+     * Compute the gradient of the function with respect to its parameters.\n+     * @param x the point for which the function value should be computed\n+     * @param parameters function parameters\n+     * @return the value\n+     * @throws FunctionEvaluationException if the function evaluation fails\n+     */\n+    public double[] gradient(double x, double[] parameters)\n+        throws FunctionEvaluationException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n+import org.apache.commons.math.optimization.OptimizationException;\n+\n+/** This class implements a curve fitting specialized for polynomials.\n+ * <p>Polynomial fitting is a very simple case of curve fitting. The\n+ * estimated coefficients are the polynomial coefficients. They are\n+ * searched by a least square estimator.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+\n+public class PolynomialFitter {\n+\n+    /** Fitter for the coefficients. */\n+    private final CurveFitter fitter;\n+\n+    /** Polynomial degree. */\n+    private final int degree;\n+\n+    /** Simple constructor.\n+     * <p>The polynomial fitter built this way are complete polynomials,\n+     * ie. a n-degree polynomial has n+1 coefficients.</p>\n+     * @param degree maximal degree of the polynomial\n+     * @param optimizer optimizer to use for the fitting\n+     */\n+    public PolynomialFitter(int degree, final DifferentiableMultivariateVectorialOptimizer optimizer) {\n+        this.fitter = new CurveFitter(optimizer);\n+        this.degree = degree;\n+    }\n+\n+    /** Add an observed weighted (x,y) point to the sample.\n+     * @param weight weight of the observed point in the fit\n+     * @param x abscissa of the point\n+     * @param y observed value of the point at x, after fitting we should\n+     * have P(x) as close as possible to this value\n+     */\n+    public void addObservedPoint(double weight, double x, double y) {\n+        fitter.addObservedPoint(weight, x, y);\n+    }\n+\n+    /** Get the polynomial fitting the weighted (x, y) points.\n+     * @return polynomial function best fitting the observed points\n+     * @exception OptimizationException if the algorithm failed to converge\n+     */\n+    public PolynomialFunction fit()\n+        throws OptimizationException {\n+        try {\n+            return new PolynomialFunction(fitter.fit(new ParametricPolynomial(), new double[degree + 1]));\n+        } catch (FunctionEvaluationException fee) {\n+            // this should never happen\n+            throw MathRuntimeException.createInternalError(fee);\n+        }\n+    }\n+\n+    /** Dedicated parametric polynomial class. */\n+    private static class ParametricPolynomial implements ParametricRealFunction {\n+\n+        /** {@inheritDoc} */\n+        public double[] gradient(double x, double[] parameters)\n+                throws FunctionEvaluationException {\n+            final double[] gradient = new double[parameters.length];\n+            double xn = 1.0;\n+            for (int i = 0; i < parameters.length; ++i) {\n+                gradient[i] = xn;\n+                xn *= x;\n+            }\n+            return gradient;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double value(final double x, final double[] parameters) {\n+            double y = 0;\n+            for (int i = parameters.length - 1; i >= 0; --i) {\n+                y = y * x + parameters[i];\n+            }\n+            return y;\n+        }\n+        \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/WeightedObservedPoint.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.fitting;\n+\n+import java.io.Serializable;\n+\n+/** This class is a simple container for weighted observed point in\n+ * {@link CurveFitter curve fitting}.\n+ * <p>Instances of this class are guaranteed to be immutable.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class WeightedObservedPoint implements Serializable {\n+\n+    /** Serializable version id. */\n+    private static final long serialVersionUID = 5306874947404636157L;\n+\n+    /** Weight of the measurement in the fitting process. */\n+    private final double weight;\n+\n+    /** Abscissa of the point. */\n+    private final double x;\n+\n+    /** Observed value of the function at x. */\n+    private final double y;\n+\n+    /** Simple constructor.\n+     * @param weight weight of the measurement in the fitting process\n+     * @param x abscissa of the measurement\n+     * @param y ordinate of the measurement\n+     */\n+    public WeightedObservedPoint(final double weight, final double x, final double y) {\n+        this.weight = weight;\n+        this.x      = x;\n+        this.y      = y;\n+    }\n+\n+    /** Get the weight of the measurement in the fitting process.\n+     * @return weight of the measurement in the fitting process\n+     */\n+    public double getWeight() {\n+        return weight;\n+    }\n+\n+    /** Get the abscissa of the point.\n+     * @return abscissa of the point\n+     */\n+    public double getX() {\n+        return x;\n+    }\n+\n+    /** Get the observed value of the function at x.\n+     * @return observed value of the function at x\n+     */\n+    public double getY() {\n+        return y;\n+    }\n+\n+}\n+\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.general;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxEvaluationsExceededException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n+import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n+import org.apache.commons.math.linear.InvalidMatrixException;\n+import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n+import org.apache.commons.math.optimization.VectorialConvergenceChecker;\n+import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n+import org.apache.commons.math.optimization.VectorialPointValuePair;\n+\n+/**\n+ * Base class for implementing least squares optimizers.\n+ * <p>This base class handles the boilerplate methods associated to thresholds\n+ * settings, jacobian and error estimation.</p>\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ *\n+ */\n+public abstract class AbstractLeastSquaresOptimizer implements DifferentiableMultivariateVectorialOptimizer {\n+\n+    /** Default maximal number of iterations allowed. */\n+    public static final int DEFAULT_MAX_ITERATIONS = 100;\n+\n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Number of iterations already performed. */\n+    private int iterations;\n+\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n+    /** Number of evaluations already performed. */\n+    private int objectiveEvaluations;\n+\n+    /** Number of jacobian evaluations. */\n+    private int jacobianEvaluations;\n+\n+    /** Convergence checker. */\n+    protected VectorialConvergenceChecker checker;\n+\n+    /** \n+     * Jacobian matrix.\n+     * <p>This matrix is in canonical form just after the calls to\n+     * {@link #updateJacobian()}, but may be modified by the solver\n+     * in the derived class (the {@link LevenbergMarquardtOptimizer\n+     * Levenberg-Marquardt optimizer} does this).</p>\n+     */\n+    protected double[][] jacobian;\n+\n+    /** Number of columns of the jacobian matrix. */\n+    protected int cols;\n+\n+    /** Number of rows of the jacobian matrix. */\n+    protected int rows;\n+\n+    /** Objective function. */\n+    private DifferentiableMultivariateVectorialFunction f;\n+\n+    /** Objective function derivatives. */\n+    private MultivariateMatrixFunction jF;\n+\n+    /** Target value for the objective functions at optimum. */\n+    protected double[] target;\n+\n+    /** Weight for the least squares cost computation. */\n+    protected double[] weights;\n+\n+    /** Current point. */\n+    protected double[] point;\n+\n+    /** Current objective function value. */\n+    protected double[] objective;\n+\n+    /** Current residuals. */\n+    protected double[] residuals;\n+\n+    /** Cost value (square root of the sum of the residuals). */\n+    protected double cost;\n+\n+    /** Simple constructor with default settings.\n+     * <p>The convergence check is set to a {@link SimpleVectorialValueChecker}\n+     * and the maximal number of evaluation is set to its default value.</p>\n+     */\n+    protected AbstractLeastSquaresOptimizer() {\n+        setConvergenceChecker(new SimpleVectorialValueChecker());\n+        setMaxIterations(DEFAULT_MAX_ITERATIONS);\n+        setMaxEvaluations(Integer.MAX_VALUE);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxIterations(int maxIterations) {\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() {\n+        return iterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return objectiveEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getJacobianEvaluations() {\n+        return jacobianEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(VectorialConvergenceChecker checker) {\n+        this.checker = checker;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public VectorialConvergenceChecker getConvergenceChecker() {\n+        return checker;\n+    }\n+\n+    /** Increment the iterations counter by 1.\n+     * @exception OptimizationException if the maximal number\n+     * of iterations is exceeded\n+     */\n+    protected void incrementIterationsCounter()\n+        throws OptimizationException {\n+        if (++iterations > maxIterations) {\n+            throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n+        }\n+    }\n+\n+    /** \n+     * Update the jacobian matrix.\n+     * @exception FunctionEvaluationException if the function jacobian\n+     * cannot be evaluated or its dimension doesn't match problem dimension\n+     */\n+    protected void updateJacobian() throws FunctionEvaluationException {\n+        ++jacobianEvaluations;\n+        jacobian = jF.value(point);\n+        if (jacobian.length != rows) {\n+            throw new FunctionEvaluationException(point, \"dimension mismatch {0} != {1}\",\n+                                                  jacobian.length, rows);\n+        }\n+        for (int i = 0; i < rows; i++) {\n+            final double[] ji = jacobian[i];\n+            final double factor = -Math.sqrt(weights[i]);\n+            for (int j = 0; j < cols; ++j) {\n+                ji[j] *= factor;\n+            }\n+        }\n+    }\n+\n+    /** \n+     * Update the residuals array and cost function value.\n+     * @exception FunctionEvaluationException if the function cannot be evaluated\n+     * or its dimension doesn't match problem dimension or maximal number of\n+     * of evaluations is exceeded\n+     */\n+    protected void updateResidualsAndCost()\n+        throws FunctionEvaluationException {\n+\n+        if (++objectiveEvaluations > maxEvaluations) {\n+            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n+                                                  point);\n+        }\n+        objective = f.value(point);\n+        if (objective.length != rows) {\n+            throw new FunctionEvaluationException(point, \"dimension mismatch {0} != {1}\",\n+                                                  objective.length, rows);\n+        }\n+        cost = 0;\n+        for (int i = 0, index = 0; i < rows; i++, index += cols) {\n+            final double residual = target[i] - objective[i];\n+            residuals[i] = residual;\n+            cost += weights[i] * residual * residual;\n+        }\n+        cost = Math.sqrt(cost);\n+\n+    }\n+\n+    /** \n+     * Get the Root Mean Square value.\n+     * Get the Root Mean Square value, i.e. the root of the arithmetic\n+     * mean of the square of all weighted residuals. This is related to the\n+     * criterion that is minimized by the optimizer as follows: if\n+     * <em>c</em> if the criterion, and <em>n</em> is the number of\n+     * measurements, then the RMS is <em>sqrt (c/n)</em>.\n+     * \n+     * @return RMS value\n+     */\n+    public double getRMS() {\n+        double criterion = 0;\n+        for (int i = 0; i < rows; ++i) {\n+            final double residual = residuals[i];\n+            criterion += weights[i] * residual * residual;\n+        }\n+        return Math.sqrt(criterion / rows);\n+    }\n+\n+    /**\n+     * Get the Chi-Square value.\n+     * @return chi-square value\n+     */\n+    public double getChiSquare() {\n+        double chiSquare = 0;\n+        for (int i = 0; i < rows; ++i) {\n+            final double residual = residuals[i];\n+            chiSquare += residual * residual / weights[i];\n+        }\n+        return chiSquare;\n+    }\n+\n+    /**\n+     * Get the covariance matrix of optimized parameters.\n+     * @return covariance matrix\n+     * @exception FunctionEvaluationException if the function jacobian cannot\n+     * be evaluated\n+     * @exception OptimizationException if the covariance matrix\n+     * cannot be computed (singular problem)\n+     */\n+    public double[][] getCovariances()\n+        throws FunctionEvaluationException, OptimizationException {\n+\n+        // set up the jacobian\n+        updateJacobian();\n+\n+        // compute transpose(J).J, avoiding building big intermediate matrices\n+        double[][] jTj = new double[cols][cols];\n+        for (int i = 0; i < cols; ++i) {\n+            for (int j = i; j < cols; ++j) {\n+                double sum = 0;\n+                for (int k = 0; k < rows; ++k) {\n+                    sum += jacobian[k][i] * jacobian[k][j];\n+                }\n+                jTj[i][j] = sum;\n+                jTj[j][i] = sum;\n+            }\n+        }\n+\n+        try {\n+            // compute the covariances matrix\n+            RealMatrix inverse =\n+                new LUDecompositionImpl(MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\n+            return inverse.getData();\n+        } catch (InvalidMatrixException ime) {\n+            throw new OptimizationException(\"unable to compute covariances: singular problem\");\n+        }\n+\n+    }\n+\n+    /**\n+     * Guess the errors in optimized parameters.\n+     * <p>Guessing is covariance-based, it only gives rough order of magnitude.</p>\n+     * @return errors in optimized parameters\n+     * @exception FunctionEvaluationException if the function jacobian cannot b evaluated\n+     * @exception OptimizationException if the covariances matrix cannot be computed\n+     * or the number of degrees of freedom is not positive (number of measurements\n+     * lesser or equal to number of parameters)\n+     */\n+    public double[] guessParametersErrors()\n+        throws FunctionEvaluationException, OptimizationException {\n+        if (rows <= cols) {\n+            throw new OptimizationException(\n+                    \"no degrees of freedom ({0} measurements, {1} parameters)\",\n+                    rows, cols);\n+        }\n+        double[] errors = new double[cols];\n+        final double c = Math.sqrt(getChiSquare() / (rows - cols));\n+        double[][] covar = getCovariances();\n+        for (int i = 0; i < errors.length; ++i) {\n+            errors[i] = Math.sqrt(covar[i][i]) * c;\n+        }\n+        return errors;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f,\n+                                            final double[] target, final double[] weights,\n+                                            final double[] startPoint)\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+\n+        if (target.length != weights.length) {\n+            throw new OptimizationException(\"dimension mismatch {0} != {1}\",\n+                                            target.length, weights.length);\n+        }\n+\n+        // reset counters\n+        iterations           = 0;\n+        objectiveEvaluations = 0;\n+        jacobianEvaluations  = 0;\n+\n+        // store least squares problem characteristics\n+        this.f         = f;\n+        jF             = f.jacobian();\n+        this.target    = target.clone();\n+        this.weights   = weights.clone();\n+        this.point     = startPoint.clone();\n+        this.residuals = new double[target.length];\n+\n+        // arrays shared with the other private methods\n+        rows      = target.length;\n+        cols      = point.length;\n+        jacobian  = new double[rows][cols];\n+\n+        cost = Double.POSITIVE_INFINITY;\n+\n+        return doOptimize();\n+\n+    }\n+\n+    /** Perform the bulk of optimization algorithm.\n+     * @return the point/value pair giving the optimal value for objective function\n+     * @exception FunctionEvaluationException if the objective function throws one during\n+     * the search\n+     * @exception OptimizationException if the algorithm failed to converge\n+     * @exception IllegalArgumentException if the start point dimension is wrong\n+     */\n+    abstract protected VectorialPointValuePair doOptimize()\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.general;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxEvaluationsExceededException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.RealConvergenceChecker;\n+import org.apache.commons.math.optimization.DifferentiableMultivariateRealOptimizer;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.SimpleScalarValueChecker;\n+\n+/**\n+ * Base class for implementing optimizers for multivariate scalar functions.\n+ * <p>This base class handles the boilerplate methods associated to thresholds\n+ * settings, iterations and evaluations counting.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class AbstractScalarDifferentiableOptimizer\n+    implements DifferentiableMultivariateRealOptimizer {\n+\n+    /** Default maximal number of iterations allowed. */\n+    public static final int DEFAULT_MAX_ITERATIONS = 100;\n+\n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Number of iterations already performed. */\n+    private int iterations;\n+\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n+    /** Number of evaluations already performed. */\n+    private int evaluations;\n+\n+    /** Number of gradient evaluations. */\n+    private int gradientEvaluations;\n+\n+    /** Convergence checker. */\n+    protected RealConvergenceChecker checker;\n+\n+    /** Objective function. */\n+    private DifferentiableMultivariateRealFunction f;\n+\n+    /** Objective function gradient. */\n+    private MultivariateVectorialFunction gradient;\n+\n+    /** Type of optimization. */\n+    protected GoalType goalType;\n+\n+    /** Current point set. */\n+    protected double[] point;\n+\n+    /** Simple constructor with default settings.\n+     * <p>The convergence check is set to a {@link SimpleScalarValueChecker}\n+     * and the maximal number of evaluation is set to its default value.</p>\n+     */\n+    protected AbstractScalarDifferentiableOptimizer() {\n+        setConvergenceChecker(new SimpleScalarValueChecker());\n+        setMaxIterations(DEFAULT_MAX_ITERATIONS);\n+        setMaxEvaluations(Integer.MAX_VALUE);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxIterations(int maxIterations) {\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() {\n+        return iterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return evaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getGradientEvaluations() {\n+        return gradientEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setConvergenceChecker(RealConvergenceChecker checker) {\n+        this.checker = checker;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealConvergenceChecker getConvergenceChecker() {\n+        return checker;\n+    }\n+\n+    /** Increment the iterations counter by 1.\n+     * @exception OptimizationException if the maximal number\n+     * of iterations is exceeded\n+     */\n+    protected void incrementIterationsCounter()\n+        throws OptimizationException {\n+        if (++iterations > maxIterations) {\n+            throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n+        }\n+    }\n+\n+    /** \n+     * Compute the gradient vector.\n+     * @param point point at which the gradient must be evaluated\n+     * @return gradient at the specified point\n+     * @exception FunctionEvaluationException if the function gradient\n+     */\n+    protected double[] computeObjectiveGradient(final double[] point)\n+        throws FunctionEvaluationException {\n+        ++gradientEvaluations;\n+        return gradient.value(point);\n+    }\n+\n+    /** \n+     * Compute the objective function value.\n+     * @param point point at which the objective function must be evaluated\n+     * @return objective function value at specified point\n+     * @exception FunctionEvaluationException if the function cannot be evaluated\n+     * or its dimension doesn't match problem dimension or the maximal number\n+     * of iterations is exceeded\n+     */\n+    protected double computeObjectiveValue(final double[] point)\n+        throws FunctionEvaluationException {\n+        if (++evaluations > maxEvaluations) {\n+            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n+                                                  point);\n+        }\n+        return f.value(point);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealPointValuePair optimize(final DifferentiableMultivariateRealFunction f,\n+                                         final GoalType goalType,\n+                                         final double[] startPoint)\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+\n+        // reset counters\n+        iterations          = 0;\n+        evaluations         = 0;\n+        gradientEvaluations = 0;\n+\n+        // store optimization problem characteristics\n+        this.f        = f;\n+        gradient      = f.gradient();\n+        this.goalType = goalType;\n+        point         = startPoint.clone();\n+\n+        return doOptimize();\n+\n+    }\n+\n+    /** Perform the bulk of optimization algorithm.\n+     * @return the point/value pair giving the optimal value for objective function\n+     * @exception FunctionEvaluationException if the objective function throws one during\n+     * the search\n+     * @exception OptimizationException if the algorithm failed to converge\n+     * @exception IllegalArgumentException if the start point dimension is wrong\n+     */\n+    abstract protected RealPointValuePair doOptimize()\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/general/ConjugateGradientFormula.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.general;\n+\n+/**\n+ * Available choices of update formulas for the &beta; parameter\n+ * in {@link NonLinearConjugateGradientOptimizer}.\n+ * <p>\n+ * The &beta; parameter is used to compute the successive conjugate\n+ * search directions. For non-linear conjugate gradients, there are\n+ * two formulas to compute &beta;:\n+ * <ul>\n+ *   <li>Fletcher-Reeves formula</li>\n+ *   <li>Polak-Ribi&egrave;re formula</li>\n+ * </ul>\n+ * On the one hand, the Fletcher-Reeves formula is guaranteed to converge\n+ * if the start point is close enough of the optimum whether the\n+ * Polak-Ribi&egrave;re formula may not converge in rare cases. On the\n+ * other hand, the Polak-Ribi&egrave;re formula is often faster when it\n+ * does converge. Polak-Ribi&egrave;re is often used.\n+ * <p>\n+ * @see NonLinearConjugateGradientOptimizer\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public enum ConjugateGradientFormula {\n+\n+    /** Fletcher-Reeves formula. */\n+    FLETCHER_REEVES,\n+\n+    /** Polak-Ribi&egrave;re formula. */\n+    POLAK_RIBIERE\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.general;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n+import org.apache.commons.math.linear.DecompositionSolver;\n+import org.apache.commons.math.linear.InvalidMatrixException;\n+import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.QRDecompositionImpl;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n+import org.apache.commons.math.optimization.VectorialPointValuePair;\n+\n+/** \n+ * Gauss-Newton least-squares solver.\n+ * <p>\n+ * This class solve a least-square problem by solving the normal equations\n+ * of the linearized problem at each iteration. Either LU decomposition or\n+ * QR decomposition can be used to solve the normal equations. LU decomposition\n+ * is faster but QR decomposition is more robust for difficult problems.\n+ * </p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ *\n+ */\n+\n+public class GaussNewtonOptimizer extends AbstractLeastSquaresOptimizer {\n+\n+    /** Indicator for using LU decomposition. */\n+    private final boolean useLU;\n+\n+    /** Simple constructor with default settings.\n+     * <p>The convergence check is set to a {@link SimpleVectorialValueChecker}\n+     * and the maximal number of evaluation is set to\n+     * {@link AbstractLeastSquaresOptimizer#DEFAULT_MAX_ITERATIONS}.\n+     * @param useLU if true, the normal equations will be solved using LU\n+     * decomposition, otherwise they will be solved using QR decomposition\n+     */\n+    public GaussNewtonOptimizer(final boolean useLU) {\n+        this.useLU = useLU;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public VectorialPointValuePair doOptimize()\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+\n+        // iterate until convergence is reached\n+        VectorialPointValuePair current = null;\n+        for (boolean converged = false; !converged;) {\n+\n+            incrementIterationsCounter();\n+\n+            // evaluate the objective function and its jacobian\n+            VectorialPointValuePair previous = current;\n+            updateResidualsAndCost();\n+            updateJacobian();\n+            current = new VectorialPointValuePair(point, objective);\n+\n+            // build the linear problem\n+            final double[]   b = new double[cols];\n+            final double[][] a = new double[cols][cols];\n+            for (int i = 0; i < rows; ++i) {\n+\n+                final double[] grad   = jacobian[i];\n+                final double weight   = weights[i];\n+                final double residual = objective[i] - target[i];\n+\n+                // compute the normal equation\n+                final double wr = weight * residual;\n+                for (int j = 0; j < cols; ++j) {\n+                    b[j] += wr * grad[j];\n+                }\n+\n+                // build the contribution matrix for measurement i\n+                for (int k = 0; k < cols; ++k) {\n+                    double[] ak = a[k];\n+                    double wgk = weight * grad[k];\n+                    for (int l = 0; l < cols; ++l) {\n+                        ak[l] += wgk * grad[l];\n+                    }\n+                }\n+\n+            }\n+\n+            try {\n+\n+                // solve the linearized least squares problem\n+                RealMatrix mA = new BlockRealMatrix(a);\n+                DecompositionSolver solver = useLU ?\n+                        new LUDecompositionImpl(mA).getSolver() :\n+                        new QRDecompositionImpl(mA).getSolver();\n+                final double[] dX = solver.solve(b);\n+\n+                // update the estimated parameters\n+                for (int i = 0; i < cols; ++i) {\n+                    point[i] += dX[i];\n+                }\n+\n+            } catch(InvalidMatrixException e) {\n+                throw new OptimizationException(\"unable to solve: singular problem\");\n+            }\n+\n+            // check convergence\n+            if (previous != null) {\n+                converged = checker.converged(getIterations(), previous, current);\n+            }\n+\n+        }\n+\n+        // we have converged\n+        return current;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.optimization.general;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.VectorialPointValuePair;\n+\n+\n+/** \n+ * This class solves a least squares problem using the Levenberg-Marquardt algorithm.\n+ *\n+ * <p>This implementation <em>should</em> work even for over-determined systems\n+ * (i.e. systems having more point than equations). Over-determined systems\n+ * are solved by ignoring the point which have the smallest impact according\n+ * to their jacobian column norm. Only the rank of the matrix and some loop bounds\n+ * are changed to implement this.</p>\n+ *\n+ * <p>The resolution engine is a simple translation of the MINPACK <a\n+ * href=\"http://www.netlib.org/minpack/lmder.f\">lmder</a> routine with minor\n+ * changes. The changes include the over-determined resolution and the Q.R.\n+ * decomposition which has been rewritten following the algorithm described in the\n+ * P. Lascaux and R. Theodor book <i>Analyse num&eacute;rique matricielle\n+ * appliqu&eacute;e &agrave; l'art de l'ing&eacute;nieur</i>, Masson 1986. The\n+ * redistribution policy for MINPACK is available <a\n+ * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for convenience, it\n+ * is reproduced below.</p>\n+ *\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>\n+ *    Minpack Copyright Notice (1999) University of Chicago.\n+ *    All rights reserved\n+ * </td></tr>\n+ * <tr><td>\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * <ol>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ * <li>Redistributions in binary form must reproduce the above\n+ *     copyright notice, this list of conditions and the following\n+ *     disclaimer in the documentation and/or other materials provided\n+ *     with the distribution.</li>\n+ * <li>The end-user documentation included with the redistribution, if any,\n+ *     must include the following acknowledgment:\n+ *     <code>This product includes software developed by the University of\n+ *           Chicago, as Operator of Argonne National Laboratory.</code>\n+ *     Alternately, this acknowledgment may appear in the software itself,\n+ *     if and wherever such third-party acknowledgments normally appear.</li>\n+ * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n+ *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n+ *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n+ *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n+ *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n+ *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n+ *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n+ *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n+ *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n+ *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n+ *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n+ *     BE CORRECTED.</strong></li>\n+ * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n+ *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n+ *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n+ *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n+ *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n+ *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n+ *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n+ *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n+ *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n+ *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n+ * <ol></td></tr>\n+ * </table>\n+\n+ * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran)\n+ * @author Burton S. Garbow (original fortran)\n+ * @author Kenneth E. Hillstrom (original fortran)\n+ * @author Jorge J. More (original fortran)\n+\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ *\n+ */\n+public class LevenbergMarquardtOptimizer extends AbstractLeastSquaresOptimizer {\n+\n+    /** Number of solved point. */\n+    private int solvedCols;\n+\n+    /** Diagonal elements of the R matrix in the Q.R. decomposition. */\n+    private double[] diagR;\n+\n+    /** Norms of the columns of the jacobian matrix. */\n+    private double[] jacNorm;\n+\n+    /** Coefficients of the Householder transforms vectors. */\n+    private double[] beta;\n+\n+    /** Columns permutation array. */\n+    private int[] permutation;\n+\n+    /** Rank of the jacobian matrix. */\n+    private int rank;\n+\n+    /** Levenberg-Marquardt parameter. */\n+    private double lmPar;\n+\n+    /** Parameters evolution direction associated with lmPar. */\n+    private double[] lmDir;\n+\n+    /** Positive input variable used in determining the initial step bound. */\n+    private double initialStepBoundFactor;\n+\n+    /** Desired relative error in the sum of squares. */\n+    private double costRelativeTolerance;\n+\n+    /**  Desired relative error in the approximate solution parameters. */\n+    private double parRelativeTolerance;\n+\n+    /** Desired max cosine on the orthogonality between the function vector\n+     * and the columns of the jacobian. */\n+    private double orthoTolerance;\n+\n+    /** \n+     * Build an optimizer for least squares problems.\n+     * <p>The default values for the algorithm settings are:\n+     *   <ul>\n+     *    <li>{@link #setInitialStepBoundFactor initial step bound factor}: 100.0</li>\n+     *    <li>{@link #setMaxIterations maximal iterations}: 1000</li>\n+     *    <li>{@link #setCostRelativeTolerance cost relative tolerance}: 1.0e-10</li>\n+     *    <li>{@link #setParRelativeTolerance parameters relative tolerance}: 1.0e-10</li>\n+     *    <li>{@link #setOrthoTolerance orthogonality tolerance}: 1.0e-10</li>\n+     *   </ul>\n+     * </p>\n+     */\n+    public LevenbergMarquardtOptimizer() {\n+\n+        // set up the superclass with a default  max cost evaluations setting\n+        setMaxIterations(1000);\n+\n+        // default values for the tuning parameters\n+        setInitialStepBoundFactor(100.0);\n+        setCostRelativeTolerance(1.0e-10);\n+        setParRelativeTolerance(1.0e-10);\n+        setOrthoTolerance(1.0e-10);\n+\n+    }\n+\n+    /** \n+     * Set the positive input variable used in determining the initial step bound.\n+     * This bound is set to the product of initialStepBoundFactor and the euclidean\n+     * norm of diag*x if nonzero, or else to initialStepBoundFactor itself. In most\n+     * cases factor should lie in the interval (0.1, 100.0). 100.0 is a generally\n+     * recommended value.\n+     *\n+     * @param initialStepBoundFactor initial step bound factor\n+     */\n+    public void setInitialStepBoundFactor(double initialStepBoundFactor) {\n+        this.initialStepBoundFactor = initialStepBoundFactor;\n+    }\n+\n+    /** \n+     * Set the desired relative error in the sum of squares.\n+     * \n+     * @param costRelativeTolerance desired relative error in the sum of squares\n+     */\n+    public void setCostRelativeTolerance(double costRelativeTolerance) {\n+        this.costRelativeTolerance = costRelativeTolerance;\n+    }\n+\n+    /** \n+     * Set the desired relative error in the approximate solution parameters.\n+     * \n+     * @param parRelativeTolerance desired relative error\n+     * in the approximate solution parameters\n+     */\n+    public void setParRelativeTolerance(double parRelativeTolerance) {\n+        this.parRelativeTolerance = parRelativeTolerance;\n+    }\n+\n+    /** \n+     * Set the desired max cosine on the orthogonality.\n+     * \n+     * @param orthoTolerance desired max cosine on the orthogonality\n+     * between the function vector and the columns of the jacobian\n+     */\n+    public void setOrthoTolerance(double orthoTolerance) {\n+        this.orthoTolerance = orthoTolerance;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected VectorialPointValuePair doOptimize()\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+\n+        // arrays shared with the other private methods\n+        solvedCols  = Math.min(rows, cols);\n+        diagR       = new double[cols];\n+        jacNorm     = new double[cols];\n+        beta        = new double[cols];\n+        permutation = new int[cols];\n+        lmDir       = new double[cols];\n+\n+        // local point\n+        double   delta   = 0, xNorm = 0;\n+        double[] diag    = new double[cols];\n+        double[] oldX    = new double[cols];\n+        double[] oldRes  = new double[rows];\n+        double[] work1   = new double[cols];\n+        double[] work2   = new double[cols];\n+        double[] work3   = new double[cols];\n+\n+        // evaluate the function at the starting point and calculate its norm\n+        updateResidualsAndCost();\n+\n+        // outer loop\n+        lmPar = 0;\n+        boolean firstIteration = true;\n+        while (true) {\n+\n+            incrementIterationsCounter();\n+\n+            // compute the Q.R. decomposition of the jacobian matrix\n+            updateJacobian();\n+            qrDecomposition();\n+\n+            // compute Qt.res\n+            qTy(residuals);\n+\n+            // now we don't need Q anymore,\n+            // so let jacobian contain the R matrix with its diagonal elements\n+            for (int k = 0; k < solvedCols; ++k) {\n+                int pk = permutation[k];\n+                jacobian[k][pk] = diagR[pk];\n+            }\n+\n+            if (firstIteration) {\n+\n+                // scale the point according to the norms of the columns\n+                // of the initial jacobian\n+                xNorm = 0;\n+                for (int k = 0; k < cols; ++k) {\n+                    double dk = jacNorm[k];\n+                    if (dk == 0) {\n+                        dk = 1.0;\n+                    }\n+                    double xk = dk * point[k];\n+                    xNorm  += xk * xk;\n+                    diag[k] = dk;\n+                }\n+                xNorm = Math.sqrt(xNorm);\n+\n+                // initialize the step bound delta\n+                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n+\n+            }\n+\n+            // check orthogonality between function vector and jacobian columns\n+            double maxCosine = 0;\n+            if (cost != 0) {\n+                for (int j = 0; j < solvedCols; ++j) {\n+                    int    pj = permutation[j];\n+                    double s  = jacNorm[pj];\n+                    if (s != 0) {\n+                        double sum = 0;\n+                        for (int i = 0; i <= j; ++i) {\n+                            sum += jacobian[i][pj] * residuals[i];\n+                        }\n+                        maxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n+                    }\n+                }\n+            }\n+            if (maxCosine <= orthoTolerance) {\n+                // convergence has been reached\n+                return new VectorialPointValuePair(point, objective);\n+            }\n+\n+            // rescale if necessary\n+            for (int j = 0; j < cols; ++j) {\n+                diag[j] = Math.max(diag[j], jacNorm[j]);\n+            }\n+\n+            // inner loop\n+            for (double ratio = 0; ratio < 1.0e-4;) {\n+\n+                // save the state\n+                for (int j = 0; j < solvedCols; ++j) {\n+                    int pj = permutation[j];\n+                    oldX[pj] = point[pj];\n+                }\n+                double previousCost = cost;\n+                double[] tmpVec = residuals;\n+                residuals = oldRes;\n+                oldRes    = tmpVec;\n+\n+                // determine the Levenberg-Marquardt parameter\n+                determineLMParameter(oldRes, delta, diag, work1, work2, work3);\n+\n+                // compute the new point and the norm of the evolution direction\n+                double lmNorm = 0;\n+                for (int j = 0; j < solvedCols; ++j) {\n+                    int pj = permutation[j];\n+                    lmDir[pj] = -lmDir[pj];\n+                    point[pj] = oldX[pj] + lmDir[pj];\n+                    double s = diag[pj] * lmDir[pj];\n+                    lmNorm  += s * s;\n+                }\n+                lmNorm = Math.sqrt(lmNorm);\n+\n+                // on the first iteration, adjust the initial step bound.\n+                if (firstIteration) {\n+                    delta = Math.min(delta, lmNorm);\n+                }\n+\n+                // evaluate the function at x + p and calculate its norm\n+                updateResidualsAndCost();\n+\n+                // compute the scaled actual reduction\n+                double actRed = -1.0;\n+                if (0.1 * cost < previousCost) {\n+                    double r = cost / previousCost;\n+                    actRed = 1.0 - r * r;\n+                }\n+\n+                // compute the scaled predicted reduction\n+                // and the scaled directional derivative\n+                for (int j = 0; j < solvedCols; ++j) {\n+                    int pj = permutation[j];\n+                    double dirJ = lmDir[pj];\n+                    work1[j] = 0;\n+                    for (int i = 0; i <= j; ++i) {\n+                        work1[i] += jacobian[i][pj] * dirJ;\n+                    }\n+                }\n+                double coeff1 = 0;\n+                for (int j = 0; j < solvedCols; ++j) {\n+                    coeff1 += work1[j] * work1[j];\n+                }\n+                double pc2 = previousCost * previousCost;\n+                coeff1 = coeff1 / pc2;\n+                double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n+                double preRed = coeff1 + 2 * coeff2;\n+                double dirDer = -(coeff1 + coeff2);\n+\n+                // ratio of the actual to the predicted reduction\n+                ratio = (preRed == 0) ? 0 : (actRed / preRed);\n+\n+                // update the step bound\n+                if (ratio <= 0.25) {\n+                    double tmp =\n+                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n+                        if ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\n+                            tmp = 0.1;\n+                        }\n+                        delta = tmp * Math.min(delta, 10.0 * lmNorm);\n+                        lmPar /= tmp;\n+                } else if ((lmPar == 0) || (ratio >= 0.75)) {\n+                    delta = 2 * lmNorm;\n+                    lmPar *= 0.5;\n+                }\n+\n+                // test for successful iteration.\n+                if (ratio >= 1.0e-4) {\n+                    // successful iteration, update the norm\n+                    firstIteration = false;\n+                    xNorm = 0;\n+                    for (int k = 0; k < cols; ++k) {\n+                        double xK = diag[k] * point[k];\n+                        xNorm    += xK * xK;\n+                    }\n+                    xNorm = Math.sqrt(xNorm);\n+                } else {\n+                    // failed iteration, reset the previous values\n+                    cost = previousCost;\n+                    for (int j = 0; j < solvedCols; ++j) {\n+                        int pj = permutation[j];\n+                        point[pj] = oldX[pj];\n+                    }\n+                    tmpVec    = residuals;\n+                    residuals = oldRes;\n+                    oldRes    = tmpVec;\n+                }\n+\n+                // tests for convergence.\n+                if (((Math.abs(actRed) <= costRelativeTolerance) &&\n+                        (preRed <= costRelativeTolerance) &&\n+                        (ratio <= 2.0)) ||\n+                        (delta <= parRelativeTolerance * xNorm)) {\n+                    return new VectorialPointValuePair(point, objective);\n+                }\n+\n+                // tests for termination and stringent tolerances\n+                // (2.2204e-16 is the machine epsilon for IEEE754)\n+                if ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n+                    throw new OptimizationException(\"cost relative tolerance is too small ({0}),\" +\n+                            \" no further reduction in the\" +\n+                            \" sum of squares is possible\",\n+                            costRelativeTolerance);\n+                } else if (delta <= 2.2204e-16 * xNorm) {\n+                    throw new OptimizationException(\"parameters relative tolerance is too small\" +\n+                            \" ({0}), no further improvement in\" +\n+                            \" the approximate solution is possible\",\n+                            parRelativeTolerance);\n+                } else if (maxCosine <= 2.2204e-16)  {\n+                    throw new OptimizationException(\"orthogonality tolerance is too small ({0}),\" +\n+                            \" solution is orthogonal to the jacobian\",\n+                            orthoTolerance);\n+                }\n+\n+            }\n+\n+        }\n+\n+    }\n+\n+    /** \n+     * Determine the Levenberg-Marquardt parameter.\n+     * <p>This implementation is a translation in Java of the MINPACK\n+     * <a href=\"http://www.netlib.org/minpack/lmpar.f\">lmpar</a>\n+     * routine.</p>\n+     * <p>This method sets the lmPar and lmDir attributes.</p>\n+     * <p>The authors of the original fortran function are:</p>\n+     * <ul>\n+     *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n+     *   <li>Burton  S. Garbow</li>\n+     *   <li>Kenneth E. Hillstrom</li>\n+     *   <li>Jorge   J. More</li>\n+     * </ul>\n+     * <p>Luc Maisonobe did the Java translation.</p>\n+     * \n+     * @param qy array containing qTy\n+     * @param delta upper bound on the euclidean norm of diagR * lmDir\n+     * @param diag diagonal matrix\n+     * @param work1 work array\n+     * @param work2 work array\n+     * @param work3 work array\n+     */\n+    private void determineLMParameter(double[] qy, double delta, double[] diag,\n+            double[] work1, double[] work2, double[] work3) {\n+\n+        // compute and store in x the gauss-newton direction, if the\n+        // jacobian is rank-deficient, obtain a least squares solution\n+        for (int j = 0; j < rank; ++j) {\n+            lmDir[permutation[j]] = qy[j];\n+        }\n+        for (int j = rank; j < cols; ++j) {\n+            lmDir[permutation[j]] = 0;\n+        }\n+        for (int k = rank - 1; k >= 0; --k) {\n+            int pk = permutation[k];\n+            double ypk = lmDir[pk] / diagR[pk];\n+            for (int i = 0; i < k; ++i) {\n+                lmDir[permutation[i]] -= ypk * jacobian[i][pk];\n+            }\n+            lmDir[pk] = ypk;\n+        }\n+\n+        // evaluate the function at the origin, and test\n+        // for acceptance of the Gauss-Newton direction\n+        double dxNorm = 0;\n+        for (int j = 0; j < solvedCols; ++j) {\n+            int pj = permutation[j];\n+            double s = diag[pj] * lmDir[pj];\n+            work1[pj] = s;\n+            dxNorm += s * s;\n+        }\n+        dxNorm = Math.sqrt(dxNorm);\n+        double fp = dxNorm - delta;\n+        if (fp <= 0.1 * delta) {\n+            lmPar = 0;\n+            return;\n+        }\n+\n+        // if the jacobian is not rank deficient, the Newton step provides\n+        // a lower bound, parl, for the zero of the function,\n+        // otherwise set this bound to zero\n+        double sum2, parl = 0;\n+        if (rank == solvedCols) {\n+            for (int j = 0; j < solvedCols; ++j) {\n+                int pj = permutation[j];\n+                work1[pj] *= diag[pj] / dxNorm; \n+            }\n+            sum2 = 0;\n+            for (int j = 0; j < solvedCols; ++j) {\n+                int pj = permutation[j];\n+                double sum = 0;\n+                for (int i = 0; i < j; ++i) {\n+                    sum += jacobian[i][pj] * work1[permutation[i]];\n+                }\n+                double s = (work1[pj] - sum) / diagR[pj];\n+                work1[pj] = s;\n+                sum2 += s * s;\n+            }\n+            parl = fp / (delta * sum2);\n+        }\n+\n+        // calculate an upper bound, paru, for the zero of the function\n+        sum2 = 0;\n+        for (int j = 0; j < solvedCols; ++j) {\n+            int pj = permutation[j];\n+            double sum = 0;\n+            for (int i = 0; i <= j; ++i) {\n+                sum += jacobian[i][pj] * qy[i];\n+            }\n+            sum /= diag[pj];\n+            sum2 += sum * sum;\n+        }\n+        double gNorm = Math.sqrt(sum2);\n+        double paru = gNorm / delta;\n+        if (paru == 0) {\n+            // 2.2251e-308 is the smallest positive real for IEE754\n+            paru = 2.2251e-308 / Math.min(delta, 0.1);\n+        }\n+\n+        // if the input par lies outside of the interval (parl,paru),\n+        // set par to the closer endpoint\n+        lmPar = Math.min(paru, Math.max(lmPar, parl));\n+        if (lmPar == 0) {\n+            lmPar = gNorm / dxNorm;\n+        }\n+\n+        for (int countdown = 10; countdown >= 0; --countdown) {\n+\n+            // evaluate the function at the current value of lmPar\n+            if (lmPar == 0) {\n+                lmPar = Math.max(2.2251e-308, 0.001 * paru);\n+            }\n+            double sPar = Math.sqrt(lmPar);\n+            for (int j = 0; j < solvedCols; ++j) {\n+                int pj = permutation[j];\n+                work1[pj] = sPar * diag[pj];\n+            }\n+            determineLMDirection(qy, work1, work2, work3);\n+\n+            dxNorm = 0;\n+            for (int j = 0; j < solvedCols; ++j) {\n+                int pj = permutation[j];\n+                double s = diag[pj] * lmDir[pj];\n+                work3[pj] = s;\n+                dxNorm += s * s;\n+            }\n+            dxNorm = Math.sqrt(dxNorm);\n+            double previousFP = fp;\n+            fp = dxNorm - delta;\n+\n+            // if the function is small enough, accept the current value\n+            // of lmPar, also test for the exceptional cases where parl is zero\n+            if ((Math.abs(fp) <= 0.1 * delta) ||\n+                    ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\n+                return;\n+            }\n+\n+            // compute the Newton correction\n+            for (int j = 0; j < solvedCols; ++j) {\n+                int pj = permutation[j];\n+                work1[pj] = work3[pj] * diag[pj] / dxNorm; \n+            }\n+            for (int j = 0; j < solvedCols; ++j) {\n+                int pj = permutation[j];\n+                work1[pj] /= work2[j];\n+                double tmp = work1[pj];\n+                for (int i = j + 1; i < solvedCols; ++i) {\n+                    work1[permutation[i]] -= jacobian[i][pj] * tmp;\n+                }\n+            }\n+            sum2 = 0;\n+            for (int j = 0; j < solvedCols; ++j) {\n+                double s = work1[permutation[j]];\n+                sum2 += s * s;\n+            }\n+            double correction = fp / (delta * sum2);\n+\n+            // depending on the sign of the function, update parl or paru.\n+            if (fp > 0) {\n+                parl = Math.max(parl, lmPar);\n+            } else if (fp < 0) {\n+                paru = Math.min(paru, lmPar);\n+            }\n+\n+            // compute an improved estimate for lmPar\n+            lmPar = Math.max(parl, lmPar + correction);\n+\n+        }\n+    }\n+\n+    /** \n+     * Solve a*x = b and d*x = 0 in the least squares sense.\n+     * <p>This implementation is a translation in Java of the MINPACK\n+     * <a href=\"http://www.netlib.org/minpack/qrsolv.f\">qrsolv</a>\n+     * routine.</p>\n+     * <p>This method sets the lmDir and lmDiag attributes.</p>\n+     * <p>The authors of the original fortran function are:</p>\n+     * <ul>\n+     *   <li>Argonne National Laboratory. MINPACK project. March 1980</li>\n+     *   <li>Burton  S. Garbow</li>\n+     *   <li>Kenneth E. Hillstrom</li>\n+     *   <li>Jorge   J. More</li>\n+     * </ul>\n+     * <p>Luc Maisonobe did the Java translation.</p>\n+     * \n+     * @param qy array containing qTy\n+     * @param diag diagonal matrix\n+     * @param lmDiag diagonal elements associated with lmDir\n+     * @param work work array\n+     */\n+    private void determineLMDirection(double[] qy, double[] diag,\n+            double[] lmDiag, double[] work) {\n+\n+        // copy R and Qty to preserve input and initialize s\n+        //  in particular, save the diagonal elements of R in lmDir\n+        for (int j = 0; j < solvedCols; ++j) {\n+            int pj = permutation[j];\n+            for (int i = j + 1; i < solvedCols; ++i) {\n+                jacobian[i][pj] = jacobian[j][permutation[i]];\n+            }\n+            lmDir[j] = diagR[pj];\n+            work[j]  = qy[j];\n+        }\n+\n+        // eliminate the diagonal matrix d using a Givens rotation\n+        for (int j = 0; j < solvedCols; ++j) {\n+\n+            // prepare the row of d to be eliminated, locating the\n+            // diagonal element using p from the Q.R. factorization\n+            int pj = permutation[j];\n+            double dpj = diag[pj];\n+            if (dpj != 0) {\n+                Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);\n+            }\n+            lmDiag[j] = dpj;\n+\n+            //  the transformations to eliminate the row of d\n+            // modify only a single element of Qty\n+            // beyond the first n, which is initially zero.\n+            double qtbpj = 0;\n+            for (int k = j; k < solvedCols; ++k) {\n+                int pk = permutation[k];\n+\n+                // determine a Givens rotation which eliminates the\n+                // appropriate element in the current row of d\n+                if (lmDiag[k] != 0) {\n+\n+                    double sin, cos;\n+                    double rkk = jacobian[k][pk];\n+                    if (Math.abs(rkk) < Math.abs(lmDiag[k])) {\n+                        double cotan = rkk / lmDiag[k];\n+                        sin   = 1.0 / Math.sqrt(1.0 + cotan * cotan);\n+                        cos   = sin * cotan;\n+                    } else {\n+                        double tan = lmDiag[k] / rkk;\n+                        cos = 1.0 / Math.sqrt(1.0 + tan * tan);\n+                        sin = cos * tan;\n+                    }\n+\n+                    // compute the modified diagonal element of R and\n+                    // the modified element of (Qty,0)\n+                    jacobian[k][pk] = cos * rkk + sin * lmDiag[k];\n+                    double temp = cos * work[k] + sin * qtbpj;\n+                    qtbpj = -sin * work[k] + cos * qtbpj;\n+                    work[k] = temp;\n+\n+                    // accumulate the tranformation in the row of s\n+                    for (int i = k + 1; i < solvedCols; ++i) {\n+                        double rik = jacobian[i][pk];\n+                        temp = cos * rik + sin * lmDiag[i];\n+                        lmDiag[i] = -sin * rik + cos * lmDiag[i];\n+                        jacobian[i][pk] = temp;\n+                    }\n+\n+                }\n+            }\n+\n+            // store the diagonal element of s and restore\n+            // the corresponding diagonal element of R\n+            lmDiag[j] = jacobian[j][permutation[j]];\n+            jacobian[j][permutation[j]] = lmDir[j];\n+\n+        }\n+\n+        // solve the triangular system for z, if the system is\n+        // singular, then obtain a least squares solution\n+        int nSing = solvedCols;\n+        for (int j = 0; j < solvedCols; ++j) {\n+            if ((lmDiag[j] == 0) && (nSing == solvedCols)) {\n+                nSing = j;\n+            }\n+            if (nSing < solvedCols) {\n+                work[j] = 0;\n+            }\n+        }\n+        if (nSing > 0) {\n+            for (int j = nSing - 1; j >= 0; --j) {\n+                int pj = permutation[j];\n+                double sum = 0;\n+                for (int i = j + 1; i < nSing; ++i) {\n+                    sum += jacobian[i][pj] * work[i];\n+                }\n+                work[j] = (work[j] - sum) / lmDiag[j];\n+            }\n+        }\n+\n+        // permute the components of z back to components of lmDir\n+        for (int j = 0; j < lmDir.length; ++j) {\n+            lmDir[permutation[j]] = work[j];\n+        }\n+\n+    }\n+\n+    /** \n+     * Decompose a matrix A as A.P = Q.R using Householder transforms.\n+     * <p>As suggested in the P. Lascaux and R. Theodor book\n+     * <i>Analyse num&eacute;rique matricielle appliqu&eacute;e &agrave;\n+     * l'art de l'ing&eacute;nieur</i> (Masson, 1986), instead of representing\n+     * the Householder transforms with u<sub>k</sub> unit vectors such that:\n+     * <pre>\n+     * H<sub>k</sub> = I - 2u<sub>k</sub>.u<sub>k</sub><sup>t</sup>\n+     * </pre>\n+     * we use <sub>k</sub> non-unit vectors such that:\n+     * <pre>\n+     * H<sub>k</sub> = I - beta<sub>k</sub>v<sub>k</sub>.v<sub>k</sub><sup>t</sup>\n+     * </pre>\n+     * where v<sub>k</sub> = a<sub>k</sub> - alpha<sub>k</sub> e<sub>k</sub>.\n+     * The beta<sub>k</sub> coefficients are provided upon exit as recomputing\n+     * them from the v<sub>k</sub> vectors would be costly.</p>\n+     * <p>This decomposition handles rank deficient cases since the tranformations\n+     * are performed in non-increasing columns norms order thanks to columns\n+     * pivoting. The diagonal elements of the R matrix are therefore also in\n+     * non-increasing absolute values order.</p>\n+     * @exception OptimizationException if the decomposition cannot be performed\n+     */\n+    private void qrDecomposition() throws OptimizationException {\n+\n+        // initializations\n+        for (int k = 0; k < cols; ++k) {\n+            permutation[k] = k;\n+            double norm2 = 0;\n+            for (int i = 0; i < jacobian.length; ++i) {\n+                double akk = jacobian[i][k];\n+                norm2 += akk * akk;\n+            }\n+            jacNorm[k] = Math.sqrt(norm2);\n+        }\n+\n+        // transform the matrix column after column\n+        for (int k = 0; k < cols; ++k) {\n+\n+            // select the column with the greatest norm on active components\n+            int nextColumn = -1;\n+            double ak2 = Double.NEGATIVE_INFINITY;\n+            for (int i = k; i < cols; ++i) {\n+                double norm2 = 0;\n+                for (int j = k; j < jacobian.length; ++j) {\n+                    double aki = jacobian[j][permutation[i]];\n+                    norm2 += aki * aki;\n+                }\n+                if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n+                    throw new OptimizationException(\n+                            \"unable to perform Q.R decomposition on the {0}x{1} jacobian matrix\",\n+                            rows, cols);\n+                }\n+                if (norm2 > ak2) {\n+                    nextColumn = i;\n+                    ak2        = norm2;\n+                }\n+            }\n+            if (ak2 == 0) {\n+                rank = k;\n+                return;\n+            }\n+            int pk                  = permutation[nextColumn];\n+            permutation[nextColumn] = permutation[k];\n+            permutation[k]          = pk;\n+\n+            // choose alpha such that Hk.u = alpha ek\n+            double akk   = jacobian[k][pk];\n+            double alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\n+            double betak = 1.0 / (ak2 - akk * alpha);\n+            beta[pk]     = betak;\n+\n+            // transform the current column\n+            diagR[pk]        = alpha;\n+            jacobian[k][pk] -= alpha;\n+\n+            // transform the remaining columns\n+            for (int dk = cols - 1 - k; dk > 0; --dk) {\n+                double gamma = 0;\n+                for (int j = k; j < jacobian.length; ++j) {\n+                    gamma += jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n+                }\n+                gamma *= betak;\n+                for (int j = k; j < jacobian.length; ++j) {\n+                    jacobian[j][permutation[k + dk]] -= gamma * jacobian[j][pk];\n+                }\n+            }\n+\n+        }\n+\n+        rank = solvedCols;\n+\n+    }\n+\n+    /** \n+     * Compute the product Qt.y for some Q.R. decomposition.\n+     * \n+     * @param y vector to multiply (will be overwritten with the result)\n+     */\n+    private void qTy(double[] y) {\n+        for (int k = 0; k < cols; ++k) {\n+            int pk = permutation[k];\n+            double gamma = 0;\n+            for (int i = k; i < rows; ++i) {\n+                gamma += jacobian[i][pk] * y[i];\n+            }\n+            gamma *= beta[pk];\n+            for (int i = k; i < rows; ++i) {\n+                y[i] -= gamma * jacobian[i][pk];\n+            }\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.general;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.solvers.BrentSolver;\n+import org.apache.commons.math.analysis.solvers.UnivariateRealSolver;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.DifferentiableMultivariateRealOptimizer;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.SimpleVectorialValueChecker;\n+\n+/** \n+ * Non-linear conjugate gradient optimizer.\n+ * <p>\n+ * This class supports both the Fletcher-Reeves and the Polak-Ribi&egrave;re\n+ * update formulas for the conjugate search directions. It also supports\n+ * optional preconditioning.\n+ * </p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ *\n+ */\n+\n+public class NonLinearConjugateGradientOptimizer\n+    extends AbstractScalarDifferentiableOptimizer\n+    implements DifferentiableMultivariateRealOptimizer {\n+\n+    /** Update formula for the beta parameter. */\n+    private final ConjugateGradientFormula updateFormula;\n+\n+    /** Preconditioner (may be null). */\n+    private Preconditioner preconditioner;\n+\n+    /** solver to use in the line search (may be null). */\n+    private UnivariateRealSolver solver;\n+\n+    /** Initial step used to bracket the optimum in line search. */\n+    private double initialStep;\n+\n+    /** Simple constructor with default settings.\n+     * <p>The convergence check is set to a {@link SimpleVectorialValueChecker}\n+     * and the maximal number of iterations is set to\n+     * {@link AbstractScalarDifferentiableOptimizer#DEFAULT_MAX_ITERATIONS}.\n+     * @param updateFormula formula to use for updating the &beta; parameter,\n+     * must be one of {@link ConjugateGradientFormula#FLETCHER_REEVES} or {@link\n+     * ConjugateGradientFormula#POLAK_RIBIERE}\n+     */\n+    public NonLinearConjugateGradientOptimizer(final ConjugateGradientFormula updateFormula) {\n+        this.updateFormula = updateFormula;\n+        preconditioner     = null;\n+        solver             = null;\n+        initialStep        = 1.0;\n+    }\n+\n+    /**\n+     * Set the preconditioner.\n+     * @param preconditioner preconditioner to use for next optimization,\n+     * may be null to remove an already registered preconditioner\n+     */\n+    public void setPreconditioner(final Preconditioner preconditioner) {\n+        this.preconditioner = preconditioner;\n+    }\n+\n+    /**\n+     * Set the solver to use during line search.\n+     * @param solver solver to use during line search, may be null\n+     * to remove an already registered solver and fall back to the\n+     * default {@link BrentSolver Brent solver}.\n+     */\n+    public void setLineSearchSolver(final UnivariateRealSolver solver) {\n+        this.solver = solver;\n+    }\n+\n+    /**\n+     * Set the initial step used to bracket the optimum in line search.\n+     * <p>\n+     * The initial step is a factor with respect to the search direction,\n+     * which itself is roughly related to the gradient of the function\n+     * </p>\n+     * @param initialStep initial step used to bracket the optimum in line search,\n+     * if a non-positive value is used, the initial step is reset to its\n+     * default value of 1.0\n+     */\n+    public void setInitialStep(final double initialStep) {\n+        if (initialStep <= 0) {\n+            this.initialStep = 1.0;\n+        } else {\n+            this.initialStep = initialStep;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected RealPointValuePair doOptimize()\n+        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+        try {\n+\n+            // initialization\n+            if (preconditioner == null) {\n+                preconditioner = new IdentityPreconditioner();\n+            }\n+            if (solver == null) {\n+                solver = new BrentSolver();\n+            }\n+            final int n = point.length;\n+            double[] r = computeObjectiveGradient(point);\n+            if (goalType == GoalType.MINIMIZE) {\n+                for (int i = 0; i < n; ++i) {\n+                    r[i] = -r[i];\n+                }\n+            }\n+\n+            // initial search direction\n+            double[] steepestDescent = preconditioner.precondition(point, r);\n+            double[] searchDirection = steepestDescent.clone();\n+\n+            double delta = 0;\n+            for (int i = 0; i < n; ++i) {\n+                delta += r[i] * searchDirection[i];\n+            }\n+\n+            RealPointValuePair current = null;\n+            while (true) {\n+\n+                final double objective = computeObjectiveValue(point);\n+                RealPointValuePair previous = current;\n+                current = new RealPointValuePair(point, objective);\n+                if (previous != null) {\n+                    if (checker.converged(getIterations(), previous, current)) {\n+                        // we have found an optimum\n+                        return current;\n+                    }\n+                }\n+\n+                incrementIterationsCounter();\n+\n+                double dTd = 0;\n+                for (final double di : searchDirection) {\n+                    dTd += di * di;\n+                }\n+\n+                // find the optimal step in the search direction\n+                final UnivariateRealFunction lsf = new LineSearchFunction(searchDirection);\n+                final double step = solver.solve(lsf, 0, findUpperBound(lsf, 0, initialStep));\n+\n+                // validate new point\n+                for (int i = 0; i < point.length; ++i) {\n+                    point[i] += step * searchDirection[i];\n+                }\n+                r = computeObjectiveGradient(point);\n+                if (goalType == GoalType.MINIMIZE) {\n+                    for (int i = 0; i < n; ++i) {\n+                        r[i] = -r[i];\n+                    }\n+                }\n+\n+                // compute beta\n+                final double deltaOld = delta;\n+                final double[] newSteepestDescent = preconditioner.precondition(point, r);\n+                delta = 0;\n+                for (int i = 0; i < n; ++i) {\n+                    delta += r[i] * newSteepestDescent[i];\n+                }\n+\n+                final double beta;\n+                if (updateFormula == ConjugateGradientFormula.FLETCHER_REEVES) {\n+                    beta = delta / deltaOld;\n+                } else {\n+                    double deltaMid = 0;\n+                    for (int i = 0; i < r.length; ++i) {\n+                        deltaMid += r[i] * steepestDescent[i];\n+                    }                    \n+                    beta = (delta - deltaMid) / deltaOld;\n+                }\n+                steepestDescent = newSteepestDescent;\n+\n+                // compute conjugate search direction\n+                if ((getIterations() % n == 0) || (beta < 0)) {\n+                    // break conjugation: reset search direction\n+                    searchDirection = steepestDescent.clone();\n+                } else {\n+                    // compute new conjugate search direction\n+                    for (int i = 0; i < n; ++i) {\n+                        searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];\n+                    }\n+                }\n+\n+            }\n+\n+        } catch (ConvergenceException ce) {\n+            throw new OptimizationException(ce);\n+        }\n+    }\n+\n+    /**\n+     * Find the upper bound b ensuring bracketing of a root between a and b\n+     * @param f function whose root must be bracketed\n+     * @param a lower bound of the interval\n+     * @param h initial step to try\n+     * @return b such that f(a) and f(b) have opposite signs\n+     * @exception FunctionEvaluationException if the function cannot be computed\n+     * @exception OptimizationException if no bracket can be found\n+     */\n+    private double findUpperBound(final UnivariateRealFunction f,\n+                                  final double a, final double h)\n+        throws FunctionEvaluationException, OptimizationException {\n+        final double yA = f.value(a);\n+        double yB = yA;\n+        for (double step = h; step < Double.MAX_VALUE; step *= Math.max(2, yA / yB)) {\n+            final double b = a + step;\n+            yB = f.value(b);\n+            if (yA * yB <= 0) {\n+                return b;\n+            }\n+        }\n+        throw new OptimizationException(\"unable to bracket optimum in line search\");\n+    }\n+\n+    /** Default identity preconditioner. */\n+    private static class IdentityPreconditioner implements Preconditioner {\n+\n+        /** {@inheritDoc} */\n+        public double[] precondition(double[] variables, double[] r) {\n+            return r.clone();\n+        }\n+\n+    }\n+\n+    /** Internal class for line search.\n+     * <p>\n+     * The function represented by this class is the dot product of\n+     * the objective function gradient and the search direction. Its\n+     * value is zero when the gradient is orthogonal to the search\n+     * direction, i.e. when the objective function value is a local\n+     * extremum along the search direction.\n+     * </p>\n+     */\n+    private class LineSearchFunction implements UnivariateRealFunction {\n+        /** Search direction. */\n+        private final double[] searchDirection;\n+\n+        /** Simple constructor.\n+         * @param searchDirection search direction\n+         */\n+        public LineSearchFunction(final double[] searchDirection) {\n+            this.searchDirection = searchDirection;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double value(double x) throws FunctionEvaluationException {\n+\n+            // current point in the search direction\n+            final double[] shiftedPoint = point.clone();\n+            for (int i = 0; i < shiftedPoint.length; ++i) {\n+                shiftedPoint[i] += x * searchDirection[i];\n+            }\n+\n+            // gradient of the objective function\n+            final double[] gradient = computeObjectiveGradient(shiftedPoint);\n+\n+            // dot product with the search direction\n+            double dotProduct = 0;\n+            for (int i = 0; i < gradient.length; ++i) {\n+                dotProduct += gradient[i] * searchDirection[i];\n+            }\n+\n+            return dotProduct;\n+\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/general/Preconditioner.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.general;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+\n+/** \n+ * This interface represents a preconditioner for differentiable scalar\n+ * objective function optimizers.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface Preconditioner {\n+\n+    /** \n+     * Precondition a search direction.\n+     * <p>\n+     * The returned preconditioned search direction must be computed fast or\n+     * the algorithm performances will drop drastically. A classical approach\n+     * is to compute only the diagonal elements of the hessian and to divide\n+     * the raw search direction by these elements if they are all positive.\n+     * If at least one of them is negative, it is safer to return a clone of\n+     * the raw search direction as if the hessian was the identity matrix. The\n+     * rationale for this simplified choice is that a negative diagonal element\n+     * means the current point is far from the optimum and preconditioning will\n+     * not be efficient anyway in this case.\n+     * </p>\n+     * @param point current point at which the search direction was computed\n+     * @param r raw search direction (i.e. opposite of the gradient)\n+     * @return approximation of H<sup>-1</sup>r where H is the objective function hessian\n+     * @exception FunctionEvaluationException if no cost can be computed for the parameters\n+     * @exception IllegalArgumentException if point dimension is wrong\n+     */\n+    double[] precondition(double[] point, double[] r)\n+        throws FunctionEvaluationException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/AbstractLinearOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import java.util.Collection;\n+\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+\n+/**\n+ * Base class for implementing linear optimizers.\n+ * <p>This base class handles the boilerplate methods associated to thresholds\n+ * settings and iterations counters.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ *\n+ */\n+public abstract class AbstractLinearOptimizer implements LinearOptimizer {\n+\n+    /** Default maximal number of iterations allowed. */\n+    public static final int DEFAULT_MAX_ITERATIONS = 100;\n+\n+    /** Maximal number of iterations allowed. */\n+    private int maxIterations;\n+\n+    /** Number of iterations already performed. */\n+    private int iterations;\n+\n+    /** Linear objective function. */\n+    protected LinearObjectiveFunction f;\n+\n+    /** Linear constraints. */\n+    protected Collection<LinearConstraint> constraints;\n+\n+    /** Type of optimization goal: either {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}. */\n+    protected GoalType goalType;\n+\n+    /** Whether to restrict the variables to non-negative values. */\n+    protected boolean restrictToNonNegative;\n+\n+    /** Simple constructor with default settings.\n+     * <p>The maximal number of evaluation is set to its default value.</p>\n+     */\n+    protected AbstractLinearOptimizer() {\n+        setMaxIterations(DEFAULT_MAX_ITERATIONS);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxIterations(int maxIterations) {\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getIterations() {\n+        return iterations;\n+    }\n+\n+    /** Increment the iterations counter by 1.\n+     * @exception OptimizationException if the maximal number\n+     * of iterations is exceeded\n+     */\n+    protected void incrementIterationsCounter()\n+        throws OptimizationException {\n+        if (++iterations > maxIterations) {\n+            throw new OptimizationException(new MaxIterationsExceededException(maxIterations));\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealPointValuePair optimize(final LinearObjectiveFunction f,\n+                                       final Collection<LinearConstraint> constraints,\n+                                       final GoalType goalType, final boolean restrictToNonNegative)\n+         throws OptimizationException {\n+\n+        // store linear problem characteristics\n+        this.f                     = f;\n+        this.constraints           = constraints;\n+        this.goalType              = goalType;\n+        this.restrictToNonNegative = restrictToNonNegative;\n+\n+        iterations  = 0;\n+\n+        // solve the problem\n+        return doOptimize();\n+\n+    }\n+\n+    /** Perform the bulk of optimization algorithm.\n+     * @return the point/value pair giving the optimal value for objective function\n+     * @exception OptimizationException if no solution fulfilling the constraints\n+     * can be found in the allowed number of iterations\n+     */\n+    abstract protected RealPointValuePair doOptimize()\n+        throws OptimizationException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/LinearConstraint.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.linear.ArrayRealVector;\n+\n+\n+/**\n+ * A linear constraint for a linear optimization problem.\n+ * <p>\n+ * A linear constraint has one of the forms:\n+ * <ul>\n+ *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> = v</li>\n+ *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> &lt;= v</li>\n+ *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> >= v</li>\n+ *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> =\n+ *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+ *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> &lt;=\n+ *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+ *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> >=\n+ *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+ * </ul>\n+ * The c<sub>i</sub>, l<sub>i</sub> or r<sub>i</sub> are the coefficients of the constraints, the x<sub>i</sub>\n+ * are the coordinates of the current point and v is the value of the constraint.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class LinearConstraint implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -764632794033034092L;\n+\n+    /** Coefficients of the constraint (left hand side). */\n+    private final transient RealVector coefficients;\n+\n+    /** Relationship between left and right hand sides (=, &lt;=, >=). */\n+    private final Relationship relationship;\n+\n+    /** Value of the constraint (right hand side). */\n+    private final double value;\n+\n+    /**\n+     * Build a constraint involving a single linear equation.\n+     * <p>\n+     * A linear constraint with a single linear equation has one of the forms:\n+     * <ul>\n+     *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> = v</li>\n+     *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> &lt;= v</li>\n+     *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> >= v</li>\n+     * </ul>\n+     * </p>\n+     * @param coefficients The coefficients of the constraint (left hand side)\n+     * @param relationship The type of (in)equality used in the constraint\n+     * @param value The value of the constraint (right hand side)\n+     */\n+    public LinearConstraint(final double[] coefficients, final Relationship relationship,\n+                            final double value) {\n+        this(new ArrayRealVector(coefficients), relationship, value);\n+    }\n+\n+    /**\n+     * Build a constraint involving a single linear equation.\n+     * <p>\n+     * A linear constraint with a single linear equation has one of the forms:\n+     * <ul>\n+     *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> = v</li>\n+     *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> &lt;= v</li>\n+     *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> >= v</li>\n+     * </ul>\n+     * </p>\n+     * @param coefficients The coefficients of the constraint (left hand side)\n+     * @param relationship The type of (in)equality used in the constraint\n+     * @param value The value of the constraint (right hand side)\n+     */\n+    public LinearConstraint(final RealVector coefficients, final Relationship relationship,\n+                            final double value) {\n+        this.coefficients = coefficients;\n+        this.relationship = relationship;\n+        this.value        = value;\n+    }\n+\n+    /**\n+     * Build a constraint involving two linear equations.\n+     * <p>\n+     * A linear constraint with two linear equation has one of the forms:\n+     * <ul>\n+     *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> =\n+     *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+     *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> &lt;=\n+     *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+     *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> >=\n+     *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+     * </ul>\n+     * </p>\n+     * @param lhsCoefficients The coefficients of the linear expression on the left hand side of the constraint\n+     * @param lhsConstant The constant term of the linear expression on the left hand side of the constraint\n+     * @param relationship The type of (in)equality used in the constraint\n+     * @param rhsCoefficients The coefficients of the linear expression on the right hand side of the constraint\n+     * @param rhsConstant The constant term of the linear expression on the right hand side of the constraint\n+     */\n+    public LinearConstraint(final double[] lhsCoefficients, final double lhsConstant,\n+                            final Relationship relationship,\n+                            final double[] rhsCoefficients, final double rhsConstant) {\n+        double[] sub = new double[lhsCoefficients.length];\n+        for (int i = 0; i < sub.length; ++i) {\n+            sub[i] = lhsCoefficients[i] - rhsCoefficients[i];\n+        }\n+        this.coefficients = new ArrayRealVector(sub, false);\n+        this.relationship = relationship;\n+        this.value        = rhsConstant - lhsConstant;\n+    }\n+\n+    /**\n+     * Build a constraint involving two linear equations.\n+     * <p>\n+     * A linear constraint with two linear equation has one of the forms:\n+     * <ul>\n+     *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> =\n+     *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+     *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> &lt;=\n+     *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+     *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> >=\n+     *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+     * </ul>\n+     * </p>\n+     * @param lhsCoefficients The coefficients of the linear expression on the left hand side of the constraint\n+     * @param lhsConstant The constant term of the linear expression on the left hand side of the constraint\n+     * @param relationship The type of (in)equality used in the constraint\n+     * @param rhsCoefficients The coefficients of the linear expression on the right hand side of the constraint\n+     * @param rhsConstant The constant term of the linear expression on the right hand side of the constraint\n+     */\n+    public LinearConstraint(final RealVector lhsCoefficients, final double lhsConstant,\n+                            final Relationship relationship,\n+                            final RealVector rhsCoefficients, final double rhsConstant) {\n+        this.coefficients = lhsCoefficients.subtract(rhsCoefficients);\n+        this.relationship = relationship;\n+        this.value        = rhsConstant - lhsConstant;\n+    }\n+\n+    /**\n+     * Get the coefficients of the constraint (left hand side).\n+     * @return coefficients of the constraint (left hand side)\n+     */\n+    public RealVector getCoefficients() {\n+        return coefficients;\n+    }\n+\n+    /**\n+     * Get the relationship between left and right hand sides.\n+     * @return relationship between left and right hand sides\n+     */\n+    public Relationship getRelationship() {\n+        return relationship;\n+    }\n+\n+    /**\n+     * Get the value of the constraint (right hand side).\n+     * @return value of the constraint (right hand side)\n+     */\n+    public double getValue() {\n+        return value;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean equals(Object other) {\n+\n+      if (this == other) { \n+        return true;\n+      }\n+\n+      if (other == null) {\n+        return false;\n+      }\n+\n+      try {\n+\n+          LinearConstraint rhs = (LinearConstraint) other;\n+          return (relationship == rhs.relationship) &&\n+                 (value        == rhs.value) &&\n+                 coefficients.equals(rhs.coefficients);\n+\n+      } catch (ClassCastException ex) {\n+          // ignore exception\n+          return false;\n+      }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Override\n+    public int hashCode() {\n+        return relationship.hashCode() ^\n+               Double.valueOf(value).hashCode() ^\n+               coefficients.hashCode();\n+    }\n+\n+    /** Serialize the instance.\n+     * @param oos stream where object should be written\n+     * @throws IOException if object cannot be written to stream\n+     */\n+    private void writeObject(ObjectOutputStream oos)\n+        throws IOException {\n+        oos.defaultWriteObject();\n+        MatrixUtils.serializeRealVector(coefficients, oos);\n+    }\n+\n+    /** Deserialize the instance.\n+     * @param ois stream from which the object should be read\n+     * @throws ClassNotFoundException if a class in the stream cannot be found\n+     * @throws IOException if object cannot be read from the stream\n+     */\n+    private void readObject(ObjectInputStream ois)\n+      throws ClassNotFoundException, IOException {\n+        ois.defaultReadObject();\n+        MatrixUtils.deserializeRealVector(this, \"coefficients\", ois);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/LinearObjectiveFunction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.linear.ArrayRealVector;\n+\n+/**\n+ * An objective function for a linear optimization problem.\n+ * <p>\n+ * A linear objective function has one the form:\n+ * <pre>\n+ * c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> + d\n+ * </pre>\n+ * The c<sub>i</sub> and d are the coefficients of the equation,\n+ * the x<sub>i</sub> are the coordinates of the current point.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class LinearObjectiveFunction implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -4531815507568396090L;\n+\n+    /** Coefficients of the constraint (c<sub>i</sub>). */\n+    private final transient RealVector coefficients;\n+\n+    /** Constant term of the linear equation. */\n+    private final double constantTerm;\n+\n+    /**\n+     * @param coefficients The coefficients for the linear equation being optimized\n+     * @param constantTerm The constant term of the linear equation\n+     */\n+    public LinearObjectiveFunction(double[] coefficients, double constantTerm) {\n+        this(new ArrayRealVector(coefficients), constantTerm);\n+    }\n+\n+    /**\n+     * @param coefficients The coefficients for the linear equation being optimized\n+     * @param constantTerm The constant term of the linear equation\n+     */\n+    public LinearObjectiveFunction(RealVector coefficients, double constantTerm) {\n+        this.coefficients = coefficients;\n+        this.constantTerm = constantTerm;\n+    }\n+\n+    /**\n+     * Get the coefficients of the linear equation being optimized.\n+     * @return coefficients of the linear equation being optimized\n+     */\n+    public RealVector getCoefficients() {\n+        return coefficients;\n+    }\n+\n+    /**\n+     * Get the constant of the linear equation being optimized.\n+     * @return constant of the linear equation being optimized\n+     */\n+    public double getConstantTerm() {\n+        return constantTerm;\n+    }\n+\n+    /**\n+     * Compute the value of the linear equation at the current point\n+     * @param point point at which linear equation must be evaluated\n+     * @return value of the linear equation at the current point\n+     */\n+    public double getValue(final double[] point) {\n+        return coefficients.dotProduct(point) + constantTerm;\n+    }\n+\n+    /**\n+     * Compute the value of the linear equation at the current point\n+     * @param point point at which linear equation must be evaluated\n+     * @return value of the linear equation at the current point\n+     */\n+    public double getValue(final RealVector point) {\n+        return coefficients.dotProduct(point) + constantTerm;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean equals(Object other) {\n+\n+      if (this == other) { \n+        return true;\n+      }\n+\n+      if (other == null) {\n+        return false;\n+      }\n+\n+      try {\n+\n+          LinearObjectiveFunction rhs = (LinearObjectiveFunction) other;\n+          return (constantTerm == rhs.constantTerm) && coefficients.equals(rhs.coefficients);\n+\n+      } catch (ClassCastException ex) {\n+          // ignore exception\n+          return false;\n+      }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Override\n+    public int hashCode() {\n+        return Double.valueOf(constantTerm).hashCode() ^ coefficients.hashCode();\n+    }\n+\n+    /** Serialize the instance.\n+     * @param oos stream where object should be written\n+     * @throws IOException if object cannot be written to stream\n+     */\n+    private void writeObject(ObjectOutputStream oos)\n+        throws IOException {\n+        oos.defaultWriteObject();\n+        MatrixUtils.serializeRealVector(coefficients, oos);\n+    }\n+\n+    /** Deserialize the instance.\n+     * @param ois stream from which the object should be read\n+     * @throws ClassNotFoundException if a class in the stream cannot be found\n+     * @throws IOException if object cannot be read from the stream\n+     */\n+    private void readObject(ObjectInputStream ois)\n+      throws ClassNotFoundException, IOException {\n+        ois.defaultReadObject();\n+        MatrixUtils.deserializeRealVector(this, \"coefficients\", ois);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/LinearOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import java.util.Collection;\n+\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+\n+/** \n+ * This interface represents an optimization algorithm for linear problems.\n+ * <p>Optimization algorithms find the input point set that either {@link GoalType\n+ * maximize or minimize} an objective function. In the linear case the form of\n+ * the function is restricted to\n+ * <pre>\n+ * c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> = v\n+ * </pre>\n+ * and there may be linear constraints too, of one of the forms:\n+ * <ul>\n+ *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> = v</li>\n+ *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> &lt;= v</li>\n+ *   <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> >= v</li>\n+ *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> =\n+ *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+ *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> &lt;=\n+ *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+ *   <li>l<sub>1</sub>x<sub>1</sub> + ... l<sub>n</sub>x<sub>n</sub> + l<sub>cst</sub> >=\n+ *       r<sub>1</sub>x<sub>1</sub> + ... r<sub>n</sub>x<sub>n</sub> + r<sub>cst</sub></li>\n+ * </ul>\n+ * where the c<sub>i</sub>, l<sub>i</sub> or r<sub>i</sub> are the coefficients of\n+ * the constraints, the x<sub>i</sub> are the coordinates of the current point and\n+ * v is the value of the constraint.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface LinearOptimizer {\n+\n+    /** Set the maximal number of iterations of the algorithm.\n+     * @param maxIterations maximal number of function calls\n+     */\n+    void setMaxIterations(int maxIterations);\n+\n+    /** Get the maximal number of iterations of the algorithm.\n+     * @return maximal number of iterations\n+     */\n+    int getMaxIterations();\n+\n+    /** Get the number of iterations realized by the algorithm.\n+     * <p>\n+     * The number of evaluations corresponds to the last call to the\n+     * {@link #optimize(LinearObjectiveFunction, Collection, GoalType, boolean) optimize}\n+     * method. It is 0 if the method has not been called yet.\n+     * </p>\n+     * @return number of iterations\n+     */\n+    int getIterations();\n+\n+    /** Optimizes an objective function.\n+     * @param f linear objective function\n+     * @param constraints linear constraints\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param restrictToNonNegative whether to restrict the variables to non-negative values\n+     * @return point/value pair giving the optimal value for objective function\n+     * @exception OptimizationException if no solution fulfilling the constraints\n+     * can be found in the allowed number of iterations\n+     */\n+   RealPointValuePair optimize(LinearObjectiveFunction f, Collection<LinearConstraint> constraints,\n+                               GoalType goalType, boolean restrictToNonNegative)\n+        throws OptimizationException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/NoFeasibleSolutionException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import org.apache.commons.math.optimization.OptimizationException;\n+\n+/**\n+ * This class represents exceptions thrown by optimizers when no solution\n+ * fulfills the constraints.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class NoFeasibleSolutionException extends OptimizationException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -3044253632189082760L;\n+\n+    /** \n+     * Simple constructor using a default message.\n+     */\n+    public NoFeasibleSolutionException() {\n+        super(\"no feasible solution\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/Relationship.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+/**\n+ * Types of relationships between two cells in a Solver {@link LinearConstraint}.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public enum Relationship {\n+\n+    /** Equality relationship. */\n+    EQ(\"=\"),\n+\n+    /** Lesser than or equal relationship. */\n+    LEQ(\"<=\"),\n+\n+    /** Greater than or equal relationship. */\n+    GEQ(\">=\");\n+\n+    /** Display string for the relationship. */\n+    private String stringValue;\n+\n+    /** Simple constructor.\n+     * @param stringValue display string for the relationship\n+     */\n+    private Relationship(String stringValue) {\n+        this.stringValue = stringValue;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public String toString() {\n+        return stringValue;\n+    }\n+\n+    /**\n+     * Get the relationship obtained when multiplying all coefficients by -1.\n+     * @return relationship obtained when multiplying all coefficients by -1\n+     */\n+    public Relationship oppositeRelationship() {\n+        switch (this) {\n+        case LEQ :\n+            return GEQ;\n+        case GEQ :\n+            return LEQ;\n+        default :\n+            return EQ;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import org.apache.commons.math.optimization.OptimizationException;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.util.MathUtils;\n+\n+\n+/**\n+ * Solves a linear problem using the Two-Phase Simplex Method.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class SimplexSolver extends AbstractLinearOptimizer {\n+\n+    /** Default amount of error to accept in floating point comparisons. */ \n+    private static final double DEFAULT_EPSILON = 1.0e-6;\n+\n+    /** Amount of error to accept in floating point comparisons. */ \n+    protected final double epsilon;  \n+\n+    /**\n+     * Build a simplex solver with default settings.\n+     */\n+    public SimplexSolver() {\n+        this(DEFAULT_EPSILON);\n+    }\n+\n+    /**\n+     * Build a simplex solver with a specified accepted amount of error\n+     * @param epsilon the amount of error to accept in floating point comparisons\n+     */\n+    public SimplexSolver(final double epsilon) {\n+        this.epsilon = epsilon;\n+    }\n+\n+    /**\n+     * Returns the column with the most negative coefficient in the objective function row.\n+     * @param tableau simple tableau for the problem\n+     * @return column with the most negative coefficient\n+     */\n+    private Integer getPivotColumn(SimplexTableau tableau) {\n+        double minValue = 0;\n+        Integer minPos = null;\n+        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n+            if (MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon) < 0) {\n+                minValue = tableau.getEntry(0, i);\n+                minPos = i;\n+            }\n+        }\n+        return minPos;\n+    }\n+\n+    /**\n+     * Returns the row with the minimum ratio as given by the minimum ratio test (MRT).\n+     * @param tableau simple tableau for the problem\n+     * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n+     * @return row with the minimum ratio\n+     */\n+    private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n+        double minRatio = Double.MAX_VALUE;\n+        Integer minRatioPos = null;\n+        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n+            double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n+            if (MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon) >= 0) {\n+                double ratio = rhs / tableau.getEntry(i, col);\n+                if (ratio < minRatio) {\n+                    minRatio = ratio;\n+                    minRatioPos = i; \n+                }\n+            }\n+        }\n+        return minRatioPos;\n+    }\n+\n+\n+    /**\n+     * Runs one iteration of the Simplex method on the given model.\n+     * @param tableau simple tableau for the problem\n+     * @throws OptimizationException if the maximal iteration count has been\n+     * exceeded or if the model is found not to have a bounded solution\n+     */\n+    protected void doIteration(final SimplexTableau tableau)\n+        throws OptimizationException {\n+\n+        incrementIterationsCounter();\n+\n+        Integer pivotCol = getPivotColumn(tableau);\n+        Integer pivotRow = getPivotRow(pivotCol, tableau);\n+        if (pivotRow == null) {\n+            throw new UnboundedSolutionException();\n+        }\n+\n+        // set the pivot element to 1\n+        double pivotVal = tableau.getEntry(pivotRow, pivotCol);\n+        tableau.divideRow(pivotRow, pivotVal);\n+\n+        // set the rest of the pivot column to 0\n+        for (int i = 0; i < tableau.getHeight(); i++) {\n+            if (i != pivotRow) {\n+                double multiplier = tableau.getEntry(i, pivotCol);\n+                tableau.subtractRow(i, pivotRow, multiplier);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Checks whether Phase 1 is solved.\n+     * @param tableau simple tableau for the problem\n+     * @return whether Phase 1 is solved\n+     */\n+    private boolean isPhase1Solved(final SimplexTableau tableau) {\n+        if (tableau.getNumArtificialVariables() == 0) {\n+            return true;\n+        }\n+        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n+            if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns whether the problem is at an optimal state.\n+     * @param tableau simple tableau for the problem\n+     * @return whether the model has been solved\n+     */\n+    public boolean isOptimal(final SimplexTableau tableau) {\n+        if (tableau.getNumArtificialVariables() > 0) {\n+            return false;\n+        }\n+        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n+            if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Solves Phase 1 of the Simplex method.\n+     * @param tableau simple tableau for the problem\n+     * @exception OptimizationException if the maximal number of iterations is\n+     * exceeded, or if the problem is found not to have a bounded solution, or\n+     * if there is no feasible solution\n+     */\n+    protected void solvePhase1(final SimplexTableau tableau)\n+        throws OptimizationException {\n+        // make sure we're in Phase 1\n+        if (tableau.getNumArtificialVariables() == 0) {\n+            return;\n+        }\n+\n+        while (!isPhase1Solved(tableau)) {\n+            doIteration(tableau);\n+        }\n+\n+        // if W is not zero then we have no feasible solution\n+        if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon)) {\n+            throw new NoFeasibleSolutionException();\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealPointValuePair doOptimize()\n+        throws OptimizationException {\n+        final SimplexTableau tableau =\n+            new SimplexTableau(f, constraints, goalType, restrictToNonNegative, epsilon);\n+        solvePhase1(tableau);\n+        tableau.discardArtificialVariables();\n+        while (!isOptimal(tableau)) {\n+            doIteration(tableau);\n+        }\n+        return tableau.getSolution();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * A tableau for use in the Simplex method.\n+ * \n+ * <p>\n+ * Example:\n+ * <pre>\n+ *   W |  Z |  x1 |  x2 |  x- | s1 |  s2 |  a1 |  RHS\n+ * ---------------------------------------------------\n+ *  -1    0    0     0     0     0     0     1     0   &lt;= phase 1 objective\n+ *   0    1   -15   -10    0     0     0     0     0   &lt;= phase 2 objective\n+ *   0    0    1     0     0     1     0     0     2   &lt;= constraint 1\n+ *   0    0    0     1     0     0     1     0     3   &lt;= constraint 2\n+ *   0    0    1     1     0     0     0     1     4   &lt;= constraint 3\n+ * </pre>\n+ * W: Phase 1 objective function</br>\n+ * Z: Phase 2 objective function</br>\n+ * x1 &amp; x2: Decision variables</br>\n+ * x-: Extra decision variable to allow for negative values</br>\n+ * s1 &amp; s2: Slack/Surplus variables</br>\n+ * a1: Artificial variable</br>\n+ * RHS: Right hand side</br>\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+class SimplexTableau implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -1369660067587938365L;\n+\n+    /** Linear objective function. */\n+    private final LinearObjectiveFunction f;\n+\n+    /** Linear constraints. */\n+    private final Collection<LinearConstraint> constraints;\n+\n+    /** Whether to restrict the variables to non-negative values. */\n+    private final boolean restrictToNonNegative;\n+\n+    /** Simple tableau. */\n+    protected transient RealMatrix tableau;\n+\n+    /** Number of decision variables. */\n+    protected final int numDecisionVariables;\n+\n+    /** Number of slack variables. */\n+    protected final int numSlackVariables;\n+\n+    /** Number of artificial variables. */\n+    protected int numArtificialVariables;\n+\n+    /** Amount of error to accept in floating point comparisons. */ \n+    protected final double epsilon;\n+    \n+    /**\n+     * Build a tableau for a linear problem.\n+     * @param f linear objective function\n+     * @param constraints linear constraints\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param restrictToNonNegative whether to restrict the variables to non-negative values\n+     * @param epsilon amount of error to accept in floating point comparisons\n+     */\n+    SimplexTableau(final LinearObjectiveFunction f,\n+                   final Collection<LinearConstraint> constraints,\n+                   final GoalType goalType, final boolean restrictToNonNegative,\n+                   final double epsilon) {\n+        this.f                      = f;\n+        this.constraints            = constraints;\n+        this.restrictToNonNegative  = restrictToNonNegative;\n+        this.epsilon                = epsilon;\n+        this.numDecisionVariables   = getNumVariables() + (restrictToNonNegative ? 0 : 1);\n+        this.numSlackVariables      = getConstraintTypeCounts(Relationship.LEQ) +\n+                                      getConstraintTypeCounts(Relationship.GEQ);\n+        this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) +\n+                                      getConstraintTypeCounts(Relationship.GEQ);\n+        this.tableau = new Array2DRowRealMatrix(createTableau(goalType == GoalType.MAXIMIZE));\n+        initialize();\n+    }\n+\n+    /**\n+     * Create the tableau by itself.\n+     * @param maximize if true, goal is to maximize the objective function\n+     * @return created tableau\n+     */\n+    protected double[][] createTableau(final boolean maximize) {\n+\n+        // create a matrix of the correct size\n+        List<LinearConstraint> constraints = getNormalizedConstraints();\n+        int width = numDecisionVariables + numSlackVariables +\n+        numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS\n+        int height = constraints.size() + getNumObjectiveFunctions();\n+        double[][] matrix = new double[height][width];\n+\n+        // initialize the objective function rows\n+        if (getNumObjectiveFunctions() == 2) {\n+            matrix[0][0] = -1;\n+        }\n+        int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n+        matrix[zIndex][zIndex] = maximize ? 1 : -1;\n+        RealVector objectiveCoefficients =\n+            maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n+            copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());\n+            matrix[zIndex][width - 1] =\n+                maximize ? f.getConstantTerm() : -1 * f.getConstantTerm();\n+\n+                if (!restrictToNonNegative) {\n+                    matrix[zIndex][getSlackVariableOffset() - 1] =\n+                        getInvertedCoeffiecientSum(objectiveCoefficients);\n+                }\n+\n+                // initialize the constraint rows\n+                int slackVar = 0;\n+                int artificialVar = 0;\n+                for (int i = 0; i < constraints.size(); i++) {\n+                    LinearConstraint constraint = constraints.get(i);\n+                    int row = getNumObjectiveFunctions() + i;\n+\n+                    // decision variable coefficients\n+                    copyArray(constraint.getCoefficients().getData(), matrix[row], 1);\n+\n+                    // x-\n+                    if (!restrictToNonNegative) {\n+                        matrix[row][getSlackVariableOffset() - 1] =\n+                            getInvertedCoeffiecientSum(constraint.getCoefficients());\n+                    }\n+\n+                    // RHS\n+                    matrix[row][width - 1] = constraint.getValue();\n+\n+                    // slack variables\n+                    if (constraint.getRelationship() == Relationship.LEQ) {\n+                        matrix[row][getSlackVariableOffset() + slackVar++] = 1;  // slack\n+                    } else if (constraint.getRelationship() == Relationship.GEQ) {\n+                        matrix[row][getSlackVariableOffset() + slackVar++] = -1; // excess\n+                    }\n+\n+                    // artificial variables\n+                    if ((constraint.getRelationship() == Relationship.EQ) ||\n+                        (constraint.getRelationship() == Relationship.GEQ)) {\n+                        matrix[0][getArtificialVariableOffset() + artificialVar] = 1; \n+                        matrix[row][getArtificialVariableOffset() + artificialVar++] = 1; \n+                    }\n+                }\n+\n+                return matrix;\n+    }\n+\n+    /** Get the number of variables.\n+     * @return number of variables\n+     */\n+    public int getNumVariables() {\n+        return f.getCoefficients().getDimension();\n+    }\n+\n+    /**\n+     * Get new versions of the constraints which have positive right hand sides.\n+     * @return new versions of the constraints\n+     */\n+    public List<LinearConstraint> getNormalizedConstraints() {\n+        List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();\n+        for (LinearConstraint constraint : constraints) {\n+            normalized.add(normalize(constraint));\n+        }\n+        return normalized;\n+    }\n+\n+    /**\n+     * Get a new equation equivalent to this one with a positive right hand side.\n+     * @param constraint reference constraint\n+     * @return new equation\n+     */\n+    private LinearConstraint normalize(final LinearConstraint constraint) {\n+        if (constraint.getValue() < 0) {\n+            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n+                                        constraint.getRelationship().oppositeRelationship(),\n+                                        -1 * constraint.getValue());\n+        }\n+        return new LinearConstraint(constraint.getCoefficients(), \n+                                    constraint.getRelationship(), constraint.getValue());\n+    }\n+\n+    /**\n+     * Get the number of objective functions in this tableau.\n+     * @return 2 for Phase 1.  1 for Phase 2.\n+     */\n+    protected final int getNumObjectiveFunctions() {\n+        return this.numArtificialVariables > 0 ? 2 : 1;\n+    }\n+\n+    /**\n+     * Get a count of constraints corresponding to a specified relationship.\n+     * @param relationship relationship to count\n+     * @return number of constraint with the specified relationship\n+     */\n+    private int getConstraintTypeCounts(final Relationship relationship) {\n+        int count = 0;\n+        for (final LinearConstraint constraint : constraints) {\n+            if (constraint.getRelationship() == relationship) {\n+                ++count;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * Puts the tableau in proper form by zeroing out the artificial variables\n+     * in the objective function via elementary row operations.\n+     */\n+    private void initialize() {\n+        for (int artificialVar = 0; artificialVar < numArtificialVariables; artificialVar++) {\n+            int row = getBasicRow(getArtificialVariableOffset() + artificialVar);\n+            subtractRow(0, row, 1.0);\n+        }\n+    }\n+\n+    /**\n+     * Get the -1 times the sum of all coefficients in the given array.\n+     * @param coefficients coefficients to sum\n+     * @return the -1 times the sum of all coefficients in the given array.\n+     */\n+    protected static double getInvertedCoeffiecientSum(final RealVector coefficients) {\n+        double sum = 0;\n+        for (double coefficient : coefficients.getData()) {\n+            sum -= coefficient;\n+        }\n+        return sum;\n+    }\n+\n+    /**\n+     * Checks whether the given column is basic.\n+     * @param col index of the column to check\n+     * @return the row that the variable is basic in.  null if the column is not basic\n+     */\n+    private Integer getBasicRow(final int col) {\n+        Integer row = null;\n+        for (int i = getNumObjectiveFunctions(); i < getHeight(); i++) {\n+            if (MathUtils.equals(getEntry(i, col), 1.0, epsilon) && (row == null)) {\n+                row = i;\n+            } else if (!MathUtils.equals(getEntry(i, col), 0.0, epsilon)) {\n+                return null;\n+            }\n+        }\n+        return row;\n+    }\n+\n+    /**\n+     * Removes the phase 1 objective function and artificial variables from this tableau.\n+     */\n+    protected void discardArtificialVariables() {\n+        if (numArtificialVariables == 0) {\n+            return;\n+        }\n+        int width = getWidth() - numArtificialVariables - 1;\n+        int height = getHeight() - 1;\n+        double[][] matrix = new double[height][width];\n+        for (int i = 0; i < height; i++) {\n+            for (int j = 0; j < width - 1; j++) {\n+                matrix[i][j] = getEntry(i + 1, j + 1);\n+            }\n+            matrix[i][width - 1] = getEntry(i + 1, getRhsOffset());\n+        }\n+        this.tableau = new Array2DRowRealMatrix(matrix);\n+        this.numArtificialVariables = 0;\n+    }\n+\n+\n+    /**\n+     * @param src the source array\n+     * @param dest the destination array\n+     * @param destPos the destination position\n+     */\n+    private void copyArray(final double[] src, final double[] dest,\n+                           final int destPos) {\n+        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length); \n+    }\n+\n+    /**\n+     * Get the current solution.\n+     * \n+     * @return current solution\n+     */\n+    protected RealPointValuePair getSolution() {\n+        double[] coefficients = new double[getOriginalNumDecisionVariables()];\n+        Integer basicRow =\n+            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n+        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n+        Set<Integer> basicRows = new HashSet<Integer>();\n+        for (int i = 0; i < coefficients.length; i++) {\n+            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n+            if (basicRows.contains(basicRow)) {\n+                // if multiple variables can take a given value \n+                // then we choose the first and set the rest equal to 0\n+                coefficients[i] = 0;\n+            } else {\n+                basicRows.add(basicRow);\n+                coefficients[i] =\n+                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n+                    (restrictToNonNegative ? 0 : mostNegative);\n+            }\n+        }\n+        return new RealPointValuePair(coefficients, f.getValue(coefficients));\n+    }\n+\n+    /**\n+     * Subtracts a multiple of one row from another.\n+     * <p>\n+     * After application of this operation, the following will hold:\n+     *   minuendRow = minuendRow - multiple * subtrahendRow\n+     * </p>\n+     * @param dividendRow index of the row\n+     * @param divisor value of the divisor\n+     */\n+    protected void divideRow(final int dividendRow, final double divisor) {\n+        for (int j = 0; j < getWidth(); j++) {\n+            tableau.setEntry(dividendRow, j, tableau.getEntry(dividendRow, j) / divisor);\n+        }\n+    }\n+\n+    /**\n+     * Subtracts a multiple of one row from another.\n+     * <p>\n+     * After application of this operation, the following will hold:\n+     *   minuendRow = minuendRow - multiple * subtrahendRow\n+     * </p>\n+     * @param minuendRow row index\n+     * @param subtrahendRow row index\n+     * @param multiple multiplication factor\n+     */\n+    protected void subtractRow(final int minuendRow, final int subtrahendRow,\n+                               final double multiple) {\n+        for (int j = 0; j < getWidth(); j++) {\n+            tableau.setEntry(minuendRow, j, tableau.getEntry(minuendRow, j) -\n+                             multiple * tableau.getEntry(subtrahendRow, j));\n+        }\n+    }\n+\n+    /**\n+     * Get the width of the tableau.\n+     * @return width of the tableau\n+     */\n+    protected final int getWidth() {\n+        return tableau.getColumnDimension();\n+    }\n+\n+    /**\n+     * Get the height of the tableau.\n+     * @return height of the tableau\n+     */\n+    protected final int getHeight() {\n+        return tableau.getRowDimension();\n+    }\n+\n+    /** Get an entry of the tableau.\n+     * @param row row index\n+     * @param column column index\n+     * @return entry at (row, column)\n+     */\n+    protected final double getEntry(final int row, final int column) {\n+        return tableau.getEntry(row, column);\n+    }\n+\n+    /** Set an entry of the tableau.\n+     * @param row row index\n+     * @param column column index\n+     * @param value for the entry\n+     */\n+    protected final void setEntry(final int row, final int column,\n+                                  final double value) {\n+        tableau.setEntry(row, column, value);\n+    }\n+\n+    /**\n+     * Get the offset of the first slack variable.\n+     * @return offset of the first slack variable\n+     */\n+    protected final int getSlackVariableOffset() {\n+        return getNumObjectiveFunctions() + numDecisionVariables;\n+    }\n+\n+    /**\n+     * Get the offset of the first artificial variable.\n+     * @return offset of the first artificial variable\n+     */\n+    protected final int getArtificialVariableOffset() {\n+        return getNumObjectiveFunctions() + numDecisionVariables + numSlackVariables;\n+    }\n+\n+    /**\n+     * Get the offset of the right hand side.\n+     * @return offset of the right hand side\n+     */\n+    protected final int getRhsOffset() {\n+        return getWidth() - 1;\n+    }\n+\n+    /**\n+     * Get the number of decision variables.\n+     * <p>\n+     * If variables are not restricted to positive values, this will include 1\n+     * extra decision variable to represent the absolute value of the most\n+     * negative variable.\n+     * </p>\n+     * @return number of decision variables\n+     * @see #getOriginalNumDecisionVariables()\n+     */\n+    protected final int getNumDecisionVariables() {\n+        return numDecisionVariables;\n+    }\n+\n+    /**\n+     * Get the original number of decision variables.\n+     * @return original number of decision variables\n+     * @see #getNumDecisionVariables()\n+     */\n+    protected final int getOriginalNumDecisionVariables() {\n+        return restrictToNonNegative ? numDecisionVariables : numDecisionVariables - 1;\n+    }\n+\n+    /**\n+     * Get the number of slack variables.\n+     * @return number of slack variables\n+     */\n+    protected final int getNumSlackVariables() {\n+        return numSlackVariables;\n+    }\n+\n+    /**\n+     * Get the number of artificial variables.\n+     * @return number of artificial variables\n+     */\n+    protected final int getNumArtificialVariables() {\n+        return numArtificialVariables;\n+    }\n+\n+    /**\n+     * Get the tableau data.\n+     * @return tableau data\n+     */\n+    protected final double[][] getData() {\n+        return tableau.getData();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean equals(Object other) {\n+\n+      if (this == other) { \n+        return true;\n+      }\n+\n+      if (other == null) {\n+        return false;\n+      }\n+\n+      try {\n+\n+          SimplexTableau rhs = (SimplexTableau) other;\n+          return (restrictToNonNegative  == rhs.restrictToNonNegative) &&\n+                 (numDecisionVariables   == rhs.numDecisionVariables) &&\n+                 (numSlackVariables      == rhs.numSlackVariables) &&\n+                 (numArtificialVariables == rhs.numArtificialVariables) &&\n+                 (epsilon                == rhs.epsilon) &&\n+                 f.equals(rhs.f) &&\n+                 constraints.equals(rhs.constraints) &&\n+                 tableau.equals(rhs.tableau);\n+\n+      } catch (ClassCastException ex) {\n+          // ignore exception\n+          return false;\n+      }\n+\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Override\n+    public int hashCode() {\n+        return Boolean.valueOf(restrictToNonNegative).hashCode() ^\n+               numDecisionVariables ^\n+               numSlackVariables ^\n+               numArtificialVariables ^\n+               Double.valueOf(epsilon).hashCode() ^\n+               f.hashCode() ^\n+               constraints.hashCode() ^\n+               tableau.hashCode();\n+    }\n+\n+    /** Serialize the instance.\n+     * @param oos stream where object should be written\n+     * @throws IOException if object cannot be written to stream\n+     */\n+    private void writeObject(ObjectOutputStream oos)\n+        throws IOException {\n+        oos.defaultWriteObject();\n+        MatrixUtils.serializeRealMatrix(tableau, oos);\n+    }\n+\n+    /** Deserialize the instance.\n+     * @param ois stream from which the object should be read\n+     * @throws ClassNotFoundException if a class in the stream cannot be found\n+     * @throws IOException if object cannot be read from the stream\n+     */\n+    private void readObject(ObjectInputStream ois)\n+      throws ClassNotFoundException, IOException {\n+        ois.defaultReadObject();\n+        MatrixUtils.deserializeRealMatrix(this, \"tableau\", ois);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/UnboundedSolutionException.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.linear;\n+\n+import org.apache.commons.math.optimization.OptimizationException;\n+\n+/**\n+ * This class represents exceptions thrown by optimizers when a solution\n+ * escapes to infinity.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class UnboundedSolutionException extends OptimizationException {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 940539497277290619L;\n+\n+    /** \n+     * Simple constructor using a default message.\n+     */\n+    public UnboundedSolutionException() {\n+        super(\"unbounded solution\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.univariate;\n+\n+import org.apache.commons.math.ConvergingAlgorithmImpl;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.MaxEvaluationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.optimization.UnivariateRealOptimizer;\n+\n+/**\n+ * Provide a default implementation for several functions useful to generic\n+ * optimizers.\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class AbstractUnivariateRealOptimizer\n+    extends ConvergingAlgorithmImpl implements UnivariateRealOptimizer {\n+\n+    /** Indicates where a root has been computed. */\n+    protected boolean resultComputed;\n+\n+    /** The last computed root. */\n+    protected double result;\n+\n+    /** Value of the function at the last computed result. */\n+    protected double functionValue;\n+\n+    /** Maximal number of evaluations allowed. */\n+    private int maxEvaluations;\n+\n+    /** Number of evaluations already performed. */\n+    private int evaluations;\n+\n+    /**\n+     * Construct a solver with given iteration count and accuracy.\n+     * FunctionEvaluationExceptionFunctionEvaluationException\n+     * @param defaultAbsoluteAccuracy maximum absolute error\n+     * @param defaultMaximalIterationCount maximum number of iterations\n+     * @throws IllegalArgumentException if f is null or the \n+     * defaultAbsoluteAccuracy is not valid\n+     */\n+    protected AbstractUnivariateRealOptimizer(final int defaultMaximalIterationCount,\n+                                              final double defaultAbsoluteAccuracy) {\n+        super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\n+        resultComputed = false;\n+        setMaxEvaluations(Integer.MAX_VALUE);\n+    }\n+\n+    /** Check if a result has been computed.\n+     * @exception IllegalStateException if no result has been computed\n+     */\n+    protected void checkResultComputed() throws IllegalStateException {\n+        if (!resultComputed) {\n+            throw MathRuntimeException.createIllegalStateException(\"no result available\");\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getResult() {\n+        checkResultComputed();\n+        return result;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getFunctionValue() {\n+        checkResultComputed();\n+        return functionValue;\n+    }\n+\n+    /**\n+     * Convenience function for implementations.\n+     * \n+     * @param x the result to set\n+     * @param fx the result to set\n+     * @param iterationCount the iteration count to set\n+     */\n+    protected final void setResult(final double x, final double fx,\n+                                   final int iterationCount) {\n+        this.result         = x;\n+        this.functionValue  = fx;\n+        this.iterationCount = iterationCount;\n+        this.resultComputed = true;\n+    }\n+\n+    /**\n+     * Convenience function for implementations.\n+     */\n+    protected final void clearResult() {\n+        this.resultComputed = false;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setMaxEvaluations(int maxEvaluations) {\n+        this.maxEvaluations = maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getMaxEvaluations() {\n+        return maxEvaluations;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getEvaluations() {\n+        return evaluations;\n+    }\n+\n+    /** \n+     * Compute the objective function value.\n+     * @param f objective function\n+     * @param point point at which the objective function must be evaluated\n+     * @return objective function value at specified point\n+     * @exception FunctionEvaluationException if the function cannot be evaluated\n+     * or the maximal number of iterations is exceeded\n+     */\n+    protected double computeObjectiveValue(final UnivariateRealFunction f,\n+                                           final double point)\n+        throws FunctionEvaluationException {\n+        if (++evaluations > maxEvaluations) {\n+            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n+                                                  point);\n+        }\n+        return f.value(point);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.optimization.univariate;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+\n+/**\n+ * Implements Richard Brent's algorithm (from his book \"Algorithms for\n+ * Minimization without Derivatives\", p. 79) for finding minima of real\n+ * univariate functions.\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class BrentOptimizer extends AbstractUnivariateRealOptimizer {\n+    \n+    /**\n+     * Golden section.\n+     */\n+    private static final double c = 0.5 * (3 - Math.sqrt(5));\n+\n+    /**\n+     * Construct a solver.\n+     */\n+    public BrentOptimizer() {\n+        super(100, 1E-10);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n+                           final double min, final double max, final double startValue)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return optimize(f, goalType, min, max);\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n+                           final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        clearResult();\n+        return localMin(f, goalType, min, max, relativeAccuracy, absoluteAccuracy);\n+    }\n+    \n+    /**\n+     * Find the minimum of the function {@code f} within the interval {@code (a, b)}.\n+     *\n+     * If the function {@code f} is defined on the interval {@code (a, b)}, then\n+     * this method finds an approximation {@code x} to the point at which {@code f}\n+     * attains its minimum.<br/>\n+     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t} and\n+     * {@code f} is never evaluated at two points closer together than {@code tol}.\n+     * {@code eps} should be no smaller than <em>2 macheps</em> and preferable not\n+     * much less than <em>sqrt(macheps)</em>, where <em>macheps</em> is the relative\n+     * machine precision. {@code t} should be positive.\n+     * @param f the function to solve\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param a Lower bound of the interval\n+     * @param b Higher bound of the interval\n+     * @param eps Relative accuracy\n+     * @param t Absolute accuracy\n+     * @return the point at which the function is minimal.\n+     * @throws MaxIterationsExceededException if the maximum iteration count\n+     * is exceeded.\n+     * @throws FunctionEvaluationException if an error occurs evaluating\n+     * the function. \n+     */\n+    private double localMin(final UnivariateRealFunction f, final GoalType goalType,\n+                            double a, double b, final double eps, final double t)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        double x = a + c * (b - a);\n+        double v = x;\n+        double w = x;\n+        double e = 0;\n+        double fx = computeObjectiveValue(f, x);\n+        if (goalType == GoalType.MAXIMIZE) {\n+            fx = -fx;\n+        }\n+        double fv = fx;\n+        double fw = fx;\n+\n+        int count = 0;\n+        while (count < maximalIterationCount) {\n+            double m = 0.5 * (a + b);\n+            double tol = eps * Math.abs(x) + t;\n+            double t2 = 2 * tol;\n+\n+            // Check stopping criterion.\n+            if (Math.abs(x - m) > t2 - 0.5 * (b - a)) {\n+                double p = 0;\n+                double q = 0;\n+                double r = 0;\n+                double d = 0;\n+                double u = 0;\n+\n+                if (Math.abs(e) > tol) { // Fit parabola.\n+                    r = (x - w) * (fx - fv);\n+                    q = (x - v) * (fx - fw);\n+                    p = (x - v) * q - (x - w) * r;\n+                    q = 2 * (q - r);\n+\n+                    if (q > 0) {\n+                        p = -p;\n+                    } else {\n+                        q = -q;\n+                    }\n+\n+                    r = e;\n+                    e = d;\n+                }\n+\n+                if (Math.abs(p) < Math.abs(0.5 * q * r) &&\n+                    (p < q * (a - x)) && (p < q * (b - x))) { // Parabolic interpolation step.\n+                    d = p / q;\n+                    u = x + d;\n+\n+                    // f must not be evaluated too close to a or b.\n+                    if (((u - a) < t2) || ((b - u) < t2)) {\n+                        d = (x < m) ? tol : -tol;\n+                    }\n+                } else { // Golden section step.\n+                    e = ((x < m) ? b : a) - x;\n+                    d = c * e;\n+                }\n+\n+                // f must not be evaluated too close to a or b.\n+                u = x + ((Math.abs(d) > tol) ? d : ((d > 0) ? tol : -tol));\n+                double fu = computeObjectiveValue(f, u);\n+                if (goalType == GoalType.MAXIMIZE) {\n+                    fu = -fu;\n+                }\n+\n+                // Update a, b, v, w and x.\n+                if (fu <= fx) {\n+                    if (u < x) {\n+                        b = x;\n+                    } else {\n+                        a = x;\n+                    }\n+                    v = w;\n+                    fv = fw;\n+                    w = x;\n+                    fw = fx;\n+                    x = u;\n+                    fx = fu;\n+                } else {\n+                    if (u < x) {\n+                        a = u;\n+                    } else {\n+                        b = u;\n+                    }\n+                    if ((fu <= fw) || (w == x)) {\n+                        v = w;\n+                        fv = fw;\n+                        w = u;\n+                        fw = fu;\n+                    } else if ((fu <= fv) || (v == x) || (v == w)) {\n+                        v = u;\n+                        fv = fu;\n+                    }\n+                }\n+            } else { // termination\n+                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n+                return x;\n+            }\n+\n+            ++count;\n+        }\n+\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Abstract class implementing the {@link  RandomGenerator} interface.\n+ * Default implementations for all methods other than {@link #nextDouble()} and\n+ * {@link #setSeed(long)} are provided. \n+ * <p>\n+ * All data generation methods are based on <code>nextDouble().</code>\n+ * Concrete implementations <strong>must</strong> override\n+ * this method and <strong>should</strong> provide better / more\n+ * performant implementations of the other methods if the underlying PRNG\n+ * supplies them.</p>\n+ *\n+ * @since 1.1\n+ * @version $Revision$ $Date$\n+ */\n+public abstract class AbstractRandomGenerator implements RandomGenerator {\n+    \n+    /** \n+     * Cached random normal value.  The default implementation for \n+     * {@link #nextGaussian} generates pairs of values and this field caches the\n+     * second value so that the full algorithm is not executed for every\n+     * activation.  The value <code>Double.NaN</code> signals that there is\n+     * no cached value.  Use {@link #clear} to clear the cached value.\n+     */\n+    private double cachedNormalDeviate = Double.NaN;\n+    \n+    /**\n+     * Construct a RandomGenerator.\n+     */\n+    public AbstractRandomGenerator() {\n+        super();\n+        \n+    }\n+    \n+    /**\n+     * Clears the cache used by the default implementation of \n+     * {@link #nextGaussian}. Implemementations that do not override the\n+     * default implementation of <code>nextGaussian</code> should call this\n+     * method in the implementation of {@link #setSeed(long)}\n+     */\n+    public void clear() {\n+        cachedNormalDeviate = Double.NaN;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSeed(int seed) {\n+        setSeed((long) seed);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSeed(int[] seed) {\n+        // the following number is the largest prime that fits in 32 bits (it is 2^32 - 5)\n+        final long prime = 4294967291l;\n+\n+        long combined = 0l;\n+        for (int s : seed) {\n+            combined = combined * prime + s;\n+        }\n+        setSeed(combined);\n+    }\n+\n+    /**\n+     * Sets the seed of the underyling random number generator using a \n+     * <code>long</code> seed.  Sequences of values generated starting with the\n+     * same seeds should be identical.\n+     * <p>\n+     * Implementations that do not override the default implementation of \n+     * <code>nextGaussian</code> should include a call to {@link #clear} in the\n+     * implementation of this method.</p>\n+     *\n+     * @param seed the seed value\n+     */\n+    public abstract void setSeed(long seed);  \n+\n+    /**\n+     * Generates random bytes and places them into a user-supplied \n+     * byte array.  The number of random bytes produced is equal to \n+     * the length of the byte array.\n+     * <p>\n+     * The default implementation fills the array with bytes extracted from\n+     * random integers generated using {@link #nextInt}.</p>\n+     * \n+     * @param bytes the non-null byte array in which to put the \n+     * random bytes\n+     */\n+    public void nextBytes(byte[] bytes) {\n+        int bytesOut = 0;\n+        while (bytesOut < bytes.length) {\n+          int randInt = nextInt();\n+          for (int i = 0; i < 3; i++) {\n+              if ( i > 0) {\n+                  randInt = randInt >> 8;\n+              }\n+              bytes[bytesOut++] = (byte) randInt;\n+              if (bytesOut == bytes.length) {\n+                  return;\n+              }\n+          }\n+        }\n+    }\n+\n+     /**\n+     * Returns the next pseudorandom, uniformly distributed <code>int</code>\n+     * value from this random number generator's sequence.  \n+     * All 2<font size=\"-1\"><sup>32</sup></font> possible <tt>int</tt> values\n+     * should be produced with  (approximately) equal probability. \n+     * <p>\n+     * The default implementation provided here returns \n+     * <pre>\n+     * <code>(int) (nextDouble() * Integer.MAX_VALUE)</code>\n+     * </pre></p>\n+     *\n+     * @return the next pseudorandom, uniformly distributed <code>int</code>\n+     *  value from this random number generator's sequence\n+     */\n+    public int nextInt() {\n+        return (int) (nextDouble() * Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Returns a pseudorandom, uniformly distributed <tt>int</tt> value\n+     * between 0 (inclusive) and the specified value (exclusive), drawn from\n+     * this random number generator's sequence. \n+     * <p>  \n+     * The default implementation returns \n+     * <pre>\n+     * <code>(int) (nextDouble() * n</code>\n+     * </pre></p>\n+     *\n+     * @param n the bound on the random number to be returned.  Must be\n+     * positive.\n+     * @return  a pseudorandom, uniformly distributed <tt>int</tt>\n+     * value between 0 (inclusive) and n (exclusive).\n+     * @throws IllegalArgumentException if n is not positive.\n+     */\n+    public int nextInt(int n) {\n+        if (n <= 0 ) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"upper bound must be positive ({0})\", n);\n+        }\n+        int result = (int) (nextDouble() * n);\n+        return result < n ? result : n - 1;\n+    }\n+\n+     /**\n+     * Returns the next pseudorandom, uniformly distributed <code>long</code>\n+     * value from this random number generator's sequence.  All \n+     * 2<font size=\"-1\"><sup>64</sup></font> possible <tt>long</tt> values \n+     * should be produced with (approximately) equal probability. \n+     * <p>  \n+     * The default implementation returns \n+     * <pre>\n+     * <code>(long) (nextDouble() * Long.MAX_VALUE)</code>\n+     * </pre></p>\n+     *\n+     * @return  the next pseudorandom, uniformly distributed <code>long</code>\n+     *value from this random number generator's sequence\n+     */\n+    public long nextLong() {\n+        return (long) (nextDouble() * Long.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Returns the next pseudorandom, uniformly distributed\n+     * <code>boolean</code> value from this random number generator's\n+     * sequence.  \n+     * <p>  \n+     * The default implementation returns \n+     * <pre>\n+     * <code>nextDouble() <= 0.5</code>\n+     * </pre></p>\n+     * \n+     * @return  the next pseudorandom, uniformly distributed\n+     * <code>boolean</code> value from this random number generator's\n+     * sequence\n+     */\n+    public boolean nextBoolean() {\n+        return nextDouble() <= 0.5;\n+    }\n+\n+     /**\n+     * Returns the next pseudorandom, uniformly distributed <code>float</code>\n+     * value between <code>0.0</code> and <code>1.0</code> from this random\n+     * number generator's sequence.  \n+     * <p>  \n+     * The default implementation returns \n+     * <pre>\n+     * <code>(float) nextDouble() </code>\n+     * </pre></p>\n+     *\n+     * @return  the next pseudorandom, uniformly distributed <code>float</code>\n+     * value between <code>0.0</code> and <code>1.0</code> from this\n+     * random number generator's sequence\n+     */\n+    public float nextFloat() {\n+        return (float) nextDouble();\n+    }\n+\n+    /**\n+     * Returns the next pseudorandom, uniformly distributed \n+     * <code>double</code> value between <code>0.0</code> and\n+     * <code>1.0</code> from this random number generator's sequence.  \n+     * <p>\n+     * This method provides the underlying source of random data used by the\n+     * other methods.</p>   \n+     *\n+     * @return  the next pseudorandom, uniformly distributed \n+     *  <code>double</code> value between <code>0.0</code> and\n+     *  <code>1.0</code> from this random number generator's sequence\n+     */  \n+    public abstract double nextDouble();  \n+\n+    /**\n+     * Returns the next pseudorandom, Gaussian (\"normally\") distributed\n+     * <code>double</code> value with mean <code>0.0</code> and standard\n+     * deviation <code>1.0</code> from this random number generator's sequence.\n+     * <p>\n+     * The default implementation uses the <em>Polar Method</em>\n+     * due to G.E.P. Box, M.E. Muller and G. Marsaglia, as described in \n+     * D. Knuth, <u>The Art of Computer Programming</u>, 3.4.1C.</p>\n+     * <p>\n+     * The algorithm generates a pair of independent random values.  One of\n+     * these is cached for reuse, so the full algorithm is not executed on each\n+     * activation.  Implementations that do not override this method should\n+     * make sure to call {@link #clear} to clear the cached value in the \n+     * implementation of {@link #setSeed(long)}.</p>\n+     * \n+     * @return  the next pseudorandom, Gaussian (\"normally\") distributed\n+     * <code>double</code> value with mean <code>0.0</code> and\n+     * standard deviation <code>1.0</code> from this random number\n+     *  generator's sequence\n+     */\n+    public double nextGaussian() {\n+        if (!Double.isNaN(cachedNormalDeviate)) {\n+            double dev = cachedNormalDeviate;\n+            cachedNormalDeviate = Double.NaN;\n+            return dev;\n+        }\n+        double v1 = 0;\n+        double v2 = 0;\n+        double s = 1;\n+        while (s >=1 ) { \n+            v1 = 2 * nextDouble() - 1; \n+            v2 = 2 * nextDouble() - 1; \n+            s = v1 * v1 + v2 * v2;\n+        }\n+        if (s != 0) {\n+            s = Math.sqrt(-2 * Math.log(s) / s);   \n+        }\n+        cachedNormalDeviate = v2 * s;\n+        return v1 * s;      \n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/random/BitsStreamGenerator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/** Base class for random number generators that generates bits streams.\n+\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+\n+ */\n+public abstract class BitsStreamGenerator implements RandomGenerator {\n+\n+    /** Next gaussian. */\n+    private double nextGaussian;\n+\n+    /** Creates a new random number generator.\n+     */\n+    public BitsStreamGenerator() {\n+        nextGaussian = Double.NaN;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public abstract void setSeed(int seed);\n+\n+    /** {@inheritDoc} */\n+    public abstract void setSeed(int[] seed);\n+\n+    /** {@inheritDoc} */\n+    public abstract void setSeed(long seed);\n+\n+    /** Generate next pseudorandom number.\n+     * <p>This method is the core generation algorithm. It is used by all the\n+     * public generation methods for the various primitive types {@link\n+     * #nextBoolean()}, {@link #nextBytes(byte[])}, {@link #nextDouble()},\n+     * {@link #nextFloat()}, {@link #nextGaussian()}, {@link #nextInt()},\n+     * {@link #next(int)} and {@link #nextLong()}.</p>\n+     * @param bits number of random bits to produce\n+     * @return random bits generated\n+     */\n+    protected abstract int next(int bits);\n+\n+    /** {@inheritDoc} */\n+    public boolean nextBoolean() {\n+        return next(1) != 0;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void nextBytes(byte[] bytes) {\n+        int i = 0;\n+        final int iEnd = bytes.length - 3;\n+        while (i < iEnd) {\n+            final int random = next(32);\n+            bytes[i]     = (byte) (random & 0xff);\n+            bytes[i + 1] = (byte) ((random >>  8) & 0xff);\n+            bytes[i + 2] = (byte) ((random >> 16) & 0xff);\n+            bytes[i + 3] = (byte) ((random >> 24) & 0xff);\n+            i += 4;\n+        }\n+        int random = next(32);\n+        while (i < bytes.length) {\n+            bytes[i++] = (byte) (random & 0xff); \n+            random     = random >> 8;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double nextDouble() {\n+        final long high = ((long) next(26)) << 26;\n+        final int  low  = next(26);\n+        return (high | low) * 0x1.0p-52d;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public float nextFloat() {\n+        return next(23) * 0x1.0p-23f;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double nextGaussian() {\n+\n+        final double random;\n+        if (Double.isNaN(nextGaussian)) {\n+            // generate a new pair of gaussian numbers\n+            final double x = nextDouble();\n+            final double y = nextDouble();\n+            final double alpha = 2 * Math.PI * x;\n+            final double r      = Math.sqrt(-2 * Math.log(y));\n+            random       = r * Math.cos(alpha);\n+            nextGaussian = r * Math.sin(alpha);\n+        } else {\n+            // use the second element of the pair already generated\n+            random = nextGaussian;\n+            nextGaussian = Double.NaN;\n+        }\n+\n+        return random;\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int nextInt() {\n+        return next(32);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int nextInt(int n) throws IllegalArgumentException {\n+\n+        if (n < 1) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"upper bound must be positive ({0})\", n);\n+        }\n+\n+        // find bit mask for n\n+        int mask = n;\n+        mask |= mask >> 1;\n+        mask |= mask >> 2;\n+        mask |= mask >> 4;\n+        mask |= mask >> 8;\n+        mask |= mask >> 16;\n+\n+        while (true) {\n+            final int random = next(32) & mask;\n+            if (random < n) {\n+                return random;\n+            }\n+        }\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public long nextLong() {\n+        final long high  = ((long) next(32)) << 32;\n+        final long  low  = ((long) next(32)) & 0xffffffffL;\n+        return high | low;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/random/CorrelatedRandomVectorGenerator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.random;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.NotPositiveDefiniteMatrixException;\n+import org.apache.commons.math.linear.RealMatrix;\n+\n+/** \n+ * A {@link RandomVectorGenerator} that generates vectors with with \n+ * correlated components.\n+ * <p>Random vectors with correlated components are built by combining\n+ * the uncorrelated components of another random vector in such a way that\n+ * the resulting correlations are the ones specified by a positive\n+ * definite covariance matrix.</p>\n+ * <p>The main use for correlated random vector generation is for Monte-Carlo\n+ * simulation of physical problems with several variables, for example to\n+ * generate error vectors to be added to a nominal vector. A particularly\n+ * interesting case is when the generated vector should be drawn from a <a\n+ * href=\"http://en.wikipedia.org/wiki/Multivariate_normal_distribution\">\n+ * Multivariate Normal Distribution</a>. The approach using a Cholesky\n+ * decomposition is quite usual in this case. However, it cas be extended\n+ * to other cases as long as the underlying random generator provides\n+ * {@link NormalizedRandomGenerator normalized values} like {@link\n+ * GaussianRandomGenerator} or {@link UniformRandomGenerator}.</p>\n+ * <p>Sometimes, the covariance matrix for a given simulation is not\n+ * strictly positive definite. This means that the correlations are\n+ * not all independent from each other. In this case, however, the non\n+ * strictly positive elements found during the Cholesky decomposition\n+ * of the covariance matrix should not be negative either, they\n+ * should be null. Another non-conventional extension handling this case\n+ * is used here. Rather than computing <code>C = U<sup>T</sup>.U</code>\n+ * where <code>C</code> is the covariance matrix and <code>U</code>\n+ * is an uppertriangular matrix, we compute <code>C = B.B<sup>T</sup></code>\n+ * where <code>B</code> is a rectangular matrix having\n+ * more rows than columns. The number of columns of <code>B</code> is\n+ * the rank of the covariance matrix, and it is the dimension of the\n+ * uncorrelated random vector that is needed to compute the component\n+ * of the correlated vector. This class handles this situation\n+ * automatically.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class CorrelatedRandomVectorGenerator\n+    implements RandomVectorGenerator {\n+\n+    /** Simple constructor.\n+     * <p>Build a correlated random vector generator from its mean\n+     * vector and covariance matrix.</p>\n+     * @param mean expected mean values for all components\n+     * @param covariance covariance matrix\n+     * @param small diagonal elements threshold under which  column are\n+     * considered to be dependent on previous ones and are discarded\n+     * @param generator underlying generator for uncorrelated normalized\n+     * components\n+     * @exception IllegalArgumentException if there is a dimension\n+     * mismatch between the mean vector and the covariance matrix\n+     * @exception NotPositiveDefiniteMatrixException if the\n+     * covariance matrix is not strictly positive definite\n+     * @exception DimensionMismatchException if the mean and covariance\n+     * arrays dimensions don't match\n+     */\n+    public CorrelatedRandomVectorGenerator(double[] mean,\n+                                           RealMatrix covariance, double small,\n+                                           NormalizedRandomGenerator generator)\n+    throws NotPositiveDefiniteMatrixException, DimensionMismatchException {\n+\n+        int order = covariance.getRowDimension();\n+        if (mean.length != order) {\n+            throw new DimensionMismatchException(mean.length, order);\n+        }\n+        this.mean = mean.clone();\n+\n+        decompose(covariance, small);\n+\n+        this.generator = generator;\n+        normalized = new double[rank];\n+\n+    }\n+\n+    /** Simple constructor.\n+     * <p>Build a null mean random correlated vector generator from its\n+     * covariance matrix.</p>\n+     * @param covariance covariance matrix\n+     * @param small diagonal elements threshold under which  column are\n+     * considered to be dependent on previous ones and are discarded\n+     * @param generator underlying generator for uncorrelated normalized\n+     * components\n+     * @exception NotPositiveDefiniteMatrixException if the\n+     * covariance matrix is not strictly positive definite\n+     */\n+    public CorrelatedRandomVectorGenerator(RealMatrix covariance, double small,\n+                                           NormalizedRandomGenerator generator)\n+    throws NotPositiveDefiniteMatrixException {\n+\n+        int order = covariance.getRowDimension();\n+        mean = new double[order];\n+        for (int i = 0; i < order; ++i) {\n+            mean[i] = 0;\n+        }\n+\n+        decompose(covariance, small);\n+\n+        this.generator = generator;\n+        normalized = new double[rank];\n+\n+    }\n+\n+    /** Get the underlying normalized components generator.\n+     * @return underlying uncorrelated components generator\n+     */\n+    public NormalizedRandomGenerator getGenerator() {\n+        return generator;\n+    }\n+\n+    /** Get the root of the covariance matrix.\n+     * The root is the rectangular matrix <code>B</code> such that\n+     * the covariance matrix is equal to <code>B.B<sup>T</sup></code>\n+     * @return root of the square matrix\n+     * @see #getRank()\n+     */\n+    public RealMatrix getRootMatrix() {\n+        return root;\n+    }\n+\n+    /** Get the rank of the covariance matrix.\n+     * The rank is the number of independent rows in the covariance\n+     * matrix, it is also the number of columns of the rectangular\n+     * matrix of the decomposition.\n+     * @return rank of the square matrix.\n+     * @see #getRootMatrix()\n+     */\n+    public int getRank() {\n+        return rank;\n+    }\n+\n+    /** Decompose the original square matrix.\n+     * <p>The decomposition is based on a Choleski decomposition\n+     * where additional transforms are performed:\n+     * <ul>\n+     *   <li>the rows of the decomposed matrix are permuted</li>\n+     *   <li>columns with the too small diagonal element are discarded</li>\n+     *   <li>the matrix is permuted</li>\n+     * </ul>\n+     * This means that rather than computing M = U<sup>T</sup>.U where U\n+     * is an upper triangular matrix, this method computed M=B.B<sup>T</sup>\n+     * where B is a rectangular matrix.\n+     * @param covariance covariance matrix\n+     * @param small diagonal elements threshold under which  column are\n+     * considered to be dependent on previous ones and are discarded\n+     * @exception NotPositiveDefiniteMatrixException if the\n+     * covariance matrix is not strictly positive definite\n+     */\n+    private void decompose(RealMatrix covariance, double small)\n+    throws NotPositiveDefiniteMatrixException {\n+\n+        int order = covariance.getRowDimension();\n+        double[][] c = covariance.getData();\n+        double[][] b = new double[order][order];\n+\n+        int[] swap  = new int[order];\n+        int[] index = new int[order];\n+        for (int i = 0; i < order; ++i) {\n+            index[i] = i;\n+        }\n+\n+        rank = 0;\n+        for (boolean loop = true; loop;) {\n+\n+            // find maximal diagonal element\n+            swap[rank] = rank;\n+            for (int i = rank + 1; i < order; ++i) {\n+                int ii  = index[i];\n+                int isi = index[swap[i]];\n+                if (c[ii][ii] > c[isi][isi]) {\n+                    swap[rank] = i;\n+                }\n+            }\n+\n+\n+            // swap elements\n+            if (swap[rank] != rank) {\n+                int tmp = index[rank];\n+                index[rank] = index[swap[rank]];\n+                index[swap[rank]] = tmp;\n+            }\n+\n+            // check diagonal element\n+            int ir = index[rank];\n+            if (c[ir][ir] < small) {\n+\n+                if (rank == 0) {\n+                    throw new NotPositiveDefiniteMatrixException();\n+                }\n+\n+                // check remaining diagonal elements\n+                for (int i = rank; i < order; ++i) {\n+                    if (c[index[i]][index[i]] < -small) {\n+                        // there is at least one sufficiently negative diagonal element,\n+                        // the covariance matrix is wrong\n+                        throw new NotPositiveDefiniteMatrixException();\n+                    }\n+                }\n+\n+                // all remaining diagonal elements are close to zero,\n+                // we consider we have found the rank of the covariance matrix\n+                ++rank;\n+                loop = false;\n+\n+            } else {\n+\n+                // transform the matrix\n+                double sqrt = Math.sqrt(c[ir][ir]);\n+                b[rank][rank] = sqrt;\n+                double inverse = 1 / sqrt;\n+                for (int i = rank + 1; i < order; ++i) {\n+                    int ii = index[i];\n+                    double e = inverse * c[ii][ir];\n+                    b[i][rank] = e;\n+                    c[ii][ii] -= e * e;\n+                    for (int j = rank + 1; j < i; ++j) {\n+                        int ij = index[j];\n+                        double f = c[ii][ij] - e * b[j][rank];\n+                        c[ii][ij] = f;\n+                        c[ij][ii] = f;\n+                    }\n+                }\n+\n+                // prepare next iteration\n+                loop = ++rank < order;\n+\n+            }\n+\n+        }\n+\n+        // build the root matrix\n+        root = MatrixUtils.createRealMatrix(order, rank);\n+        for (int i = 0; i < order; ++i) {\n+            for (int j = 0; j < rank; ++j) {\n+                root.setEntry(index[i], j, b[i][j]);\n+            }\n+        }\n+\n+    }\n+\n+    /** Generate a correlated random vector.\n+     * @return a random vector as an array of double. The returned array\n+     * is created at each call, the caller can do what it wants with it.\n+     */\n+    public double[] nextVector() {\n+\n+        // generate uncorrelated vector\n+        for (int i = 0; i < rank; ++i) {\n+            normalized[i] = generator.nextNormalizedDouble();\n+        }\n+\n+        // compute correlated vector\n+        double[] correlated = new double[mean.length];\n+        for (int i = 0; i < correlated.length; ++i) {\n+            correlated[i] = mean[i];\n+            for (int j = 0; j < rank; ++j) {\n+                correlated[i] += root.getEntry(i, j) * normalized[j];\n+            }\n+        }\n+\n+        return correlated;\n+\n+    }\n+\n+    /** Mean vector. */\n+    private double[] mean;\n+\n+    /** Permutated Cholesky root of the covariance matrix. */\n+    private RealMatrix root;\n+\n+    /** Rank of the covariance matrix. */\n+    private int rank;\n+\n+    /** Underlying generator. */\n+    private NormalizedRandomGenerator generator;\n+\n+    /** Storage for the normalized vector. */\n+    private double[] normalized;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/random/EmpiricalDistribution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.random;\n+\n+import java.io.IOException;\n+import java.io.File;\n+import java.net.URL;\n+import java.util.List;\n+\n+import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+\n+/**\n+ * Represents an <a href=\"http://random.mat.sbg.ac.at/~ste/dipl/node11.html\">\n+ * empirical probability distribution</a> -- a probability distribution derived\n+ * from observed data without making any assumptions about the functional form\n+ * of the population distribution that the data come from.<p>\n+ * Implementations of this interface maintain data structures, called\n+ * <i>distribution digests</i>, that describe empirical distributions and\n+ * support the following operations: <ul>\n+ * <li>loading the distribution from a file of observed data values</li>\n+ * <li>dividing the input data into \"bin ranges\" and reporting bin frequency\n+ *     counts (data for histogram)</li>\n+ * <li>reporting univariate statistics describing the full set of data values\n+ *     as well as the observations within each bin</li>\n+ * <li>generating random values from the distribution</li>\n+ * </ul>\n+ * Applications can use <code>EmpiricalDistribution</code> implementations to\n+ * build grouped frequency histograms representing the input data or to\n+ * generate random values \"like\" those in the input file -- i.e., the values\n+ * generated will follow the distribution of the values in the file.</p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public interface EmpiricalDistribution {\n+\n+    /**\n+     * Computes the empirical distribution from the provided\n+     * array of numbers.\n+     * \n+     * @param dataArray the data array\n+     */\n+    void load(double[] dataArray);\n+\n+    /**\n+     * Computes the empirical distribution from the input file.\n+     * \n+     * @param file the input file\n+     * @throws IOException if an IO error occurs\n+     */\n+    void load(File file) throws IOException;\n+\n+    /**\n+     * Computes the empirical distribution using data read from a URL.\n+     * \n+     * @param url url of the input file\n+     * @throws IOException if an IO error occurs\n+     */\n+    void load(URL url) throws IOException;\n+\n+    /**\n+     * Generates a random value from this distribution.\n+     * <strong>Preconditions:</strong><ul>\n+     * <li>the distribution must be loaded before invoking this method</li></ul>\n+     * @return the random value.\n+     * \n+     * @throws IllegalStateException if the distribution has not been loaded\n+     */\n+    double getNextValue() throws IllegalStateException;\n+\n+\n+    /**\n+     * Returns a \n+     * {@link org.apache.commons.math.stat.descriptive.StatisticalSummary} \n+     * describing this distribution.\n+     * <strong>Preconditions:</strong><ul>\n+     * <li>the distribution must be loaded before invoking this method</li>\n+     * </ul>\n+     * \n+     * @return the sample statistics\n+     * @throws IllegalStateException if the distribution has not been loaded\n+     */\n+    StatisticalSummary getSampleStats() throws IllegalStateException;\n+\n+    /**\n+     * Property indicating whether or not the distribution has been loaded.\n+     * \n+     * @return true if the distribution has been loaded\n+     */\n+    boolean isLoaded();\n+\n+     /**\n+     * Returns the number of bins.\n+     * \n+     * @return the number of bins\n+     */\n+    int getBinCount();\n+\n+    /**\n+     * Returns a list of \n+     * {@link org.apache.commons.math.stat.descriptive.SummaryStatistics}\n+     * containing statistics describing the values in each of the bins.  The\n+     * List is indexed on the bin number.\n+     * \n+     * @return List of bin statistics\n+     */\n+    List<SummaryStatistics> getBinStats();\n+\n+    /**\n+     * Returns the array of upper bounds for the bins.  Bins are: <br/>\n+     * [min,upperBounds[0]],(upperBounds[0],upperBounds[1]],...,\n+     *  (upperBounds[binCount-1],max].\n+     * \n+     * @return array of bin upper bounds\n+     */\n+    double[] getUpperBounds();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.random;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.Serializable;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+\n+/**\n+ * Implements <code>EmpiricalDistribution</code> interface.  This implementation\n+ * uses what amounts to the\n+ * <a href=\"http://nedwww.ipac.caltech.edu/level5/March02/Silverman/Silver2_6.html\">\n+ * Variable Kernel Method</a> with Gaussian smoothing:<p>\n+ * <strong>Digesting the input file</strong>\n+ * <ol><li>Pass the file once to compute min and max.</li>\n+ * <li>Divide the range from min-max into <code>binCount</code> \"bins.\"</li>\n+ * <li>Pass the data file again, computing bin counts and univariate\n+ *     statistics (mean, std dev.) for each of the bins </li>\n+ * <li>Divide the interval (0,1) into subintervals associated with the bins,\n+ *     with the length of a bin's subinterval proportional to its count.</li></ol>\n+ * <strong>Generating random values from the distribution</strong><ol>\n+ * <li>Generate a uniformly distributed value in (0,1) </li>\n+ * <li>Select the subinterval to which the value belongs.\n+ * <li>Generate a random Gaussian value with mean = mean of the associated\n+ *     bin and std dev = std dev of associated bin.</li></ol></p><p>\n+ *<strong>USAGE NOTES:</strong><ul>\n+ *<li>The <code>binCount</code> is set by default to 1000.  A good rule of thumb\n+ *    is to set the bin count to approximately the length of the input file divided\n+ *    by 10. </li>\n+ *<li>The input file <i>must</i> be a plain text file containing one valid numeric\n+ *    entry per line.</li>\n+ * </ul></p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class EmpiricalDistributionImpl implements Serializable, EmpiricalDistribution {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 5729073523949762654L;\n+\n+    /** List of SummaryStatistics objects characterizing the bins */\n+    private List<SummaryStatistics> binStats = null;\n+\n+    /** Sample statistics */\n+    private SummaryStatistics sampleStats = null;\n+\n+    /** number of bins */\n+    private int binCount = 1000;\n+\n+    /** is the distribution loaded? */\n+    private boolean loaded = false;\n+\n+    /** upper bounds of subintervals in (0,1) \"belonging\" to the bins */\n+    private double[] upperBounds = null;\n+\n+    /** RandomData instance to use in repeated calls to getNext() */\n+    private RandomData randomData = new RandomDataImpl();\n+\n+    /**\n+     * Creates a new EmpiricalDistribution with the default bin count.\n+     */\n+    public EmpiricalDistributionImpl() {\n+        binStats = new ArrayList<SummaryStatistics>();\n+    }\n+\n+    /**\n+     * Creates a new EmpiricalDistribution  with the specified bin count.\n+     * \n+     * @param binCount number of bins\n+     */\n+    public EmpiricalDistributionImpl(int binCount) {\n+        this.binCount = binCount;\n+        binStats = new ArrayList<SummaryStatistics>();\n+    }\n+\n+     /**\n+     * Computes the empirical distribution from the provided\n+     * array of numbers.\n+     * \n+     * @param in the input data array\n+     */\n+    public void load(double[] in) {\n+        DataAdapter da = new ArrayDataAdapter(in);\n+        try {\n+            da.computeStats();\n+            fillBinStats(in);\n+        } catch (Exception e) {\n+            throw new MathRuntimeException(e);\n+        }\n+        loaded = true;\n+\n+    }\n+\n+    /**\n+     * Computes the empirical distribution using data read from a URL.\n+     * @param url  url of the input file\n+     * \n+     * @throws IOException if an IO error occurs\n+     */\n+    public void load(URL url) throws IOException {\n+        BufferedReader in =\n+            new BufferedReader(new InputStreamReader(url.openStream()));\n+        try {\n+            DataAdapter da = new StreamDataAdapter(in);\n+            try {\n+                da.computeStats();\n+            } catch (IOException ioe) {\n+                // don't wrap exceptions which are already IOException\n+                throw ioe;\n+            } catch (RuntimeException rte) {\n+                // don't wrap RuntimeExceptions\n+                throw rte;\n+            } catch (Exception e) {\n+                throw MathRuntimeException.createIOException(e);\n+            }\n+            if (sampleStats.getN() == 0) {\n+                throw MathRuntimeException.createEOFException(\"URL {0} contains no data\",\n+                                                              url);\n+            }\n+            in = new BufferedReader(new InputStreamReader(url.openStream()));\n+            fillBinStats(in);\n+            loaded = true;\n+        } finally {\n+           try {\n+               in.close();\n+           } catch (IOException ex) {\n+               // ignore\n+           }\n+        }\n+    }\n+\n+    /**\n+     * Computes the empirical distribution from the input file.\n+     * \n+     * @param file the input file\n+     * @throws IOException if an IO error occurs\n+     */\n+    public void load(File file) throws IOException {\n+        BufferedReader in = new BufferedReader(new FileReader(file));\n+        try {\n+            DataAdapter da = new StreamDataAdapter(in);\n+            try {\n+                da.computeStats();\n+            } catch (IOException ioe) {\n+                // don't wrap exceptions which are already IOException\n+                throw ioe;\n+            } catch (RuntimeException rte) {\n+                // don't wrap RuntimeExceptions\n+                throw rte;\n+            } catch (Exception e) {\n+                throw MathRuntimeException.createIOException(e);\n+            }\n+            in = new BufferedReader(new FileReader(file));\n+            fillBinStats(in);\n+            loaded = true;\n+        } finally {\n+            try {\n+                in.close();\n+            } catch (IOException ex) {\n+                // ignore\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Provides methods for computing <code>sampleStats</code> and\n+     * <code>beanStats</code> abstracting the source of data.\n+     */\n+    private abstract class DataAdapter{\n+        /** \n+         * Compute bin stats.\n+         * \n+         * @param min minimum value\n+         * @param delta  grid size\n+         * @throws Exception  if an error occurs computing bin stats\n+         */\n+        public abstract void computeBinStats(double min, double delta)\n+                throws Exception;\n+        /**\n+         * Compute sample statistics.\n+         * \n+         * @throws Exception if an error occurs computing sample stats\n+         */\n+        public abstract void computeStats() throws Exception;\n+    }\n+    /**\n+     * Factory of <code>DataAdapter</code> objects. For every supported source\n+     * of data (array of doubles, file, etc.) an instance of the proper object\n+     * is returned.\n+     */\n+    private class DataAdapterFactory{\n+        /**\n+         * Creates a DataAdapter from a data object\n+         * \n+         * @param in object providing access to the data\n+         * @return DataAdapter instance\n+         */\n+        public DataAdapter getAdapter(Object in) {\n+            if (in instanceof BufferedReader) {\n+                BufferedReader inputStream = (BufferedReader) in;\n+                return new StreamDataAdapter(inputStream);\n+            } else if (in instanceof double[]) {\n+                double[] inputArray = (double[]) in;\n+                return new ArrayDataAdapter(inputArray);\n+            } else {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"input data comes from unsupported datasource: {0}, \" +\n+                      \"supported sources: {1}, {2}\",\n+                      in.getClass().getName(),\n+                      BufferedReader.class.getName(), double[].class.getName());\n+            }\n+        }\n+    }\n+    /**\n+     * <code>DataAdapter</code> for data provided through some input stream\n+     */\n+    private class StreamDataAdapter extends DataAdapter{\n+        \n+        /** Input stream providng access to the data */\n+        private BufferedReader inputStream;\n+        \n+        /**\n+         * Create a StreamDataAdapter from a BufferedReader\n+         * \n+         * @param in BufferedReader input stream\n+         */\n+        public StreamDataAdapter(BufferedReader in){\n+            super();\n+            inputStream = in;\n+        }\n+        /**\n+         * Computes binStats\n+         * \n+         * @param min  minimum value\n+         * @param delta  grid size\n+         * @throws IOException if an IO error occurs\n+         */\n+        @Override\n+        public void computeBinStats(double min, double delta)\n+                throws IOException {\n+            String str = null;\n+            double val = 0.0d;\n+            while ((str = inputStream.readLine()) != null) {\n+                val = Double.parseDouble(str);\n+                SummaryStatistics stats = binStats.get(findBin(min, val, delta));\n+                stats.addValue(val);\n+            }\n+\n+            inputStream.close();\n+            inputStream = null;\n+        }\n+        /**\n+         * Computes sampleStats\n+         * \n+         * @throws IOException if an IOError occurs\n+         */\n+        @Override\n+        public void computeStats() throws IOException {\n+            String str = null;\n+            double val = 0.0;\n+            sampleStats = new SummaryStatistics();\n+            while ((str = inputStream.readLine()) != null) {\n+                val = Double.valueOf(str).doubleValue();\n+                sampleStats.addValue(val);\n+            }\n+            inputStream.close();\n+            inputStream = null;\n+        }\n+    }\n+\n+    /**\n+     * <code>DataAdapter</code> for data provided as array of doubles.\n+     */\n+    private class ArrayDataAdapter extends DataAdapter{\n+        \n+        /** Array of input  data values */\n+        private double[] inputArray;\n+        \n+        /**\n+         * Construct an ArrayDataAdapter from a double[] array\n+         * \n+         * @param in double[] array holding the data\n+         */\n+        public ArrayDataAdapter(double[] in){\n+            super();\n+            inputArray = in;\n+        }\n+        /**\n+         * Computes sampleStats\n+         * \n+         * @throws IOException if an IO error occurs\n+         */\n+        @Override\n+        public void computeStats() throws IOException {\n+            sampleStats = new SummaryStatistics();\n+            for (int i = 0; i < inputArray.length; i++) {\n+                sampleStats.addValue(inputArray[i]);\n+            }\n+        }\n+        /**\n+         * Computes binStats\n+         * \n+         * @param min  minimum value\n+         * @param delta  grid size\n+         * @throws IOException  if an IO error occurs\n+         */\n+        @Override\n+        public void computeBinStats(double min, double delta)\n+            throws IOException {\n+            for (int i = 0; i < inputArray.length; i++) {\n+                SummaryStatistics stats =\n+                    binStats.get(findBin(min, inputArray[i], delta));\n+                stats.addValue(inputArray[i]);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Fills binStats array (second pass through data file).\n+     * \n+     * @param in object providing access to the data\n+     * @throws IOException  if an IO error occurs\n+     */\n+    private void fillBinStats(Object in) throws IOException {\n+        // Load array of bin upper bounds -- evenly spaced from min - max\n+        double min = sampleStats.getMin();\n+        double max = sampleStats.getMax();\n+        double delta = (max - min)/(Double.valueOf(binCount)).doubleValue();\n+        double[] binUpperBounds = new double[binCount];\n+        binUpperBounds[0] = min + delta;\n+        for (int i = 1; i< binCount - 1; i++) {\n+            binUpperBounds[i] = binUpperBounds[i-1] + delta;\n+        }\n+        binUpperBounds[binCount -1] = max;\n+\n+        // Initialize binStats ArrayList\n+        if (!binStats.isEmpty()) {\n+            binStats.clear();\n+        }\n+        for (int i = 0; i < binCount; i++) {\n+            SummaryStatistics stats = new SummaryStatistics();\n+            binStats.add(i,stats);\n+        }\n+\n+        // Filling data in binStats Array\n+        DataAdapterFactory aFactory = new DataAdapterFactory();\n+        DataAdapter da = aFactory.getAdapter(in);\n+        try {\n+            da.computeBinStats(min, delta);\n+        } catch (IOException ioe) {\n+            // don't wrap exceptions which are already IOException\n+            throw ioe;\n+        } catch (RuntimeException rte) {\n+            // don't wrap RuntimeExceptions\n+            throw rte;\n+        } catch (Exception e) {\n+            throw MathRuntimeException.createIOException(e);\n+        }\n+\n+        // Assign upperBounds based on bin counts\n+        upperBounds = new double[binCount];\n+        upperBounds[0] =\n+        ((double) binStats.get(0).getN()) / (double) sampleStats.getN();\n+        for (int i = 1; i < binCount-1; i++) {\n+            upperBounds[i] = upperBounds[i-1] +\n+            ((double) binStats.get(i).getN()) / (double) sampleStats.getN();\n+        }\n+        upperBounds[binCount-1] = 1.0d;\n+    }\n+    \n+    /**\n+     * Returns the index of the bin to which the given value belongs\n+     * \n+     * @param min  the minimum value\n+     * @param value  the value whose bin we are trying to find\n+     * @param delta  the grid size\n+     * @return the index of the bin containing the value\n+     */\n+    private int findBin(double min, double value, double delta) {\n+        return Math.min(\n+                Math.max((int) Math.ceil((value- min) / delta) - 1, 0), \n+                binCount - 1);\n+        }\n+\n+    /**\n+     * Generates a random value from this distribution.\n+     * \n+     * @return the random value.\n+     * @throws IllegalStateException if the distribution has not been loaded\n+     */\n+    public double getNextValue() throws IllegalStateException {\n+\n+        if (!loaded) {\n+            throw MathRuntimeException.createIllegalStateException(\"distribution not loaded\");\n+        }\n+\n+        // Start with a uniformly distributed random number in (0,1)\n+        double x = Math.random();\n+\n+        // Use this to select the bin and generate a Gaussian within the bin\n+        for (int i = 0; i < binCount; i++) {\n+           if (x <= upperBounds[i]) {\n+               SummaryStatistics stats = binStats.get(i);\n+               if (stats.getN() > 0) {\n+                   if (stats.getStandardDeviation() > 0) {  // more than one obs\n+                        return randomData.nextGaussian\n+                            (stats.getMean(),stats.getStandardDeviation());\n+                   } else {\n+                       return stats.getMean(); // only one obs in bin\n+                   }\n+               }\n+           }\n+        }\n+        throw new MathRuntimeException(\"no bin selected\");\n+    }\n+\n+    /**\n+     * Returns a {@link StatisticalSummary} describing this distribution.\n+     * <strong>Preconditions:</strong><ul>\n+     * <li>the distribution must be loaded before invoking this method</li></ul>\n+     * \n+     * @return the sample statistics\n+     * @throws IllegalStateException if the distribution has not been loaded\n+     */\n+    public StatisticalSummary getSampleStats() {\n+        return sampleStats;\n+    }\n+\n+    /**\n+     * Returns the number of bins.\n+     * \n+     * @return the number of bins.\n+     */\n+    public int getBinCount() {\n+        return binCount;\n+    }\n+\n+    /**\n+     * Returns a List of {@link SummaryStatistics} instances containing\n+     * statistics describing the values in each of the bins.  The list is\n+     * indexed on the bin number.\n+     * \n+     * @return List of bin statistics.\n+     */\n+    public List<SummaryStatistics> getBinStats() {\n+        return binStats;\n+    }\n+\n+    /**\n+     * Returns (a fresh copy of) the array of upper bounds for the bins.\n+       Bins are: <br/>\n+     * [min,upperBounds[0]],(upperBounds[0],upperBounds[1]],...,\n+     *  (upperBounds[binCount-1],max]\n+     * \n+     * @return array of bin upper bounds\n+     */\n+    public double[] getUpperBounds() {\n+        int len = upperBounds.length;\n+        double[] out = new double[len];\n+        System.arraycopy(upperBounds, 0, out, 0, len);\n+        return out;\n+    }\n+\n+    /**\n+     * Property indicating whether or not the distribution has been loaded.\n+     * \n+     * @return true if the distribution has been loaded\n+     */\n+    public boolean isLoaded() {\n+        return loaded;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/random/GaussianRandomGenerator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.random;\n+\n+/** \n+ * This class is a gaussian normalized random generator for scalars.\n+ * <p>This class is a simple wrapper around the {@link\n+ * RandomGenerator#nextGaussian} method.</p>\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class GaussianRandomGenerator implements NormalizedRandomGenerator {\n+\n+    /** Create a new generator.\n+     * @param generator underlying random generator to use\n+     */\n+    public GaussianRandomGenerator(RandomGenerator generator) {\n+        this.generator = generator;\n+    }\n+\n+    /** Generate a random scalar with null mean and unit standard deviation.\n+     * @return a random scalar with null mean and unit standard deviation\n+     */\n+    public double nextNormalizedDouble() {\n+        return generator.nextGaussian();\n+    }\n+\n+    /** Underlying generator. */\n+    private RandomGenerator generator;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/random/JDKRandomGenerator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+\n+import java.util.Random;\n+\n+/**\n+ * Extension of <code>java.util.Random</code> to implement \n+ * {@link RandomGenerator}.\n+ *\n+ * @since 1.1\n+ * @version $Revision$ $Date$\n+ */\n+public class JDKRandomGenerator extends Random implements RandomGenerator {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -7745277476784028798L;\n+\n+    /** {@inheritDoc} */\n+    public void setSeed(int seed) {\n+        setSeed((long) seed);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSeed(int[] seed) {\n+        // the following number is the largest prime that fits in 32 bits (it is 2^32 - 5)\n+        final long prime = 4294967291l;\n+\n+        long combined = 0l;\n+        for (int s : seed) {\n+            combined = combined * prime + s;\n+        }\n+        setSeed(combined);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/random/MersenneTwister.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+\n+import java.io.Serializable;\n+\n+\n+/** This class implements a powerful pseudo-random number generator\n+ * developed by Makoto Matsumoto and Takuji Nishimura during\n+ * 1996-1997.\n+\n+ * <p>This generator features an extremely long period\n+ * (2<sup>19937</sup>-1) and 623-dimensional equidistribution up to 32\n+ * bits accuracy. The home page for this generator is located at <a\n+ * href=\"http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html\">\n+ * http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html</a>.</p>\n+\n+ * <p>This generator is described in a paper by Makoto Matsumoto and\n+ * Takuji Nishimura in 1998: <a\n+ * href=\"http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/ARTICLES/mt.pdf\">Mersenne\n+ * Twister: A 623-Dimensionally Equidistributed Uniform Pseudo-Random\n+ * Number Generator</a>, ACM Transactions on Modeling and Computer\n+ * Simulation, Vol. 8, No. 1, January 1998, pp 3--30</p>\n+\n+ * <p>This class is mainly a Java port of the 2002-01-26 version of\n+ * the generator written in C by Makoto Matsumoto and Takuji\n+ * Nishimura. Here is their original copyright:</p>\n+\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\n+ *     All rights reserved.</td></tr>\n+\n+ * <tr><td>Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * <ol>\n+ *   <li>Redistributions of source code must retain the above copyright\n+ *       notice, this list of conditions and the following disclaimer.</li>\n+ *   <li>Redistributions in binary form must reproduce the above copyright\n+ *       notice, this list of conditions and the following disclaimer in the\n+ *       documentation and/or other materials provided with the distribution.</li>\n+ *   <li>The names of its contributors may not be used to endorse or promote \n+ *       products derived from this software without specific prior written \n+ *       permission.</li>\n+ * </ol></td></tr>\n+\n+ * <tr><td><strong>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND\n+ * CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES,\n+ * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,\n+ * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n+ * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE\n+ * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.</strong></td></tr>\n+ * </table>\n+\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+\n+ */\n+public class MersenneTwister extends BitsStreamGenerator implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 8661194735290153518L;\n+\n+    /** Size of the bytes pool. */\n+    private static final int   N     = 624;\n+\n+    /** Period second parameter. */\n+    private static final int   M     = 397;\n+\n+    /** X * MATRIX_A for X = {0, 1}. */\n+    private static final int[] MAG01 = { 0x0, 0x9908b0df };\n+\n+    /** Bytes pool. */\n+    private int[] mt;\n+\n+    /** Current index in the bytes pool. */\n+    private int   mti;\n+\n+    /** Creates a new random number generator.\n+     * <p>The instance is initialized using the current time as the\n+     * seed.</p>\n+     */\n+    public MersenneTwister() {\n+        mt = new int[N];\n+        setSeed(System.currentTimeMillis());\n+    }\n+\n+    /** Creates a new random number generator using a single int seed.\n+     * @param seed the initial seed (32 bits integer)\n+     */\n+    public MersenneTwister(int seed) {\n+        mt = new int[N];\n+        setSeed(seed);\n+    }\n+\n+    /** Creates a new random number generator using an int array seed.\n+     * @param seed the initial seed (32 bits integers array), if null\n+     * the seed of the generator will be related to the current time\n+     */\n+    public MersenneTwister(int[] seed) {\n+        mt = new int[N];\n+        setSeed(seed);\n+    }\n+\n+    /** Creates a new random number generator using a single long seed.\n+     * @param seed the initial seed (64 bits integer)\n+     */\n+    public MersenneTwister(long seed) {\n+        mt = new int[N];\n+        setSeed(seed);\n+    }\n+\n+    /** Reinitialize the generator as if just built with the given int seed.\n+     * <p>The state of the generator is exactly the same as a new\n+     * generator built with the same seed.</p>\n+     * @param seed the initial seed (32 bits integer)\n+     */\n+    public void setSeed(int seed) {\n+        // we use a long masked by 0xffffffffL as a poor man unsigned int\n+        long longMT = seed;\n+        mt[0]= (int) longMT;\n+        for (mti = 1; mti < N; ++mti) {\n+            // See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier.\n+            // initializer from the 2002-01-09 C version by Makoto Matsumoto\n+            longMT = (1812433253l * (longMT ^ (longMT >> 30)) + mti) & 0xffffffffL; \n+            mt[mti]= (int) longMT;\n+        }\n+    }\n+\n+    /** Reinitialize the generator as if just built with the given int array seed.\n+     * <p>The state of the generator is exactly the same as a new\n+     * generator built with the same seed.</p>\n+     * @param seed the initial seed (32 bits integers array), if null\n+     * the seed of the generator will be related to the current time\n+     */\n+    public void setSeed(int[] seed) {\n+\n+        if (seed == null) {\n+            setSeed(System.currentTimeMillis());\n+            return;\n+        }\n+\n+        setSeed(19650218);\n+        int i = 1;\n+        int j = 0;\n+\n+        for (int k = Math.max(N, seed.length); k != 0; k--) {\n+            long l0 = (mt[i] & 0x7fffffffl)   | ((mt[i]   < 0) ? 0x80000000l : 0x0l);\n+            long l1 = (mt[i-1] & 0x7fffffffl) | ((mt[i-1] < 0) ? 0x80000000l : 0x0l);\n+            long l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1664525l)) + seed[j] + j; // non linear\n+            mt[i]   = (int) (l & 0xffffffffl);\n+            i++; j++;\n+            if (i >= N) {\n+                mt[0] = mt[N - 1];\n+                i = 1;\n+            }\n+            if (j >= seed.length) {\n+                j = 0;\n+            }\n+        }\n+\n+        for (int k = N - 1; k != 0; k--) {\n+            long l0 = (mt[i] & 0x7fffffffl)   | ((mt[i]   < 0) ? 0x80000000l : 0x0l);\n+            long l1 = (mt[i-1] & 0x7fffffffl) | ((mt[i-1] < 0) ? 0x80000000l : 0x0l);\n+            long l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1566083941l)) - i; // non linear\n+            mt[i]   = (int) (l & 0xffffffffL);\n+            i++;\n+            if (i >= N) {\n+                mt[0] = mt[N - 1];\n+                i = 1;\n+            }\n+        }\n+\n+        mt[0] = 0x80000000; // MSB is 1; assuring non-zero initial array\n+\n+    }\n+\n+    /** Reinitialize the generator as if just built with the given long seed.\n+     * <p>The state of the generator is exactly the same as a new\n+     * generator built with the same seed.</p>\n+     * @param seed the initial seed (64 bits integer)\n+     */\n+    public void setSeed(long seed) {\n+        setSeed(new int[] { (int) (seed >>> 32), (int) (seed & 0xffffffffl) });\n+    }\n+\n+    /** Generate next pseudorandom number.\n+     * <p>This method is the core generation algorithm. It is used by all the\n+     * public generation methods for the various primitive types {@link\n+     * #nextBoolean()}, {@link #nextBytes(byte[])}, {@link #nextDouble()},\n+     * {@link #nextFloat()}, {@link #nextGaussian()}, {@link #nextInt()},\n+     * {@link #next(int)} and {@link #nextLong()}.</p>\n+     * @param bits number of random bits to produce\n+     * @return random bits generated\n+     */\n+    protected int next(int bits) {\n+\n+        int y;\n+\n+        if (mti >= N) { // generate N words at one time\n+            int mtNext = mt[0];\n+            for (int k = 0; k < N - M; ++k) {\n+                int mtCurr = mtNext;\n+                mtNext = mt[k + 1];\n+                y = (mtCurr & 0x80000000) | (mtNext & 0x7fffffff);\n+                mt[k] = mt[k + M] ^ (y >>> 1) ^ MAG01[y & 0x1];\n+            }\n+            for (int k = N - M; k < N - 1; ++k) {\n+                int mtCurr = mtNext;\n+                mtNext = mt[k + 1];\n+                y = (mtCurr & 0x80000000) | (mtNext & 0x7fffffff);\n+                mt[k] = mt[k + (M - N)] ^ (y >>> 1) ^ MAG01[y & 0x1];\n+            }\n+            y = (mtNext & 0x80000000) | (mt[0] & 0x7fffffff);\n+            mt[N - 1] = mt[M - 1] ^ (y >>> 1) ^ MAG01[y & 0x1];\n+\n+            mti = 0;\n+        }\n+\n+        y = mt[mti++];\n+\n+        // tempering\n+        y ^= (y >>> 11);\n+        y ^= (y <<   7) & 0x9d2c5680;\n+        y ^= (y <<  15) & 0xefc60000;\n+        y ^= (y >>> 18);\n+\n+        return y >>> (32 - bits);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/random/NormalizedRandomGenerator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.random;\n+\n+/** \n+ * This interface represent a normalized random generator for\n+ * scalars.\n+ * Normalized generator provide null mean and unit standard deviation scalars.\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public interface NormalizedRandomGenerator {\n+\n+  /** Generate a random scalar with null mean and unit standard deviation.\n+   * <p>This method does <strong>not</strong> specify the shape of the\n+   * distribution, it is the implementing class that provides it. The\n+   * only contract here is to generate numbers with null mean and unit\n+   * standard deviation.</p>\n+   * @return a random scalar with null mean and unit standard deviation\n+   */\n+  public double nextNormalizedDouble();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/random/RandomAdaptor.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+\n+import java.util.Random;\n+\n+/**\n+ * Extension of <code>java.util.Random</code> wrapping a\n+ * {@link RandomGenerator}.   \n+ *\n+ * @since 1.1\n+ * @version $Revision$ $Date$\n+ */\n+public class RandomAdaptor extends Random implements RandomGenerator {\n+    \n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 2306581345647615033L;\n+\n+    /** Wrapped randomGenerator instance */\n+    private RandomGenerator randomGenerator = null;\n+\n+    /** \n+     * Prevent instantiation without a generator argument\n+     */ \n+    @SuppressWarnings(\"unused\")\n+    private RandomAdaptor() { }\n+    \n+    /**\n+     * Construct a RandomAdaptor wrapping the supplied RandomGenerator.\n+     * \n+     * @param randomGenerator  the wrapped generator\n+     */\n+    public RandomAdaptor(RandomGenerator randomGenerator) {\n+        this.randomGenerator = randomGenerator;\n+    } \n+    \n+    /**\n+     * Factory method to create a <code>Random</code> using the supplied\n+     * <code>RandomGenerator</code>.\n+     * \n+     * @param randomGenerator  wrapped RandomGenerator instance\n+     * @return a Random instance wrapping the RandomGenerator\n+     */\n+    public static Random createAdaptor(RandomGenerator randomGenerator) {\n+        return new RandomAdaptor(randomGenerator);\n+    }\n+    \n+    /**\n+     * Returns the next pseudorandom, uniformly distributed\n+     * <code>boolean</code> value from this random number generator's\n+     * sequence.  \n+     * \n+     * @return  the next pseudorandom, uniformly distributed\n+     * <code>boolean</code> value from this random number generator's\n+     * sequence\n+     */\n+    @Override\n+    public boolean nextBoolean() {\n+        return randomGenerator.nextBoolean();\n+    }\n+\n+     /**\n+     * Generates random bytes and places them into a user-supplied \n+     * byte array.  The number of random bytes produced is equal to \n+     * the length of the byte array.\n+     * \n+     * @param bytes the non-null byte array in which to put the \n+     * random bytes\n+     */\n+    @Override\n+    public void nextBytes(byte[] bytes) {\n+        randomGenerator.nextBytes(bytes);\n+    }\n+\n+     /**\n+     * Returns the next pseudorandom, uniformly distributed \n+     * <code>double</code> value between <code>0.0</code> and\n+     * <code>1.0</code> from this random number generator's sequence.  \n+     *\n+     * @return  the next pseudorandom, uniformly distributed \n+     *  <code>double</code> value between <code>0.0</code> and\n+     *  <code>1.0</code> from this random number generator's sequence\n+     */  \n+    @Override\n+    public double nextDouble() {\n+        return randomGenerator.nextDouble();\n+    }\n+\n+    /**\n+     * Returns the next pseudorandom, uniformly distributed <code>float</code>\n+     * value between <code>0.0</code> and <code>1.0</code> from this random\n+     * number generator's sequence.  \n+     *\n+     * @return  the next pseudorandom, uniformly distributed <code>float</code>\n+     * value between <code>0.0</code> and <code>1.0</code> from this\n+     * random number generator's sequence\n+     */\n+    @Override\n+    public float nextFloat() {\n+        return randomGenerator.nextFloat();\n+    }\n+\n+    /**\n+     * Returns the next pseudorandom, Gaussian (\"normally\") distributed\n+     * <code>double</code> value with mean <code>0.0</code> and standard\n+     * deviation <code>1.0</code> from this random number generator's sequence.\n+     * \n+     * @return  the next pseudorandom, Gaussian (\"normally\") distributed\n+     * <code>double</code> value with mean <code>0.0</code> and\n+     * standard deviation <code>1.0</code> from this random number\n+     *  generator's sequence\n+     */\n+    @Override\n+    public double nextGaussian() {\n+        return randomGenerator.nextGaussian();\n+    }\n+\n+     /**\n+     * Returns the next pseudorandom, uniformly distributed <code>int</code>\n+     * value from this random number generator's sequence.  \n+     * All 2<font size=\"-1\"><sup>32</sup></font> possible <tt>int</tt> values\n+     * should be produced with  (approximately) equal probability. \n+     *\n+     * @return the next pseudorandom, uniformly distributed <code>int</code>\n+     *  value from this random number generator's sequence\n+     */\n+    @Override\n+    public int nextInt() {\n+        return randomGenerator.nextInt();\n+    }\n+\n+    /**\n+     * Returns a pseudorandom, uniformly distributed <tt>int</tt> value\n+     * between 0 (inclusive) and the specified value (exclusive), drawn from\n+     * this random number generator's sequence.   \n+     *\n+     * @param n the bound on the random number to be returned.  Must be\n+     * positive.\n+     * @return  a pseudorandom, uniformly distributed <tt>int</tt>\n+     * value between 0 (inclusive) and n (exclusive).\n+     * @throws IllegalArgumentException  if n is not positive.\n+     */\n+    @Override\n+    public int nextInt(int n) {\n+        return randomGenerator.nextInt(n);\n+    }\n+\n+    /**\n+     * Returns the next pseudorandom, uniformly distributed <code>long</code>\n+     * value from this random number generator's sequence.  All \n+     * 2<font size=\"-1\"><sup>64</sup></font> possible <tt>long</tt> values \n+     * should be produced with (approximately) equal probability. \n+     *\n+     * @return  the next pseudorandom, uniformly distributed <code>long</code>\n+     *value from this random number generator's sequence\n+     */\n+    @Override\n+    public long nextLong() {\n+        return randomGenerator.nextLong();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSeed(int seed) {\n+        if (randomGenerator != null) {  // required to avoid NPE in constructor\n+            randomGenerator.setSeed(seed);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSeed(int[] seed) {\n+        if (randomGenerator != null) {  // required to avoid NPE in constructor\n+            randomGenerator.setSeed(seed);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setSeed(long seed) {\n+        if (randomGenerator != null) {  // required to avoid NPE in constructor\n+            randomGenerator.setSeed(seed);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/random/RandomData.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.random;\n+import java.util.Collection;\n+\n+/**\n+ * Random data generation utilities.\n+ * @version $Revision$ $Date$\n+ */\n+public interface RandomData {\n+    /**\n+     * Generates a random string of hex characters of length\n+     * <code>len</code>.\n+     * <p>\n+     * The generated string will be random, but not cryptographically\n+     * secure. To generate cryptographically secure strings, use\n+     * <code>nextSecureHexString</code></p>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>len > 0</code> (otherwise an IllegalArgumentException\n+     *     is thrown.)</li>\n+     * </ul></p>\n+     *\n+     * @param len the length of the string to be generated\n+     * @return random string of hex characters of length <code>len</code>\n+     */\n+    String nextHexString(int len);\n+\n+    /**\n+     * Generates a uniformly distributed random integer between\n+     * <code>lower</code> and <code>upper</code> (endpoints included).\n+     * <p>\n+     * The generated integer will be random, but not cryptographically secure.\n+     * To generate cryptographically secure integer sequences, use\n+     * <code>nextSecureInt</code>.</p>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n+     *     is thrown.)</li>\n+     * </ul></p>\n+     *\n+     * @param lower lower bound for generated integer\n+     * @param upper upper bound for generated integer\n+     * @return a random integer greater than or equal to <code>lower</code>\n+     * and less than or equal to <code>upper</code>.\n+     */\n+    int nextInt(int lower, int upper);\n+\n+    /**\n+     * Generates a uniformly distributed random long integer between\n+     * <code>lower</code> and <code>upper</code> (endpoints included).\n+     * <p>\n+     * The generated long integer values will be random, but not\n+     * cryptographically secure.\n+     * To generate cryptographically secure sequences of longs, use\n+     * <code>nextSecureLong</code></p>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n+     *     is thrown.)</li>\n+     * </ul></p>\n+     *\n+     * @param lower lower bound for generated integer\n+     * @param upper upper bound for generated integer\n+     * @return a random integer greater than or equal to <code>lower</code>\n+     * and less than or equal to <code>upper</code>.\n+     */\n+    long nextLong(long lower, long upper);\n+\n+    /**\n+     * Generates a random string of hex characters from a secure random\n+     * sequence.\n+     * <p>\n+     * If cryptographic security is not required,\n+     * use <code>nextHexString()</code>.</p>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>len > 0</code> (otherwise an IllegalArgumentException\n+     *     is thrown.)</li>\n+     * </ul></p>\n+     * @param len length of return string\n+     * @return the random hex string\n+     */\n+    String nextSecureHexString(int len);\n+\n+    /**\n+     * Generates a uniformly distributed random integer between\n+     * <code>lower</code> and <code>upper</code> (endpoints included)\n+     * from a secure random sequence.\n+     * <p>\n+     * Sequences of integers generated using this method will be\n+     * cryptographically secure. If cryptographic security is not required,\n+     * <code>nextInt</code> should be used instead of this method.</p>\n+     * <p>\n+     * <strong>Definition</strong>:\n+     * <a href=\"http://en.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator\">\n+     * Secure Random Sequence</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n+     *     is thrown.)</li>\n+     * </ul></p>\n+     *\n+     * @param lower lower bound for generated integer\n+     * @param upper upper bound for generated integer\n+     * @return a random integer greater than or equal to <code>lower</code>\n+     * and less than or equal to <code>upper</code>.\n+     */\n+    int nextSecureInt(int lower, int upper);\n+\n+    /**\n+     * Generates a random long integer between <code>lower</code>\n+     * and <code>upper</code> (endpoints included).\n+     * <p>\n+     * Sequences of long values generated using this method will be\n+     * cryptographically secure. If cryptographic security is not required,\n+     * <code>nextLong</code> should be used instead of this method.</p>\n+     * <p>\n+     * <strong>Definition</strong>:\n+     * <a href=\"http://en.wikipedia.org/wiki/Cryptographically_secure_pseudo-random_number_generator\">\n+     * Secure Random Sequence</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n+     *     is thrown.)</li>\n+     * </ul></p>\n+     *\n+     * @param lower lower bound for generated integer\n+     * @param upper upper bound for generated integer\n+     * @return a long integer greater than or equal to <code>lower</code>\n+     * and less than or equal to <code>upper</code>.\n+     */\n+    long nextSecureLong(long lower, long upper);\n+\n+    /**\n+     * Generates a random value from the Poisson distribution with\n+     * the given mean.\n+     * <p>\n+     * <strong>Definition</strong>:\n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda366j.htm\">\n+     * Poisson Distribution</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The specified mean <i>must</i> be positive (otherwise an\n+     *     IllegalArgumentException is thrown.)</li>\n+     * </ul></p>\n+     * @param mean Mean of the distribution\n+     * @return poisson deviate with the specified mean\n+     */\n+    long nextPoisson(double mean);\n+\n+    /**\n+     * Generates a random value from the\n+     * Normal (or Gaussian) distribution with the given mean\n+     * and standard deviation.\n+     * <p>\n+     * <strong>Definition</strong>:\n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda3661.htm\">\n+     * Normal Distribution</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li><code>sigma > 0</code> (otherwise an IllegalArgumentException\n+     *     is thrown.)</li>\n+     * </ul></p>\n+     * @param mu Mean of the distribution\n+     * @param sigma Standard deviation of the distribution\n+     * @return random value from Gaussian distribution with mean = mu,\n+     * standard deviation = sigma\n+     */\n+    double nextGaussian(double mu, double sigma);\n+\n+    /**\n+     * Generates a random value from the exponential distribution\n+     * with expected value = <code>mean</code>.\n+     * <p>\n+     * <strong>Definition</strong>:\n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda3667.htm\">\n+     * Exponential Distribution</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li><code>mu >= 0</code> (otherwise an IllegalArgumentException\n+     *     is thrown.)</li>\n+     * </ul></p>\n+     * @param mean Mean of the distribution\n+     * @return random value from exponential distribution\n+     */\n+    double nextExponential(double mean);\n+\n+    /**\n+     * Generates a uniformly distributed random value from the open interval\n+     * (<code>lower</code>,<code>upper</code>) (i.e., endpoints excluded).\n+     * <p>\n+     * <strong>Definition</strong>:\n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda3662.htm\">\n+     * Uniform Distribution</a> <code>lower</code> and\n+     * <code>upper - lower</code> are the\n+     * <a href = \"http://www.itl.nist.gov/div898/handbook/eda/section3/eda364.htm\">\n+     * location and scale parameters</a>, respectively.</p>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>lower < upper</code> (otherwise an IllegalArgumentException\n+     *     is thrown.)</li>\n+     * </ul></p>\n+     *\n+     * @param lower lower endpoint of the interval of support\n+     * @param upper upper endpoint of the interval of support\n+     * @return uniformly distributed random value between lower\n+     * and upper (exclusive)\n+     */\n+    double nextUniform(double lower, double upper);\n+\n+    /**\n+     * Generates an integer array of length <code>k</code> whose entries\n+     * are selected randomly, without repetition, from the integers <code>\n+     * 0 through n-1</code> (inclusive).\n+     * <p>\n+     * Generated arrays represent permutations\n+     * of <code>n</code> taken <code>k</code> at a time.</p>\n+     * <p>\n+     * <strong>Preconditions:</strong><ul>\n+     * <li> <code>k <= n</code></li>\n+     * <li> <code>n > 0</code> </li>\n+     * </ul>\n+     * If the preconditions are not met, an IllegalArgumentException is\n+     * thrown.</p>\n+     *\n+     * @param n domain of the permutation\n+     * @param k size of the permutation\n+     * @return random k-permutation of n\n+     */\n+    int[] nextPermutation(int n, int k);\n+\n+    /**\n+     * Returns an array of <code>k</code> objects selected randomly\n+     * from the Collection <code>c</code>.\n+     * <p>\n+     * Sampling from <code>c</code>\n+     * is without replacement; but if <code>c</code> contains identical\n+     * objects, the sample may include repeats.  If all elements of <code>\n+     * c</code> are distinct, the resulting object array represents a\n+     * <a href=\"http://rkb.home.cern.ch/rkb/AN16pp/node250.html#SECTION0002500000000000000000\">\n+     * Simple Random Sample</a> of size\n+     * <code>k</code> from the elements of <code>c</code>.</p>\n+     * <p>\n+     * <strong>Preconditions:</strong><ul>\n+     * <li> k must be less than or equal to the size of c </li>\n+     * <li> c must not be empty </li>\n+     * </ul>\n+     * If the preconditions are not met, an IllegalArgumentException is\n+     * thrown.</p>\n+     *\n+     * @param c collection to be sampled\n+     * @param k size of the sample\n+     * @return random sample of k elements from c\n+     */\n+    Object[] nextSample(Collection<?> c, int k);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.random;\n+\n+import java.io.Serializable;\n+import java.security.MessageDigest;\n+import java.security.SecureRandom;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.NoSuchProviderException;\n+import java.util.Collection;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Implements the {@link RandomData} interface using a {@link RandomGenerator}\n+ * instance to generate non-secure data and a {@link java.security.SecureRandom}\n+ * instance to provide data for the <code>nextSecureXxx</code> methods. If no\n+ * <code>RandomGenerator</code> is provided in the constructor, the default is\n+ * to use a generator based on {@link java.util.Random}. To plug in a different\n+ * implementation, either implement <code>RandomGenerator</code> directly or\n+ * extend {@link AbstractRandomGenerator}.\n+ * <p>\n+ * Supports reseeding the underlying pseudo-random number generator (PRNG). The\n+ * <code>SecurityProvider</code> and <code>Algorithm</code> used by the\n+ * <code>SecureRandom</code> instance can also be reset.\n+ * </p>\n+ * <p>\n+ * For details on the default PRNGs, see {@link java.util.Random} and\n+ * {@link java.security.SecureRandom}.\n+ * </p>\n+ * <p>\n+ * <strong>Usage Notes</strong>:\n+ * <ul>\n+ * <li>\n+ * Instance variables are used to maintain <code>RandomGenerator</code> and\n+ * <code>SecureRandom</code> instances used in data generation. Therefore, to\n+ * generate a random sequence of values or strings, you should use just\n+ * <strong>one</strong> <code>RandomDataImpl</code> instance repeatedly.</li>\n+ * <li>\n+ * The \"secure\" methods are *much* slower. These should be used only when a\n+ * cryptographically secure random sequence is required. A secure random\n+ * sequence is a sequence of pseudo-random values which, in addition to being\n+ * well-dispersed (so no subsequence of values is an any more likely than other\n+ * subsequence of the the same length), also has the additional property that\n+ * knowledge of values generated up to any point in the sequence does not make\n+ * it any easier to predict subsequent values.</li>\n+ * <li>\n+ * When a new <code>RandomDataImpl</code> is created, the underlying random\n+ * number generators are <strong>not</strong> intialized. If you do not\n+ * explicitly seed the default non-secure generator, it is seeded with the\n+ * current time in milliseconds on first use. The same holds for the secure\n+ * generator. If you provide a <code>RandomGenerator</code> to the constructor,\n+ * however, this generator is not reseeded by the constructor nor is it reseeded\n+ * on first use.</li>\n+ * <li>\n+ * The <code>reSeed</code> and <code>reSeedSecure</code> methods delegate to the\n+ * corresponding methods on the underlying <code>RandomGenerator</code> and\n+ * <code>SecureRandom</code> instances. Therefore, <code>reSeed(long)</code>\n+ * fully resets the initial state of the non-secure random number generator (so\n+ * that reseeding with a specific value always results in the same subsequent\n+ * random sequence); whereas reSeedSecure(long) does <strong>not</strong>\n+ * reinitialize the secure random number generator (so secure sequences started\n+ * with calls to reseedSecure(long) won't be identical).</li>\n+ * <li>\n+ * This implementation is not synchronized.\n+ * </ul>\n+ * </p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class RandomDataImpl implements RandomData, Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -626730818244969716L;\n+\n+    /** underlying random number generator */\n+    private RandomGenerator rand = null;\n+\n+    /** underlying secure random number generator */\n+    private SecureRandom secRand = null;\n+\n+    /**\n+     * Construct a RandomDataImpl.\n+     */\n+    public RandomDataImpl() {\n+    }\n+\n+    /**\n+     * Construct a RandomDataImpl using the supplied {@link RandomGenerator} as\n+     * the source of (non-secure) random data.\n+     * \n+     * @param rand\n+     *            the source of (non-secure) random data\n+     * @since 1.1\n+     */\n+    public RandomDataImpl(RandomGenerator rand) {\n+        super();\n+        this.rand = rand;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * <strong>Algorithm Description:</strong> hex strings are generated using a\n+     * 2-step process.\n+     * <ol>\n+     * <li>\n+     * len/2+1 binary bytes are generated using the underlying Random</li>\n+     * <li>\n+     * Each binary byte is translated into 2 hex digits</li>\n+     * </ol>\n+     * </p>\n+     * \n+     * @param len\n+     *            the desired string length.\n+     * @return the random string.\n+     */\n+    public String nextHexString(int len) {\n+        if (len <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"length must be positive ({0})\", len);\n+        }\n+\n+        // Get a random number generator\n+        RandomGenerator ran = getRan();\n+\n+        // Initialize output buffer\n+        StringBuffer outBuffer = new StringBuffer();\n+\n+        // Get int(len/2)+1 random bytes\n+        byte[] randomBytes = new byte[(len / 2) + 1];\n+        ran.nextBytes(randomBytes);\n+\n+        // Convert each byte to 2 hex digits\n+        for (int i = 0; i < randomBytes.length; i++) {\n+            Integer c = Integer.valueOf(randomBytes[i]);\n+\n+            /*\n+             * Add 128 to byte value to make interval 0-255 before doing hex\n+             * conversion. This guarantees <= 2 hex digits from toHexString()\n+             * toHexString would otherwise add 2^32 to negative arguments.\n+             */\n+            String hex = Integer.toHexString(c.intValue() + 128);\n+\n+            // Make sure we add 2 hex digits for each byte\n+            if (hex.length() == 1) {\n+                hex = \"0\" + hex;\n+            }\n+            outBuffer.append(hex);\n+        }\n+        return outBuffer.toString().substring(0, len);\n+    }\n+\n+    /**\n+     * Generate a random int value uniformly distributed between\n+     * <code>lower</code> and <code>upper</code>, inclusive.\n+     * \n+     * @param lower\n+     *            the lower bound.\n+     * @param upper\n+     *            the upper bound.\n+     * @return the random integer.\n+     */\n+    public int nextInt(int lower, int upper) {\n+        if (lower >= upper) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"upper bound ({0}) must be greater than lower bound ({1})\",\n+                    upper, lower);\n+        }\n+        RandomGenerator rand = getRan();\n+        double r = rand.nextDouble();\n+        return (int) ((r * upper) + ((1.0 - r) * lower) + r);\n+    }\n+\n+    /**\n+     * Generate a random long value uniformly distributed between\n+     * <code>lower</code> and <code>upper</code>, inclusive.\n+     * \n+     * @param lower\n+     *            the lower bound.\n+     * @param upper\n+     *            the upper bound.\n+     * @return the random integer.\n+     */\n+    public long nextLong(long lower, long upper) {\n+        if (lower >= upper) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"upper bound ({0}) must be greater than lower bound ({1})\",\n+                  upper, lower);\n+        }\n+        RandomGenerator rand = getRan();\n+        double r = rand.nextDouble();\n+        return (long) ((r * upper) + ((1.0 - r) * lower) + r);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * <strong>Algorithm Description:</strong> hex strings are generated in\n+     * 40-byte segments using a 3-step process.\n+     * <ol>\n+     * <li>\n+     * 20 random bytes are generated using the underlying\n+     * <code>SecureRandom</code>.</li>\n+     * <li>\n+     * SHA-1 hash is applied to yield a 20-byte binary digest.</li>\n+     * <li>\n+     * Each byte of the binary digest is converted to 2 hex digits.</li>\n+     * </ol>\n+     * </p>\n+     * \n+     * @param len\n+     *            the length of the generated string\n+     * @return the random string\n+     */\n+    public String nextSecureHexString(int len) {\n+        if (len <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"length must be positive ({0})\", len);\n+        }\n+\n+        // Get SecureRandom and setup Digest provider\n+        SecureRandom secRan = getSecRan();\n+        MessageDigest alg = null;\n+        try {\n+            alg = MessageDigest.getInstance(\"SHA-1\");\n+        } catch (NoSuchAlgorithmException ex) {\n+            return null; // gulp FIXME? -- this *should* never fail.\n+        }\n+        alg.reset();\n+\n+        // Compute number of iterations required (40 bytes each)\n+        int numIter = (len / 40) + 1;\n+\n+        StringBuffer outBuffer = new StringBuffer();\n+        for (int iter = 1; iter < numIter + 1; iter++) {\n+            byte[] randomBytes = new byte[40];\n+            secRan.nextBytes(randomBytes);\n+            alg.update(randomBytes);\n+\n+            // Compute hash -- will create 20-byte binary hash\n+            byte hash[] = alg.digest();\n+\n+            // Loop over the hash, converting each byte to 2 hex digits\n+            for (int i = 0; i < hash.length; i++) {\n+                Integer c = Integer.valueOf(hash[i]);\n+\n+                /*\n+                 * Add 128 to byte value to make interval 0-255 This guarantees\n+                 * <= 2 hex digits from toHexString() toHexString would\n+                 * otherwise add 2^32 to negative arguments\n+                 */\n+                String hex = Integer.toHexString(c.intValue() + 128);\n+\n+                // Keep strings uniform length -- guarantees 40 bytes\n+                if (hex.length() == 1) {\n+                    hex = \"0\" + hex;\n+                }\n+                outBuffer.append(hex);\n+            }\n+        }\n+        return outBuffer.toString().substring(0, len);\n+    }\n+\n+    /**\n+     * Generate a random int value uniformly distributed between\n+     * <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses\n+     * a secure random number generator.\n+     * \n+     * @param lower\n+     *            the lower bound.\n+     * @param upper\n+     *            the upper bound.\n+     * @return the random integer.\n+     */\n+    public int nextSecureInt(int lower, int upper) {\n+        if (lower >= upper) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"upper bound ({0}) must be greater than lower bound ({1})\",\n+                  upper, lower);\n+        }\n+        SecureRandom sec = getSecRan();\n+        return lower + (int) (sec.nextDouble() * (upper - lower + 1));\n+    }\n+\n+    /**\n+     * Generate a random long value uniformly distributed between\n+     * <code>lower</code> and <code>upper</code>, inclusive. This algorithm uses\n+     * a secure random number generator.\n+     * \n+     * @param lower\n+     *            the lower bound.\n+     * @param upper\n+     *            the upper bound.\n+     * @return the random integer.\n+     */\n+    public long nextSecureLong(long lower, long upper) {\n+        if (lower >= upper) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"upper bound ({0}) must be greater than lower bound ({1})\",\n+                  upper, lower);\n+        }\n+        SecureRandom sec = getSecRan();\n+        return lower + (long) (sec.nextDouble() * (upper - lower + 1));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * <strong>Algorithm Description</strong>: For small means, uses simulation\n+     * of a Poisson process using Uniform deviates, as described <a\n+     * href=\"http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm\"> here.</a>\n+     * </p>\n+     * <p>\n+     * The Poisson process (and hence value returned) is bounded by 1000 * mean.\n+     * </p>\n+     * \n+     * <p>\n+     * For large means, uses a reject method as described in <a\n+     * href=\"http://cg.scs.carleton.ca/~luc/rnbookindex.html\">Non-Uniform Random\n+     * Variate Generation</a>\n+     * </p>\n+     * \n+     * <p>\n+     * References:\n+     * <ul>\n+     * <li>Devroye, Luc. (1986). <i>Non-Uniform Random Variate Generation</i>.\n+     * New York, NY. Springer-Verlag</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param mean\n+     *            mean of the Poisson distribution.\n+     * @return the random Poisson value.\n+     */\n+    public long nextPoisson(double mean) {\n+        if (mean <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"the Poisson mean must be positive ({0})\", mean);\n+        }\n+\n+        RandomGenerator rand = getRan();\n+\n+        double pivot = 6.0;\n+        if (mean < pivot) {\n+            double p = Math.exp(-mean);\n+            long n = 0;\n+            double r = 1.0d;\n+            double rnd = 1.0d;\n+\n+            while (n < 1000 * mean) {\n+                rnd = rand.nextDouble();\n+                r = r * rnd;\n+                if (r >= p) {\n+                    n++;\n+                } else {\n+                    return n;\n+                }\n+            }\n+            return n;\n+        } else {\n+            double mu = Math.floor(mean);\n+            double delta = Math.floor(pivot + (mu - pivot) / 2.0); // integer\n+            // between 6\n+            // and mean\n+            double mu2delta = 2.0 * mu + delta;\n+            double muDeltaHalf = mu + delta / 2.0;\n+            double logMeanMu = Math.log(mean / mu);\n+\n+            double muFactorialLog = MathUtils.factorialLog((int) mu);\n+\n+            double c1 = Math.sqrt(Math.PI * mu / 2.0);\n+            double c2 = c1 +\n+                        Math.sqrt(Math.PI * muDeltaHalf /\n+                                  (2.0 * Math.exp(1.0 / mu2delta)));\n+            double c3 = c2 + 2.0;\n+            double c4 = c3 + Math.exp(1.0 / 78.0);\n+            double c = c4 + 2.0 / delta * mu2delta *\n+                       Math.exp(-delta / mu2delta * (1.0 + delta / 2.0));\n+\n+            double y = 0.0;\n+            double x = 0.0;\n+            double w = Double.POSITIVE_INFINITY;\n+\n+            boolean accept = false;\n+            while (!accept) {\n+                double u = nextUniform(0.0, c);\n+                double e = nextExponential(mean);\n+\n+                if (u <= c1) {\n+                    double z = nextGaussian(0.0, 1.0);\n+                    y = -Math.abs(z) * Math.sqrt(mu) - 1.0;\n+                    x = Math.floor(y);\n+                    w = -z * z / 2.0 - e - x * logMeanMu;\n+                    if (x < -mu) {\n+                        w = Double.POSITIVE_INFINITY;\n+                    }\n+                } else if (c1 < u && u <= c2) {\n+                    double z = nextGaussian(0.0, 1.0);\n+                    y = 1.0 + Math.abs(z) * Math.sqrt(muDeltaHalf);\n+                    x = Math.ceil(y);\n+                    w = (-y * y + 2.0 * y) / mu2delta - e - x * logMeanMu;\n+                    if (x > delta) {\n+                        w = Double.POSITIVE_INFINITY;\n+                    }\n+                } else if (c2 < u && u <= c3) {\n+                    x = 0.0;\n+                    w = -e;\n+                } else if (c3 < u && u <= c4) {\n+                    x = 1.0;\n+                    w = -e - logMeanMu;\n+                } else if (c4 < u) {\n+                    double v = nextExponential(mean);\n+                    y = delta + v * 2.0 / delta * mu2delta;\n+                    x = Math.ceil(y);\n+                    w = -delta / mu2delta * (1.0 + y / 2.0) - e - x * logMeanMu;\n+                }\n+                accept = (w <= x * Math.log(mu) -\n+                         MathUtils.factorialLog((int) (mu + x)) /\n+                         muFactorialLog);\n+            }\n+            // cast to long is acceptable because both x and mu are whole\n+            // numbers.\n+            return (long) (x + mu);\n+        }\n+    }\n+\n+    /**\n+     * Generate a random value from a Normal (a.k.a. Gaussian) distribution with\n+     * the given mean, <code>mu</code> and the given standard deviation,\n+     * <code>sigma</code>.\n+     * \n+     * @param mu\n+     *            the mean of the distribution\n+     * @param sigma\n+     *            the standard deviation of the distribution\n+     * @return the random Normal value\n+     */\n+    public double nextGaussian(double mu, double sigma) {\n+        if (sigma <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"standard deviation must be positive ({0})\", sigma);\n+        }\n+        RandomGenerator rand = getRan();\n+        return sigma * rand.nextGaussian() + mu;\n+    }\n+\n+    /**\n+     * Returns a random value from an Exponential distribution with the given\n+     * mean.\n+     * <p>\n+     * <strong>Algorithm Description</strong>: Uses the <a\n+     * href=\"http://www.jesus.ox.ac.uk/~clifford/a5/chap1/node5.html\"> Inversion\n+     * Method</a> to generate exponentially distributed random values from\n+     * uniform deviates.\n+     * </p>\n+     * \n+     * @param mean\n+     *            the mean of the distribution\n+     * @return the random Exponential value\n+     */\n+    public double nextExponential(double mean) {\n+        if (mean < 0.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"mean must be positive ({0})\", mean);\n+        }\n+        RandomGenerator rand = getRan();\n+        double unif = rand.nextDouble();\n+        while (unif == 0.0d) {\n+            unif = rand.nextDouble();\n+        }\n+        return -mean * Math.log(unif);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p>\n+     * <strong>Algorithm Description</strong>: scales the output of\n+     * Random.nextDouble(), but rejects 0 values (i.e., will generate another\n+     * random double if Random.nextDouble() returns 0). This is necessary to\n+     * provide a symmetric output interval (both endpoints excluded).\n+     * </p>\n+     * \n+     * @param lower\n+     *            the lower bound.\n+     * @param upper\n+     *            the upper bound.\n+     * @return a uniformly distributed random value from the interval (lower,\n+     *         upper)\n+     */\n+    public double nextUniform(double lower, double upper) {\n+        if (lower >= upper) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"upper bound ({0}) must be greater than lower bound ({1})\",\n+                  upper, lower);\n+        }\n+        RandomGenerator rand = getRan();\n+\n+        // ensure nextDouble() isn't 0.0\n+        double u = rand.nextDouble();\n+        while (u <= 0.0) {\n+            u = rand.nextDouble();\n+        }\n+\n+        return lower + u * (upper - lower);\n+    }\n+\n+    /**\n+     * Returns the RandomGenerator used to generate non-secure random data.\n+     * <p>\n+     * Creates and initializes a default generator if null.\n+     * </p>\n+     * \n+     * @return the Random used to generate random data\n+     * @since 1.1\n+     */\n+    private RandomGenerator getRan() {\n+        if (rand == null) {\n+            rand = new JDKRandomGenerator();\n+            rand.setSeed(System.currentTimeMillis());\n+        }\n+        return rand;\n+    }\n+\n+    /**\n+     * Returns the SecureRandom used to generate secure random data.\n+     * <p>\n+     * Creates and initializes if null.\n+     * </p>\n+     * \n+     * @return the SecureRandom used to generate secure random data\n+     */\n+    private SecureRandom getSecRan() {\n+        if (secRand == null) {\n+            secRand = new SecureRandom();\n+            secRand.setSeed(System.currentTimeMillis());\n+        }\n+        return secRand;\n+    }\n+\n+    /**\n+     * Reseeds the random number generator with the supplied seed.\n+     * <p>\n+     * Will create and initialize if null.\n+     * </p>\n+     * \n+     * @param seed\n+     *            the seed value to use\n+     */\n+    public void reSeed(long seed) {\n+        if (rand == null) {\n+            rand = new JDKRandomGenerator();\n+        }\n+        rand.setSeed(seed);\n+    }\n+\n+    /**\n+     * Reseeds the secure random number generator with the current time in\n+     * milliseconds.\n+     * <p>\n+     * Will create and initialize if null.\n+     * </p>\n+     */\n+    public void reSeedSecure() {\n+        if (secRand == null) {\n+            secRand = new SecureRandom();\n+        }\n+        secRand.setSeed(System.currentTimeMillis());\n+    }\n+\n+    /**\n+     * Reseeds the secure random number generator with the supplied seed.\n+     * <p>\n+     * Will create and initialize if null.\n+     * </p>\n+     * \n+     * @param seed\n+     *            the seed value to use\n+     */\n+    public void reSeedSecure(long seed) {\n+        if (secRand == null) {\n+            secRand = new SecureRandom();\n+        }\n+        secRand.setSeed(seed);\n+    }\n+\n+    /**\n+     * Reseeds the random number generator with the current time in\n+     * milliseconds.\n+     */\n+    public void reSeed() {\n+        if (rand == null) {\n+            rand = new JDKRandomGenerator();\n+        }\n+        rand.setSeed(System.currentTimeMillis());\n+    }\n+\n+    /**\n+     * Sets the PRNG algorithm for the underlying SecureRandom instance using\n+     * the Security Provider API. The Security Provider API is defined in <a\n+     * href =\n+     * \"http://java.sun.com/j2se/1.3/docs/guide/security/CryptoSpec.html#AppA\">\n+     * Java Cryptography Architecture API Specification & Reference.</a>\n+     * <p>\n+     * <strong>USAGE NOTE:</strong> This method carries <i>significant</i>\n+     * overhead and may take several seconds to execute.\n+     * </p>\n+     * \n+     * @param algorithm\n+     *            the name of the PRNG algorithm\n+     * @param provider\n+     *            the name of the provider\n+     * @throws NoSuchAlgorithmException\n+     *             if the specified algorithm is not available\n+     * @throws NoSuchProviderException\n+     *             if the specified provider is not installed\n+     */\n+    public void setSecureAlgorithm(String algorithm, String provider)\n+            throws NoSuchAlgorithmException, NoSuchProviderException {\n+        secRand = SecureRandom.getInstance(algorithm, provider);\n+    }\n+\n+    /**\n+     * Generates an integer array of length <code>k</code> whose entries are\n+     * selected randomly, without repetition, from the integers\n+     * <code>0 through n-1</code> (inclusive).\n+     * <p>\n+     * Generated arrays represent permutations of <code>n</code> taken\n+     * <code>k</code> at a time.\n+     * </p>\n+     * <p>\n+     * <strong>Preconditions:</strong>\n+     * <ul>\n+     * <li> <code>k <= n</code></li>\n+     * <li> <code>n > 0</code></li>\n+     * </ul>\n+     * If the preconditions are not met, an IllegalArgumentException is thrown.\n+     * </p>\n+     * <p>\n+     * Uses a 2-cycle permutation shuffle. The shuffling process is described <a\n+     * href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n+     * here</a>.\n+     * </p>\n+     * \n+     * @param n\n+     *            domain of the permutation (must be positive)\n+     * @param k\n+     *            size of the permutation (must satisfy 0 < k <= n).\n+     * @return the random permutation as an int array\n+     */\n+    public int[] nextPermutation(int n, int k) {\n+        if (k > n) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"permutation k ({0}) exceeds n ({1})\", k, n);\n+        }\n+        if (k == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"permutation k ({0}) must be positive\", k);\n+        }\n+\n+        int[] index = getNatural(n);\n+        shuffle(index, n - k);\n+        int[] result = new int[k];\n+        for (int i = 0; i < k; i++) {\n+            result[i] = index[n - i - 1];\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Uses a 2-cycle permutation shuffle to generate a random permutation.\n+     * <strong>Algorithm Description</strong>: Uses a 2-cycle permutation\n+     * shuffle to generate a random permutation of <code>c.size()</code> and\n+     * then returns the elements whose indexes correspond to the elements of the\n+     * generated permutation. This technique is described, and proven to\n+     * generate random samples, <a\n+     * href=\"http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html\">\n+     * here</a>\n+     * \n+     * @param c\n+     *            Collection to sample from.\n+     * @param k\n+     *            sample size.\n+     * @return the random sample.\n+     */\n+    public Object[] nextSample(Collection<?> c, int k) {\n+        int len = c.size();\n+        if (k > len) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"sample size ({0}) exceeds collection size ({1})\");\n+        }\n+        if (k <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"sample size must be positive ({0})\", k);\n+        }\n+\n+        Object[] objects = c.toArray();\n+        int[] index = nextPermutation(len, k);\n+        Object[] result = new Object[k];\n+        for (int i = 0; i < k; i++) {\n+            result[i] = objects[index[i]];\n+        }\n+        return result;\n+    }\n+\n+    // ------------------------Private methods----------------------------------\n+\n+    /**\n+     * Uses a 2-cycle permutation shuffle to randomly re-order the last elements\n+     * of list.\n+     * \n+     * @param list\n+     *            list to be shuffled\n+     * @param end\n+     *            element past which shuffling begins\n+     */\n+    private void shuffle(int[] list, int end) {\n+        int target = 0;\n+        for (int i = list.length - 1; i >= end; i--) {\n+            if (i == 0) {\n+                target = 0;\n+            } else {\n+                target = nextInt(0, i);\n+            }\n+            int temp = list[target];\n+            list[target] = list[i];\n+            list[i] = temp;\n+        }\n+    }\n+\n+    /**\n+     * Returns an array representing n.\n+     * \n+     * @param n\n+     *            the natural number to represent\n+     * @return array with entries = elements of n\n+     */\n+    private int[] getNatural(int n) {\n+        int[] natural = new int[n];\n+        for (int i = 0; i < n; i++) {\n+            natural[i] = i;\n+        }\n+        return natural;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/random/RandomGenerator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.random;\n+\n+\n+/**\n+ * Interface extracted from <code>java.util.Random</code>.  This interface is\n+ * implemented by {@link AbstractRandomGenerator}.  \n+ *\n+ * @since 1.1\n+ * @version $Revision$ $Date$\n+ */\n+public interface RandomGenerator {\n+    \n+    /**\n+     * Sets the seed of the underyling random number generator using an\n+     * <code>int</code> seed.\n+     * <p>Sequences of values generated starting with the same seeds\n+     * should be identical.\n+     * </p>\n+     * @param seed the seed value\n+     */\n+    void setSeed(int seed);\n+\n+    /**\n+     * Sets the seed of the underyling random number generator using an\n+     * <code>int</code> array seed.\n+     * <p>Sequences of values generated starting with the same seeds\n+     * should be identical.\n+     * </p>\n+     * @param seed the seed value\n+     */\n+    void setSeed(int[] seed);\n+    \n+    /**\n+     * Sets the seed of the underyling random number generator using a\n+     * <code>long</code> seed.\n+     * <p>Sequences of values generated starting with the same seeds\n+     * should be identical.\n+     * </p>\n+     * @param seed the seed value\n+     */\n+    void setSeed(long seed);\n+    \n+    /**\n+     * Generates random bytes and places them into a user-supplied \n+     * byte array.  The number of random bytes produced is equal to \n+     * the length of the byte array.\n+     * \n+     * @param bytes the non-null byte array in which to put the \n+     * random bytes\n+     */\n+    void nextBytes(byte[] bytes);\n+    \n+    /**\n+     * Returns the next pseudorandom, uniformly distributed <code>int</code>\n+     * value from this random number generator's sequence.  \n+     * All 2<font size=\"-1\"><sup>32</sup></font> possible <tt>int</tt> values\n+     * should be produced with  (approximately) equal probability. \n+     *\n+     * @return the next pseudorandom, uniformly distributed <code>int</code>\n+     *  value from this random number generator's sequence\n+     */\n+    int nextInt();\n+    \n+    /**\n+     * Returns a pseudorandom, uniformly distributed <tt>int</tt> value\n+     * between 0 (inclusive) and the specified value (exclusive), drawn from\n+     * this random number generator's sequence.   \n+     *\n+     * @param n the bound on the random number to be returned.  Must be\n+     * positive.\n+     * @return  a pseudorandom, uniformly distributed <tt>int</tt>\n+     * value between 0 (inclusive) and n (exclusive).\n+     * @throws IllegalArgumentException  if n is not positive.\n+     */\n+    int nextInt(int n);\n+    \n+    /**\n+     * Returns the next pseudorandom, uniformly distributed <code>long</code>\n+     * value from this random number generator's sequence.  All \n+     * 2<font size=\"-1\"><sup>64</sup></font> possible <tt>long</tt> values \n+     * should be produced with (approximately) equal probability. \n+     *\n+     * @return  the next pseudorandom, uniformly distributed <code>long</code>\n+     *value from this random number generator's sequence\n+     */\n+    long nextLong();\n+    \n+    /**\n+     * Returns the next pseudorandom, uniformly distributed\n+     * <code>boolean</code> value from this random number generator's\n+     * sequence.  \n+     * \n+     * @return  the next pseudorandom, uniformly distributed\n+     * <code>boolean</code> value from this random number generator's\n+     * sequence\n+     */\n+    boolean nextBoolean();\n+    \n+    /**\n+     * Returns the next pseudorandom, uniformly distributed <code>float</code>\n+     * value between <code>0.0</code> and <code>1.0</code> from this random\n+     * number generator's sequence.  \n+     *\n+     * @return  the next pseudorandom, uniformly distributed <code>float</code>\n+     * value between <code>0.0</code> and <code>1.0</code> from this\n+     * random number generator's sequence\n+     */\n+    float nextFloat();\n+    \n+    /**\n+     * Returns the next pseudorandom, uniformly distributed \n+     * <code>double</code> value between <code>0.0</code> and\n+     * <code>1.0</code> from this random number generator's sequence.  \n+     *\n+     * @return  the next pseudorandom, uniformly distributed \n+     *  <code>double</code> value between <code>0.0</code> and\n+     *  <code>1.0</code> from this random number generator's sequence\n+     */  \n+    double nextDouble();\n+    \n+    /**\n+     * Returns the next pseudorandom, Gaussian (\"normally\") distributed\n+     * <code>double</code> value with mean <code>0.0</code> and standard\n+     * deviation <code>1.0</code> from this random number generator's sequence.\n+     * \n+     * @return  the next pseudorandom, Gaussian (\"normally\") distributed\n+     * <code>double</code> value with mean <code>0.0</code> and\n+     * standard deviation <code>1.0</code> from this random number\n+     *  generator's sequence\n+     */\n+    double nextGaussian();\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/random/RandomVectorGenerator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.random;\n+\n+\n+/** This interface represents a random generator for whole vectors.\n+ * \n+ * @since 1.2\n+ * @version $Revision$ $Date$\n+ *\n+ */\n+\n+public interface RandomVectorGenerator {\n+\n+  /** Generate a random vector.\n+   * @return a random vector as an array of double.\n+   */\n+  public double[] nextVector();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/random/UncorrelatedRandomVectorGenerator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.random;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/** \n+ * A {@link RandomVectorGenerator} that generates vectors with uncorrelated\n+ * components. Components of generated vectors follow (independent) Gaussian\n+ * distributions, with parameters supplied in the constructor.\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+\n+public class UncorrelatedRandomVectorGenerator\n+  implements RandomVectorGenerator {\n+\n+  /** Simple constructor.\n+   * <p>Build an uncorrelated random vector generator from\n+   * its mean and standard deviation vectors.</p>\n+   * @param mean expected mean values for each component\n+   * @param standardDeviation standard deviation for each component\n+   * @param generator underlying generator for uncorrelated normalized\n+   * components\n+   */\n+  public UncorrelatedRandomVectorGenerator(double[] mean,\n+                                           double[] standardDeviation,\n+                                           NormalizedRandomGenerator generator) {\n+    if (mean.length != standardDeviation.length) {\n+      throw MathRuntimeException.createIllegalArgumentException(\n+            \"dimension mismatch {0} != {1}\",\n+            mean.length, standardDeviation.length);\n+    }\n+    this.mean              = mean.clone();\n+    this.standardDeviation = standardDeviation.clone();\n+    this.generator = generator;\n+  }\n+\n+  /** Simple constructor.\n+   * <p>Build a null mean random and unit standard deviation\n+   * uncorrelated vector generator</p>\n+   * @param dimension dimension of the vectors to generate\n+   * @param generator underlying generator for uncorrelated normalized\n+   * components\n+   */\n+  public UncorrelatedRandomVectorGenerator(int dimension,\n+                                           NormalizedRandomGenerator generator) {\n+    mean              = new double[dimension];\n+    standardDeviation = new double[dimension];\n+    Arrays.fill(standardDeviation, 1.0);\n+    this.generator = generator;\n+  }\n+\n+  /** Generate an uncorrelated random vector.\n+   * @return a random vector as a newly built array of double\n+   */\n+  public double[] nextVector() {\n+\n+    double[] random = new double[mean.length]; \n+    for (int i = 0; i < random.length; ++i) {\n+      random[i] = mean[i] + standardDeviation[i] * generator.nextNormalizedDouble();\n+    }\n+\n+    return random;\n+\n+  }\n+\n+  /** Mean vector. */\n+  private double[] mean;\n+\n+  /** Standard deviation vector. */\n+  private double[] standardDeviation;\n+\n+  /** Underlying scalar generator. */\n+  private NormalizedRandomGenerator generator;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/random/UniformRandomGenerator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.random;\n+\n+/** \n+ * This class implements a normalized uniform random generator.\n+ * <p>Since it is a normalized random generator, it generates values\n+ * from a uniform distribution with mean equal to 0 and standard \n+ * deviation equal to 1. Generated values fall in the range\n+ * [-&#x0221A;3, +&#x0221A;3].</p>\n+ * \n+ * @since 1.2\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+\n+public class UniformRandomGenerator implements NormalizedRandomGenerator {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 1569292426375546027L;\n+\n+    /** Create a new generator.\n+     * @param generator underlying random generator to use\n+     */\n+    public UniformRandomGenerator(RandomGenerator generator) {\n+        this.generator = generator;\n+    }\n+\n+    /** Generate a random scalar with null mean and unit standard deviation.\n+     * <p>The number generated is uniformly distributed between -&sqrt;(3)\n+     * and +&sqrt;(3).</p>\n+     * @return a random scalar with null mean and unit standard deviation\n+     */\n+    public double nextNormalizedDouble() {\n+        return SQRT3 * (2 * generator.nextDouble() - 1.0);\n+    }\n+\n+    /** Underlying generator. */\n+    private RandomGenerator generator;\n+\n+    /** Square root of three. */\n+    private static final double SQRT3 = Math.sqrt(3.0);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/random/ValueServer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.random;\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Generates values for use in simulation applications.\n+ * <p>\n+ * How values are generated is determined by the <code>mode</code>\n+ * property.</p>\n+ * <p>\n+ * Supported <code>mode</code> values are: <ul>\n+ * <li> DIGEST_MODE -- uses an empirical distribution </li>\n+ * <li> REPLAY_MODE -- replays data from <code>valuesFileURL</code></li>\n+ * <li> UNIFORM_MODE -- generates uniformly distributed random values with\n+ *                      mean = <code>mu</code> </li>\n+ * <li> EXPONENTIAL_MODE -- generates exponentially distributed random values\n+ *                         with mean = <code>mu</code></li>\n+ * <li> GAUSSIAN_MODE -- generates Gaussian distributed random values with\n+ *                       mean = <code>mu</code> and\n+ *                       standard deviation = <code>sigma</code></li>\n+ * <li> CONSTANT_MODE -- returns <code>mu</code> every time.</li></ul></p>\n+ *\n+ * @version $Revision$ $Date$\n+ *\n+ */\n+public class ValueServer {\n+    /** mode determines how values are generated */\n+    private int mode = 5;\n+\n+    /** URI to raw data values  */\n+    private URL valuesFileURL = null;\n+\n+    /** Mean for use with non-data-driven modes */\n+    private double mu = 0.0;\n+\n+    /** Standard deviation for use with GAUSSIAN_MODE */\n+    private double sigma = 0.0;\n+\n+    /** Empirical probability distribution for use with DIGEST_MODE */\n+    private EmpiricalDistribution empiricalDistribution = null;\n+\n+    /** file pointer for REPLAY_MODE */\n+    private BufferedReader filePointer = null;\n+\n+    /** RandomDataImpl to use for random data generation */\n+    private RandomData randomData = new RandomDataImpl();\n+\n+    // Data generation modes ======================================\n+\n+    /** Use empirical distribution  */\n+    public static final int DIGEST_MODE = 0;\n+\n+    /** Replay data from valuesFilePath */\n+    public static final int REPLAY_MODE = 1;\n+\n+    /** Uniform random deviates with mean = mu */\n+    public static final int UNIFORM_MODE = 2;\n+\n+    /** Exponential random deviates with mean = mu */\n+    public static final int EXPONENTIAL_MODE = 3;\n+\n+    /** Gaussian random deviates with mean = mu, std dev = sigma */\n+    public static final int GAUSSIAN_MODE = 4;\n+\n+    /** Always return mu */\n+    public static final int CONSTANT_MODE = 5;\n+\n+    /** Creates new ValueServer */\n+    public ValueServer() {\n+    }\n+\n+    /**\n+     * Returns the next generated value, generated according\n+     * to the mode value (see MODE constants).\n+     *\n+     * @return generated value\n+     * @throws IOException in REPLAY_MODE if a file I/O error occurs\n+     */\n+    public double getNext() throws IOException {\n+        switch (mode) {\n+            case DIGEST_MODE: return getNextDigest();\n+            case REPLAY_MODE: return getNextReplay();\n+            case UNIFORM_MODE: return getNextUniform();\n+            case EXPONENTIAL_MODE: return getNextExponential();\n+            case GAUSSIAN_MODE: return getNextGaussian();\n+            case CONSTANT_MODE: return mu;\n+            default: throw MathRuntimeException.createIllegalStateException(\n+                    \"unknown mode {0}, known modes: \" +\n+                    \"{1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}) and {11} ({12})\",\n+                    mode,\n+                    \"DIGEST_MODE\",   DIGEST_MODE,   \"REPLAY_MODE\",      REPLAY_MODE,\n+                    \"UNIFORM_MODE\",  UNIFORM_MODE,  \"EXPONENTIAL_MODE\", EXPONENTIAL_MODE,\n+                    \"GAUSSIAN_MODE\", GAUSSIAN_MODE, \"CONSTANT_MODE\",    CONSTANT_MODE);\n+        }\n+    }\n+\n+    /**\n+     * Fills the input array with values generated using getNext() repeatedly.\n+     *\n+     * @param values array to be filled\n+     * @throws IOException in REPLAY_MODE if a file I/O error occurs\n+     */\n+    public void fill(double[] values) throws IOException {\n+        for (int i = 0; i < values.length; i++) {\n+            values[i] = getNext();\n+        }\n+    }\n+\n+    /**\n+     * Returns an array of length <code>length</code> with values generated\n+     * using getNext() repeatedly.\n+     *\n+     * @param length length of output array\n+     * @return array of generated values\n+     * @throws IOException in REPLAY_MODE if a file I/O error occurs\n+     */\n+    public double[] fill(int length) throws IOException {\n+        double[] out = new double[length];\n+        for (int i = 0; i < length; i++) {\n+            out[i] = getNext();\n+        }\n+        return out;\n+    }\n+\n+    /**\n+     * Computes the empirical distribution using values from the file\n+     * in <code>valuesFileURL</code>, using the default number of bins.\n+     * <p>\n+     * <code>valuesFileURL</code> must exist and be\n+     * readable by *this at runtime.</p>\n+     * <p>\n+     * This method must be called before using <code>getNext()</code>\n+     * with <code>mode = DIGEST_MODE</code></p>\n+     *\n+     * @throws IOException if an I/O error occurs reading the input file\n+     */\n+    public void computeDistribution() throws IOException {\n+        empiricalDistribution = new EmpiricalDistributionImpl();\n+        empiricalDistribution.load(valuesFileURL);\n+    }\n+\n+    /**\n+     * Computes the empirical distribution using values from the file\n+     * in <code>valuesFileURL</code> and <code>binCount</code> bins.\n+     * <p>\n+     * <code>valuesFileURL</code> must exist and be readable by this process\n+     * at runtime.</p>\n+     * <p>\n+     * This method must be called before using <code>getNext()</code>\n+     * with <code>mode = DIGEST_MODE</code></p>\n+     *\n+     * @param binCount the number of bins used in computing the empirical\n+     * distribution\n+     * @throws IOException if an error occurs reading the input file\n+     */\n+    public void computeDistribution(int binCount)\n+            throws IOException {\n+        empiricalDistribution = new EmpiricalDistributionImpl(binCount);\n+        empiricalDistribution.load(valuesFileURL);\n+        mu = empiricalDistribution.getSampleStats().getMean();\n+        sigma = empiricalDistribution.getSampleStats().getStandardDeviation();\n+    }\n+\n+    /** Getter for property mode.\n+     * @return Value of property mode.\n+     */\n+    public int getMode() {\n+        return mode;\n+    }\n+\n+    /** Setter for property mode.\n+     * @param mode New value of property mode.\n+     */\n+    public void setMode(int mode) {\n+        this.mode = mode;\n+    }\n+\n+    /**\n+     * Getter for <code>valuesFileURL<code>\n+     * @return Value of property valuesFileURL.\n+     */\n+    public URL getValuesFileURL() {\n+        return valuesFileURL;\n+    }\n+\n+    /**\n+     * Sets the <code>valuesFileURL</code> using a string URL representation\n+     * @param url String representation for new valuesFileURL.\n+     * @throws MalformedURLException if url is not well formed\n+     */\n+    public void setValuesFileURL(String url) throws MalformedURLException {\n+        this.valuesFileURL = new URL(url);\n+    }\n+\n+    /**\n+     * Sets the <code>valuesFileURL</code>\n+     * @param url New value of property valuesFileURL.\n+     */\n+    public void setValuesFileURL(URL url) {\n+        this.valuesFileURL = url;\n+    }\n+\n+    /** Getter for property empiricalDistribution.\n+     * @return Value of property empiricalDistribution.\n+     */\n+    public EmpiricalDistribution getEmpiricalDistribution() {\n+        return empiricalDistribution;\n+    }\n+\n+    /**\n+     * Resets REPLAY_MODE file pointer to the beginning of the <code>valuesFileURL</code>.\n+     *\n+     * @throws IOException if an error occurs opening the file\n+     */\n+    public void resetReplayFile() throws IOException {\n+        if (filePointer != null) {\n+            try {\n+                filePointer.close();\n+                filePointer = null;\n+            } catch (IOException ex) {\n+                // ignore\n+            }\n+        }\n+        filePointer = new BufferedReader(new InputStreamReader(valuesFileURL.openStream()));\n+    }\n+\n+    /**\n+     * Closes <code>valuesFileURL</code> after use in REPLAY_MODE.\n+     *\n+     * @throws IOException if an error occurs closing the file\n+     */\n+    public void closeReplayFile() throws IOException {\n+        if (filePointer != null) {\n+            filePointer.close();\n+            filePointer = null;\n+        }\n+    }\n+\n+    /** Getter for property mu.\n+     * @return Value of property mu.\n+     */\n+    public double getMu() {\n+        return mu;\n+    }\n+\n+    /** Setter for property mu.\n+     * @param mu New value of property mu.\n+     */\n+    public void setMu(double mu) {\n+        this.mu = mu;\n+    }\n+\n+    /** Getter for property sigma.\n+     * @return Value of property sigma.\n+     */\n+    public double getSigma() {\n+        return sigma;\n+    }\n+\n+    /** Setter for property sigma.\n+     * @param sigma New value of property sigma.\n+     */\n+    public void setSigma(double sigma) {\n+        this.sigma = sigma;\n+    }\n+\n+    //------------- private methods ---------------------------------\n+\n+    /**\n+     * Gets a random value in DIGEST_MODE.\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>Before this method is called, <code>computeDistribution()</code>\n+     * must have completed successfully; otherwise an\n+     * <code>IllegalStateException</code> will be thrown</li></ul></p>\n+     *\n+     * @return next random value from the empirical distribution digest\n+     */\n+    private double getNextDigest() {\n+        if ((empiricalDistribution == null) ||\n+            (empiricalDistribution.getBinStats().size() == 0)) {\n+            throw MathRuntimeException.createIllegalStateException(\"digest not initialized\");\n+        }\n+        return empiricalDistribution.getNextValue();\n+    }\n+\n+    /**\n+     * Gets next sequential value from the <code>valuesFileURL</code>.\n+     * <p>\n+     * Throws an IOException if the read fails.</p>\n+     * <p>\n+     * This method will open the <code>valuesFileURL</code> if there is no\n+     * replay file open.</p>\n+     * <p>\n+     * The <code>valuesFileURL</code> will be closed and reopened to wrap around\n+     * from EOF to BOF if EOF is encountered. EOFException (which is a kind of\n+     * IOException) may still be thrown if the <code>valuesFileURL</code> is\n+     * empty.</p>\n+     *\n+     * @return next value from the replay file\n+     * @throws IOException if there is a problem reading from the file\n+     * @throws NumberFormatException if an invalid numeric string is\n+     *   encountered in the file\n+     */\n+    private double getNextReplay() throws IOException {\n+        String str = null;\n+        if (filePointer == null) {\n+            resetReplayFile();\n+        }\n+        if ((str = filePointer.readLine()) == null) {\n+            // we have probably reached end of file, wrap around from EOF to BOF\n+            closeReplayFile();\n+            resetReplayFile();\n+            if ((str = filePointer.readLine()) == null) {\n+                throw MathRuntimeException.createEOFException(\"URL {0} contains no data\",\n+                                                              valuesFileURL);\n+            }\n+        }\n+        return Double.valueOf(str).doubleValue();\n+    }\n+\n+    /**\n+     * Gets a uniformly distributed random value with mean = mu.\n+     *\n+     * @return random uniform value\n+     */\n+    private double getNextUniform() {\n+        return randomData.nextUniform(0, 2 * mu);\n+    }\n+\n+    /**\n+     * Gets an exponentially distributed random value with mean = mu.\n+     *\n+     * @return random exponential value\n+     */\n+    private double getNextExponential() {\n+        return randomData.nextExponential(mu);\n+    }\n+\n+    /**\n+     * Gets a Gaussian distributed random value with mean = mu\n+     * and standard deviation = sigma.\n+     *\n+     * @return random Gaussian value\n+     */\n+    private double getNextGaussian() {\n+        return randomData.nextGaussian(mu, sigma);\n+    }\n+\n+    /**\n+     * Construct a ValueServer instance using a RandomData as its source\n+     * of random data.\n+     * \n+     * @param randomData the RandomData instance used to source random data\n+     * @since 1.1\n+     */\n+    public ValueServer(RandomData randomData) {\n+        super();\n+        this.randomData = randomData;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/special/Beta.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.special;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.util.ContinuedFraction;\n+\n+/**\n+ * This is a utility class that provides computation methods related to the\n+ * Beta family of functions.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class Beta {\n+\n+    /** Maximum allowed numerical error. */\n+    private static final double DEFAULT_EPSILON = 10e-15;\n+\n+    /**\n+     * Default constructor.  Prohibit instantiation.\n+     */\n+    private Beta() {\n+        super();\n+    }\n+\n+    /**\n+     * Returns the\n+     * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n+     * regularized beta function</a> I(x, a, b).\n+     * \n+     * @param x the value.\n+     * @param a the a parameter.\n+     * @param b the b parameter.\n+     * @return the regularized beta function I(x, a, b)\n+     * @throws MathException if the algorithm fails to converge.\n+     */\n+    public static double regularizedBeta(double x, double a, double b)\n+        throws MathException\n+    {\n+        return regularizedBeta(x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Returns the\n+     * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n+     * regularized beta function</a> I(x, a, b).\n+     * \n+     * @param x the value.\n+     * @param a the a parameter.\n+     * @param b the b parameter.\n+     * @param epsilon When the absolute value of the nth item in the\n+     *                series is less than epsilon the approximation ceases\n+     *                to calculate further elements in the series.\n+     * @return the regularized beta function I(x, a, b)\n+     * @throws MathException if the algorithm fails to converge.\n+     */\n+    public static double regularizedBeta(double x, double a, double b,\n+        double epsilon) throws MathException\n+    {\n+        return regularizedBeta(x, a, b, epsilon, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Returns the regularized beta function I(x, a, b).\n+     * \n+     * @param x the value.\n+     * @param a the a parameter.\n+     * @param b the b parameter.\n+     * @param maxIterations Maximum number of \"iterations\" to complete. \n+     * @return the regularized beta function I(x, a, b)\n+     * @throws MathException if the algorithm fails to converge.\n+     */\n+    public static double regularizedBeta(double x, double a, double b,\n+        int maxIterations) throws MathException\n+    {\n+        return regularizedBeta(x, a, b, DEFAULT_EPSILON, maxIterations);\n+    }\n+    \n+    /**\n+     * Returns the regularized beta function I(x, a, b).\n+     * \n+     * The implementation of this method is based on:\n+     * <ul>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\">\n+     * Regularized Beta Function</a>.</li>\n+     * <li>\n+     * <a href=\"http://functions.wolfram.com/06.21.10.0001.01\">\n+     * Regularized Beta Function</a>.</li>\n+     * </ul>\n+     * \n+     * @param x the value.\n+     * @param a the a parameter.\n+     * @param b the b parameter.\n+     * @param epsilon When the absolute value of the nth item in the\n+     *                series is less than epsilon the approximation ceases\n+     *                to calculate further elements in the series.\n+     * @param maxIterations Maximum number of \"iterations\" to complete. \n+     * @return the regularized beta function I(x, a, b)\n+     * @throws MathException if the algorithm fails to converge.\n+     */\n+    public static double regularizedBeta(double x, final double a,\n+        final double b, double epsilon, int maxIterations) throws MathException\n+    {\n+        double ret;\n+\n+        if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || (x < 0) ||\n+            (x > 1) || (a <= 0.0) || (b <= 0.0))\n+        {\n+            ret = Double.NaN;\n+        } else if (x > (a + 1.0) / (a + b + 2.0)) {\n+            ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n+        } else {\n+            ContinuedFraction fraction = new ContinuedFraction() {\n+\n+                @Override\n+                protected double getB(int n, double x) {\n+                    double ret;\n+                    double m;\n+                    if (n % 2 == 0) { // even\n+                        m = n / 2.0;\n+                        ret = (m * (b - m) * x) /\n+                            ((a + (2 * m) - 1) * (a + (2 * m)));\n+                    } else {\n+                        m = (n - 1.0) / 2.0;\n+                        ret = -((a + m) * (a + b + m) * x) /\n+                                ((a + (2 * m)) * (a + (2 * m) + 1.0));\n+                    }\n+                    return ret;\n+                }\n+\n+                @Override\n+                protected double getA(int n, double x) {\n+                    return 1.0;\n+                }\n+            };\n+            ret = Math.exp((a * Math.log(x)) + (b * Math.log(1.0 - x)) -\n+                Math.log(a) - logBeta(a, b, epsilon, maxIterations)) *\n+                1.0 / fraction.evaluate(x, epsilon, maxIterations);\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns the natural logarithm of the beta function B(a, b).\n+     * \n+     * @param a the a parameter.\n+     * @param b the b parameter.\n+     * @return log(B(a, b))\n+     */\n+    public static double logBeta(double a, double b) {\n+        return logBeta(a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n+    }\n+    \n+    /**\n+     * Returns the natural logarithm of the beta function B(a, b).\n+     *\n+     * The implementation of this method is based on:\n+     * <ul>\n+     * <li><a href=\"http://mathworld.wolfram.com/BetaFunction.html\">\n+     * Beta Function</a>, equation (1).</li>\n+     * </ul>\n+     * \n+     * @param a the a parameter.\n+     * @param b the b parameter.\n+     * @param epsilon When the absolute value of the nth item in the\n+     *                series is less than epsilon the approximation ceases\n+     *                to calculate further elements in the series.\n+     * @param maxIterations Maximum number of \"iterations\" to complete. \n+     * @return log(B(a, b))\n+     */\n+    public static double logBeta(double a, double b, double epsilon,\n+        int maxIterations) {\n+            \n+        double ret;\n+\n+        if (Double.isNaN(a) || Double.isNaN(b) || (a <= 0.0) || (b <= 0.0)) {\n+            ret = Double.NaN;\n+        } else {\n+            ret = Gamma.logGamma(a) + Gamma.logGamma(b) -\n+                Gamma.logGamma(a + b);\n+        }\n+\n+        return ret;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/special/Erf.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.special;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * This is a utility class that provides computation methods related to the\n+ * error functions.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class Erf {\n+\n+    /**\n+     * Default constructor.  Prohibit instantiation.\n+     */\n+    private Erf() {\n+        super();\n+    }\n+\n+    /**\n+     * Returns the error function erf(x).\n+     * \n+     * The implementation of this method is based on:\n+     * <ul>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/Erf.html\">\n+     * Erf</a>, equation (3).</li>\n+     * </ul>\n+     * \n+     * @param x the value.\n+     * @return the error function erf(x)\n+     * @throws MathException if the algorithm fails to converge.\n+     */\n+    public static double erf(double x) throws MathException {\n+        double ret = Gamma.regularizedGammaP(0.5, x * x, 1.0e-15, 10000);\n+        if (x < 0) {\n+            ret = -ret;\n+        }\n+        return ret;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/special/Gamma.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.special;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.util.ContinuedFraction;\n+\n+/**\n+ * This is a utility class that provides computation methods related to the\n+ * Gamma family of functions.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class Gamma {\n+    \n+    /** \n+     * <a href=\"http://en.wikipedia.org/wiki/Euler-Mascheroni_constant\">Euler-Mascheroni constant</a>\n+     * @since 2.0\n+     */\n+    public static final double GAMMA = 0.577215664901532860606512090082;\n+\n+    /** Maximum allowed numerical error. */\n+    private static final double DEFAULT_EPSILON = 10e-15;\n+\n+    /** Lanczos coefficients */\n+    private static final double[] lanczos =\n+    {\n+        0.99999999999999709182,\n+        57.156235665862923517,\n+        -59.597960355475491248,\n+        14.136097974741747174,\n+        -0.49191381609762019978,\n+        .33994649984811888699e-4,\n+        .46523628927048575665e-4,\n+        -.98374475304879564677e-4,\n+        .15808870322491248884e-3,\n+        -.21026444172410488319e-3,\n+        .21743961811521264320e-3,\n+        -.16431810653676389022e-3,\n+        .84418223983852743293e-4,\n+        -.26190838401581408670e-4,\n+        .36899182659531622704e-5,\n+    };\n+\n+    /** Avoid repeated computation of log of 2 PI in logGamma */\n+    private static final double HALF_LOG_2_PI = 0.5 * Math.log(2.0 * Math.PI);\n+\n+\n+    /**\n+     * Default constructor.  Prohibit instantiation.\n+     */\n+    private Gamma() {\n+        super();\n+    }\n+\n+    /**\n+     * Returns the natural logarithm of the gamma function &#915;(x).\n+     *\n+     * The implementation of this method is based on:\n+     * <ul>\n+     * <li><a href=\"http://mathworld.wolfram.com/GammaFunction.html\">\n+     * Gamma Function</a>, equation (28).</li>\n+     * <li><a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\">\n+     * Lanczos Approximation</a>, equations (1) through (5).</li>\n+     * <li><a href=\"http://my.fit.edu/~gabdo/gamma.txt\">Paul Godfrey, A note on\n+     * the computation of the convergent Lanczos complex Gamma approximation\n+     * </a></li>\n+     * </ul>\n+     * \n+     * @param x the value.\n+     * @return log(&#915;(x))\n+     */\n+    public static double logGamma(double x) {\n+        double ret;\n+\n+        if (Double.isNaN(x) || (x <= 0.0)) {\n+            ret = Double.NaN;\n+        } else {\n+            double g = 607.0 / 128.0;\n+            \n+            double sum = 0.0;\n+            for (int i = lanczos.length - 1; i > 0; --i) {\n+                sum = sum + (lanczos[i] / (x + i));\n+            }\n+            sum = sum + lanczos[0];\n+\n+            double tmp = x + g + .5;\n+            ret = ((x + .5) * Math.log(tmp)) - tmp +\n+                HALF_LOG_2_PI + Math.log(sum / x);\n+        }\n+\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns the regularized gamma function P(a, x).\n+     * \n+     * @param a the a parameter.\n+     * @param x the value.\n+     * @return the regularized gamma function P(a, x)\n+     * @throws MathException if the algorithm fails to converge.\n+     */\n+    public static double regularizedGammaP(double a, double x)\n+        throws MathException\n+    {\n+        return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n+    }\n+        \n+        \n+    /**\n+     * Returns the regularized gamma function P(a, x).\n+     * \n+     * The implementation of this method is based on:\n+     * <ul>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n+     * Regularized Gamma Function</a>, equation (1).</li>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\">\n+     * Incomplete Gamma Function</a>, equation (4).</li>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html\">\n+     * Confluent Hypergeometric Function of the First Kind</a>, equation (1).\n+     * </li>\n+     * </ul>\n+     * \n+     * @param a the a parameter.\n+     * @param x the value.\n+     * @param epsilon When the absolute value of the nth item in the\n+     *                series is less than epsilon the approximation ceases\n+     *                to calculate further elements in the series.\n+     * @param maxIterations Maximum number of \"iterations\" to complete. \n+     * @return the regularized gamma function P(a, x)\n+     * @throws MathException if the algorithm fails to converge.\n+     */\n+    public static double regularizedGammaP(double a, \n+                                           double x, \n+                                           double epsilon, \n+                                           int maxIterations) \n+        throws MathException\n+    {\n+        double ret;\n+\n+        if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n+            ret = Double.NaN;\n+        } else if (x == 0.0) {\n+            ret = 0.0;\n+        } else if (a >= 1.0 && x > a) {\n+            // use regularizedGammaQ because it should converge faster in this\n+            // case.\n+            ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);\n+        } else {\n+            // calculate series\n+            double n = 0.0; // current element index\n+            double an = 1.0 / a; // n-th element in the series\n+            double sum = an; // partial sum\n+            while (Math.abs(an) > epsilon && n < maxIterations) {\n+                // compute next element in the series\n+                n = n + 1.0;\n+                an = an * (x / (a + n));\n+\n+                // update partial sum\n+                sum = sum + an;\n+            }\n+            if (n >= maxIterations) {\n+                throw new MaxIterationsExceededException(maxIterations);\n+            } else {\n+                ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;\n+            }\n+        }\n+\n+        return ret;\n+    }\n+    \n+    /**\n+     * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).\n+     * \n+     * @param a the a parameter.\n+     * @param x the value.\n+     * @return the regularized gamma function Q(a, x)\n+     * @throws MathException if the algorithm fails to converge.\n+     */\n+    public static double regularizedGammaQ(double a, double x)\n+        throws MathException\n+    {\n+        return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n+    }\n+    \n+    /**\n+     * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).\n+     * \n+     * The implementation of this method is based on:\n+     * <ul>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n+     * Regularized Gamma Function</a>, equation (1).</li>\n+     * <li>\n+     * <a href=\"    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\">\n+     * Regularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)</a></li>\n+     * </ul>\n+     * \n+     * @param a the a parameter.\n+     * @param x the value.\n+     * @param epsilon When the absolute value of the nth item in the\n+     *                series is less than epsilon the approximation ceases\n+     *                to calculate further elements in the series.\n+     * @param maxIterations Maximum number of \"iterations\" to complete. \n+     * @return the regularized gamma function P(a, x)\n+     * @throws MathException if the algorithm fails to converge.\n+     */\n+    public static double regularizedGammaQ(final double a, \n+                                           double x, \n+                                           double epsilon, \n+                                           int maxIterations) \n+        throws MathException\n+    {\n+        double ret;\n+\n+        if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n+            ret = Double.NaN;\n+        } else if (x == 0.0) {\n+            ret = 1.0;\n+        } else if (x < a || a < 1.0) {\n+            // use regularizedGammaP because it should converge faster in this\n+            // case.\n+            ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n+        } else {\n+            // create continued fraction\n+            ContinuedFraction cf = new ContinuedFraction() {\n+\n+                @Override\n+                protected double getA(int n, double x) {\n+                    return ((2.0 * n) + 1.0) - a + x;\n+                }\n+\n+                @Override\n+                protected double getB(int n, double x) {\n+                    return n * (a - n);\n+                }\n+            };\n+            \n+            ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);\n+            ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n+        }\n+\n+        return ret;\n+    }\n+\n+\n+    // limits for switching algorithm in digamma\n+    /** C limit */\n+     private static final double C_LIMIT = 49;\n+     /** S limit */\n+     private static final double S_LIMIT = 1e-5;\n+\n+    /**\n+     * <p>Computes the digamma function of x.</p>\n+     * \n+     * <p>This is an independently written implementation of the algorithm described in\n+     * Jose Bernardo, Algorithm AS 103: Psi (Digamma) Function, Applied Statistics, 1976.</p>\n+     * \n+     * <p>Some of the constants have been changed to increase accuracy at the moderate expense\n+     * of run-time.  The result should be accurate to within 10^-8 absolute tolerance for\n+     * x >= 10^-5 and within 10^-8 relative tolerance for x > 0.</p>\n+     * \n+     * <p>Performance for large negative values of x will be quite expensive (proportional to\n+     * |x|).  Accuracy for negative values of x should be about 10^-8 absolute for results\n+     * less than 10^5 and 10^-8 relative for results larger than that.</p>\n+     * \n+     * @param x  the argument\n+     * @return   digamma(x) to within 10-8 relative or absolute error whichever is smaller\n+     * @see <a href=\"http://en.wikipedia.org/wiki/Digamma_function\"> Digamma at wikipedia </a>\n+     * @see <a href=\"http://www.uv.es/~bernardo/1976AppStatist.pdf\"> Bernardo's original article </a>\n+     * @since 2.0\n+     */\n+    public static double digamma(double x) {\n+        if (x > 0 && x <= S_LIMIT) {\n+            // use method 5 from Bernardo AS103\n+            // accurate to O(x)\n+            return -GAMMA - 1 / x;\n+        }\n+\n+        if (x >= C_LIMIT) {\n+            // use method 4 (accurate to O(1/x^8)\n+            double inv = 1 / (x * x);\n+            //            1       1        1         1\n+            // log(x) -  --- - ------ + ------- - -------\n+            //           2 x   12 x^2   120 x^4   252 x^6\n+            return Math.log(x) - 0.5 / x - inv * ((1.0 / 12) + inv * (1.0 / 120 - inv / 252));\n+        }\n+\n+        return digamma(x + 1) - 1 / x;\n+    }\n+\n+    /**\n+     * <p>Computes the trigamma function of x.  This function is derived by taking the derivative of\n+     * the implementation of digamma.</p>\n+     * \n+     * @param x  the argument\n+     * @return   trigamma(x) to within 10-8 relative or absolute error whichever is smaller\n+     * @see <a href=\"http://en.wikipedia.org/wiki/Trigamma_function\"> Trigamma at wikipedia </a>\n+     * @see Gamma#digamma(double)\n+     * @since 2.0\n+     */\n+    public static double trigamma(double x) {\n+        if (x > 0 && x <= S_LIMIT) {\n+            return 1 / (x * x);\n+        }\n+\n+        if (x >= C_LIMIT) {\n+            double inv = 1 / (x * x);\n+            //  1    1      1       1       1\n+            //  - + ---- + ---- - ----- + -----\n+            //  x      2      3       5       7\n+            //      2 x    6 x    30 x    42 x\n+            return 1 / x + inv / 2 + inv / x * (1.0 / 6 - inv * (1.0 / 30 + inv / 42));\n+        }\n+\n+        return trigamma(x + 1) + 1 / (x * x);\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat;\n+\n+import java.io.Serializable;\n+import java.text.NumberFormat;\n+import java.util.Iterator;\n+import java.util.Comparator;\n+import java.util.TreeMap;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/** \n+ * Maintains a frequency distribution.\n+ * <p>\n+ * Accepts int, long, char or Comparable values.  New values added must be \n+ * comparable to those that have been added, otherwise the add method will \n+ * throw an IllegalArgumentException.</p>\n+ * <p>\n+ * Integer values (int, long, Integer, Long) are not distinguished by type -- \n+ * i.e. <code>addValue(Long.valueOf(2)), addValue(2), addValue(2l)</code> all have\n+ * the same effect (similarly for arguments to <code>getCount,</code> etc.).</p>\n+ * <p>\n+ * char values are converted by <code>addValue</code> to Character instances.\n+ * As such, these values are not comparable to integral values, so attempts\n+ * to combine integral types with chars in a frequency distribution will fail.\n+ * </p>\n+ * <p>\n+ * The values are ordered using the default (natural order), unless a  \n+ * <code>Comparator</code> is supplied in the constructor.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class Frequency implements Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -3845586908418844111L;\n+\n+    /** underlying collection */\n+    private final TreeMap<Comparable<?>, Long> freqTable;\n+\n+    /**\n+     * Default constructor.\n+     */\n+    public Frequency() {\n+        freqTable = new TreeMap<Comparable<?>, Long>();\n+    }\n+    \n+    /**\n+     * Constructor allowing values Comparator to be specified.\n+     * \n+     * @param comparator Comparator used to order values\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    public Frequency(Comparator<?> comparator) {\n+        freqTable = new TreeMap<Comparable<?>, Long>((Comparator<? super Comparable<?>>) comparator);\n+    }\n+\n+    /**\n+     * Return a string representation of this frequency\n+     * distribution.\n+     * \n+     * @return a string representation.\n+     */\n+    @Override\n+    public String toString() {\n+        NumberFormat nf = NumberFormat.getPercentInstance();\n+        StringBuffer outBuffer = new StringBuffer();\n+        outBuffer.append(\"Value \\t Freq. \\t Pct. \\t Cum Pct. \\n\");\n+        Iterator<Comparable<?>> iter = freqTable.keySet().iterator();\n+        while (iter.hasNext()) {\n+            Comparable<?> value = iter.next();\n+            outBuffer.append(value);\n+            outBuffer.append('\\t');\n+            outBuffer.append(getCount(value));\n+            outBuffer.append('\\t');\n+            outBuffer.append(nf.format(getPct(value)));\n+            outBuffer.append('\\t');\n+            outBuffer.append(nf.format(getCumPct(value)));\n+            outBuffer.append('\\n');\n+        }\n+        return outBuffer.toString();\n+    }\n+\n+    /**\n+     * Adds 1 to the frequency count for v.\n+     * <p>\n+     * If other objects have already been added to this Frequency, v must\n+     * be comparable to those that have already been added.\n+     * </p>\n+     * \n+     * @param v the value to add.\n+     * @throws IllegalArgumentException if <code>v</code> is not Comparable, \n+     *         or is not comparable with previous entries\n+     * @deprecated use {@link #addValue(Comparable)} instead\n+     */\n+    @Deprecated\n+    public void addValue(Object v) {\n+        if (v instanceof Comparable<?>){\n+            addValue((Comparable<?>) v);            \n+        } else {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"class ({0}) does not implement Comparable\",\n+                  v.getClass().getName());\n+        }\n+    }\n+    \n+    /**\n+     * Adds 1 to the frequency count for v.\n+     * <p>\n+     * If other objects have already been added to this Frequency, v must\n+     * be comparable to those that have already been added.\n+     * </p>\n+     * \n+     * @param v the value to add.\n+     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n+     */\n+    public void addValue(Comparable<?> v){\n+        Comparable<?> obj = v;\n+        if (v instanceof Integer) {\n+           obj = Long.valueOf(((Integer) v).longValue());\n+        }\n+        try {\n+            Long count = freqTable.get(obj);\n+            if (count == null) {\n+                freqTable.put(obj, Long.valueOf(1));\n+            } else {\n+                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n+            }\n+        } catch (ClassCastException ex) {   \n+            //TreeMap will throw ClassCastException if v is not comparable\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"instance of class {0} not comparable to existing values\",\n+                  v.getClass().getName());\n+        }\n+    }\n+\n+    /**\n+     * Adds 1 to the frequency count for v.\n+     * \n+     * @param v the value to add.\n+     */\n+    public void addValue(int v) {\n+        addValue(Long.valueOf(v));\n+    }\n+    \n+    /**\n+     * Adds 1 to the frequency count for v.\n+     * \n+     * @param v the value to add.\n+     */\n+    public void addValue(Integer v) {\n+        addValue(Long.valueOf(v.longValue()));\n+    }\n+\n+    /**\n+     * Adds 1 to the frequency count for v.\n+     * \n+     * @param v the value to add.\n+     */\n+    public void addValue(long v) {\n+        addValue(Long.valueOf(v));\n+    }\n+    \n+    /**\n+     * Adds 1 to the frequency count for v.\n+     * \n+     * @param v the value to add.\n+     */\n+    public void addValue(char v) {\n+        addValue(Character.valueOf(v));\n+    }\n+    \n+    /** Clears the frequency table */\n+    public void clear() {\n+        freqTable.clear();\n+    }\n+    \n+    /**\n+     * Returns an Iterator over the set of values that have been added.\n+     * <p>\n+     * If added values are integral (i.e., integers, longs, Integers, or Longs), \n+     * they are converted to Longs when they are added, so the objects returned\n+     * by the Iterator will in this case be Longs.</p>\n+     * \n+     * @return values Iterator\n+     */\n+    public Iterator<Comparable<?>> valuesIterator() {\n+        return freqTable.keySet().iterator();\n+    }\n+    \n+    //-------------------------------------------------------------------------\n+    \n+    /**\n+     * Returns the sum of all frequencies.\n+     * \n+     * @return the total frequency count.\n+     */\n+    public long getSumFreq() {\n+        long result = 0;\n+        Iterator<Long> iterator = freqTable.values().iterator();\n+        while (iterator.hasNext())  {\n+            result += iterator.next().longValue();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns the number of values = v.\n+     * Returns 0 if the value is not comparable.\n+     * \n+     * @param v the value to lookup.\n+     * @return the frequency of v.\n+     * @deprecated replaced by {@link #getCount(Comparable)} as of 2.0\n+     */\n+    @Deprecated\n+    public long getCount(Object v) {\n+        return getCount((Comparable<?>) v);\n+    }\n+\n+    /**\n+     * Returns the number of values = v.\n+     * Returns 0 if the value is not comparable.\n+     * \n+     * @param v the value to lookup.\n+     * @return the frequency of v.\n+     */\n+    public long getCount(Comparable<?> v) {\n+        if (v instanceof Integer) {\n+            return getCount(((Integer) v).longValue());\n+        }\n+        long result = 0;\n+        try { \n+            Long count =  freqTable.get(v);\n+            if (count != null) {\n+                result = count.longValue();\n+            }\n+        } catch (ClassCastException ex) {\n+            // ignore and return 0 -- ClassCastException will be thrown if value is not comparable\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns the number of values = v.\n+     * \n+     * @param v the value to lookup.\n+     * @return the frequency of v.\n+     */\n+    public long getCount(int v) {\n+        return getCount(Long.valueOf(v));\n+    }\n+    \n+    /**\n+     * Returns the number of values = v.\n+     * \n+     * @param v the value to lookup.\n+     * @return the frequency of v.\n+     */\n+    public long getCount(long v) {\n+        return getCount(Long.valueOf(v));\n+    }\n+    \n+    /**\n+     * Returns the number of values = v.\n+     * \n+     * @param v the value to lookup.\n+     * @return the frequency of v.\n+     */\n+    public long getCount(char v) {\n+        return getCount(Character.valueOf(v));\n+    }\n+    \n+    //-------------------------------------------------------------\n+\n+    /**\n+      * Returns the percentage of values that are equal to v\n+     * (as a proportion between 0 and 1).\n+     * <p>\n+     * Returns <code>Double.NaN</code> if no values have been added.</p>\n+     * \n+     * @param v the value to lookup\n+     * @return the proportion of values equal to v\n+     * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n+     */\n+    @Deprecated\n+    public double getPct(Object v) {\n+        return getCumPct((Comparable<?>) v);\n+    }\n+\n+    /**\n+     * Returns the percentage of values that are equal to v\n+     * (as a proportion between 0 and 1).\n+     * <p>\n+     * Returns <code>Double.NaN</code> if no values have been added.</p>\n+     * \n+     * @param v the value to lookup\n+     * @return the proportion of values equal to v\n+     */\n+    public double getPct(Comparable<?> v) {\n+        final long sumFreq = getSumFreq();\n+        if (sumFreq == 0) {\n+            return Double.NaN;\n+        }\n+        return (double) getCount(v) / (double) sumFreq;        \n+    }\n+    \n+    /**\n+     * Returns the percentage of values that are equal to v\n+     * (as a proportion between 0 and 1).\n+     * \n+     * @param v the value to lookup\n+     * @return the proportion of values equal to v\n+     */\n+    public double getPct(int v) {\n+        return getPct(Long.valueOf(v));       \n+    }\n+    \n+    /**\n+     * Returns the percentage of values that are equal to v\n+     * (as a proportion between 0 and 1).\n+     * \n+     * @param v the value to lookup\n+     * @return the proportion of values equal to v\n+     */\n+    public double getPct(long v) {\n+        return getPct(Long.valueOf(v));         \n+    }\n+    \n+    /**\n+     * Returns the percentage of values that are equal to v\n+     * (as a proportion between 0 and 1).\n+     * \n+     * @param v the value to lookup\n+     * @return the proportion of values equal to v\n+     */\n+    public double getPct(char v) {\n+        return getPct(Character.valueOf(v));         \n+    }\n+    \n+    //-----------------------------------------------------------------------------------------\n+    \n+    /**\n+     * Returns the cumulative frequency of values less than or equal to v.\n+     * <p>\n+     * Returns 0 if v is not comparable to the values set.</p>\n+     * \n+     * @param v the value to lookup.\n+     * @return the proportion of values equal to v\n+     * @deprecated replaced by {@link #getCumFreq(Comparable)} as of 2.0\n+     */\n+    @Deprecated\n+    public long getCumFreq(Object v) {\n+        return getCumFreq((Comparable<?>) v);\n+    }\n+\n+    /**\n+     * Returns the cumulative frequency of values less than or equal to v.\n+     * <p>\n+     * Returns 0 if v is not comparable to the values set.</p>\n+     * \n+     * @param v the value to lookup.\n+     * @return the proportion of values equal to v\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+        public long getCumFreq(Comparable<?> v) {\n+        if (getSumFreq() == 0) {\n+            return 0;\n+        }\n+        if (v instanceof Integer) {\n+            return getCumFreq(((Integer) v).longValue());\n+        }\n+        Comparator<Comparable<?>> c = (Comparator<Comparable<?>>) freqTable.comparator();\n+        if (c == null) {\n+            c = new NaturalComparator();\n+        }\n+        long result = 0;\n+        \n+        try {\n+            Long value = freqTable.get(v);\n+            if (value != null) {\n+                result = value.longValue();\n+            }\n+        } catch (ClassCastException ex) {\n+            return result;   // v is not comparable\n+        }\n+\n+        if (c.compare(v, freqTable.firstKey()) < 0) {\n+            return 0;  // v is comparable, but less than first value\n+        }\n+        \n+        if (c.compare(v, freqTable.lastKey()) >= 0) {\n+            return getSumFreq();    // v is comparable, but greater than the last value\n+        }\n+        \n+        Iterator<Comparable<?>> values = valuesIterator();\n+        while (values.hasNext()) {\n+            Comparable<?> nextValue = values.next();\n+            if (c.compare(v, nextValue) > 0) {\n+                result += getCount(nextValue);\n+            } else {\n+                return result;\n+            }\n+        }\n+        return result;\n+    }\n+    \n+     /**\n+     * Returns the cumulative frequency of values less than or equal to v.\n+     * <p>\n+     * Returns 0 if v is not comparable to the values set.</p>\n+     * \n+     * @param v the value to lookup\n+     * @return the proportion of values equal to v\n+     */\n+    public long getCumFreq(int v) {\n+        return getCumFreq(Long.valueOf(v));       \n+    }\n+    \n+     /**\n+     * Returns the cumulative frequency of values less than or equal to v.\n+     * <p>\n+     * Returns 0 if v is not comparable to the values set.</p>\n+     * \n+     * @param v the value to lookup\n+     * @return the proportion of values equal to v\n+     */\n+    public long getCumFreq(long v) {\n+        return getCumFreq(Long.valueOf(v));         \n+    }\n+    \n+    /**\n+     * Returns the cumulative frequency of values less than or equal to v.\n+     * <p>\n+     * Returns 0 if v is not comparable to the values set.</p>\n+     * \n+     * @param v the value to lookup\n+     * @return the proportion of values equal to v\n+     */\n+    public long getCumFreq(char v) {\n+        return getCumFreq(Character.valueOf(v));         \n+    }\n+    \n+    //----------------------------------------------------------------------------------------------\n+    \n+    /**\n+     * Returns the cumulative percentage of values less than or equal to v\n+     * (as a proportion between 0 and 1).\n+     * <p>\n+     * Returns <code>Double.NaN</code> if no values have been added.\n+     * Returns 0 if at least one value has been added, but v is not comparable\n+     * to the values set.</p>\n+     * \n+     * @param v the value to lookup\n+     * @return the proportion of values less than or equal to v\n+     * @deprecated replaced by {@link #getCumPct(Comparable)} as of 2.0\n+     */\n+    @Deprecated\n+    public double getCumPct(Object v) {\n+        return getCumPct((Comparable<?>) v);\n+        \n+    }\n+\n+    /**\n+     * Returns the cumulative percentage of values less than or equal to v\n+     * (as a proportion between 0 and 1).\n+     * <p>\n+     * Returns <code>Double.NaN</code> if no values have been added.\n+     * Returns 0 if at least one value has been added, but v is not comparable\n+     * to the values set.</p>\n+     * \n+     * @param v the value to lookup\n+     * @return the proportion of values less than or equal to v\n+     */\n+    public double getCumPct(Comparable<?> v) {\n+        final long sumFreq = getSumFreq();\n+        if (sumFreq == 0) {\n+            return Double.NaN;\n+        }\n+        return (double) getCumFreq(v) / (double) sumFreq;        \n+    }\n+    \n+    /**\n+     * Returns the cumulative percentage of values less than or equal to v\n+     * (as a proportion between 0 and 1).\n+     * <p>\n+     * Returns 0 if v is not comparable to the values set.</p>\n+     * \n+     * @param v the value to lookup\n+     * @return the proportion of values less than or equal to v\n+     */\n+    public double getCumPct(int v) {\n+        return getCumPct(Long.valueOf(v));       \n+    }\n+    \n+    /**\n+     * Returns the cumulative percentage of values less than or equal to v\n+     * (as a proportion between 0 and 1).\n+     * <p>\n+     * Returns 0 if v is not comparable to the values set.</p>\n+     * \n+     * @param v the value to lookup\n+     * @return the proportion of values less than or equal to v\n+     */\n+    public double getCumPct(long v) {\n+        return getCumPct(Long.valueOf(v));         \n+    }\n+    \n+    /**\n+     * Returns the cumulative percentage of values less than or equal to v\n+     * (as a proportion between 0 and 1).\n+     * <p>\n+     * Returns 0 if v is not comparable to the values set.</p>\n+     * \n+     * @param v the value to lookup\n+     * @return the proportion of values less than or equal to v\n+     */\n+    public double getCumPct(char v) {\n+        return getCumPct(Character.valueOf(v));         \n+    }\n+    \n+    /**\n+     * A Comparator that compares comparable objects using the\n+     * natural order.  Copied from Commons Collections ComparableComparator.\n+     */\n+    private static class NaturalComparator<T extends Comparable<T>> implements Comparator<Comparable<T>>, Serializable {\n+\n+        /** Serializable version identifier */\n+        private static final long serialVersionUID = -3852193713161395148L;\n+\n+        /**\n+         * Compare the two {@link Comparable Comparable} arguments.\n+         * This method is equivalent to:\n+         * <pre>(({@link Comparable Comparable})o1).{@link Comparable#compareTo compareTo}(o2)</pre>\n+         * \n+         * @param  o1 the first object \n+         * @param  o2 the second object\n+         * @return  result of comparison\n+         * @throws NullPointerException when <i>o1</i> is <code>null</code>, \n+         *         or when <code>((Comparable)o1).compareTo(o2)</code> does\n+         * @throws ClassCastException when <i>o1</i> is not a {@link Comparable Comparable}, \n+         *         or when <code>((Comparable)o1).compareTo(o2)</code> does\n+         */\n+        @SuppressWarnings(\"unchecked\")\n+        public int compare(Comparable<T> o1, Comparable<T> o2) {\n+            return (o1.compareTo((T) o2));\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result +\n+                 ((freqTable == null) ? 0 : freqTable.hashCode());\n+        return result;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (!(obj instanceof Frequency))\n+            return false;\n+        Frequency other = (Frequency) obj;\n+        if (freqTable == null) {\n+            if (other.freqTable != null)\n+                return false;\n+        } else if (!freqTable.equals(other.freqTable))\n+            return false;\n+        return true;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/StatUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.moment.GeometricMean;\n+import org.apache.commons.math.stat.descriptive.moment.Mean;\n+import org.apache.commons.math.stat.descriptive.moment.Variance;\n+import org.apache.commons.math.stat.descriptive.rank.Max;\n+import org.apache.commons.math.stat.descriptive.rank.Min;\n+import org.apache.commons.math.stat.descriptive.rank.Percentile;\n+import org.apache.commons.math.stat.descriptive.summary.Product;\n+import org.apache.commons.math.stat.descriptive.summary.Sum;\n+import org.apache.commons.math.stat.descriptive.summary.SumOfLogs;\n+import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n+\n+/**\n+ * StatUtils provides static methods for computing statistics based on data\n+ * stored in double[] arrays. \n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public final class StatUtils {\n+\n+    /** sum */\n+    private static final UnivariateStatistic sum = new Sum();\n+\n+    /** sumSq */\n+    private static final UnivariateStatistic sumSq = new SumOfSquares();\n+\n+    /** prod */\n+    private static final UnivariateStatistic prod = new Product();\n+\n+    /** sumLog */\n+    private static final UnivariateStatistic sumLog = new SumOfLogs();\n+\n+    /** min */\n+    private static final UnivariateStatistic min = new Min();\n+\n+    /** max */\n+    private static final UnivariateStatistic max = new Max();\n+\n+    /** mean */\n+    private static final UnivariateStatistic mean = new Mean();\n+\n+    /** variance */\n+    private static final Variance variance = new Variance();\n+\n+    /** percentile */\n+    private static final Percentile percentile = new Percentile();\n+    \n+    /** geometric mean */\n+    private static final GeometricMean geometricMean = new GeometricMean();\n+\n+    /**\n+     * Private Constructor\n+     */\n+    private StatUtils() {\n+    }\n+\n+    /**\n+     * Returns the sum of the values in the input array, or\n+     * <code>Double.NaN</code> if the array is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the input array\n+     * is null.</p>\n+     * \n+     * @param values  array of values to sum\n+     * @return the sum of the values or <code>Double.NaN</code> if the array\n+     * is empty\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public static double sum(final double[] values) {\n+        return sum.evaluate(values);\n+    }\n+\n+    /**\n+     * Returns the sum of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the sum of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    public static double sum(final double[] values, final int begin, \n+            final int length) {\n+        return sum.evaluate(values, begin, length);\n+    }\n+\n+    /**\n+     * Returns the sum of the squares of the entries in the input array, or \n+     * <code>Double.NaN</code> if the array is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * \n+     * @param values  input array\n+     * @return the sum of the squared values or <code>Double.NaN</code> if the\n+     * array is empty\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public static double sumSq(final double[] values) {\n+        return sumSq.evaluate(values);\n+    }\n+\n+    /**\n+     * Returns the sum of the squares of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the sum of the squares of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     * parameters are not valid\n+     */\n+    public static double sumSq(final double[] values, final int begin,\n+            final int length) {\n+        return sumSq.evaluate(values, begin, length);\n+    }\n+\n+    /**\n+     * Returns the product of the entries in the input array, or \n+     * <code>Double.NaN</code> if the array is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * \n+     * @param values the input array\n+     * @return the product of the values or Double.NaN if the array is empty\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public static double product(final double[] values) {\n+        return prod.evaluate(values);\n+    }\n+\n+    /**\n+     * Returns the product of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the product of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     * parameters are not valid\n+     */\n+    public static double product(final double[] values, final int begin,\n+            final int length) {\n+        return prod.evaluate(values, begin, length);\n+    }\n+\n+    /**\n+     * Returns the sum of the natural logs of the entries in the input array, or \n+     * <code>Double.NaN</code> if the array is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * <p>\n+     * See {@link org.apache.commons.math.stat.descriptive.summary.SumOfLogs}.\n+     * </p>\n+     * \n+     * @param values the input array\n+     * @return the sum of the natural logs of the values or Double.NaN if \n+     * the array is empty\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public static double sumLog(final double[] values) {\n+        return sumLog.evaluate(values);\n+    }\n+\n+    /**\n+     * Returns the sum of the natural logs of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * <p>\n+     * See {@link org.apache.commons.math.stat.descriptive.summary.SumOfLogs}.\n+     * </p>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the sum of the natural logs of the values or Double.NaN if \n+     * length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     * parameters are not valid\n+     */\n+    public static double sumLog(final double[] values, final int begin,\n+            final int length) {\n+        return sumLog.evaluate(values, begin, length);\n+    }\n+\n+    /**\n+     * Returns the arithmetic mean of the entries in the input array, or \n+     * <code>Double.NaN</code> if the array is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * <p>\n+     * See {@link org.apache.commons.math.stat.descriptive.moment.Mean} for\n+     * details on the computing algorithm.</p>\n+     * \n+     * @param values the input array\n+     * @return the mean of the values or Double.NaN if the array is empty\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public static double mean(final double[] values) {\n+        return mean.evaluate(values);\n+    }\n+\n+    /**\n+     * Returns the arithmetic mean of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * <p>\n+     * See {@link org.apache.commons.math.stat.descriptive.moment.Mean} for\n+     * details on the computing algorithm.</p>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the mean of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     * parameters are not valid\n+     */\n+    public static double mean(final double[] values, final int begin,\n+            final int length) {\n+        return mean.evaluate(values, begin, length);\n+    }\n+    \n+    /**\n+     * Returns the geometric mean of the entries in the input array, or \n+     * <code>Double.NaN</code> if the array is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * <p>\n+     * See {@link org.apache.commons.math.stat.descriptive.moment.GeometricMean}\n+     * for details on the computing algorithm.</p>\n+     * \n+     * @param values the input array\n+     * @return the geometric mean of the values or Double.NaN if the array is empty\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public static double geometricMean(final double[] values) {\n+        return geometricMean.evaluate(values);\n+    }\n+\n+    /**\n+     * Returns the geometric mean of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * <p>\n+     * See {@link org.apache.commons.math.stat.descriptive.moment.GeometricMean}\n+     * for details on the computing algorithm.</p>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the geometric mean of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     * parameters are not valid\n+     */\n+    public static double geometricMean(final double[] values, final int begin,\n+            final int length) {\n+        return geometricMean.evaluate(values, begin, length);\n+    }\n+    \n+\n+    /**\n+     * Returns the variance of the entries in the input array, or \n+     * <code>Double.NaN</code> if the array is empty.\n+     * <p>\n+     * See {@link org.apache.commons.math.stat.descriptive.moment.Variance} for\n+     * details on the computing algorithm.</p>\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * \n+     * @param values the input array\n+     * @return the variance of the values or Double.NaN if the array is empty\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public static double variance(final double[] values) {\n+        return variance.evaluate(values);\n+    }\n+\n+    /**\n+     * Returns the variance of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * See {@link org.apache.commons.math.stat.descriptive.moment.Variance} for\n+     * details on the computing algorithm.</p>\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null or the\n+     * array index parameters are not valid.</p>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the variance of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    public static double variance(final double[] values, final int begin,\n+            final int length) {\n+        return variance.evaluate(values, begin, length);\n+    }\n+    \n+    /**\n+     * Returns the variance of the entries in the specified portion of\n+     * the input array, using the precomputed mean value.  Returns \n+     * <code>Double.NaN</code> if the designated subarray is empty.\n+     * <p>\n+     * See {@link org.apache.commons.math.stat.descriptive.moment.Variance} for\n+     * details on the computing algorithm.</p>\n+     * <p>\n+     * The formula used assumes that the supplied mean value is the arithmetic\n+     * mean of the sample data, not a known population parameter.  This method\n+     * is supplied only to save computation when the mean has already been\n+     * computed.</p>\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null or the\n+     * array index parameters are not valid.</p>\n+     * \n+     * @param values the input array\n+     * @param mean the precomputed mean value\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the variance of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    public static double variance(final double[] values, final double mean, \n+            final int begin, final int length) {\n+        return variance.evaluate(values, mean, begin, length);    \n+    }\n+    \n+    /**\n+     * Returns the variance of the entries in the input array, using the\n+     * precomputed mean value.  Returns <code>Double.NaN</code> if the array\n+     * is empty.  \n+     * <p>\n+     * See {@link org.apache.commons.math.stat.descriptive.moment.Variance} for\n+     * details on the computing algorithm.</p>  \n+     * <p>\n+     * The formula used assumes that the supplied mean value is the arithmetic\n+     * mean of the sample data, not a known population parameter.  This method\n+     * is supplied only to save computation when the mean has already been\n+     * computed.</p>\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * \n+     * @param values the input array\n+     * @param mean the precomputed mean value\n+     * @return the variance of the values or Double.NaN if the array is empty\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public static double variance(final double[] values, final double mean) {\n+        return variance.evaluate(values, mean);    \n+    }\n+\n+    /**\n+     * Returns the maximum of the entries in the input array, or \n+     * <code>Double.NaN</code> if the array is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * <p>\n+     * <ul>\n+     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+     * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n+     * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>, \n+     * the result is <code>Double.POSITIVE_INFINITY.</code></li>\n+     * </ul></p>\n+     * \n+     * @param values the input array\n+     * @return the maximum of the values or Double.NaN if the array is empty\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public static double max(final double[] values) {\n+        return max.evaluate(values);\n+    }\n+\n+    /**\n+     * Returns the maximum of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null or\n+     * the array index parameters are not valid.</p>\n+     * <p>\n+     * <ul>\n+     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+     * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n+     * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>, \n+     * the result is <code>Double.POSITIVE_INFINITY.</code></li>\n+     * </ul></p>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the maximum of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     * parameters are not valid\n+     */\n+    public static double max(final double[] values, final int begin,\n+            final int length) {\n+        return max.evaluate(values, begin, length);\n+    }\n+\n+     /**\n+     * Returns the minimum of the entries in the input array, or \n+     * <code>Double.NaN</code> if the array is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * <p>\n+     * <ul>\n+     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+     * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n+     * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>, \n+     * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n+     * </ul> </p>\n+     * \n+     * @param values the input array\n+     * @return the minimum of the values or Double.NaN if the array is empty\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public static double min(final double[] values) {\n+        return min.evaluate(values);\n+    }\n+\n+     /**\n+     * Returns the minimum of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null or\n+     * the array index parameters are not valid.</p>\n+     * <p>\n+     * <ul>\n+     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+     * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n+     * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>, \n+     * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n+     * </ul></p>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the minimum of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     * parameters are not valid\n+     */\n+    public static double min(final double[] values, final int begin,\n+            final int length) {\n+        return min.evaluate(values, begin, length);\n+    }\n+    \n+    /**\n+     * Returns an estimate of the <code>p</code>th percentile of the values\n+     * in the <code>values</code> array.\n+     * <p>\n+     * <ul>\n+     * <li>Returns <code>Double.NaN</code> if <code>values</code> has length \n+     * <code>0</code></li></p>\n+     * <li>Returns (for any value of <code>p</code>) <code>values[0]</code>\n+     *  if <code>values</code> has length <code>1</code></li>\n+     * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n+     * is null  or p is not a valid quantile value (p must be greater than 0\n+     * and less than or equal to 100)</li>\n+     * </ul></p>\n+     * <p>\n+     * See {@link org.apache.commons.math.stat.descriptive.rank.Percentile} for\n+     * a description of the percentile estimation algorithm used.</p>\n+     * \n+     * @param values input array of values\n+     * @param p the percentile value to compute\n+     * @return the percentile value or Double.NaN if the array is empty\n+     * @throws IllegalArgumentException if <code>values</code> is null \n+     * or p is invalid\n+     */\n+    public static double percentile(final double[] values, final double p) {\n+            return percentile.evaluate(values,p);\n+    }\n+\n+     /**\n+     * Returns an estimate of the <code>p</code>th percentile of the values\n+     * in the <code>values</code> array, starting with the element in (0-based)\n+     * position <code>begin</code> in the array and including <code>length</code>\n+     * values.\n+     * <p>\n+     * <ul>\n+     * <li>Returns <code>Double.NaN</code> if <code>length = 0</code></li>\n+     * <li>Returns (for any value of <code>p</code>) <code>values[begin]</code>\n+     *  if <code>length = 1 </code></li>\n+     * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n+     *  is null , <code>begin</code> or <code>length</code> is invalid, or \n+     * <code>p</code> is not a valid quantile value (p must be greater than 0\n+     * and less than or equal to 100)</li>\n+     * </ul></p>\n+     * <p>\n+      * See {@link org.apache.commons.math.stat.descriptive.rank.Percentile} for\n+      * a description of the percentile estimation algorithm used.</p>\n+     * \n+     * @param values array of input values\n+     * @param p  the percentile to compute\n+     * @param begin  the first (0-based) element to include in the computation\n+     * @param length  the number of array elements to include\n+     * @return  the percentile value\n+     * @throws IllegalArgumentException if the parameters are not valid or the\n+     * input array is null\n+     */\n+    public static double percentile(final double[] values, final int begin, \n+            final int length, final double p) {\n+        return percentile.evaluate(values, begin, length, p);\n+    }   \n+    \n+    /**\n+     * Returns the sum of the (signed) differences between corresponding elements of the\n+     * input arrays -- i.e., sum(sample1[i] - sample2[i]).\n+     * \n+     * @param sample1  the first array\n+     * @param sample2  the second array\n+     * @return sum of paired differences\n+     * @throws IllegalArgumentException if the arrays do not have the same\n+     * (positive) length\n+     */\n+    public static double sumDifference(final double[] sample1, final double[] sample2)\n+        throws IllegalArgumentException {\n+        int n = sample1.length;\n+        if ((n  != sample2.length) || (n < 1)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"input arrays must have the same positive length ({0} and {1})\",\n+                  n, sample2.length);\n+        }\n+        double result = 0;\n+        for (int i = 0; i < n; i++) {\n+            result += sample1[i] - sample2[i];\n+        }\n+        return result;\n+    }\n+    \n+    /**\n+     * Returns the mean of the (signed) differences between corresponding elements of the\n+     * input arrays -- i.e., sum(sample1[i] - sample2[i]) / sample1.length.\n+     * \n+     * @param sample1  the first array\n+     * @param sample2  the second array\n+     * @return mean of paired differences\n+     * @throws IllegalArgumentException if the arrays do not have the same\n+     * (positive) length\n+     */\n+    public static double meanDifference(final double[] sample1, final double[] sample2)\n+    throws IllegalArgumentException {\n+        return sumDifference(sample1, sample2) / sample1.length;\n+    }\n+    \n+    /**\n+     * Returns the variance of the (signed) differences between corresponding elements of the\n+     * input arrays -- i.e., var(sample1[i] - sample2[i]).\n+     * \n+     * @param sample1  the first array\n+     * @param sample2  the second array\n+     * @param meanDifference   the mean difference between corresponding entries \n+     * @see #meanDifference(double[],double[])\n+     * @return variance of paired differences\n+     * @throws IllegalArgumentException if the arrays do not have the same\n+     * length or their common length is less than 2.\n+     */\n+    public static double varianceDifference(final double[] sample1, final double[] sample2, \n+            double meanDifference)  throws IllegalArgumentException {\n+        double sum1 = 0d;\n+        double sum2 = 0d;\n+        double diff = 0d;\n+        int n = sample1.length;\n+        if (n < 2 || n != sample2.length) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"input arrays must have the same length and at least two elements ({0} and {1})\",\n+                  n, sample2.length);\n+        }\n+        for (int i = 0; i < n; i++) {\n+            diff = sample1[i] - sample2[i];\n+            sum1 += (diff - meanDifference) *(diff - meanDifference);\n+            sum2 += diff - meanDifference;\n+        }\n+        return (sum1 - (sum2 * sum2 / n)) / (n - 1);\n+    }      \n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/Cluster.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.clustering;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Cluster holding a set of {@link Clusterable} points.\n+ * @param <T> the type of points that can be clustered\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class Cluster<T extends Clusterable<T>> implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -3442297081515880464L;\n+\n+    /** The points contained in this cluster. */\n+    private final List<T> points;\n+\n+    /** Center of the cluster. */\n+    private final T center;\n+\n+    /**\n+     * Build a cluster centered at a specified point.\n+     * @param center the point which is to be the center of this cluster\n+     */\n+    public Cluster(final T center) {\n+        this.center = center;\n+        points = new ArrayList<T>();\n+    }\n+\n+    /**\n+     * Add a point to this cluster.\n+     * @param point point to add\n+     */\n+    public void addPoint(final T point) {\n+        points.add(point);\n+    }\n+\n+    /**\n+     * Get the points contained in the cluster.\n+     * @return points contained in the cluster\n+     */\n+    public List<T> getPoints() {\n+        return points;\n+    }\n+\n+    /**\n+     * Get the point chosen to be the center of this cluster.\n+     * @return chosen cluster center\n+     */\n+    public T getCenter() {\n+        return center;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/Clusterable.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.clustering;\n+\n+import java.util.Collection;\n+\n+/**\n+ * Interface for points that can be clustered together.\n+ * @param <T> the type of point that can be clustered\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface Clusterable<T> {\n+\n+    /**\n+     * Returns the distance from the given point.\n+     * \n+     * @param p the point to compute the distance from\n+     * @return the distance from the given point\n+     */\n+    double distanceFrom(T p);\n+\n+    /**\n+     * Returns the centroid of the given Collection of points.\n+     * \n+     * @param p the Collection of points to compute the centroid of\n+     * @return the centroid of the given Collection of Points\n+     */\n+    T centroidOf(Collection<T> p);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.clustering;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * A simple implementation of {@link Clusterable} for points with integer coordinates.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class EuclideanIntegerPoint implements Clusterable<EuclideanIntegerPoint>, Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 3946024775784901369L;\n+\n+    /** Point coordinates. */\n+    private final int[] point;\n+\n+    /**\n+     * Build an instance wrapping an integer array.\n+     * <p>The wrapped array is referenced, it is <em>not</em> copied.</p>\n+     * @param point the n-dimensional point in integer space\n+     */\n+    public EuclideanIntegerPoint(final int[] point) {\n+        this.point = point;\n+    }\n+\n+    /**\n+     * Get the n-dimensional point in integer space.\n+     * @return a reference (not a copy!) to the wrapped array\n+     */\n+    public int[] getPoint() {\n+        return point;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double distanceFrom(final EuclideanIntegerPoint p) {\n+        return MathUtils.distance(point, p.getPoint());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public EuclideanIntegerPoint centroidOf(final Collection<EuclideanIntegerPoint> points) {\n+        int[] centroid = new int[getPoint().length];\n+        for (EuclideanIntegerPoint p : points) {\n+            for (int i = 0; i < centroid.length; i++) {\n+                centroid[i] += p.getPoint()[i];\n+            }\n+        }\n+        for (int i = 0; i < centroid.length; i++) {\n+            centroid[i] /= points.size();\n+        }\n+        return new EuclideanIntegerPoint(centroid);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean equals(final Object other) {\n+        if (!(other instanceof EuclideanIntegerPoint)) {\n+            return false;\n+        }\n+        final int[] otherPoint = ((EuclideanIntegerPoint) other).getPoint();\n+        if (point.length != otherPoint.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < point.length; i++) {\n+            if (point[i] != otherPoint[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int hashCode() {\n+        int hashCode = 0;\n+        for (Integer i : point) {\n+            hashCode += i.hashCode() * 13 + 7;\n+        }\n+        return hashCode;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.clustering;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Random;\n+\n+/**\n+ * Clustering algorithm based on David Arthur and Sergei Vassilvitski k-means++ algorithm.\n+ * @param <T> type of the points to cluster\n+ * @see <a href=\"http://en.wikipedia.org/wiki/K-means%2B%2B\">K-means++ (wikipedia)</a>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {\n+\n+    /** Random generator for choosing initial centers. */\n+    private final Random random;\n+\n+    /** Build a clusterer.\n+     * @param random random generator to use for choosing initial centers\n+     */\n+    public KMeansPlusPlusClusterer(final Random random) {\n+        this.random = random;\n+    }\n+\n+    /**\n+     * Runs the K-means++ clustering algorithm.\n+     * \n+     * @param points the points to cluster\n+     * @param k the number of clusters to split the data into\n+     * @param maxIterations the maximum number of iterations to run the algorithm\n+     *     for.  If negative, no maximum will be used\n+     * @return a list of clusters containing the points\n+     */\n+    public List<Cluster<T>> cluster(final Collection<T> points,\n+                                    final int k, final int maxIterations) {\n+        // create the initial clusters\n+        List<Cluster<T>> clusters = chooseInitialCenters(points, k, random);\n+        assignPointsToClusters(clusters, points);\n+\n+        // iterate through updating the centers until we're done\n+        final int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations; \n+        for (int count = 0; count < max; count++) {\n+            boolean clusteringChanged = false;\n+            List<Cluster<T>> newClusters = new ArrayList<Cluster<T>>();\n+            for (final Cluster<T> cluster : clusters) {\n+                final T newCenter = cluster.getCenter().centroidOf(cluster.getPoints());\n+                if (!newCenter.equals(cluster.getCenter())) {\n+                    clusteringChanged = true;\n+                }\n+                newClusters.add(new Cluster<T>(newCenter));\n+            }\n+            if (!clusteringChanged) {\n+                return clusters;\n+            }\n+            assignPointsToClusters(newClusters, points);\n+            clusters = newClusters;\n+        }\n+        return clusters;\n+    }\n+\n+    /**\n+     * Adds the given points to the closest {@link Cluster}.\n+     * \n+     * @param <T> type of the points to cluster\n+     * @param clusters the {@link Cluster}s to add the points to\n+     * @param points the points to add to the given {@link Cluster}s\n+     */\n+    private static <T extends Clusterable<T>> void\n+        assignPointsToClusters(final Collection<Cluster<T>> clusters, final Collection<T> points) {\n+        for (final T p : points) {\n+            Cluster<T> cluster = getNearestCluster(clusters, p);\n+            cluster.addPoint(p);\n+        }\n+    }\n+\n+    /**\n+     * Use K-means++ to choose the initial centers.\n+     * \n+     * @param <T> type of the points to cluster\n+     * @param points the points to choose the initial centers from\n+     * @param k the number of centers to choose\n+     * @param random random generator to use\n+     * @return the initial centers\n+     */\n+    private static <T extends Clusterable<T>> List<Cluster<T>>\n+        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n+\n+        final List<T> pointSet = new ArrayList<T>(points);\n+        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n+\n+        // Choose one center uniformly at random from among the data points.\n+        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n+        resultSet.add(new Cluster<T>(firstPoint));\n+\n+        final double[] dx2 = new double[pointSet.size()];\n+        while (resultSet.size() < k) {\n+            // For each data point x, compute D(x), the distance between x and \n+            // the nearest center that has already been chosen.\n+            int sum = 0;\n+            for (int i = 0; i < pointSet.size(); i++) {\n+                final T p = pointSet.get(i);\n+                final Cluster<T> nearest = getNearestCluster(resultSet, p);\n+                final double d = p.distanceFrom(nearest.getCenter());\n+                sum += d * d;\n+                dx2[i] = sum;\n+            }\n+\n+            // Add one new data point as a center. Each point x is chosen with\n+            // probability proportional to D(x)2\n+            final double r = random.nextDouble() * sum;\n+            for (int i = 0 ; i < dx2.length; i++) {\n+                if (dx2[i] >= r) {\n+                    final T p = pointSet.remove(i);\n+                    resultSet.add(new Cluster<T>(p));\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return resultSet;\n+\n+    }\n+\n+    /**\n+     * Returns the nearest {@link Cluster} to the given point\n+     * \n+     * @param <T> type of the points to cluster\n+     * @param clusters the {@link Cluster}s to search\n+     * @param point the point to find the nearest {@link Cluster} for\n+     * @return the nearest {@link Cluster} to the given point\n+     */\n+    private static <T extends Clusterable<T>> Cluster<T>\n+        getNearestCluster(final Collection<Cluster<T>> clusters, final T point) {\n+        double minDistance = Double.MAX_VALUE;\n+        Cluster<T> minCluster = null;\n+        for (final Cluster<T> c : clusters) {\n+            final double distance = point.distanceFrom(c.getCenter());\n+            if (distance < minDistance) {\n+                minDistance = distance;\n+                minCluster = c;\n+            }\n+        }\n+        return minCluster;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/Covariance.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.correlation;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n+import org.apache.commons.math.stat.descriptive.moment.Mean;\n+import org.apache.commons.math.stat.descriptive.moment.Variance;\n+\n+/**\n+ * Computes covariances for pairs of arrays or columns of a matrix.\n+ * \n+ * <p>The constructors that take <code>RealMatrix</code> or \n+ * <code>double[][]</code> arguments generate covariance matrices.  The\n+ * columns of the input matrices are assumed to represent variable values.</p>\n+ * \n+ * <p>The constructor argument <code>biasCorrected</code> determines whether or\n+ * not computed covariances are bias-corrected.</p>\n+ * \n+ * <p>Unbiased covariances are given by the formula</p>\n+ * <code>cov(X, Y) = &Sigma;[(x<sub>i</sub> - E(X))(y<sub>i</sub> - E(Y))] / (n - 1)</code>\n+ * where <code>E(X)</code> is the mean of <code>X</code> and <code>E(Y)</code>\n+ * is the mean of the <code>Y</code> values.\n+ * \n+ * <p>Non-bias-corrected estimates use <code>n</code> in place of <code>n - 1</code>\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class Covariance {\n+    \n+    /** covariance matrix */\n+    private final RealMatrix covarianceMatrix;\n+\n+    /**\n+     * Create an empty covariance matrix.\n+     */\n+    /** Number of observations (length of covariate vectors) */\n+    private final int n;\n+    \n+    /** \n+     * Create a Covariance with no data\n+     */\n+    public Covariance() {\n+        super();\n+        covarianceMatrix = null;\n+        n = 0;\n+    }\n+    \n+    /**\n+     * Create a Covariance matrix from a rectangular array\n+     * whose columns represent covariates.\n+     * \n+     * <p>The <code>biasCorrected</code> parameter determines whether or not\n+     * covariance estimates are bias-corrected.</p>\n+     * \n+     * <p>The input array must be rectangular with at least two columns\n+     * and two rows.</p>\n+     * \n+     * @param data rectangular array with columns representing covariates\n+     * @param biasCorrected true means covariances are bias-corrected\n+     * @throws IllegalArgumentException if the input data array is not\n+     * rectangular with at least two rows and two columns.\n+     */\n+    public Covariance(double[][] data, boolean biasCorrected) {\n+        this(new BlockRealMatrix(data), biasCorrected);\n+    }\n+    \n+    /**\n+     * Create a Covariance matrix from a rectangular array\n+     * whose columns represent covariates.\n+     * \n+     * <p>The input array must be rectangular with at least two columns\n+     * and two rows</p>\n+     * \n+     * @param data rectangular array with columns representing covariates\n+     * @throws IllegalArgumentException if the input data array is not\n+     * rectangular with at least two rows and two columns.\n+     */\n+    public Covariance(double[][] data) {\n+        this(data, true);\n+    }\n+    \n+    /**\n+     * Create a covariance matrix from a matrix whose columns\n+     * represent covariates.\n+     * \n+     * <p>The <code>biasCorrected</code> parameter determines whether or not\n+     * covariance estimates are bias-corrected.</p>\n+     * \n+     * <p>The matrix must have at least two columns and two rows</p>\n+     * \n+     * @param matrix matrix with columns representing covariates\n+     * @param biasCorrected true means covariances are bias-corrected\n+     * @throws IllegalArgumentException if the input matrix does not have\n+     * at least two rows and two columns\n+     */\n+    public Covariance(RealMatrix matrix, boolean biasCorrected) {\n+       checkSufficientData(matrix);\n+       n = matrix.getRowDimension();\n+       covarianceMatrix = computeCovarianceMatrix(matrix, biasCorrected);\n+    }\n+    \n+    /**\n+     * Create a covariance matrix from a matrix whose columns\n+     * represent covariates.\n+     * \n+     * <p>The matrix must have at least two columns and two rows</p>\n+     * \n+     * @param matrix matrix with columns representing covariates\n+     * @throws IllegalArgumentException if the input matrix does not have\n+     * at least two rows and two columns\n+     */\n+    public Covariance(RealMatrix matrix) {\n+        this(matrix, true);\n+    }\n+    \n+    /**\n+     * Returns the covariance matrix\n+     * \n+     * @return covariance matrix\n+     */\n+    public RealMatrix getCovarianceMatrix() {\n+        return covarianceMatrix;\n+    }\n+    \n+    /**\n+     * Returns the number of observations (length of covariate vectors)\n+     * \n+     * @return number of observations\n+     */\n+    \n+    public int getN() {\n+        return n;\n+    }\n+    \n+    /**\n+     * Compute a covariance matrix from a matrix whose columns represent\n+     * covariates.\n+     * @param matrix input matrix (must have at least two columns and two rows)\n+     * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n+     * @return covariance matrix\n+     */\n+    protected RealMatrix computeCovarianceMatrix(RealMatrix matrix, boolean biasCorrected) {\n+        int dimension = matrix.getColumnDimension();\n+        Variance variance = new Variance(biasCorrected);\n+        RealMatrix outMatrix = new BlockRealMatrix(dimension, dimension);\n+        for (int i = 0; i < dimension; i++) {\n+            for (int j = 0; j < i; j++) {\n+              double cov = covariance(matrix.getColumn(i), matrix.getColumn(j), biasCorrected);\n+              outMatrix.setEntry(i, j, cov);\n+              outMatrix.setEntry(j, i, cov);\n+            }\n+            outMatrix.setEntry(i, i, variance.evaluate(matrix.getColumn(i)));\n+        }\n+        return outMatrix;\n+    }\n+    \n+    /**\n+     * Create a covariance matrix from a matrix whose columns represent\n+     * covariates. Covariances are computed using the bias-corrected formula.\n+     * @param matrix input matrix (must have at least two columns and two rows)\n+     * @return covariance matrix\n+     * @see #Covariance\n+     */\n+    protected RealMatrix computeCovarianceMatrix(RealMatrix matrix) {\n+        return computeCovarianceMatrix(matrix, true);\n+    }\n+    \n+    /**\n+     * Compute a covariance matrix from a rectangular array whose columns represent\n+     * covariates.\n+     * @param data input array (must have at least two columns and two rows)\n+     * @param biasCorrected determines whether or not covariance estimates are bias-corrected\n+     * @return covariance matrix\n+     */\n+    protected RealMatrix computeCovarianceMatrix(double[][] data, boolean biasCorrected) {\n+        return computeCovarianceMatrix(new BlockRealMatrix(data), biasCorrected);\n+    }\n+    \n+    /**\n+     * Create a covariance matrix from a rectangual array whose columns represent\n+     * covariates. Covariances are computed using the bias-corrected formula.\n+     * @param data input array (must have at least two columns and two rows)\n+     * @return covariance matrix\n+     * @see #Covariance\n+     */\n+    protected RealMatrix computeCovarianceMatrix(double[][] data) {\n+        return computeCovarianceMatrix(data, true);\n+    }\n+    \n+    /**\n+     * Computes the covariance between the two arrays.\n+     * \n+     * <p>Array lengths must match and the common length must be at least 2.</p>\n+     *\n+     * @param xArray first data array\n+     * @param yArray second data array\n+     * @param biasCorrected if true, returned value will be bias-corrected \n+     * @return returns the covariance for the two arrays \n+     * @throws  IllegalArgumentException if the arrays lengths do not match or\n+     * there is insufficient data\n+     */\n+    public double covariance(final double[] xArray, final double[] yArray, boolean biasCorrected) \n+        throws IllegalArgumentException {\n+        Mean mean = new Mean();\n+        double result = 0d;\n+        int length = xArray.length;\n+        if(length == yArray.length && length > 1) {\n+            double xMean = mean.evaluate(xArray);\n+            double yMean = mean.evaluate(yArray);\n+            for (int i = 0; i < length; i++) {\n+                double xDev = xArray[i] - xMean;\n+                double yDev = yArray[i] - yMean;\n+                result += (xDev * yDev - result) / (i + 1);\n+            }\n+        }\n+        else {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+               \"arrays must have the same length and both must have at \" +\n+               \"least two elements. xArray has size {0}, yArray has {1} elements\",\n+                    length, yArray.length);\n+        }\n+        return biasCorrected ? result * ((double) length / (double)(length - 1)) : result;\n+    }\n+    \n+    /**\n+     * Computes the covariance between the two arrays, using the bias-corrected\n+     * formula.\n+     * \n+     * <p>Array lengths must match and the common length must be at least 2.</p>\n+     *\n+     * @param xArray first data array\n+     * @param yArray second data array\n+     * @return returns the covariance for the two arrays \n+     * @throws  IllegalArgumentException if the arrays lengths do not match or\n+     * there is insufficient data\n+     */\n+    public double covariance(final double[] xArray, final double[] yArray) \n+        throws IllegalArgumentException {\n+        return covariance(xArray, yArray, true);\n+    }\n+    \n+    /**\n+     * Throws IllegalArgumentException of the matrix does not have at least\n+     * two columns and two rows\n+     * @param matrix matrix to check\n+     */\n+    private void checkSufficientData(final RealMatrix matrix) {\n+        int nRows = matrix.getRowDimension();\n+        int nCols = matrix.getColumnDimension();\n+        if (nRows < 2 || nCols < 2) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"insufficient data: only {0} rows and {1} columns.\",\n+                    nRows, nCols);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.correlation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.distribution.TDistribution;\n+import org.apache.commons.math.distribution.TDistributionImpl;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n+import org.apache.commons.math.stat.regression.SimpleRegression;\n+\n+/**\n+ * Computes Pearson's product-moment correlation coefficients for pairs of arrays\n+ * or columns of a matrix.\n+ * \n+ * <p>The constructors that take <code>RealMatrix</code> or \n+ * <code>double[][]</code> arguments generate correlation matrices.  The\n+ * columns of the input matrices are assumed to represent variable values.\n+ * Correlations are given by the formula</p>\n+ * <code>cor(X, Y) = &Sigma;[(x<sub>i</sub> - E(X))(y<sub>i</sub> - E(Y))] / [(n - 1)s(X)s(Y)]</code>\n+ * where <code>E(X)</code> is the mean of <code>X</code>, <code>E(Y)</code>\n+ * is the mean of the <code>Y</code> values and s(X), s(Y) are standard deviations.\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class PearsonsCorrelation {\n+    \n+    /** correlation matrix */\n+    private final RealMatrix correlationMatrix;\n+    \n+    /** number of observations */\n+    private final int nObs;\n+    \n+    /**\n+     * Create a PearsonsCorrelation instance without data\n+     */\n+    public PearsonsCorrelation() {\n+        super();\n+        correlationMatrix = null;\n+        nObs = 0;\n+    }\n+    \n+    /**\n+     * Create a PearsonsCorrelation from a rectangular array\n+     * whose columns represent values of variables to be correlated.\n+     * \n+     * @param data rectangular array with columns representing variables\n+     * @throws IllegalArgumentException if the input data array is not\n+     * rectangular with at least two rows and two columns.\n+     */\n+    public PearsonsCorrelation(double[][] data) {\n+        this(new BlockRealMatrix(data));\n+    }\n+    \n+    /**\n+     * Create a PearsonsCorrelation from a RealMatrix whose columns\n+     * represent variables to be correlated.\n+     * \n+     * @param matrix matrix with columns representing variables to correlate\n+     */\n+    public PearsonsCorrelation(RealMatrix matrix) {\n+        checkSufficientData(matrix);\n+        nObs = matrix.getRowDimension();\n+        correlationMatrix = computeCorrelationMatrix(matrix);\n+    }\n+    \n+    /**\n+     * Create a PearsonsCorrelation from a {@link Covariance}.  The correlation\n+     * matrix is computed by scaling the Covariance's covariance matrix.\n+     * The Covariance instance must have been created from a data matrix with\n+     * columns representing variable values.\n+     * \n+     * @param covariance Covariance instance\n+     */\n+    public PearsonsCorrelation(Covariance covariance) {\n+        RealMatrix covarianceMatrix = covariance.getCovarianceMatrix();\n+        if (covarianceMatrix == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"covariance matrix is null\");\n+        }\n+        nObs = covariance.getN();\n+        correlationMatrix = covarianceToCorrelation(covarianceMatrix);\n+    }\n+    \n+    /**\n+     * Create a PearsonsCorrelation from a covariance matrix.  The correlation\n+     * matrix is computed by scaling the covariance matrix.\n+     * \n+     * @param covarianceMatrix covariance matrix\n+     * @param numberOfObservations the number of observations in the dataset used to compute\n+     * the covariance matrix\n+     */\n+    public PearsonsCorrelation(RealMatrix covarianceMatrix, int numberOfObservations) {\n+        nObs = numberOfObservations;\n+        correlationMatrix = covarianceToCorrelation(covarianceMatrix);\n+        \n+    }\n+    \n+    /**\n+     * Returns the correlation matrix\n+     * \n+     * @return correlation matrix\n+     */\n+    public RealMatrix getCorrelationMatrix() {\n+        return correlationMatrix;  \n+    }\n+    \n+    /**\n+     * Returns a matrix of standard errors associated with the estimates\n+     * in the correlation matrix.<br/>\n+     * <code>getCorrelationStandardErrors().getEntry(i,j)</code> is the standard\n+     * error associated with <code>getCorrelationMatrix.getEntry(i,j)</code>\n+     * <p>The formula used to compute the standard error is <br/>\n+     * <code>SE<sub>r</sub> = ((1 - r<sup>2</sup>) / (n - 2))<sup>1/2</sup></code>\n+     * where <code>r</code> is the estimated correlation coefficient and \n+     * <code>n</code> is the number of observations in the source dataset.</p>\n+     * \n+     * @return matrix of correlation standard errors\n+     */\n+    public RealMatrix getCorrelationStandardErrors() {\n+        int nVars = correlationMatrix.getColumnDimension();\n+        double[][] out = new double[nVars][nVars];\n+        for (int i = 0; i < nVars; i++) {\n+            for (int j = 0; j < nVars; j++) {\n+                double r = correlationMatrix.getEntry(i, j);\n+                out[i][j] = Math.sqrt((1 - r * r) /(nObs - 2));\n+            }\n+        }\n+        return new BlockRealMatrix(out);\n+    }\n+\n+    /**\n+     * Returns a matrix of p-values associated with the (two-sided) null\n+     * hypothesis that the corresponding correlation coefficient is zero.\n+     * <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability\n+     * that a random variable distributed as <code>t<sub>n-2</sub></code> takes\n+     * a value with absolute value greater than or equal to <br>\n+     * <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p>\n+     * <p>The values in the matrix are sometimes referred to as the \n+     * <i>significance</i> of the corresponding correlation coefficients.</p>\n+     * \n+     * @return matrix of p-values\n+     * @throws MathException if an error occurs estimating probabilities\n+     */\n+    public RealMatrix getCorrelationPValues() throws MathException {\n+        TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n+        int nVars = correlationMatrix.getColumnDimension();\n+        double[][] out = new double[nVars][nVars];\n+        for (int i = 0; i < nVars; i++) {\n+            for (int j = 0; j < nVars; j++) {\n+                if (i == j) {\n+                    out[i][j] = 0d;\n+                } else {\n+                    double r = correlationMatrix.getEntry(i, j);\n+                    double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n+                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n+                }\n+            }\n+        }\n+        return new BlockRealMatrix(out);\n+    }\n+    \n+    \n+    /**\n+     * Computes the correlation matrix for the columns of the\n+     * input matrix.\n+     * \n+     * @param matrix matrix with columns representing variables to correlate\n+     * @return correlation matrix\n+     */\n+    public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {\n+        int nVars = matrix.getColumnDimension();\n+        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n+        for (int i = 0; i < nVars; i++) {\n+            for (int j = 0; j < i; j++) {\n+              double corr = correlation(matrix.getColumn(i), matrix.getColumn(j));\n+              outMatrix.setEntry(i, j, corr);\n+              outMatrix.setEntry(j, i, corr);\n+            }\n+            outMatrix.setEntry(i, i, 1d);\n+        }\n+        return outMatrix;\n+    }\n+    \n+    /**\n+     * Computes the correlation matrix for the columns of the\n+     * input rectangular array.  The colums of the array represent values\n+     * of variables to be correlated.\n+     * \n+     * @param data matrix with columns representing variables to correlate\n+     * @return correlation matrix\n+     */\n+    public RealMatrix computeCorrelationMatrix(double[][] data) {\n+       return computeCorrelationMatrix(new BlockRealMatrix(data));\n+    }\n+    \n+    /**\n+     * Computes the Pearson's product-moment correlation coefficient between the two arrays.\n+     * \n+     * </p>Throws IllegalArgumentException if the arrays do not have the same length\n+     * or their common length is less than 2</p>\n+     *\n+     * @param xArray first data array\n+     * @param yArray second data array\n+     * @return Returns Pearson's correlation coefficient for the two arrays \n+     * @throws  IllegalArgumentException if the arrays lengths do not match or\n+     * there is insufficient data\n+     */\n+    public double correlation(final double[] xArray, final double[] yArray) throws IllegalArgumentException {\n+        SimpleRegression regression = new SimpleRegression();\n+        if(xArray.length == yArray.length && xArray.length > 1) {\n+            for(int i=0; i<xArray.length; i++) {\n+                regression.addData(xArray[i], yArray[i]);\n+            }\n+            return regression.getR();\n+        }\n+        else {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid array dimensions. xArray has size {0}; yArray has {1} elements\",\n+                    xArray.length, yArray.length);\n+        }\n+    }\n+    \n+    /**\n+     * Derives a correlation matrix from a covariance matrix.\n+     * \n+     * <p>Uses the formula <br/>\n+     * <code>r(X,Y) = cov(X,Y)/s(X)s(Y)</code> where \n+     * <code>r(&middot,&middot;)</code> is the correlation coefficient and\n+     * <code>s(&middot;)</code> means standard deviation.</p>\n+     * \n+     * @param covarianceMatrix the covariance matrix\n+     * @return correlation matrix\n+     */\n+    public RealMatrix covarianceToCorrelation(RealMatrix covarianceMatrix) {\n+        int nVars = covarianceMatrix.getColumnDimension();\n+        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n+        for (int i = 0; i < nVars; i++) {\n+            double sigma = Math.sqrt(covarianceMatrix.getEntry(i, i));\n+            outMatrix.setEntry(i, i, 1d);\n+            for (int j = 0; j < i; j++) {\n+                double entry = covarianceMatrix.getEntry(i, j) / \n+                       (sigma * Math.sqrt(covarianceMatrix.getEntry(j, j)));\n+                outMatrix.setEntry(i, j, entry);\n+                outMatrix.setEntry(j, i, entry);\n+            }\n+        }\n+        return outMatrix;\n+    }\n+    \n+    /**\n+     * Throws IllegalArgumentException of the matrix does not have at least\n+     * two columns and two rows\n+     * \n+     * @param matrix matrix to check for sufficiency\n+     */\n+    private void checkSufficientData(final RealMatrix matrix) {\n+        int nRows = matrix.getRowDimension();\n+        int nCols = matrix.getColumnDimension();\n+        if (nRows < 2 || nCols < 2) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"insufficient data: only {0} rows and {1} columns.\",\n+                    nRows, nCols);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/correlation/SpearmansCorrelation.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.correlation;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.linear.BlockRealMatrix;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.stat.ranking.NaturalRanking;\n+import org.apache.commons.math.stat.ranking.RankingAlgorithm;\n+\n+/**\n+ * <p>Spearman's rank correlation. This implementation performs a rank\n+ * transformation on the input data and then computes {@link PearsonsCorrelation}\n+ * on the ranked data.</p>\n+ * \n+ * <p>By default, ranks are computed using {@link NaturalRanking} with default\n+ * strategies for handling NaNs and ties in the data (NaNs maximal, ties averaged).\n+ * The ranking algorithm can be set using a constructor argument.</p>\n+ * \n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+\n+public class SpearmansCorrelation {   \n+   \n+    /** Input data */\n+    private final RealMatrix data;\n+    \n+    /** Ranking algorithm  */\n+    private final RankingAlgorithm rankingAlgorithm;\n+    \n+    /** Rank correlation */\n+    private final PearsonsCorrelation rankCorrelation;\n+    \n+    /**\n+     * Create a SpearmansCorrelation with the given input data matrix\n+     * and ranking algorithm.\n+     * \n+     * @param dataMatrix matrix of data with columns representing\n+     * variables to correlate\n+     * @param rankingAlgorithm ranking algorithm\n+     */    \n+    public SpearmansCorrelation(final RealMatrix dataMatrix, final RankingAlgorithm rankingAlgorithm) {\n+        this.data = dataMatrix.copy(); \n+        this.rankingAlgorithm = rankingAlgorithm;\n+        rankTransform(data);\n+        rankCorrelation = new PearsonsCorrelation(data);\n+    }\n+    \n+    /**\n+     * Create a SpearmansCorrelation from the given data matrix.\n+     * \n+     * @param dataMatrix matrix of data with columns representing\n+     * variables to correlate\n+     */\n+    public SpearmansCorrelation(final RealMatrix dataMatrix) {\n+        this(dataMatrix, new NaturalRanking());\n+    }\n+    \n+    /**\n+     * Create a SpearmansCorrelation without data.\n+     */\n+    public SpearmansCorrelation() {\n+        data = null; \n+        this.rankingAlgorithm = new NaturalRanking();\n+        rankCorrelation = null;\n+    }\n+    \n+    /**\n+     * Calculate the Spearman Rank Correlation Matrix. \n+     * \n+     * @return Spearman Rank Correlation Matrix\n+     */\n+    public RealMatrix getCorrelationMatrix() {\n+        return rankCorrelation.getCorrelationMatrix();\n+    }\n+    \n+    /**\n+     * Returns a {@link PearsonsCorrelation} instance constructed from the\n+     * ranked input data. That is,\n+     * <code>new SpearmansCorrelation(matrix).getRankCorrelation()</code>\n+     * is equivalent to \n+     * <code>new PearsonsCorrelation(rankTransform(matrix))</code> where\n+     * <code>rankTransform(matrix)</code> is the result of applying the\n+     * configured <code>RankingAlgorithm</code> to each of the columns of\n+     * <code>matrix.</code>\n+     * \n+     * @return PearsonsCorrelation among ranked column data\n+     */\n+    public PearsonsCorrelation getRankCorrelation() {\n+        return rankCorrelation;\n+    }\n+    \n+    /**\n+     * Computes the Spearman's rank correlation matrix for the columns of the\n+     * input matrix.\n+     * \n+     * @param matrix matrix with columns representing variables to correlate\n+     * @return correlation matrix\n+     */\n+    public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {\n+        RealMatrix matrixCopy = matrix.copy();\n+        rankTransform(matrixCopy);\n+        return new PearsonsCorrelation().computeCorrelationMatrix(matrixCopy);\n+    }\n+    \n+    /**\n+     * Computes the Spearman's rank correlation matrix for the columns of the\n+     * input rectangular array.  The columns of the array represent values\n+     * of variables to be correlated.\n+     * \n+     * @param data matrix with columns representing variables to correlate\n+     * @return correlation matrix\n+     */\n+    public RealMatrix computeCorrelationMatrix(double[][] data) {\n+       return computeCorrelationMatrix(new BlockRealMatrix(data));\n+    }\n+    \n+    /**\n+     * Computes the Spearman's rank correlation coefficient between the two arrays.\n+     * \n+     * </p>Throws IllegalArgumentException if the arrays do not have the same length\n+     * or their common length is less than 2</p>\n+     *\n+     * @param xArray first data array\n+     * @param yArray second data array\n+     * @return Returns Spearman's rank correlation coefficient for the two arrays \n+     * @throws  IllegalArgumentException if the arrays lengths do not match or\n+     * there is insufficient data\n+     */\n+    public double correlation(final double[] xArray, final double[] yArray)\n+    throws IllegalArgumentException {\n+        if (xArray.length == yArray.length && xArray.length > 1) {\n+            return new PearsonsCorrelation().correlation(rankingAlgorithm.rank(xArray),\n+                    rankingAlgorithm.rank(yArray));\n+        }\n+        else {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid array dimensions. xArray has size {0}; yArray has {1} elements\",\n+                    xArray.length, yArray.length);\n+        }\n+    }\n+    \n+    /**\n+     * Applies rank transform to each of the columns of <code>matrix</code>\n+     * using the current <code>rankingAlgorithm</code>\n+     * \n+     * @param matrix matrix to transform\n+     */\n+    private void rankTransform(RealMatrix matrix) {\n+        for (int i = 0; i < matrix.getColumnDimension(); i++) {\n+            matrix.setColumn(i, rankingAlgorithm.rank(matrix.getColumn(i)));\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ *\n+ * Abstract implementation of the {@link StorelessUnivariateStatistic} interface.\n+ * <p>\n+ * Provides default <code>evaluate()</code> and <code>incrementAll(double[])<code>\n+ * implementations.</p>\n+ * <p>\n+ * <strong>Note that these implementations are not synchronized.</strong></p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public abstract class AbstractStorelessUnivariateStatistic\n+    extends AbstractUnivariateStatistic\n+    implements StorelessUnivariateStatistic {\n+    \n+    /**\n+     * This default implementation calls {@link #clear}, then invokes \n+     * {@link #increment} in a loop over the the input array, and then uses \n+     * {@link #getResult} to compute the return value.  \n+     * <p>\n+     * Note that this implementation changes the internal state of the\n+     * statistic.  Its side effects are the same as invoking {@link #clear} and\n+     * then {@link #incrementAll(double[])}.</p>\n+     * <p>\n+     * Implementations may override this method with a more efficient and\n+     * possibly more accurate implementation that works directly with the\n+     * input array.</p>\n+     * <p>\n+     * If the array is null, an IllegalArgumentException is thrown.</p>\n+     * @param values input array\n+     * @return the value of the statistic applied to the input array\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatistic#evaluate(double[])\n+     */\n+    @Override\n+    public double evaluate(final double[] values) {\n+        if (values == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"input values array is null\");\n+        }\n+        return evaluate(values, 0, values.length);\n+    }\n+    \n+    /**\n+     * This default implementation calls {@link #clear}, then invokes \n+     * {@link #increment} in a loop over the specified portion of the input \n+     * array, and then uses {@link #getResult} to compute the return value.  \n+     * <p>\n+     * Note that this implementation changes the internal state of the\n+     * statistic.  Its side effects are the same as invoking {@link #clear} and\n+     * then {@link #incrementAll(double[], int, int)}.</p>\n+     * <p>\n+     * Implementations may override this method with a more efficient and\n+     * possibly more accurate implementation that works directly with the\n+     * input array.</p>\n+     * <p>\n+     * If the array is null or the index parameters are not valid, an \n+     * IllegalArgumentException is thrown.</p>\n+     * @param values the input array\n+     * @param begin the index of the first element to include\n+     * @param length the number of elements to include\n+     * @return the value of the statistic applied to the included array entries\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatistic#evaluate(double[], int, int)\n+     */\n+    @Override\n+    public double evaluate(final double[] values, final int begin, final int length) {\n+        if (test(values, begin, length)) {\n+            clear();\n+            incrementAll(values, begin, length);\n+        }\n+        return getResult();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public abstract StorelessUnivariateStatistic copy();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public abstract void clear();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public abstract double getResult();\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public abstract void increment(final double d);\n+    \n+    /**\n+     * This default implementation just calls {@link #increment} in a loop over\n+     * the input array.   \n+     * <p>\n+     * Throws IllegalArgumentException if the input values array is null.</p>\n+     * \n+     * @param values values to add\n+     * @throws IllegalArgumentException if values is null\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#incrementAll(double[])\n+     */\n+    public void incrementAll(double[] values) {\n+        if (values == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"input values array is null\");\n+        }\n+        incrementAll(values, 0, values.length);\n+    } \n+   \n+    /**\n+     * This default implementation just calls {@link #increment} in a loop over\n+     * the specified portion of the input array.\n+     * <p>\n+     * Throws IllegalArgumentException if the input values array is null.</p>\n+     * \n+     * @param values  array holding values to add\n+     * @param begin   index of the first array element to add\n+     * @param length  number of array elements to add\n+     * @throws IllegalArgumentException if values is null\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#incrementAll(double[], int, int)\n+     */\n+    public void incrementAll(double[] values, int begin, int length) {\n+        if (test(values, begin, length)) {\n+            int k = begin + length;\n+            for (int i = begin; i < k; i++) {\n+                increment(values[i]);\n+            }   \n+        }\n+    }\n+    \n+    /**\n+     * Returns true iff <code>object</code> is an \n+     * <code>AbstractStorelessUnivariateStatistic</code> returning the same\n+     * values as this for <code>getResult()</code> and <code>getN()</code>\n+     * @param object object to test equality against.\n+     * @return true if object returns the same value as this\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (object == this ) {\n+            return true;\n+        }\n+       if (object instanceof AbstractStorelessUnivariateStatistic == false) {\n+            return false;\n+        }\n+        AbstractStorelessUnivariateStatistic stat = (AbstractStorelessUnivariateStatistic) object;\n+        return (MathUtils.equals(stat.getResult(), this.getResult()) && \n+                MathUtils.equals(stat.getN(), this.getN()));\n+    }\n+    \n+    /**\n+     * Returns hash code based on getResult() and getN()\n+     * \n+     * @return hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        return 31* (31 + MathUtils.hash(getResult())) + MathUtils.hash(getN());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Abstract base class for all implementations of the \n+ * {@link UnivariateStatistic} interface.\n+ * <p>\n+ * Provides a default implementation of <code>evaluate(double[]),</code> \n+ * delegating to <code>evaluate(double[], int, int)</code> in the natural way.\n+ * </p>\n+ * <p>\n+ * Also includes a <code>test</code> method that performs generic parameter\n+ * validation for the <code>evaluate</code> methods.</p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public abstract class AbstractUnivariateStatistic\n+    implements UnivariateStatistic {\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double evaluate(final double[] values) {\n+        test(values, 0, 0);\n+        return evaluate(values, 0, values.length);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public abstract double evaluate(final double[] values, final int begin, final int length);\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public abstract UnivariateStatistic copy();\n+\n+    /**\n+     * This method is used by <code>evaluate(double[], int, int)</code> methods\n+     * to verify that the input parameters designate a subarray of positive length.\n+     * <p>\n+     * <ul>\n+     * <li>returns <code>true</code> iff the parameters designate a subarray of \n+     * positive length</li>\n+     * <li>throws <code>IllegalArgumentException</code> if the array is null or\n+     * or the indices are invalid</li>\n+     * <li>returns <code>false</li> if the array is non-null, but \n+     * <code>length</code> is 0.\n+     * </ul></p>\n+     *\n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return true if the parameters are valid and designate a subarray of positive length\n+     * @throws IllegalArgumentException if the indices are invalid or the array is null\n+     */\n+    protected boolean test(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n+\n+        if (values == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"input values array is null\");\n+        }\n+        \n+        if (begin < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"start position cannot be negative ({0})\", begin);\n+        }\n+        \n+        if (length < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"length cannot be negative ({0})\", length);\n+        }\n+        \n+        if (begin + length > values.length) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"subarray ends after array end\");\n+        }\n+\n+        if (length == 0) {\n+            return false;\n+        }\n+\n+        return true;\n+\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/AggregateSummaryStatistics.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.Iterator;\n+\n+/**\n+ * <p>\n+ * An aggregator for {@code SummaryStatistics} from several data sets or\n+ * data set partitions.  In its simplest usage mode, the client creates an\n+ * instance via the zero-argument constructor, then uses\n+ * {@link #createContributingStatistics()} to obtain a {@code SummaryStatistics}\n+ * for each individual data set / partition.  The per-set statistics objects\n+ * are used as normal, and at any time the aggregate statistics for all the\n+ * contributors can be obtained from this object.\n+ * </p><p>\n+ * Clients with specialized requirements can use alternative constructors to\n+ * control the statistics implementations and initial values used by the\n+ * contributing and the internal aggregate {@code SummaryStatistics} objects.\n+ * </p><p>\n+ * A static {@link #aggregate(Collection)} method is also included that computes\n+ * aggregate statistics directly from a Collection of SummaryStatistics instances.\n+ * </p><p>\n+ * When {@link #createContributingStatistics()} is used to create SummaryStatistics\n+ * instances to be aggregated concurrently, the created instances' \n+ * {@link SummaryStatistics#addValue(double)} methods must synchronize on the aggregating\n+ * instance maintained by this class.  In multithreaded environments, if the functionality\n+ * provided by {@link #aggregate(Collection)} is adequate, that method should be used\n+ * to avoid unecessary computation and synchronization delays.</p>\n+ *\n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ * \n+ */\n+public class AggregateSummaryStatistics implements StatisticalSummary,\n+        Serializable {\n+\n+ \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -8207112444016386906L;\n+\n+    /**\n+     * A SummaryStatistics serving as a prototype for creating SummaryStatistics\n+     * contributing to this aggregate \n+     */\n+    private final SummaryStatistics statisticsPrototype;\n+    \n+    /**\n+     * The SummaryStatistics in which aggregate statistics are accumulated.\n+     */\n+    private final SummaryStatistics statistics;\n+    \n+    /**\n+     * Initializes a new AggregateSummaryStatistics with default statistics\n+     * implementations.\n+     * \n+     */\n+    public AggregateSummaryStatistics() {\n+        this(new SummaryStatistics());\n+    }\n+    \n+    /**\n+     * Initializes a new AggregateSummaryStatistics with the specified statistics\n+     * object as a prototype for contributing statistics and for the internal\n+     * aggregate statistics.  This provides for customized statistics implementations\n+     * to be used by contributing and aggregate statistics.\n+     *\n+     * @param prototypeStatistics a {@code SummaryStatistics} serving as a\n+     *      prototype both for the internal aggregate statistics and for\n+     *      contributing statistics obtained via the\n+     *      {@code createContributingStatistics()} method.  Being a prototype\n+     *      means that other objects are initialized by copying this object's state. \n+     *      If {@code null}, a new, default statistics object is used.  Any statistic\n+     *      values in the prototype are propagated to contributing statistics\n+     *      objects and (once) into these aggregate statistics.\n+     * @see #createContributingStatistics()\n+     */\n+    public AggregateSummaryStatistics(SummaryStatistics prototypeStatistics) {\n+        this(prototypeStatistics, (prototypeStatistics == null ? null :\n+                new SummaryStatistics(prototypeStatistics)));\n+    }\n+    \n+    /**\n+     * Initializes a new AggregateSummaryStatistics with the specified statistics\n+     * object as a prototype for contributing statistics and for the internal\n+     * aggregate statistics.  This provides for different statistics implementations\n+     * to be used by contributing and aggregate statistics and for an initial\n+     * state to be supplied for the aggregate statistics.\n+     *\n+     * @param prototypeStatistics a {@code SummaryStatistics} serving as a\n+     *      prototype both for the internal aggregate statistics and for\n+     *      contributing statistics obtained via the\n+     *      {@code createContributingStatistics()} method.  Being a prototype\n+     *      means that other objects are initialized by copying this object's state. \n+     *      If {@code null}, a new, default statistics object is used.  Any statistic\n+     *      values in the prototype are propagated to contributing statistics\n+     *      objects, but not into these aggregate statistics.\n+     * @param initialStatistics a {@code SummaryStatistics} to serve as the\n+     *      internal aggregate statistics object.  If {@code null}, a new, default\n+     *      statistics object is used.\n+     * @see #createContributingStatistics()\n+     */\n+    public AggregateSummaryStatistics(SummaryStatistics prototypeStatistics,\n+            SummaryStatistics initialStatistics) {\n+        this.statisticsPrototype = ((prototypeStatistics == null) ?\n+                new SummaryStatistics() : prototypeStatistics);\n+        this.statistics = ((initialStatistics == null) ?\n+                new SummaryStatistics() : initialStatistics);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}.  This version returns the maximum over all the aggregated\n+     * data.\n+     *\n+     * @see StatisticalSummary#getMax()\n+     */\n+    public double getMax() {\n+        synchronized (statistics) {\n+            return statistics.getMax();\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}.  This version returns the mean of all the aggregated data.\n+     *\n+     * @see StatisticalSummary#getMean()\n+     */\n+    public double getMean() {\n+        synchronized (statistics) {\n+            return statistics.getMean();\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}.  This version returns the minimum over all the aggregated\n+     * data.\n+     *\n+     * @see StatisticalSummary#getMin()\n+     */\n+    public double getMin() {\n+        synchronized (statistics) {\n+            return statistics.getMin();\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}.  This version returns a count of all the aggregated data.\n+     *\n+     * @see StatisticalSummary#getN()\n+     */\n+    public long getN() {\n+        synchronized (statistics) {\n+            return statistics.getN();\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}.  This version returns the standard deviation of all the\n+     * aggregated data.\n+     *\n+     * @see StatisticalSummary#getStandardDeviation()\n+     */\n+    public double getStandardDeviation() {\n+        synchronized (statistics) {\n+            return statistics.getStandardDeviation();\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}.  This version returns a sum of all the aggregated data.\n+     *\n+     * @see StatisticalSummary#getSum()\n+     */\n+    public double getSum() {\n+        synchronized (statistics) {\n+            return statistics.getSum();\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}.  This version returns the variance of all the aggregated\n+     * data.\n+     *\n+     * @see StatisticalSummary#getVariance()\n+     */\n+    public double getVariance() {\n+        synchronized (statistics) {\n+            return statistics.getVariance();\n+        }\n+    }\n+    \n+    /**\n+     * Returns the sum of the logs of all the aggregated data.\n+     * \n+     * @return the sum of logs\n+     * @see SummaryStatistics#getSumOfLogs()\n+     */\n+    public double getSumOfLogs() {\n+        synchronized (statistics) {\n+            return statistics.getSumOfLogs();\n+        }\n+    }\n+    \n+    /**\n+     * Returns the geometric mean of all the aggregated data.\n+     * \n+     * @return the geometric mean\n+     * @see SummaryStatistics#getGeometricMean()\n+     */\n+    public double getGeometricMean() {\n+        synchronized (statistics) {\n+            return statistics.getGeometricMean();\n+        }\n+    }\n+    \n+    /**\n+     * Returns the sum of the squares of all the aggregated data.\n+     * \n+     * @return The sum of squares\n+     * @see SummaryStatistics#getSumsq()\n+     */\n+    public double getSumsq() {\n+        synchronized (statistics) {\n+            return statistics.getSumsq();\n+        }\n+    }\n+    \n+    /**\n+     * Returns a statistic related to the Second Central Moment.  Specifically,\n+     * what is returned is the sum of squared deviations from the sample mean\n+     * among the all of the aggregated data.\n+     * \n+     * @return second central moment statistic\n+     * @see SummaryStatistics#getSecondMoment()\n+     */\n+    public double getSecondMoment() {\n+        synchronized (statistics) {\n+            return statistics.getSecondMoment();\n+        }\n+    }\n+    \n+    /**\n+     * Return a {@link StatisticalSummaryValues} instance reporting current\n+     * aggregate statistics.\n+     * \n+     * @return Current values of aggregate statistics\n+     */\n+    public StatisticalSummary getSummary() {\n+        synchronized (statistics) {\n+            return new StatisticalSummaryValues(getMean(), getVariance(), getN(), \n+                    getMax(), getMin(), getSum());\n+        }\n+    }\n+\n+    /**\n+     * Creates and returns a {@code SummaryStatistics} whose data will be\n+     * aggregated with those of this {@code AggregateSummaryStatistics}. \n+     *\n+     * @return a {@code SummaryStatistics} whose data will be aggregated with\n+     *      those of this {@code AggregateSummaryStatistics}.  The initial state\n+     *      is a copy of the configured prototype statistics.\n+     */\n+    public SummaryStatistics createContributingStatistics() {\n+        SummaryStatistics contributingStatistics\n+                = new AggregatingSummaryStatistics(statistics);\n+        \n+        SummaryStatistics.copy(statisticsPrototype, contributingStatistics);\n+        \n+        return contributingStatistics;\n+    }\n+    \n+    /**\n+     * Computes aggregate summary statistics. This method can be used to combine statistics\n+     * computed over partitions or subsamples - i.e., the StatisticalSummaryValues returned\n+     * should contain the same values that would have been obtained by computing a single\n+     * StatisticalSummary over the combined dataset.\n+     * <p>\n+     * Returns null if the collection is empty or null.\n+     * </p>\n+     * \n+     * @param statistics collection of SummaryStatistics to aggregate\n+     * @return summary statistics for the combined dataset\n+     */\n+    public static StatisticalSummaryValues aggregate(Collection<SummaryStatistics> statistics) {\n+        if (statistics == null) {\n+            return null;\n+        }\n+        Iterator<SummaryStatistics> iterator = statistics.iterator();\n+        if (!iterator.hasNext()) {\n+            return null;\n+        }\n+        SummaryStatistics current = iterator.next();\n+        long n = current.getN();\n+        double min = current.getMin();\n+        double sum = current.getSum();\n+        double max = current.getMax();\n+        double m2 = current.getSecondMoment();\n+        double mean = current.getMean();\n+        while (iterator.hasNext()) {\n+            current = iterator.next();\n+            if (current.getMin() < min || Double.isNaN(min)) {\n+                min = current.getMin();\n+            }\n+            if (current.getMax() > max || Double.isNaN(max)) {\n+                max = current.getMax();\n+            }\n+            sum += current.getSum();\n+            final double oldN = n;\n+            final double curN = current.getN();\n+            n += curN;\n+            final double meanDiff = current.getMean() - mean;\n+            mean = sum / n;\n+            m2 = m2 + current.getSecondMoment() + meanDiff * meanDiff * oldN * curN / n; \n+        }\n+        final double variance;\n+        if (n == 0) {\n+            variance = Double.NaN;\n+        } else if (n == 1) {\n+            variance = 0d;\n+        } else {\n+            variance = m2 / (n - 1);\n+        }\n+        return new StatisticalSummaryValues(mean, variance, n, max, min, sum);\n+    }\n+    \n+    /**\n+     * A SummaryStatistics that also forwards all values added to it to a second\n+     * {@code SummaryStatistics} for aggregation.\n+     *\n+     * @since 2.0\n+     */\n+    private static class AggregatingSummaryStatistics extends SummaryStatistics {\n+        \n+        /**\n+         * The serialization version of this class\n+         */\n+        private static final long serialVersionUID = 1L;\n+        \n+        /**\n+         * An additional SummaryStatistics into which values added to these\n+         * statistics (and possibly others) are aggregated\n+         */\n+        private final SummaryStatistics aggregateStatistics;\n+        \n+        /**\n+         * Initializes a new AggregatingSummaryStatistics with the specified\n+         * aggregate statistics object\n+         *\n+         * @param aggregateStatistics a {@code SummaryStatistics} into which\n+         *      values added to this statistics object should be aggregated\n+         */\n+        public AggregatingSummaryStatistics(SummaryStatistics aggregateStatistics) {\n+            this.aggregateStatistics = aggregateStatistics;\n+        }\n+\n+        /**\n+         * {@inheritDoc}.  This version adds the provided value to the configured\n+         * aggregate after adding it to these statistics.\n+         *\n+         * @see SummaryStatistics#addValue(double)\n+         */\n+        @Override\n+        public void addValue(double value) {\n+            super.addValue(value);\n+            synchronized (aggregateStatistics) {\n+                aggregateStatistics.addValue(value);\n+            }\n+        }\n+\n+        /**\n+         * Returns true iff <code>object</code> is a\n+         * <code>SummaryStatistics</code> instance and all statistics have the\n+         * same values as this.\n+         * @param object the object to test equality against.\n+         * @return true if object equals this\n+         */\n+        @Override\n+        public boolean equals(Object object) {\n+            if (object == this) {\n+                return true;\n+            }\n+            if (object instanceof AggregatingSummaryStatistics == false) {\n+                return false;\n+            }\n+            AggregatingSummaryStatistics stat = (AggregatingSummaryStatistics)object;\n+            return (super.equals(stat) &&\n+                    aggregateStatistics.equals(stat.aggregateStatistics));\n+        }\n+\n+        /**\n+         * Returns hash code based on values of statistics\n+         * @return hash code\n+         */\n+        @Override\n+        public int hashCode() {\n+            return 123 + super.hashCode() + aggregateStatistics.hashCode();\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.stat.descriptive.moment.GeometricMean;\n+import org.apache.commons.math.stat.descriptive.moment.Kurtosis;\n+import org.apache.commons.math.stat.descriptive.moment.Mean;\n+import org.apache.commons.math.stat.descriptive.moment.Skewness;\n+import org.apache.commons.math.stat.descriptive.moment.Variance;\n+import org.apache.commons.math.stat.descriptive.rank.Max;\n+import org.apache.commons.math.stat.descriptive.rank.Min;\n+import org.apache.commons.math.stat.descriptive.rank.Percentile;\n+import org.apache.commons.math.stat.descriptive.summary.Sum;\n+import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n+import org.apache.commons.math.util.ResizableDoubleArray;\n+\n+\n+/**\n+ * Maintains a dataset of values of a single variable and computes descriptive\n+ * statistics based on stored data. The {@link #getWindowSize() windowSize}\n+ * property sets a limit on the number of values that can be stored in the \n+ * dataset.  The default value, INFINITE_WINDOW, puts no limit on the size of\n+ * the dataset.  This value should be used with caution, as the backing store\n+ * will grow without bound in this case.  For very large datasets, \n+ * {@link SummaryStatistics}, which does not store the dataset, should be used\n+ * instead of this class. If <code>windowSize</code> is not INFINITE_WINDOW and\n+ * more values are added than can be stored in the dataset, new values are\n+ * added in a \"rolling\" manner, with new values replacing the \"oldest\" values \n+ * in the dataset.\n+ * \n+ * <p>Note: this class is not threadsafe.  Use \n+ * {@link SynchronizedDescriptiveStatistics} if concurrent access from multiple\n+ * threads is required.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class DescriptiveStatistics implements StatisticalSummary, Serializable {\n+    \n+    /** Serialization UID */\n+    private static final long serialVersionUID = 4133067267405273064L;\n+\n+    /** hold the window size **/\n+    protected int windowSize = INFINITE_WINDOW;\n+    \n+    /** \n+     *  Stored data values\n+     */\n+    protected ResizableDoubleArray eDA = new ResizableDoubleArray();\n+  \n+    /** Mean statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic meanImpl = new Mean();\n+    \n+    /** Geometric mean statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic geometricMeanImpl = new GeometricMean();\n+    \n+    /** Kurtosis statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic kurtosisImpl = new Kurtosis();\n+    \n+    /** Maximum statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic maxImpl = new Max();\n+    \n+    /** Minimum statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic minImpl = new Min();\n+    \n+    /** Percentile statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic percentileImpl = new Percentile();\n+    \n+    /** Skewness statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic skewnessImpl = new Skewness();\n+    \n+    /** Variance statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic varianceImpl = new Variance();\n+    \n+    /** Sum of squares statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic sumsqImpl = new SumOfSquares();\n+    \n+    /** Sum statistic implementation - can be reset by setter. */\n+    private UnivariateStatistic sumImpl = new Sum();\n+    \n+    /**\n+     * Construct a DescriptiveStatistics instance with an infinite window\n+     */\n+    public DescriptiveStatistics() {\n+    }\n+    \n+    /**\n+     * Construct a DescriptiveStatistics instance with the specified window\n+     * \n+     * @param window the window size.\n+     */\n+    public DescriptiveStatistics(int window) {\n+        setWindowSize(window);\n+    }\n+    \n+    /**\n+     * Copy constructor.  Construct a new DescriptiveStatistics instance that\n+     * is a copy of original.\n+     * \n+     * @param original DescriptiveStatistics instance to copy\n+     */\n+    public DescriptiveStatistics(DescriptiveStatistics original) {\n+        copy(original, this);\n+    }\n+    \n+    /**\n+     * Represents an infinite window size.  When the {@link #getWindowSize()}\n+     * returns this value, there is no limit to the number of data values\n+     * that can be stored in the dataset.\n+     */\n+    public static final int INFINITE_WINDOW = -1;\n+\n+    /**\n+     * Adds the value to the dataset. If the dataset is at the maximum size\n+     * (i.e., the number of stored elements equals the currently configured\n+     * windowSize), the first (oldest) element in the dataset is discarded\n+     * to make room for the new value.\n+     * \n+     * @param v the value to be added \n+     */\n+    public void addValue(double v) {\n+        if (windowSize != INFINITE_WINDOW) {\n+            if (getN() == windowSize) {\n+                eDA.addElementRolling(v);\n+            } else if (getN() < windowSize) {\n+                eDA.addElement(v);\n+            }\n+        } else {\n+            eDA.addElement(v);\n+        }\n+    }\n+\n+    /**\n+     * Removes the most recent value from the dataset.\n+     */\n+    public void removeMostRecentValue() {\n+        eDA.discardMostRecentElements(1);\n+    }\n+\n+    /**\n+     * Replaces the most recently stored value with the given value.\n+     * There must be at least one element stored to call this method.\n+     * \n+     * @param v the value to replace the most recent stored value\n+     * @return replaced value\n+     */\n+    public double replaceMostRecentValue(double v) {\n+        return eDA.substituteMostRecentElement(v);\n+    }\n+\n+    /** \n+     * Returns the <a href=\"http://www.xycoon.com/arithmetic_mean.htm\">\n+     * arithmetic mean </a> of the available values \n+     * @return The mean or Double.NaN if no values have been added.\n+     */\n+    public double getMean() {\n+        return apply(meanImpl);\n+    }\n+\n+    /** \n+     * Returns the <a href=\"http://www.xycoon.com/geometric_mean.htm\">\n+     * geometric mean </a> of the available values\n+     * @return The geometricMean, Double.NaN if no values have been added, \n+     * or if the product of the available values is less than or equal to 0.\n+     */\n+    public double getGeometricMean() {\n+        return apply(geometricMeanImpl);\n+    }\n+\n+    /** \n+     * Returns the variance of the available values.\n+     * @return The variance, Double.NaN if no values have been added \n+     * or 0.0 for a single value set.  \n+     */\n+    public double getVariance() {\n+        return apply(varianceImpl);\n+    }\n+\n+    /** \n+     * Returns the standard deviation of the available values.\n+     * @return The standard deviation, Double.NaN if no values have been added \n+     * or 0.0 for a single value set. \n+     */\n+    public double getStandardDeviation() {\n+        double stdDev = Double.NaN;\n+        if (getN() > 0) {\n+            if (getN() > 1) {\n+                stdDev = Math.sqrt(getVariance());\n+            } else {\n+                stdDev = 0.0;\n+            }\n+        }\n+        return (stdDev);\n+    }\n+\n+    /**\n+     * Returns the skewness of the available values. Skewness is a \n+     * measure of the asymmetry of a given distribution.\n+     * @return The skewness, Double.NaN if no values have been added \n+     * or 0.0 for a value set &lt;=2. \n+     */\n+    public double getSkewness() {\n+        return apply(skewnessImpl);\n+    }\n+\n+    /**\n+     * Returns the Kurtosis of the available values. Kurtosis is a \n+     * measure of the \"peakedness\" of a distribution\n+     * @return The kurtosis, Double.NaN if no values have been added, or 0.0 \n+     * for a value set &lt;=3. \n+     */\n+    public double getKurtosis() {\n+        return apply(kurtosisImpl);\n+    }\n+\n+    /** \n+     * Returns the maximum of the available values\n+     * @return The max or Double.NaN if no values have been added.\n+     */\n+    public double getMax() {\n+        return apply(maxImpl);\n+    }\n+\n+    /** \n+    * Returns the minimum of the available values\n+    * @return The min or Double.NaN if no values have been added.\n+    */\n+    public double getMin() {\n+        return apply(minImpl);\n+    }\n+\n+    /** \n+     * Returns the number of available values\n+     * @return The number of available values\n+     */\n+    public long getN() {\n+        return eDA.getNumElements();\n+    }\n+\n+    /**\n+     * Returns the sum of the values that have been added to Univariate.\n+     * @return The sum or Double.NaN if no values have been added\n+     */\n+    public double getSum() {\n+        return apply(sumImpl);\n+    }\n+\n+    /**\n+     * Returns the sum of the squares of the available values.\n+     * @return The sum of the squares or Double.NaN if no \n+     * values have been added.\n+     */\n+    public double getSumsq() {\n+        return apply(sumsqImpl);\n+    }\n+\n+    /** \n+     * Resets all statistics and storage\n+     */\n+    public void clear() {\n+        eDA.clear();\n+    }\n+\n+\n+    /**\n+     * Returns the maximum number of values that can be stored in the\n+     * dataset, or INFINITE_WINDOW (-1) if there is no limit.\n+     * \n+     * @return The current window size or -1 if its Infinite.\n+     */\n+    public int getWindowSize() {\n+        return windowSize;\n+    }\n+\n+    /**\n+     * WindowSize controls the number of values which contribute \n+     * to the reported statistics.  For example, if \n+     * windowSize is set to 3 and the values {1,2,3,4,5} \n+     * have been added <strong> in that order</strong> \n+     * then the <i>available values</i> are {3,4,5} and all\n+     * reported statistics will be based on these values\n+     * @param windowSize sets the size of the window.\n+     */\n+    public void setWindowSize(int windowSize) {\n+        if (windowSize < 1) {\n+            if (windowSize != INFINITE_WINDOW) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"window size must be positive ({0})\", windowSize);\n+            }\n+        }\n+        \n+        this.windowSize = windowSize;\n+\n+        // We need to check to see if we need to discard elements\n+        // from the front of the array.  If the windowSize is less than \n+        // the current number of elements.\n+        if (windowSize != INFINITE_WINDOW && windowSize < eDA.getNumElements()) {\n+            eDA.discardFrontElements(eDA.getNumElements() - windowSize);\n+        }\n+    }\n+    \n+    /**\n+     * Returns the current set of values in an array of double primitives.  \n+     * The order of addition is preserved.  The returned array is a fresh\n+     * copy of the underlying data -- i.e., it is not a reference to the\n+     * stored data.\n+     * \n+     * @return returns the current set of numbers in the order in which they \n+     *         were added to this set\n+     */\n+    public double[] getValues() {\n+        return eDA.getElements();\n+    }\n+\n+    /**\n+     * Returns the current set of values in an array of double primitives,  \n+     * sorted in ascending order.  The returned array is a fresh\n+     * copy of the underlying data -- i.e., it is not a reference to the\n+     * stored data.\n+     * @return returns the current set of \n+     * numbers sorted in ascending order        \n+     */\n+    public double[] getSortedValues() {\n+        double[] sort = getValues();\n+        Arrays.sort(sort);\n+        return sort;\n+    }\n+\n+    /**\n+     * Returns the element at the specified index\n+     * @param index The Index of the element\n+     * @return return the element at the specified index\n+     */\n+    public double getElement(int index) {\n+        return eDA.getElement(index);\n+    }\n+\n+    /**\n+     * Returns an estimate for the pth percentile of the stored values. \n+     * <p>\n+     * The implementation provided here follows the first estimation procedure presented\n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section2/prc252.htm\">here.</a>\n+     * </p><p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>0 &lt; p &le; 100</code> (otherwise an \n+     * <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li>at least one value must be stored (returns <code>Double.NaN\n+     *     </code> otherwise)</li>\n+     * </ul></p>\n+     * \n+     * @param p the requested percentile (scaled from 0 - 100)\n+     * @return An estimate for the pth percentile of the stored data \n+     * @throws IllegalStateException if percentile implementation has been\n+     *  overridden and the supplied implementation does not support setQuantile\n+     * values\n+     */\n+    public double getPercentile(double p) {\n+        if (percentileImpl instanceof Percentile) {\n+            ((Percentile) percentileImpl).setQuantile(p);\n+        } else {\n+            try {\n+                percentileImpl.getClass().getMethod(\"setQuantile\", \n+                        new Class[] {Double.TYPE}).invoke(percentileImpl,\n+                                new Object[] {Double.valueOf(p)});\n+            } catch (NoSuchMethodException e1) { // Setter guard should prevent\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"percentile implementation {0} does not support setQuantile\",\n+                      percentileImpl.getClass().getName());\n+            } catch (IllegalAccessException e2) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"cannot access setQuantile method in percentile implementation {0}\",\n+                      percentileImpl.getClass().getName());\n+            } catch (InvocationTargetException e3) {\n+                throw MathRuntimeException.createIllegalArgumentException(e3.getCause()); \n+            }\n+        }\n+        return apply(percentileImpl);\n+    }\n+    \n+    /**\n+     * Generates a text report displaying univariate statistics from values\n+     * that have been added.  Each statistic is displayed on a separate\n+     * line.\n+     * \n+     * @return String with line feeds displaying statistics\n+     */\n+    @Override\n+    public String toString() {\n+        StringBuffer outBuffer = new StringBuffer();\n+        String endl = \"\\n\";\n+        outBuffer.append(\"DescriptiveStatistics:\").append(endl);\n+        outBuffer.append(\"n: \").append(getN()).append(endl);\n+        outBuffer.append(\"min: \").append(getMin()).append(endl);\n+        outBuffer.append(\"max: \").append(getMax()).append(endl);\n+        outBuffer.append(\"mean: \").append(getMean()).append(endl);\n+        outBuffer.append(\"std dev: \").append(getStandardDeviation())\n+            .append(endl);\n+        outBuffer.append(\"median: \").append(getPercentile(50)).append(endl);\n+        outBuffer.append(\"skewness: \").append(getSkewness()).append(endl);\n+        outBuffer.append(\"kurtosis: \").append(getKurtosis()).append(endl);\n+        return outBuffer.toString();\n+    }\n+    \n+    /**\n+     * Apply the given statistic to the data associated with this set of statistics.\n+     * @param stat the statistic to apply\n+     * @return the computed value of the statistic.\n+     */\n+    public double apply(UnivariateStatistic stat) {\n+        return stat.evaluate(eDA.getInternalValues(), eDA.start(), eDA.getNumElements());\n+    }\n+\n+    // Implementation getters and setter\n+    \n+    /**\n+     * Returns the currently configured mean implementation.\n+     * \n+     * @return the UnivariateStatistic implementing the mean\n+     * @since 1.2\n+     */\n+    public synchronized UnivariateStatistic getMeanImpl() {\n+        return meanImpl;\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the mean.</p>\n+     * \n+     * @param meanImpl the UnivariateStatistic instance to use\n+     * for computing the mean\n+     * @since 1.2\n+     */\n+    public synchronized void setMeanImpl(UnivariateStatistic meanImpl) {\n+        this.meanImpl = meanImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured geometric mean implementation.\n+     * \n+     * @return the UnivariateStatistic implementing the geometric mean\n+     * @since 1.2\n+     */\n+    public synchronized UnivariateStatistic getGeometricMeanImpl() {\n+        return geometricMeanImpl;\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the gemoetric mean.</p>\n+     * \n+     * @param geometricMeanImpl the UnivariateStatistic instance to use\n+     * for computing the geometric mean\n+     * @since 1.2\n+     */\n+    public synchronized void setGeometricMeanImpl(\n+            UnivariateStatistic geometricMeanImpl) {\n+        this.geometricMeanImpl = geometricMeanImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured kurtosis implementation.\n+     * \n+     * @return the UnivariateStatistic implementing the kurtosis\n+     * @since 1.2\n+     */\n+    public synchronized UnivariateStatistic getKurtosisImpl() {\n+        return kurtosisImpl;\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the kurtosis.</p>\n+     * \n+     * @param kurtosisImpl the UnivariateStatistic instance to use\n+     * for computing the kurtosis\n+     * @since 1.2\n+     */\n+    public synchronized void setKurtosisImpl(UnivariateStatistic kurtosisImpl) {\n+        this.kurtosisImpl = kurtosisImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured maximum implementation.\n+     * \n+     * @return the UnivariateStatistic implementing the maximum\n+     * @since 1.2\n+     */\n+    public synchronized UnivariateStatistic getMaxImpl() {\n+        return maxImpl;\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the maximum.</p>\n+     * \n+     * @param maxImpl the UnivariateStatistic instance to use\n+     * for computing the maximum\n+     * @since 1.2\n+     */\n+    public synchronized void setMaxImpl(UnivariateStatistic maxImpl) {\n+        this.maxImpl = maxImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured minimum implementation.\n+     * \n+     * @return the UnivariateStatistic implementing the minimum\n+     * @since 1.2\n+     */\n+    public synchronized UnivariateStatistic getMinImpl() {\n+        return minImpl;\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the minimum.</p>\n+     * \n+     * @param minImpl the UnivariateStatistic instance to use\n+     * for computing the minimum\n+     * @since 1.2\n+     */\n+    public synchronized void setMinImpl(UnivariateStatistic minImpl) {\n+        this.minImpl = minImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured percentile implementation.\n+     * \n+     * @return the UnivariateStatistic implementing the percentile\n+     * @since 1.2\n+     */\n+    public synchronized UnivariateStatistic getPercentileImpl() {\n+        return percentileImpl;\n+    }\n+\n+    /**\n+     * Sets the implementation to be used by {@link #getPercentile(double)}.\n+     * The supplied <code>UnivariateStatistic</code> must provide a\n+     * <code>setQuantile(double)</code> method; otherwise \n+     * <code>IllegalArgumentException</code> is thrown.\n+     * \n+     * @param percentileImpl the percentileImpl to set\n+     * @throws IllegalArgumentException if the supplied implementation does not\n+     *  provide a <code>setQuantile</code> method\n+     * @since 1.2\n+     */\n+    public synchronized void setPercentileImpl(\n+            UnivariateStatistic percentileImpl) {\n+        try {\n+            percentileImpl.getClass().getMethod(\"setQuantile\", \n+                    new Class[] {Double.TYPE}).invoke(percentileImpl,\n+                            new Object[] {Double.valueOf(50.0d)});\n+        } catch (NoSuchMethodException e1) { \n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"percentile implementation {0} does not support setQuantile\",\n+                  percentileImpl.getClass().getName());\n+        } catch (IllegalAccessException e2) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"cannot access setQuantile method in percentile implementation {0}\",\n+                  percentileImpl.getClass().getName());\n+        } catch (InvocationTargetException e3) {\n+            throw MathRuntimeException.createIllegalArgumentException(e3.getCause()); \n+        }\n+        this.percentileImpl = percentileImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured skewness implementation.\n+     * \n+     * @return the UnivariateStatistic implementing the skewness\n+     * @since 1.2\n+     */\n+    public synchronized UnivariateStatistic getSkewnessImpl() {\n+        return skewnessImpl;\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the skewness.</p>\n+     * \n+     * @param skewnessImpl the UnivariateStatistic instance to use\n+     * for computing the skewness\n+     * @since 1.2\n+     */\n+    public synchronized void setSkewnessImpl(\n+            UnivariateStatistic skewnessImpl) {\n+        this.skewnessImpl = skewnessImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured variance implementation.\n+     * \n+     * @return the UnivariateStatistic implementing the variance\n+     * @since 1.2\n+     */\n+    public synchronized UnivariateStatistic getVarianceImpl() {\n+        return varianceImpl;\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the variance.</p>\n+     * \n+     * @param varianceImpl the UnivariateStatistic instance to use\n+     * for computing the variance\n+     * @since 1.2\n+     */\n+    public synchronized void setVarianceImpl(\n+            UnivariateStatistic varianceImpl) {\n+        this.varianceImpl = varianceImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured sum of squares implementation.\n+     * \n+     * @return the UnivariateStatistic implementing the sum of squares\n+     * @since 1.2\n+     */\n+    public synchronized UnivariateStatistic getSumsqImpl() {\n+        return sumsqImpl;\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the sum of squares.</p>\n+     * \n+     * @param sumsqImpl the UnivariateStatistic instance to use\n+     * for computing the sum of squares\n+     * @since 1.2\n+     */\n+    public synchronized void setSumsqImpl(UnivariateStatistic sumsqImpl) {\n+        this.sumsqImpl = sumsqImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured sum implementation.\n+     * \n+     * @return the UnivariateStatistic implementing the sum\n+     * @since 1.2\n+     */\n+    public synchronized UnivariateStatistic getSumImpl() {\n+        return sumImpl;\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the sum.</p>\n+     * \n+     * @param sumImpl the UnivariateStatistic instance to use\n+     * for computing the sum\n+     * @since 1.2\n+     */\n+    public synchronized void setSumImpl(UnivariateStatistic sumImpl) {\n+        this.sumImpl = sumImpl;\n+    }  \n+    \n+    /**\n+     * Returns a copy of this DescriptiveStatistics instance with the same internal state.\n+     * \n+     * @return a copy of this\n+     */\n+    public DescriptiveStatistics copy() {\n+        DescriptiveStatistics result = new DescriptiveStatistics();\n+        copy(this, result);\n+        return result; \n+    }\n+     \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source DescriptiveStatistics to copy\n+     * @param dest DescriptiveStatistics to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(DescriptiveStatistics source, DescriptiveStatistics dest) {\n+        // Copy data and window size\n+        dest.eDA = source.eDA.copy();\n+        dest.windowSize = source.windowSize;\n+        \n+        // Copy implementations\n+        dest.maxImpl = source.maxImpl.copy();\n+        dest.meanImpl = source.meanImpl.copy();\n+        dest.minImpl = source.minImpl.copy();\n+        dest.sumImpl = source.sumImpl.copy();\n+        dest.varianceImpl = source.varianceImpl.copy();\n+        dest.sumsqImpl = source.sumsqImpl.copy();\n+        dest.geometricMeanImpl = source.geometricMeanImpl.copy();\n+        dest.kurtosisImpl = source.kurtosisImpl;\n+        dest.skewnessImpl = source.skewnessImpl;\n+        dest.percentileImpl = source.percentileImpl;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/MultivariateSummaryStatistics.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.stat.descriptive.moment.GeometricMean;\n+import org.apache.commons.math.stat.descriptive.moment.Mean;\n+import org.apache.commons.math.stat.descriptive.moment.VectorialCovariance;\n+import org.apache.commons.math.stat.descriptive.rank.Max;\n+import org.apache.commons.math.stat.descriptive.rank.Min;\n+import org.apache.commons.math.stat.descriptive.summary.Sum;\n+import org.apache.commons.math.stat.descriptive.summary.SumOfLogs;\n+import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * <p>Computes summary statistics for a stream of n-tuples added using the \n+ * {@link #addValue(double[]) addValue} method. The data values are not stored\n+ * in memory, so this class can be used to compute statistics for very large\n+ * n-tuple streams.</p>\n+ * \n+ * <p>The {@link StorelessUnivariateStatistic} instances used to maintain\n+ * summary state and compute statistics are configurable via setters.\n+ * For example, the default implementation for the mean can be overridden by\n+ * calling {@link #setMeanImpl(StorelessUnivariateStatistic[])}. Actual\n+ * parameters to these methods must implement the \n+ * {@link StorelessUnivariateStatistic} interface and configuration must be\n+ * completed before <code>addValue</code> is called. No configuration is\n+ * necessary to use the default, commons-math provided implementations.</p>\n+ * \n+ * <p>To compute statistics for a stream of n-tuples, construct a\n+ * MultivariateStatistics instance with dimension n and then use \n+ * {@link #addValue(double[])} to add n-tuples. The <code>getXxx</code>\n+ * methods where Xxx is a statistic return an array of <code>double</code>\n+ * values, where for <code>i = 0,...,n-1</code> the i<sup>th</sup> array element is the\n+ * value of the given statistic for data range consisting of the i<sup>th</sup> element of\n+ * each of the input n-tuples.  For example, if <code>addValue</code> is called\n+ * with actual parameters {0, 1, 2}, then {3, 4, 5} and finally {6, 7, 8},\n+ * <code>getSum</code> will return a three-element array with values\n+ * {0+3+6, 1+4+7, 2+5+8}</p>\n+ * \n+ * <p>Note: This class is not thread-safe. Use \n+ * {@link SynchronizedMultivariateSummaryStatistics} if concurrent access from multiple\n+ * threads is required.</p>\n+ *\n+ * @since 1.2\n+ * @version $Revision$ $Date$\n+ */\n+public class MultivariateSummaryStatistics\n+  implements StatisticalMultivariateSummary, Serializable {\n+\n+    /** Serialization UID */\n+    private static final long serialVersionUID = 2271900808994826718L;\n+\n+    /**\n+     * Construct a MultivariateSummaryStatistics instance\n+     * @param k dimension of the data\n+     * @param isCovarianceBiasCorrected if true, the unbiased sample\n+     * covariance is computed, otherwise the biased population covariance\n+     * is computed\n+     */\n+    public MultivariateSummaryStatistics(int k, boolean isCovarianceBiasCorrected) {\n+        this.k = k;\n+\n+        sumImpl     = new StorelessUnivariateStatistic[k];\n+        sumSqImpl   = new StorelessUnivariateStatistic[k];\n+        minImpl     = new StorelessUnivariateStatistic[k];\n+        maxImpl     = new StorelessUnivariateStatistic[k];\n+        sumLogImpl  = new StorelessUnivariateStatistic[k];\n+        geoMeanImpl = new StorelessUnivariateStatistic[k];\n+        meanImpl    = new StorelessUnivariateStatistic[k];\n+\n+        for (int i = 0; i < k; ++i) {\n+            sumImpl[i]     = new Sum();\n+            sumSqImpl[i]   = new SumOfSquares();\n+            minImpl[i]     = new Min();\n+            maxImpl[i]     = new Max();\n+            sumLogImpl[i]  = new SumOfLogs();\n+            geoMeanImpl[i] = new GeometricMean();\n+            meanImpl[i]    = new Mean();\n+        }\n+\n+        covarianceImpl =\n+            new VectorialCovariance(k, isCovarianceBiasCorrected);\n+\n+    }\n+\n+    /** Dimension of the data. */\n+    private int k;\n+\n+    /** Count of values that have been added */\n+    private long n = 0;\n+    \n+    /** Sum statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] sumImpl;\n+    \n+    /** Sum of squares statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] sumSqImpl;\n+    \n+    /** Minimum statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] minImpl;\n+    \n+    /** Maximum statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] maxImpl;\n+    \n+    /** Sum of log statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] sumLogImpl;\n+    \n+    /** Geometric mean statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] geoMeanImpl;\n+    \n+    /** Mean statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic[] meanImpl;\n+    \n+    /** Covariance statistic implementation - cannot be reset. */\n+    private VectorialCovariance covarianceImpl;\n+\n+    /**\n+     * Add an n-tuple to the data\n+     * \n+     * @param value  the n-tuple to add\n+     * @throws DimensionMismatchException if the length of the array\n+     * does not match the one used at construction\n+     */\n+    public void addValue(double[] value)\n+      throws DimensionMismatchException {\n+        checkDimension(value.length);\n+        for (int i = 0; i < k; ++i) {\n+            double v = value[i];\n+            sumImpl[i].increment(v);\n+            sumSqImpl[i].increment(v);\n+            minImpl[i].increment(v);\n+            maxImpl[i].increment(v);\n+            sumLogImpl[i].increment(v);\n+            geoMeanImpl[i].increment(v);\n+            meanImpl[i].increment(v);\n+        }\n+        covarianceImpl.increment(value);\n+        n++;\n+    }\n+\n+    /** \n+     * Returns the dimension of the data\n+     * @return The dimension of the data\n+     */\n+    public int getDimension() {\n+        return k;\n+    }\n+\n+    /** \n+     * Returns the number of available values\n+     * @return The number of available values\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+\n+    /**\n+     * Returns an array of the results of a statistic.\n+     * @param stats univariate statistic array\n+     * @return results array\n+     */\n+    private double[] getResults(StorelessUnivariateStatistic[] stats) {\n+        double[] results = new double[stats.length];\n+        for (int i = 0; i < results.length; ++i) {\n+            results[i] = stats[i].getResult();\n+        }\n+        return results;\n+    }\n+\n+    /**\n+     * Returns an array whose i<sup>th</sup> entry is the sum of the\n+     * i<sup>th</sup> entries of the arrays that have been added using \n+     * {@link #addValue(double[])}\n+     * \n+     * @return the array of component sums\n+     */\n+    public double[] getSum() {\n+        return getResults(sumImpl);\n+    }\n+\n+    /**\n+     * Returns an array whose i<sup>th</sup> entry is the sum of squares of the\n+     * i<sup>th</sup> entries of the arrays that have been added using \n+     * {@link #addValue(double[])}\n+     * \n+     * @return the array of component sums of squares\n+     */\n+    public double[] getSumSq() {\n+        return getResults(sumSqImpl);\n+    }\n+\n+    /**\n+     * Returns an array whose i<sup>th</sup> entry is the sum of logs of the\n+     * i<sup>th</sup> entries of the arrays that have been added using \n+     * {@link #addValue(double[])}\n+     * \n+     * @return the array of component log sums\n+     */\n+    public double[] getSumLog() {\n+        return getResults(sumLogImpl);\n+    }\n+\n+    /**\n+     * Returns an array whose i<sup>th</sup> entry is the mean of the\n+     * i<sup>th</sup> entries of the arrays that have been added using \n+     * {@link #addValue(double[])}\n+     * \n+     * @return the array of component means\n+     */\n+    public double[] getMean() {\n+        return getResults(meanImpl);\n+    }\n+\n+    /**\n+     * Returns an array whose i<sup>th</sup> entry is the standard deviation of the\n+     * i<sup>th</sup> entries of the arrays that have been added using \n+     * {@link #addValue(double[])}\n+     * \n+     * @return the array of component standard deviations\n+     */\n+    public double[] getStandardDeviation() {\n+        double[] stdDev = new double[k];\n+        if (getN() < 1) {\n+            Arrays.fill(stdDev, Double.NaN);\n+        } else if (getN() < 2) {\n+            Arrays.fill(stdDev, 0.0);\n+        } else {\n+            RealMatrix matrix = covarianceImpl.getResult();\n+            for (int i = 0; i < k; ++i) {\n+                stdDev[i] = Math.sqrt(matrix.getEntry(i, i));\n+            }\n+        }\n+        return stdDev;\n+    }\n+\n+    /**\n+     * Returns the covariance matrix of the values that have been added.\n+     *\n+     * @return the covariance matrix \n+     */\n+    public RealMatrix getCovariance() {\n+        return covarianceImpl.getResult();\n+    }\n+\n+    /**\n+     * Returns an array whose i<sup>th</sup> entry is the maximum of the\n+     * i<sup>th</sup> entries of the arrays that have been added using \n+     * {@link #addValue(double[])}\n+     * \n+     * @return the array of component maxima\n+     */\n+    public double[] getMax() {\n+        return getResults(maxImpl);\n+    }\n+\n+    /**\n+     * Returns an array whose i<sup>th</sup> entry is the minimum of the\n+     * i<sup>th</sup> entries of the arrays that have been added using \n+     * {@link #addValue(double[])}\n+     * \n+     * @return the array of component minima\n+     */\n+    public double[] getMin() {\n+        return getResults(minImpl);\n+    }\n+\n+    /**\n+     * Returns an array whose i<sup>th</sup> entry is the geometric mean of the\n+     * i<sup>th</sup> entries of the arrays that have been added using \n+     * {@link #addValue(double[])}\n+     * \n+     * @return the array of component geometric means\n+     */\n+    public double[] getGeometricMean() {\n+        return getResults(geoMeanImpl);\n+    }\n+    \n+    /**\n+     * Generates a text report displaying\n+     * summary statistics from values that\n+     * have been added.\n+     * @return String with line feeds displaying statistics\n+     */\n+    @Override\n+    public String toString() {\n+        StringBuffer outBuffer = new StringBuffer();\n+        outBuffer.append(\"MultivariateSummaryStatistics:\\n\");\n+        outBuffer.append(\"n: \" + getN() + \"\\n\");\n+        append(outBuffer, getMin(), \"min: \", \", \", \"\\n\");\n+        append(outBuffer, getMax(), \"max: \", \", \", \"\\n\");\n+        append(outBuffer, getMean(), \"mean: \", \", \", \"\\n\");\n+        append(outBuffer, getGeometricMean(), \"geometric mean: \", \", \", \"\\n\");\n+        append(outBuffer, getSumSq(), \"sum of squares: \", \", \", \"\\n\");\n+        append(outBuffer, getSumLog(), \"sum of logarithms: \", \", \", \"\\n\");\n+        append(outBuffer, getStandardDeviation(), \"standard deviation: \", \", \", \"\\n\");\n+        outBuffer.append(\"covariance: \" + getCovariance().toString() + \"\\n\");\n+        return outBuffer.toString();\n+    }\n+\n+    /**\n+     * Append a text representation of an array to a buffer.\n+     * @param buffer buffer to fill\n+     * @param data data array\n+     * @param prefix text prefix\n+     * @param separator elements separator\n+     * @param suffix text suffix\n+     */\n+    private void append(StringBuffer buffer, double[] data,\n+                        String prefix, String separator, String suffix) {\n+        buffer.append(prefix);\n+        for (int i = 0; i < data.length; ++i) {\n+            if (i > 0) {\n+                buffer.append(separator);\n+            }\n+            buffer.append(data[i]);\n+        }\n+        buffer.append(suffix);\n+    }\n+\n+    /** \n+     * Resets all statistics and storage\n+     */\n+    public void clear() {\n+        this.n = 0;\n+        for (int i = 0; i < k; ++i) {\n+            minImpl[i].clear();\n+            maxImpl[i].clear();\n+            sumImpl[i].clear();\n+            sumLogImpl[i].clear();\n+            sumSqImpl[i].clear();\n+            geoMeanImpl[i].clear();\n+            meanImpl[i].clear();\n+        }\n+        covarianceImpl.clear();\n+    }\n+    \n+    /**\n+     * Returns true iff <code>object</code> is a <code>SummaryStatistics</code>\n+     * instance and all statistics have the same values as this.\n+     * @param object the object to test equality against.\n+     * @return true if object equals this\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (object == this ) {\n+            return true;\n+        }\n+        if (object instanceof MultivariateSummaryStatistics == false) {\n+            return false;\n+        }\n+        MultivariateSummaryStatistics stat = (MultivariateSummaryStatistics) object;\n+        return (MathUtils.equals(stat.getGeometricMean(), \n+                this.getGeometricMean()) &&\n+                MathUtils.equals(stat.getMax(), this.getMax()) && \n+                MathUtils.equals(stat.getMean(),this.getMean()) &&\n+                MathUtils.equals(stat.getMin(),this.getMin()) &&\n+                MathUtils.equals(stat.getN(), this.getN()) &&\n+                MathUtils.equals(stat.getSum(), this.getSum()) &&\n+                MathUtils.equals(stat.getSumSq(),this.getSumSq()) &&\n+                MathUtils.equals(stat.getSumLog(),this.getSumLog()) &&\n+                stat.getCovariance().equals(this.getCovariance()));\n+    }\n+    \n+    /**\n+     * Returns hash code based on values of statistics\n+     * \n+     * @return hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        int result = 31 + MathUtils.hash(getGeometricMean());\n+        result = result * 31 + MathUtils.hash(getGeometricMean());\n+        result = result * 31 + MathUtils.hash(getMax());\n+        result = result * 31 + MathUtils.hash(getMean());\n+        result = result * 31 + MathUtils.hash(getMin());\n+        result = result * 31 + MathUtils.hash(getN());\n+        result = result * 31 + MathUtils.hash(getSum());\n+        result = result * 31 + MathUtils.hash(getSumSq());\n+        result = result * 31 + MathUtils.hash(getSumLog());\n+        result = result * 31 + getCovariance().hashCode();\n+        return result;\n+    }\n+\n+    // Getters and setters for statistics implementations\n+    /**\n+     * Sets statistics implementations.\n+     * @param newImpl new implementations for statistics\n+     * @param oldImpl old implementations for statistics\n+     * @throws DimensionMismatchException if the array dimension\n+     * does not match the one used at construction\n+     * @throws IllegalStateException if data has already been added\n+     *  (i.e if n > 0)\n+     */\n+    private void setImpl(StorelessUnivariateStatistic[] newImpl,\n+                         StorelessUnivariateStatistic[] oldImpl)\n+       throws DimensionMismatchException, IllegalStateException {\n+        checkEmpty();\n+        checkDimension(newImpl.length);\n+        System.arraycopy(newImpl, 0, oldImpl, 0, newImpl.length);\n+    }\n+\n+    /**\n+     * Returns the currently configured Sum implementation\n+     * \n+     * @return the StorelessUnivariateStatistic implementing the sum\n+     */\n+    public StorelessUnivariateStatistic[] getSumImpl() {\n+        return sumImpl.clone();\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the Sum.</p>\n+     * <p>This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * otherwise an IllegalStateException will be thrown.</p>\n+     * \n+     * @param sumImpl the StorelessUnivariateStatistic instance to use\n+     * for computing the Sum\n+     * @throws DimensionMismatchException if the array dimension\n+     * does not match the one used at construction\n+     * @throws IllegalStateException if data has already been added\n+     *  (i.e if n > 0)\n+     */\n+    public void setSumImpl(StorelessUnivariateStatistic[] sumImpl)\n+      throws DimensionMismatchException {\n+        setImpl(sumImpl, this.sumImpl);\n+    }\n+\n+    /**\n+     * Returns the currently configured sum of squares implementation\n+     * \n+     * @return the StorelessUnivariateStatistic implementing the sum of squares\n+     */\n+    public StorelessUnivariateStatistic[] getSumsqImpl() {\n+        return sumSqImpl.clone();\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the sum of squares.</p>\n+     * <p>This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * otherwise an IllegalStateException will be thrown.</p>\n+     * \n+     * @param sumsqImpl the StorelessUnivariateStatistic instance to use\n+     * for computing the sum of squares\n+     * @throws DimensionMismatchException if the array dimension\n+     * does not match the one used at construction\n+     * @throws IllegalStateException if data has already been added\n+     *  (i.e if n > 0)\n+     */\n+    public void setSumsqImpl(StorelessUnivariateStatistic[] sumsqImpl)\n+      throws DimensionMismatchException {\n+        setImpl(sumsqImpl, this.sumSqImpl);\n+    }\n+\n+    /**\n+     * Returns the currently configured minimum implementation\n+     * \n+     * @return the StorelessUnivariateStatistic implementing the minimum\n+     */\n+    public StorelessUnivariateStatistic[] getMinImpl() {\n+        return minImpl.clone();\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the minimum.</p>\n+     * <p>This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * otherwise an IllegalStateException will be thrown.</p>\n+     * \n+     * @param minImpl the StorelessUnivariateStatistic instance to use\n+     * for computing the minimum\n+     * @throws DimensionMismatchException if the array dimension\n+     * does not match the one used at construction\n+     * @throws IllegalStateException if data has already been added\n+     *  (i.e if n > 0)\n+     */\n+    public void setMinImpl(StorelessUnivariateStatistic[] minImpl)\n+      throws DimensionMismatchException {\n+        setImpl(minImpl, this.minImpl);\n+    }\n+\n+    /**\n+     * Returns the currently configured maximum implementation\n+     * \n+     * @return the StorelessUnivariateStatistic implementing the maximum\n+     */\n+    public StorelessUnivariateStatistic[] getMaxImpl() {\n+        return maxImpl.clone();\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the maximum.</p>\n+     * <p>This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * otherwise an IllegalStateException will be thrown.</p>\n+     * \n+     * @param maxImpl the StorelessUnivariateStatistic instance to use\n+     * for computing the maximum\n+     * @throws DimensionMismatchException if the array dimension\n+     * does not match the one used at construction\n+     * @throws IllegalStateException if data has already been added\n+     *  (i.e if n > 0)\n+     */\n+    public void setMaxImpl(StorelessUnivariateStatistic[] maxImpl)\n+      throws DimensionMismatchException {\n+        setImpl(maxImpl, this.maxImpl);\n+    }\n+\n+    /**\n+     * Returns the currently configured sum of logs implementation\n+     * \n+     * @return the StorelessUnivariateStatistic implementing the log sum\n+     */\n+    public StorelessUnivariateStatistic[] getSumLogImpl() {\n+        return sumLogImpl.clone();\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the sum of logs.</p>\n+     * <p>This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * otherwise an IllegalStateException will be thrown.</p>\n+     * \n+     * @param sumLogImpl the StorelessUnivariateStatistic instance to use\n+     * for computing the log sum\n+     * @throws DimensionMismatchException if the array dimension\n+     * does not match the one used at construction\n+     * @throws IllegalStateException if data has already been added \n+     *  (i.e if n > 0)\n+     */\n+    public void setSumLogImpl(StorelessUnivariateStatistic[] sumLogImpl)\n+      throws DimensionMismatchException {\n+        setImpl(sumLogImpl, this.sumLogImpl);\n+    }\n+\n+    /**\n+     * Returns the currently configured geometric mean implementation\n+     * \n+     * @return the StorelessUnivariateStatistic implementing the geometric mean\n+     */\n+    public StorelessUnivariateStatistic[] getGeoMeanImpl() {\n+        return geoMeanImpl.clone();\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the geometric mean.</p>\n+     * <p>This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * otherwise an IllegalStateException will be thrown.</p>\n+     * \n+     * @param geoMeanImpl the StorelessUnivariateStatistic instance to use\n+     * for computing the geometric mean\n+     * @throws DimensionMismatchException if the array dimension\n+     * does not match the one used at construction\n+     * @throws IllegalStateException if data has already been added\n+     *  (i.e if n > 0)\n+     */\n+    public void setGeoMeanImpl(StorelessUnivariateStatistic[] geoMeanImpl)\n+      throws DimensionMismatchException {\n+        setImpl(geoMeanImpl, this.geoMeanImpl);\n+    }\n+\n+    /**\n+     * Returns the currently configured mean implementation\n+     * \n+     * @return the StorelessUnivariateStatistic implementing the mean\n+     */\n+    public StorelessUnivariateStatistic[] getMeanImpl() {\n+        return meanImpl.clone();\n+    }\n+\n+    /**\n+     * <p>Sets the implementation for the mean.</p>\n+     * <p>This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double[]) addValue} has been used to add data; \n+     * otherwise an IllegalStateException will be thrown.</p>\n+     * \n+     * @param meanImpl the StorelessUnivariateStatistic instance to use\n+     * for computing the mean\n+     * @throws DimensionMismatchException if the array dimension\n+     * does not match the one used at construction\n+     * @throws IllegalStateException if data has already been added\n+     *  (i.e if n > 0)\n+     */\n+    public void setMeanImpl(StorelessUnivariateStatistic[] meanImpl)\n+      throws DimensionMismatchException {\n+        setImpl(meanImpl, this.meanImpl);\n+    }\n+\n+    /**\n+     * Throws IllegalStateException if n > 0.\n+     */\n+    private void checkEmpty() {\n+        if (n > 0) {\n+            throw MathRuntimeException.createIllegalStateException(\n+                    \"{0} values have been added before statistic is configured\",\n+                    n);\n+        }\n+    }\n+\n+    /**\n+     * Throws DimensionMismatchException if dimension != k.\n+     * @param dimension dimension to check\n+     * @throws DimensionMismatchException if dimension != k\n+     */\n+    private void checkDimension(int dimension)\n+      throws DimensionMismatchException {\n+        if (dimension != k) {\n+            throw new DimensionMismatchException(dimension, k);\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalMultivariateSummary.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import org.apache.commons.math.linear.RealMatrix;\n+\n+/**\n+ *  Reporting interface for basic multivariate statistics.\n+ *\n+ * @since 1.2\n+ * @version $Revision$ $Date$\n+ */\n+public interface StatisticalMultivariateSummary {\n+    /** \n+     * Returns the dimension of the data\n+     * @return The dimension of the data\n+     */\n+    public int getDimension();\n+    /**\n+     * Returns an array whose i<sup>th</sup> entry is the\n+     * mean of the i<sup>th</sup> entries of the arrays\n+     * that correspond to each multivariate sample\n+     * \n+     * @return the array of component means\n+     */\n+    public abstract double[] getMean();\n+    /** \n+     * Returns the covariance of the available values.\n+     * @return The covariance, null if no multivariate sample\n+     * have been added or a zeroed matrix for a single value set.  \n+     */\n+    public abstract RealMatrix getCovariance();\n+    /**\n+     * Returns an array whose i<sup>th</sup> entry is the\n+     * standard deviation of the i<sup>th</sup> entries of the arrays\n+     * that correspond to each multivariate sample\n+     * \n+     * @return the array of component standard deviations\n+     */\n+    public abstract double[] getStandardDeviation();\n+    /**\n+     * Returns an array whose i<sup>th</sup> entry is the\n+     * maximum of the i<sup>th</sup> entries of the arrays\n+     * that correspond to each multivariate sample\n+     * \n+     * @return the array of component maxima\n+     */\n+    public abstract double[] getMax();\n+    /**\n+     * Returns an array whose i<sup>th</sup> entry is the\n+     * minimum of the i<sup>th</sup> entries of the arrays\n+     * that correspond to each multivariate sample\n+     * \n+     * @return the array of component minima\n+     */\n+    public abstract double[] getMin();\n+    /** \n+     * Returns the number of available values\n+     * @return The number of available values\n+     */\n+    public abstract long getN();\n+    /**\n+     * Returns an array whose i<sup>th</sup> entry is the\n+     * geometric mean of the i<sup>th</sup> entries of the arrays\n+     * that correspond to each multivariate sample\n+     * \n+     * @return the array of component geometric means\n+     */\n+    public double[] getGeometricMean();\n+    /**\n+     * Returns an array whose i<sup>th</sup> entry is the\n+     * sum of the i<sup>th</sup> entries of the arrays\n+     * that correspond to each multivariate sample\n+     * \n+     * @return the array of component sums\n+     */\n+    public abstract double[] getSum();\n+    /**\n+     * Returns an array whose i<sup>th</sup> entry is the\n+     * sum of squares of the i<sup>th</sup> entries of the arrays\n+     * that correspond to each multivariate sample\n+     * \n+     * @return the array of component sums of squares\n+     */\n+    public abstract double[] getSumSq();\n+    /**\n+     * Returns an array whose i<sup>th</sup> entry is the\n+     * sum of logs of the i<sup>th</sup> entries of the arrays\n+     * that correspond to each multivariate sample\n+     * \n+     * @return the array of component log sums\n+     */\n+    public abstract double[] getSumLog();\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalSummary.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+/**\n+ *  Reporting interface for basic univariate statistics.\n+ *\n+  * @version $Revision$ $Date$\n+ */\n+public interface StatisticalSummary {\n+    /** \n+     * Returns the <a href=\"http://www.xycoon.com/arithmetic_mean.htm\">\n+     * arithmetic mean </a> of the available values \n+     * @return The mean or Double.NaN if no values have been added.\n+     */\n+    public abstract double getMean();\n+    /** \n+     * Returns the variance of the available values.\n+     * @return The variance, Double.NaN if no values have been added \n+     * or 0.0 for a single value set.  \n+     */\n+    public abstract double getVariance();\n+    /** \n+     * Returns the standard deviation of the available values.\n+     * @return The standard deviation, Double.NaN if no values have been added \n+     * or 0.0 for a single value set. \n+     */\n+    public abstract double getStandardDeviation();\n+    /** \n+     * Returns the maximum of the available values\n+     * @return The max or Double.NaN if no values have been added.\n+     */\n+    public abstract double getMax();\n+    /** \n+    * Returns the minimum of the available values\n+    * @return The min or Double.NaN if no values have been added.\n+    */\n+    public abstract double getMin();\n+    /** \n+     * Returns the number of available values\n+     * @return The number of available values\n+     */\n+    public abstract long getN();\n+    /**\n+     * Returns the sum of the values that have been added to Univariate.\n+     * @return The sum or Double.NaN if no values have been added\n+     */\n+    public abstract double getSum();\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.io.Serializable;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ *  Value object representing the results of a univariate statistical summary.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class StatisticalSummaryValues implements Serializable, \n+    StatisticalSummary {\n+   \n+    /** Serialization id */\n+    private static final long serialVersionUID = -5108854841843722536L;\n+\n+    /** The sample mean */\n+    private final double mean;\n+    \n+    /** The sample variance */\n+    private final double variance;\n+    \n+    /** The number of observations in the sample */\n+    private final long n;\n+    \n+    /** The maximum value */\n+    private final double max;\n+    \n+    /** The minimum value */\n+    private final double min;\n+    \n+    /** The sum of the sample values */\n+    private final double sum;\n+    \n+    /**\n+      * Constructor\n+      * \n+      * @param mean  the sample mean\n+      * @param variance  the sample variance\n+      * @param n  the number of observations in the sample \n+      * @param max  the maximum value\n+      * @param min  the minimum value\n+      * @param sum  the sum of the values\n+     */\n+    public StatisticalSummaryValues(double mean, double variance, long n,\n+        double max, double min, double sum) {\n+        super();\n+        this.mean = mean;\n+        this.variance = variance;\n+        this.n = n;\n+        this.max = max;\n+        this.min = min;\n+        this.sum = sum;\n+    }\n+\n+    /**\n+     * @return Returns the max.\n+     */\n+    public double getMax() {\n+        return max;\n+    }\n+\n+    /**\n+     * @return Returns the mean.\n+     */\n+    public double getMean() {\n+        return mean;\n+    }\n+\n+    /**\n+     * @return Returns the min.\n+     */\n+    public double getMin() {\n+        return min;\n+    }\n+\n+    /**\n+     * @return Returns the number of values.\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+\n+    /**\n+     * @return Returns the sum.\n+     */\n+    public double getSum() {\n+        return sum;\n+    }\n+    \n+    /**\n+     * @return Returns the standard deviation\n+     */\n+    public double getStandardDeviation() {\n+        return Math.sqrt(variance);\n+    }\n+\n+    /**\n+     * @return Returns the variance.\n+     */\n+    public double getVariance() {\n+        return variance;\n+    }\n+    \n+    /**\n+     * Returns true iff <code>object</code> is a \n+     * <code>StatisticalSummaryValues</code> instance and all statistics have\n+     *  the same values as this.\n+     * \n+     * @param object the object to test equality against.\n+     * @return true if object equals this\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (object == this ) {\n+            return true;\n+        }\n+        if (object instanceof StatisticalSummaryValues == false) {\n+            return false;\n+        }\n+        StatisticalSummaryValues stat = (StatisticalSummaryValues) object;\n+        return (MathUtils.equals(stat.getMax(), this.getMax()) && \n+                MathUtils.equals(stat.getMean(),this.getMean()) &&\n+                MathUtils.equals(stat.getMin(),this.getMin()) &&\n+                MathUtils.equals(stat.getN(), this.getN()) &&\n+                MathUtils.equals(stat.getSum(), this.getSum()) &&\n+                MathUtils.equals(stat.getVariance(),this.getVariance()));\n+    }\n+    \n+    /**\n+     * Returns hash code based on values of statistics\n+     * \n+     * @return hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        int result = 31 + MathUtils.hash(getMax());\n+        result = result * 31 + MathUtils.hash(getMean());\n+        result = result * 31 + MathUtils.hash(getMin());\n+        result = result * 31 + MathUtils.hash(getN());\n+        result = result * 31 + MathUtils.hash(getSum());\n+        result = result * 31 + MathUtils.hash(getVariance());\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatistic.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+/**\n+ * Extends the definition of {@link UnivariateStatistic} with \n+ * {@link #increment} and {@link #incrementAll(double[])} methods for adding\n+ * values and updating internal state.  \n+ * <p>\n+ * This interface is designed to be used for calculating statistics that can be\n+ * computed in one pass through the data without storing the full array of\n+ * sample values.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public interface StorelessUnivariateStatistic extends UnivariateStatistic {\n+\n+    /**\n+     * Updates the internal state of the statistic to reflect the addition of the new value.\n+     * @param d  the new value.\n+     */\n+    void increment(double d);\n+    \n+    /**\n+     * Updates the internal state of the statistic to reflect addition of\n+     * all values in the values array.  Does not clear the statistic first --\n+     * i.e., the values are added <strong>incrementally</strong> to the dataset.\n+     * \n+     * @param values  array holding the new values to add\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    void incrementAll(double[] values);\n+    \n+    /**\n+     * Updates the internal state of the statistic to reflect addition of\n+     * the values in the designated portion of the values array.  Does not\n+     * clear the statistic first -- i.e., the values are added \n+     * <strong>incrementally</strong> to the dataset.\n+     * \n+     * @param values  array holding the new values to add\n+     * @param start  the array index of the first value to add\n+     * @param length  the number of elements to add\n+     * @throws IllegalArgumentException if the array is null or the index\n+     */\n+    void incrementAll(double[] values, int start, int length);\n+\n+    /**\n+     * Returns the current value of the Statistic.\n+     * @return value of the statistic, <code>Double.NaN</code> if it\n+     * has been cleared or just instantiated.\n+     */\n+    double getResult();\n+\n+    /**\n+     * Returns the number of values that have been added.\n+     * @return the number of values.\n+     */\n+    long getN();\n+\n+    /**\n+     * Clears the internal state of the Statistic\n+     */\n+    void clear();\n+    \n+    /**\n+     * Returns a copy of the statistic with the same internal state.\n+     * \n+     * @return a copy of the statistic\n+     */\n+    StorelessUnivariateStatistic copy();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.stat.descriptive.moment.GeometricMean;\n+import org.apache.commons.math.stat.descriptive.moment.Mean;\n+import org.apache.commons.math.stat.descriptive.moment.SecondMoment;\n+import org.apache.commons.math.stat.descriptive.moment.Variance;\n+import org.apache.commons.math.stat.descriptive.rank.Max;\n+import org.apache.commons.math.stat.descriptive.rank.Min;\n+import org.apache.commons.math.stat.descriptive.summary.Sum;\n+import org.apache.commons.math.stat.descriptive.summary.SumOfLogs;\n+import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * <p>\n+ * Computes summary statistics for a stream of data values added using the\n+ * {@link #addValue(double) addValue} method. The data values are not stored in\n+ * memory, so this class can be used to compute statistics for very large data\n+ * streams.\n+ * </p>\n+ * <p>\n+ * The {@link StorelessUnivariateStatistic} instances used to maintain summary\n+ * state and compute statistics are configurable via setters. For example, the\n+ * default implementation for the variance can be overridden by calling\n+ * {@link #setVarianceImpl(StorelessUnivariateStatistic)}. Actual parameters to\n+ * these methods must implement the {@link StorelessUnivariateStatistic}\n+ * interface and configuration must be completed before <code>addValue</code>\n+ * is called. No configuration is necessary to use the default, commons-math\n+ * provided implementations.\n+ * </p>\n+ * <p>\n+ * Note: This class is not thread-safe. Use\n+ * {@link SynchronizedSummaryStatistics} if concurrent access from multiple\n+ * threads is required.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ */\n+public class SummaryStatistics implements StatisticalSummary, Serializable {\n+\n+    /** Serialization UID */\n+    private static final long serialVersionUID = -2021321786743555871L;\n+\n+    /**\n+     * Construct a SummaryStatistics instance\n+     */\n+    public SummaryStatistics() {\n+    }\n+\n+    /**\n+     * A copy constructor. Creates a deep-copy of the {@code original}.\n+     * \n+     * @param original the {@code SummaryStatistics} instance to copy\n+     */\n+    public SummaryStatistics(SummaryStatistics original) {\n+        copy(original, this);\n+    }\n+\n+    /** count of values that have been added */\n+    protected long n = 0;\n+\n+    /** SecondMoment is used to compute the mean and variance */\n+    protected SecondMoment secondMoment = new SecondMoment();\n+\n+    /** sum of values that have been added */\n+    protected Sum sum = new Sum();\n+\n+    /** sum of the square of each value that has been added */\n+    protected SumOfSquares sumsq = new SumOfSquares();\n+\n+    /** min of values that have been added */\n+    protected Min min = new Min();\n+\n+    /** max of values that have been added */\n+    protected Max max = new Max();\n+\n+    /** sumLog of values that have been added */\n+    protected SumOfLogs sumLog = new SumOfLogs();\n+\n+    /** geoMean of values that have been added */\n+    protected GeometricMean geoMean = new GeometricMean(sumLog);\n+\n+    /** mean of values that have been added */\n+    protected Mean mean = new Mean();\n+\n+    /** variance of values that have been added */\n+    protected Variance variance = new Variance();\n+\n+    /** Sum statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic sumImpl = sum;\n+\n+    /** Sum of squares statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic sumsqImpl = sumsq;\n+\n+    /** Minimum statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic minImpl = min;\n+\n+    /** Maximum statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic maxImpl = max;\n+\n+    /** Sum of log statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic sumLogImpl = sumLog;\n+\n+    /** Geometric mean statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic geoMeanImpl = geoMean;\n+\n+    /** Mean statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic meanImpl = mean;\n+\n+    /** Variance statistic implementation - can be reset by setter. */\n+    private StorelessUnivariateStatistic varianceImpl = variance;\n+\n+    /**\n+     * Return a {@link StatisticalSummaryValues} instance reporting current\n+     * statistics.\n+     * @return Current values of statistics\n+     */\n+    public StatisticalSummary getSummary() {\n+        return new StatisticalSummaryValues(getMean(), getVariance(), getN(), \n+                getMax(), getMin(), getSum());\n+    }\n+\n+    /**\n+     * Add a value to the data\n+     * @param value the value to add\n+     */\n+    public void addValue(double value) {\n+        sumImpl.increment(value);\n+        sumsqImpl.increment(value);\n+        minImpl.increment(value);\n+        maxImpl.increment(value);\n+        sumLogImpl.increment(value);\n+        secondMoment.increment(value);\n+        // If mean, variance or geomean have been overridden,\n+        // need to increment these\n+        if (!(meanImpl instanceof Mean)) {\n+            meanImpl.increment(value);\n+        }\n+        if (!(varianceImpl instanceof Variance)) {\n+            varianceImpl.increment(value);\n+        }\n+        if (!(geoMeanImpl instanceof GeometricMean)) {\n+            geoMeanImpl.increment(value);\n+        }\n+        n++;\n+    }\n+\n+    /**\n+     * Returns the number of available values\n+     * @return The number of available values\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+\n+    /**\n+     * Returns the sum of the values that have been added\n+     * @return The sum or <code>Double.NaN</code> if no values have been added\n+     */\n+    public double getSum() {\n+        return sumImpl.getResult();\n+    }\n+\n+    /**\n+     * Returns the sum of the squares of the values that have been added.\n+     * <p>\n+     * Double.NaN is returned if no values have been added.\n+     * </p>\n+     * @return The sum of squares\n+     */\n+    public double getSumsq() {\n+        return sumsqImpl.getResult();\n+    }\n+\n+    /**\n+     * Returns the mean of the values that have been added.\n+     * <p>\n+     * Double.NaN is returned if no values have been added.\n+     * </p>\n+     * @return the mean\n+     */\n+    public double getMean() {\n+        if (mean == meanImpl) {\n+            return new Mean(secondMoment).getResult();\n+        } else {\n+            return meanImpl.getResult();\n+        }\n+    }\n+\n+    /**\n+     * Returns the standard deviation of the values that have been added.\n+     * <p>\n+     * Double.NaN is returned if no values have been added.\n+     * </p>\n+     * @return the standard deviation\n+     */\n+    public double getStandardDeviation() {\n+        double stdDev = Double.NaN;\n+        if (getN() > 0) {\n+            if (getN() > 1) {\n+                stdDev = Math.sqrt(getVariance());\n+            } else {\n+                stdDev = 0.0;\n+            }\n+        }\n+        return (stdDev);\n+    }\n+\n+    /**\n+     * Returns the variance of the values that have been added.\n+     * <p>\n+     * Double.NaN is returned if no values have been added.\n+     * </p>\n+     * @return the variance\n+     */\n+    public double getVariance() {\n+        if (varianceImpl == variance) {\n+            return new Variance(secondMoment).getResult();\n+        } else {\n+            return varianceImpl.getResult();\n+        }\n+    }\n+\n+    /**\n+     * Returns the maximum of the values that have been added.\n+     * <p>\n+     * Double.NaN is returned if no values have been added.\n+     * </p>\n+     * @return the maximum\n+     */\n+    public double getMax() {\n+        return maxImpl.getResult();\n+    }\n+\n+    /**\n+     * Returns the minimum of the values that have been added.\n+     * <p>\n+     * Double.NaN is returned if no values have been added.\n+     * </p>\n+     * @return the minimum\n+     */\n+    public double getMin() {\n+        return minImpl.getResult();\n+    }\n+\n+    /**\n+     * Returns the geometric mean of the values that have been added.\n+     * <p>\n+     * Double.NaN is returned if no values have been added.\n+     * </p>\n+     * @return the geometric mean\n+     */\n+    public double getGeometricMean() {\n+        return geoMeanImpl.getResult();\n+    }\n+\n+    /**\n+     * Returns the sum of the logs of the values that have been added.\n+     * <p>\n+     * Double.NaN is returned if no values have been added.\n+     * </p>\n+     * @return the sum of logs\n+     * @since 1.2\n+     */\n+    public double getSumOfLogs() {\n+        return sumLogImpl.getResult();\n+    }\n+    \n+    /**\n+     * Returns a statistic related to the Second Central Moment.  Specifically,\n+     * what is returned is the sum of squared deviations from the sample mean\n+     * among the values that have been added.\n+     * <p>\n+     * Returns <code>Double.NaN</code> if no data values have been added and\n+     * returns <code>0</code> if there is just one value in the data set.</p>\n+     * <p>\n+     * @return second central moment statistic\n+     * @since 2.0\n+     */\n+    public double getSecondMoment() {\n+        return secondMoment.getResult();\n+    }\n+\n+    /**\n+     * Generates a text report displaying summary statistics from values that\n+     * have been added.\n+     * @return String with line feeds displaying statistics\n+     * @since 1.2\n+     */\n+    @Override\n+    public String toString() {\n+        StringBuffer outBuffer = new StringBuffer();\n+        String endl = \"\\n\";\n+        outBuffer.append(\"SummaryStatistics:\").append(endl);\n+        outBuffer.append(\"n: \").append(getN()).append(endl);\n+        outBuffer.append(\"min: \").append(getMin()).append(endl);\n+        outBuffer.append(\"max: \").append(getMax()).append(endl);\n+        outBuffer.append(\"mean: \").append(getMean()).append(endl);\n+        outBuffer.append(\"geometric mean: \").append(getGeometricMean())\n+            .append(endl);\n+        outBuffer.append(\"variance: \").append(getVariance()).append(endl);\n+        outBuffer.append(\"sum of squares: \").append(getSumsq()).append(endl);\n+        outBuffer.append(\"standard deviation: \").append(getStandardDeviation())\n+            .append(endl);\n+        outBuffer.append(\"sum of logs: \").append(getSumOfLogs()).append(endl);\n+        return outBuffer.toString();\n+    }\n+\n+    /**\n+     * Resets all statistics and storage\n+     */\n+    public void clear() {\n+        this.n = 0;\n+        minImpl.clear();\n+        maxImpl.clear();\n+        sumImpl.clear();\n+        sumLogImpl.clear();\n+        sumsqImpl.clear();\n+        geoMeanImpl.clear();\n+        secondMoment.clear();\n+        if (meanImpl != mean) {\n+            meanImpl.clear();\n+        }\n+        if (varianceImpl != variance) {\n+            varianceImpl.clear();\n+        }\n+    }\n+\n+    /**\n+     * Returns true iff <code>object</code> is a\n+     * <code>SummaryStatistics</code> instance and all statistics have the\n+     * same values as this.\n+     * @param object the object to test equality against.\n+     * @return true if object equals this\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (object == this) {\n+            return true;\n+        }\n+        if (object instanceof SummaryStatistics == false) {\n+            return false;\n+        }\n+        SummaryStatistics stat = (SummaryStatistics)object;\n+        return (MathUtils.equals(stat.getGeometricMean(), this.getGeometricMean()) &&\n+                MathUtils.equals(stat.getMax(), this.getMax()) &&\n+                MathUtils.equals(stat.getMean(), this.getMean()) &&\n+                MathUtils.equals(stat.getMin(), this.getMin()) &&\n+                MathUtils.equals(stat.getN(), this.getN()) &&\n+                MathUtils.equals(stat.getSum(), this.getSum()) &&\n+                MathUtils.equals(stat.getSumsq(), this.getSumsq()) &&\n+                MathUtils.equals(stat.getVariance(),\n+            this.getVariance()));\n+    }\n+\n+    /**\n+     * Returns hash code based on values of statistics\n+     * @return hash code\n+     */\n+    @Override\n+    public int hashCode() {\n+        int result = 31 + MathUtils.hash(getGeometricMean());\n+        result = result * 31 + MathUtils.hash(getGeometricMean());\n+        result = result * 31 + MathUtils.hash(getMax());\n+        result = result * 31 + MathUtils.hash(getMean());\n+        result = result * 31 + MathUtils.hash(getMin());\n+        result = result * 31 + MathUtils.hash(getN());\n+        result = result * 31 + MathUtils.hash(getSum());\n+        result = result * 31 + MathUtils.hash(getSumsq());\n+        result = result * 31 + MathUtils.hash(getVariance());\n+        return result;\n+    }\n+\n+    // Getters and setters for statistics implementations\n+    /**\n+     * Returns the currently configured Sum implementation\n+     * @return the StorelessUnivariateStatistic implementing the sum\n+     * @since 1.2\n+     */\n+    public StorelessUnivariateStatistic getSumImpl() {\n+        return sumImpl;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets the implementation for the Sum.\n+     * </p>\n+     * <p>\n+     * This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double) addValue} has been used to add data;\n+     * otherwise an IllegalStateException will be thrown.\n+     * </p>\n+     * @param sumImpl the StorelessUnivariateStatistic instance to use for\n+     *        computing the Sum\n+     * @throws IllegalStateException if data has already been added (i.e if n >\n+     *         0)\n+     * @since 1.2\n+     */\n+    public void setSumImpl(StorelessUnivariateStatistic sumImpl) {\n+        checkEmpty();\n+        this.sumImpl = sumImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured sum of squares implementation\n+     * @return the StorelessUnivariateStatistic implementing the sum of squares\n+     * @since 1.2\n+     */\n+    public StorelessUnivariateStatistic getSumsqImpl() {\n+        return sumsqImpl;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets the implementation for the sum of squares.\n+     * </p>\n+     * <p>\n+     * This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double) addValue} has been used to add data;\n+     * otherwise an IllegalStateException will be thrown.\n+     * </p>\n+     * @param sumsqImpl the StorelessUnivariateStatistic instance to use for\n+     *        computing the sum of squares\n+     * @throws IllegalStateException if data has already been added (i.e if n >\n+     *         0)\n+     * @since 1.2\n+     */\n+    public void setSumsqImpl(StorelessUnivariateStatistic sumsqImpl) {\n+        checkEmpty();\n+        this.sumsqImpl = sumsqImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured minimum implementation\n+     * @return the StorelessUnivariateStatistic implementing the minimum\n+     * @since 1.2\n+     */\n+    public StorelessUnivariateStatistic getMinImpl() {\n+        return minImpl;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets the implementation for the minimum.\n+     * </p>\n+     * <p>\n+     * This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double) addValue} has been used to add data;\n+     * otherwise an IllegalStateException will be thrown.\n+     * </p>\n+     * @param minImpl the StorelessUnivariateStatistic instance to use for\n+     *        computing the minimum\n+     * @throws IllegalStateException if data has already been added (i.e if n >\n+     *         0)\n+     * @since 1.2\n+     */\n+    public void setMinImpl(StorelessUnivariateStatistic minImpl) {\n+        checkEmpty();\n+        this.minImpl = minImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured maximum implementation\n+     * @return the StorelessUnivariateStatistic implementing the maximum\n+     * @since 1.2\n+     */\n+    public StorelessUnivariateStatistic getMaxImpl() {\n+        return maxImpl;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets the implementation for the maximum.\n+     * </p>\n+     * <p>\n+     * This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double) addValue} has been used to add data;\n+     * otherwise an IllegalStateException will be thrown.\n+     * </p>\n+     * @param maxImpl the StorelessUnivariateStatistic instance to use for\n+     *        computing the maximum\n+     * @throws IllegalStateException if data has already been added (i.e if n >\n+     *         0)\n+     * @since 1.2\n+     */\n+    public void setMaxImpl(StorelessUnivariateStatistic maxImpl) {\n+        checkEmpty();\n+        this.maxImpl = maxImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured sum of logs implementation\n+     * @return the StorelessUnivariateStatistic implementing the log sum\n+     * @since 1.2\n+     */\n+    public StorelessUnivariateStatistic getSumLogImpl() {\n+        return sumLogImpl;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets the implementation for the sum of logs.\n+     * </p>\n+     * <p>\n+     * This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double) addValue} has been used to add data;\n+     * otherwise an IllegalStateException will be thrown.\n+     * </p>\n+     * @param sumLogImpl the StorelessUnivariateStatistic instance to use for\n+     *        computing the log sum\n+     * @throws IllegalStateException if data has already been added (i.e if n >\n+     *         0)\n+     * @since 1.2\n+     */\n+    public void setSumLogImpl(StorelessUnivariateStatistic sumLogImpl) {\n+        checkEmpty();\n+        this.sumLogImpl = sumLogImpl;\n+        geoMean.setSumLogImpl(sumLogImpl);\n+    }\n+\n+    /**\n+     * Returns the currently configured geometric mean implementation\n+     * @return the StorelessUnivariateStatistic implementing the geometric mean\n+     * @since 1.2\n+     */\n+    public StorelessUnivariateStatistic getGeoMeanImpl() {\n+        return geoMeanImpl;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets the implementation for the geometric mean.\n+     * </p>\n+     * <p>\n+     * This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double) addValue} has been used to add data;\n+     * otherwise an IllegalStateException will be thrown.\n+     * </p>\n+     * @param geoMeanImpl the StorelessUnivariateStatistic instance to use for\n+     *        computing the geometric mean\n+     * @throws IllegalStateException if data has already been added (i.e if n >\n+     *         0)\n+     * @since 1.2\n+     */\n+    public void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl) {\n+        checkEmpty();\n+        this.geoMeanImpl = geoMeanImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured mean implementation\n+     * @return the StorelessUnivariateStatistic implementing the mean\n+     * @since 1.2\n+     */\n+    public StorelessUnivariateStatistic getMeanImpl() {\n+        return meanImpl;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets the implementation for the mean.\n+     * </p>\n+     * <p>\n+     * This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double) addValue} has been used to add data;\n+     * otherwise an IllegalStateException will be thrown.\n+     * </p>\n+     * @param meanImpl the StorelessUnivariateStatistic instance to use for\n+     *        computing the mean\n+     * @throws IllegalStateException if data has already been added (i.e if n >\n+     *         0)\n+     * @since 1.2\n+     */\n+    public void setMeanImpl(StorelessUnivariateStatistic meanImpl) {\n+        checkEmpty();\n+        this.meanImpl = meanImpl;\n+    }\n+\n+    /**\n+     * Returns the currently configured variance implementation\n+     * @return the StorelessUnivariateStatistic implementing the variance\n+     * @since 1.2\n+     */\n+    public StorelessUnivariateStatistic getVarianceImpl() {\n+        return varianceImpl;\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets the implementation for the variance.\n+     * </p>\n+     * <p>\n+     * This method must be activated before any data has been added - i.e.,\n+     * before {@link #addValue(double) addValue} has been used to add data;\n+     * otherwise an IllegalStateException will be thrown.\n+     * </p>\n+     * @param varianceImpl the StorelessUnivariateStatistic instance to use for\n+     *        computing the variance\n+     * @throws IllegalStateException if data has already been added (i.e if n >\n+     *         0)\n+     * @since 1.2\n+     */\n+    public void setVarianceImpl(StorelessUnivariateStatistic varianceImpl) {\n+        checkEmpty();\n+        this.varianceImpl = varianceImpl;\n+    }\n+\n+    /**\n+     * Throws IllegalStateException if n > 0.\n+     */\n+    private void checkEmpty() {\n+        if (n > 0) {\n+            throw MathRuntimeException.createIllegalStateException(\n+                    \"{0} values have been added before statistic is configured\",\n+                    n);\n+        }\n+    }\n+    \n+    /**\n+     * Returns a copy of this SummaryStatistics instance with the same internal state.\n+     * \n+     * @return a copy of this\n+     */\n+    public SummaryStatistics copy() {\n+        SummaryStatistics result = new SummaryStatistics();\n+        copy(this, result);\n+        return result; \n+    }\n+     \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source SummaryStatistics to copy\n+     * @param dest SummaryStatistics to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(SummaryStatistics source, SummaryStatistics dest) {\n+        dest.maxImpl = source.maxImpl.copy();\n+        dest.meanImpl = source.meanImpl.copy();\n+        dest.minImpl = source.minImpl.copy();\n+        dest.sumImpl = source.sumImpl.copy();\n+        dest.varianceImpl = source.varianceImpl.copy();\n+        dest.sumLogImpl = source.sumLogImpl.copy();\n+        dest.sumsqImpl = source.sumsqImpl.copy();\n+        if (source.getGeoMeanImpl() instanceof GeometricMean) {\n+            // Keep geoMeanImpl, sumLogImpl in synch\n+            dest.geoMeanImpl = new GeometricMean((SumOfLogs) dest.sumLogImpl);\n+        } else {\n+            dest.geoMeanImpl = source.geoMeanImpl.copy();\n+        }\n+        SecondMoment.copy(source.secondMoment, dest.secondMoment);\n+        dest.n = source.n;\n+        \n+        // Make sure that if stat == statImpl in source, same\n+        // holds in dest; otherwise copy stat\n+        if (source.geoMean == source.geoMeanImpl) {\n+            dest.geoMean = (GeometricMean) dest.geoMeanImpl;\n+        } else {\n+            GeometricMean.copy(source.geoMean, dest.geoMean);\n+        } \n+        if (source.max == source.maxImpl) {\n+            dest.max = (Max) dest.maxImpl;\n+        } else {\n+            Max.copy(source.max, dest.max);\n+        } \n+        if (source.mean == source.meanImpl) {\n+            dest.mean = (Mean) dest.meanImpl;\n+        } else {\n+            Mean.copy(source.mean, dest.mean);\n+        } \n+        if (source.min == source.minImpl) {\n+            dest.min = (Min) dest.minImpl;\n+        } else {\n+            Min.copy(source.min, dest.min);\n+        } \n+        if (source.sum == source.sumImpl) {\n+            dest.sum = (Sum) dest.sumImpl;\n+        } else {\n+            Sum.copy(source.sum, dest.sum);\n+        } \n+        if (source.variance == source.varianceImpl) {\n+            dest.variance = (Variance) dest.varianceImpl;\n+        } else {\n+            Variance.copy(source.variance, dest.variance);\n+        } \n+        if (source.sumLog == source.sumLogImpl) {\n+            dest.sumLog = (SumOfLogs) dest.sumLogImpl;\n+        } else {\n+            SumOfLogs.copy(source.sumLog, dest.sumLog);\n+        } \n+        if (source.sumsq == source.sumsqImpl) {\n+            dest.sumsq = (SumOfSquares) dest.sumsqImpl;\n+        } else {\n+            SumOfSquares.copy(source.sumsq, dest.sumsq);\n+        } \n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SynchronizedDescriptiveStatistics.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+/**\n+ * Implementation of\n+ * {@link org.apache.commons.math.stat.descriptive.DescriptiveStatistics} that\n+ * is safe to use in a multithreaded environment.  Multiple threads can safely\n+ * operate on a single instance without causing runtime exceptions due to race\n+ * conditions.  In effect, this implementation makes modification and access\n+ * methods atomic operations for a single instance.  That is to say, as one\n+ * thread is computing a statistic from the instance, no other thread can modify\n+ * the instance nor compute another statistic. \n+ *\n+ * @since 1.2\n+ * @version $Revision$ $Date$\n+ */\n+public class SynchronizedDescriptiveStatistics extends DescriptiveStatistics {\n+\n+    /** Serialization UID */\n+    private static final long serialVersionUID = 1L;\n+\n+    /**\n+     * Construct an instance with infinite window\n+     */\n+    public SynchronizedDescriptiveStatistics() {\n+        this(INFINITE_WINDOW);\n+    }\n+\n+    /**\n+     * Construct an instance with finite window\n+     * @param window the finite window size.\n+     */\n+    public SynchronizedDescriptiveStatistics(int window) {\n+        super(window);\n+    }\n+    \n+    /**\n+     * A copy constructor. Creates a deep-copy of the {@code original}.\n+     * \n+     * @param original the {@code SynchronizedDescriptiveStatistics} instance to copy\n+     */\n+    public SynchronizedDescriptiveStatistics(SynchronizedDescriptiveStatistics original) {\n+        copy(original, this);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void addValue(double v) {\n+        super.addValue(v);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double apply(UnivariateStatistic stat) {\n+        return super.apply(stat);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void clear() {\n+        super.clear();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double getElement(int index) {\n+        return super.getElement(index);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized long getN() {\n+        return super.getN();\n+    }\n+\n+    /** \n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double getStandardDeviation() {\n+        return super.getStandardDeviation();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double[] getValues() {\n+        return super.getValues();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized int getWindowSize() {\n+        return super.getWindowSize();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void setWindowSize(int windowSize) {\n+        super.setWindowSize(windowSize);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized String toString() {\n+        return super.toString();\n+    }\n+    \n+    /**\n+     * Returns a copy of this SynchronizedDescriptiveStatistics instance with the\n+     * same internal state.\n+     * \n+     * @return a copy of this\n+     */\n+    @Override\n+    public synchronized SynchronizedDescriptiveStatistics copy() {\n+        SynchronizedDescriptiveStatistics result = \n+            new SynchronizedDescriptiveStatistics();\n+        copy(this, result);\n+        return result; \n+    }\n+     \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * <p>Acquires synchronization lock on source, then dest before copying.</p>\n+     * \n+     * @param source SynchronizedDescriptiveStatistics to copy\n+     * @param dest SynchronizedDescriptiveStatistics to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(SynchronizedDescriptiveStatistics source,\n+            SynchronizedDescriptiveStatistics dest) {\n+        synchronized (source) {\n+            synchronized (dest) {\n+                DescriptiveStatistics.copy(source, dest);\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SynchronizedMultivariateSummaryStatistics.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.linear.RealMatrix;\n+\n+/**\n+ * Implementation of\n+ * {@link org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics} that\n+ * is safe to use in a multithreaded environment.  Multiple threads can safely\n+ * operate on a single instance without causing runtime exceptions due to race\n+ * conditions.  In effect, this implementation makes modification and access\n+ * methods atomic operations for a single instance.  That is to say, as one\n+ * thread is computing a statistic from the instance, no other thread can modify\n+ * the instance nor compute another statistic.\n+ * @since 1.2\n+ * @version $Revision$ $Date$\n+ */\n+public class SynchronizedMultivariateSummaryStatistics\n+  extends MultivariateSummaryStatistics {\n+\n+    /** Serialization UID */\n+    private static final long serialVersionUID = 7099834153347155363L;\n+\n+    /**\n+     * Construct a SynchronizedMultivariateSummaryStatistics instance\n+     * @param k dimension of the data\n+     * @param isCovarianceBiasCorrected if true, the unbiased sample\n+     * covariance is computed, otherwise the biased population covariance\n+     * is computed\n+     */\n+    public SynchronizedMultivariateSummaryStatistics(int k, boolean isCovarianceBiasCorrected) {\n+        super(k, isCovarianceBiasCorrected);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void addValue(double[] value)\n+      throws DimensionMismatchException {\n+      super.addValue(value);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized int getDimension() {\n+        return super.getDimension();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized long getN() {\n+        return super.getN();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double[] getSum() {\n+        return super.getSum();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double[] getSumSq() {\n+        return super.getSumSq();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double[] getSumLog() {\n+        return super.getSumLog();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double[] getMean() {\n+        return super.getMean();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double[] getStandardDeviation() {\n+        return super.getStandardDeviation();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized RealMatrix getCovariance() {\n+        return super.getCovariance();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double[] getMax() {\n+        return super.getMax();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double[] getMin() {\n+        return super.getMin();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double[] getGeometricMean() {\n+        return super.getGeometricMean();\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized String toString() {\n+        return super.toString();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void clear() {\n+        super.clear();\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized boolean equals(Object object) {\n+        return super.equals(object);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized int hashCode() {\n+        return super.hashCode();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized StorelessUnivariateStatistic[] getSumImpl() {\n+        return super.getSumImpl();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void setSumImpl(StorelessUnivariateStatistic[] sumImpl)\n+      throws DimensionMismatchException {\n+        super.setSumImpl(sumImpl);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized StorelessUnivariateStatistic[] getSumsqImpl() {\n+        return super.getSumsqImpl();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void setSumsqImpl(StorelessUnivariateStatistic[] sumsqImpl)\n+      throws DimensionMismatchException {\n+        super.setSumsqImpl(sumsqImpl);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized StorelessUnivariateStatistic[] getMinImpl() {\n+        return super.getMinImpl();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void setMinImpl(StorelessUnivariateStatistic[] minImpl)\n+      throws DimensionMismatchException {\n+        super.setMinImpl(minImpl);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized StorelessUnivariateStatistic[] getMaxImpl() {\n+        return super.getMaxImpl();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void setMaxImpl(StorelessUnivariateStatistic[] maxImpl)\n+      throws DimensionMismatchException {\n+        super.setMaxImpl(maxImpl);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized StorelessUnivariateStatistic[] getSumLogImpl() {\n+        return super.getSumLogImpl();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void setSumLogImpl(StorelessUnivariateStatistic[] sumLogImpl)\n+      throws DimensionMismatchException {\n+        super.setSumLogImpl(sumLogImpl);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized StorelessUnivariateStatistic[] getGeoMeanImpl() {\n+        return super.getGeoMeanImpl();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void setGeoMeanImpl(StorelessUnivariateStatistic[] geoMeanImpl)\n+      throws DimensionMismatchException {\n+        super.setGeoMeanImpl(geoMeanImpl);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized StorelessUnivariateStatistic[] getMeanImpl() {\n+        return super.getMeanImpl();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void setMeanImpl(StorelessUnivariateStatistic[] meanImpl)\n+      throws DimensionMismatchException {\n+        super.setMeanImpl(meanImpl);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/SynchronizedSummaryStatistics.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+/**\n+ * Implementation of\n+ * {@link org.apache.commons.math.stat.descriptive.SummaryStatistics} that\n+ * is safe to use in a multithreaded environment.  Multiple threads can safely\n+ * operate on a single instance without causing runtime exceptions due to race\n+ * conditions.  In effect, this implementation makes modification and access\n+ * methods atomic operations for a single instance.  That is to say, as one\n+ * thread is computing a statistic from the instance, no other thread can modify\n+ * the instance nor compute another statistic. \n+ *\n+ * @since 1.2\n+ * @version $Revision$ $Date$\n+ */\n+public class SynchronizedSummaryStatistics extends SummaryStatistics {\n+\n+    /** Serialization UID */\n+    private static final long serialVersionUID = 1909861009042253704L;\n+\n+    /**\n+     * Construct a SynchronizedSummaryStatistics instance\n+     */\n+    public SynchronizedSummaryStatistics() {\n+        super();\n+    }\n+    \n+    /**\n+     * A copy constructor. Creates a deep-copy of the {@code original}.\n+     * \n+     * @param original the {@code SynchronizedSummaryStatistics} instance to copy\n+     */\n+    public SynchronizedSummaryStatistics(SynchronizedSummaryStatistics original) {\n+        copy(original, this);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized StatisticalSummary getSummary() {\n+        return super.getSummary();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void addValue(double value) {\n+        super.addValue(value);\n+    }\n+\n+    /** \n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized long getN() {\n+        return super.getN();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double getSum() {\n+        return super.getSum();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double getSumsq() {\n+        return super.getSumsq();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double getMean() {\n+        return super.getMean();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double getStandardDeviation() {\n+        return super.getStandardDeviation();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double getVariance() {\n+        return super.getVariance();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double getMax() {\n+        return super.getMax();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double getMin() {\n+        return super.getMin();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized double getGeometricMean() {\n+        return super.getGeometricMean();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized String toString() {\n+        return super.toString();\n+    }\n+\n+    /** \n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void clear() {\n+        super.clear();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized boolean equals(Object object) {\n+        return super.equals(object);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized int hashCode() {\n+        return super.hashCode();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized StorelessUnivariateStatistic getSumImpl() {\n+        return super.getSumImpl();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void setSumImpl(StorelessUnivariateStatistic sumImpl) {\n+        super.setSumImpl(sumImpl);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized StorelessUnivariateStatistic getSumsqImpl() {\n+        return super.getSumsqImpl();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void setSumsqImpl(StorelessUnivariateStatistic sumsqImpl) {\n+        super.setSumsqImpl(sumsqImpl);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized StorelessUnivariateStatistic getMinImpl() {\n+        return super.getMinImpl();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void setMinImpl(StorelessUnivariateStatistic minImpl) {\n+        super.setMinImpl(minImpl);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized StorelessUnivariateStatistic getMaxImpl() {\n+        return super.getMaxImpl();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void setMaxImpl(StorelessUnivariateStatistic maxImpl) {\n+        super.setMaxImpl(maxImpl);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized StorelessUnivariateStatistic getSumLogImpl() {\n+        return super.getSumLogImpl();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void setSumLogImpl(StorelessUnivariateStatistic sumLogImpl) {\n+        super.setSumLogImpl(sumLogImpl);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized StorelessUnivariateStatistic getGeoMeanImpl() {\n+        return super.getGeoMeanImpl();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl) {\n+        super.setGeoMeanImpl(geoMeanImpl);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized StorelessUnivariateStatistic getMeanImpl() {\n+        return super.getMeanImpl();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void setMeanImpl(StorelessUnivariateStatistic meanImpl) {\n+        super.setMeanImpl(meanImpl);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized StorelessUnivariateStatistic getVarianceImpl() {\n+        return super.getVarianceImpl();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public synchronized void setVarianceImpl(StorelessUnivariateStatistic varianceImpl) {\n+        super.setVarianceImpl(varianceImpl);\n+    }\n+    \n+    /**\n+     * Returns a copy of this SynchronizedSummaryStatistics instance with the\n+     * same internal state.\n+     * \n+     * @return a copy of this\n+     */\n+    @Override\n+    public synchronized SynchronizedSummaryStatistics copy() {\n+        SynchronizedSummaryStatistics result = \n+            new SynchronizedSummaryStatistics();\n+        copy(this, result);\n+        return result; \n+    }\n+     \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * <p>Acquires synchronization lock on source, then dest before copying.</p>\n+     * \n+     * @param source SynchronizedSummaryStatistics to copy\n+     * @param dest SynchronizedSummaryStatistics to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(SynchronizedSummaryStatistics source,\n+            SynchronizedSummaryStatistics dest) {\n+        synchronized (source) {\n+            synchronized (dest) {\n+                SummaryStatistics.copy(source, dest);\n+            }\n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/UnivariateStatistic.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+\n+/**\n+ * Base interface implemented by all statistics.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public interface UnivariateStatistic {\n+\n+    /**\n+     * Returns the result of evaluating the statistic over the input array.\n+     * \n+     * @param values input array\n+     * @return the value of the statistic applied to the input array\n+     */\n+    double evaluate(double[] values);\n+\n+    /**\n+     * Returns the result of evaluating the statistic over the specified entries\n+     * in the input array.\n+     * \n+     * @param values the input array\n+     * @param begin the index of the first element to include\n+     * @param length the number of elements to include\n+     * @return the value of the statistic applied to the included array entries\n+     */\n+    double evaluate(double[] values, int begin, int length);\n+    \n+    /**\n+     * Returns a copy of the statistic with the same internal state.\n+     * \n+     * @return a copy of the statistic\n+     */\n+    UnivariateStatistic copy();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/FirstMoment.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * Computes the first moment (arithmetic mean).  Uses the definitional formula:\n+ * <p>\n+ * mean = sum(x_i) / n </p>\n+ * <p>\n+ * where <code>n</code> is the number of observations. </p>\n+ * <p>\n+ * To limit numeric errors, the value of the statistic is computed using the\n+ * following recursive updating algorithm: </p>\n+ * <p>\n+ * <ol>\n+ * <li>Initialize <code>m = </code> the first value</li>\n+ * <li>For each additional value, update using <br>\n+ *   <code>m = m + (new value - m) / (number of observations)</code></li>\n+ * </ol></p>\n+ * <p>\n+ *  Returns <code>Double.NaN</code> if the dataset is empty.</p>\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class FirstMoment extends AbstractStorelessUnivariateStatistic \n+    implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 6112755307178490473L;\n+\n+    \n+    /** Count of values that have been added */\n+    protected long n;\n+\n+    /** First moment of values that have been added */\n+    protected double m1;\n+    \n+    /** \n+     * Deviation of most recently added value from previous first moment.\n+     * Retained to prevent repeated computation in higher order moments.\n+     */\n+    protected double dev;\n+    \n+    /**\n+     * Deviation of most recently added value from previous first moment,\n+     * normalized by previous sample size.  Retained to prevent repeated\n+     * computation in higher order moments\n+     */\n+    protected double nDev;\n+\n+    /**\n+     * Create a FirstMoment instance\n+     */\n+    public FirstMoment() {\n+        n = 0;\n+        m1 = Double.NaN;\n+        dev = Double.NaN;\n+        nDev = Double.NaN;\n+    }\n+    \n+    /**\n+     * Copy constructor, creates a new {@code FirstMoment} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code FirstMoment} instance to copy\n+     */\n+     public FirstMoment(FirstMoment original) {\n+         super();\n+         copy(original, this);\n+     }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+     @Override\n+    public void increment(final double d) {\n+        if (n == 0) {\n+            m1 = 0.0;\n+        }\n+        n++;\n+        double n0 = n;\n+        dev = d - m1;\n+        nDev = dev / n0;\n+        m1 += nDev;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear() {\n+        m1 = Double.NaN;\n+        n = 0;\n+        dev = Double.NaN;\n+        nDev = Double.NaN;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double getResult() {\n+        return m1;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public FirstMoment copy() {\n+        FirstMoment result = new FirstMoment();\n+        copy(this, result);\n+        return result; \n+    }\n+     \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source FirstMoment to copy\n+     * @param dest FirstMoment to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(FirstMoment source, FirstMoment dest) {\n+        dest.n = source.n;\n+        dest.m1 = source.m1;\n+        dest.dev = source.dev;\n+        dest.nDev = dest.nDev;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/FourthMoment.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Computes a statistic related to the Fourth Central Moment.  Specifically,\n+ * what is computed is the sum of \n+ * <p>\n+ * (x_i - xbar) ^ 4, </p>\n+ * <p>\n+ * where the x_i are the \n+ * sample observations and xbar is the sample mean. </p>\n+ * <p>\n+ * The following recursive updating formula is used: </p>\n+ * <p>\n+ * Let <ul>\n+ * <li> dev = (current obs - previous mean) </li>\n+ * <li> m2 = previous value of {@link SecondMoment} </li>\n+ * <li> m2 = previous value of {@link ThirdMoment} </li>\n+ * <li> n = number of observations (including current obs) </li>\n+ * </ul>\n+ * Then </p>\n+ * <p>\n+ * new value = old value - 4 * (dev/n) * m3 + 6 * (dev/n)^2 * m2 + <br>\n+ * [n^2 - 3 * (n-1)] * dev^4 * (n-1) / n^3 </p>\n+ * <p>\n+ * Returns <code>Double.NaN</code> if no data values have been added and\n+ * returns <code>0</code> if there is just one value in the data set. </p>\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally. </p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class FourthMoment extends ThirdMoment implements Serializable{\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 4763990447117157611L;\n+        \n+    /** fourth moment of values that have been added */\n+    protected double m4;\n+\n+    /**\n+     * Create a FourthMoment instance\n+     */\n+    public FourthMoment() {\n+        super();\n+        m4 = Double.NaN;\n+    }\n+    \n+    /**\n+     * Copy constructor, creates a new {@code FourthMoment} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code FourthMoment} instance to copy\n+     */\n+     public FourthMoment(FourthMoment original) {\n+         super();\n+         copy(original, this);\n+     }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+     @Override\n+    public void increment(final double d) {\n+        if (n < 1) {\n+            m4 = 0.0;\n+            m3 = 0.0;\n+            m2 = 0.0;\n+            m1 = 0.0;\n+        }\n+\n+        double prevM3 = m3;\n+        double prevM2 = m2;\n+        \n+        super.increment(d);\n+        \n+        double n0 = n;\n+\n+        m4 = m4 - 4.0 * nDev * prevM3 + 6.0 * nDevSq * prevM2 +\n+            ((n0 * n0) - 3 * (n0 -1)) * (nDevSq * nDevSq * (n0 - 1) * n0);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double getResult() {\n+        return m4;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear() {\n+        super.clear();\n+        m4 = Double.NaN;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public FourthMoment copy() {\n+        FourthMoment result = new FourthMoment();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source FourthMoment to copy\n+     * @param dest FourthMoment to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(FourthMoment source, FourthMoment dest) {\n+        ThirdMoment.copy(source, dest);\n+        dest.m4 = source.m4;\n+    }  \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.summary.SumOfLogs;\n+\n+/**\n+ * Returns the <a href=\"http://www.xycoon.com/geometric_mean.htm\">\n+ * geometric mean </a> of the available values.\n+ * <p>\n+ * Uses a {@link SumOfLogs} instance to compute sum of logs and returns\n+ * <code> exp( 1/n  (sum of logs) ).</code>  Therefore, </p>\n+ * <ul>\n+ * <li>If any of values are < 0, the result is <code>NaN.</code></li>\n+ * <li>If all values are non-negative and less than \n+ * <code>Double.POSITIVE_INFINITY</code>,  but at least one value is 0, the \n+ * result is <code>0.</code></li>\n+ * <li>If both <code>Double.POSITIVE_INFINITY</code> and \n+ * <code>Double.NEGATIVE_INFINITY</code> are among the values, the result is\n+ * <code>NaN.</code></li>\n+ * </ul> </p>\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.</p>\n+ * \n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class GeometricMean extends AbstractStorelessUnivariateStatistic implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -8178734905303459453L;  \n+    \n+    /** Wrapped SumOfLogs instance */\n+    private StorelessUnivariateStatistic sumOfLogs;\n+\n+    /**\n+     * Create a GeometricMean instance\n+     */\n+    public GeometricMean() {\n+        sumOfLogs = new SumOfLogs();\n+    }\n+    \n+    /**\n+     * Copy constructor, creates a new {@code GeometricMean} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code GeometricMean} instance to copy\n+     */\n+    public GeometricMean(GeometricMean original) {\n+        super();\n+        copy(original, this);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public GeometricMean copy() {\n+        GeometricMean result = new GeometricMean();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Create a GeometricMean instance using the given SumOfLogs instance\n+     * @param sumOfLogs sum of logs instance to use for computation\n+     */\n+    public GeometricMean(SumOfLogs sumOfLogs) {\n+        this.sumOfLogs = sumOfLogs;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void increment(final double d) {\n+        sumOfLogs.increment(d);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double getResult() {\n+        if (sumOfLogs.getN() > 0) {\n+            return Math.exp(sumOfLogs.getResult() / sumOfLogs.getN());\n+        } else {\n+            return Double.NaN;\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear() {\n+        sumOfLogs.clear();\n+    }\n+\n+    /**\n+     * Returns the geometric mean of the entries in the specified portion\n+     * of the input array.\n+     * <p>\n+     * See {@link GeometricMean} for details on the computing algorithm.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * \n+     * @param values input array containing the values\n+     * @param begin first array element to include\n+     * @param length the number of elements to include\n+     * @return the geometric mean or Double.NaN if length = 0 or\n+     * any of the values are &lt;= 0.\n+     * @throws IllegalArgumentException if the input array is null or the array\n+     * index parameters are not valid\n+     */\n+    @Override\n+    public double evaluate(\n+        final double[] values, final int begin, final int length) {\n+        return Math.exp(\n+            sumOfLogs.evaluate(values, begin, length) / length);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public long getN() {\n+        return sumOfLogs.getN();\n+    }\n+    \n+    /**\n+     * <p>Sets the implementation for the sum of logs.</p>\n+     * <p>This method must be activated before any data has been added - i.e.,\n+     * before {@link #increment(double) increment} has been used to add data; \n+     * otherwise an IllegalStateException will be thrown.</p>\n+     * \n+     * @param sumLogImpl the StorelessUnivariateStatistic instance to use\n+     * for computing the log sum\n+     * @throws IllegalStateException if data has already been added \n+     *  (i.e if n > 0)\n+     */\n+    public void setSumLogImpl(\n+            StorelessUnivariateStatistic sumLogImpl) {\n+        checkEmpty();\n+        this.sumOfLogs = sumLogImpl;\n+    }\n+    \n+    /**\n+     * Returns the currently configured sum of logs implementation\n+     * \n+     * @return the StorelessUnivariateStatistic implementing the log sum\n+     */\n+    public StorelessUnivariateStatistic getSumLogImpl() {\n+        return sumOfLogs;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source GeometricMean to copy\n+     * @param dest GeometricMean to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(GeometricMean source, GeometricMean dest) {\n+        dest.sumOfLogs = source.sumOfLogs.copy();\n+    }\n+    \n+    \n+    /**\n+     * Throws IllegalStateException if n > 0.\n+     */\n+    private void checkEmpty() {\n+        if (getN() > 0) {\n+            throw MathRuntimeException.createIllegalStateException(\n+                    \"{0} values have been added before statistic is configured\",\n+                    getN());\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+\n+/**\n+ * Computes the Kurtosis of the available values.\n+ * <p>\n+ * We use the following (unbiased) formula to define kurtosis:</p>\n+ *  <p>\n+ *  kurtosis = { [n(n+1) / (n -1)(n - 2)(n-3)] sum[(x_i - mean)^4] / std^4 } - [3(n-1)^2 / (n-2)(n-3)]\n+ *  </p><p>\n+ *  where n is the number of values, mean is the {@link Mean} and std is the\n+ * {@link StandardDeviation}</p>\n+ * <p>\n+ *  Note that this statistic is undefined for n < 4.  <code>Double.Nan</code>\n+ *  is returned when there is not sufficient data to compute the statistic.</p>\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.</p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class Kurtosis extends AbstractStorelessUnivariateStatistic  implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 2784465764798260919L;  \n+      \n+    /**Fourth Moment on which this statistic is based */\n+    protected FourthMoment moment;\n+\n+    /** \n+     * Determines whether or not this statistic can be incremented or cleared.\n+     * <p>\n+     * Statistics based on (constructed from) external moments cannot\n+     * be incremented or cleared.</p>\n+    */\n+    protected boolean incMoment;\n+\n+    /**\n+     * Construct a Kurtosis\n+     */\n+    public Kurtosis() {\n+        incMoment = true;\n+        moment = new FourthMoment();\n+    }\n+\n+    /**\n+     * Construct a Kurtosis from an external moment\n+     * \n+     * @param m4 external Moment\n+     */\n+    public Kurtosis(final FourthMoment m4) {\n+        incMoment = false;\n+        this.moment = m4;\n+    }\n+    \n+    /**\n+     * Copy constructor, creates a new {@code Kurtosis} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Kurtosis} instance to copy\n+     */\n+    public Kurtosis(Kurtosis original) {\n+        copy(original, this);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void increment(final double d) {\n+        if (incMoment) {\n+            moment.increment(d);\n+        }  else  {\n+            throw MathRuntimeException.createIllegalStateException(\n+                    \"statistics constructed from external moments cannot be incremented\");\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double getResult() {\n+        double kurtosis = Double.NaN;\n+        if (moment.getN() > 3) {\n+            double variance = moment.m2 / (moment.n - 1);\n+                if (moment.n <= 3 || variance < 10E-20) {\n+                    kurtosis = 0.0;\n+                } else {\n+                    double n = moment.n;\n+                    kurtosis =\n+                        (n * (n + 1) * moment.m4 -\n+                                3 * moment.m2 * moment.m2 * (n - 1)) /\n+                                ((n - 1) * (n -2) * (n -3) * variance * variance);\n+                }\n+        }\n+        return kurtosis;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear() {\n+        if (incMoment) {\n+            moment.clear();\n+        } else  {\n+            throw MathRuntimeException.createIllegalStateException(\n+                    \"statistics constructed from external moments cannot be cleared\");\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public long getN() {\n+        return moment.getN();\n+    }\n+    \n+    /* UnvariateStatistic Approach  */\n+\n+    /**\n+     * Returns the kurtosis of the entries in the specified portion of the\n+     * input array.  \n+     * <p>\n+     * See {@link Kurtosis} for details on the computing algorithm.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the kurtosis of the values or Double.NaN if length is less than\n+     * 4\n+     * @throws IllegalArgumentException if the input array is null or the array\n+     * index parameters are not valid\n+     */\n+    @Override\n+    public double evaluate(final double[] values,final int begin, final int length) {\n+        // Initialize the kurtosis  \n+        double kurt = Double.NaN;   \n+        \n+        if (test(values, begin, length) && length > 3) {       \n+            \n+            // Compute the mean and standard deviation\n+            Variance variance = new Variance();\n+            variance.incrementAll(values, begin, length);\n+            double mean = variance.moment.m1;\n+            double stdDev = Math.sqrt(variance.getResult());\n+            \n+            // Sum the ^4 of the distance from the mean divided by the\n+            // standard deviation\n+            double accum3 = 0.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                accum3 += Math.pow((values[i] - mean), 4.0);\n+            }\n+            accum3 /= Math.pow(stdDev, 4.0d);\n+            \n+            // Get N\n+            double n0 = length;\n+            \n+            double coefficientOne =\n+                (n0 * (n0 + 1)) / ((n0 - 1) * (n0 - 2) * (n0 - 3));\n+            double termTwo =\n+                ((3 * Math.pow(n0 - 1, 2.0)) / ((n0 - 2) * (n0 - 3)));\n+            \n+            // Calculate kurtosis\n+            kurt = (coefficientOne * accum3) - termTwo;\n+        }       \n+        return kurt;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Kurtosis copy() {\n+        Kurtosis result = new Kurtosis();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source Kurtosis to copy\n+     * @param dest Kurtosis to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(Kurtosis source, Kurtosis dest) {\n+        dest.moment = source.moment.copy();\n+        dest.incMoment = source.incMoment;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.summary.Sum;\n+\n+/**\n+ * <p>Computes the arithmetic mean of a set of values. Uses the definitional \n+ * formula:</p>\n+ * <p>\n+ * mean = sum(x_i) / n\n+ * </p>\n+ * <p>where <code>n</code> is the number of observations.\n+ * </p>\n+ * <p>When {@link #increment(double)} is used to add data incrementally from a\n+ * stream of (unstored) values, the value of the statistic that \n+ * {@link #getResult()} returns is computed using the following recursive\n+ * updating algorithm: </p>\n+ * <ol>\n+ * <li>Initialize <code>m = </code> the first value</li>\n+ * <li>For each additional value, update using <br>\n+ *   <code>m = m + (new value - m) / (number of observations)</code></li>\n+ * </ol>\n+ * <p> If {@link #evaluate(double[])} is used to compute the mean of an array\n+ * of stored values, a two-pass, corrected algorithm is used, starting with\n+ * the definitional formula computed using the array of stored values and then\n+ * correcting this by adding the mean deviation of the data values from the\n+ * arithmetic mean. See, e.g. \"Comparison of Several Algorithms for Computing\n+ * Sample Means and Variances,\" Robert F. Ling, Journal of the American\n+ * Statistical Association, Vol. 69, No. 348 (Dec., 1974), pp. 859-866. </p>\n+ * <p>\n+ *  Returns <code>Double.NaN</code> if the dataset is empty.\n+ * </p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class Mean extends AbstractStorelessUnivariateStatistic \n+    implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -1296043746617791564L;    \n+    \n+    /** First moment on which this statistic is based. */\n+    protected FirstMoment moment;\n+\n+    /** \n+     * Determines whether or not this statistic can be incremented or cleared.\n+     * <p>\n+     * Statistics based on (constructed from) external moments cannot\n+     * be incremented or cleared.</p>\n+     */\n+    protected boolean incMoment;\n+\n+    /** Constructs a Mean. */\n+    public Mean() {\n+        incMoment = true;\n+        moment = new FirstMoment();\n+    }\n+\n+    /**\n+     * Constructs a Mean with an External Moment.\n+     * \n+     * @param m1 the moment\n+     */\n+    public Mean(final FirstMoment m1) {\n+        this.moment = m1;\n+        incMoment = false;\n+    }\n+    \n+    /**\n+     * Copy constructor, creates a new {@code Mean} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Mean} instance to copy\n+     */\n+    public Mean(Mean original) {\n+        copy(original, this);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void increment(final double d) {\n+        if (incMoment) {\n+            moment.increment(d);\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear() {\n+        if (incMoment) {\n+            moment.clear();\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double getResult() {\n+        return moment.m1;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public long getN() {\n+        return moment.getN();\n+    }\n+\n+    /**\n+     * Returns the arithmetic mean of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * <p>\n+     * See {@link Mean} for details on the computing algorithm.</p>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the mean of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    @Override\n+    public double evaluate(final double[] values,final int begin, final int length) {\n+        if (test(values, begin, length)) {\n+            Sum sum = new Sum();\n+            double sampleSize = length;\n+            \n+            // Compute initial estimate using definitional formula\n+            double xbar = sum.evaluate(values, begin, length) / sampleSize;\n+            \n+            // Compute correction factor in second pass\n+            double correction = 0;\n+            for (int i = begin; i < begin + length; i++) {\n+                correction += (values[i] - xbar);\n+            }\n+            return xbar + (correction/sampleSize);\n+        }\n+        return Double.NaN;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Mean copy() {\n+        Mean result = new Mean();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source Mean to copy\n+     * @param dest Mean to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(Mean source, Mean dest) {\n+        dest.incMoment = source.incMoment;\n+        dest.moment = source.moment.copy();\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/SecondMoment.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Computes a statistic related to the Second Central Moment.  Specifically,\n+ * what is computed is the sum of squared deviations from the sample mean.\n+ * <p>\n+ * The following recursive updating formula is used:</p>\n+ * <p>\n+ * Let <ul>\n+ * <li> dev = (current obs - previous mean) </li>\n+ * <li> n = number of observations (including current obs) </li>\n+ * </ul>\n+ * Then</p>\n+ * <p>\n+ * new value = old value + dev^2 * (n -1) / n.</p>\n+ * <p>\n+ * Returns <code>Double.NaN</code> if no data values have been added and\n+ * returns <code>0</code> if there is just one value in the data set.</p>\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.</p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class SecondMoment extends FirstMoment implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 3942403127395076445L;  \n+      \n+    /** second moment of values that have been added */\n+    protected double m2;\n+\n+    /**\n+     * Create a SecondMoment instance\n+     */\n+    public SecondMoment() {\n+        super();\n+        m2 = Double.NaN;\n+    }\n+    \n+    /**\n+     * Copy constructor, creates a new {@code SecondMoment} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code SecondMoment} instance to copy\n+     */\n+    public SecondMoment(SecondMoment original) {\n+        super(original);\n+        this.m2 = original.m2;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void increment(final double d) {\n+        if (n < 1) {\n+            m1 = m2 = 0.0;\n+        }\n+        super.increment(d);\n+        m2 += ((double) n - 1) * dev * nDev;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear() {\n+        super.clear();\n+        m2 = Double.NaN;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double getResult() {\n+        return m2;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SecondMoment copy() {\n+        SecondMoment result = new SecondMoment();\n+        copy(this, result);\n+        return result; \n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source SecondMoment to copy\n+     * @param dest SecondMoment to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(SecondMoment source, SecondMoment dest) {\n+        FirstMoment.copy(source, dest);\n+        dest.m2 = source.m2;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * Computes the skewness of the available values.\n+ * <p>\n+ * We use the following (unbiased) formula to define skewness:</p>\n+ * <p>\n+ * skewness = [n / (n -1) (n - 2)] sum[(x_i - mean)^3] / std^3 </p>\n+ * <p>\n+ * where n is the number of values, mean is the {@link Mean} and std is the \n+ * {@link StandardDeviation} </p>\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally. </p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class Skewness extends AbstractStorelessUnivariateStatistic implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 7101857578996691352L;    \n+    \n+    /** Third moment on which this statistic is based */\n+    protected ThirdMoment moment = null;\n+\n+     /** \n+     * Determines whether or not this statistic can be incremented or cleared.\n+     * <p>\n+     * Statistics based on (constructed from) external moments cannot\n+     * be incremented or cleared.</p>\n+    */\n+    protected boolean incMoment;\n+\n+    /**\n+     * Constructs a Skewness\n+     */\n+    public Skewness() {\n+        incMoment = true;\n+        moment = new ThirdMoment();\n+    }\n+\n+    /**\n+     * Constructs a Skewness with an external moment\n+     * @param m3 external moment\n+     */\n+    public Skewness(final ThirdMoment m3) {\n+        incMoment = false;\n+        this.moment = m3;\n+    }\n+     \n+    /**\n+     * Copy constructor, creates a new {@code Skewness} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Skewness} instance to copy\n+     */\n+    public Skewness(Skewness original) {\n+        copy(original, this);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void increment(final double d) {\n+        if (incMoment) {\n+            moment.increment(d);\n+        }\n+    }\n+\n+    /**\n+     * Returns the value of the statistic based on the values that have been added.\n+     * <p>\n+     * See {@link Skewness} for the definition used in the computation.</p>\n+     * \n+     * @return the skewness of the available values.\n+     */\n+    @Override\n+    public double getResult() {\n+        \n+        if (moment.n < 3) {\n+            return Double.NaN;\n+        }\n+        double variance = moment.m2 / (moment.n - 1);\n+        if (variance < 10E-20) {\n+            return 0.0d;\n+        } else {\n+            double n0 = moment.getN();\n+            return  (n0 * moment.m3) /\n+            ((n0 - 1) * (n0 -2) * Math.sqrt(variance) * variance);\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public long getN() {\n+        return moment.getN();\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear() {\n+        if (incMoment) {\n+            moment.clear();\n+        }\n+    }\n+\n+    /**\n+     * Returns the Skewness of the entries in the specifed portion of the\n+     * input array.\n+     * <p>\n+     * See {@link Skewness} for the definition used in the computation.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * \n+     * @param values the input array\n+     * @param begin the index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the skewness of the values or Double.NaN if length is less than\n+     * 3\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    @Override\n+    public double evaluate(final double[] values,final int begin, \n+            final int length) {\n+\n+        // Initialize the skewness\n+        double skew = Double.NaN;\n+\n+        if (test(values, begin, length) && length > 2 ){\n+            Mean mean = new Mean();\n+            // Get the mean and the standard deviation\n+            double m = mean.evaluate(values, begin, length);\n+            \n+            // Calc the std, this is implemented here instead\n+            // of using the standardDeviation method eliminate\n+            // a duplicate pass to get the mean\n+            double accum = 0.0;\n+            double accum2 = 0.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                accum += Math.pow((values[i] - m), 2.0);\n+                accum2 += (values[i] - m);\n+            }\n+            double stdDev = Math.sqrt((accum - (Math.pow(accum2, 2) / length)) /\n+                    (length - 1));\n+            \n+            double accum3 = 0.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                accum3 += Math.pow(values[i] - m, 3.0d);\n+            }\n+            accum3 /= Math.pow(stdDev, 3.0d);\n+            \n+            // Get N\n+            double n0 = length;\n+            \n+            // Calculate skewness\n+            skew = (n0 / ((n0 - 1) * (n0 - 2))) * accum3;\n+        }\n+        return skew;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Skewness copy() {\n+        Skewness result = new Skewness();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source Skewness to copy\n+     * @param dest Skewness to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(Skewness source, Skewness dest) {\n+        dest.moment = new ThirdMoment(source.moment.copy());\n+        dest.incMoment = source.incMoment;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * Computes the sample standard deviation.  The standard deviation\n+ * is the positive square root of the variance.  This implementation wraps a\n+ * {@link Variance} instance.  The <code>isBiasCorrected</code> property of the\n+ * wrapped Variance instance is exposed, so that this class can be used to\n+ * compute both the \"sample standard deviation\" (the square root of the \n+ * bias-corrected \"sample variance\") or the \"population standard deviation\"\n+ * (the square root of the non-bias-corrected \"population variance\"). See \n+ * {@link Variance} for more information.  \n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.</p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class StandardDeviation extends AbstractStorelessUnivariateStatistic\n+    implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 5728716329662425188L;  \n+    \n+    /** Wrapped Variance instance */\n+    private Variance variance = null;\n+\n+    /**\n+     * Constructs a StandardDeviation.  Sets the underlying {@link Variance}\n+     * instance's <code>isBiasCorrected</code> property to true.\n+     */\n+    public StandardDeviation() {\n+        variance = new Variance();\n+    }\n+\n+    /**\n+     * Constructs a StandardDeviation from an external second moment.\n+     * \n+     * @param m2 the external moment\n+     */\n+    public StandardDeviation(final SecondMoment m2) {\n+        variance = new Variance(m2);\n+    }\n+    \n+    /**\n+     * Copy constructor, creates a new {@code StandardDeviation} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code StandardDeviation} instance to copy\n+     */\n+    public StandardDeviation(StandardDeviation original) {\n+        copy(original, this);\n+    }\n+    \n+    /**\n+     * Contructs a StandardDeviation with the specified value for the\n+     * <code>isBiasCorrected</code> property.  If this property is set to \n+     * <code>true</code>, the {@link Variance} used in computing results will\n+     * use the bias-corrected, or \"sample\" formula.  See {@link Variance} for\n+     * details.\n+     * \n+     * @param isBiasCorrected  whether or not the variance computation will use\n+     * the bias-corrected formula\n+     */\n+    public StandardDeviation(boolean isBiasCorrected) {\n+        variance = new Variance(isBiasCorrected);\n+    }\n+    \n+    /**\n+     * Contructs a StandardDeviation with the specified value for the\n+     * <code>isBiasCorrected</code> property and the supplied external moment.\n+     * If <code>isBiasCorrected</code> is set to <code>true</code>, the\n+     * {@link Variance} used in computing results will use the bias-corrected,\n+     * or \"sample\" formula.  See {@link Variance} for details.\n+     * \n+     * @param isBiasCorrected  whether or not the variance computation will use\n+     * the bias-corrected formula\n+      * @param m2 the external moment\n+     */\n+    public StandardDeviation(boolean isBiasCorrected, SecondMoment m2) {\n+        variance = new Variance(isBiasCorrected, m2);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void increment(final double d) {\n+        variance.increment(d);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public long getN() {\n+        return variance.getN();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double getResult() {\n+        return Math.sqrt(variance.getResult());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear() {\n+        variance.clear();\n+    }\n+\n+    /**\n+     * Returns the Standard Deviation of the entries in the input array, or \n+     * <code>Double.NaN</code> if the array is empty.\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * <p>\n+     * Does not change the internal state of the statistic.</p>\n+     * \n+     * @param values the input array\n+     * @return the standard deviation of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null\n+     */  \n+    @Override\n+    public double evaluate(final double[] values)  {\n+        return Math.sqrt(variance.evaluate(values));\n+    }\n+    \n+    /**\n+     * Returns the Standard Deviation of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample. </p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * <p>\n+     * Does not change the internal state of the statistic.</p>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the standard deviation of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    @Override\n+    public double evaluate(final double[] values, final int begin, final int length)  {\n+       return Math.sqrt(variance.evaluate(values, begin, length));\n+    }\n+    \n+    /**\n+     * Returns the Standard Deviation of the entries in the specified portion of\n+     * the input array, using the precomputed mean value.  Returns\n+     * <code>Double.NaN</code> if the designated subarray is empty.\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n+     * <p>\n+     * The formula used assumes that the supplied mean value is the arithmetic\n+     * mean of the sample data, not a known population parameter.  This method\n+     * is supplied only to save computation when the mean has already been\n+     * computed.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * <p>\n+     * Does not change the internal state of the statistic.</p>\n+     * \n+     * @param values the input array\n+     * @param mean the precomputed mean value\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the standard deviation of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final double mean,\n+            final int begin, final int length)  {\n+        return Math.sqrt(variance.evaluate(values, mean, begin, length));\n+    }\n+    \n+    /**\n+     * Returns the Standard Deviation of the entries in the input array, using\n+     * the precomputed mean value.  Returns\n+     * <code>Double.NaN</code> if the designated subarray is empty.\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n+     * <p>\n+     * The formula used assumes that the supplied mean value is the arithmetic\n+     * mean of the sample data, not a known population parameter.  This method\n+     * is supplied only to save computation when the mean has already been\n+     * computed.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * <p>\n+     * Does not change the internal state of the statistic.</p>\n+     * \n+     * @param values the input array\n+     * @param mean the precomputed mean value\n+     * @return the standard deviation of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public double evaluate(final double[] values, final double mean)  {\n+        return Math.sqrt(variance.evaluate(values, mean));\n+    }\n+    \n+    /**\n+     * @return Returns the isBiasCorrected.\n+     */\n+    public boolean isBiasCorrected() {\n+        return variance.isBiasCorrected();\n+    }\n+\n+    /**\n+     * @param isBiasCorrected The isBiasCorrected to set.\n+     */\n+    public void setBiasCorrected(boolean isBiasCorrected) {\n+        variance.setBiasCorrected(isBiasCorrected);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public StandardDeviation copy() {\n+        StandardDeviation result = new StandardDeviation();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source StandardDeviation to copy\n+     * @param dest StandardDeviation to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(StandardDeviation source, StandardDeviation dest) {\n+        dest.variance = source.variance.copy();\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/ThirdMoment.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+\n+\n+/**\n+ * Computes a statistic related to the Third Central Moment.  Specifically,\n+ * what is computed is the sum of cubed deviations from the sample mean.\n+ * <p>\n+ * The following recursive updating formula is used:</p>\n+ * <p>\n+ * Let <ul>\n+ * <li> dev = (current obs - previous mean) </li>\n+ * <li> m2 = previous value of {@link SecondMoment} </li>\n+ * <li> n = number of observations (including current obs) </li>\n+ * </ul>\n+ * Then</p>\n+ * <p>\n+ * new value = old value - 3 * (dev/n) * m2 + (n-1) * (n -2) * (dev^3/n^2)</p>\n+ * <p>\n+ * Returns <code>Double.NaN</code> if no data values have been added and\n+ * returns <code>0</code> if there is just one value in the data set.</p>\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.</p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class ThirdMoment extends SecondMoment implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -7818711964045118679L;  \n+      \n+    /** third moment of values that have been added */\n+    protected double m3;\n+\n+     /**\n+     * Square of deviation of most recently added value from previous first \n+     * moment, normalized by previous sample size.  Retained to prevent \n+     * repeated computation in higher order moments.  nDevSq = nDev * nDev.\n+     */\n+    protected double nDevSq;\n+\n+    /**\n+     * Create a FourthMoment instance\n+     */\n+    public ThirdMoment() {\n+        super();\n+        m3 = Double.NaN;\n+        nDevSq = Double.NaN;\n+    }\n+    \n+    /**\n+     * Copy constructor, creates a new {@code ThirdMoment} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code ThirdMoment} instance to copy\n+     */\n+    public ThirdMoment(ThirdMoment original) {\n+        copy(original, this);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void increment(final double d) {\n+        if (n < 1) {\n+            m3 = m2 = m1 = 0.0;\n+        }  \n+       \n+        double prevM2 = m2;\n+        super.increment(d);\n+        nDevSq = nDev * nDev;\n+        double n0 = n;\n+        m3 = m3 - 3.0 * nDev * prevM2 + (n0 - 1) * (n0 - 2) * nDevSq * dev;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double getResult() {\n+        return m3;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear() {\n+        super.clear();\n+        m3 = Double.NaN;\n+        nDevSq = Double.NaN;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public ThirdMoment copy() {\n+        ThirdMoment result = new ThirdMoment();\n+        copy(this, result);\n+        return result; \n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source ThirdMoment to copy\n+     * @param dest ThirdMoment to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(ThirdMoment source, ThirdMoment dest) {\n+        SecondMoment.copy(source, dest);\n+        dest.m3 = source.m3;\n+        dest.nDevSq = source.nDevSq;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * Computes the variance of the available values.  By default, the unbiased\n+ * \"sample variance\" definitional formula is used: \n+ * <p>\n+ * variance = sum((x_i - mean)^2) / (n - 1) </p>\n+ * <p>\n+ * where mean is the {@link Mean} and <code>n</code> is the number\n+ * of sample observations.</p>\n+ * <p>\n+ * The definitional formula does not have good numerical properties, so\n+ * this implementation does not compute the statistic using the definitional\n+ * formula. <ul>\n+ * <li> The <code>getResult</code> method computes the variance using \n+ * updating formulas based on West's algorithm, as described in\n+ * <a href=\"http://doi.acm.org/10.1145/359146.359152\"> Chan, T. F. and\n+ * J. G. Lewis 1979, <i>Communications of the ACM</i>,\n+ * vol. 22 no. 9, pp. 526-531.</a></li>\n+ * <li> The <code>evaluate</code> methods leverage the fact that they have the\n+ * full array of values in memory to execute a two-pass algorithm. \n+ * Specifically, these methods use the \"corrected two-pass algorithm\" from\n+ * Chan, Golub, Levesque, <i>Algorithms for Computing the Sample Variance</i>,\n+ * American Statistician, August 1983.</li></ul>\n+ * Note that adding values using <code>increment</code> or \n+ * <code>incrementAll</code> and then executing <code>getResult</code> will\n+ * sometimes give a different, less accurate, result than executing \n+ * <code>evaluate</code> with the full array of values. The former approach\n+ * should only be used when the full array of values is not available.</p>\n+ * <p>\n+ * The \"population variance\"  ( sum((x_i - mean)^2) / n ) can also\n+ * be computed using this statistic.  The <code>isBiasCorrected</code>\n+ * property determines whether the \"population\" or \"sample\" value is\n+ * returned by the <code>evaluate</code> and <code>getResult</code> methods.\n+ * To compute population variances, set this property to <code>false.</code>\n+ * </p>\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.</p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class Variance extends AbstractStorelessUnivariateStatistic implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -9111962718267217978L;  \n+      \n+    /** SecondMoment is used in incremental calculation of Variance*/\n+    protected SecondMoment moment = null;\n+\n+    /**\n+     * Boolean test to determine if this Variance should also increment\n+     * the second moment, this evaluates to false when this Variance is\n+     * constructed with an external SecondMoment as a parameter.\n+     */\n+    protected boolean incMoment = true;\n+    \n+    /**\n+     * Determines whether or not bias correction is applied when computing the\n+     * value of the statisic.  True means that bias is corrected.  See \n+     * {@link Variance} for details on the formula.\n+     */\n+    private boolean isBiasCorrected = true;\n+\n+    /**\n+     * Constructs a Variance with default (true) <code>isBiasCorrected</code>\n+     * property.\n+     */\n+    public Variance() {\n+        moment = new SecondMoment();\n+    }\n+\n+    /**\n+     * Constructs a Variance based on an external second moment.\n+     * \n+     * @param m2 the SecondMoment (Third or Fourth moments work\n+     * here as well.)\n+     */\n+    public Variance(final SecondMoment m2) {\n+        incMoment = false;\n+        this.moment = m2;\n+    }\n+    \n+    /**\n+     * Constructs a Variance with the specified <code>isBiasCorrected</code>\n+     * property\n+     * \n+     * @param isBiasCorrected  setting for bias correction - true means\n+     * bias will be corrected and is equivalent to using the argumentless\n+     * constructor\n+     */\n+    public Variance(boolean isBiasCorrected) {\n+        moment = new SecondMoment();\n+        this.isBiasCorrected = isBiasCorrected;\n+    }\n+    \n+    /**\n+     * Constructs a Variance with the specified <code>isBiasCorrected</code>\n+     * property and the supplied external second moment.\n+     * \n+     * @param isBiasCorrected  setting for bias correction - true means\n+     * bias will be corrected\n+     * @param m2 the SecondMoment (Third or Fourth moments work\n+     * here as well.)\n+     */\n+    public Variance(boolean isBiasCorrected, SecondMoment m2) {\n+        incMoment = false;\n+        this.moment = m2;\n+        this.isBiasCorrected = isBiasCorrected;      \n+    }\n+   \n+    /**\n+     * Copy constructor, creates a new {@code Variance} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Variance} instance to copy\n+     */\n+    public Variance(Variance original) {\n+        copy(original, this);\n+    }           \n+    \n+    /**\n+     * {@inheritDoc}  \n+     * <p>If all values are available, it is more accurate to use \n+     * {@link #evaluate(double[])} rather than adding values one at a time\n+     * using this method and then executing {@link #getResult}, since\n+     * <code>evaluate</code> leverages the fact that is has the full \n+     * list of values together to execute a two-pass algorithm.  \n+     * See {@link Variance}.</p>\n+     */\n+    @Override\n+    public void increment(final double d) {\n+        if (incMoment) {\n+            moment.increment(d);\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double getResult() {\n+            if (moment.n == 0) {\n+                return Double.NaN;\n+            } else if (moment.n == 1) {\n+                return 0d;\n+            } else {\n+                if (isBiasCorrected) {\n+                    return moment.m2 / (moment.n - 1d);\n+                } else {\n+                    return moment.m2 / (moment.n);\n+                }\n+            }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public long getN() {\n+        return moment.getN();\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear() {\n+        if (incMoment) {\n+            moment.clear();\n+        }\n+    }\n+    \n+    /**\n+     * Returns the variance of the entries in the input array, or \n+     * <code>Double.NaN</code> if the array is empty.\n+     * <p>\n+     * See {@link Variance} for details on the computing algorithm.</p>\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * <p>\n+     * Does not change the internal state of the statistic.</p>\n+     * \n+     * @param values the input array\n+     * @return the variance of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    @Override\n+    public double evaluate(final double[] values) {\n+        if (values == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"input values array is null\");\n+        }\n+        return evaluate(values, 0, values.length);\n+    }\n+\n+    /**\n+     * Returns the variance of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * See {@link Variance} for details on the computing algorithm.</p>\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n+     * <p>\n+     * Does not change the internal state of the statistic.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the variance of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    @Override\n+    public double evaluate(final double[] values, final int begin, final int length) {\n+\n+        double var = Double.NaN;\n+\n+        if (test(values, begin, length)) {\n+            clear();\n+            if (length == 1) {\n+                var = 0.0;\n+            } else if (length > 1) {\n+                Mean mean = new Mean();\n+                double m = mean.evaluate(values, begin, length);\n+                var = evaluate(values, m, begin, length);\n+            }\n+        }\n+        return var;\n+    }\n+    \n+    /**\n+     * Returns the variance of the entries in the specified portion of\n+     * the input array, using the precomputed mean value.  Returns \n+     * <code>Double.NaN</code> if the designated subarray is empty.\n+     * <p>\n+     * See {@link Variance} for details on the computing algorithm.</p>\n+     * <p>\n+     * The formula used assumes that the supplied mean value is the arithmetic\n+     * mean of the sample data, not a known population parameter.  This method\n+     * is supplied only to save computation when the mean has already been\n+     * computed.</p>\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * <p>\n+     * Does not change the internal state of the statistic.</p>\n+     * \n+     * @param values the input array\n+     * @param mean the precomputed mean value\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the variance of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final double mean, \n+            final int begin, final int length) {\n+        \n+        double var = Double.NaN;\n+\n+        if (test(values, begin, length)) {\n+            if (length == 1) {\n+                var = 0.0;\n+            } else if (length > 1) {\n+                double accum = 0.0;\n+                double dev = 0.0;\n+                double accum2 = 0.0;\n+                for (int i = begin; i < begin + length; i++) {\n+                    dev = values[i] - mean;\n+                    accum += dev * dev;\n+                    accum2 += dev;\n+                }\n+                double len = length;            \n+                if (isBiasCorrected) {\n+                    var = (accum - (accum2 * accum2 / len)) / (len - 1.0);\n+                } else {\n+                    var = (accum - (accum2 * accum2 / len)) / len;\n+                }\n+            }\n+        }\n+        return var;\n+    }\n+    \n+    /**\n+     * Returns the variance of the entries in the input array, using the\n+     * precomputed mean value.  Returns <code>Double.NaN</code> if the array\n+     * is empty.\n+     * <p>\n+     * See {@link Variance} for details on the computing algorithm.</p>\n+     * <p>\n+     * If <code>isBiasCorrected</code> is <code>true</code> the formula used\n+     * assumes that the supplied mean value is the arithmetic mean of the\n+     * sample data, not a known population parameter.  If the mean is a known\n+     * population parameter, or if the \"population\" version of the variance is\n+     * desired, set <code>isBiasCorrected</code> to <code>false</code> before\n+     * invoking this method.</p>\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * <p>\n+     * Does not change the internal state of the statistic.</p>\n+     * \n+     * @param values the input array\n+     * @param mean the precomputed mean value\n+     * @return the variance of the values or Double.NaN if the array is empty\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public double evaluate(final double[] values, final double mean) {\n+        return evaluate(values, mean, 0, values.length);\n+    }\n+\n+    /**\n+     * @return Returns the isBiasCorrected.\n+     */\n+    public boolean isBiasCorrected() {\n+        return isBiasCorrected;\n+    }\n+\n+    /**\n+     * @param isBiasCorrected The isBiasCorrected to set.\n+     */\n+    public void setBiasCorrected(boolean isBiasCorrected) {\n+        this.isBiasCorrected = isBiasCorrected;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Variance copy() {\n+        Variance result = new Variance();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source Variance to copy\n+     * @param dest Variance to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(Variance source, Variance dest) {\n+        dest.moment = source.moment.copy();\n+        dest.isBiasCorrected = source.isBiasCorrected;\n+        dest.incMoment = source.incMoment;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/VectorialCovariance.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+import org.apache.commons.math.linear.MatrixUtils;\n+import org.apache.commons.math.linear.RealMatrix;\n+\n+/**\n+ * Returns the covariance matrix of the available vectors.\n+ * @since 1.2\n+ * @version $Revision$ $Date$\n+ */\n+public class VectorialCovariance implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 4118372414238930270L;\n+\n+    /** Sums for each component. */\n+    private double[] sums;\n+\n+    /** Sums of products for each component. */\n+    private double[] productsSums;\n+\n+    /** Indicator for bias correction. */\n+    private boolean isBiasCorrected;\n+\n+    /** Number of vectors in the sample. */\n+    private long n;\n+\n+    /** Constructs a VectorialCovariance.\n+     * @param dimension vectors dimension\n+     * @param isBiasCorrected if true, computed the unbiased sample covariance,\n+     * otherwise computes the biased population covariance\n+     */\n+    public VectorialCovariance(int dimension, boolean isBiasCorrected) {\n+        sums         = new double[dimension];\n+        productsSums = new double[dimension * (dimension + 1) / 2];\n+        n            = 0;\n+        this.isBiasCorrected = isBiasCorrected;\n+    }\n+\n+    /**\n+     * Add a new vector to the sample.\n+     * @param v vector to add\n+     * @exception DimensionMismatchException if the vector does not have the right dimension\n+     */\n+    public void increment(double[] v) throws DimensionMismatchException {\n+        if (v.length != sums.length) {\n+            throw new DimensionMismatchException(v.length, sums.length);\n+        }\n+        int k = 0;\n+        for (int i = 0; i < v.length; ++i) {\n+            sums[i] += v[i];\n+            for (int j = 0; j <= i; ++j) {\n+                productsSums[k++] += v[i] * v[j];\n+            }\n+        }\n+        n++;\n+    }\n+\n+    /**\n+     * Get the covariance matrix.\n+     * @return covariance matrix\n+     */\n+    public RealMatrix getResult() {\n+\n+        int dimension = sums.length;\n+        RealMatrix result = MatrixUtils.createRealMatrix(dimension, dimension);\n+\n+        if (n > 1) {\n+            double c = 1.0 / (n * (isBiasCorrected ? (n - 1) : n));\n+            int k = 0;\n+            for (int i = 0; i < dimension; ++i) {\n+                for (int j = 0; j <= i; ++j) {\n+                    double e = c * (n * productsSums[k++] - sums[i] * sums[j]);\n+                    result.setEntry(i, j, e);\n+                    result.setEntry(j, i, e);\n+                }\n+            }\n+        }\n+\n+        return result;\n+\n+    }\n+\n+    /**\n+     * Get the number of vectors in the sample.\n+     * @return number of vectors in the sample\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+\n+    /**\n+     * Clears the internal state of the Statistic\n+     */\n+    public void clear() {\n+        n = 0;\n+        Arrays.fill(sums, 0.0);\n+        Arrays.fill(productsSums, 0.0);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + (isBiasCorrected ? 1231 : 1237);\n+        result = prime * result + (int) (n ^ (n >>> 32));\n+        result = prime * result + Arrays.hashCode(productsSums);\n+        result = prime * result + Arrays.hashCode(sums);\n+        return result;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (!(obj instanceof VectorialCovariance))\n+            return false;\n+        VectorialCovariance other = (VectorialCovariance) obj;\n+        if (isBiasCorrected != other.isBiasCorrected)\n+            return false;\n+        if (n != other.n)\n+            return false;\n+        if (!Arrays.equals(productsSums, other.productsSums))\n+            return false;\n+        if (!Arrays.equals(sums, other.sums))\n+            return false;\n+        return true;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/VectorialMean.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.DimensionMismatchException;\n+\n+/**\n+ * Returns the arithmetic mean of the available vectors.\n+ * @since 1.2\n+ * @version $Revision$ $Date$\n+ */\n+public class VectorialMean implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 8223009086481006892L;\n+\n+    /** Means for each component. */\n+    private Mean[] means;\n+\n+    /** Constructs a VectorialMean.\n+     * @param dimension vectors dimension\n+     */\n+    public VectorialMean(int dimension) {\n+        means = new Mean[dimension];\n+        for (int i = 0; i < dimension; ++i) {\n+            means[i] = new Mean();\n+        }\n+    }\n+\n+    /**\n+     * Add a new vector to the sample.\n+     * @param v vector to add\n+     * @exception DimensionMismatchException if the vector does not have the right dimension\n+     */\n+    public void increment(double[] v) throws DimensionMismatchException {\n+        if (v.length != means.length) {\n+            throw new DimensionMismatchException(v.length, means.length);\n+        }\n+        for (int i = 0; i < v.length; ++i) {\n+            means[i].increment(v[i]);\n+        }\n+    }\n+\n+    /**\n+     * Get the mean vector.\n+     * @return mean vector\n+     */\n+    public double[] getResult() {\n+        double[] result = new double[means.length];\n+        for (int i = 0; i < result.length; ++i) {\n+            result[i] = means[i].getResult();\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Get the number of vectors in the sample.\n+     * @return number of vectors in the sample\n+     */\n+    public long getN() {\n+        return (means.length == 0) ? 0 : means[0].getN();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + Arrays.hashCode(means);\n+        return result;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (!(obj instanceof VectorialMean))\n+            return false;\n+        VectorialMean other = (VectorialMean) obj;\n+        if (!Arrays.equals(means, other.means))\n+            return false;\n+        return true;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/rank/Max.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.rank;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * Returns the maximum of the available values.\n+ * <p>\n+ * <ul>\n+ * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+ * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n+ * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>, \n+ * the result is <code>Double.POSITIVE_INFINITY.</code></li>\n+ * </ul></p>\n+* <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.</p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class Max extends AbstractStorelessUnivariateStatistic implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -5593383832225844641L;    \n+    \n+    /** Number of values that have been added */\n+    private long n;\n+        \n+    /** Current value of the statistic */\n+    private double value;\n+\n+    /**\n+     * Create a Max instance\n+     */\n+    public Max() {\n+        n = 0;\n+        value = Double.NaN;\n+    }\n+    \n+    /**\n+     * Copy constructor, creates a new {@code Max} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Max} instance to copy\n+     */\n+    public Max(Max original) {\n+        copy(original, this);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void increment(final double d) {\n+        if (d > value || Double.isNaN(value)) {\n+            value = d;\n+        }\n+        n++;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear() {\n+        value = Double.NaN;\n+        n = 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double getResult() {\n+        return value;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+    \n+    /**\n+     * Returns the maximum of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null or\n+     * the array index parameters are not valid.</p>\n+     * <p>\n+     * <ul>\n+     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+     * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n+     * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>, \n+     * the result is <code>Double.POSITIVE_INFINITY.</code></li>\n+     * </ul></p>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the maximum of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    @Override\n+    public double evaluate(final double[] values, final int begin, final int length) {\n+        double max = Double.NaN;\n+        if (test(values, begin, length)) {\n+            max = values[begin];\n+            for (int i = begin; i < begin + length; i++) {\n+                if (!Double.isNaN(values[i])) {\n+                    max = (max > values[i]) ? max : values[i];\n+                }\n+            }\n+        }\n+        return max;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Max copy() {\n+        Max result = new Max();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source Max to copy\n+     * @param dest Max to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(Max source, Max dest) {\n+        dest.n = source.n;\n+        dest.value = source.value;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/rank/Median.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.rank;\n+\n+import java.io.Serializable;\n+\n+\n+/**\n+ * Returns the median of the available values.  This is the same as the 50th percentile.\n+ * See {@link Percentile} for a description of the algorithm used.\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.</p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class Median extends Percentile implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -3961477041290915687L;    \n+\n+    /**\n+     * Default constructor.\n+     */\n+    public Median() {\n+        super(50.0);\n+    }\n+    \n+    /**\n+     * Copy constructor, creates a new {@code Median} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Median} instance to copy\n+     */\n+    public Median(Median original) {\n+        super(original);\n+    }        \n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/rank/Min.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.rank;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * Returns the minimum of the available values.\n+ * <p>\n+ * <ul>\n+ * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+ * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n+ * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>, \n+ * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n+ * </ul></p>\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.</p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class Min extends AbstractStorelessUnivariateStatistic implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -2941995784909003131L;  \n+      \n+    /**Number of values that have been added */\n+    private long n;\n+    \n+    /**Current value of the statistic */\n+    private double value;\n+\n+    /**\n+     * Create a Min instance\n+     */\n+    public Min() {\n+        n = 0;\n+        value = Double.NaN;\n+    }\n+    \n+    /**\n+     * Copy constructor, creates a new {@code Min} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Min} instance to copy\n+     */\n+    public Min(Min original) {\n+        copy(original, this);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void increment(final double d) {\n+        if (d < value || Double.isNaN(value)) {\n+            value = d;\n+        }\n+        n++;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear() {\n+        value = Double.NaN;\n+        n = 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double getResult() {\n+        return value;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+    \n+    /**\n+     * Returns the minimum of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null or\n+     * the array index parameters are not valid.</p>\n+     * <p>\n+     * <ul>\n+     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+     * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n+     * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>, \n+     * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n+     * </ul> </p>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the minimum of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    @Override\n+    public double evaluate(final double[] values,final int begin, final int length) {\n+        double min = Double.NaN;\n+        if (test(values, begin, length)) {\n+            min = values[begin];\n+            for (int i = begin; i < begin + length; i++) {\n+                if (!Double.isNaN(values[i])) {\n+                    min = (min < values[i]) ? min : values[i];\n+                }\n+            }\n+        }\n+        return min;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Min copy() {\n+        Min result = new Min();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source Min to copy\n+     * @param dest Min to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(Min source, Min dest) {\n+        dest.n = source.n;\n+        dest.value = source.value;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.rank;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic;\n+\n+/**\n+ * Provides percentile computation.\n+ * <p>\n+ * There are several commonly used methods for estimating percentiles (a.k.a. \n+ * quantiles) based on sample data.  For large samples, the different methods \n+ * agree closely, but when sample sizes are small, different methods will give\n+ * significantly different results.  The algorithm implemented here works as follows:\n+ * <ol>\n+ * <li>Let <code>n</code> be the length of the (sorted) array and \n+ * <code>0 < p <= 100</code> be the desired percentile.</li>\n+ * <li>If <code> n = 1 </code> return the unique array element (regardless of \n+ * the value of <code>p</code>); otherwise </li>\n+ * <li>Compute the estimated percentile position  \n+ * <code> pos = p * (n + 1) / 100</code> and the difference, <code>d</code>\n+ * between <code>pos</code> and <code>floor(pos)</code> (i.e. the fractional\n+ * part of <code>pos</code>).  If <code>pos >= n</code> return the largest\n+ * element in the array; otherwise</li>\n+ * <li>Let <code>lower</code> be the element in position \n+ * <code>floor(pos)</code> in the array and let <code>upper</code> be the\n+ * next element in the array.  Return <code>lower + d * (upper - lower)</code>\n+ * </li>\n+ * </ol></p>\n+ * <p>\n+ * To compute percentiles, the data must be (totally) ordered.  Input arrays\n+ * are copied and then sorted using  {@link java.util.Arrays#sort(double[])}.\n+ * The ordering used by <code>Arrays.sort(double[])</code> is the one determined\n+ * by {@link java.lang.Double#compareTo(Double)}.  This ordering makes \n+ * <code>Double.NaN</code> larger than any other value (including \n+ * <code>Double.POSITIVE_INFINITY</code>).  Therefore, for example, the median\n+ * (50th percentile) of  \n+ * <code>{0, 1, 2, 3, 4, Double.NaN}</code> evaluates to <code>2.5.</code></p>\n+ * <p>\n+ * Since percentile estimation usually involves interpolation between array \n+ * elements, arrays containing  <code>NaN</code> or infinite values will often\n+ * result in <code>NaN<code> or infinite values returned.</p>\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.</p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class Percentile extends AbstractUnivariateStatistic implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -8091216485095130416L; \n+       \n+    /** Determines what percentile is computed when evaluate() is activated \n+     * with no quantile argument */\n+    private double quantile = 0.0;\n+\n+    /**\n+     * Constructs a Percentile with a default quantile\n+     * value of 50.0.\n+     */\n+    public Percentile() {\n+        this(50.0);\n+    }\n+\n+    /**\n+     * Constructs a Percentile with the specific quantile value.\n+     * @param p the quantile\n+     * @throws IllegalArgumentException  if p is not greater than 0 and less\n+     * than or equal to 100\n+     */\n+    public Percentile(final double p) {\n+        setQuantile(p);\n+    }\n+\n+    /**\n+     * Copy constructor, creates a new {@code Percentile} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Percentile} instance to copy\n+     */\n+    public Percentile(Percentile original) {\n+        copy(original, this);\n+    }        \n+    \n+    /**\n+     * Returns an estimate of the <code>p</code>th percentile of the values\n+     * in the <code>values</code> array.\n+     * <p>\n+     * Calls to this method do not modify the internal <code>quantile</code>\n+     * state of this statistic.</p>\n+     * <p>\n+     * <ul>\n+     * <li>Returns <code>Double.NaN</code> if <code>values</code> has length \n+     * <code>0</code></li>\n+     * <li>Returns (for any value of <code>p</code>) <code>values[0]</code>\n+     *  if <code>values</code> has length <code>1</code></li>\n+     * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n+     * is null or p is not a valid quantile value (p must be greater than 0\n+     * and less than or equal to 100) </li>\n+     * </ul></p>\n+     * <p>\n+     * See {@link Percentile} for a description of the percentile estimation\n+     * algorithm used.</p>\n+     * \n+     * @param values input array of values\n+     * @param p the percentile value to compute\n+     * @return the percentile value or Double.NaN if the array is empty\n+     * @throws IllegalArgumentException if <code>values</code> is null \n+     *     or p is invalid\n+     */\n+    public double evaluate(final double[] values, final double p) {\n+        test(values, 0, 0);\n+        return evaluate(values, 0, values.length, p);\n+    }\n+\n+    /**\n+     * Returns an estimate of the <code>quantile</code>th percentile of the\n+     * designated values in the <code>values</code> array.  The quantile\n+     * estimated is determined by the <code>quantile</code> property.\n+     * <p>\n+     * <ul>\n+     * <li>Returns <code>Double.NaN</code> if <code>length = 0</code></li>\n+     * <li>Returns (for any value of <code>quantile</code>) \n+     * <code>values[begin]</code> if <code>length = 1 </code></li>\n+     * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n+     * is null,  or <code>start</code> or <code>length</code> \n+     * is invalid</li>\n+     * </ul></p>\n+     * <p>\n+     * See {@link Percentile} for a description of the percentile estimation\n+     * algorithm used.</p>\n+     * \n+     * @param values the input array\n+     * @param start index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the percentile value\n+     * @throws IllegalArgumentException if the parameters are not valid\n+     * \n+     */\n+    @Override\n+    public double evaluate( final double[] values, final int start, final int length) {\n+        return evaluate(values, start, length, quantile);\n+    }\n+\n+     /**\n+     * Returns an estimate of the <code>p</code>th percentile of the values\n+     * in the <code>values</code> array, starting with the element in (0-based)\n+     * position <code>begin</code> in the array and including <code>length</code>\n+     * values.\n+     * <p>\n+     * Calls to this method do not modify the internal <code>quantile</code>\n+     * state of this statistic.</p>\n+     * <p>\n+     * <ul>\n+     * <li>Returns <code>Double.NaN</code> if <code>length = 0</code></li>\n+     * <li>Returns (for any value of <code>p</code>) <code>values[begin]</code>\n+     *  if <code>length = 1 </code></li>\n+     * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n+     *  is null , <code>begin</code> or <code>length</code> is invalid, or \n+     * <code>p</code> is not a valid quantile value (p must be greater than 0\n+     * and less than or equal to 100)</li>\n+     * </ul></p>\n+     * <p>\n+     * See {@link Percentile} for a description of the percentile estimation\n+     * algorithm used.</p>\n+     * \n+     * @param values array of input values\n+     * @param p  the percentile to compute\n+     * @param begin  the first (0-based) element to include in the computation\n+     * @param length  the number of array elements to include\n+     * @return  the percentile value\n+     * @throws IllegalArgumentException if the parameters are not valid or the\n+     * input array is null\n+     */\n+    public double evaluate(final double[] values, final int begin, \n+            final int length, final double p) {\n+\n+        test(values, begin, length);\n+\n+        if ((p > 100) || (p <= 0)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"out of bounds quantile value: {0}, must be in (0, 100]\", p);\n+        }\n+        if (length == 0) {\n+            return Double.NaN;\n+        }\n+        if (length == 1) {\n+            return values[begin]; // always return single value for n = 1\n+        }\n+        double n = length;\n+        double pos = p * (n + 1) / 100;\n+        double fpos = Math.floor(pos);\n+        int intPos = (int) fpos;\n+        double dif = pos - fpos;\n+        double[] sorted = new double[length];\n+        System.arraycopy(values, begin, sorted, 0, length);\n+        Arrays.sort(sorted);\n+\n+        if (pos < 1) {\n+            return sorted[0];\n+        }\n+        if (pos >= n) {\n+            return sorted[length - 1];\n+        }\n+        double lower = sorted[intPos - 1];\n+        double upper = sorted[intPos];\n+        return lower + dif * (upper - lower);\n+    }\n+\n+    /**\n+     * Returns the value of the quantile field (determines what percentile is\n+     * computed when evaluate() is called with no quantile argument).\n+     * \n+     * @return quantile\n+     */\n+    public double getQuantile() {\n+        return quantile;\n+    }\n+\n+    /**\n+     * Sets the value of the quantile field (determines what percentile is \n+     * computed when evaluate() is called with no quantile argument).\n+     * \n+     * @param p a value between 0 < p <= 100 \n+     * @throws IllegalArgumentException  if p is not greater than 0 and less\n+     * than or equal to 100\n+     */\n+    public void setQuantile(final double p) {\n+        if (p <= 0 || p > 100) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"out of bounds quantile value: {0}, must be in (0, 100]\", p);\n+        }\n+        quantile = p;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Percentile copy() {\n+        Percentile result = new Percentile();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source Percentile to copy\n+     * @param dest Percentile to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(Percentile source, Percentile dest) {\n+        dest.quantile = source.quantile;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.summary;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * Returns the product of the available values.\n+ * <p>\n+ * If there are no values in the dataset, or any of the values are \n+ * <code>NaN</code>, then <code>NaN</code> is returned.</p>\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.</p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class Product extends AbstractStorelessUnivariateStatistic implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 2824226005990582538L;   \n+     \n+    /**The number of values that have been added */\n+    private long n;\n+    \n+    /**\n+     * The current Running Product.\n+     */\n+    private double value;\n+\n+    /**\n+     * Create a Product instance\n+     */\n+    public Product() {\n+        n = 0;\n+        value = Double.NaN;\n+    }\n+    \n+    /**\n+     * Copy constructor, creates a new {@code Product} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Product} instance to copy\n+     */\n+    public Product(Product original) {\n+        copy(original, this);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void increment(final double d) {\n+        if (n == 0) {\n+            value = d;\n+        } else {\n+            value *= d;\n+        }\n+        n++;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double getResult() {\n+        return value;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear() {\n+        value = Double.NaN;\n+        n = 0;\n+    }\n+\n+    /**\n+     * Returns the product of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the product of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    @Override\n+    public double evaluate(final double[] values, final int begin, final int length) {\n+        double product = Double.NaN;\n+        if (test(values, begin, length)) {\n+            product = 1.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                product *= values[i];\n+            }\n+        }\n+        return product;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Product copy() {\n+        Product result = new Product();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source Product to copy\n+     * @param dest Product to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(Product source, Product dest) {\n+        dest.n = source.n;\n+        dest.value = source.value;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.summary;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+  * Returns the sum of the available values.\n+ * <p>\n+ * If there are no values in the dataset, or any of the values are \n+ * <code>NaN</code>, then <code>NaN</code> is returned.</p>\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.</p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class Sum extends AbstractStorelessUnivariateStatistic implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -8231831954703408316L;  \n+      \n+    /** */\n+    private long n;\n+    \n+    /**\n+     * The currently running sum.\n+     */\n+    private double value;\n+\n+    /**\n+     * Create a Sum instance\n+     */\n+    public Sum() {\n+        n = 0;\n+        value = Double.NaN;\n+    }\n+    \n+    /**\n+     * Copy constructor, creates a new {@code Sum} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code Sum} instance to copy\n+     */\n+    public Sum(Sum original) {\n+        copy(original, this);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void increment(final double d) {\n+        if (n == 0) {\n+            value = d;\n+        } else {\n+            value += d;\n+        }\n+        n++;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double getResult() {\n+        return value;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear() {\n+        value = Double.NaN;\n+        n = 0;\n+    }\n+\n+    /**\n+     * The sum of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the sum of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    @Override\n+    public double evaluate(final double[] values, final int begin, final int length) {\n+        double sum = Double.NaN;\n+        if (test(values, begin, length)) {\n+            sum = 0.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                sum += values[i];\n+            }\n+        }\n+        return sum;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Sum copy() {\n+        Sum result = new Sum();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source Sum to copy\n+     * @param dest Sum to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(Sum source, Sum dest) {\n+        dest.n = source.n;\n+        dest.value = source.value;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.summary;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * Returns the sum of the natural logs for this collection of values.  \n+ * <p>\n+ * Uses {@link java.lang.Math#log(double)} to compute the logs.  Therefore,\n+ * <ul>\n+ * <li>If any of values are < 0, the result is <code>NaN.</code></li>\n+ * <li>If all values are non-negative and less than \n+ * <code>Double.POSITIVE_INFINITY</code>,  but at least one value is 0, the\n+ * result is <code>Double.NEGATIVE_INFINITY.</code></li>\n+ * <li>If both <code>Double.POSITIVE_INFINITY</code> and \n+ * <code>Double.NEGATIVE_INFINITY</code> are among the values, the result is\n+ * <code>NaN.</code></li>\n+ * </ul></p>\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.</p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class SumOfLogs extends AbstractStorelessUnivariateStatistic implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -370076995648386763L;    \n+\n+    /**Number of values that have been added */\n+    private int n;\n+    \n+    /**\n+     * The currently running value\n+     */\n+    private double value;\n+    \n+    /**\n+     * Create a SumOfLogs instance\n+     */\n+    public SumOfLogs() {\n+       value = 0d;\n+       n = 0;\n+    }\n+    \n+    /**\n+     * Copy constructor, creates a new {@code SumOfLogs} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code SumOfLogs} instance to copy\n+     */\n+    public SumOfLogs(SumOfLogs original) {\n+        copy(original, this);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void increment(final double d) {\n+        value += Math.log(d);\n+        n++;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double getResult() {\n+        if (n > 0) {\n+            return value;\n+        } else {\n+            return Double.NaN;\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear() {\n+        value = 0d;\n+        n = 0;\n+    }\n+\n+    /**\n+     * Returns the sum of the natural logs of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * <p>\n+     * See {@link SumOfLogs}.</p>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the sum of the natural logs of the values or Double.NaN if \n+     * length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    @Override\n+    public double evaluate(final double[] values, final int begin, final int length) {\n+        double sumLog = Double.NaN;\n+        if (test(values, begin, length)) {\n+            sumLog = 0.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                sumLog += Math.log(values[i]);\n+            }\n+        }\n+        return sumLog;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SumOfLogs copy() {\n+        SumOfLogs result = new SumOfLogs();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source SumOfLogs to copy\n+     * @param dest SumOfLogs to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(SumOfLogs source, SumOfLogs dest) {\n+        dest.n = source.n;\n+        dest.value = source.value;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.summary;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * Returns the sum of the squares of the available values.\n+ * <p>\n+ * If there are no values in the dataset, or any of the values are \n+ * <code>NaN</code>, then <code>NaN</code> is returned.</p>\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.</p>\n+ * \n+ * @version $Revision$ $Date$\n+ */\n+public class SumOfSquares extends AbstractStorelessUnivariateStatistic implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 1460986908574398008L;  \n+      \n+    /** */\n+    private long n;\n+    \n+    /**\n+     * The currently running sumSq\n+     */\n+    private double value;\n+\n+    /**\n+     * Create a SumOfSquares instance\n+     */\n+    public SumOfSquares() {\n+        n = 0;\n+        value = Double.NaN;\n+    }\n+    \n+    /**\n+     * Copy constructor, creates a new {@code SumOfSquares} identical\n+     * to the {@code original}\n+     * \n+     * @param original the {@code SumOfSquares} instance to copy\n+     */\n+    public SumOfSquares(SumOfSquares original) {\n+        copy(original, this);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void increment(final double d) {\n+        if (n == 0) {\n+            value = d * d;\n+        } else {\n+            value += d * d;\n+        }\n+        n++;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double getResult() {\n+        return value;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void clear() {\n+        value = Double.NaN;\n+        n = 0;\n+    }\n+\n+    /**\n+     * Returns the sum of the squares of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the sum of the squares of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    @Override\n+    public double evaluate(final double[] values,final int begin, final int length) {\n+        double sumSq = Double.NaN;\n+        if (test(values, begin, length)) {\n+            sumSq = 0.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                sumSq += values[i] * values[i];\n+            }\n+        }\n+        return sumSq;\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SumOfSquares copy() {\n+        SumOfSquares result = new SumOfSquares();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     * \n+     * @param source SumOfSquares to copy\n+     * @param dest SumOfSquares to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(SumOfSquares source, SumOfSquares dest) {\n+        dest.n = source.n;\n+        dest.value = source.value;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/inference/ChiSquareTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.inference;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * An interface for Chi-Square tests.\n+ * <p>This interface handles only known distributions. If the distribution is\n+ * unknown and should be provided by a sample, then the {@link UnknownDistributionChiSquareTest\n+ * UnknownDistributionChiSquareTest} extended interface should be used instead.</p>\n+ * @version $Revision$ $Date$ \n+ */\n+public interface ChiSquareTest {\n+     \n+     /**\n+     * Computes the <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm\">\n+     * Chi-Square statistic</a> comparing <code>observed</code> and <code>expected</code> \n+     * frequency counts. \n+     * <p>\n+     * This statistic can be used to perform a Chi-Square test evaluating the null hypothesis that\n+     *  the observed counts follow the expected distribution.</p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>Expected counts must all be positive.  \n+     * </li>\n+     * <li>Observed counts must all be >= 0.   \n+     * </li>\n+     * <li>The observed and expected arrays must have the same length and\n+     * their common length must be at least 2.  \n+     * </li></ul></p><p>\n+     * If any of the preconditions are not met, an \n+     * <code>IllegalArgumentException</code> is thrown.</p>\n+     *\n+     * @param observed array of observed frequency counts\n+     * @param expected array of expected frequency counts\n+     * @return chiSquare statistic\n+     * @throws IllegalArgumentException if preconditions are not met\n+     */\n+    double chiSquare(double[] expected, long[] observed) \n+        throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns the <i>observed significance level</i>, or <a href=\n+     * \"http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue\">\n+     * p-value</a>, associated with a \n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm\">\n+     * Chi-square goodness of fit test</a> comparing the <code>observed</code> \n+     * frequency counts to those in the <code>expected</code> array.\n+     * <p>\n+     * The number returned is the smallest significance level at which one can reject \n+     * the null hypothesis that the observed counts conform to the frequency distribution \n+     * described by the expected counts.</p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>Expected counts must all be positive.  \n+     * </li>\n+     * <li>Observed counts must all be >= 0.   \n+     * </li>\n+     * <li>The observed and expected arrays must have the same length and\n+     * their common length must be at least 2.  \n+     * </li></ul></p><p>\n+     * If any of the preconditions are not met, an \n+     * <code>IllegalArgumentException</code> is thrown.</p>\n+     *\n+     * @param observed array of observed frequency counts\n+     * @param expected array of expected frequency counts\n+     * @return p-value\n+     * @throws IllegalArgumentException if preconditions are not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    double chiSquareTest(double[] expected, long[] observed) \n+        throws IllegalArgumentException, MathException;\n+    \n+    /**\n+     * Performs a <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda35f.htm\">\n+     * Chi-square goodness of fit test</a> evaluating the null hypothesis that the observed counts \n+     * conform to the frequency distribution described by the expected counts, with \n+     * significance level <code>alpha</code>.  Returns true iff the null hypothesis can be rejected\n+     * with 100 * (1 - alpha) percent confidence.\n+     * <p>\n+     * <strong>Example:</strong><br>\n+     * To test the hypothesis that <code>observed</code> follows \n+     * <code>expected</code> at the 99% level, use </p><p>\n+     * <code>chiSquareTest(expected, observed, 0.01) </code></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>Expected counts must all be positive.  \n+     * </li>\n+     * <li>Observed counts must all be >= 0.   \n+     * </li>\n+     * <li>The observed and expected arrays must have the same length and\n+     * their common length must be at least 2.  \n+     * <li> <code> 0 < alpha < 0.5 </code>\n+     * </li></ul></p><p>\n+     * If any of the preconditions are not met, an \n+     * <code>IllegalArgumentException</code> is thrown.</p>\n+     *\n+     * @param observed array of observed frequency counts\n+     * @param expected array of expected frequency counts\n+     * @param alpha significance level of the test\n+     * @return true iff null hypothesis can be rejected with confidence\n+     * 1 - alpha\n+     * @throws IllegalArgumentException if preconditions are not met\n+     * @throws MathException if an error occurs performing the test\n+     */\n+    boolean chiSquareTest(double[] expected, long[] observed, double alpha) \n+        throws IllegalArgumentException, MathException;\n+    \n+    /**\n+     *  Computes the Chi-Square statistic associated with a \n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm\">\n+     *  chi-square test of independence</a> based on the input <code>counts</code>\n+     *  array, viewed as a two-way table.  \n+     * <p>\n+     * The rows of the 2-way table are \n+     * <code>count[0], ... , count[count.length - 1] </code></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>All counts must be >= 0.  \n+     * </li>\n+     * <li>The count array must be rectangular (i.e. all count[i] subarrays\n+     *  must have the same length). \n+     * </li>\n+     * <li>The 2-way table represented by <code>counts</code> must have at\n+     *  least 2 columns and at least 2 rows.\n+     * </li>\n+     * </li></ul></p><p>\n+     * If any of the preconditions are not met, an \n+     * <code>IllegalArgumentException</code> is thrown.</p>\n+     *\n+     * @param counts array representation of 2-way table\n+     * @return chiSquare statistic\n+     * @throws IllegalArgumentException if preconditions are not met\n+     */\n+    double chiSquare(long[][] counts) \n+    throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns the <i>observed significance level</i>, or <a href=\n+     * \"http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue\">\n+     * p-value</a>, associated with a \n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm\">\n+     * chi-square test of independence</a> based on the input <code>counts</code>\n+     * array, viewed as a two-way table.  \n+     * <p>\n+     * The rows of the 2-way table are \n+     * <code>count[0], ... , count[count.length - 1] </code></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>All counts must be >= 0.  \n+     * </li>\n+     * <li>The count array must be rectangular (i.e. all count[i] subarrays must have the same length). \n+     * </li>\n+     * <li>The 2-way table represented by <code>counts</code> must have at least 2 columns and\n+     *        at least 2 rows.\n+     * </li>\n+     * </li></ul></p><p>\n+     * If any of the preconditions are not met, an \n+     * <code>IllegalArgumentException</code> is thrown.</p>\n+     *\n+     * @param counts array representation of 2-way table\n+     * @return p-value\n+     * @throws IllegalArgumentException if preconditions are not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    double chiSquareTest(long[][] counts) \n+    throws IllegalArgumentException, MathException;\n+    \n+    /**\n+     * Performs a <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section4/prc45.htm\">\n+     * chi-square test of independence</a> evaluating the null hypothesis that the classifications \n+     * represented by the counts in the columns of the input 2-way table are independent of the rows,\n+     * with significance level <code>alpha</code>.  Returns true iff the null hypothesis can be rejected\n+     * with 100 * (1 - alpha) percent confidence.\n+     * <p>\n+     * The rows of the 2-way table are \n+     * <code>count[0], ... , count[count.length - 1] </code></p>\n+     * <p>\n+     * <strong>Example:</strong><br>\n+     * To test the null hypothesis that the counts in\n+     * <code>count[0], ... , count[count.length - 1] </code>\n+     *  all correspond to the same underlying probability distribution at the 99% level, use </p><p>\n+     * <code>chiSquareTest(counts, 0.01) </code></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>All counts must be >= 0.  \n+     * </li>\n+     * <li>The count array must be rectangular (i.e. all count[i] subarrays must have the same length). \n+     * </li>\n+     * <li>The 2-way table represented by <code>counts</code> must have at least 2 columns and\n+     *        at least 2 rows.\n+     * </li>\n+     * </li></ul></p><p>\n+     * If any of the preconditions are not met, an \n+     * <code>IllegalArgumentException</code> is thrown.</p>\n+     *\n+     * @param counts array representation of 2-way table\n+     * @param alpha significance level of the test\n+     * @return true iff null hypothesis can be rejected with confidence\n+     * 1 - alpha\n+     * @throws IllegalArgumentException if preconditions are not met\n+     * @throws MathException if an error occurs performing the test\n+     */\n+    boolean chiSquareTest(long[][] counts, double alpha) \n+    throws IllegalArgumentException, MathException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/inference/ChiSquareTestImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.inference;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.distribution.ChiSquaredDistribution;\n+import org.apache.commons.math.distribution.ChiSquaredDistributionImpl;\n+\n+/**\n+ * Implements Chi-Square test statistics defined in the\n+ * {@link UnknownDistributionChiSquareTest} interface.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class ChiSquareTestImpl implements UnknownDistributionChiSquareTest {\n+\n+    /** Distribution used to compute inference statistics. */\n+    private ChiSquaredDistribution distribution;\n+  \n+    /**\n+     * Construct a ChiSquareTestImpl \n+     */\n+    public ChiSquareTestImpl() {\n+        this(new ChiSquaredDistributionImpl(1.0));\n+    }\n+\n+    /**\n+     * Create a test instance using the given distribution for computing\n+     * inference statistics.\n+     * @param x distribution used to compute inference statistics.\n+     * @since 1.2\n+     */\n+    public ChiSquareTestImpl(ChiSquaredDistribution x) {\n+        super();\n+        setDistribution(x);\n+    }\n+     /**\n+     * {@inheritDoc}\n+     * <p><strong>Note: </strong>This implementation rescales the \n+     * <code>expected</code> array if necessary to ensure that the sum of the\n+     * expected and observed counts are equal.</p>\n+     * \n+     * @param observed array of observed frequency counts\n+     * @param expected array of expected frequency counts\n+     * @return chi-square test statistic\n+     * @throws IllegalArgumentException if preconditions are not met\n+     * or length is less than 2\n+     */\n+    public double chiSquare(double[] expected, long[] observed)\n+        throws IllegalArgumentException {\n+        if (expected.length < 2) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"expected array length = {0}, must be at least 2\",\n+                  expected.length);\n+        }\n+        if (expected.length != observed.length) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"dimension mismatch {0} != {1}\", expected.length, observed.length);\n+        }\n+        checkPositive(expected);\n+        checkNonNegative(observed);\n+        double sumExpected = 0d;\n+        double sumObserved = 0d;\n+        for (int i = 0; i < observed.length; i++) {\n+            sumExpected += expected[i];\n+            sumObserved += observed[i];\n+        }\n+        double ratio = 1.0d;\n+        boolean rescale = false;\n+        if (Math.abs(sumExpected - sumObserved) > 10E-6) {\n+            ratio = sumObserved / sumExpected;\n+            rescale = true;\n+        }\n+        double sumSq = 0.0d;\n+        double dev = 0.0d;\n+        for (int i = 0; i < observed.length; i++) {\n+            if (rescale) {\n+                dev = (observed[i] - ratio * expected[i]);\n+                sumSq += dev * dev / (ratio * expected[i]);\n+            } else {\n+                dev = (observed[i] - expected[i]);\n+                sumSq += dev * dev / expected[i];\n+            }\n+        }\n+        return sumSq;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p><strong>Note: </strong>This implementation rescales the \n+     * <code>expected</code> array if necessary to ensure that the sum of the\n+     * expected and observed counts are equal.</p>\n+     * \n+     * @param observed array of observed frequency counts\n+     * @param expected array of expected frequency counts\n+     * @return p-value\n+     * @throws IllegalArgumentException if preconditions are not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    public double chiSquareTest(double[] expected, long[] observed)\n+        throws IllegalArgumentException, MathException {\n+        distribution.setDegreesOfFreedom(expected.length - 1.0);\n+        return 1.0 - distribution.cumulativeProbability(\n+            chiSquare(expected, observed));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * <p><strong>Note: </strong>This implementation rescales the \n+     * <code>expected</code> array if necessary to ensure that the sum of the\n+     * expected and observed counts are equal.</p>\n+     * \n+     * @param observed array of observed frequency counts\n+     * @param expected array of expected frequency counts\n+     * @param alpha significance level of the test\n+     * @return true iff null hypothesis can be rejected with confidence\n+     * 1 - alpha\n+     * @throws IllegalArgumentException if preconditions are not met\n+     * @throws MathException if an error occurs performing the test\n+     */\n+    public boolean chiSquareTest(double[] expected, long[] observed, \n+            double alpha) throws IllegalArgumentException, MathException {\n+        if ((alpha <= 0) || (alpha > 0.5)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"out of bounds significance level {0}, must be between {1} and {2}\",\n+                  alpha, 0, 0.5);\n+        }\n+        return (chiSquareTest(expected, observed) < alpha);\n+    }\n+    \n+    /**\n+     * @param counts array representation of 2-way table\n+     * @return chi-square test statistic\n+     * @throws IllegalArgumentException if preconditions are not met\n+     */\n+    public double chiSquare(long[][] counts) throws IllegalArgumentException {\n+        \n+        checkArray(counts);\n+        int nRows = counts.length;\n+        int nCols = counts[0].length;\n+        \n+        // compute row, column and total sums\n+        double[] rowSum = new double[nRows];\n+        double[] colSum = new double[nCols];\n+        double total = 0.0d;\n+        for (int row = 0; row < nRows; row++) {\n+            for (int col = 0; col < nCols; col++) {\n+                rowSum[row] += counts[row][col];\n+                colSum[col] += counts[row][col];\n+                total += counts[row][col];\n+            }\n+        }\n+        \n+        // compute expected counts and chi-square\n+        double sumSq = 0.0d;\n+        double expected = 0.0d;\n+        for (int row = 0; row < nRows; row++) {\n+            for (int col = 0; col < nCols; col++) {\n+                expected = (rowSum[row] * colSum[col]) / total;\n+                sumSq += ((counts[row][col] - expected) * \n+                        (counts[row][col] - expected)) / expected; \n+            }\n+        } \n+        return sumSq;\n+    }\n+\n+    /**\n+     * @param counts array representation of 2-way table\n+     * @return p-value\n+     * @throws IllegalArgumentException if preconditions are not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    public double chiSquareTest(long[][] counts)\n+    throws IllegalArgumentException, MathException {\n+        checkArray(counts);\n+        double df = ((double) counts.length -1) * ((double) counts[0].length - 1);\n+        distribution.setDegreesOfFreedom(df);\n+        return 1 - distribution.cumulativeProbability(chiSquare(counts));\n+    }\n+\n+    /**\n+     * @param counts array representation of 2-way table\n+     * @param alpha significance level of the test\n+     * @return true iff null hypothesis can be rejected with confidence\n+     * 1 - alpha\n+     * @throws IllegalArgumentException if preconditions are not met\n+     * @throws MathException if an error occurs performing the test\n+     */\n+    public boolean chiSquareTest(long[][] counts, double alpha)\n+    throws IllegalArgumentException, MathException {\n+        if ((alpha <= 0) || (alpha > 0.5)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"out of bounds significance level {0}, must be between {1} and {2}\",\n+                  alpha, 0.0, 0.5);\n+        }\n+        return (chiSquareTest(counts) < alpha);\n+    }\n+    \n+    /**\n+     * @param observed1 array of observed frequency counts of the first data set\n+     * @param observed2 array of observed frequency counts of the second data set\n+     * @return chi-square test statistic\n+     * @throws IllegalArgumentException if preconditions are not met\n+     * @since 1.2\n+     */\n+    public double chiSquareDataSetsComparison(long[] observed1, long[] observed2)\n+        throws IllegalArgumentException {\n+        \n+        // Make sure lengths are same\n+        if (observed1.length < 2) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"observed array length = {0}, must be at least 2\",\n+                  observed1.length);\n+        }\n+        if (observed1.length != observed2.length) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"dimension mismatch {0} != {1}\",\n+                  observed1.length, observed2.length);\n+        }\n+\n+        // Ensure non-negative counts\n+        checkNonNegative(observed1);\n+        checkNonNegative(observed2);\n+\n+        // Compute and compare count sums\n+        long countSum1 = 0;\n+        long countSum2 = 0;\n+        boolean unequalCounts = false;\n+        double weight = 0.0;\n+        for (int i = 0; i < observed1.length; i++) {\n+            countSum1 += observed1[i];\n+            countSum2 += observed2[i];   \n+        }\n+        // Ensure neither sample is uniformly 0\n+        if (countSum1 == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"observed counts are all 0 in first observed array\"); \n+        }\n+        if (countSum2 == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"observed counts are all 0 in second observed array\"); \n+        }\n+        // Compare and compute weight only if different\n+        unequalCounts = (countSum1 != countSum2);\n+        if (unequalCounts) {\n+            weight = Math.sqrt((double) countSum1 / (double) countSum2);\n+        }\n+        // Compute ChiSquare statistic\n+        double sumSq = 0.0d;\n+        double dev = 0.0d;\n+        double obs1 = 0.0d;\n+        double obs2 = 0.0d;\n+        for (int i = 0; i < observed1.length; i++) {\n+            if (observed1[i] == 0 && observed2[i] == 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"observed counts are both zero for entry {0}\", i);\n+            } else {\n+                obs1 = observed1[i];\n+                obs2 = observed2[i];\n+                if (unequalCounts) { // apply weights\n+                    dev = obs1/weight - obs2 * weight;\n+                } else {\n+                    dev = obs1 - obs2;\n+                }\n+                sumSq += (dev * dev) / (obs1 + obs2);\n+            }\n+        }\n+        return sumSq;\n+    }\n+\n+    /**\n+     * @param observed1 array of observed frequency counts of the first data set\n+     * @param observed2 array of observed frequency counts of the second data set\n+     * @return p-value\n+     * @throws IllegalArgumentException if preconditions are not met\n+     * @throws MathException if an error occurs computing the p-value\n+     * @since 1.2\n+     */\n+    public double chiSquareTestDataSetsComparison(long[] observed1, long[] observed2)\n+        throws IllegalArgumentException, MathException {\n+        distribution.setDegreesOfFreedom((double) observed1.length - 1);\n+        return 1 - distribution.cumulativeProbability(\n+                chiSquareDataSetsComparison(observed1, observed2));\n+    }\n+\n+    /**\n+     * @param observed1 array of observed frequency counts of the first data set\n+     * @param observed2 array of observed frequency counts of the second data set\n+     * @param alpha significance level of the test\n+     * @return true iff null hypothesis can be rejected with confidence\n+     * 1 - alpha\n+     * @throws IllegalArgumentException if preconditions are not met\n+     * @throws MathException if an error occurs performing the test\n+     * @since 1.2\n+     */\n+    public boolean chiSquareTestDataSetsComparison(long[] observed1, long[] observed2,\n+            double alpha) throws IllegalArgumentException, MathException {\n+        if ((alpha <= 0) || (alpha > 0.5)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"out of bounds significance level {0}, must be between {1} and {2}\",\n+                  alpha, 0.0, 0.5);\n+        }\n+        return (chiSquareTestDataSetsComparison(observed1, observed2) < alpha);\n+    }\n+\n+    /**\n+     * Checks to make sure that the input long[][] array is rectangular,\n+     * has at least 2 rows and 2 columns, and has all non-negative entries,\n+     * throwing IllegalArgumentException if any of these checks fail.\n+     * \n+     * @param in input 2-way table to check\n+     * @throws IllegalArgumentException if the array is not valid\n+     */\n+    private void checkArray(long[][] in) throws IllegalArgumentException {\n+        \n+        if (in.length < 2) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"invalid row dimension: {0} (must be at least 2)\",\n+                  in.length);\n+        }\n+        \n+        if (in[0].length < 2) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"invalid column dimension: {0} (must be at least 2)\",\n+                  in[0].length);\n+        }    \n+        \n+        checkRectangular(in);\n+        checkNonNegative(in);\n+        \n+    }\n+    \n+    //---------------------  Private array methods -- should find a utility home for these\n+    \n+    /**\n+     * Throws IllegalArgumentException if the input array is not rectangular.\n+     * \n+     * @param in array to be tested\n+     * @throws NullPointerException if input array is null\n+     * @throws IllegalArgumentException if input array is not rectangular\n+     */\n+    private void checkRectangular(long[][] in) {\n+        for (int i = 1; i < in.length; i++) {\n+            if (in[i].length != in[0].length) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"some rows have length {0} while others have length {1}\",\n+                      in[i].length, in[0].length);\n+            }\n+        }  \n+    }\n+    \n+    /**\n+     * Check all entries of the input array are > 0.\n+     * \n+     * @param in array to be tested\n+     * @exception IllegalArgumentException if one entry is not positive\n+     */\n+    private void checkPositive(double[] in) throws IllegalArgumentException {\n+        for (int i = 0; i < in.length; i++) {\n+            if (in[i] <= 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"element {0} is not positive: {1}\",\n+                      i, in[i]);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Check all entries of the input array are >= 0.\n+     * \n+     * @param in array to be tested\n+     * @exception IllegalArgumentException if one entry is negative\n+     */\n+    private void checkNonNegative(long[] in) throws IllegalArgumentException {\n+        for (int i = 0; i < in.length; i++) {\n+            if (in[i] < 0) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"element {0} is negative: {1}\",\n+                      i, in[i]);\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Check all entries of the input array are >= 0.\n+     * \n+     * @param in array to be tested\n+     * @exception IllegalArgumentException if one entry is negative\n+     */\n+    private void checkNonNegative(long[][] in) throws IllegalArgumentException {\n+        for (int i = 0; i < in.length; i ++) {\n+            for (int j = 0; j < in[i].length; j++) {\n+                if (in[i][j] < 0) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                          \"element ({0}, {1}) is negative: {2}\",\n+                          i, j, in[i][j]);\n+                }\n+            }\n+        }\n+    }\n+ \n+    /**\n+     * Modify the distribution used to compute inference statistics.\n+     * \n+     * @param value\n+     *            the new distribution\n+     * @since 1.2\n+     */\n+    public void setDistribution(ChiSquaredDistribution value) {\n+        distribution = value;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/inference/OneWayAnova.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.inference;\n+\n+import org.apache.commons.math.MathException;\n+import java.util.Collection;\n+\n+/**\n+ * An interface for one-way ANOVA (analysis of variance). \n+ *\n+ * <p> Tests for differences between two or more categories of univariate data\n+ * (for example, the body mass index of accountants, lawyers, doctors and\n+ * computer programmers).  When two categories are given, this is equivalent to\n+ * the {@link org.apache.commons.math.stat.inference.TTest}.\n+ * </p>\n+ *\n+ * @since 1.2\n+ * @version $Revision$ $Date$ \n+ */\n+public interface OneWayAnova {\n+    /**\n+     * Computes the ANOVA F-value for a collection of <code>double[]</code>\n+     * arrays.\n+     * \n+     * <p><strong>Preconditions</strong>: <ul>\n+     * <li>The categoryData <code>Collection</code> must contain\n+     * <code>double[]</code> arrays.</li>\n+     * <li> There must be at least two <code>double[]</code> arrays in the\n+     * <code>categoryData</code> collection and each of these arrays must\n+     * contain at least two values.</li></ul></p>\n+     *\n+     * @param categoryData <code>Collection</code> of <code>double[]</code>\n+     * arrays each containing data for one category\n+     * @return Fvalue\n+     * @throws IllegalArgumentException if the preconditions are not met\n+     * @throws MathException if the statistic can not be computed do to a\n+     *         convergence or other numerical error.\n+     */\n+    public double anovaFValue(Collection<double[]> categoryData)\n+        throws IllegalArgumentException, MathException;\n+\n+    /**\n+     * Computes the ANOVA P-value for a collection of <code>double[]</code>\n+     * arrays.\n+     *\n+     * <p><strong>Preconditions</strong>: <ul>\n+     * <li>The categoryData <code>Collection</code> must contain\n+     * <code>double[]</code> arrays.</li>\n+     * <li> There must be at least two <code>double[]</code> arrays in the\n+     * <code>categoryData</code> collection and each of these arrays must\n+     * contain at least two values.</li></ul></p>\n+     *\n+     * @param categoryData <code>Collection</code> of <code>double[]</code>\n+     * arrays each containing data for one category\n+     * @return Pvalue\n+     * @throws IllegalArgumentException if the preconditions are not met\n+     * @throws MathException if the statistic can not be computed do to a\n+     *         convergence or other numerical error.\n+     */\n+    public double anovaPValue(Collection<double[]> categoryData)\n+        throws IllegalArgumentException, MathException;\n+\n+    /**\n+     * Performs an ANOVA test, evaluating the null hypothesis that there\n+     * is no difference among the means of the data categories.\n+     * \n+     * <p><strong>Preconditions</strong>: <ul>\n+     * <li>The categoryData <code>Collection</code> must contain\n+     * <code>double[]</code> arrays.</li>\n+     * <li> There must be at least two <code>double[]</code> arrays in the\n+     * <code>categoryData</code> collection and each of these arrays must\n+     * contain at least two values.</li>\n+     * <li>alpha must be strictly greater than 0 and less than or equal to 0.5.\n+     * </li></ul></p>\n+     *\n+     * @param categoryData <code>Collection</code> of <code>double[]</code>\n+     * arrays each containing data for one category\n+     * @param alpha significance level of the test\n+     * @return true if the null hypothesis can be rejected with \n+     * confidence 1 - alpha\n+     * @throws IllegalArgumentException if the preconditions are not met\n+     * @throws MathException if the statistic can not be computed do to a\n+     *         convergence or other numerical error.\n+    */\n+    public boolean anovaTest(Collection<double[]> categoryData, double alpha)\n+        throws IllegalArgumentException, MathException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/inference/OneWayAnovaImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.inference;\n+\n+import java.util.Collection;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.distribution.FDistribution;\n+import org.apache.commons.math.distribution.FDistributionImpl;\n+import org.apache.commons.math.stat.descriptive.summary.Sum;\n+import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n+\n+\n+/**\n+ * Implements one-way ANOVA statistics defined in the {@link OneWayAnovaImpl}\n+ * interface.\n+ * \n+ * <p>Uses the \n+ * {@link org.apache.commons.math.distribution.FDistribution\n+ *  commons-math F Distribution implementation} to estimate exact p-values.</p>\n+ *\n+ * <p>This implementation is based on a description at \n+ * http://faculty.vassar.edu/lowry/ch13pt1.html</p>\n+ * <pre>\n+ * Abbreviations: bg = between groups,\n+ *                wg = within groups,\n+ *                ss = sum squared deviations\n+ * </pre>\n+ *\n+ * @since 1.2\n+ * @version $Revision$ $Date$\n+ */\n+public class OneWayAnovaImpl implements OneWayAnova  {\n+\n+    /**\n+     * Default constructor.\n+     */\n+    public OneWayAnovaImpl() {\n+    }\n+    \n+    /**\n+     * {@inheritDoc}<p>\n+     * This implementation computes the F statistic using the definitional \n+     * formula<pre>\n+     *   F = msbg/mswg</pre>\n+     * where<pre>\n+     *  msbg = between group mean square\n+     *  mswg = within group mean square</pre>\n+     * are as defined <a href=\"http://faculty.vassar.edu/lowry/ch13pt1.html\">\n+     * here</a></p>\n+     */\n+    public double anovaFValue(Collection<double[]> categoryData)\n+        throws IllegalArgumentException, MathException {\n+        AnovaStats a = anovaStats(categoryData);\n+        return a.F;\n+    }\n+\n+    /**\n+     * {@inheritDoc}<p>\n+     * This implementation uses the\n+     * {@link org.apache.commons.math.distribution.FDistribution\n+     * commons-math F Distribution implementation} to estimate the exact\n+     * p-value, using the formula<pre>\n+     *   p = 1 - cumulativeProbability(F)</pre>\n+     * where <code>F</code> is the F value and <code>cumulativeProbability</code>\n+     * is the commons-math implementation of the F distribution.</p>\n+     */\n+    public double anovaPValue(Collection<double[]> categoryData)\n+        throws IllegalArgumentException, MathException {\n+        AnovaStats a = anovaStats(categoryData);\n+        FDistribution fdist = new FDistributionImpl(a.dfbg, a.dfwg);\n+        return 1.0 - fdist.cumulativeProbability(a.F);\n+    }\n+\n+    /**\n+     * {@inheritDoc}<p>\n+     * This implementation uses the\n+     * {@link org.apache.commons.math.distribution.FDistribution\n+     * commons-math F Distribution implementation} to estimate the exact\n+     * p-value, using the formula<pre>\n+     *   p = 1 - cumulativeProbability(F)</pre>\n+     * where <code>F</code> is the F value and <code>cumulativeProbability</code>\n+     * is the commons-math implementation of the F distribution.</p>\n+     * <p>True is returned iff the estimated p-value is less than alpha.</p>\n+     */\n+    public boolean anovaTest(Collection<double[]> categoryData, double alpha)\n+        throws IllegalArgumentException, MathException {\n+        if ((alpha <= 0) || (alpha > 0.5)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"out of bounds significance level {0}, must be between {1} and {2}\",\n+                  alpha, 0, 0.5);\n+        }\n+        return (anovaPValue(categoryData) < alpha);\n+    }\n+\n+\n+    /**\n+     * This method actually does the calculations (except P-value).\n+     * \n+     * @param categoryData <code>Collection</code> of <code>double[]</code>\n+     * arrays each containing data for one category\n+     * @return computed AnovaStats\n+     * @throws IllegalArgumentException if categoryData does not meet\n+     * preconditions specified in the interface definition\n+     * @throws MathException if an error occurs computing the Anova stats\n+     */\n+    private AnovaStats anovaStats(Collection<double[]> categoryData)\n+        throws IllegalArgumentException, MathException {\n+\n+        // check if we have enough categories\n+        if (categoryData.size() < 2) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"two or more categories required, got {0}\",\n+                  categoryData.size());\n+        }\n+        \n+        // check if each category has enough data and all is double[]\n+        for (double[] array : categoryData) {\n+            if (array.length <= 1) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"two or more values required in each category, one has {0}\",\n+                      array.length);\n+            }\n+        }\n+\n+        int dfwg = 0;\n+        double sswg = 0;\n+        Sum totsum = new Sum();\n+        SumOfSquares totsumsq = new SumOfSquares();\n+        int totnum = 0;\n+        \n+        for (double[] data : categoryData) {\n+\n+            Sum sum = new Sum();\n+            SumOfSquares sumsq = new SumOfSquares();\n+            int num = 0;\n+\n+            for (int i = 0; i < data.length; i++) {\n+                double val = data[i];\n+\n+                // within category\n+                num++;\n+                sum.increment(val);\n+                sumsq.increment(val);\n+\n+                // for all categories\n+                totnum++;\n+                totsum.increment(val);\n+                totsumsq.increment(val);\n+            }\n+            dfwg += num - 1;\n+            double ss = sumsq.getResult() - sum.getResult() * sum.getResult() / num;\n+            sswg += ss;\n+        }\n+        double sst = totsumsq.getResult() - totsum.getResult() * \n+            totsum.getResult()/totnum;\n+        double ssbg = sst - sswg;\n+        int dfbg = categoryData.size() - 1;\n+        double msbg = ssbg/dfbg;\n+        double mswg = sswg/dfwg;\n+        double F = msbg/mswg;\n+\n+        return new AnovaStats(dfbg, dfwg, F);\n+    }\n+\n+    /** \n+        Convenience class to pass dfbg,dfwg,F values around within AnovaImpl.\n+        No get/set methods provided.\n+    */\n+    private static class AnovaStats {\n+\n+        /** Degrees of freedom in numerator (between groups). */\n+        private int dfbg;\n+\n+        /** Degrees of freedom in denominator (within groups). */\n+        private int dfwg;\n+\n+        /** Statistic. */\n+        private double F;\n+\n+        /**\n+         * Constructor\n+         * @param dfbg degrees of freedom in numerator (between groups)\n+         * @param dfwg degrees of freedom in denominator (within groups)\n+         * @param F statistic\n+         */\n+        AnovaStats(int dfbg, int dfwg, double F) {\n+            this.dfbg = dfbg;\n+            this.dfwg = dfwg;\n+            this.F = F;\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/inference/TTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.inference;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n+\n+/**\n+ * An interface for Student's t-tests.\n+ * <p>\n+ * Tests can be:<ul>\n+ * <li>One-sample or two-sample</li>\n+ * <li>One-sided or two-sided</li>\n+ * <li>Paired or unpaired (for two-sample tests)</li>\n+ * <li>Homoscedastic (equal variance assumption) or heteroscedastic\n+ * (for two sample tests)</li>\n+ * <li>Fixed significance level (boolean-valued) or returning p-values.\n+ * </li></ul></p>\n+ * <p>\n+ * Test statistics are available for all tests.  Methods including \"Test\" in\n+ * in their names perform tests, all other methods return t-statistics.  Among\n+ * the \"Test\" methods, <code>double-</code>valued methods return p-values;\n+ * <code>boolean-</code>valued methods perform fixed significance level tests.\n+ * Significance levels are always specified as numbers between 0 and 0.5\n+ * (e.g. tests at the 95% level  use <code>alpha=0.05</code>).</p>\n+ * <p>\n+ * Input to tests can be either <code>double[]</code> arrays or \n+ * {@link StatisticalSummary} instances.</p>\n+ * \n+ *\n+ * @version $Revision$ $Date$ \n+ */\n+public interface TTest {\n+    /**\n+     * Computes a paired, 2-sample t-statistic based on the data in the input \n+     * arrays.  The t-statistic returned is equivalent to what would be returned by\n+     * computing the one-sample t-statistic {@link #t(double, double[])}, with\n+     * <code>mu = 0</code> and the sample array consisting of the (signed) \n+     * differences between corresponding entries in <code>sample1</code> and \n+     * <code>sample2.</code>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The input arrays must have the same length and their common length\n+     * must be at least 2.\n+     * </li></ul></p>\n+     *\n+     * @param sample1 array of sample data values\n+     * @param sample2 array of sample data values\n+     * @return t statistic\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if the statistic can not be computed do to a\n+     *         convergence or other numerical error.\n+     */\n+    public abstract double pairedT(double[] sample1, double[] sample2)\n+        throws IllegalArgumentException, MathException;\n+    /**\n+     * Returns the <i>observed significance level</i>, or \n+     * <i> p-value</i>, associated with a paired, two-sample, two-tailed t-test \n+     * based on the data in the input arrays.\n+     * <p>\n+     * The number returned is the smallest significance level\n+     * at which one can reject the null hypothesis that the mean of the paired\n+     * differences is 0 in favor of the two-sided alternative that the mean paired \n+     * difference is not equal to 0. For a one-sided test, divide the returned \n+     * value by 2.</p>\n+     * <p>\n+     * This test is equivalent to a one-sample t-test computed using\n+     * {@link #tTest(double, double[])} with <code>mu = 0</code> and the sample\n+     * array consisting of the signed differences between corresponding elements of \n+     * <code>sample1</code> and <code>sample2.</code></p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the p-value depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n+     * here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The input array lengths must be the same and their common length must\n+     * be at least 2.\n+     * </li></ul></p>\n+     *\n+     * @param sample1 array of sample data values\n+     * @param sample2 array of sample data values\n+     * @return p-value for t-test\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    public abstract double pairedTTest(double[] sample1, double[] sample2)\n+        throws IllegalArgumentException, MathException;\n+    /**\n+     * Performs a paired t-test evaluating the null hypothesis that the \n+     * mean of the paired differences between <code>sample1</code> and\n+     * <code>sample2</code> is 0 in favor of the two-sided alternative that the \n+     * mean paired difference is not equal to 0, with significance level \n+     * <code>alpha</code>.\n+     * <p>\n+     * Returns <code>true</code> iff the null hypothesis can be rejected with \n+     * confidence <code>1 - alpha</code>.  To perform a 1-sided test, use \n+     * <code>alpha * 2</code></p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the test depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n+     * here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The input array lengths must be the same and their common length \n+     * must be at least 2.\n+     * </li>\n+     * <li> <code> 0 < alpha < 0.5 </code>\n+     * </li></ul></p>\n+     *\n+     * @param sample1 array of sample data values\n+     * @param sample2 array of sample data values\n+     * @param alpha significance level of the test\n+     * @return true if the null hypothesis can be rejected with \n+     * confidence 1 - alpha\n+     * @throws IllegalArgumentException if the preconditions are not met\n+     * @throws MathException if an error occurs performing the test\n+     */\n+    public abstract boolean pairedTTest(\n+        double[] sample1,\n+        double[] sample2,\n+        double alpha)\n+        throws IllegalArgumentException, MathException;\n+    /**\n+     * Computes a <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula\"> \n+     * t statistic </a> given observed values and a comparison constant.\n+     * <p>\n+     * This statistic can be used to perform a one sample t-test for the mean.\n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The observed array length must be at least 2.\n+     * </li></ul></p>\n+     *\n+     * @param mu comparison constant\n+     * @param observed array of values\n+     * @return t statistic\n+     * @throws IllegalArgumentException if input array length is less than 2\n+     */\n+    public abstract double t(double mu, double[] observed)\n+        throws IllegalArgumentException;\n+    /**\n+     * Computes a <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula\">\n+     * t statistic </a> to use in comparing the mean of the dataset described by \n+     * <code>sampleStats</code> to <code>mu</code>.\n+     * <p>\n+     * This statistic can be used to perform a one sample t-test for the mean.\n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li><code>observed.getN() > = 2</code>.\n+     * </li></ul></p>\n+     *\n+     * @param mu comparison constant\n+     * @param sampleStats DescriptiveStatistics holding sample summary statitstics\n+     * @return t statistic\n+     * @throws IllegalArgumentException if the precondition is not met\n+     */\n+    public abstract double t(double mu, StatisticalSummary sampleStats)\n+        throws IllegalArgumentException;\n+    /**\n+     * Computes a 2-sample t statistic,  under the hypothesis of equal \n+     * subpopulation variances.  To compute a t-statistic without the\n+     * equal variances hypothesis, use {@link #t(double[], double[])}.\n+     * <p>\n+     * This statistic can be used to perform a (homoscedastic) two-sample\n+     * t-test to compare sample means.</p>\n+     * <p>\n+     * The t-statisitc is</p>\n+     * <p>\n+     * &nbsp;&nbsp;<code>  t = (m1 - m2) / (sqrt(1/n1 +1/n2) sqrt(var))</code>\n+     * </p><p>\n+     * where <strong><code>n1</code></strong> is the size of first sample; \n+     * <strong><code> n2</code></strong> is the size of second sample; \n+     * <strong><code> m1</code></strong> is the mean of first sample;  \n+     * <strong><code> m2</code></strong> is the mean of second sample</li>\n+     * </ul>\n+     * and <strong><code>var</code></strong> is the pooled variance estimate:\n+     * </p><p>\n+     * <code>var = sqrt(((n1 - 1)var1 + (n2 - 1)var2) / ((n1-1) + (n2-1)))</code>\n+     * </p><p> \n+     * with <strong><code>var1<code></strong> the variance of the first sample and\n+     * <strong><code>var2</code></strong> the variance of the second sample.\n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The observed array lengths must both be at least 2.\n+     * </li></ul></p>\n+     *\n+     * @param sample1 array of sample data values\n+     * @param sample2 array of sample data values\n+     * @return t statistic\n+     * @throws IllegalArgumentException if the precondition is not met\n+     */\n+    public abstract double homoscedasticT(double[] sample1, double[] sample2)\n+        throws IllegalArgumentException;\n+    /**\n+     * Computes a 2-sample t statistic, without the hypothesis of equal\n+     * subpopulation variances.  To compute a t-statistic assuming equal\n+     * variances, use {@link #homoscedasticT(double[], double[])}.\n+     * <p>\n+     * This statistic can be used to perform a two-sample t-test to compare\n+     * sample means.</p>\n+     * <p>\n+     * The t-statisitc is</p>\n+     * <p>\n+     * &nbsp;&nbsp; <code>  t = (m1 - m2) / sqrt(var1/n1 + var2/n2)</code>\n+     * </p><p>\n+     *  where <strong><code>n1</code></strong> is the size of the first sample\n+     * <strong><code> n2</code></strong> is the size of the second sample; \n+     * <strong><code> m1</code></strong> is the mean of the first sample;  \n+     * <strong><code> m2</code></strong> is the mean of the second sample;\n+     * <strong><code> var1</code></strong> is the variance of the first sample;\n+     * <strong><code> var2</code></strong> is the variance of the second sample;  \n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The observed array lengths must both be at least 2.\n+     * </li></ul></p>\n+     *\n+     * @param sample1 array of sample data values\n+     * @param sample2 array of sample data values\n+     * @return t statistic\n+     * @throws IllegalArgumentException if the precondition is not met\n+     */\n+    public abstract double t(double[] sample1, double[] sample2)\n+        throws IllegalArgumentException;\n+    /**\n+     * Computes a 2-sample t statistic </a>, comparing the means of the datasets\n+     * described by two {@link StatisticalSummary} instances, without the\n+     * assumption of equal subpopulation variances.  Use \n+     * {@link #homoscedasticT(StatisticalSummary, StatisticalSummary)} to\n+     * compute a t-statistic under the equal variances assumption.\n+     * <p>\n+     * This statistic can be used to perform a two-sample t-test to compare\n+     * sample means.</p>\n+     * <p>\n+      * The returned  t-statisitc is</p>\n+     * <p>\n+     * &nbsp;&nbsp; <code>  t = (m1 - m2) / sqrt(var1/n1 + var2/n2)</code>\n+     * </p><p>\n+     * where <strong><code>n1</code></strong> is the size of the first sample; \n+     * <strong><code> n2</code></strong> is the size of the second sample; \n+     * <strong><code> m1</code></strong> is the mean of the first sample;  \n+     * <strong><code> m2</code></strong> is the mean of the second sample\n+     * <strong><code> var1</code></strong> is the variance of the first sample;  \n+     * <strong><code> var2</code></strong> is the variance of the second sample\n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The datasets described by the two Univariates must each contain\n+     * at least 2 observations.\n+     * </li></ul></p>\n+     *\n+     * @param sampleStats1 StatisticalSummary describing data from the first sample\n+     * @param sampleStats2 StatisticalSummary describing data from the second sample\n+     * @return t statistic\n+     * @throws IllegalArgumentException if the precondition is not met\n+     */\n+    public abstract double t(\n+        StatisticalSummary sampleStats1,\n+        StatisticalSummary sampleStats2)\n+        throws IllegalArgumentException;\n+    /**\n+     * Computes a 2-sample t statistic, comparing the means of the datasets\n+     * described by two {@link StatisticalSummary} instances, under the\n+     * assumption of equal subpopulation variances.  To compute a t-statistic\n+     * without the equal variances assumption, use \n+     * {@link #t(StatisticalSummary, StatisticalSummary)}.\n+     * <p>\n+     * This statistic can be used to perform a (homoscedastic) two-sample\n+     * t-test to compare sample means.</p>\n+     * <p>\n+     * The t-statisitc returned is</p>\n+     * <p>\n+     * &nbsp;&nbsp;<code>  t = (m1 - m2) / (sqrt(1/n1 +1/n2) sqrt(var))</code>\n+     * </p><p>\n+     * where <strong><code>n1</code></strong> is the size of first sample; \n+     * <strong><code> n2</code></strong> is the size of second sample; \n+     * <strong><code> m1</code></strong> is the mean of first sample;  \n+     * <strong><code> m2</code></strong> is the mean of second sample\n+     * and <strong><code>var</code></strong> is the pooled variance estimate:\n+     * </p><p>\n+     * <code>var = sqrt(((n1 - 1)var1 + (n2 - 1)var2) / ((n1-1) + (n2-1)))</code>\n+     * </p><p> \n+     * with <strong><code>var1<code></strong> the variance of the first sample and\n+     * <strong><code>var2</code></strong> the variance of the second sample.\n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The datasets described by the two Univariates must each contain\n+     * at least 2 observations.\n+     * </li></ul></p>\n+     *\n+     * @param sampleStats1 StatisticalSummary describing data from the first sample\n+     * @param sampleStats2 StatisticalSummary describing data from the second sample\n+     * @return t statistic\n+     * @throws IllegalArgumentException if the precondition is not met\n+     */\n+    public abstract double homoscedasticT(\n+        StatisticalSummary sampleStats1,\n+        StatisticalSummary sampleStats2)\n+        throws IllegalArgumentException;\n+    /**\n+     * Returns the <i>observed significance level</i>, or \n+     * <i>p-value</i>, associated with a one-sample, two-tailed t-test \n+     * comparing the mean of the input array with the constant <code>mu</code>.\n+     * <p>\n+     * The number returned is the smallest significance level\n+     * at which one can reject the null hypothesis that the mean equals \n+     * <code>mu</code> in favor of the two-sided alternative that the mean\n+     * is different from <code>mu</code>. For a one-sided test, divide the \n+     * returned value by 2.</p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the test depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">here</a>\n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The observed array length must be at least 2.\n+     * </li></ul></p>\n+     *\n+     * @param mu constant value to compare sample mean against\n+     * @param sample array of sample data values\n+     * @return p-value\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    public abstract double tTest(double mu, double[] sample)\n+        throws IllegalArgumentException, MathException;\n+    /**\n+     * Performs a <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm\">\n+     * two-sided t-test</a> evaluating the null hypothesis that the mean of the population from\n+     * which <code>sample</code> is drawn equals <code>mu</code>.\n+     * <p>\n+     * Returns <code>true</code> iff the null hypothesis can be \n+     * rejected with confidence <code>1 - alpha</code>.  To \n+     * perform a 1-sided test, use <code>alpha * 2</code></p>\n+     * <p>\n+     * <strong>Examples:</strong><br><ol>\n+     * <li>To test the (2-sided) hypothesis <code>sample mean = mu </code> at\n+     * the 95% level, use <br><code>tTest(mu, sample, 0.05) </code>\n+     * </li>\n+     * <li>To test the (one-sided) hypothesis <code> sample mean < mu </code>\n+     * at the 99% level, first verify that the measured sample mean is less \n+     * than <code>mu</code> and then use \n+     * <br><code>tTest(mu, sample, 0.02) </code>\n+     * </li></ol></p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the test depends on the assumptions of the one-sample \n+     * parametric t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/sg_glos.html#one-sample\">here</a>\n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The observed array length must be at least 2.\n+     * </li></ul></p>\n+     *\n+     * @param mu constant value to compare sample mean against\n+     * @param sample array of sample data values\n+     * @param alpha significance level of the test\n+     * @return p-value\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if an error computing the p-value\n+     */\n+    public abstract boolean tTest(double mu, double[] sample, double alpha)\n+        throws IllegalArgumentException, MathException;\n+    /**\n+     * Returns the <i>observed significance level</i>, or \n+     * <i>p-value</i>, associated with a one-sample, two-tailed t-test \n+     * comparing the mean of the dataset described by <code>sampleStats</code>\n+     * with the constant <code>mu</code>.\n+     * <p>\n+     * The number returned is the smallest significance level\n+     * at which one can reject the null hypothesis that the mean equals \n+     * <code>mu</code> in favor of the two-sided alternative that the mean\n+     * is different from <code>mu</code>. For a one-sided test, divide the \n+     * returned value by 2.</p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the test depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n+     * here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The sample must contain at least 2 observations.\n+     * </li></ul></p>\n+     *\n+     * @param mu constant value to compare sample mean against\n+     * @param sampleStats StatisticalSummary describing sample data\n+     * @return p-value\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    public abstract double tTest(double mu, StatisticalSummary sampleStats)\n+        throws IllegalArgumentException, MathException;\n+    /**\n+     * Performs a <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm\">\n+     * two-sided t-test</a> evaluating the null hypothesis that the mean of the\n+     * population from which the dataset described by <code>stats</code> is\n+     * drawn equals <code>mu</code>.\n+     * <p>\n+     * Returns <code>true</code> iff the null hypothesis can be rejected with\n+     * confidence <code>1 - alpha</code>.  To  perform a 1-sided test, use\n+     * <code>alpha * 2.</code></p>\n+     * <p>\n+     * <strong>Examples:</strong><br><ol>\n+     * <li>To test the (2-sided) hypothesis <code>sample mean = mu </code> at\n+     * the 95% level, use <br><code>tTest(mu, sampleStats, 0.05) </code>\n+     * </li>\n+     * <li>To test the (one-sided) hypothesis <code> sample mean < mu </code>\n+     * at the 99% level, first verify that the measured sample mean is less \n+     * than <code>mu</code> and then use \n+     * <br><code>tTest(mu, sampleStats, 0.02) </code>\n+     * </li></ol></p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the test depends on the assumptions of the one-sample \n+     * parametric t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/sg_glos.html#one-sample\">here</a>\n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The sample must include at least 2 observations.\n+     * </li></ul></p>\n+     *\n+     * @param mu constant value to compare sample mean against\n+     * @param sampleStats StatisticalSummary describing sample data values\n+     * @param alpha significance level of the test\n+     * @return p-value\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    public abstract boolean tTest(\n+        double mu,\n+        StatisticalSummary sampleStats,\n+        double alpha)\n+        throws IllegalArgumentException, MathException;\n+    /**\n+     * Returns the <i>observed significance level</i>, or \n+     * <i>p-value</i>, associated with a two-sample, two-tailed t-test \n+     * comparing the means of the input arrays.\n+     * <p>\n+     * The number returned is the smallest significance level\n+     * at which one can reject the null hypothesis that the two means are\n+     * equal in favor of the two-sided alternative that they are different. \n+     * For a one-sided test, divide the returned value by 2.</p>\n+     * <p>\n+     * The test does not assume that the underlying popuation variances are\n+     * equal  and it uses approximated degrees of freedom computed from the \n+     * sample data to compute the p-value.  The t-statistic used is as defined in\n+     * {@link #t(double[], double[])} and the Welch-Satterthwaite approximation\n+     * to the degrees of freedom is used, \n+     * as described \n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm\">\n+     * here.</a>  To perform the test under the assumption of equal subpopulation\n+     * variances, use {@link #homoscedasticTTest(double[], double[])}.</p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the p-value depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n+     * here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The observed array lengths must both be at least 2.\n+     * </li></ul></p>\n+     *\n+     * @param sample1 array of sample data values\n+     * @param sample2 array of sample data values\n+     * @return p-value for t-test\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    public abstract double tTest(double[] sample1, double[] sample2)\n+        throws IllegalArgumentException, MathException;\n+    /**\n+     * Returns the <i>observed significance level</i>, or \n+     * <i>p-value</i>, associated with a two-sample, two-tailed t-test \n+     * comparing the means of the input arrays, under the assumption that\n+     * the two samples are drawn from subpopulations with equal variances.\n+     * To perform the test without the equal variances assumption, use\n+     * {@link #tTest(double[], double[])}.</p>\n+     * <p>\n+     * The number returned is the smallest significance level\n+     * at which one can reject the null hypothesis that the two means are\n+     * equal in favor of the two-sided alternative that they are different. \n+     * For a one-sided test, divide the returned value by 2.</p>\n+     * <p>\n+     * A pooled variance estimate is used to compute the t-statistic.  See\n+     * {@link #homoscedasticT(double[], double[])}. The sum of the sample sizes\n+     * minus 2 is used as the degrees of freedom.</p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the p-value depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n+     * here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The observed array lengths must both be at least 2.\n+     * </li></ul></p>\n+     *\n+     * @param sample1 array of sample data values\n+     * @param sample2 array of sample data values\n+     * @return p-value for t-test\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    public abstract double homoscedasticTTest(\n+        double[] sample1,\n+        double[] sample2)\n+        throws IllegalArgumentException, MathException;\n+    /**\n+     * Performs a \n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm\">\n+     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code> \n+     * and <code>sample2</code> are drawn from populations with the same mean, \n+     * with significance level <code>alpha</code>.  This test does not assume\n+     * that the subpopulation variances are equal.  To perform the test assuming\n+     * equal variances, use \n+     * {@link #homoscedasticTTest(double[], double[], double)}.\n+     * <p>\n+     * Returns <code>true</code> iff the null hypothesis that the means are\n+     * equal can be rejected with confidence <code>1 - alpha</code>.  To \n+     * perform a 1-sided test, use <code>alpha * 2</code></p>\n+     * <p>\n+     * See {@link #t(double[], double[])} for the formula used to compute the\n+     * t-statistic.  Degrees of freedom are approximated using the\n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm\">\n+     * Welch-Satterthwaite approximation.</a></p>\n+     * <p>\n+     * <strong>Examples:</strong><br><ol>\n+     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at\n+     * the 95% level,  use \n+     * <br><code>tTest(sample1, sample2, 0.05). </code>\n+     * </li>\n+     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code>,\n+     * at the 99% level, first verify that the measured  mean of <code>sample 1</code>\n+     * is less than the mean of <code>sample 2</code> and then use \n+     * <br><code>tTest(sample1, sample2, 0.02) </code>\n+     * </li></ol></p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the test depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n+     * here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The observed array lengths must both be at least 2.\n+     * </li>\n+     * <li> <code> 0 < alpha < 0.5 </code>\n+     * </li></ul></p>\n+     *\n+     * @param sample1 array of sample data values\n+     * @param sample2 array of sample data values\n+     * @param alpha significance level of the test\n+     * @return true if the null hypothesis can be rejected with \n+     * confidence 1 - alpha\n+     * @throws IllegalArgumentException if the preconditions are not met\n+     * @throws MathException if an error occurs performing the test\n+     */\n+    public abstract boolean tTest(\n+        double[] sample1,\n+        double[] sample2,\n+        double alpha)\n+        throws IllegalArgumentException, MathException;\n+    /**\n+     * Performs a \n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm\">\n+     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code> \n+     * and <code>sample2</code> are drawn from populations with the same mean, \n+     * with significance level <code>alpha</code>,  assuming that the\n+     * subpopulation variances are equal.  Use \n+     * {@link #tTest(double[], double[], double)} to perform the test without\n+     * the assumption of equal variances.\n+     * <p>\n+     * Returns <code>true</code> iff the null hypothesis that the means are\n+     * equal can be rejected with confidence <code>1 - alpha</code>.  To \n+     * perform a 1-sided test, use <code>alpha * 2.</code>  To perform the test\n+     * without the assumption of equal subpopulation variances, use \n+     * {@link #tTest(double[], double[], double)}.</p>\n+     * <p>\n+     * A pooled variance estimate is used to compute the t-statistic. See\n+     * {@link #t(double[], double[])} for the formula. The sum of the sample\n+     * sizes minus 2 is used as the degrees of freedom.</p>\n+     * <p>\n+     * <strong>Examples:</strong><br><ol>\n+     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at\n+     * the 95% level, use <br><code>tTest(sample1, sample2, 0.05). </code>\n+     * </li>\n+     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2, </code>\n+     * at the 99% level, first verify that the measured mean of \n+     * <code>sample 1</code> is less than the mean of <code>sample 2</code>\n+     * and then use\n+     * <br><code>tTest(sample1, sample2, 0.02) </code>\n+     * </li></ol></p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the test depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n+     * here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The observed array lengths must both be at least 2.\n+     * </li>\n+     * <li> <code> 0 < alpha < 0.5 </code>\n+     * </li></ul></p>\n+     *\n+     * @param sample1 array of sample data values\n+     * @param sample2 array of sample data values\n+     * @param alpha significance level of the test\n+     * @return true if the null hypothesis can be rejected with \n+     * confidence 1 - alpha\n+     * @throws IllegalArgumentException if the preconditions are not met\n+     * @throws MathException if an error occurs performing the test\n+     */\n+    public abstract boolean homoscedasticTTest(\n+        double[] sample1,\n+        double[] sample2,\n+        double alpha)\n+        throws IllegalArgumentException, MathException;\n+    /**\n+     * Returns the <i>observed significance level</i>, or \n+     * <i>p-value</i>, associated with a two-sample, two-tailed t-test \n+     * comparing the means of the datasets described by two StatisticalSummary\n+     * instances.\n+     * <p>\n+     * The number returned is the smallest significance level\n+     * at which one can reject the null hypothesis that the two means are\n+     * equal in favor of the two-sided alternative that they are different. \n+     * For a one-sided test, divide the returned value by 2.</p>\n+     * <p>\n+     * The test does not assume that the underlying popuation variances are\n+     * equal  and it uses approximated degrees of freedom computed from the \n+     * sample data to compute the p-value.   To perform the test assuming\n+     * equal variances, use \n+     * {@link #homoscedasticTTest(StatisticalSummary, StatisticalSummary)}.</p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the p-value depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n+     * here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The datasets described by the two Univariates must each contain\n+     * at least 2 observations.\n+     * </li></ul></p>\n+     *\n+     * @param sampleStats1  StatisticalSummary describing data from the first sample\n+     * @param sampleStats2  StatisticalSummary describing data from the second sample\n+     * @return p-value for t-test\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    public abstract double tTest(\n+        StatisticalSummary sampleStats1,\n+        StatisticalSummary sampleStats2)\n+        throws IllegalArgumentException, MathException;\n+    /**\n+     * Returns the <i>observed significance level</i>, or \n+     * <i>p-value</i>, associated with a two-sample, two-tailed t-test \n+     * comparing the means of the datasets described by two StatisticalSummary\n+     * instances, under the hypothesis of equal subpopulation variances. To\n+     * perform a test without the equal variances assumption, use\n+     * {@link #tTest(StatisticalSummary, StatisticalSummary)}.\n+     * <p>\n+     * The number returned is the smallest significance level\n+     * at which one can reject the null hypothesis that the two means are\n+     * equal in favor of the two-sided alternative that they are different. \n+     * For a one-sided test, divide the returned value by 2.</p>\n+     * <p>\n+     * See {@link #homoscedasticT(double[], double[])} for the formula used to\n+     * compute the t-statistic. The sum of the  sample sizes minus 2 is used as\n+     * the degrees of freedom.</p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the p-value depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">here</a>\n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The datasets described by the two Univariates must each contain\n+     * at least 2 observations.\n+     * </li></ul></p>\n+     *\n+     * @param sampleStats1  StatisticalSummary describing data from the first sample\n+     * @param sampleStats2  StatisticalSummary describing data from the second sample\n+     * @return p-value for t-test\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    public abstract double homoscedasticTTest(\n+        StatisticalSummary sampleStats1,\n+        StatisticalSummary sampleStats2)\n+        throws IllegalArgumentException, MathException;\n+    /**\n+     * Performs a \n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm\">\n+     * two-sided t-test</a> evaluating the null hypothesis that \n+     * <code>sampleStats1</code> and <code>sampleStats2</code> describe\n+     * datasets drawn from populations with the same mean, with significance\n+     * level <code>alpha</code>.   This test does not assume that the\n+     * subpopulation variances are equal.  To perform the test under the equal\n+     * variances assumption, use\n+     * {@link #homoscedasticTTest(StatisticalSummary, StatisticalSummary)}.\n+     * <p>\n+     * Returns <code>true</code> iff the null hypothesis that the means are\n+     * equal can be rejected with confidence <code>1 - alpha</code>.  To \n+     * perform a 1-sided test, use <code>alpha * 2</code></p>\n+     * <p>\n+     * See {@link #t(double[], double[])} for the formula used to compute the\n+     * t-statistic.  Degrees of freedom are approximated using the\n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm\">\n+     * Welch-Satterthwaite approximation.</a></p>\n+     * <p>\n+     * <strong>Examples:</strong><br><ol>\n+     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at\n+     * the 95%, use \n+     * <br><code>tTest(sampleStats1, sampleStats2, 0.05) </code>\n+     * </li>\n+     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code>\n+     * at the 99% level,  first verify that the measured mean of  \n+     * <code>sample 1</code> is less than  the mean of <code>sample 2</code>\n+     * and then use \n+     * <br><code>tTest(sampleStats1, sampleStats2, 0.02) </code>\n+     * </li></ol></p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the test depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n+     * here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The datasets described by the two Univariates must each contain\n+     * at least 2 observations.\n+     * </li>\n+     * <li> <code> 0 < alpha < 0.5 </code>\n+     * </li></ul></p>\n+     *\n+     * @param sampleStats1 StatisticalSummary describing sample data values\n+     * @param sampleStats2 StatisticalSummary describing sample data values\n+     * @param alpha significance level of the test\n+     * @return true if the null hypothesis can be rejected with \n+     * confidence 1 - alpha\n+     * @throws IllegalArgumentException if the preconditions are not met\n+     * @throws MathException if an error occurs performing the test\n+     */\n+    public abstract boolean tTest(\n+        StatisticalSummary sampleStats1,\n+        StatisticalSummary sampleStats2,\n+        double alpha)\n+        throws IllegalArgumentException, MathException;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/inference/TTestImpl.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.inference;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.distribution.TDistribution;\n+import org.apache.commons.math.distribution.TDistributionImpl;\n+import org.apache.commons.math.stat.StatUtils;\n+import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n+\n+/**\n+ * Implements t-test statistics defined in the {@link TTest} interface.\n+ * <p>\n+ * Uses commons-math {@link org.apache.commons.math.distribution.TDistribution}\n+ * implementation to estimate exact p-values.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class TTestImpl implements TTest  {\n+\n+    /** Distribution used to compute inference statistics. */\n+    private TDistribution distribution;\n+    \n+    /**\n+     * Default constructor.\n+     */\n+    public TTestImpl() {\n+        this(new TDistributionImpl(1.0));\n+    }\n+    \n+    /**\n+     * Create a test instance using the given distribution for computing\n+     * inference statistics.\n+     * @param t distribution used to compute inference statistics.\n+     * @since 1.2\n+     */\n+    public TTestImpl(TDistribution t) {\n+        super();\n+        setDistribution(t);\n+    }\n+    \n+    /**\n+     * Computes a paired, 2-sample t-statistic based on the data in the input \n+     * arrays.  The t-statistic returned is equivalent to what would be returned by\n+     * computing the one-sample t-statistic {@link #t(double, double[])}, with\n+     * <code>mu = 0</code> and the sample array consisting of the (signed) \n+     * differences between corresponding entries in <code>sample1</code> and \n+     * <code>sample2.</code>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The input arrays must have the same length and their common length\n+     * must be at least 2.\n+     * </li></ul></p>\n+     *\n+     * @param sample1 array of sample data values\n+     * @param sample2 array of sample data values\n+     * @return t statistic\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if the statistic can not be computed do to a\n+     *         convergence or other numerical error.\n+     */\n+    public double pairedT(double[] sample1, double[] sample2)\n+        throws IllegalArgumentException, MathException {\n+        checkSampleData(sample1);\n+        checkSampleData(sample2);\n+        double meanDifference = StatUtils.meanDifference(sample1, sample2);\n+        return t(meanDifference, 0,  \n+                StatUtils.varianceDifference(sample1, sample2, meanDifference),\n+                sample1.length);\n+    }\n+\n+     /**\n+     * Returns the <i>observed significance level</i>, or \n+     * <i> p-value</i>, associated with a paired, two-sample, two-tailed t-test \n+     * based on the data in the input arrays.\n+     * <p>\n+     * The number returned is the smallest significance level\n+     * at which one can reject the null hypothesis that the mean of the paired\n+     * differences is 0 in favor of the two-sided alternative that the mean paired \n+     * difference is not equal to 0. For a one-sided test, divide the returned \n+     * value by 2.</p>\n+     * <p>\n+     * This test is equivalent to a one-sample t-test computed using\n+     * {@link #tTest(double, double[])} with <code>mu = 0</code> and the sample\n+     * array consisting of the signed differences between corresponding elements of \n+     * <code>sample1</code> and <code>sample2.</code></p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the p-value depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n+     * here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The input array lengths must be the same and their common length must\n+     * be at least 2.\n+     * </li></ul></p>\n+     *\n+     * @param sample1 array of sample data values\n+     * @param sample2 array of sample data values\n+     * @return p-value for t-test\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    public double pairedTTest(double[] sample1, double[] sample2)\n+        throws IllegalArgumentException, MathException {\n+        double meanDifference = StatUtils.meanDifference(sample1, sample2);\n+        return tTest(meanDifference, 0, \n+                StatUtils.varianceDifference(sample1, sample2, meanDifference), \n+                sample1.length);\n+    }\n+\n+     /**\n+     * Performs a paired t-test evaluating the null hypothesis that the \n+     * mean of the paired differences between <code>sample1</code> and\n+     * <code>sample2</code> is 0 in favor of the two-sided alternative that the \n+     * mean paired difference is not equal to 0, with significance level \n+     * <code>alpha</code>.\n+     * <p>\n+     * Returns <code>true</code> iff the null hypothesis can be rejected with \n+     * confidence <code>1 - alpha</code>.  To perform a 1-sided test, use \n+     * <code>alpha * 2</code></p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the test depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n+     * here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The input array lengths must be the same and their common length \n+     * must be at least 2.\n+     * </li>\n+     * <li> <code> 0 < alpha < 0.5 </code>\n+     * </li></ul></p>\n+     *\n+     * @param sample1 array of sample data values\n+     * @param sample2 array of sample data values\n+     * @param alpha significance level of the test\n+     * @return true if the null hypothesis can be rejected with \n+     * confidence 1 - alpha\n+     * @throws IllegalArgumentException if the preconditions are not met\n+     * @throws MathException if an error occurs performing the test\n+     */\n+    public boolean pairedTTest(double[] sample1, double[] sample2, double alpha)\n+        throws IllegalArgumentException, MathException {\n+        checkSignificanceLevel(alpha);\n+        return (pairedTTest(sample1, sample2) < alpha);\n+    }\n+\n+    /**\n+     * Computes a <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula\"> \n+     * t statistic </a> given observed values and a comparison constant.\n+     * <p>\n+     * This statistic can be used to perform a one sample t-test for the mean.\n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The observed array length must be at least 2.\n+     * </li></ul></p>\n+     *\n+     * @param mu comparison constant\n+     * @param observed array of values\n+     * @return t statistic\n+     * @throws IllegalArgumentException if input array length is less than 2\n+     */\n+    public double t(double mu, double[] observed)\n+    throws IllegalArgumentException {\n+        checkSampleData(observed);\n+        return t(StatUtils.mean(observed), mu, StatUtils.variance(observed),\n+                observed.length);\n+    }\n+\n+    /**\n+     * Computes a <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section2/prc22.htm#formula\">\n+     * t statistic </a> to use in comparing the mean of the dataset described by \n+     * <code>sampleStats</code> to <code>mu</code>.\n+     * <p>\n+     * This statistic can be used to perform a one sample t-test for the mean.\n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li><code>observed.getN() > = 2</code>.\n+     * </li></ul></p>\n+     *\n+     * @param mu comparison constant\n+     * @param sampleStats DescriptiveStatistics holding sample summary statitstics\n+     * @return t statistic\n+     * @throws IllegalArgumentException if the precondition is not met\n+     */\n+    public double t(double mu, StatisticalSummary sampleStats)\n+    throws IllegalArgumentException {\n+        checkSampleData(sampleStats);\n+        return t(sampleStats.getMean(), mu, sampleStats.getVariance(),\n+                sampleStats.getN());\n+    }\n+\n+    /**\n+     * Computes a 2-sample t statistic,  under the hypothesis of equal \n+     * subpopulation variances.  To compute a t-statistic without the\n+     * equal variances hypothesis, use {@link #t(double[], double[])}.\n+     * <p>\n+     * This statistic can be used to perform a (homoscedastic) two-sample\n+     * t-test to compare sample means.</p>\n+     * <p>\n+     * The t-statisitc is</p>\n+     * <p>\n+     * &nbsp;&nbsp;<code>  t = (m1 - m2) / (sqrt(1/n1 +1/n2) sqrt(var))</code>\n+     * </p><p>\n+     * where <strong><code>n1</code></strong> is the size of first sample; \n+     * <strong><code> n2</code></strong> is the size of second sample; \n+     * <strong><code> m1</code></strong> is the mean of first sample;  \n+     * <strong><code> m2</code></strong> is the mean of second sample</li>\n+     * </ul>\n+     * and <strong><code>var</code></strong> is the pooled variance estimate:\n+     * </p><p>\n+     * <code>var = sqrt(((n1 - 1)var1 + (n2 - 1)var2) / ((n1-1) + (n2-1)))</code>\n+     * </p><p> \n+     * with <strong><code>var1<code></strong> the variance of the first sample and\n+     * <strong><code>var2</code></strong> the variance of the second sample.\n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The observed array lengths must both be at least 2.\n+     * </li></ul></p>\n+     *\n+     * @param sample1 array of sample data values\n+     * @param sample2 array of sample data values\n+     * @return t statistic\n+     * @throws IllegalArgumentException if the precondition is not met\n+     */\n+    public double homoscedasticT(double[] sample1, double[] sample2)\n+    throws IllegalArgumentException {\n+        checkSampleData(sample1);\n+        checkSampleData(sample2);\n+        return homoscedasticT(StatUtils.mean(sample1), StatUtils.mean(sample2),\n+                StatUtils.variance(sample1), StatUtils.variance(sample2),\n+                sample1.length, sample2.length);\n+    }\n+    \n+    /**\n+     * Computes a 2-sample t statistic, without the hypothesis of equal\n+     * subpopulation variances.  To compute a t-statistic assuming equal\n+     * variances, use {@link #homoscedasticT(double[], double[])}.\n+     * <p>\n+     * This statistic can be used to perform a two-sample t-test to compare\n+     * sample means.</p>\n+     * <p>\n+     * The t-statisitc is</p>\n+     * <p>\n+     * &nbsp;&nbsp; <code>  t = (m1 - m2) / sqrt(var1/n1 + var2/n2)</code>\n+     * </p><p>\n+     *  where <strong><code>n1</code></strong> is the size of the first sample\n+     * <strong><code> n2</code></strong> is the size of the second sample; \n+     * <strong><code> m1</code></strong> is the mean of the first sample;  \n+     * <strong><code> m2</code></strong> is the mean of the second sample;\n+     * <strong><code> var1</code></strong> is the variance of the first sample;\n+     * <strong><code> var2</code></strong> is the variance of the second sample;  \n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The observed array lengths must both be at least 2.\n+     * </li></ul></p>\n+     *\n+     * @param sample1 array of sample data values\n+     * @param sample2 array of sample data values\n+     * @return t statistic\n+     * @throws IllegalArgumentException if the precondition is not met\n+     */\n+    public double t(double[] sample1, double[] sample2)\n+    throws IllegalArgumentException {\n+        checkSampleData(sample1);\n+        checkSampleData(sample2);\n+        return t(StatUtils.mean(sample1), StatUtils.mean(sample2),\n+                StatUtils.variance(sample1), StatUtils.variance(sample2),\n+                sample1.length, sample2.length);\n+    }\n+\n+    /**\n+     * Computes a 2-sample t statistic </a>, comparing the means of the datasets\n+     * described by two {@link StatisticalSummary} instances, without the\n+     * assumption of equal subpopulation variances.  Use \n+     * {@link #homoscedasticT(StatisticalSummary, StatisticalSummary)} to\n+     * compute a t-statistic under the equal variances assumption.\n+     * <p>\n+     * This statistic can be used to perform a two-sample t-test to compare\n+     * sample means.</p>\n+     * <p>\n+      * The returned  t-statisitc is</p>\n+     * <p>\n+     * &nbsp;&nbsp; <code>  t = (m1 - m2) / sqrt(var1/n1 + var2/n2)</code>\n+     * </p><p>\n+     * where <strong><code>n1</code></strong> is the size of the first sample; \n+     * <strong><code> n2</code></strong> is the size of the second sample; \n+     * <strong><code> m1</code></strong> is the mean of the first sample;  \n+     * <strong><code> m2</code></strong> is the mean of the second sample\n+     * <strong><code> var1</code></strong> is the variance of the first sample;  \n+     * <strong><code> var2</code></strong> is the variance of the second sample\n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The datasets described by the two Univariates must each contain\n+     * at least 2 observations.\n+     * </li></ul></p>\n+     *\n+     * @param sampleStats1 StatisticalSummary describing data from the first sample\n+     * @param sampleStats2 StatisticalSummary describing data from the second sample\n+     * @return t statistic\n+     * @throws IllegalArgumentException if the precondition is not met\n+     */\n+    public double t(StatisticalSummary sampleStats1, \n+                    StatisticalSummary sampleStats2)\n+    throws IllegalArgumentException {\n+        checkSampleData(sampleStats1);\n+        checkSampleData(sampleStats2);\n+        return t(sampleStats1.getMean(), sampleStats2.getMean(), \n+                sampleStats1.getVariance(), sampleStats2.getVariance(),\n+                sampleStats1.getN(), sampleStats2.getN());\n+    }\n+    \n+    /**\n+     * Computes a 2-sample t statistic, comparing the means of the datasets\n+     * described by two {@link StatisticalSummary} instances, under the\n+     * assumption of equal subpopulation variances.  To compute a t-statistic\n+     * without the equal variances assumption, use \n+     * {@link #t(StatisticalSummary, StatisticalSummary)}.\n+     * <p>\n+     * This statistic can be used to perform a (homoscedastic) two-sample\n+     * t-test to compare sample means.</p>\n+     * <p>\n+     * The t-statisitc returned is</p>\n+     * <p>\n+     * &nbsp;&nbsp;<code>  t = (m1 - m2) / (sqrt(1/n1 +1/n2) sqrt(var))</code>\n+     * </p><p>\n+     * where <strong><code>n1</code></strong> is the size of first sample; \n+     * <strong><code> n2</code></strong> is the size of second sample; \n+     * <strong><code> m1</code></strong> is the mean of first sample;  \n+     * <strong><code> m2</code></strong> is the mean of second sample\n+     * and <strong><code>var</code></strong> is the pooled variance estimate:\n+     * </p><p>\n+     * <code>var = sqrt(((n1 - 1)var1 + (n2 - 1)var2) / ((n1-1) + (n2-1)))</code>\n+     * <p> \n+     * with <strong><code>var1<code></strong> the variance of the first sample and\n+     * <strong><code>var2</code></strong> the variance of the second sample.\n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The datasets described by the two Univariates must each contain\n+     * at least 2 observations.\n+     * </li></ul></p>\n+     *\n+     * @param sampleStats1 StatisticalSummary describing data from the first sample\n+     * @param sampleStats2 StatisticalSummary describing data from the second sample\n+     * @return t statistic\n+     * @throws IllegalArgumentException if the precondition is not met\n+     */\n+    public double homoscedasticT(StatisticalSummary sampleStats1, \n+            StatisticalSummary sampleStats2)\n+    throws IllegalArgumentException {\n+        checkSampleData(sampleStats1);\n+        checkSampleData(sampleStats2);\n+        return homoscedasticT(sampleStats1.getMean(), sampleStats2.getMean(), \n+                sampleStats1.getVariance(), sampleStats2.getVariance(), \n+                sampleStats1.getN(), sampleStats2.getN());\n+    }\n+\n+     /**\n+     * Returns the <i>observed significance level</i>, or \n+     * <i>p-value</i>, associated with a one-sample, two-tailed t-test \n+     * comparing the mean of the input array with the constant <code>mu</code>.\n+     * <p>\n+     * The number returned is the smallest significance level\n+     * at which one can reject the null hypothesis that the mean equals \n+     * <code>mu</code> in favor of the two-sided alternative that the mean\n+     * is different from <code>mu</code>. For a one-sided test, divide the \n+     * returned value by 2.</p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the test depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">here</a>\n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The observed array length must be at least 2.\n+     * </li></ul></p>\n+     *\n+     * @param mu constant value to compare sample mean against\n+     * @param sample array of sample data values\n+     * @return p-value\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    public double tTest(double mu, double[] sample)\n+    throws IllegalArgumentException, MathException {\n+        checkSampleData(sample);\n+        return tTest( StatUtils.mean(sample), mu, StatUtils.variance(sample),\n+                sample.length);\n+    }\n+\n+    /**\n+     * Performs a <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm\">\n+     * two-sided t-test</a> evaluating the null hypothesis that the mean of the population from\n+     * which <code>sample</code> is drawn equals <code>mu</code>.\n+     * <p>\n+     * Returns <code>true</code> iff the null hypothesis can be \n+     * rejected with confidence <code>1 - alpha</code>.  To \n+     * perform a 1-sided test, use <code>alpha * 2</code>\n+     * </p><p>\n+     * <strong>Examples:</strong><br><ol>\n+     * <li>To test the (2-sided) hypothesis <code>sample mean = mu </code> at\n+     * the 95% level, use <br><code>tTest(mu, sample, 0.05) </code>\n+     * </li>\n+     * <li>To test the (one-sided) hypothesis <code> sample mean < mu </code>\n+     * at the 99% level, first verify that the measured sample mean is less \n+     * than <code>mu</code> and then use \n+     * <br><code>tTest(mu, sample, 0.02) </code>\n+     * </li></ol></p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the test depends on the assumptions of the one-sample \n+     * parametric t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/sg_glos.html#one-sample\">here</a>\n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The observed array length must be at least 2.\n+     * </li></ul></p>\n+     *\n+     * @param mu constant value to compare sample mean against\n+     * @param sample array of sample data values\n+     * @param alpha significance level of the test\n+     * @return p-value\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if an error computing the p-value\n+     */\n+    public boolean tTest(double mu, double[] sample, double alpha)\n+    throws IllegalArgumentException, MathException {\n+        checkSignificanceLevel(alpha);\n+        return (tTest(mu, sample) < alpha);\n+    }\n+\n+    /**\n+     * Returns the <i>observed significance level</i>, or \n+     * <i>p-value</i>, associated with a one-sample, two-tailed t-test \n+     * comparing the mean of the dataset described by <code>sampleStats</code>\n+     * with the constant <code>mu</code>.\n+     * <p>\n+     * The number returned is the smallest significance level\n+     * at which one can reject the null hypothesis that the mean equals \n+     * <code>mu</code> in favor of the two-sided alternative that the mean\n+     * is different from <code>mu</code>. For a one-sided test, divide the \n+     * returned value by 2.</p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the test depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n+     * here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The sample must contain at least 2 observations.\n+     * </li></ul></p>\n+     *\n+     * @param mu constant value to compare sample mean against\n+     * @param sampleStats StatisticalSummary describing sample data\n+     * @return p-value\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    public double tTest(double mu, StatisticalSummary sampleStats)\n+    throws IllegalArgumentException, MathException {\n+        checkSampleData(sampleStats);\n+        return tTest(sampleStats.getMean(), mu, sampleStats.getVariance(),\n+                sampleStats.getN());\n+    }\n+\n+     /**\n+     * Performs a <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm\">\n+     * two-sided t-test</a> evaluating the null hypothesis that the mean of the\n+     * population from which the dataset described by <code>stats</code> is\n+     * drawn equals <code>mu</code>.\n+     * <p>\n+     * Returns <code>true</code> iff the null hypothesis can be rejected with\n+     * confidence <code>1 - alpha</code>.  To  perform a 1-sided test, use\n+     * <code>alpha * 2.</code></p>\n+     * <p>\n+     * <strong>Examples:</strong><br><ol>\n+     * <li>To test the (2-sided) hypothesis <code>sample mean = mu </code> at\n+     * the 95% level, use <br><code>tTest(mu, sampleStats, 0.05) </code>\n+     * </li>\n+     * <li>To test the (one-sided) hypothesis <code> sample mean < mu </code>\n+     * at the 99% level, first verify that the measured sample mean is less \n+     * than <code>mu</code> and then use \n+     * <br><code>tTest(mu, sampleStats, 0.02) </code>\n+     * </li></ol></p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the test depends on the assumptions of the one-sample \n+     * parametric t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/sg_glos.html#one-sample\">here</a>\n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The sample must include at least 2 observations.\n+     * </li></ul></p>\n+     *\n+     * @param mu constant value to compare sample mean against\n+     * @param sampleStats StatisticalSummary describing sample data values\n+     * @param alpha significance level of the test\n+     * @return p-value\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    public boolean tTest( double mu, StatisticalSummary sampleStats,\n+            double alpha)\n+    throws IllegalArgumentException, MathException {\n+        checkSignificanceLevel(alpha);\n+        return (tTest(mu, sampleStats) < alpha);\n+    }\n+\n+    /**\n+     * Returns the <i>observed significance level</i>, or \n+     * <i>p-value</i>, associated with a two-sample, two-tailed t-test \n+     * comparing the means of the input arrays.\n+     * <p>\n+     * The number returned is the smallest significance level\n+     * at which one can reject the null hypothesis that the two means are\n+     * equal in favor of the two-sided alternative that they are different. \n+     * For a one-sided test, divide the returned value by 2.</p>\n+     * <p>\n+     * The test does not assume that the underlying popuation variances are\n+     * equal  and it uses approximated degrees of freedom computed from the \n+     * sample data to compute the p-value.  The t-statistic used is as defined in\n+     * {@link #t(double[], double[])} and the Welch-Satterthwaite approximation\n+     * to the degrees of freedom is used, \n+     * as described \n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm\">\n+     * here.</a>  To perform the test under the assumption of equal subpopulation\n+     * variances, use {@link #homoscedasticTTest(double[], double[])}.</p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the p-value depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n+     * here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The observed array lengths must both be at least 2.\n+     * </li></ul></p>\n+     *\n+     * @param sample1 array of sample data values\n+     * @param sample2 array of sample data values\n+     * @return p-value for t-test\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    public double tTest(double[] sample1, double[] sample2)\n+    throws IllegalArgumentException, MathException {\n+        checkSampleData(sample1);\n+        checkSampleData(sample2);\n+        return tTest(StatUtils.mean(sample1), StatUtils.mean(sample2),\n+                StatUtils.variance(sample1), StatUtils.variance(sample2),\n+                sample1.length, sample2.length);\n+    }\n+    \n+    /**\n+     * Returns the <i>observed significance level</i>, or \n+     * <i>p-value</i>, associated with a two-sample, two-tailed t-test \n+     * comparing the means of the input arrays, under the assumption that\n+     * the two samples are drawn from subpopulations with equal variances.\n+     * To perform the test without the equal variances assumption, use\n+     * {@link #tTest(double[], double[])}.\n+     * <p>\n+     * The number returned is the smallest significance level\n+     * at which one can reject the null hypothesis that the two means are\n+     * equal in favor of the two-sided alternative that they are different. \n+     * For a one-sided test, divide the returned value by 2.</p>\n+     * <p>\n+     * A pooled variance estimate is used to compute the t-statistic.  See\n+     * {@link #homoscedasticT(double[], double[])}. The sum of the sample sizes\n+     * minus 2 is used as the degrees of freedom.</p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the p-value depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n+     * here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The observed array lengths must both be at least 2.\n+     * </li></ul></p>\n+     *\n+     * @param sample1 array of sample data values\n+     * @param sample2 array of sample data values\n+     * @return p-value for t-test\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    public double homoscedasticTTest(double[] sample1, double[] sample2)\n+    throws IllegalArgumentException, MathException {\n+        checkSampleData(sample1);\n+        checkSampleData(sample2);\n+        return homoscedasticTTest(StatUtils.mean(sample1), \n+                StatUtils.mean(sample2), StatUtils.variance(sample1),\n+                StatUtils.variance(sample2), sample1.length, \n+                sample2.length);\n+    }\n+    \n+\n+     /**\n+     * Performs a \n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm\">\n+     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code> \n+     * and <code>sample2</code> are drawn from populations with the same mean, \n+     * with significance level <code>alpha</code>.  This test does not assume\n+     * that the subpopulation variances are equal.  To perform the test assuming\n+     * equal variances, use \n+     * {@link #homoscedasticTTest(double[], double[], double)}.\n+     * <p>\n+     * Returns <code>true</code> iff the null hypothesis that the means are\n+     * equal can be rejected with confidence <code>1 - alpha</code>.  To \n+     * perform a 1-sided test, use <code>alpha / 2</code></p>\n+     * <p>\n+     * See {@link #t(double[], double[])} for the formula used to compute the\n+     * t-statistic.  Degrees of freedom are approximated using the\n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm\">\n+     * Welch-Satterthwaite approximation.</a></p>\n+      \n+     * <p>\n+     * <strong>Examples:</strong><br><ol>\n+     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at\n+     * the 95% level,  use \n+     * <br><code>tTest(sample1, sample2, 0.05). </code>\n+     * </li>\n+     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code> at\n+     * the 99% level, first verify that the measured  mean of <code>sample 1</code>\n+     * is less than the mean of <code>sample 2</code> and then use \n+     * <br><code>tTest(sample1, sample2, 0.02) </code>\n+     * </li></ol></p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the test depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n+     * here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The observed array lengths must both be at least 2.\n+     * </li>\n+     * <li> <code> 0 < alpha < 0.5 </code>\n+     * </li></ul></p>\n+     *\n+     * @param sample1 array of sample data values\n+     * @param sample2 array of sample data values\n+     * @param alpha significance level of the test\n+     * @return true if the null hypothesis can be rejected with \n+     * confidence 1 - alpha\n+     * @throws IllegalArgumentException if the preconditions are not met\n+     * @throws MathException if an error occurs performing the test\n+     */\n+    public boolean tTest(double[] sample1, double[] sample2,\n+            double alpha)\n+    throws IllegalArgumentException, MathException {\n+        checkSignificanceLevel(alpha);\n+        return (tTest(sample1, sample2) < alpha);\n+    }\n+    \n+    /**\n+     * Performs a \n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm\">\n+     * two-sided t-test</a> evaluating the null hypothesis that <code>sample1</code> \n+     * and <code>sample2</code> are drawn from populations with the same mean, \n+     * with significance level <code>alpha</code>,  assuming that the\n+     * subpopulation variances are equal.  Use \n+     * {@link #tTest(double[], double[], double)} to perform the test without\n+     * the assumption of equal variances.\n+     * <p>\n+     * Returns <code>true</code> iff the null hypothesis that the means are\n+     * equal can be rejected with confidence <code>1 - alpha</code>.  To \n+     * perform a 1-sided test, use <code>alpha * 2.</code>  To perform the test\n+     * without the assumption of equal subpopulation variances, use \n+     * {@link #tTest(double[], double[], double)}.</p>\n+     * <p>\n+     * A pooled variance estimate is used to compute the t-statistic. See\n+     * {@link #t(double[], double[])} for the formula. The sum of the sample\n+     * sizes minus 2 is used as the degrees of freedom.</p>\n+     * <p>\n+     * <strong>Examples:</strong><br><ol>\n+     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at\n+     * the 95% level, use <br><code>tTest(sample1, sample2, 0.05). </code>\n+     * </li>\n+     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2, </code>\n+     * at the 99% level, first verify that the measured mean of \n+     * <code>sample 1</code> is less than the mean of <code>sample 2</code>\n+     * and then use\n+     * <br><code>tTest(sample1, sample2, 0.02) </code>\n+     * </li></ol></p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the test depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n+     * here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The observed array lengths must both be at least 2.\n+     * </li>\n+     * <li> <code> 0 < alpha < 0.5 </code>\n+     * </li></ul></p>\n+     *\n+     * @param sample1 array of sample data values\n+     * @param sample2 array of sample data values\n+     * @param alpha significance level of the test\n+     * @return true if the null hypothesis can be rejected with \n+     * confidence 1 - alpha\n+     * @throws IllegalArgumentException if the preconditions are not met\n+     * @throws MathException if an error occurs performing the test\n+     */\n+    public boolean homoscedasticTTest(double[] sample1, double[] sample2,\n+            double alpha)\n+    throws IllegalArgumentException, MathException {\n+        checkSignificanceLevel(alpha);\n+        return (homoscedasticTTest(sample1, sample2) < alpha);\n+    }\n+\n+     /**\n+     * Returns the <i>observed significance level</i>, or \n+     * <i>p-value</i>, associated with a two-sample, two-tailed t-test \n+     * comparing the means of the datasets described by two StatisticalSummary\n+     * instances.\n+     * <p>\n+     * The number returned is the smallest significance level\n+     * at which one can reject the null hypothesis that the two means are\n+     * equal in favor of the two-sided alternative that they are different. \n+     * For a one-sided test, divide the returned value by 2.</p>\n+     * <p>\n+     * The test does not assume that the underlying popuation variances are\n+     * equal  and it uses approximated degrees of freedom computed from the \n+     * sample data to compute the p-value.   To perform the test assuming\n+     * equal variances, use \n+     * {@link #homoscedasticTTest(StatisticalSummary, StatisticalSummary)}.</p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the p-value depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n+     * here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The datasets described by the two Univariates must each contain\n+     * at least 2 observations.\n+     * </li></ul></p>\n+     *\n+     * @param sampleStats1  StatisticalSummary describing data from the first sample\n+     * @param sampleStats2  StatisticalSummary describing data from the second sample\n+     * @return p-value for t-test\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    public double tTest(StatisticalSummary sampleStats1, StatisticalSummary sampleStats2)\n+    throws IllegalArgumentException, MathException {\n+        checkSampleData(sampleStats1);\n+        checkSampleData(sampleStats2);\n+        return tTest(sampleStats1.getMean(), sampleStats2.getMean(), sampleStats1.getVariance(),\n+                sampleStats2.getVariance(), sampleStats1.getN(), \n+                sampleStats2.getN());\n+    }\n+    \n+    /**\n+     * Returns the <i>observed significance level</i>, or \n+     * <i>p-value</i>, associated with a two-sample, two-tailed t-test \n+     * comparing the means of the datasets described by two StatisticalSummary\n+     * instances, under the hypothesis of equal subpopulation variances. To\n+     * perform a test without the equal variances assumption, use\n+     * {@link #tTest(StatisticalSummary, StatisticalSummary)}.\n+     * <p>\n+     * The number returned is the smallest significance level\n+     * at which one can reject the null hypothesis that the two means are\n+     * equal in favor of the two-sided alternative that they are different. \n+     * For a one-sided test, divide the returned value by 2.</p>\n+     * <p>\n+     * See {@link #homoscedasticT(double[], double[])} for the formula used to\n+     * compute the t-statistic. The sum of the  sample sizes minus 2 is used as\n+     * the degrees of freedom.</p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the p-value depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">here</a>\n+     * </p><p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The datasets described by the two Univariates must each contain\n+     * at least 2 observations.\n+     * </li></ul></p>\n+     *\n+     * @param sampleStats1  StatisticalSummary describing data from the first sample\n+     * @param sampleStats2  StatisticalSummary describing data from the second sample\n+     * @return p-value for t-test\n+     * @throws IllegalArgumentException if the precondition is not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    public double homoscedasticTTest(StatisticalSummary sampleStats1, \n+                                     StatisticalSummary sampleStats2)\n+    throws IllegalArgumentException, MathException {\n+        checkSampleData(sampleStats1);\n+        checkSampleData(sampleStats2);\n+        return homoscedasticTTest(sampleStats1.getMean(),\n+                sampleStats2.getMean(), sampleStats1.getVariance(),\n+                sampleStats2.getVariance(), sampleStats1.getN(), \n+                sampleStats2.getN());\n+    }\n+\n+    /**\n+     * Performs a \n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/eda/section3/eda353.htm\">\n+     * two-sided t-test</a> evaluating the null hypothesis that \n+     * <code>sampleStats1</code> and <code>sampleStats2</code> describe\n+     * datasets drawn from populations with the same mean, with significance\n+     * level <code>alpha</code>.   This test does not assume that the\n+     * subpopulation variances are equal.  To perform the test under the equal\n+     * variances assumption, use\n+     * {@link #homoscedasticTTest(StatisticalSummary, StatisticalSummary)}.\n+     * <p>\n+     * Returns <code>true</code> iff the null hypothesis that the means are\n+     * equal can be rejected with confidence <code>1 - alpha</code>.  To \n+     * perform a 1-sided test, use <code>alpha * 2</code></p>\n+     * <p>\n+     * See {@link #t(double[], double[])} for the formula used to compute the\n+     * t-statistic.  Degrees of freedom are approximated using the\n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section3/prc31.htm\">\n+     * Welch-Satterthwaite approximation.</a></p>\n+     * <p>\n+     * <strong>Examples:</strong><br><ol>\n+     * <li>To test the (2-sided) hypothesis <code>mean 1 = mean 2 </code> at\n+     * the 95%, use \n+     * <br><code>tTest(sampleStats1, sampleStats2, 0.05) </code>\n+     * </li>\n+     * <li>To test the (one-sided) hypothesis <code> mean 1 < mean 2 </code>\n+     * at the 99% level,  first verify that the measured mean of  \n+     * <code>sample 1</code> is less than  the mean of <code>sample 2</code>\n+     * and then use \n+     * <br><code>tTest(sampleStats1, sampleStats2, 0.02) </code>\n+     * </li></ol></p>\n+     * <p>\n+     * <strong>Usage Note:</strong><br>\n+     * The validity of the test depends on the assumptions of the parametric\n+     * t-test procedure, as discussed \n+     * <a href=\"http://www.basic.nwu.edu/statguidefiles/ttest_unpaired_ass_viol.html\">\n+     * here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>The datasets described by the two Univariates must each contain\n+     * at least 2 observations.\n+     * </li>\n+     * <li> <code> 0 < alpha < 0.5 </code>\n+     * </li></ul></p>\n+     *\n+     * @param sampleStats1 StatisticalSummary describing sample data values\n+     * @param sampleStats2 StatisticalSummary describing sample data values\n+     * @param alpha significance level of the test\n+     * @return true if the null hypothesis can be rejected with \n+     * confidence 1 - alpha\n+     * @throws IllegalArgumentException if the preconditions are not met\n+     * @throws MathException if an error occurs performing the test\n+     */\n+    public boolean tTest(StatisticalSummary sampleStats1,\n+            StatisticalSummary sampleStats2, double alpha)\n+    throws IllegalArgumentException, MathException {\n+        checkSignificanceLevel(alpha);\n+        return (tTest(sampleStats1, sampleStats2) < alpha);\n+    }\n+    \n+    //----------------------------------------------- Protected methods \n+\n+    /**\n+     * Computes approximate degrees of freedom for 2-sample t-test.\n+     * \n+     * @param v1 first sample variance\n+     * @param v2 second sample variance\n+     * @param n1 first sample n\n+     * @param n2 second sample n\n+     * @return approximate degrees of freedom\n+     */\n+    protected double df(double v1, double v2, double n1, double n2) {\n+        return (((v1 / n1) + (v2 / n2)) * ((v1 / n1) + (v2 / n2))) /\n+        ((v1 * v1) / (n1 * n1 * (n1 - 1d)) + (v2 * v2) /\n+                (n2 * n2 * (n2 - 1d)));\n+    }\n+\n+    /**\n+     * Computes t test statistic for 1-sample t-test.\n+     * \n+     * @param m sample mean\n+     * @param mu constant to test against\n+     * @param v sample variance\n+     * @param n sample n\n+     * @return t test statistic\n+     */\n+    protected double t(double m, double mu, double v, double n) {\n+        return (m - mu) / Math.sqrt(v / n);\n+    }\n+    \n+    /**\n+     * Computes t test statistic for 2-sample t-test.\n+     * <p>\n+     * Does not assume that subpopulation variances are equal.</p>\n+     * \n+     * @param m1 first sample mean\n+     * @param m2 second sample mean\n+     * @param v1 first sample variance\n+     * @param v2 second sample variance\n+     * @param n1 first sample n\n+     * @param n2 second sample n\n+     * @return t test statistic\n+     */\n+    protected double t(double m1, double m2,  double v1, double v2, double n1,\n+            double n2)  {\n+            return (m1 - m2) / Math.sqrt((v1 / n1) + (v2 / n2));\n+    }\n+    \n+    /**\n+     * Computes t test statistic for 2-sample t-test under the hypothesis\n+     * of equal subpopulation variances.\n+     * \n+     * @param m1 first sample mean\n+     * @param m2 second sample mean\n+     * @param v1 first sample variance\n+     * @param v2 second sample variance\n+     * @param n1 first sample n\n+     * @param n2 second sample n\n+     * @return t test statistic\n+     */\n+    protected double homoscedasticT(double m1, double m2,  double v1,\n+            double v2, double n1, double n2)  {\n+            double pooledVariance = ((n1  - 1) * v1 + (n2 -1) * v2 ) / (n1 + n2 - 2); \n+            return (m1 - m2) / Math.sqrt(pooledVariance * (1d / n1 + 1d / n2));\n+    }\n+    \n+    /**\n+     * Computes p-value for 2-sided, 1-sample t-test.\n+     * \n+     * @param m sample mean\n+     * @param mu constant to test against\n+     * @param v sample variance\n+     * @param n sample n\n+     * @return p-value\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    protected double tTest(double m, double mu, double v, double n)\n+    throws MathException {\n+        double t = Math.abs(t(m, mu, v, n));\n+        distribution.setDegreesOfFreedom(n - 1);\n+        return 2.0 * distribution.cumulativeProbability(-t);\n+    }\n+\n+    /**\n+     * Computes p-value for 2-sided, 2-sample t-test.\n+     * <p>\n+     * Does not assume subpopulation variances are equal. Degrees of freedom\n+     * are estimated from the data.</p>\n+     * \n+     * @param m1 first sample mean\n+     * @param m2 second sample mean\n+     * @param v1 first sample variance\n+     * @param v2 second sample variance\n+     * @param n1 first sample n\n+     * @param n2 second sample n\n+     * @return p-value\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    protected double tTest(double m1, double m2, double v1, double v2, \n+            double n1, double n2)\n+    throws MathException {\n+        double t = Math.abs(t(m1, m2, v1, v2, n1, n2));\n+        double degreesOfFreedom = 0;\n+        degreesOfFreedom = df(v1, v2, n1, n2);\n+        distribution.setDegreesOfFreedom(degreesOfFreedom);\n+        return 2.0 * distribution.cumulativeProbability(-t);\n+    }\n+    \n+    /**\n+     * Computes p-value for 2-sided, 2-sample t-test, under the assumption\n+     * of equal subpopulation variances.\n+     * <p>\n+     * The sum of the sample sizes minus 2 is used as degrees of freedom.</p>\n+     * \n+     * @param m1 first sample mean\n+     * @param m2 second sample mean\n+     * @param v1 first sample variance\n+     * @param v2 second sample variance\n+     * @param n1 first sample n\n+     * @param n2 second sample n\n+     * @return p-value\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    protected double homoscedasticTTest(double m1, double m2, double v1,\n+            double v2, double n1, double n2)\n+    throws MathException {\n+        double t = Math.abs(homoscedasticT(m1, m2, v1, v2, n1, n2));\n+        double degreesOfFreedom = n1 + n2 - 2;\n+        distribution.setDegreesOfFreedom(degreesOfFreedom);\n+        return 2.0 * distribution.cumulativeProbability(-t);\n+    }\n+    \n+    /**\n+     * Modify the distribution used to compute inference statistics.\n+     * @param value the new distribution\n+     * @since 1.2\n+     */\n+    public void setDistribution(TDistribution value) {\n+        distribution = value;\n+    }\n+\n+    /** Check significance level.\n+     * @param alpha significance level\n+     * @exception IllegalArgumentException if significance level is out of bounds\n+     */\n+    private void checkSignificanceLevel(final double alpha)\n+        throws IllegalArgumentException {\n+        if ((alpha <= 0) || (alpha > 0.5)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"out of bounds significance level {0}, must be between {1} and {2}\",\n+                  alpha, 0.0, 0.5);\n+        }\n+    }\n+\n+    /** Check sample data.\n+     * @param data sample data\n+     * @exception IllegalArgumentException if there is not enough sample data\n+     */\n+    private void checkSampleData(final double[] data)\n+        throws IllegalArgumentException {\n+        if ((data == null) || (data.length < 2)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"insufficient data for t statistic, needs at least 2, got {0}\",\n+                  (data == null) ? 0 : data.length);\n+        }\n+    }\n+\n+    /** Check sample data.\n+     * @param stat statistical summary\n+     * @exception IllegalArgumentException if there is not enough sample data\n+     */\n+    private void checkSampleData(final StatisticalSummary stat)\n+        throws IllegalArgumentException {\n+        if ((stat == null) || (stat.getN() < 2)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"insufficient data for t statistic, needs at least 2, got {0}\",\n+                  (stat == null) ? 0 : stat.getN());\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/inference/TestUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.inference;\n+\n+import java.util.Collection;\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n+\n+/**\n+ * A collection of static methods to create inference test instances or to\n+ * perform inference tests.\n+ *\n+ * @since 1.1\n+ * @version $Revision$ $Date$ \n+ */\n+public class TestUtils  {\n+    /**\n+     * Prevent instantiation.\n+     */\n+    protected TestUtils() {\n+        super();\n+    }\n+    \n+    /** Singleton TTest instance using default implementation. */\n+    private static TTest tTest = new TTestImpl();\n+   \n+    /** Singleton ChiSquareTest instance using default implementation. */\n+    private static ChiSquareTest chiSquareTest = \n+        new ChiSquareTestImpl();\n+    \n+    /** Singleton ChiSquareTest instance using default implementation. */\n+    private static UnknownDistributionChiSquareTest unknownDistributionChiSquareTest = \n+        new ChiSquareTestImpl();\n+    \n+    /** Singleton OneWayAnova instance using default implementation. */\n+    private static OneWayAnova oneWayAnova =\n+        new OneWayAnovaImpl();\n+    \n+    /**\n+     * Set the (singleton) TTest instance.\n+     * \n+     * @param tTest the new instance to use\n+     * @since 1.2\n+     */\n+    public static void setChiSquareTest(TTest tTest) {\n+        TestUtils.tTest = tTest;\n+    }\n+    \n+    /**\n+     * Return a (singleton) TTest instance.  Does not create a new instance.\n+     * \n+     * @return a TTest instance\n+     */\n+    public static TTest getTTest() {\n+        return tTest;\n+    }\n+    \n+    /**\n+     * Set the (singleton) ChiSquareTest instance.\n+     * \n+     * @param chiSquareTest the new instance to use\n+     * @since 1.2\n+     */\n+    public static void setChiSquareTest(ChiSquareTest chiSquareTest) {\n+        TestUtils.chiSquareTest = chiSquareTest;\n+    }\n+    \n+    /**\n+     * Return a (singleton) ChiSquareTest instance.  Does not create a new instance.\n+     * \n+     * @return a ChiSquareTest instance\n+     */\n+    public static ChiSquareTest getChiSquareTest() {\n+        return chiSquareTest;\n+    }\n+    \n+    /**\n+     * Set the (singleton) UnknownDistributionChiSquareTest instance.\n+     * \n+     * @param unknownDistributionChiSquareTest the new instance to use\n+     * @since 1.2\n+     */\n+    public static void setUnknownDistributionChiSquareTest(UnknownDistributionChiSquareTest unknownDistributionChiSquareTest) {\n+        TestUtils.unknownDistributionChiSquareTest = unknownDistributionChiSquareTest;\n+    }\n+    \n+    /**\n+     * Return a (singleton) UnknownDistributionChiSquareTest instance.  Does not create a new instance.\n+     * \n+     * @return a UnknownDistributionChiSquareTest instance\n+     */\n+    public static UnknownDistributionChiSquareTest getUnknownDistributionChiSquareTest() {\n+        return unknownDistributionChiSquareTest;\n+    }\n+    \n+    /**\n+     * Set the (singleton) OneWayAnova instance\n+     * \n+     * @param oneWayAnova the new instance to use\n+     * @since 1.2\n+     */\n+    public static void setOneWayAnova(OneWayAnova oneWayAnova) {\n+        TestUtils.oneWayAnova = oneWayAnova;\n+    }\n+    \n+    /**\n+     * Return a (singleton) OneWayAnova instance.  Does not create a new instance.\n+     * \n+     * @return a OneWayAnova instance\n+     * @since 1.2\n+     */\n+    public static OneWayAnova getOneWayAnova() {\n+        return oneWayAnova;\n+    }\n+    \n+    \n+    // CHECKSTYLE: stop JavadocMethodCheck\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticT(double[], double[])\n+     */\n+    public static double homoscedasticT(double[] sample1, double[] sample2)\n+        throws IllegalArgumentException {\n+        return tTest.homoscedasticT(sample1, sample2);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticT(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)\n+     */\n+    public static double homoscedasticT(StatisticalSummary sampleStats1,\n+        StatisticalSummary sampleStats2)\n+        throws IllegalArgumentException {\n+        return tTest.homoscedasticT(sampleStats1, sampleStats2);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticTTest(double[], double[], double)\n+     */\n+    public static boolean homoscedasticTTest(double[] sample1, double[] sample2,\n+            double alpha)\n+        throws IllegalArgumentException, MathException {\n+        return tTest. homoscedasticTTest(sample1, sample2, alpha);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticTTest(double[], double[])\n+     */\n+    public static double homoscedasticTTest(double[] sample1, double[] sample2)\n+        throws IllegalArgumentException, MathException {\n+        return tTest.homoscedasticTTest(sample1, sample2);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#homoscedasticTTest(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)\n+     */\n+    public static double homoscedasticTTest(StatisticalSummary sampleStats1,\n+        StatisticalSummary sampleStats2)\n+        throws IllegalArgumentException, MathException {\n+        return tTest.homoscedasticTTest(sampleStats1, sampleStats2);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#pairedT(double[], double[])\n+     */\n+    public static double pairedT(double[] sample1, double[] sample2)\n+        throws IllegalArgumentException, MathException {\n+        return tTest.pairedT(sample1, sample2);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#pairedTTest(double[], double[], double)\n+     */\n+    public static boolean pairedTTest(double[] sample1, double[] sample2,\n+        double alpha)\n+        throws IllegalArgumentException, MathException {\n+        return tTest.pairedTTest(sample1, sample2, alpha);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#pairedTTest(double[], double[])\n+     */\n+    public static double pairedTTest(double[] sample1, double[] sample2)\n+        throws IllegalArgumentException, MathException {\n+        return tTest.pairedTTest(sample1, sample2);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#t(double, double[])\n+     */\n+    public static double t(double mu, double[] observed)\n+        throws IllegalArgumentException {\n+        return tTest.t(mu, observed);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#t(double, org.apache.commons.math.stat.descriptive.StatisticalSummary)\n+     */\n+    public static double t(double mu, StatisticalSummary sampleStats)\n+        throws IllegalArgumentException {\n+        return tTest.t(mu, sampleStats);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#t(double[], double[])\n+     */\n+    public static double t(double[] sample1, double[] sample2)\n+        throws IllegalArgumentException {\n+        return tTest.t(sample1, sample2);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#t(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)\n+     */\n+    public static double t(StatisticalSummary sampleStats1,\n+            StatisticalSummary sampleStats2)\n+        throws IllegalArgumentException {\n+        return tTest.t(sampleStats1, sampleStats2);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, double[], double)\n+     */\n+    public static boolean tTest(double mu, double[] sample, double alpha)\n+        throws IllegalArgumentException, MathException {\n+        return tTest.tTest(mu, sample, alpha);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, double[])\n+     */\n+    public static double tTest(double mu, double[] sample)\n+        throws IllegalArgumentException, MathException {\n+        return tTest.tTest(mu, sample);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, org.apache.commons.math.stat.descriptive.StatisticalSummary, double)\n+     */\n+    public static boolean tTest(double mu, StatisticalSummary sampleStats,\n+        double alpha)\n+        throws IllegalArgumentException, MathException {\n+        return tTest. tTest(mu, sampleStats, alpha);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#tTest(double, org.apache.commons.math.stat.descriptive.StatisticalSummary)\n+     */\n+    public static double tTest(double mu, StatisticalSummary sampleStats)\n+        throws IllegalArgumentException, MathException {\n+        return tTest.tTest(mu, sampleStats);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#tTest(double[], double[], double)\n+     */\n+    public static boolean tTest(double[] sample1, double[] sample2, double alpha)\n+        throws IllegalArgumentException, MathException {\n+        return tTest.tTest(sample1, sample2, alpha);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#tTest(double[], double[])\n+     */\n+    public static double tTest(double[] sample1, double[] sample2)\n+        throws IllegalArgumentException, MathException {\n+        return tTest.tTest(sample1, sample2);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#tTest(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary, double)\n+     */\n+    public static boolean tTest(StatisticalSummary sampleStats1,\n+        StatisticalSummary sampleStats2, double alpha)\n+        throws IllegalArgumentException, MathException {\n+        return tTest. tTest(sampleStats1, sampleStats2, alpha);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.TTest#tTest(org.apache.commons.math.stat.descriptive.StatisticalSummary, org.apache.commons.math.stat.descriptive.StatisticalSummary)\n+     */\n+    public static double tTest(StatisticalSummary sampleStats1,\n+        StatisticalSummary sampleStats2)\n+        throws IllegalArgumentException, MathException {\n+        return tTest.tTest(sampleStats1, sampleStats2);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquare(double[], long[])\n+     */\n+    public static double chiSquare(double[] expected, long[] observed)\n+        throws IllegalArgumentException {\n+        return chiSquareTest.chiSquare(expected, observed);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquare(long[][])\n+     */\n+    public static double chiSquare(long[][] counts) \n+        throws IllegalArgumentException {\n+        return chiSquareTest.chiSquare(counts);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(double[], long[], double)\n+     */\n+    public static boolean chiSquareTest(double[] expected, long[] observed,\n+        double alpha)\n+        throws IllegalArgumentException, MathException {\n+        return chiSquareTest.chiSquareTest(expected, observed, alpha);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(double[], long[])\n+     */\n+    public static double chiSquareTest(double[] expected, long[] observed)\n+        throws IllegalArgumentException, MathException {\n+        return chiSquareTest.chiSquareTest(expected, observed);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(long[][], double)\n+     */\n+    public static boolean chiSquareTest(long[][] counts, double alpha)\n+        throws IllegalArgumentException, MathException {\n+        return chiSquareTest. chiSquareTest(counts, alpha);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.ChiSquareTest#chiSquareTest(long[][])\n+     */\n+    public static double chiSquareTest(long[][] counts)\n+        throws IllegalArgumentException, MathException {\n+        return chiSquareTest. chiSquareTest(counts);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.UnknownDistributionChiSquareTest#chiSquareDataSetsComparison(long[], long[])\n+     *\n+     * @since 1.2\n+     */\n+    public static double chiSquareDataSetsComparison(long[] observed1, long[] observed2)\n+        throws IllegalArgumentException {\n+        return unknownDistributionChiSquareTest.chiSquareDataSetsComparison(observed1, observed2);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.UnknownDistributionChiSquareTest#chiSquareTestDataSetsComparison(long[], long[])\n+     *\n+     * @since 1.2\n+     */\n+    public static double chiSquareTestDataSetsComparison(long[] observed1, long[] observed2)\n+        throws IllegalArgumentException, MathException {\n+        return unknownDistributionChiSquareTest.chiSquareTestDataSetsComparison(observed1, observed2);\n+    }\n+\n+\n+    /**\n+     * @see org.apache.commons.math.stat.inference.UnknownDistributionChiSquareTest#chiSquareTestDataSetsComparison(long[], long[], double)\n+     *\n+     * @since 1.2\n+     */\n+    public static boolean chiSquareTestDataSetsComparison(long[] observed1, long[] observed2,\n+        double alpha)\n+        throws IllegalArgumentException, MathException {\n+        return unknownDistributionChiSquareTest.chiSquareTestDataSetsComparison(observed1, observed2, alpha);\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.inference.OneWayAnova#anovaFValue(Collection)\n+     *\n+     * @since 1.2\n+     */\n+    public static double oneWayAnovaFValue(Collection<double[]> categoryData)\n+    throws IllegalArgumentException, MathException {\n+        return oneWayAnova.anovaFValue(categoryData);\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.inference.OneWayAnova#anovaPValue(Collection)\n+     * \n+     * @since 1.2\n+     */\n+    public static double oneWayAnovaPValue(Collection<double[]> categoryData)\n+    throws IllegalArgumentException, MathException {\n+        return oneWayAnova.anovaPValue(categoryData);\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.inference.OneWayAnova#anovaTest(Collection,double)\n+     *\n+     * @since 1.2\n+     */\n+    public static boolean oneWayAnovaTest(Collection<double[]> categoryData, double alpha)\n+    throws IllegalArgumentException, MathException {\n+        return oneWayAnova.anovaTest(categoryData, alpha);\n+    }\n+\n+    // CHECKSTYLE: resume JavadocMethodCheck\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/inference/UnknownDistributionChiSquareTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.inference;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * An interface for Chi-Square tests for unknown distributions.\n+ * <p>Two samples tests are used when the distribution is unknown <i>a priori</i>\n+ * but provided by one sample. We compare the second sample against the first.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2 \n+ */\n+public interface UnknownDistributionChiSquareTest extends ChiSquareTest {\n+     \n+    /**\n+     * <p>Computes a \n+     * <a href=\"http://www.itl.nist.gov/div898/software/dataplot/refman1/auxillar/chi2samp.htm\">\n+     * Chi-Square two sample test statistic</a> comparing bin frequency counts\n+     * in <code>observed1</code> and <code>observed2</code>.  The\n+     * sums of frequency counts in the two samples are not required to be the\n+     * same.  The formula used to compute the test statistic is</p>\n+     * <code>\n+     * &sum;[(K * observed1[i] - observed2[i]/K)<sup>2</sup> / (observed1[i] + observed2[i])]\n+     * </code> where \n+     * <br/><code>K = &sqrt;[&sum(observed2 / &sum;(observed1)]</code>\n+     * </p>\n+     * <p>This statistic can be used to perform a Chi-Square test evaluating the null hypothesis that\n+     * both observed counts follow the same distribution.</p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>Observed counts must be non-negative.\n+     * </li>\n+     * <li>Observed counts for a specific bin must not both be zero.\n+     * </li>\n+     * <li>Observed counts for a specific sample must not all be 0.\n+     * </li>\n+     * <li>The arrays <code>observed1</code> and <code>observed2</code> must have the same length and\n+     * their common length must be at least 2.\n+     * </li></ul></p><p>\n+     * If any of the preconditions are not met, an\n+     * <code>IllegalArgumentException</code> is thrown.</p>\n+     *\n+     * @param observed1 array of observed frequency counts of the first data set\n+     * @param observed2 array of observed frequency counts of the second data set\n+     * @return chiSquare statistic\n+     * @throws IllegalArgumentException if preconditions are not met\n+     */\n+    double chiSquareDataSetsComparison(long[] observed1, long[] observed2)\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * <p>Returns the <i>observed significance level</i>, or <a href=\n+     * \"http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue\">\n+     * p-value</a>, associated with a Chi-Square two sample test comparing\n+     * bin frequency counts in <code>observed1</code> and \n+     * <code>observed2</code>.\n+     * </p>\n+     * <p>The number returned is the smallest significance level at which one\n+     * can reject the null hypothesis that the observed counts conform to the\n+     * same distribution.\n+     * </p>\n+     * <p>See {@link #chiSquareDataSetsComparison(long[], long[])} for details\n+     * on the formula used to compute the test statistic. The degrees of\n+     * of freedom used to perform the test is one less than the common length\n+     * of the input observed count arrays.\n+     * </p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>Observed counts must be non-negative.\n+     * </li>\n+     * <li>Observed counts for a specific bin must not both be zero.\n+     * </li>\n+     * <li>Observed counts for a specific sample must not all be 0.\n+     * </li>\n+     * <li>The arrays <code>observed1</code> and <code>observed2</code> must\n+     * have the same length and\n+     * their common length must be at least 2.\n+     * </li></ul><p>\n+     * If any of the preconditions are not met, an\n+     * <code>IllegalArgumentException</code> is thrown.</p>\n+     *\n+     * @param observed1 array of observed frequency counts of the first data set\n+     * @param observed2 array of observed frequency counts of the second data set\n+     * @return p-value\n+     * @throws IllegalArgumentException if preconditions are not met\n+     * @throws MathException if an error occurs computing the p-value\n+     */\n+    double chiSquareTestDataSetsComparison(long[] observed1, long[] observed2)\n+      throws IllegalArgumentException, MathException;\n+\n+    /**\n+     * <p>Performs a Chi-Square two sample test comparing two binned data\n+     * sets. The test evaluates the null hypothesis that the two lists of\n+     * observed counts conform to the same frequency distribution, with\n+     * significance level <code>alpha</code>.  Returns true iff the null\n+     * hypothesis can be rejected with 100 * (1 - alpha) percent confidence.\n+     * </p>\n+     * <p>See {@link #chiSquareDataSetsComparison(long[], long[])} for \n+     * details on the formula used to compute the Chisquare statistic used\n+     * in the test. The degrees of of freedom used to perform the test is\n+     * one less than the common length of the input observed count arrays.\n+     * </p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>Observed counts must be non-negative.\n+     * </li>\n+     * <li>Observed counts for a specific bin must not both be zero.\n+     * </li>\n+     * <li>Observed counts for a specific sample must not all be 0.\n+     * </li>\n+     * <li>The arrays <code>observed1</code> and <code>observed2</code> must\n+     * have the same length and their common length must be at least 2.\n+     * </li>\n+     * <li> <code> 0 < alpha < 0.5 </code>\n+     * </li></ul><p>\n+     * If any of the preconditions are not met, an\n+     * <code>IllegalArgumentException</code> is thrown.</p>\n+     *\n+     * @param observed1 array of observed frequency counts of the first data set\n+     * @param observed2 array of observed frequency counts of the second data set\n+     * @param alpha significance level of the test\n+     * @return true iff null hypothesis can be rejected with confidence\n+     * 1 - alpha\n+     * @throws IllegalArgumentException if preconditions are not met\n+     * @throws MathException if an error occurs performing the test\n+     */\n+    boolean chiSquareTestDataSetsComparison(long[] observed1, long[] observed2, double alpha)\n+      throws IllegalArgumentException, MathException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/ranking/NaNStrategy.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.ranking;\n+\n+/**\n+ * Strategies for handling NaN values in rank transformations.\n+ * <ul>\n+ * <li>MINIMAL - NaNs are treated as minimal in the ordering, equivalent to\n+ * (that is, tied with) <code>Double.NEGATIVE_INFINITY</code>.</li>\n+ * <li>MAXIMAL - NaNs are treated as maximal in the ordering, equivalent to\n+ * <code>Double.POSITIVE_INFINITY</code></li>\n+ * <li>REMOVED - NaNs are removed before the rank transform is applied</li>\n+ * <li>FIXED - NaNs are left \"in place,\" that is the rank transformation is\n+ * applied to the other elements in the input array, but the NaN elements\n+ * are returned unchanged.</li>\n+ * </ul>\n+ *\n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+public enum NaNStrategy {\n+    \n+    /** NaNs are considered minimal in the ordering */\n+    MINIMAL,\n+    \n+    /** NaNs are considered maximal in the ordering */\n+    MAXIMAL,\n+    \n+    /** NaNs are removed before computing ranks */\n+    REMOVED,\n+    \n+    /** NaNs are left in place */\n+    FIXED\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/ranking/NaturalRanking.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.ranking;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import org.apache.commons.math.random.RandomData;\n+import org.apache.commons.math.random.RandomDataImpl;\n+import org.apache.commons.math.random.RandomGenerator;\n+\n+\n+/**\n+ * <p> Ranking based on the natural ordering on doubles.</p>\n+ * <p>NaNs are treated according to the configured {@link NaNStrategy} and ties\n+ * are handled using the selected {@link TiesStrategy}. \n+ * Configuration settings are supplied in optional constructor arguments.\n+ * Defaults are {@link NaNStrategy#MAXIMAL} and {@link TiesStrategy#AVERAGE},\n+ * respectively. When using {@link TiesStrategy#RANDOM}, a \n+ * {@link RandomGenerator} may be supplied as a constructor argument.</p>\n+ * <p>Examples:\n+ * <table border=\"1\" cellpadding=\"3\">\n+ * <tr><th colspan=\"3\">\n+ * Input data: (20, 17, 30, 42.3, 17, 50, Double.NaN, Double.NEGATIVE_INFINITY, 17)\n+ * </th></tr>\n+ * <tr><th>NaNStrategy</th><th>TiesStrategy</th>\n+ * <th><code>rank(data)</code></th>\n+ * <tr>\n+ * <td>default (NaNs maximal)</td>\n+ * <td>default (ties averaged)</td>\n+ * <td>(5, 3, 6, 7, 3, 8, 9, 1, 3)</td></tr>\n+ * <tr>\n+ * <td>default (NaNs maximal)</td>\n+ * <td>MINIMUM</td>\n+ * <td>(5, 2, 6, 7, 2, 8, 9, 1, 2)</td></tr>\n+ * <tr>\n+ * <td>MINIMAL</td>\n+ * <td>default (ties averaged)</td>\n+ * <td>(6, 4, 7, 8, 4, 9, 1.5, 1.5, 4)</td></tr>\n+ * <tr>\n+ * <td>REMOVED</td>\n+ * <td>SEQUENTIAL</td>\n+ * <td>(5, 2, 6, 7, 3, 8, 1, 4)</td></tr>\n+ * <tr>\n+ * <td>MINIMAL</td>\n+ * <td>MAXIMUM</td>\n+ * <td>(6, 5, 7, 8, 5, 9, 2, 2, 5)</td></tr></table></p>\n+ * \n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+public class NaturalRanking implements RankingAlgorithm {\n+   \n+    /** NaN strategy - defaults to NaNs maximal */\n+    private final NaNStrategy nanStrategy;\n+    \n+    /** Ties strategy - defaults to ties averaged */\n+    private final TiesStrategy tiesStrategy;\n+    \n+    /** Source of random data - used only when ties strategy is RANDOM */\n+    private final RandomData randomData;\n+    \n+    /** default NaN strategy */\n+    public static final NaNStrategy DEFAULT_NAN_STRATEGY = NaNStrategy.MAXIMAL;\n+    \n+    /** default ties strategy */\n+    public static final TiesStrategy DEFAULT_TIES_STRATEGY = TiesStrategy.AVERAGE;\n+    \n+    /**\n+     * Create a NaturalRanking with default strategies for handling ties and NaNs.\n+     */\n+    public NaturalRanking() {\n+        super();\n+        tiesStrategy = DEFAULT_TIES_STRATEGY;\n+        nanStrategy = DEFAULT_NAN_STRATEGY;\n+        randomData = null;\n+    }\n+\n+    /**\n+     * Create a NaturalRanking with the given TiesStrategy.\n+     * \n+     * @param tiesStrategy the TiesStrategy to use\n+     */\n+    public NaturalRanking(TiesStrategy tiesStrategy) {\n+        super();\n+        this.tiesStrategy = tiesStrategy;\n+        nanStrategy = DEFAULT_NAN_STRATEGY;\n+        randomData = new RandomDataImpl();\n+    }\n+\n+    /**\n+     * Create a NaturalRanking with the given NaNStrategy.\n+     * \n+     * @param nanStrategy the NaNStrategy to use\n+     */\n+    public NaturalRanking(NaNStrategy nanStrategy) {\n+        super();\n+        this.nanStrategy = nanStrategy;\n+        tiesStrategy = DEFAULT_TIES_STRATEGY;\n+        randomData = null; \n+    }\n+\n+    /**\n+     * Create a NaturalRanking with the given NaNStrategy and TiesStrategy.\n+     * \n+     * @param nanStrategy NaNStrategy to use\n+     * @param tiesStrategy TiesStrategy to use\n+     */\n+    public NaturalRanking(NaNStrategy nanStrategy, TiesStrategy tiesStrategy) {\n+        super();\n+        this.nanStrategy = nanStrategy;\n+        this.tiesStrategy = tiesStrategy;\n+        randomData = new RandomDataImpl();\n+    }\n+    \n+    /**\n+     * Create a NaturalRanking with TiesStrategy.RANDOM and the given\n+     * RandomGenerator as the source of random data.\n+     * \n+     * @param randomGenerator source of random data\n+     */\n+    public NaturalRanking(RandomGenerator randomGenerator) {\n+        super();\n+        this.tiesStrategy = TiesStrategy.RANDOM;\n+        nanStrategy = DEFAULT_NAN_STRATEGY;\n+        randomData = new RandomDataImpl(randomGenerator);\n+    }\n+\n+\n+    /**\n+     * Create a NaturalRanking with the given NaNStrategy, TiesStrategy.RANDOM\n+     * and the given source of random data.\n+     * \n+     * @param nanStrategy NaNStrategy to use\n+     * @param randomGenerator source of random data\n+     */\n+    public NaturalRanking(NaNStrategy nanStrategy,\n+            RandomGenerator randomGenerator) {\n+        super();\n+        this.nanStrategy = nanStrategy;\n+        this.tiesStrategy = TiesStrategy.RANDOM;\n+        randomData = new RandomDataImpl(randomGenerator);\n+    }\n+    \n+    /**\n+     * Return the NaNStrategy\n+     * \n+     * @return returns the NaNStrategy\n+     */\n+    public NaNStrategy getNanStrategy() {\n+        return nanStrategy;\n+    }\n+\n+    /**\n+     * Return the TiesStrategy\n+     * \n+     * @return the TiesStrategy\n+     */\n+    public TiesStrategy getTiesStrategy() {\n+        return tiesStrategy;\n+    }\n+\n+    /**\n+     * Rank <code>data</code> using the natural ordering on Doubles, with\n+     * NaN values handled according to <code>nanStrategy</code> and ties\n+     * resolved using <code>tiesStrategy.</code>\n+     * \n+     * @param data array to be ranked\n+     * @return array of ranks\n+     */\n+    public double[] rank(double[] data) {\n+        \n+        // Array recording initial positions of data to be ranked\n+        IntDoublePair[] ranks = new IntDoublePair[data.length];  \n+        for (int i = 0; i < data.length; i++) {\n+            ranks[i] = new IntDoublePair(data[i], i);\n+        }\n+        \n+        // Recode, remove or record positions of NaNs\n+        List<Integer> nanPositions = null;\n+        switch (nanStrategy) {\n+            case MAXIMAL: // Replace NaNs with +INFs\n+                recodeNaNs(ranks, Double.POSITIVE_INFINITY);\n+                break;\n+            case MINIMAL: // Replace NaNs with -INFs\n+                recodeNaNs(ranks, Double.NEGATIVE_INFINITY);\n+                break;\n+            case REMOVED: // Drop NaNs from data\n+                ranks = removeNaNs(ranks);\n+                break;\n+            case FIXED:   // Record positions of NaNs\n+                nanPositions = getNanPositions(ranks);\n+                break;\n+        }\n+        \n+        // Sort the IntDoublePairs\n+        Arrays.sort(ranks);\n+        \n+        // Walk the sorted array, filling output array using sorted positions,\n+        // resolving ties as we go\n+        double[] out = new double[ranks.length];\n+        int pos = 1;  // position in sorted array \n+        out[ranks[0].getPosition()] = pos;\n+        List<Integer> tiesTrace = new ArrayList<Integer>();\n+        tiesTrace.add(ranks[0].getPosition());\n+        for (int i = 1; i < ranks.length; i++) {\n+            if (Double.compare(ranks[i].getValue(), ranks[i - 1].getValue()) > 0) {\n+                // tie sequence has ended (or had length 1)\n+                pos = i + 1;\n+                if (tiesTrace.size() > 1) {  // if seq is nontrivial, resolve\n+                    resolveTie(out, tiesTrace);\n+                }\n+                tiesTrace = new ArrayList<Integer>();\n+                tiesTrace.add(ranks[i].getPosition());\n+            } else {\n+                // tie sequence continues\n+                tiesTrace.add(ranks[i].getPosition());\n+            }\n+            out[ranks[i].getPosition()] = pos;\n+        }\n+        if (tiesTrace.size() > 1) {  // handle tie sequence at end\n+            resolveTie(out, tiesTrace);\n+        }\n+        if (nanStrategy == NaNStrategy.FIXED) {\n+            restoreNaNs(out, nanPositions);\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     * Returns an array that is a copy of the input array with IntDoublePairs\n+     * having NaN values removed.\n+     * \n+     * @param ranks input array\n+     * @return array with NaN-valued entries removed\n+     */\n+    private IntDoublePair[] removeNaNs(IntDoublePair[] ranks) {\n+        if (!containsNaNs(ranks)) {\n+            return ranks;\n+        }\n+        IntDoublePair[] outRanks = new IntDoublePair[ranks.length];\n+        int j = 0;\n+        for (int i = 0; i < ranks.length; i++) {\n+            if (Double.isNaN(ranks[i].getValue())) {\n+                // drop, but adjust original ranks of later elements\n+                for (int k = i + 1; k < ranks.length; k++) {\n+                    ranks[k] = new IntDoublePair(\n+                            ranks[k].getValue(), ranks[k].getPosition() - 1);\n+                }\n+            } else {\n+                outRanks[j] = new IntDoublePair(\n+                        ranks[i].getValue(), ranks[i].getPosition());\n+                j++;\n+            }\n+        }\n+        IntDoublePair[] returnRanks = new IntDoublePair[j];\n+        System.arraycopy(outRanks, 0, returnRanks, 0, j);\n+        return returnRanks;\n+    }\n+\n+    /**\n+     * Recodes NaN values to the given value. \n+     * \n+     * @param ranks array to recode\n+     * @param value the value to replace NaNs with\n+     */\n+    private void recodeNaNs(IntDoublePair[] ranks, double value) {\n+        for (int i = 0; i < ranks.length; i++) {\n+            if (Double.isNaN(ranks[i].getValue())) {\n+                ranks[i] = new IntDoublePair(\n+                        value, ranks[i].getPosition());\n+            }\n+        }\n+    }\n+    \n+    /**\n+     * Checks for presence of NaNs in <code>ranks.</code>\n+     * \n+     * @param ranks array to be searched for NaNs\n+     * @return true iff ranks contains one or more NaNs\n+     */\n+    private boolean containsNaNs(IntDoublePair[] ranks) {\n+        for (int i = 0; i < ranks.length; i++) {\n+            if (Double.isNaN(ranks[i].getValue())) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+    \n+    /**\n+     * Resolve a sequence of ties, using the configured {@link TiesStrategy}.\n+     * The input <code>ranks</code> array is expected to take the same value\n+     * for all indices in <code>tiesTrace</code>.  The common value is recoded\n+     * according to the tiesStrategy. For example, if ranks = <5,8,2,6,2,7,1,2>,\n+     * tiesTrace = <2,4,7> and tiesStrategy is MINIMUM, ranks will be unchanged.\n+     * The same array and trace with tiesStrategy AVERAGE will come out\n+     * <5,8,3,6,3,7,1,3>.\n+     * \n+     * @param ranks array of ranks \n+     * @param tiesTrace list of indices where <code>ranks</code> is constant\n+     * -- that is, for any i and j in TiesTrace, <code> ranks[i] == ranks[j] \n+     * </code>\n+     */\n+    private void resolveTie(double[] ranks, List<Integer> tiesTrace) {\n+        \n+        // constant value of ranks over tiesTrace\n+        final double c = ranks[tiesTrace.get(0)];\n+        \n+        // length of sequence of tied ranks\n+        final int length = tiesTrace.size();\n+        \n+        switch (tiesStrategy) {\n+            case  AVERAGE:  // Replace ranks with average\n+                fill(ranks, tiesTrace, (2 * c + length - 1) / 2d);\n+                break;\n+            case MAXIMUM:   // Replace ranks with maximum values\n+                fill(ranks, tiesTrace, c + length - 1);\n+                break;\n+            case MINIMUM:   // Replace ties with minimum\n+                fill(ranks, tiesTrace, c);\n+                break;\n+            case RANDOM:    // Fill with random integral values in [c, c + length - 1]\n+                Iterator<Integer> iterator = tiesTrace.iterator();\n+                long f = Math.round(c);\n+                while (iterator.hasNext()) {\n+                    ranks[iterator.next()] = \n+                        randomData.nextLong(f, f + length - 1);\n+                }\n+                break;\n+            case SEQUENTIAL:  // Fill sequentially from c to c + length - 1\n+                // walk and fill\n+                iterator = tiesTrace.iterator();\n+                f = Math.round(c);\n+                int i = 0;\n+                while (iterator.hasNext()) {\n+                    ranks[iterator.next()] = f + i++;\n+                }\n+                break;\n+        }   \n+    }\n+    \n+    /**\n+     * Sets<code>data[i] = value</code> for each i in <code>tiesTrace.</code>\n+     * \n+     * @param data array to modify\n+     * @param tiesTrace list of index values to set\n+     * @param value value to set\n+     */\n+    private void fill(double[] data, List<Integer> tiesTrace, double value) {\n+        Iterator<Integer> iterator = tiesTrace.iterator();\n+        while (iterator.hasNext()) {\n+            data[iterator.next()] = value;\n+        }\n+    }\n+    \n+    /**\n+     * Set <code>ranks[i] = Double.NaN</code> for each i in <code>nanPositions.</code>\n+     * \n+     * @param ranks array to modify\n+     * @param nanPositions list of index values to set to <code>Double.NaN</code>\n+     */\n+    private void restoreNaNs(double[] ranks, List<Integer> nanPositions) {\n+        if (nanPositions.size() == 0) {\n+            return;\n+        }\n+        Iterator<Integer> iterator = nanPositions.iterator();\n+        while (iterator.hasNext()) {\n+            ranks[iterator.next().intValue()] = Double.NaN;  \n+        }\n+        \n+    }\n+    \n+    /**\n+     * Returns a list of indexes where <code>ranks</code> is <code>NaN.</code>\n+     * \n+     * @param ranks array to search for <code>NaNs</code>\n+     * @return list of indexes i such that <code>ranks[i] = NaN</code>\n+     */\n+    private List<Integer> getNanPositions(IntDoublePair[] ranks) {\n+        ArrayList<Integer> out = new ArrayList<Integer>();\n+        for (int i = 0; i < ranks.length; i++) {\n+            if (Double.isNaN(ranks[i].getValue())) {\n+                out.add(Integer.valueOf(i));\n+            }\n+        }\n+        return out;     \n+    }\n+    \n+    /**\n+     * Represents the position of a double value in an ordering.\n+     * Comparable interface is implemented so Arrays.sort can be used\n+     * to sort an array of IntDoublePairs by value.  Note that the\n+     * implicitly defined natural ordering is NOT consistent with equals.\n+     */\n+    private static class IntDoublePair implements Comparable<IntDoublePair>  {\n+\n+        /** Value of the pair */\n+        final private double value;\n+\n+        /** Original position of the pair */\n+        final private int position;\n+\n+        /**\n+         * Construct an IntDoublePair with the given value and position.\n+         * @param value the value of the pair\n+         * @param position the original position\n+         */\n+        public IntDoublePair(double value, int position) {\n+            this.value = value;\n+            this.position = position;\n+        }\n+\n+        /**\n+         * Compare this IntDoublePair to another pair.\n+         * Only the <strong>values</strong> are compared.\n+         * \n+         * @param other the other pair to compare this to\n+         * @return result of <code>Double.compare(value, other.value)</code>\n+         */\n+        public int compareTo(IntDoublePair other) {\n+            return Double.compare(value, other.value);\n+        }\n+\n+        /**\n+         * Returns the value of the pair.\n+         * @return value\n+         */\n+        public double getValue() {\n+            return value;\n+        }\n+\n+        /**\n+         * Returns the original position of the pair.\n+         * @return position\n+         */\n+        public int getPosition() {\n+            return position;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/ranking/RankingAlgorithm.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.ranking;\n+\n+/**\n+ * Interface representing a rank transformation.\n+ * \n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+public interface RankingAlgorithm {\n+    /**\n+     * <p>Performs a rank transformation on the input data, returning an array\n+     * of ranks.</p>\n+     * \n+     * <p>Ranks should be 1-based - that is, the smallest value\n+     * returned in an array of ranks should be greater than or equal to one,\n+     * rather than 0. Ranks should in general take integer values, though\n+     * implementations may return averages or other floating point values\n+     * to resolve ties in the input data.</p>\n+     * \n+     * @param data array of data to be ranked\n+     * @return an array of ranks corresponding to the elements of the input array\n+     */\n+    double[] rank (double[] data);\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/ranking/TiesStrategy.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.ranking;\n+\n+/**\n+ * Strategies for handling tied values in rank transformations.\n+ * <ul>\n+ * <li>SEQUENTIAL - Ties are assigned ranks in order of occurrence in the original array,\n+ * for example (1,3,4,3) is ranked as (1,2,4,3)</li>\n+ * <li>MINIMUM - Tied values are assigned the minimum applicable rank, or the rank\n+ * of the first occurrence. For example, (1,3,4,3) is ranked as (1,2,4,2)</li>\n+ * <li>MAXIMUM - Tied values are assigned the maximum applicable rank, or the rank\n+ * of the last occurrence. For example, (1,3,4,3) is ranked as (1,3,4,3)</li>\n+ * <li>AVERAGE - Tied values are assigned the average of the applicable ranks.  \n+ * For example, (1,3,4,3) is ranked as (1,2.5,4,2.5)</li>\n+ * <li>AVERAGE - Tied values are assigned a random integer rank from among the\n+ * applicable values. The assigned rank will always be an integer, (inclusively)\n+ * between the values retured by the MINIMUM and MAXIMUM strategies.</li>\n+ * </ul>\n+ *\n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+public enum TiesStrategy {\n+    \n+    /** Ties assigned sequential ranks in order of occurrence */\n+    SEQUENTIAL,\n+    \n+    /** Ties get the minimum applicable rank */\n+    MINIMUM,\n+    \n+    /** Ties get the maximum applicable rank */\n+    MAXIMUM,\n+    \n+    /** Ties get the average of applicable ranks */\n+    AVERAGE,\n+    \n+    /** Ties get a random integral value from among applicable ranks */\n+    RANDOM\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/regression/AbstractMultipleLinearRegression.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.regression;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.linear.ArrayRealVector;\n+\n+/**\n+ * Abstract base class for implementations of MultipleLinearRegression.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class AbstractMultipleLinearRegression implements\n+        MultipleLinearRegression {\n+\n+    /** X sample data. */\n+    protected RealMatrix X;\n+\n+    /** Y sample data. */\n+    protected RealVector Y;\n+\n+    /**\n+     * Loads model x and y sample data from a flat array of data, overriding any previous sample.\n+     * Assumes that rows are concatenated with y values first in each row.\n+     * \n+     * @param data input data array\n+     * @param nobs number of observations (rows)\n+     * @param nvars number of independent variables (columns, not counting y)\n+     */\n+    public void newSampleData(double[] data, int nobs, int nvars) {\n+        double[] y = new double[nobs];\n+        double[][] x = new double[nobs][nvars + 1];\n+        int pointer = 0;\n+        for (int i = 0; i < nobs; i++) {\n+            y[i] = data[pointer++];\n+            x[i][0] = 1.0d;\n+            for (int j = 1; j < nvars + 1; j++) {\n+                x[i][j] = data[pointer++];\n+            }\n+        }\n+        this.X = new Array2DRowRealMatrix(x);\n+        this.Y = new ArrayRealVector(y);\n+    }\n+    \n+    /**\n+     * Loads new y sample data, overriding any previous sample\n+     * \n+     * @param y the [n,1] array representing the y sample\n+     */\n+    protected void newYSampleData(double[] y) {\n+        this.Y = new ArrayRealVector(y);\n+    }\n+\n+    /**\n+     * Loads new x sample data, overriding any previous sample\n+     * \n+     * @param x the [n,k] array representing the x sample\n+     */\n+    protected void newXSampleData(double[][] x) {\n+        this.X = new Array2DRowRealMatrix(x);\n+    }\n+\n+    /**\n+     * Validates sample data.\n+     * \n+     * @param x the [n,k] array representing the x sample\n+     * @param y the [n,1] array representing the y sample\n+     * @throws IllegalArgumentException if the x and y array data are not\n+     *             compatible for the regression\n+     */\n+    protected void validateSampleData(double[][] x, double[] y) {\n+        if ((x == null) || (y == null) || (x.length != y.length)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"dimension mismatch {0} != {1}\",\n+                  (x == null) ? 0 : x.length,\n+                  (y == null) ? 0 : y.length);\n+        } else if ((x.length > 0) && (x[0].length > x.length)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"not enough data ({0} rows) for this many predictors ({1} predictors)\",\n+                  x.length, x[0].length);\n+        }\n+    }\n+\n+    /**\n+     * Validates sample data.\n+     * \n+     * @param x the [n,k] array representing the x sample\n+     * @param covariance the [n,n] array representing the covariance matrix\n+     * @throws IllegalArgumentException if the x sample data or covariance\n+     *             matrix are not compatible for the regression\n+     */\n+    protected void validateCovarianceData(double[][] x, double[][] covariance) {\n+        if (x.length != covariance.length) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                 \"dimension mismatch {0} != {1}\", x.length, covariance.length);\n+        }\n+        if (covariance.length > 0 && covariance.length != covariance[0].length) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"a {0}x{1} matrix was provided instead of a square matrix\",\n+                  covariance.length, covariance[0].length);\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double[] estimateRegressionParameters() {\n+        RealVector b = calculateBeta();\n+        return b.getData();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double[] estimateResiduals() {\n+        RealVector b = calculateBeta();\n+        RealVector e = Y.subtract(X.operate(b));\n+        return e.getData();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double[][] estimateRegressionParametersVariance() {\n+        return calculateBetaVariance().getData();\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double[] estimateRegressionParametersStandardErrors() {\n+        double[][] betaVariance = estimateRegressionParametersVariance();\n+        double sigma = calculateYVariance();\n+        int length = betaVariance[0].length;\n+        double[] result = new double[length];\n+        for (int i = 0; i < length; i++) {\n+            result[i] = Math.sqrt(sigma * betaVariance[i][i]);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    public double estimateRegressandVariance() {\n+        return calculateYVariance();\n+    }\n+\n+    /**\n+     * Calculates the beta of multiple linear regression in matrix notation.\n+     * \n+     * @return beta\n+     */\n+    protected abstract RealVector calculateBeta();\n+\n+    /**\n+     * Calculates the beta variance of multiple linear regression in matrix\n+     * notation.\n+     * \n+     * @return beta variance\n+     */\n+    protected abstract RealMatrix calculateBetaVariance();\n+\n+    /**\n+     * Calculates the Y variance of multiple linear regression.\n+     * \n+     * @return Y variance\n+     */\n+    protected abstract double calculateYVariance();\n+\n+    /**\n+     * Calculates the residuals of multiple linear regression in matrix\n+     * notation.\n+     * \n+     * <pre>\n+     * u = y - X * b\n+     * </pre>\n+     * \n+     * @return The residuals [n,1] matrix\n+     */\n+    protected RealVector calculateResiduals() {\n+        RealVector b = calculateBeta();\n+        return Y.subtract(X.operate(b));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegression.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.regression;\n+\n+import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.linear.RealVector;\n+\n+\n+/**\n+ * The GLS implementation of the multiple linear regression.\n+ * \n+ * GLS assumes a general covariance matrix Omega of the error\n+ * <pre>\n+ * u ~ N(0, Omega)\n+ * </pre>\n+ * \n+ * Estimated by GLS, \n+ * <pre>\n+ * b=(X' Omega^-1 X)^-1X'Omega^-1 y\n+ * </pre>\n+ * whose variance is\n+ * <pre>\n+ * Var(b)=(X' Omega^-1 X)^-1\n+ * </pre>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class GLSMultipleLinearRegression extends AbstractMultipleLinearRegression {\n+    \n+    /** Covariance matrix. */\n+    private RealMatrix Omega;\n+\n+    /** Inverse of covariance matrix. */\n+    private RealMatrix OmegaInverse;\n+\n+    /** Replace sample data, overriding any previous sample.\n+     * @param y y values of the sample\n+     * @param x x values of the sample\n+     * @param covariance array representing the covariance matrix\n+     */\n+    public void newSampleData(double[] y, double[][] x, double[][] covariance) {\n+        validateSampleData(x, y);\n+        newYSampleData(y);\n+        newXSampleData(x);\n+        validateCovarianceData(x, covariance);\n+        newCovarianceData(covariance);\n+    }\n+\n+    /**\n+     * Add the covariance data.\n+     * \n+     * @param omega the [n,n] array representing the covariance\n+     */\n+    protected void newCovarianceData(double[][] omega){\n+        this.Omega = new Array2DRowRealMatrix(omega);\n+        this.OmegaInverse = null;\n+    }\n+\n+    /**\n+     * Get the inverse of the covariance.\n+     * <p>The inverse of the covariance matrix is lazily evaluated and cached.</p>\n+     * @return inverse of the covariance\n+     */\n+    protected RealMatrix getOmegaInverse() {\n+        if (OmegaInverse == null) {\n+            OmegaInverse = new LUDecompositionImpl(Omega).getSolver().getInverse();\n+        }\n+        return OmegaInverse;\n+    }\n+    \n+    /**\n+     * Calculates beta by GLS.\n+     * <pre>\n+     *  b=(X' Omega^-1 X)^-1X'Omega^-1 y\n+     * </pre>\n+     * @return beta\n+     */\n+    @Override\n+    protected RealVector calculateBeta() {\n+        RealMatrix OI = getOmegaInverse();\n+        RealMatrix XT = X.transpose();\n+        RealMatrix XTOIX = XT.multiply(OI).multiply(X);\n+        RealMatrix inverse = new LUDecompositionImpl(XTOIX).getSolver().getInverse();\n+        return inverse.multiply(XT).multiply(OI).operate(Y);\n+    }\n+\n+    /**\n+     * Calculates the variance on the beta by GLS.\n+     * <pre>\n+     *  Var(b)=(X' Omega^-1 X)^-1\n+     * </pre>\n+     * @return The beta variance matrix\n+     */\n+    @Override\n+    protected RealMatrix calculateBetaVariance() {\n+        RealMatrix OI = getOmegaInverse();\n+        RealMatrix XTOIX = X.transpose().multiply(OI).multiply(X);\n+        return new LUDecompositionImpl(XTOIX).getSolver().getInverse();\n+    }\n+\n+    /**\n+     * Calculates the variance on the y by GLS.\n+     * <pre>\n+     *  Var(y)=Tr(u' Omega^-1 u)/(n-k)\n+     * </pre>\n+     * @return The Y variance\n+     */\n+    @Override\n+    protected double calculateYVariance() {\n+        RealVector residuals = calculateResiduals();\n+        double t = residuals.dotProduct(getOmegaInverse().operate(residuals));\n+        return t / (X.getRowDimension() - X.getColumnDimension());\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/regression/MultipleLinearRegression.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.regression;\n+\n+/**\n+ * The multiple linear regression can be represented in matrix-notation.\n+ * <pre>\n+ *  y=X*b+u\n+ * </pre>\n+ * where y is an <code>n-vector</code> <b>regressand</b>, X is a <code>[n,k]</code> matrix whose <code>k</code> columns are called\n+ * <b>regressors</b>, b is <code>k-vector</code> of <b>regression parameters</b> and <code>u</code> is an <code>n-vector</code>\n+ * of <b>error terms</b> or <b>residuals</b>.\n+ * \n+ * The notation is quite standard in literature, \n+ * cf eg <a href=\"http://www.econ.queensu.ca/ETM\">Davidson and MacKinnon, Econometrics Theory and Methods, 2004</a>.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface MultipleLinearRegression {\n+\n+    /**\n+     * Estimates the regression parameters b.\n+     * \n+     * @return The [k,1] array representing b\n+     */\n+    double[] estimateRegressionParameters();\n+\n+    /**\n+     * Estimates the variance of the regression parameters, ie Var(b).\n+     * \n+     * @return The [k,k] array representing the variance of b\n+     */\n+    double[][] estimateRegressionParametersVariance();\n+    \n+    /**\n+     * Estimates the residuals, ie u = y - X*b.\n+     * \n+     * @return The [n,1] array representing the residuals\n+     */\n+    double[] estimateResiduals();\n+\n+    /**\n+     * Returns the variance of the regressand, ie Var(y).\n+     * \n+     * @return The double representing the variance of y\n+     */\n+    double estimateRegressandVariance();\n+    \n+    /**\n+     * Returns the standard errors of the regression parameters.\n+     * \n+     * @return standard errors of estimated regression parameters\n+     */\n+     double[] estimateRegressionParametersStandardErrors();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.regression;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.QRDecomposition;\n+import org.apache.commons.math.linear.QRDecompositionImpl;\n+import org.apache.commons.math.linear.RealMatrix;\n+import org.apache.commons.math.linear.Array2DRowRealMatrix;\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.linear.ArrayRealVector;\n+\n+/**\n+ * <p>Implements ordinary least squares (OLS) to estimate the parameters of a \n+ * multiple linear regression model.</p>\n+ * \n+ * <p>OLS assumes the covariance matrix of the error to be diagonal and with\n+ * equal variance.</p>\n+ * <p>\n+ * u ~ N(0, &sigma;<sup>2</sup>I)\n+ * </p>\n+ * \n+ * <p>The regression coefficients, b, satisfy the normal equations:\n+ * <p>\n+ * X<sup>T</sup> X b = X<sup>T</sup> y\n+ * </p>\n+ * \n+ * <p>To solve the normal equations, this implementation uses QR decomposition\n+ * of the X matrix. (See {@link QRDecompositionImpl} for details on the\n+ * decomposition algorithm.)\n+ * </p>\n+ * <p>X<sup>T</sup>X b = X<sup>T</sup> y <br/>\n+ * (QR)<sup>T</sup> (QR) b = (QR)<sup>T</sup>y <br/>\n+ * R<sup>T</sup> (Q<sup>T</sup>Q) R b = R<sup>T</sup> Q<sup>T</sup> y <br/>\n+ * R<sup>T</sup> R b = R<sup>T</sup> Q<sup>T</sup> y <br/>\n+ * (R<sup>T</sup>)<sup>-1</sup> R<sup>T</sup> R b = (R<sup>T</sup>)<sup>-1</sup> R<sup>T</sup> Q<sup>T</sup> y <br/>\n+ * R b = Q<sup>T</sup> y\n+ * </p>\n+ * Given Q and R, the last equation is solved by back-subsitution.</p>\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class OLSMultipleLinearRegression extends AbstractMultipleLinearRegression {\n+    \n+    /** Cached QR decomposition of X matrix */\n+    private QRDecomposition qr = null;\n+\n+    /**\n+     * Loads model x and y sample data, overriding any previous sample.\n+     * \n+     * Computes and caches QR decomposition of the X matrix.\n+     * @param y the [n,1] array representing the y sample\n+     * @param x the [n,k] array representing the x sample\n+     * @throws IllegalArgumentException if the x and y array data are not\n+     *             compatible for the regression\n+     */\n+    public void newSampleData(double[] y, double[][] x) {\n+        validateSampleData(x, y);\n+        newYSampleData(y);\n+        newXSampleData(x);\n+    }\n+    \n+    /**\n+     * {@inheritDoc}\n+     * \n+     * Computes and caches QR decomposition of the X matrix\n+     */\n+    @Override\n+    public void newSampleData(double[] data, int nobs, int nvars) {\n+        super.newSampleData(data, nobs, nvars);\n+        qr = new QRDecompositionImpl(X);\n+    }\n+    \n+    /**\n+     * <p>Compute the \"hat\" matrix.\n+     * </p>\n+     * <p>The hat matrix is defined in terms of the design matrix X\n+     *  by X(X<sup>T</sup>X)<sup>-1</sup>X<sup>T</sup>\n+     * </p>\n+     * <p>The implementation here uses the QR decomposition to compute the\n+     * hat matrix as Q I<sub>p</sub>Q<sup>T</sup> where I<sub>p</sub> is the\n+     * p-dimensional identity matrix augmented by 0's.  This computational\n+     * formula is from \"The Hat Matrix in Regression and ANOVA\",\n+     * David C. Hoaglin and Roy E. Welsch, \n+     * <i>The American Statistician</i>, Vol. 32, No. 1 (Feb., 1978), pp. 17-22.\n+     * \n+     * @return the hat matrix\n+     */\n+    public RealMatrix calculateHat() {\n+        // Create augmented identity matrix\n+        RealMatrix Q = qr.getQ();\n+        final int p = qr.getR().getColumnDimension();\n+        final int n = Q.getColumnDimension();\n+        Array2DRowRealMatrix augI = new Array2DRowRealMatrix(n, n);\n+        double[][] augIData = augI.getDataRef();\n+        for (int i = 0; i < n; i++) {\n+            for (int j =0; j < n; j++) {\n+                if (i == j && i < p) {\n+                    augIData[i][j] = 1d;\n+                } else {\n+                    augIData[i][j] = 0d;\n+                }\n+            }\n+        }\n+        \n+        // Compute and return Hat matrix\n+        return Q.multiply(augI).multiply(Q.transpose());\n+    }\n+   \n+    /**\n+     * Loads new x sample data, overriding any previous sample\n+     * \n+     * @param x the [n,k] array representing the x sample\n+     */\n+    @Override\n+    protected void newXSampleData(double[][] x) {\n+        this.X = new Array2DRowRealMatrix(x);\n+        qr = new QRDecompositionImpl(X);\n+    }\n+    \n+    /**\n+     * Calculates regression coefficients using OLS.\n+     * \n+     * @return beta\n+     */\n+    @Override\n+    protected RealVector calculateBeta() {\n+        return solveUpperTriangular(qr.getR(), qr.getQ().transpose().operate(Y));\n+    }\n+\n+    /**\n+     * <p>Calculates the variance on the beta by OLS.\n+     * </p>\n+     * <p>Var(b) = (X<sup>T</sup>X)<sup>-1</sup>\n+     * </p>\n+     * <p>Uses QR decomposition to reduce (X<sup>T</sup>X)<sup>-1</sup>\n+     * to (R<sup>T</sup>R)<sup>-1</sup>, with only the top p rows of\n+     * R included, where p = the length of the beta vector.</p> \n+     * \n+     * @return The beta variance\n+     */\n+    @Override\n+    protected RealMatrix calculateBetaVariance() {\n+        int p = X.getColumnDimension();\n+        RealMatrix Raug = qr.getR().getSubMatrix(0, p - 1 , 0, p - 1);\n+        RealMatrix Rinv = new LUDecompositionImpl(Raug).getSolver().getInverse();\n+        return Rinv.multiply(Rinv.transpose());\n+    }\n+    \n+\n+    /**\n+     * <p>Calculates the variance on the Y by OLS.\n+     * </p>\n+     * <p> Var(y) = Tr(u<sup>T</sup>u)/(n - k)\n+     * </p>\n+     * @return The Y variance\n+     */\n+    @Override\n+    protected double calculateYVariance() {\n+        RealVector residuals = calculateResiduals();\n+        return residuals.dotProduct(residuals) /\n+               (X.getRowDimension() - X.getColumnDimension());\n+    }\n+    \n+    /** TODO:  Find a home for the following methods in the linear package */   \n+    \n+    /**\n+     * <p>Uses back substitution to solve the system</p>\n+     * \n+     * <p>coefficients X = constants</p>\n+     * \n+     * <p>coefficients must upper-triangular and constants must be a column \n+     * matrix.  The solution is returned as a column matrix.</p>\n+     * \n+     * <p>The number of columns in coefficients determines the length\n+     * of the returned solution vector (column matrix).  If constants\n+     * has more rows than coefficients has columns, excess rows are ignored.\n+     * Similarly, extra (zero) rows in coefficients are ignored</p>\n+     * \n+     * @param coefficients upper-triangular coefficients matrix\n+     * @param constants column RHS constants vector\n+     * @return solution matrix as a column vector\n+     * \n+     */\n+    private static RealVector solveUpperTriangular(RealMatrix coefficients,\n+                                                   RealVector constants) {\n+        checkUpperTriangular(coefficients, 1E-12);\n+        int length = coefficients.getColumnDimension();\n+        double x[] = new double[length];\n+        for (int i = 0; i < length; i++) {\n+            int index = length - 1 - i;\n+            double sum = 0;\n+            for (int j = index + 1; j < length; j++) {\n+                sum += coefficients.getEntry(index, j) * x[j];\n+            }\n+            x[index] = (constants.getEntry(index) - sum) / coefficients.getEntry(index, index);\n+        } \n+        return new ArrayRealVector(x);\n+    }\n+    \n+    /**\n+     * <p>Check if a matrix is upper-triangular.</p>\n+     * \n+     * <p>Makes sure all below-diagonal elements are within epsilon of 0.</p>\n+     * \n+     * @param m matrix to check\n+     * @param epsilon maximum allowable absolute value for elements below\n+     * the main diagonal\n+     * \n+     * @throws IllegalArgumentException if m is not upper-triangular\n+     */\n+    private static void checkUpperTriangular(RealMatrix m, double epsilon) {\n+        int nCols = m.getColumnDimension();\n+        int nRows = m.getRowDimension();\n+        for (int r = 0; r < nRows; r++) {\n+            int bound = Math.min(r, nCols);\n+            for (int c = 0; c < bound; c++) {\n+                if (Math.abs(m.getEntry(r, c)) > epsilon) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                          \"matrix is not upper-triangular, entry ({0}, {1}) = {2} is too large\",\n+                          r, c, m.getEntry(r, c));\n+                }\n+            }\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.regression;\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.distribution.TDistribution;\n+import org.apache.commons.math.distribution.TDistributionImpl;\n+\n+/**\n+ * Estimates an ordinary least squares regression model\n+ * with one independent variable.\n+ * <p>\n+ * <code> y = intercept + slope * x  </code></p>\n+ * <p>\n+ * Standard errors for <code>intercept</code> and <code>slope</code> are \n+ * available as well as ANOVA, r-square and Pearson's r statistics.</p>\n+ * <p>\n+ * Observations (x,y pairs) can be added to the model one at a time or they \n+ * can be provided in a 2-dimensional array.  The observations are not stored\n+ * in memory, so there is no limit to the number of observations that can be\n+ * added to the model.</p> \n+ * <p>\n+ * <strong>Usage Notes</strong>: <ul>\n+ * <li> When there are fewer than two observations in the model, or when\n+ * there is no variation in the x values (i.e. all x values are the same) \n+ * all statistics return <code>NaN</code>. At least two observations with\n+ * different x coordinates are requred to estimate a bivariate regression \n+ * model.\n+ * </li>\n+ * <li> getters for the statistics always compute values based on the current\n+ * set of observations -- i.e., you can get statistics, then add more data\n+ * and get updated statistics without using a new instance.  There is no \n+ * \"compute\" method that updates all statistics.  Each of the getters performs\n+ * the necessary computations to return the requested statistic.</li>\n+ * </ul></p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class SimpleRegression implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -3004689053607543335L;\n+\n+    /** the distribution used to compute inference statistics. */\n+    private TDistribution distribution;\n+    \n+    /** sum of x values */\n+    private double sumX = 0d;\n+\n+    /** total variation in x (sum of squared deviations from xbar) */\n+    private double sumXX = 0d;\n+\n+    /** sum of y values */\n+    private double sumY = 0d;\n+\n+    /** total variation in y (sum of squared deviations from ybar) */\n+    private double sumYY = 0d;\n+\n+    /** sum of products */\n+    private double sumXY = 0d;\n+\n+    /** number of observations */\n+    private long n = 0;\n+\n+    /** mean of accumulated x values, used in updating formulas */\n+    private double xbar = 0;\n+\n+    /** mean of accumulated y values, used in updating formulas */\n+    private double ybar = 0;\n+\n+    // ---------------------Public methods--------------------------------------\n+\n+    /**\n+     * Create an empty SimpleRegression instance\n+     */\n+    public SimpleRegression() {\n+        this(new TDistributionImpl(1.0));\n+    }\n+    \n+    /**\n+     * Create an empty SimpleRegression using the given distribution object to\n+     * compute inference statistics.\n+     * @param t the distribution used to compute inference statistics.\n+     * @since 1.2\n+     */\n+    public SimpleRegression(TDistribution t) {\n+        super();\n+        setDistribution(t);\n+    }\n+    \n+    /**\n+     * Adds the observation (x,y) to the regression data set.\n+     * <p>\n+     * Uses updating formulas for means and sums of squares defined in \n+     * \"Algorithms for Computing the Sample Variance: Analysis and\n+     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J. \n+     * 1983, American Statistician, vol. 37, pp. 242-247, referenced in\n+     * Weisberg, S. \"Applied Linear Regression\". 2nd Ed. 1985.</p>\n+     *\n+     *\n+     * @param x independent variable value\n+     * @param y dependent variable value\n+     */\n+    public void addData(double x, double y) {\n+        if (n == 0) {\n+            xbar = x;\n+            ybar = y;\n+        } else {\n+            double dx = x - xbar;\n+            double dy = y - ybar;\n+            sumXX += dx * dx * (double) n / (n + 1d);\n+            sumYY += dy * dy * (double) n / (n + 1d);\n+            sumXY += dx * dy * (double) n / (n + 1d);\n+            xbar += dx / (n + 1.0);\n+            ybar += dy / (n + 1.0);\n+        }\n+        sumX += x;\n+        sumY += y;\n+        n++;\n+        \n+        if (n > 2) {\n+            distribution.setDegreesOfFreedom(n - 2);\n+        }\n+    }\n+\n+    \n+    /**\n+     * Removes the observation (x,y) from the regression data set.\n+     * <p>\n+     * Mirrors the addData method.  This method permits the use of \n+     * SimpleRegression instances in streaming mode where the regression \n+     * is applied to a sliding \"window\" of observations, however the caller is \n+     * responsible for maintaining the set of observations in the window.</p>\n+     * \n+     * The method has no effect if there are no points of data (i.e. n=0)\n+     *\n+     * @param x independent variable value\n+     * @param y dependent variable value\n+     */\n+    public void removeData(double x, double y) {\n+        if (n > 0) {\n+            double dx = x - xbar;\n+            double dy = y - ybar;\n+            sumXX -= dx * dx * (double) n / (n - 1d);\n+            sumYY -= dy * dy * (double) n / (n - 1d);\n+            sumXY -= dx * dy * (double) n / (n - 1d);\n+            xbar -= dx / (n - 1.0);\n+            ybar -= dy / (n - 1.0);\n+            sumX -= x;\n+            sumY -= y;\n+            n--;\n+            \n+            if (n > 2) {\n+                distribution.setDegreesOfFreedom(n - 2);\n+            } \n+        }\n+    }\n+\n+    /**\n+     * Adds the observations represented by the elements in \n+     * <code>data</code>.\n+     * <p>\n+     * <code>(data[0][0],data[0][1])</code> will be the first observation, then\n+     * <code>(data[1][0],data[1][1])</code>, etc.</p>\n+     * <p> \n+     * This method does not replace data that has already been added.  The\n+     * observations represented by <code>data</code> are added to the existing\n+     * dataset.</p>\n+     * <p> \n+     * To replace all data, use <code>clear()</code> before adding the new \n+     * data.</p>\n+     * \n+     * @param data array of observations to be added\n+     */\n+    public void addData(double[][] data) {\n+        for (int i = 0; i < data.length; i++) {\n+            addData(data[i][0], data[i][1]);\n+        }\n+    }\n+\n+\n+    /**\n+     * Removes observations represented by the elements in <code>data</code>.\n+      * <p> \n+     * If the array is larger than the current n, only the first n elements are \n+     * processed.  This method permits the use of SimpleRegression instances in \n+     * streaming mode where the regression is applied to a sliding \"window\" of \n+     * observations, however the caller is responsible for maintaining the set \n+     * of observations in the window.</p>\n+     * <p> \n+     * To remove all data, use <code>clear()</code>.</p>\n+     * \n+     * @param data array of observations to be removed\n+     */\n+    public void removeData(double[][] data) {\n+        for (int i = 0; i < data.length && n > 0; i++) {\n+            removeData(data[i][0], data[i][1]);\n+        }\n+    }\n+\n+    /**\n+     * Clears all data from the model.\n+     */\n+    public void clear() {\n+        sumX = 0d;\n+        sumXX = 0d;\n+        sumY = 0d;\n+        sumYY = 0d;\n+        sumXY = 0d;\n+        n = 0;\n+    }\n+\n+    /**\n+     * Returns the number of observations that have been added to the model.\n+     *\n+     * @return n number of observations that have been added.\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+\n+    /**\n+     * Returns the \"predicted\" <code>y</code> value associated with the \n+     * supplied <code>x</code> value,  based on the data that has been\n+     * added to the model when this method is activated.\n+     * <p>\n+     * <code> predict(x) = intercept + slope * x </code></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>At least two observations (with at least two different x values)\n+     * must have been added before invoking this method. If this method is \n+     * invoked before a model can be estimated, <code>Double,NaN</code> is\n+     * returned.\n+     * </li></ul></p>\n+     *\n+     * @param x input <code>x</code> value\n+     * @return predicted <code>y</code> value\n+     */\n+    public double predict(double x) {\n+        double b1 = getSlope();\n+        return getIntercept(b1) + b1 * x;\n+    }\n+\n+    /**\n+     * Returns the intercept of the estimated regression line.\n+     * <p>\n+     * The least squares estimate of the intercept is computed using the \n+     * <a href=\"http://www.xycoon.com/estimation4.htm\">normal equations</a>.\n+     * The intercept is sometimes denoted b0.</p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>At least two observations (with at least two different x values)\n+     * must have been added before invoking this method. If this method is \n+     * invoked before a model can be estimated, <code>Double,NaN</code> is\n+     * returned.\n+     * </li></ul></p>\n+     *\n+     * @return the intercept of the regression line\n+     */\n+    public double getIntercept() {\n+        return getIntercept(getSlope());\n+    }\n+\n+    /**\n+    * Returns the slope of the estimated regression line.  \n+    * <p>\n+    * The least squares estimate of the slope is computed using the \n+    * <a href=\"http://www.xycoon.com/estimation4.htm\">normal equations</a>.\n+    * The slope is sometimes denoted b1.</p>\n+    * <p>\n+    * <strong>Preconditions</strong>: <ul>\n+    * <li>At least two observations (with at least two different x values)\n+    * must have been added before invoking this method. If this method is \n+    * invoked before a model can be estimated, <code>Double.NaN</code> is\n+    * returned.\n+    * </li></ul></p>\n+    *\n+    * @return the slope of the regression line\n+    */\n+    public double getSlope() {\n+        if (n < 2) {\n+            return Double.NaN; //not enough data \n+        }\n+        if (Math.abs(sumXX) < 10 * Double.MIN_VALUE) {\n+            return Double.NaN; //not enough variation in x\n+        }\n+        return sumXY / sumXX;\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://www.xycoon.com/SumOfSquares.htm\">\n+     * sum of squared errors</a> (SSE) associated with the regression \n+     * model.\n+     * <p>\n+     * The sum is computed using the computational formula</p>\n+     * <p>\n+     * <code>SSE = SYY - (SXY * SXY / SXX)</code></p>\n+     * <p>\n+     * where <code>SYY</code> is the sum of the squared deviations of the y\n+     * values about their mean, <code>SXX</code> is similarly defined and\n+     * <code>SXY</code> is the sum of the products of x and y mean deviations.\n+     * </p><p>\n+     * The sums are accumulated using the updating algorithm referenced in \n+     * {@link #addData}.</p>\n+     * <p>\n+     * The return value is constrained to be non-negative - i.e., if due to \n+     * rounding errors the computational formula returns a negative result, \n+     * 0 is returned.</p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>At least two observations (with at least two different x values)\n+     * must have been added before invoking this method. If this method is \n+     * invoked before a model can be estimated, <code>Double,NaN</code> is\n+     * returned.\n+     * </li></ul></p>\n+     *\n+     * @return sum of squared errors associated with the regression model\n+     */\n+    public double getSumSquaredErrors() {\n+        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);\n+    }\n+\n+    /**\n+     * Returns the sum of squared deviations of the y values about their mean.\n+     * <p>\n+     * This is defined as SSTO \n+     * <a href=\"http://www.xycoon.com/SumOfSquares.htm\">here</a>.</p>\n+     * <p>\n+     * If <code>n < 2</code>, this returns <code>Double.NaN</code>.</p>\n+     *\n+     * @return sum of squared deviations of y values\n+     */\n+    public double getTotalSumSquares() {\n+        if (n < 2) {\n+            return Double.NaN;\n+        }\n+        return sumYY;\n+    }\n+    \n+    /**\n+     * Returns the sum of squared deviations of the x values about their mean.\n+     *\n+     * If <code>n < 2</code>, this returns <code>Double.NaN</code>.</p>\n+     *\n+     * @return sum of squared deviations of x values\n+     */\n+    public double getXSumSquares() {\n+        if (n < 2) {\n+            return Double.NaN;\n+        }\n+        return sumXX;\n+    }\n+    \n+    /**\n+     * Returns the sum of crossproducts, x<sub>i</sub>*y<sub>i</sub>.\n+     *\n+     * @return sum of cross products\n+     */\n+    public double getSumOfCrossProducts() {\n+        return sumXY;\n+    }\n+\n+    /**\n+     * Returns the sum of squared deviations of the predicted y values about \n+     * their mean (which equals the mean of y).\n+     * <p>\n+     * This is usually abbreviated SSR or SSM.  It is defined as SSM \n+     * <a href=\"http://www.xycoon.com/SumOfSquares.htm\">here</a></p>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>At least two observations (with at least two different x values)\n+     * must have been added before invoking this method. If this method is \n+     * invoked before a model can be estimated, <code>Double.NaN</code> is\n+     * returned.\n+     * </li></ul></p>\n+     *\n+     * @return sum of squared deviations of predicted y values\n+     */\n+    public double getRegressionSumSquares() {\n+        return getRegressionSumSquares(getSlope());\n+    }\n+\n+    /**\n+     * Returns the sum of squared errors divided by the degrees of freedom,\n+     * usually abbreviated MSE. \n+     * <p>\n+     * If there are fewer than <strong>three</strong> data pairs in the model,\n+     * or if there is no variation in <code>x</code>, this returns \n+     * <code>Double.NaN</code>.</p>\n+     *\n+     * @return sum of squared deviations of y values\n+     */\n+    public double getMeanSquareError() {\n+        if (n < 3) {\n+            return Double.NaN;\n+        }\n+        return getSumSquaredErrors() / (n - 2);\n+    }\n+\n+    /**\n+     * Returns <a href=\"http://mathworld.wolfram.com/CorrelationCoefficient.html\">\n+     * Pearson's product moment correlation coefficient</a>,\n+     * usually denoted r. \n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>At least two observations (with at least two different x values)\n+     * must have been added before invoking this method. If this method is \n+     * invoked before a model can be estimated, <code>Double,NaN</code> is\n+     * returned.\n+     * </li></ul></p>\n+     *\n+     * @return Pearson's r\n+     */\n+    public double getR() {\n+        double b1 = getSlope();\n+        double result = Math.sqrt(getRSquare());\n+        if (b1 < 0) {\n+            result = -result;\n+        }\n+        return result;\n+    }\n+\n+    /** \n+     * Returns the <a href=\"http://www.xycoon.com/coefficient1.htm\"> \n+     * coefficient of determination</a>,\n+     * usually denoted r-square. \n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>At least two observations (with at least two different x values)\n+     * must have been added before invoking this method. If this method is \n+     * invoked before a model can be estimated, <code>Double,NaN</code> is\n+     * returned.\n+     * </li></ul></p>\n+     *\n+     * @return r-square\n+     */\n+    public double getRSquare() {\n+        double ssto = getTotalSumSquares();\n+        return (ssto - getSumSquaredErrors()) / ssto;\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://www.xycoon.com/standarderrorb0.htm\">\n+     * standard error of the intercept estimate</a>, \n+     * usually denoted s(b0). \n+     * <p>\n+     * If there are fewer that <strong>three</strong> observations in the \n+     * model, or if there is no variation in x, this returns \n+     * <code>Double.NaN</code>.</p>\n+     *\n+     * @return standard error associated with intercept estimate\n+     */\n+    public double getInterceptStdErr() {\n+        return Math.sqrt(\n+            getMeanSquareError() * ((1d / (double) n) + (xbar * xbar) / sumXX));\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://www.xycoon.com/standerrorb(1).htm\">standard\n+     * error of the slope estimate</a>,\n+     * usually denoted s(b1). \n+     * <p>\n+     * If there are fewer that <strong>three</strong> data pairs in the model,\n+     * or if there is no variation in x, this returns <code>Double.NaN</code>.\n+     * </p>\n+     * \n+     * @return standard error associated with slope estimate\n+     */\n+    public double getSlopeStdErr() {\n+        return Math.sqrt(getMeanSquareError() / sumXX);\n+    }\n+\n+    /**\n+     * Returns the half-width of a 95% confidence interval for the slope\n+     * estimate.\n+     * <p>\n+     * The 95% confidence interval is</p>\n+     * <p>\n+     * <code>(getSlope() - getSlopeConfidenceInterval(), \n+     * getSlope() + getSlopeConfidenceInterval())</code></p>\n+     * <p>\n+     * If there are fewer that <strong>three</strong> observations in the \n+     * model, or if there is no variation in x, this returns \n+     * <code>Double.NaN</code>.</p>\n+     * <p>\n+     * <strong>Usage Note</strong>:<br>\n+     * The validity of this statistic depends on the assumption that the \n+     * observations included in the model are drawn from a\n+     * <a href=\"http://mathworld.wolfram.com/BivariateNormalDistribution.html\">\n+     * Bivariate Normal Distribution</a>.</p>\n+     *\n+     * @return half-width of 95% confidence interval for the slope estimate\n+     * @throws MathException if the confidence interval can not be computed.\n+     */\n+    public double getSlopeConfidenceInterval() throws MathException {\n+        return getSlopeConfidenceInterval(0.05d);\n+    }\n+\n+    /**\n+     * Returns the half-width of a (100-100*alpha)% confidence interval for \n+     * the slope estimate.\n+     * <p>\n+     * The (100-100*alpha)% confidence interval is </p>\n+     * <p>\n+     * <code>(getSlope() - getSlopeConfidenceInterval(), \n+     * getSlope() + getSlopeConfidenceInterval())</code></p>\n+     * <p>\n+     * To request, for example, a 99% confidence interval, use \n+     * <code>alpha = .01</code></p>\n+     * <p>\n+     * <strong>Usage Note</strong>:<br>\n+     * The validity of this statistic depends on the assumption that the \n+     * observations included in the model are drawn from a\n+     * <a href=\"http://mathworld.wolfram.com/BivariateNormalDistribution.html\">\n+     * Bivariate Normal Distribution</a>.</p>\n+     * <p>\n+     * <strong> Preconditions:</strong><ul>\n+     * <li>If there are fewer that <strong>three</strong> observations in the \n+     * model, or if there is no variation in x, this returns \n+     * <code>Double.NaN</code>.\n+     * </li>\n+     * <li><code>(0 < alpha < 1)</code>; otherwise an \n+     * <code>IllegalArgumentException</code> is thrown.\n+     * </li></ul></p> \n+     *\n+     * @param alpha the desired significance level \n+     * @return half-width of 95% confidence interval for the slope estimate\n+     * @throws MathException if the confidence interval can not be computed.\n+     */\n+    public double getSlopeConfidenceInterval(double alpha)\n+        throws MathException {\n+        if (alpha >= 1 || alpha <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"out of bounds significance level {0}, must be between {1} and {2}\",\n+                  alpha, 0.0, 1.0);\n+        }\n+        return getSlopeStdErr() *\n+            distribution.inverseCumulativeProbability(1d - alpha / 2d);\n+    }\n+\n+    /**\n+     * Returns the significance level of the slope (equiv) correlation. \n+     * <p>\n+     * Specifically, the returned value is the smallest <code>alpha</code>\n+     * such that the slope confidence interval with significance level\n+     * equal to <code>alpha</code> does not include <code>0</code>.\n+     * On regression output, this is often denoted <code>Prob(|t| > 0)</code>\n+     * </p><p>\n+     * <strong>Usage Note</strong>:<br>\n+     * The validity of this statistic depends on the assumption that the \n+     * observations included in the model are drawn from a\n+     * <a href=\"http://mathworld.wolfram.com/BivariateNormalDistribution.html\">\n+     * Bivariate Normal Distribution</a>.</p>\n+     * <p>\n+     * If there are fewer that <strong>three</strong> observations in the \n+     * model, or if there is no variation in x, this returns \n+     * <code>Double.NaN</code>.</p>\n+     *\n+     * @return significance level for slope/correlation\n+     * @throws MathException if the significance level can not be computed.\n+     */\n+    public double getSignificance() throws MathException {\n+        return 2d * (1.0 - distribution.cumulativeProbability(\n+                    Math.abs(getSlope()) / getSlopeStdErr()));\n+    }\n+\n+    // ---------------------Private methods-----------------------------------\n+\n+    /**\n+    * Returns the intercept of the estimated regression line, given the slope.\n+    * <p>\n+    * Will return <code>NaN</code> if slope is <code>NaN</code>.</p>\n+    *\n+    * @param slope current slope\n+    * @return the intercept of the regression line\n+    */\n+    private double getIntercept(double slope) {\n+        return (sumY - slope * sumX) / n;\n+    }\n+\n+    /**\n+     * Computes SSR from b1.\n+     * \n+     * @param slope regression slope estimate\n+     * @return sum of squared deviations of predicted y values\n+     */\n+    private double getRegressionSumSquares(double slope) {\n+        return slope * slope * sumXX;\n+    }\n+    \n+    /**\n+     * Modify the distribution used to compute inference statistics.\n+     * @param value the new distribution\n+     * @since 1.2\n+     */\n+    public void setDistribution(TDistribution value) {\n+        distribution = value;\n+        \n+        // modify degrees of freedom\n+        if (n > 2) {\n+            distribution.setDegreesOfFreedom(n - 2);\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/transform/FastCosineTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.complex.Complex;\n+\n+/**\n+ * Implements the <a href=\"http://documents.wolfram.com/v5/Add-onsLinks/\n+ * StandardPackages/LinearAlgebra/FourierTrig.html\">Fast Cosine Transform</a>\n+ * for transformation of one-dimensional data sets. For reference, see\n+ * <b>Fast Fourier Transforms</b>, ISBN 0849371635, chapter 3.\n+ * <p>\n+ * FCT is its own inverse, up to a multiplier depending on conventions.\n+ * The equations are listed in the comments of the corresponding methods.</p>\n+ * <p>\n+ * Different from FFT and FST, FCT requires the length of data set to be\n+ * power of 2 plus one. Users should especially pay attention to the\n+ * function transformation on how this affects the sampling.</p>\n+ * <p>As of version 2.0 this no longer implements Serializable</p>\n+ *\n+ * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $\n+ * @since 1.2\n+ */\n+public class FastCosineTransformer implements RealTransformer {\n+\n+    /**\n+     * Construct a default transformer.\n+     */\n+    public FastCosineTransformer() {\n+        super();\n+    }\n+\n+    /**\n+     * Transform the given real data set.\n+     * <p>\n+     * The formula is F<sub>n</sub> = (1/2) [f<sub>0</sub> + (-1)<sup>n</sup> f<sub>N</sub>] +\n+     *                        &sum;<sub>k=1</sub><sup>N-1</sup> f<sub>k</sub> cos(&pi; nk/N)\n+     * </p>\n+     * \n+     * @param f the real data array to be transformed\n+     * @return the real transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform(double f[]) throws IllegalArgumentException {\n+        return fct(f);\n+    }\n+\n+    /**\n+     * Transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is F<sub>n</sub> = (1/2) [f<sub>0</sub> + (-1)<sup>n</sup> f<sub>N</sub>] +\n+     *                        &sum;<sub>k=1</sub><sup>N-1</sup> f<sub>k</sub> cos(&pi; nk/N)\n+     * </p>\n+     * \n+     * @param f the function to be sampled and transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real transformed array\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform(UnivariateRealFunction f,\n+                              double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n+        double data[] = FastFourierTransformer.sample(f, min, max, n);\n+        return fct(data);\n+    }\n+\n+    /**\n+     * Transform the given real data set.\n+     * <p>\n+     * The formula is F<sub>n</sub> = &radic;(1/2N) [f<sub>0</sub> + (-1)<sup>n</sup> f<sub>N</sub>] +\n+     *                        &radic;(2/N) &sum;<sub>k=1</sub><sup>N-1</sup> f<sub>k</sub> cos(&pi; nk/N)\n+     * </p>\n+     * \n+     * @param f the real data array to be transformed\n+     * @return the real transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform2(double f[]) throws IllegalArgumentException {\n+\n+        double scaling_coefficient = Math.sqrt(2.0 / (f.length-1));\n+        return FastFourierTransformer.scaleArray(fct(f), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is F<sub>n</sub> = &radic;(1/2N) [f<sub>0</sub> + (-1)<sup>n</sup> f<sub>N</sub>] +\n+     *                        &radic;(2/N) &sum;<sub>k=1</sub><sup>N-1</sup> f<sub>k</sub> cos(&pi; nk/N)\n+     *\n+     * </p>\n+     * \n+     * @param f the function to be sampled and transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real transformed array\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform2(UnivariateRealFunction f,\n+                               double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n+\n+        double data[] = FastFourierTransformer.sample(f, min, max, n);\n+        double scaling_coefficient = Math.sqrt(2.0 / (n-1));\n+        return FastFourierTransformer.scaleArray(fct(data), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real data set.\n+     * <p>\n+     * The formula is f<sub>k</sub> = (1/N) [F<sub>0</sub> + (-1)<sup>k</sup> F<sub>N</sub>] +\n+     *                        (2/N) &sum;<sub>n=1</sub><sup>N-1</sup> F<sub>n</sub> cos(&pi; nk/N)\n+     * </p>\n+     * \n+     * @param f the real data array to be inversely transformed\n+     * @return the real inversely transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform(double f[]) throws IllegalArgumentException {\n+\n+        double scaling_coefficient = 2.0 / (f.length - 1);\n+        return FastFourierTransformer.scaleArray(fct(f), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is f<sub>k</sub> = (1/N) [F<sub>0</sub> + (-1)<sup>k</sup> F<sub>N</sub>] +\n+     *                        (2/N) &sum;<sub>n=1</sub><sup>N-1</sup> F<sub>n</sub> cos(&pi; nk/N)\n+     * </p>\n+     * \n+     * @param f the function to be sampled and inversely transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real inversely transformed array\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform(UnivariateRealFunction f,\n+                                     double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n+\n+        double data[] = FastFourierTransformer.sample(f, min, max, n);\n+        double scaling_coefficient = 2.0 / (n - 1);\n+        return FastFourierTransformer.scaleArray(fct(data), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real data set.\n+     * <p>\n+     * The formula is f<sub>k</sub> = &radic;(1/2N) [F<sub>0</sub> + (-1)<sup>k</sup> F<sub>N</sub>] +\n+     *                        &radic;(2/N) &sum;<sub>n=1</sub><sup>N-1</sup> F<sub>n</sub> cos(&pi; nk/N)\n+     * </p>\n+     * \n+     * @param f the real data array to be inversely transformed\n+     * @return the real inversely transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform2(double f[]) throws IllegalArgumentException {\n+        return transform2(f);\n+    }\n+\n+    /**\n+     * Inversely transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is f<sub>k</sub> = &radic;(1/2N) [F<sub>0</sub> + (-1)<sup>k</sup> F<sub>N</sub>] +\n+     *                        &radic;(2/N) &sum;<sub>n=1</sub><sup>N-1</sup> F<sub>n</sub> cos(&pi; nk/N)\n+     * </p>\n+     * \n+     * @param f the function to be sampled and inversely transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real inversely transformed array\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform2(UnivariateRealFunction f,\n+                                      double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n+\n+        return transform2(f, min, max, n);\n+    }\n+\n+    /**\n+     * Perform the FCT algorithm (including inverse).\n+     *\n+     * @param f the real data array to be transformed\n+     * @return the real transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    protected double[] fct(double f[])\n+        throws IllegalArgumentException {\n+\n+        double A, B, C, F1, x[], F[] = new double[f.length];\n+\n+        int N = f.length - 1;\n+        if (!FastFourierTransformer.isPowerOf2(N)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0} is not a power of 2 plus one\",\n+                    f.length);\n+        }\n+        if (N == 1) {       // trivial case\n+            F[0] = 0.5 * (f[0] + f[1]);\n+            F[1] = 0.5 * (f[0] - f[1]);\n+            return F;\n+        }\n+\n+        // construct a new array and perform FFT on it\n+        x = new double[N];\n+        x[0] = 0.5 * (f[0] + f[N]);\n+        x[N >> 1] = f[N >> 1];\n+        F1 = 0.5 * (f[0] - f[N]);   // temporary variable for F[1]\n+        for (int i = 1; i < (N >> 1); i++) {\n+            A = 0.5 * (f[i] + f[N-i]);\n+            B = Math.sin(i * Math.PI / N) * (f[i] - f[N-i]);\n+            C = Math.cos(i * Math.PI / N) * (f[i] - f[N-i]);\n+            x[i] = A - B;\n+            x[N-i] = A + B;\n+            F1 += C;\n+        }\n+        FastFourierTransformer transformer = new FastFourierTransformer();\n+        Complex y[] = transformer.transform(x);\n+\n+        // reconstruct the FCT result for the original array\n+        F[0] = y[0].getReal();\n+        F[1] = F1;\n+        for (int i = 1; i < (N >> 1); i++) {\n+            F[2*i] = y[i].getReal();\n+            F[2*i+1] = F[2*i-1] - y[i].getImaginary();\n+        }\n+        F[N] = y[N >> 1].getReal();\n+\n+        return F;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/transform/FastFourierTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.complex.Complex;\n+\n+/**\n+ * Implements the <a href=\"http://mathworld.wolfram.com/FastFourierTransform.html\">\n+ * Fast Fourier Transform</a> for transformation of one-dimensional data sets.\n+ * For reference, see <b>Applied Numerical Linear Algebra</b>, ISBN 0898713897,\n+ * chapter 6.\n+ * <p>\n+ * There are several conventions for the definition of FFT and inverse FFT,\n+ * mainly on different coefficient and exponent. Here the equations are listed\n+ * in the comments of the corresponding methods.</p>\n+ * <p>\n+ * We require the length of data set to be power of 2, this greatly simplifies\n+ * and speeds up the code. Users can pad the data with zeros to meet this\n+ * requirement. There are other flavors of FFT, for reference, see S. Winograd,\n+ * <i>On computing the discrete Fourier transform</i>, Mathematics of Computation,\n+ * 32 (1978), 175 - 199.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class FastFourierTransformer implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    static final long serialVersionUID = 5138259215438106000L;\n+\n+    /** roots of unity */\n+    private RootsOfUnity roots = new RootsOfUnity();\n+\n+    /**\n+     * Construct a default transformer.\n+     */\n+    public FastFourierTransformer() {\n+        super();\n+    }\n+\n+    /**\n+     * Transform the given real data set.\n+     * <p>\n+     * The formula is $ y_n = \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k $\n+     * </p>\n+     * \n+     * @param f the real data array to be transformed\n+     * @return the complex transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] transform(double f[])\n+        throws IllegalArgumentException {\n+        return fft(f, false);\n+    }\n+\n+    /**\n+     * Transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is $ y_n = \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k $\n+     * </p>\n+     * \n+     * @param f the function to be sampled and transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the complex transformed array\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] transform(UnivariateRealFunction f,\n+                               double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n+        double data[] = sample(f, min, max, n);\n+        return fft(data, false);\n+    }\n+\n+    /**\n+     * Transform the given complex data set.\n+     * <p>\n+     * The formula is $ y_n = \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k $\n+     * </p>\n+     * \n+     * @param f the complex data array to be transformed\n+     * @return the complex transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] transform(Complex f[])\n+        throws IllegalArgumentException {\n+        roots.computeOmega(f.length);\n+        return fft(f);\n+    }\n+\n+    /**\n+     * Transform the given real data set.\n+     * <p>\n+     * The formula is $y_n = (1/\\sqrt{N}) \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k$\n+     * </p>\n+     * \n+     * @param f the real data array to be transformed\n+     * @return the complex transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] transform2(double f[])\n+        throws IllegalArgumentException {\n+\n+        double scaling_coefficient = 1.0 / Math.sqrt(f.length);\n+        return scaleArray(fft(f, false), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is $y_n = (1/\\sqrt{N}) \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k$\n+     * </p>\n+     * \n+     * @param f the function to be sampled and transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the complex transformed array\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] transform2(UnivariateRealFunction f,\n+                                double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n+\n+        double data[] = sample(f, min, max, n);\n+        double scaling_coefficient = 1.0 / Math.sqrt(n);\n+        return scaleArray(fft(data, false), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Transform the given complex data set.\n+     * <p>\n+     * The formula is $y_n = (1/\\sqrt{N}) \\Sigma_{k=0}^{N-1} e^{-2 \\pi i nk/N} x_k$\n+     * </p>\n+     * \n+     * @param f the complex data array to be transformed\n+     * @return the complex transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] transform2(Complex f[])\n+        throws IllegalArgumentException {\n+\n+        roots.computeOmega(f.length);\n+        double scaling_coefficient = 1.0 / Math.sqrt(f.length);\n+        return scaleArray(fft(f), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real data set.\n+     * <p>\n+     * The formula is $ x_k = (1/N) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n $\n+     * </p>\n+     * \n+     * @param f the real data array to be inversely transformed\n+     * @return the complex inversely transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] inversetransform(double f[])\n+        throws IllegalArgumentException {\n+\n+        double scaling_coefficient = 1.0 / f.length;\n+        return scaleArray(fft(f, true), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is $ x_k = (1/N) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n $\n+     * </p>\n+     * \n+     * @param f the function to be sampled and inversely transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the complex inversely transformed array\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] inversetransform(UnivariateRealFunction f,\n+                                      double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n+\n+        double data[] = sample(f, min, max, n);\n+        double scaling_coefficient = 1.0 / n;\n+        return scaleArray(fft(data, true), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given complex data set.\n+     * <p>\n+     * The formula is $ x_k = (1/N) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n $\n+     * </p>\n+     * \n+     * @param f the complex data array to be inversely transformed\n+     * @return the complex inversely transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] inversetransform(Complex f[])\n+        throws IllegalArgumentException {\n+\n+        roots.computeOmega(-f.length);    // pass negative argument\n+        double scaling_coefficient = 1.0 / f.length;\n+        return scaleArray(fft(f), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real data set.\n+     * <p>\n+     * The formula is $x_k = (1/\\sqrt{N}) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n$\n+     * </p>\n+     * \n+     * @param f the real data array to be inversely transformed\n+     * @return the complex inversely transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] inversetransform2(double f[])\n+        throws IllegalArgumentException {\n+\n+        double scaling_coefficient = 1.0 / Math.sqrt(f.length);\n+        return scaleArray(fft(f, true), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is $x_k = (1/\\sqrt{N}) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n$\n+     * </p>\n+     * \n+     * @param f the function to be sampled and inversely transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the complex inversely transformed array\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] inversetransform2(UnivariateRealFunction f,\n+                                       double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n+\n+        double data[] = sample(f, min, max, n);\n+        double scaling_coefficient = 1.0 / Math.sqrt(n);\n+        return scaleArray(fft(data, true), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given complex data set.\n+     * <p>\n+     * The formula is $x_k = (1/\\sqrt{N}) \\Sigma_{n=0}^{N-1} e^{2 \\pi i nk/N} y_n$\n+     * </p>\n+     * \n+     * @param f the complex data array to be inversely transformed\n+     * @return the complex inversely transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public Complex[] inversetransform2(Complex f[])\n+        throws IllegalArgumentException {\n+\n+        roots.computeOmega(-f.length);    // pass negative argument\n+        double scaling_coefficient = 1.0 / Math.sqrt(f.length);\n+        return scaleArray(fft(f), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Perform the base-4 Cooley-Tukey FFT algorithm (including inverse).\n+     *\n+     * @param f the real data array to be transformed\n+     * @param isInverse the indicator of forward or inverse transform\n+     * @return the complex transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    protected Complex[] fft(double f[], boolean isInverse)\n+        throws IllegalArgumentException {\n+\n+        verifyDataSet(f);\n+        Complex F[] = new Complex[f.length];\n+        if (f.length == 1) {\n+            F[0] = new Complex(f[0], 0.0);\n+            return F;\n+        }\n+\n+        // Rather than the naive real to complex conversion, pack 2N\n+        // real numbers into N complex numbers for better performance.\n+        int N = f.length >> 1;\n+        Complex c[] = new Complex[N];\n+        for (int i = 0; i < N; i++) {\n+            c[i] = new Complex(f[2*i], f[2*i+1]);\n+        }\n+        roots.computeOmega(isInverse ? -N : N);\n+        Complex z[] = fft(c);\n+\n+        // reconstruct the FFT result for the original array\n+        roots.computeOmega(isInverse ? -2*N : 2*N);\n+        F[0] = new Complex(2 * (z[0].getReal() + z[0].getImaginary()), 0.0);\n+        F[N] = new Complex(2 * (z[0].getReal() - z[0].getImaginary()), 0.0);\n+        for (int i = 1; i < N; i++) {\n+            Complex A = z[N-i].conjugate();\n+            Complex B = z[i].add(A);\n+            Complex C = z[i].subtract(A);\n+            //Complex D = roots.getOmega(i).multiply(Complex.I);\n+            Complex D = new Complex(-roots.getOmegaImaginary(i),\n+                                    roots.getOmegaReal(i));\n+            F[i] = B.subtract(C.multiply(D));\n+            F[2*N-i] = F[i].conjugate();\n+        }\n+\n+        return scaleArray(F, 0.5);\n+    }\n+\n+    /**\n+     * Perform the base-4 Cooley-Tukey FFT algorithm (including inverse).\n+     *\n+     * @param data the complex data array to be transformed\n+     * @return the complex transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    protected Complex[] fft(Complex data[])\n+        throws IllegalArgumentException {\n+\n+        int i, j, k, m, N = data.length;\n+        Complex A, B, C, D, E, F, z, f[] = new Complex[N];\n+\n+        // initial simple cases\n+        verifyDataSet(data);\n+        if (N == 1) {\n+            f[0] = data[0];\n+            return f;\n+        }\n+        if (N == 2) {\n+            f[0] = data[0].add(data[1]);\n+            f[1] = data[0].subtract(data[1]);\n+            return f;\n+        }\n+\n+        // permute original data array in bit-reversal order\n+        j = 0;\n+        for (i = 0; i < N; i++) {\n+            f[i] = data[j];\n+            k = N >> 1;\n+            while (j >= k && k > 0) {\n+                j -= k; k >>= 1;\n+            }\n+            j += k;\n+        }\n+\n+        // the bottom base-4 round\n+        for (i = 0; i < N; i += 4) {\n+            A = f[i].add(f[i+1]);\n+            B = f[i+2].add(f[i+3]);\n+            C = f[i].subtract(f[i+1]);\n+            D = f[i+2].subtract(f[i+3]);\n+            E = C.add(D.multiply(Complex.I));\n+            F = C.subtract(D.multiply(Complex.I));\n+            f[i] = A.add(B);\n+            f[i+2] = A.subtract(B);\n+            // omegaCount indicates forward or inverse transform\n+            f[i+1] = roots.isForward() ? F : E;\n+            f[i+3] = roots.isForward() ? E : F;\n+        }\n+\n+        // iterations from bottom to top take O(N*logN) time\n+        for (i = 4; i < N; i <<= 1) {\n+            m = N / (i<<1);\n+            for (j = 0; j < N; j += i<<1) {\n+                for (k = 0; k < i; k++) {\n+                    //z = f[i+j+k].multiply(roots.getOmega(k*m));\n+                    final int k_times_m = k*m;\n+                    final double omega_k_times_m_real = roots.getOmegaReal(k_times_m);\n+                    final double omega_k_times_m_imaginary = roots.getOmegaImaginary(k_times_m);\n+                    //z = f[i+j+k].multiply(omega[k*m]);\n+                    z = new Complex(\n+                        f[i+j+k].getReal() * omega_k_times_m_real -\n+                        f[i+j+k].getImaginary() * omega_k_times_m_imaginary,\n+                        f[i+j+k].getReal() * omega_k_times_m_imaginary +\n+                        f[i+j+k].getImaginary() * omega_k_times_m_real);\n+                  \n+                    f[i+j+k] = f[j+k].subtract(z);\n+                    f[j+k] = f[j+k].add(z);\n+                }\n+            }\n+        }\n+        return f;\n+    }\n+\n+    /**\n+     * Sample the given univariate real function on the given interval.\n+     * <p>\n+     * The interval is divided equally into N sections and sample points\n+     * are taken from min to max-(max-min)/N. Usually f(x) is periodic\n+     * such that f(min) = f(max) (note max is not sampled), but we don't\n+     * require that.</p>\n+     *\n+     * @param f the function to be sampled\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the samples array\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public static double[] sample(UnivariateRealFunction f,\n+                                  double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n+\n+        if (n <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"number of sample is not positive: {0}\",\n+                    n);\n+        }\n+        verifyInterval(min, max);\n+\n+        double s[] = new double[n];\n+        double h = (max - min) / n;\n+        for (int i = 0; i < n; i++) {\n+            s[i] = f.value(min + i * h);\n+        }\n+        return s;\n+    }\n+\n+    /**\n+     * Multiply every component in the given real array by the\n+     * given real number. The change is made in place.\n+     *\n+     * @param f the real array to be scaled\n+     * @param d the real scaling coefficient\n+     * @return a reference to the scaled array\n+     */\n+    public static double[] scaleArray(double f[], double d) {\n+        for (int i = 0; i < f.length; i++) {\n+            f[i] *= d;\n+        }\n+        return f;\n+    }\n+\n+    /**\n+     * Multiply every component in the given complex array by the\n+     * given real number. The change is made in place.\n+     *\n+     * @param f the complex array to be scaled\n+     * @param d the real scaling coefficient\n+     * @return a reference to the scaled array\n+     */\n+    public static Complex[] scaleArray(Complex f[], double d) {\n+        for (int i = 0; i < f.length; i++) {\n+            f[i] = new Complex(d * f[i].getReal(), d * f[i].getImaginary());\n+        }\n+        return f;\n+    }\n+\n+    /**\n+     * Returns true if the argument is power of 2.\n+     * \n+     * @param n the number to test\n+     * @return true if the argument is power of 2\n+     */\n+    public static boolean isPowerOf2(long n) {\n+        return (n > 0) && ((n & (n - 1)) == 0);\n+    }\n+\n+    /**\n+     * Verifies that the data set has length of power of 2.\n+     * \n+     * @param d the data array\n+     * @throws IllegalArgumentException if array length is not power of 2\n+     */\n+    public static void verifyDataSet(double d[]) throws IllegalArgumentException {\n+        if (!isPowerOf2(d.length)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0} is not a power of 2, consider padding for fix\",\n+                    d.length);\n+        }       \n+    }\n+\n+    /**\n+     * Verifies that the data set has length of power of 2.\n+     * \n+     * @param o the data array\n+     * @throws IllegalArgumentException if array length is not power of 2\n+     */\n+    public static void verifyDataSet(Object o[]) throws IllegalArgumentException {\n+        if (!isPowerOf2(o.length)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0} is not a power of 2, consider padding for fix\",\n+                    o.length);\n+        }       \n+    }\n+\n+    /**\n+     * Verifies that the endpoints specify an interval.\n+     * \n+     * @param lower lower endpoint\n+     * @param upper upper endpoint\n+     * @throws IllegalArgumentException if not interval\n+     */\n+    public static void verifyInterval(double lower, double upper)\n+        throws IllegalArgumentException {\n+\n+        if (lower >= upper) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"endpoints do not specify an interval: [{0}, {1}]\",\n+                    lower, upper);\n+        }       \n+    }\n+    \n+    /**\n+     * Performs a multi-dimensional Fourier transform on a given array.\n+     * Use {@link #inversetransform2(Complex[])} and\n+     * {@link #transform2(Complex[])} in a row-column implementation\n+     * in any number of dimensions with O(N&times;log(N)) complexity with\n+     * N=n<sub>1</sub>&times;n<sub>2</sub>&times;n<sub>3</sub>&times;...&times;n<sub>d</sub>,\n+     * n<sub>x</sub>=number of elements in dimension x,\n+     * and d=total number of dimensions.\n+     *\n+     * @param mdca Multi-Dimensional Complex Array id est Complex[][][][]\n+     * @param forward inverseTransform2 is preformed if this is false\n+     * @return transform of mdca as a Multi-Dimensional Complex Array id est Complex[][][][]\n+     * @throws IllegalArgumentException if any dimension is not a power of two\n+     */\n+    public Object mdfft(Object mdca, boolean forward)\n+        throws IllegalArgumentException {\n+        MultiDimensionalComplexMatrix mdcm = (MultiDimensionalComplexMatrix)\n+                new MultiDimensionalComplexMatrix(mdca).clone();\n+        int[] dimensionSize = mdcm.getDimensionSizes();\n+        //cycle through each dimension\n+        for (int i = 0; i < dimensionSize.length; i++) {\n+            mdfft(mdcm, forward, i, new int[0]);\n+        }\n+        return mdcm.getArray();\n+    }\n+    \n+    /**\n+     * Performs one dimension of a multi-dimensional Fourier transform.\n+     *\n+     * @param mdcm input matrix\n+     * @param forward inverseTransform2 is preformed if this is false\n+     * @param d index of the dimension to process\n+     * @param subVector recursion subvector\n+     * @throws IllegalArgumentException if any dimension is not a power of two\n+     */\n+    private void mdfft(MultiDimensionalComplexMatrix mdcm, boolean forward,\n+                       int d, int[] subVector)\n+        throws IllegalArgumentException {\n+        int[] dimensionSize = mdcm.getDimensionSizes();\n+        //if done\n+        if (subVector.length == dimensionSize.length) {\n+            Complex[] temp = new Complex[dimensionSize[d]];\n+            for (int i = 0; i < dimensionSize[d]; i++) {\n+                //fft along dimension d\n+                subVector[d] = i;\n+                temp[i] = mdcm.get(subVector);\n+            }\n+            \n+            if (forward)\n+                temp = transform2(temp);\n+            else\n+                temp = inversetransform2(temp);\n+            \n+            for (int i = 0; i < dimensionSize[d]; i++) {\n+                subVector[d] = i;\n+                mdcm.set(temp[i], subVector);\n+            }\n+        } else {\n+            int[] vector = new int[subVector.length + 1];\n+            System.arraycopy(subVector, 0, vector, 0, subVector.length);\n+            if (subVector.length == d) {\n+                //value is not important once the recursion is done.\n+                //then an fft will be applied along the dimension d.\n+                vector[d] = 0;\n+                mdfft(mdcm, forward, d, vector);\n+            } else {\n+                for (int i = 0; i < dimensionSize[subVector.length]; i++) {\n+                    vector[subVector.length] = i;\n+                    //further split along the next dimension\n+                    mdfft(mdcm, forward, d, vector);\n+                }\n+            }\n+        }\n+        return;\n+    }\n+\n+    /**\n+     * Complex matrix implementation.\n+     * Not designed for synchronized access\n+     * may eventually be replaced by jsr-83 of the java community process\n+     * http://jcp.org/en/jsr/detail?id=83\n+     * may require additional exception throws for other basic requirements.\n+     */\n+    private static class MultiDimensionalComplexMatrix\n+        implements Cloneable {\n+\n+        /** Size in all dimensions. */\n+        protected int[] dimensionSize;\n+\n+        /** Storage array. */\n+        protected Object multiDimensionalComplexArray;\n+\n+        /** Simple constructor.\n+         * @param multiDimensionalComplexArray array containing the matrix elements\n+         */\n+        public MultiDimensionalComplexMatrix(Object multiDimensionalComplexArray) {\n+\n+            this.multiDimensionalComplexArray = multiDimensionalComplexArray;\n+\n+            // count dimensions\n+            int numOfDimensions = 0;\n+            for (Object lastDimension = multiDimensionalComplexArray;\n+                 lastDimension instanceof Object[];) {\n+                final Object[] array = (Object[]) lastDimension;\n+                numOfDimensions++;\n+                lastDimension = array[0];\n+            }\n+\n+            // allocate array with exact count\n+            dimensionSize = new int[numOfDimensions];\n+\n+            // fill array\n+            numOfDimensions = 0;\n+            for (Object lastDimension = multiDimensionalComplexArray;\n+                 lastDimension instanceof Object[];) {\n+                final Object[] array = (Object[]) lastDimension;\n+                dimensionSize[numOfDimensions++] = array.length;\n+                lastDimension = array[0];\n+            }\n+\n+        }\n+\n+        /**\n+         * Get a matrix element.\n+         * @param vector indices of the element\n+         * @return matrix element\n+         * @exception IllegalArgumentException if dimensions do not match\n+         */\n+        public Complex get(int... vector)\n+            throws IllegalArgumentException {\n+            if (vector == null) {\n+                if (dimensionSize.length > 0) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"some dimensions don't match: {0} != {1}\",\n+                            0, dimensionSize.length);\n+                }\n+                return null;\n+            }\n+            if (vector.length != dimensionSize.length) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some dimensions don't match: {0} != {1}\",\n+                        vector.length, dimensionSize.length);\n+            }\n+            \n+            Object lastDimension = multiDimensionalComplexArray;\n+            \n+            for (int i = 0; i < dimensionSize.length; i++) {\n+                lastDimension = ((Object[]) lastDimension)[vector[i]];\n+            }\n+            return (Complex) lastDimension;\n+        }\n+        \n+        /**\n+         * Set a matrix element.\n+         * @param magnitude magnitude of the element\n+         * @param vector indices of the element\n+         * @return the previous value\n+         * @exception IllegalArgumentException if dimensions do not match\n+         */\n+        public Complex set(Complex magnitude, int... vector)\n+            throws IllegalArgumentException {\n+            if (vector == null) {\n+                if (dimensionSize.length > 0) {\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                            \"some dimensions don't match: {0} != {1}\",\n+                            0, dimensionSize.length);\n+                }\n+                return null;\n+            }\n+            if (vector.length != dimensionSize.length) {\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                        \"some dimensions don't match: {0} != {1}\",\n+                        vector.length,dimensionSize.length);\n+            }\n+\n+            Object[] lastDimension = (Object[]) multiDimensionalComplexArray;\n+            for (int i = 0; i < dimensionSize.length - 1; i++) {\n+                lastDimension = (Object[]) lastDimension[vector[i]];\n+            }\n+\n+            Complex lastValue = (Complex) lastDimension[vector[dimensionSize.length - 1]];\n+            lastDimension[vector[dimensionSize.length - 1]] = magnitude;\n+\n+            return lastValue;\n+        }\n+\n+        /**\n+         * Get the size in all dimensions.\n+         * @return size in all dimensions\n+         */\n+        public int[] getDimensionSizes() {\n+            return dimensionSize.clone();\n+        }\n+\n+        /**\n+         * Get the underlying storage array\n+         * @return underlying storage array\n+         */\n+        public Object getArray() {\n+            return multiDimensionalComplexArray;\n+        }\n+\n+        /** {@inheritDoc} */\n+        @Override\n+        public Object clone() {\n+            MultiDimensionalComplexMatrix mdcm =\n+                    new MultiDimensionalComplexMatrix(Array.newInstance(\n+                    Complex.class, dimensionSize));\n+            clone(mdcm);\n+            return mdcm;\n+        }\n+        \n+        /**\n+         * Copy contents of current array into mdcm.\n+         * @param mdcm array where to copy data\n+         */\n+        private void clone(MultiDimensionalComplexMatrix mdcm) {\n+            int[] vector = new int[dimensionSize.length];\n+            int size = 1;\n+            for (int i = 0; i < dimensionSize.length; i++) {\n+                size *= dimensionSize[i];\n+            }\n+            int[][] vectorList = new int[size][dimensionSize.length];\n+            for (int[] nextVector: vectorList) {\n+                System.arraycopy(vector, 0, nextVector, 0,\n+                                 dimensionSize.length);\n+                for (int i = 0; i < dimensionSize.length; i++) {\n+                    vector[i]++;\n+                    if (vector[i] < dimensionSize[i]) {\n+                        break;\n+                    } else {\n+                        vector[i] = 0;\n+                    }\n+                }\n+            }\n+            \n+            for (int[] nextVector: vectorList) {\n+                mdcm.set(get(nextVector), nextVector);\n+            }\n+        }\n+    }\n+    \n+    \n+    /** Computes the n<sup>th</sup> roots of unity. \n+     * A cache of already computed values is maintained.\n+     */\n+    private static class RootsOfUnity implements Serializable {\n+\n+      /** Serializable version id. */\n+      private static final long serialVersionUID = 6404784357747329667L;\n+\n+      /** Number of roots of unity. */\n+      private int      omegaCount;\n+\n+      /** Real part of the roots. */\n+      private double[] omegaReal;\n+\n+      /** Imaginary part of the roots for forward transform. */\n+      private double[] omegaImaginaryForward;\n+\n+      /** Imaginary part of the roots for reverse transform. */\n+      private double[] omegaImaginaryInverse;\n+\n+      /** Forward/reverse indicator. */\n+      private boolean  isForward;\n+\n+      /**\n+       * Build an engine for computing then <sup>th</sup> roots of unity\n+       */\n+      public RootsOfUnity() {\n+        \n+        omegaCount = 0;\n+        omegaReal = null;\n+        omegaImaginaryForward = null;\n+        omegaImaginaryInverse = null;\n+        isForward = true;\n+        \n+      }\n+\n+      /**\n+       * Check if computation has been done for forward or reverse transform.\n+       * @return true if computation has been done for forward transform\n+       * @throws IllegalStateException if no roots of unity have been computed yet\n+       */\n+      public synchronized boolean isForward() throws IllegalStateException {\n+          \n+        if (omegaCount == 0) {\n+          throw MathRuntimeException.createIllegalStateException(\n+                  \"roots of unity have not been computed yet\");\n+        }        \n+        return isForward;\n+        \n+      }\n+      \n+      /** Computes the n<sup>th</sup> roots of unity.\n+       * <p>The computed omega[] = { 1, w, w<sup>2</sup>, ... w<sup>(n-1)</sup> } where\n+       * w = exp(-2 &pi; i / n), i = &sqrt;(-1).</p>\n+       * <p>Note that n is positive for\n+       * forward transform and negative for inverse transform.</p>\n+       * @param n number of roots of unity to compute,\n+       * positive for forward transform, negative for inverse transform\n+       * @throws IllegalArgumentException if n = 0\n+       */\n+      public synchronized void computeOmega(int n) throws IllegalArgumentException {\n+\n+        if (n == 0) {\n+          throw MathRuntimeException.createIllegalArgumentException(\n+                  \"cannot compute 0-th root of unity, indefinite result\");\n+        }\n+\n+        isForward = (n > 0);\n+        \n+        // avoid repetitive calculations\n+        final int absN = Math.abs(n);\n+        \n+        if (absN == omegaCount) {\n+            return;\n+        }\n+\n+        // calculate everything from scratch, for both forward and inverse versions\n+        final double t    = 2.0 * Math.PI / absN;\n+        final double cosT = Math.cos(t);\n+        final double sinT = Math.sin(t);\n+        omegaReal             = new double[absN];\n+        omegaImaginaryForward = new double[absN];\n+        omegaImaginaryInverse = new double[absN];\n+        omegaReal[0]             = 1.0;\n+        omegaImaginaryForward[0] = 0.0;\n+        omegaImaginaryInverse[0] = 0.0;\n+        for (int i = 1; i < absN; i++) {\n+          omegaReal[i] =\n+            omegaReal[i-1] * cosT + omegaImaginaryForward[i-1] * sinT;\n+          omegaImaginaryForward[i] =\n+             omegaImaginaryForward[i-1] * cosT - omegaReal[i-1] * sinT;\n+          omegaImaginaryInverse[i] = -omegaImaginaryForward[i];\n+        }\n+        omegaCount = absN;\n+\n+      }\n+\n+      /**\n+       * Get the real part of the k<sup>th</sup> n<sup>th</sup> root of unity\n+       * @param k index of the n<sup>th</sup> root of unity\n+       * @return real part of the k<sup>th</sup> n<sup>th</sup> root of unity\n+       * @throws IllegalStateException if no roots of unity have been computed yet\n+       * @throws IllegalArgumentException if k is out of range\n+       */\n+      public synchronized double getOmegaReal(int k)\n+        throws IllegalStateException, IllegalArgumentException {\n+        \n+        if (omegaCount == 0) {\n+            throw MathRuntimeException.createIllegalStateException(\n+                    \"roots of unity have not been computed yet\");\n+        }\n+        if ((k < 0) || (k >= omegaCount)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"out of range root of unity index {0} (must be in [{1};{2}])\",\n+                    k, 0, omegaCount - 1);\n+        }\n+        \n+        return omegaReal[k];\n+        \n+      }\n+\n+      /**\n+       * Get the imaginary part of the k<sup>th</sup> n<sup>th</sup> root of unity\n+       * @param k index of the n<sup>th</sup> root of unity\n+       * @return imaginary part of the k<sup>th</sup> n<sup>th</sup> root of unity\n+       * @throws IllegalStateException if no roots of unity have been computed yet\n+       * @throws IllegalArgumentException if k is out of range\n+       */\n+      public synchronized double getOmegaImaginary(int k)\n+        throws IllegalStateException, IllegalArgumentException {\n+      \n+        if (omegaCount == 0) {\n+            throw MathRuntimeException.createIllegalStateException(\n+                    \"roots of unity have not been computed yet\");\n+        }\n+        if ((k < 0) || (k >= omegaCount)) {\n+          throw MathRuntimeException.createIllegalArgumentException(\n+                  \"out of range root of unity index {0} (must be in [{1};{2}])\",\n+                  k, 0, omegaCount - 1);\n+        }\n+\n+        return (isForward) ?\n+            omegaImaginaryForward[k] : omegaImaginaryInverse[k];\n+        \n+      }\n+\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/transform/FastHadamardTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Implements the <a href=\"http://www.archive.chipcenter.com/dsp/DSP000517F1.html\">Fast Hadamard Transform</a> (FHT).\n+ * Transformation of an input vector x to the output vector y.\n+ * <p>In addition to transformation of real vectors, the Hadamard transform can\n+ * transform integer vectors into integer vectors. However, this integer transform\n+ * cannot be inverted directly. Due to a scaling factor it may lead to rational results.\n+ * As an example, the inverse transform of integer vector (0, 1, 0, 1) is rational\n+ * vector (1/2, -1/2, 0, 0).</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class FastHadamardTransformer implements RealTransformer {\n+\n+    /** {@inheritDoc} */\n+    public double[] transform(double f[])\n+        throws IllegalArgumentException {\n+        return fht(f);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] transform(UnivariateRealFunction f,\n+                              double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n+        return fht(FastFourierTransformer.sample(f, min, max, n));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double[] inversetransform(double f[])\n+    throws IllegalArgumentException {\n+        return FastFourierTransformer.scaleArray(fht(f), 1.0 / f.length);\n+   }\n+\n+    /** {@inheritDoc} */\n+    public double[] inversetransform(UnivariateRealFunction f,\n+                                     double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n+        final double[] unscaled =\n+            fht(FastFourierTransformer.sample(f, min, max, n));\n+        return FastFourierTransformer.scaleArray(unscaled, 1.0 / n);\n+    }\n+\n+    /**\n+     * Transform the given real data set.\n+     * <p>The integer transform cannot be inverted directly, due to a scaling\n+     * factor it may lead to double results.</p>\n+     * @param f the integer data array to be transformed (signal)\n+     * @return the integer transformed array (spectrum)\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public int[] transform(int f[])\n+        throws IllegalArgumentException {\n+        return fht(f);\n+    }\n+\n+    /**\n+     * The FHT (Fast Hadamard Transformation) which uses only subtraction and addition.\n+     * <br>\n+     * Requires <b>Nlog2N = n2</b><sup>n</sup> additions.\n+     * <br>\n+     * <br>\n+     * <b><u>Short Table of manual calculation for N=8:</u></b>\n+     * <ol>\n+     * <li><b>x</b> is the input vector we want to transform</li>\n+     * <li><b>y</b> is the output vector which is our desired result</li>\n+     * <li>a and b are just helper rows</li>\n+     * </ol>\n+     * <pre>\n+     * <code>\n+     * +----+----------+---------+----------+\n+     * | <b>x</b>  |    <b>a</b>     |    <b>b</b>    |    <b>y</b>     |\n+     * +----+----------+---------+----------+\n+     * | x<sub>0</sub> | a<sub>0</sub>=x<sub>0</sub>+x<sub>1</sub> | b<sub>0</sub>=a<sub>0</sub>+a<sub>1</sub> | y<sub>0</sub>=b<sub>0</sub>+b<sub>1</sub> |\n+     * +----+----------+---------+----------+\n+     * | x<sub>1</sub> | a<sub>1</sub>=x<sub>2</sub>+x<sub>3</sub> | b<sub>0</sub>=a<sub>2</sub>+a<sub>3</sub> | y<sub>0</sub>=b<sub>2</sub>+b<sub>3</sub> |\n+     * +----+----------+---------+----------+\n+     * | x<sub>2</sub> | a<sub>2</sub>=x<sub>4</sub>+x<sub>5</sub> | b<sub>0</sub>=a<sub>4</sub>+a<sub>5</sub> | y<sub>0</sub>=b<sub>4</sub>+b<sub>5</sub> |\n+     * +----+----------+---------+----------+\n+     * | x<sub>3</sub> | a<sub>3</sub>=x<sub>6</sub>+x<sub>7</sub> | b<sub>0</sub>=a<sub>6</sub>+a<sub>7</sub> | y<sub>0</sub>=b<sub>6</sub>+b<sub>7</sub> |\n+     * +----+----------+---------+----------+\n+     * | x<sub>4</sub> | a<sub>0</sub>=x<sub>0</sub>-x<sub>1</sub> | b<sub>0</sub>=a<sub>0</sub>-a<sub>1</sub> | y<sub>0</sub>=b<sub>0</sub>-b<sub>1</sub> |\n+     * +----+----------+---------+----------+\n+     * | x<sub>5</sub> | a<sub>1</sub>=x<sub>2</sub>-x<sub>3</sub> | b<sub>0</sub>=a<sub>2</sub>-a<sub>3</sub> | y<sub>0</sub>=b<sub>2</sub>-b<sub>3</sub> |\n+     * +----+----------+---------+----------+\n+     * | x<sub>6</sub> | a<sub>2</sub>=x<sub>4</sub>-x<sub>5</sub> | b<sub>0</sub>=a<sub>4</sub>-a<sub>5</sub> | y<sub>0</sub>=b<sub>4</sub>-b<sub>5</sub> |\n+     * +----+----------+---------+----------+\n+     * | x<sub>7</sub> | a<sub>3</sub>=x<sub>6</sub>-x<sub>7</sub> | b<sub>0</sub>=a<sub>6</sub>-a<sub>7</sub> | y<sub>0</sub>=b<sub>6</sub>-b<sub>7</sub> |\n+     * +----+----------+---------+----------+\n+     * </code>\n+     * </pre>\n+     * \n+     * <b><u>How it works</u></b>\n+     * <ol>\n+     * <li>Construct a matrix with N rows and n+1 columns<br>   <b>hadm[n+1][N]</b> \n+     * <br><i>(If I use [x][y] it always means [row-offset][column-offset] of a Matrix with n rows and m columns. Its entries go from M[0][0] to M[n][m])</i></li>\n+     * <li>Place the input vector <b>x[N]</b> in the first column of the matrix <b>hadm</b></li>\n+     * <li>The entries of the submatrix D<sub>top</sub> are calculated as follows.\n+     * <br>D<sub>top</sub> goes from entry [0][1] to [N/2-1][n+1].\n+     * <br>The columns of D<sub>top</sub> are the pairwise mutually exclusive sums of the previous column \n+     * </li>\n+     * <li>The entries of the submatrix D<sub>bottom</sub> are calculated as follows.\n+     * <br>D<sub>bottom</sub> goes from entry [N/2][1] to [N][n+1].\n+     * <br>The columns of D<sub>bottom</sub> are the pairwise differences of the previous column \n+     * </li>\n+     * <li>How D<sub>top</sub> and D<sub>bottom</sub> you can understand best with the example for N=8 above.\n+     * <li>The output vector y is now in the last column of <b>hadm</b></li>\n+     * <li><i>Algorithm from: http://www.archive.chipcenter.com/dsp/DSP000517F1.html</i></li>    \n+     * </ol>\n+     * <br>\n+     * <b><u>Visually</u></b>\n+     * <pre>\n+     *        +--------+---+---+---+-----+---+\n+     *        |   0    | 1 | 2 | 3 | ... |n+1|\n+     * +------+--------+---+---+---+-----+---+\n+     * |0     | x<sub>0</sub>     |       /\\            |\n+     * |1     | x<sub>1</sub>     |       ||            |\n+     * |2     | x<sub>2</sub>     |   <= D<sub>top</sub>  =>       |\n+     * |...   | ...    |       ||            |\n+     * |N/2-1 | x<sub>N/2-1</sub>  |       \\/            |\n+     * +------+--------+---+---+---+-----+---+\n+     * |N/2   | x<sub>N/2</sub>   |       /\\            |\n+     * |N/2+1 | x<sub>N/2+1</sub>  |       ||            |\n+     * |N/2+2 | x<sub>N/2+2</sub>  |  <= D<sub>bottom</sub>  =>      | which is in the last column of the matrix\n+     * |...   | ...    |       ||            |\n+     * |N     | x<sub>N/2</sub>   |        \\/           |\n+     * +------+--------+---+---+---+-----+---+\n+     * </pre>\n+     * \n+     * @param x input vector\n+     * @return y output vector\n+     * @exception IllegalArgumentException if input array is not a power of 2\n+     */\n+    protected double[] fht(double x[]) throws IllegalArgumentException {\n+\n+        // n is the row count of the input vector x\n+        final int n     = x.length;\n+        final int halfN = n / 2;\n+\n+        // n has to be of the form n = 2^p !!\n+        if (!FastFourierTransformer.isPowerOf2(n)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0} is not a power of 2\",\n+                    n);\n+        }\n+\n+        // Instead of creating a matrix with p+1 columns and n rows\n+        // we will use two single dimension arrays which we will use in an alternating way.\n+        double[] yPrevious = new double[n];\n+        double[] yCurrent  = x.clone();\n+\n+        // iterate from left to right (column)\n+        for (int j = 1; j < n; j <<= 1) {\n+\n+            // switch columns\n+            final double[] yTmp = yCurrent;\n+            yCurrent  = yPrevious;\n+            yPrevious = yTmp;\n+\n+            // iterate from top to bottom (row)\n+            for (int i = 0; i < halfN; ++i) { \n+                // D<sub>top</sub>\n+                // The top part works with addition\n+                final int twoI = 2 * i;\n+                yCurrent[i] = yPrevious[twoI] + yPrevious[twoI + 1];\n+            }\n+            for (int i = halfN; i < n; ++i) { \n+                // D<sub>bottom</sub>   \n+                // The bottom part works with subtraction\n+                final int twoI = 2 * i;\n+                yCurrent[i] = yPrevious[twoI - n] - yPrevious[twoI - n + 1];\n+            }\n+        }\n+\n+        // return the last computed output vector y\n+        return yCurrent;\n+\n+    }\n+    /**\n+     * The FHT (Fast Hadamard Transformation) which uses only subtraction and addition.\n+     * @param x input vector\n+     * @return y output vector\n+     * @exception IllegalArgumentException if input array is not a power of 2\n+     */\n+    protected int[] fht(int x[]) throws IllegalArgumentException {\n+\n+        // n is the row count of the input vector x\n+        final int n     = x.length;\n+        final int halfN = n / 2;\n+\n+        // n has to be of the form n = 2^p !!\n+        if (!FastFourierTransformer.isPowerOf2(n)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0} is not a power of 2\",\n+                    n);\n+        }\n+\n+        // Instead of creating a matrix with p+1 columns and n rows\n+        // we will use two single dimension arrays which we will use in an alternating way.\n+        int[] yPrevious = new int[n];\n+        int[] yCurrent  = x.clone();\n+\n+        // iterate from left to right (column)\n+        for (int j = 1; j < n; j <<= 1) {\n+\n+            // switch columns\n+            final int[] yTmp = yCurrent;\n+            yCurrent  = yPrevious;\n+            yPrevious = yTmp;\n+\n+            // iterate from top to bottom (row)\n+            for (int i = 0; i < halfN; ++i) { \n+                // D<sub>top</sub>\n+                // The top part works with addition\n+                final int twoI = 2 * i;\n+                yCurrent[i] = yPrevious[twoI] + yPrevious[twoI + 1];\n+            }\n+            for (int i = halfN; i < n; ++i) { \n+                // D<sub>bottom</sub>   \n+                // The bottom part works with subtraction\n+                final int twoI = 2 * i;\n+                yCurrent[i] = yPrevious[twoI - n] - yPrevious[twoI - n + 1];\n+            }\n+        }\n+\n+        // return the last computed output vector y\n+        return yCurrent;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/transform/FastSineTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+import org.apache.commons.math.analysis.*;\n+import org.apache.commons.math.complex.*;\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Implements the <a href=\"http://documents.wolfram.com/v5/Add-onsLinks/\n+ * StandardPackages/LinearAlgebra/FourierTrig.html\">Fast Sine Transform</a>\n+ * for transformation of one-dimensional data sets. For reference, see\n+ * <b>Fast Fourier Transforms</b>, ISBN 0849371635, chapter 3.\n+ * <p>\n+ * FST is its own inverse, up to a multiplier depending on conventions.\n+ * The equations are listed in the comments of the corresponding methods.</p>\n+ * <p>\n+ * Similar to FFT, we also require the length of data set to be power of 2.\n+ * In addition, the first element must be 0 and it's enforced in function\n+ * transformation after sampling.</p>\n+ * <p>As of version 2.0 this no longer implements Serializable</p>\n+ * \n+ * @version $Revision$ $Date$\n+ * @since 1.2\n+ */\n+public class FastSineTransformer implements RealTransformer {\n+\n+    /**\n+     * Construct a default transformer.\n+     */\n+    public FastSineTransformer() {\n+        super();\n+    }\n+\n+    /**\n+     * Transform the given real data set.\n+     * <p>\n+     * The formula is F<sub>n</sub> = &sum;<sub>k=0</sub><sup>N-1</sup> f<sub>k</sub> sin(&pi; nk/N)\n+     * </p>\n+     * \n+     * @param f the real data array to be transformed\n+     * @return the real transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform(double f[])\n+        throws IllegalArgumentException {\n+        return fst(f);\n+    }\n+\n+    /**\n+     * Transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is F<sub>n</sub> = &sum;<sub>k=0</sub><sup>N-1</sup> f<sub>k</sub> sin(&pi; nk/N)\n+     * </p>\n+     * \n+     * @param f the function to be sampled and transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real transformed array\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform(UnivariateRealFunction f,\n+                              double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n+\n+        double data[] = FastFourierTransformer.sample(f, min, max, n);\n+        data[0] = 0.0;\n+        return fst(data);\n+    }\n+\n+    /**\n+     * Transform the given real data set.\n+     * <p>\n+     * The formula is F<sub>n</sub> = &radic;(2/N) &sum;<sub>k=0</sub><sup>N-1</sup> f<sub>k</sub> sin(&pi; nk/N)\n+     * </p>\n+     * \n+     * @param f the real data array to be transformed\n+     * @return the real transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform2(double f[]) throws IllegalArgumentException {\n+\n+        double scaling_coefficient = Math.sqrt(2.0 / f.length);\n+        return FastFourierTransformer.scaleArray(fst(f), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is F<sub>n</sub> = &radic;(2/N) &sum;<sub>k=0</sub><sup>N-1</sup> f<sub>k</sub> sin(&pi; nk/N)\n+     * </p>\n+     * \n+     * @param f the function to be sampled and transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real transformed array\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] transform2(\n+        UnivariateRealFunction f, double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n+\n+        double data[] = FastFourierTransformer.sample(f, min, max, n);\n+        data[0] = 0.0;\n+        double scaling_coefficient = Math.sqrt(2.0 / n);\n+        return FastFourierTransformer.scaleArray(fst(data), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real data set.\n+     * <p>\n+     * The formula is f<sub>k</sub> = (2/N) &sum;<sub>n=0</sub><sup>N-1</sup> F<sub>n</sub> sin(&pi; nk/N)\n+     * </p>\n+     * \n+     * @param f the real data array to be inversely transformed\n+     * @return the real inversely transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform(double f[]) throws IllegalArgumentException {\n+\n+        double scaling_coefficient = 2.0 / f.length;\n+        return FastFourierTransformer.scaleArray(fst(f), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is f<sub>k</sub> = (2/N) &sum;<sub>n=0</sub><sup>N-1</sup> F<sub>n</sub> sin(&pi; nk/N)\n+     * </p>\n+     * \n+     * @param f the function to be sampled and inversely transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real inversely transformed array\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform(UnivariateRealFunction f, double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n+\n+        double data[] = FastFourierTransformer.sample(f, min, max, n);\n+        data[0] = 0.0;\n+        double scaling_coefficient = 2.0 / n;\n+        return FastFourierTransformer.scaleArray(fst(data), scaling_coefficient);\n+    }\n+\n+    /**\n+     * Inversely transform the given real data set.\n+     * <p>\n+     * The formula is f<sub>k</sub> = &radic;(2/N) &sum;<sub>n=0</sub><sup>N-1</sup> F<sub>n</sub> sin(&pi; nk/N)\n+     * </p>\n+     * \n+     * @param f the real data array to be inversely transformed\n+     * @return the real inversely transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform2(double f[]) throws IllegalArgumentException {\n+\n+        return transform2(f);\n+    }\n+\n+    /**\n+     * Inversely transform the given real function, sampled on the given interval.\n+     * <p>\n+     * The formula is f<sub>k</sub> = &radic;(2/N) &sum;<sub>n=0</sub><sup>N-1</sup> F<sub>n</sub> sin(&pi; nk/N)\n+     * </p>\n+     * \n+     * @param f the function to be sampled and inversely transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real inversely transformed array\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public double[] inversetransform2(UnivariateRealFunction f, double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException {\n+\n+        return transform2(f, min, max, n);\n+    }\n+\n+    /**\n+     * Perform the FST algorithm (including inverse).\n+     *\n+     * @param f the real data array to be transformed\n+     * @return the real transformed array\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    protected double[] fst(double f[]) throws IllegalArgumentException {\n+\n+        double A, B, x[], F[] = new double[f.length];\n+\n+        FastFourierTransformer.verifyDataSet(f);\n+        if (f[0] != 0.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"first element is not 0: {0}\",\n+                    f[0]);\n+        }\n+        int N = f.length;\n+        if (N == 1) {       // trivial case\n+            F[0] = 0.0;\n+            return F;\n+        }\n+\n+        // construct a new array and perform FFT on it\n+        x = new double[N];\n+        x[0] = 0.0;\n+        x[N >> 1] = 2.0 * f[N >> 1];\n+        for (int i = 1; i < (N >> 1); i++) {\n+            A = Math.sin(i * Math.PI / N) * (f[i] + f[N-i]);\n+            B = 0.5 * (f[i] - f[N-i]);\n+            x[i] = A + B;\n+            x[N-i] = A - B;\n+        }\n+        FastFourierTransformer transformer = new FastFourierTransformer();\n+        Complex y[] = transformer.transform(x);\n+\n+        // reconstruct the FST result for the original array\n+        F[0] = 0.0;\n+        F[1] = 0.5 * y[0].getReal();\n+        for (int i = 1; i < (N >> 1); i++) {\n+            F[2*i] = -y[i].getImaginary();\n+            F[2*i+1] = y[i].getReal() + F[2*i-1];\n+        }\n+\n+        return F;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/transform/RealTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.transform;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.complex.Complex;\n+\n+/**\n+ * Interface for one-dimensional data sets transformations producing real results.\n+ * <p>Such transforms include {@link FastSineTransformer sine transform},\n+ * {@link FastCosineTransformer cosine transform} or {@link\n+ * FastHadamardTransformer Hadamard transform}. {@link FastFourierTransformer\n+ * Fourier transform} is of a different kind and does not implement this\n+ * interface since it produces {@link Complex complex} results instead of real\n+ * ones.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface RealTransformer  {\n+\n+    /**\n+     * Transform the given real data set.\n+     * @param f the real data array to be transformed (signal)\n+     * @return the real transformed array (spectrum)\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    double[] transform(double f[])\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Transform the given real function, sampled on the given interval.\n+     * @param f the function to be sampled and transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real transformed array\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    double[] transform(UnivariateRealFunction f, double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException;\n+\n+    /**\n+     * Inversely transform the given real data set.\n+     * @param f the real data array to be inversely transformed (spectrum)\n+     * @return the real inversely transformed array (signal)\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    public abstract double[] inversetransform(double f[])\n+        throws IllegalArgumentException;\n+\n+    /**\n+     * Inversely transform the given real function, sampled on the given interval.\n+     * @param f the function to be sampled and inversely transformed\n+     * @param min the lower bound for the interval\n+     * @param max the upper bound for the interval\n+     * @param n the number of sample points\n+     * @return the real inversely transformed array\n+     * @throws FunctionEvaluationException if function cannot be evaluated\n+     * at some point\n+     * @throws IllegalArgumentException if any parameters are invalid\n+     */\n+    double[] inversetransform(UnivariateRealFunction f, double min, double max, int n)\n+        throws FunctionEvaluationException, IllegalArgumentException;\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/BigReal.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+\n+import java.io.Serializable;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.math.MathContext;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+\n+/**\n+ * Arbitrary precision decimal number.\n+ * <p>\n+ * This class is a simple wrapper around the standard <code>BigDecimal</code>\n+ * in order to implement the {@link FieldElement} interface.\n+ * </p>\n+ * @since 2.0\n+ * @version $Revision$ $Date$\n+ */\n+public class BigReal implements FieldElement<BigReal>, Comparable<BigReal>, Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 7887631840434052850L;\n+\n+    /** A big real representing 0. */\n+    public static final BigReal ZERO = new BigReal(BigDecimal.ZERO);\n+\n+    /** A big real representing 1. */\n+    public static final BigReal ONE = new BigReal(BigDecimal.ONE);\n+\n+    /** Underlying BigDecimal. */\n+    private final BigDecimal d;\n+\n+    /** Build an instance from a BigDecimal.\n+     * @param val value of the instance\n+     */\n+    public BigReal(BigDecimal val) {\n+        d =  val;\n+    }\n+\n+    /** Build an instance from a BigInteger.\n+     * @param val value of the instance\n+     */\n+    public BigReal(BigInteger val) {\n+        d = new BigDecimal(val);\n+    }\n+\n+    /** Build an instance from an unscaled BigInteger.\n+     * @param unscaledVal unscaled value\n+     * @param scale scale to use\n+     */\n+    public BigReal(BigInteger unscaledVal, int scale) {\n+        d = new BigDecimal(unscaledVal, scale);\n+    }\n+\n+    /** Build an instance from an unscaled BigInteger.\n+     * @param unscaledVal unscaled value\n+     * @param scale scale to use\n+     * @param mc to used\n+     */\n+    public BigReal(BigInteger unscaledVal, int scale, MathContext mc) {\n+        d = new BigDecimal(unscaledVal, scale, mc);\n+    }\n+\n+    /** Build an instance from a BigInteger.\n+     * @param val value of the instance\n+     * @param mc context to use\n+     */\n+    public BigReal(BigInteger val, MathContext mc) {\n+        d = new BigDecimal(val, mc);\n+    }\n+\n+    /** Build an instance from a characters representation.\n+     * @param in character representation of the value\n+     */\n+    public BigReal(char[] in) {\n+        d = new BigDecimal(in);\n+    }\n+\n+    /** Build an instance from a characters representation.\n+     * @param in character representation of the value\n+     * @param offset offset of the first character to analyze\n+     * @param len length of the array slice to analyze\n+     */\n+    public BigReal(char[] in, int offset, int len) {\n+        d = new BigDecimal(in, offset, len);\n+    }\n+\n+    /** Build an instance from a characters representation.\n+     * @param in character representation of the value\n+     * @param offset offset of the first character to analyze\n+     * @param len length of the array slice to analyze\n+     * @param mc context to use\n+     */\n+    public BigReal(char[] in, int offset, int len, MathContext mc) {\n+        d = new BigDecimal(in, offset, len, mc);\n+    }\n+\n+    /** Build an instance from a characters representation.\n+     * @param in character representation of the value\n+     * @param mc context to use\n+     */\n+    public BigReal(char[] in, MathContext mc) {\n+        d = new BigDecimal(in, mc);\n+    }\n+\n+    /** Build an instance from a double.\n+     * @param val value of the instance\n+     */\n+    public BigReal(double val) {\n+        d = new BigDecimal(val);\n+    }\n+\n+    /** Build an instance from a double.\n+     * @param val value of the instance\n+     * @param mc context to use\n+     */\n+    public BigReal(double val, MathContext mc) {\n+        d = new BigDecimal(val, mc);\n+    }\n+\n+    /** Build an instance from an int.\n+     * @param val value of the instance\n+     */\n+    public BigReal(int val) {\n+        d = new BigDecimal(val);\n+    }\n+\n+    /** Build an instance from an int.\n+     * @param val value of the instance\n+     * @param mc context to use\n+     */\n+    public BigReal(int val, MathContext mc) {\n+        d = new BigDecimal(val, mc);\n+    }\n+\n+    /** Build an instance from a long.\n+     * @param val value of the instance\n+     */\n+    public BigReal(long val) {\n+        d = new BigDecimal(val);\n+    }\n+\n+    /** Build an instance from a long.\n+     * @param val value of the instance\n+     * @param mc context to use\n+     */\n+    public BigReal(long val, MathContext mc) {\n+        d = new BigDecimal(val, mc);\n+    }\n+\n+    /** Build an instance from a String representation.\n+     * @param val character representation of the value\n+     */\n+    public BigReal(String val) {\n+        d = new BigDecimal(val);\n+    }\n+\n+    /** Build an instance from a String representation.\n+     * @param val character representation of the value\n+     * @param mc context to use\n+     */\n+    public BigReal(String val, MathContext mc)  {\n+        d = new BigDecimal(val, mc);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public BigReal add(BigReal a) {\n+        return new BigReal(d.add(a.d));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public BigReal subtract(BigReal a) {\n+        return new BigReal(d.subtract(a.d));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public BigReal divide(BigReal a) throws ArithmeticException {\n+        return new BigReal(d.divide(a.d));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public BigReal multiply(BigReal a) {\n+        return new BigReal(d.multiply(a.d));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int compareTo(BigReal a) {\n+        return d.compareTo(a.d);\n+    }\n+\n+    /** Get the double value corresponding to the instance.\n+     * @return double value corresponding to the instance\n+     */\n+    public double doubleValue() {\n+        return d.doubleValue();\n+    }\n+\n+    /** Get the BigDecimal value corresponding to the instance.\n+     * @return BigDecimal value corresponding to the instance\n+     */\n+    public BigDecimal bigDecimalValue() {\n+        return d;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public boolean equals(Object other) {\n+        try {\n+            if (other == null) {\n+                return false;\n+            }\n+            return d.equals(((BigReal) other).d);\n+        } catch (ClassCastException cce) {\n+            return false;\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int hashCode() {\n+        return d.hashCode();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Field<BigReal> getField() {\n+        return BigRealField.getInstance();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/BigRealField.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.util;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.Field;\n+\n+/**\n+ * Representation of real numbers with arbitrary precision field.\n+ * <p>\n+ * This class is a singleton.\n+ * </p>\n+ * @see BigReal\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class BigRealField implements Field<BigReal>, Serializable  {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 4756431066541037559L;\n+\n+    /** Private constructor for the singleton.\n+     */\n+    private BigRealField() {\n+    }\n+\n+    /** Get the unique instance.\n+     * @return the unique instance\n+     */\n+    public static BigRealField getInstance() {\n+        return LazyHolder.INSTANCE;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public BigReal getOne() {\n+        return BigReal.ONE;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public BigReal getZero() {\n+        return BigReal.ZERO;\n+    }\n+\n+    /** Holder for the instance.\n+     * <p>We use here the Initialization On Demand Holder Idiom.</p>\n+     */\n+    private static class LazyHolder {\n+        /** Cached field instance. */\n+        private static final BigRealField INSTANCE = new BigRealField();\n+    }\n+\n+    /** Handle deserialization of the singleton.\n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        // return the singleton instance\n+        return LazyHolder.INSTANCE; \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/CompositeFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import java.text.FieldPosition;\n+import java.text.Format;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+/**\n+ * Base class for formatters of composite objects (complex numbers, vectors ...).\n+ *\n+ * @author Apache Software Foundation\n+ * @version $Revision$ $Date$\n+ */\n+public abstract class CompositeFormat extends Format {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 5358685519349262494L;\n+\n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getInstance()} with the only customizing that the\n+     * maximum number of fraction digits is set to 2.  \n+     * @return the default number format.\n+     */\n+    protected static NumberFormat getDefaultNumberFormat() {\n+        return getDefaultNumberFormat(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Create a default number format.  The default number format is based on\n+     * {@link NumberFormat#getInstance(java.util.Locale)} with the only\n+     * customizing that the maximum number of fraction digits is set to 2.  \n+     * @param locale the specific locale used by the format.\n+     * @return the default number format specific to the given locale.\n+     */\n+    protected static NumberFormat getDefaultNumberFormat(final Locale locale) {\n+        final NumberFormat nf = NumberFormat.getInstance(locale);\n+        nf.setMaximumFractionDigits(2);\n+        return nf;\n+    }\n+\n+    /**\n+     * Parses <code>source</code> until a non-whitespace character is found.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.  On output, <code>pos</code>\n+     *        holds the index of the next non-whitespace character.\n+     */\n+    protected void parseAndIgnoreWhitespace(final String source,\n+                                            final ParsePosition pos) {\n+        parseNextCharacter(source, pos);\n+        pos.setIndex(pos.getIndex() - 1);\n+    }\n+\n+    /**\n+     * Parses <code>source</code> until a non-whitespace character is found.\n+     *\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the first non-whitespace character.\n+     */\n+    protected char parseNextCharacter(final String source,\n+                                      final ParsePosition pos) {\n+         int index = pos.getIndex();\n+         final int n = source.length();\n+         char ret = 0;\n+    \n+         if (index < n) {\n+             char c;\n+             do {\n+                 c = source.charAt(index++);\n+             } while (Character.isWhitespace(c) && index < n);\n+             pos.setIndex(index);\n+         \n+             if (index < n) {\n+                 ret = c;\n+             }\n+         }\n+         \n+         return ret;\n+    }\n+\n+    /**\n+     * Parses <code>source</code> for special double values.  These values\n+     * include Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n+     *\n+     * @param source the string to parse\n+     * @param value the special value to parse.\n+     * @param pos input/ouput parsing parameter.\n+     * @return the special number.\n+     */\n+    private Number parseNumber(final String source, final double value,\n+                               final ParsePosition pos) {\n+        Number ret = null;\n+        \n+        StringBuffer sb = new StringBuffer();\n+        sb.append('(');\n+        sb.append(value);\n+        sb.append(')');\n+        \n+        final int n = sb.length();\n+        final int startIndex = pos.getIndex();\n+        final int endIndex = startIndex + n;\n+        if (endIndex < source.length()) {\n+            if (source.substring(startIndex, endIndex).compareTo(sb.toString()) == 0) {\n+                ret = Double.valueOf(value);\n+                pos.setIndex(endIndex);\n+            }\n+        }\n+        \n+        return ret;\n+    }\n+\n+    /**\n+     * Parses <code>source</code> for a number.  This method can parse normal,\n+     * numeric values as well as special values.  These special values include\n+     * Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY.\n+     *\n+     * @param source the string to parse\n+     * @param format the number format used to parse normal, numeric values.\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed number.\n+     */\n+    protected Number parseNumber(final String source, final NumberFormat format,\n+                                 final ParsePosition pos) {\n+        final int startIndex = pos.getIndex();\n+        Number number = format.parse(source, pos);\n+        final int endIndex = pos.getIndex();\n+        \n+        // check for error parsing number\n+        if (startIndex == endIndex) {\n+            // try parsing special numbers\n+            final double[] special = {\n+                Double.NaN, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY\n+            };\n+            for (int i = 0; i < special.length; ++i) {\n+                number = parseNumber(source, special[i], pos);\n+                if (number != null) {\n+                    break;\n+                }\n+            }\n+        }\n+        \n+        return number;\n+    }\n+\n+    /**\n+     * Parse <code>source</code> for an expected fixed string.\n+     * @param source the string to parse\n+     * @param expected expected string\n+     * @param pos input/ouput parsing parameter.\n+     * @return true if the expected string was there\n+     */\n+    protected boolean parseFixedstring(final String source, final String expected,\n+                                       final ParsePosition pos) {\n+\n+        final int startIndex = pos.getIndex();\n+        final int endIndex = startIndex + expected.length();\n+        if ((startIndex >= source.length()) ||\n+            (endIndex > source.length()) ||\n+            (source.substring(startIndex, endIndex).compareTo(expected) != 0)) {\n+            // set index back to start, error index should be the start index\n+            pos.setIndex(startIndex);\n+            pos.setErrorIndex(startIndex);\n+            return false;\n+        }\n+\n+        // the string was here\n+        pos.setIndex(endIndex);\n+        return true;\n+\n+    }\n+\n+    /**\n+     * Formats a double value to produce a string.  In general, the value is\n+     * formatted using the formatting rules of <code>format</code>.  There are\n+     * three exceptions to this:\n+     * <ol>\n+     * <li>NaN is formatted as '(NaN)'</li>\n+     * <li>Positive infinity is formatted as '(Infinity)'</li>\n+     * <li>Negative infinity is formatted as '(-Infinity)'</li>\n+     * </ol>\n+     *\n+     * @param value the double to format.\n+     * @param format the format used.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    protected StringBuffer formatDouble(final double value, final NumberFormat format,\n+                                        final StringBuffer toAppendTo,\n+                                        final FieldPosition pos) {\n+        if( Double.isNaN(value) || Double.isInfinite(value) ) {\n+            toAppendTo.append('(');\n+            toAppendTo.append(value);\n+            toAppendTo.append(')');\n+        } else {\n+            format.format(value, toAppendTo, pos);\n+        }\n+        return toAppendTo;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/ContinuedFraction.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+\n+/**\n+ * Provides a generic means to evaluate continued fractions.  Subclasses simply\n+ * provided the a and b coefficients to evaluate the continued fraction.\n+ *\n+ * <p>\n+ * References:\n+ * <ul>\n+ * <li><a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n+ * Continued Fraction</a></li>\n+ * </ul>\n+ * </p>\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public abstract class ContinuedFraction {\n+    \n+    /** Maximum allowed numerical error. */\n+    private static final double DEFAULT_EPSILON = 10e-9;\n+\n+    /**\n+     * Default constructor.\n+     */\n+    protected ContinuedFraction() {\n+        super();\n+    }\n+\n+    /**\n+     * Access the n-th a coefficient of the continued fraction.  Since a can be\n+     * a function of the evaluation point, x, that is passed in as well.\n+     * @param n the coefficient index to retrieve.\n+     * @param x the evaluation point.\n+     * @return the n-th a coefficient.\n+     */\n+    protected abstract double getA(int n, double x);\n+\n+    /**\n+     * Access the n-th b coefficient of the continued fraction.  Since b can be\n+     * a function of the evaluation point, x, that is passed in as well.\n+     * @param n the coefficient index to retrieve.\n+     * @param x the evaluation point.\n+     * @return the n-th b coefficient.\n+     */\n+    protected abstract double getB(int n, double x);\n+\n+    /**\n+     * Evaluates the continued fraction at the value x.\n+     * @param x the evaluation point.\n+     * @return the value of the continued fraction evaluated at x. \n+     * @throws MathException if the algorithm fails to converge.\n+     */\n+    public double evaluate(double x) throws MathException {\n+        return evaluate(x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Evaluates the continued fraction at the value x.\n+     * @param x the evaluation point.\n+     * @param epsilon maximum error allowed.\n+     * @return the value of the continued fraction evaluated at x. \n+     * @throws MathException if the algorithm fails to converge.\n+     */\n+    public double evaluate(double x, double epsilon) throws MathException {\n+        return evaluate(x, epsilon, Integer.MAX_VALUE);\n+    }\n+\n+    /**\n+     * Evaluates the continued fraction at the value x.\n+     * @param x the evaluation point.\n+     * @param maxIterations maximum number of convergents\n+     * @return the value of the continued fraction evaluated at x. \n+     * @throws MathException if the algorithm fails to converge.\n+     */\n+    public double evaluate(double x, int maxIterations) throws MathException {\n+        return evaluate(x, DEFAULT_EPSILON, maxIterations);\n+    }\n+\n+    /**\n+     * <p>\n+     * Evaluates the continued fraction at the value x.\n+     * </p>\n+     * \n+     * <p>\n+     * The implementation of this method is based on equations 14-17 of:\n+     * <ul>\n+     * <li>\n+     *   Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web\n+     *   Resource. <a target=\"_blank\"\n+     *   href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n+     *   http://mathworld.wolfram.com/ContinuedFraction.html</a>\n+     * </li>\n+     * </ul>\n+     * The recurrence relationship defined in those equations can result in\n+     * very large intermediate results which can result in numerical overflow.\n+     * As a means to combat these overflow conditions, the intermediate results\n+     * are scaled whenever they threaten to become numerically unstable.</p>\n+     *   \n+     * @param x the evaluation point.\n+     * @param epsilon maximum error allowed.\n+     * @param maxIterations maximum number of convergents\n+     * @return the value of the continued fraction evaluated at x. \n+     * @throws MathException if the algorithm fails to converge.\n+     */\n+    public double evaluate(double x, double epsilon, int maxIterations)\n+        throws MathException\n+    {\n+        double p0 = 1.0;\n+        double p1 = getA(0, x);\n+        double q0 = 0.0;\n+        double q1 = 1.0;\n+        double c = p1 / q1;\n+        int n = 0;\n+        double relativeError = Double.MAX_VALUE;\n+        while (n < maxIterations && relativeError > epsilon) {\n+            ++n;\n+            double a = getA(n, x);\n+            double b = getB(n, x);\n+            double p2 = a * p1 + b * p0;\n+            double q2 = a * q1 + b * q0;\n+            if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n+                // need to scale\n+                if (a != 0.0) {\n+                    p2 = p1 + (b / a * p0);\n+                    q2 = q1 + (b / a * q0);\n+                } else if (b != 0) {\n+                    p2 = (a / b * p1) + p0;\n+                    q2 = (a / b * q1) + q0;\n+                } else {\n+                    // can not scale an convergent is unbounded.\n+                    throw new ConvergenceException(\n+                        \"Continued fraction convergents diverged to +/- infinity for value {0}\",\n+                        x);\n+                }\n+            }\n+            double r = p2 / q2;\n+            relativeError = Math.abs(r / c - 1.0);\n+                \n+            // prepare for next iteration\n+            c = p2 / q2;\n+            p0 = p1;\n+            p1 = p2;\n+            q0 = q1;\n+            q1 = q2;\n+        }\n+\n+        if (n >= maxIterations) {\n+            throw new MaxIterationsExceededException(maxIterations,\n+                \"Continued fraction convergents failed to converge for value {0}\",\n+                x);\n+        }\n+\n+        return c;\n+    }\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/DefaultTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.util;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * A Default NumberTransformer for java.lang.Numbers and Numeric Strings. This \n+ * provides some simple conversion capabilities to turn any java.lang.Number \n+ * into a primitive double or to turn a String representation of a Number into \n+ * a double.\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public class DefaultTransformer implements NumberTransformer, Serializable {\n+   \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 4019938025047800455L;\n+    \n+    /**\n+     * @param o  the object that gets transformed.\n+     * @return a double primitive representation of the Object o.\n+     * @throws org.apache.commons.math.MathException If it cannot successfully \n+     * be transformed or is null.\n+     * @see <a href=\"http://commons.apache.org/collections/api-release/org/apache/commons/collections/Transformer.html\"/>\n+     */\n+    public double transform(Object o) throws MathException{\n+\n+        if (o == null) {\n+            throw new MathException(\"Conversion Exception in Transformation, Object is null\");\n+        }\n+\n+        if (o instanceof Number) {\n+            return ((Number)o).doubleValue();\n+        }\n+            \n+        try {\n+            return Double.valueOf(o.toString()).doubleValue();\n+        } catch (Exception e) {\n+            throw new MathException(e,\n+                                    \"Conversion Exception in Transformation: {0}\", e.getMessage());\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean equals(Object other) {\n+        if (this == other) { \n+            return true;\n+        }\n+        if (other == null) {\n+            return false;\n+        }\n+        return other instanceof DefaultTransformer;\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Override\n+    public int hashCode() {\n+        // some arbitrary number ...\n+        return 401993047;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/DoubleArray.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+\n+/**\n+ * Provides a standard interface for double arrays.  Allows different\n+ * array implementations to support various storage mechanisms\n+ * such as automatic expansion, contraction, and array \"rolling\".\n+ *\n+ * @version $Revision$ $Date$\n+ */\n+public interface DoubleArray {\n+\n+    /**\n+     * Returns the number of elements currently in the array.  Please note\n+     * that this may be different from the length of the internal storage array.  \n+     * \n+     * @return number of elements\n+     */\n+    int getNumElements();\n+\n+    /**\n+     * Returns the element at the specified index.  Note that if an\n+     * out of bounds index is supplied a ArrayIndexOutOfBoundsException \n+     * will be thrown.\n+     * \n+     * @param index index to fetch a value from\n+     * @return value stored at the specified index\n+     * @throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n+     *         zero or is greater than <code>getNumElements() - 1</code>.\n+     */\n+    double getElement(int index);\n+\n+    /**\n+     * Sets the element at the specified index.  If the specified index is greater than\n+     * <code>getNumElements() - 1</code>, the <code>numElements</code> property\n+     * is increased to <code>index +1</code> and additional storage is allocated \n+     * (if necessary) for the new element and all  (uninitialized) elements \n+     * between the new element and the previous end of the array).\n+     * \n+     * @param index index to store a value in\n+     * @param value value to store at the specified index\n+     * @throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n+     *         zero.\n+     */\n+    void setElement(int index, double value);\n+\n+    /**\n+     * Adds an element to the end of this expandable array\n+     * \n+     * @param value to be added to end of array\n+     */\n+    void addElement(double value);\n+\n+    /**\n+     * <p>\n+     * Adds an element to the end of the array and removes the first\n+     * element in the array.  Returns the discarded first element.\n+     * The effect is similar to a push operation in a FIFO queue.\n+     * </p>\n+     * <p>\n+     * Example: If the array contains the elements 1, 2, 3, 4 (in that order)\n+     * and addElementRolling(5) is invoked, the result is an array containing\n+     * the entries 2, 3, 4, 5 and the value returned is 1.\n+     * </p>\n+     * \n+     * @param value the value to be added to the array\n+     * @return the value which has been discarded or \"pushed\" out of the array\n+     *         by this rolling insert\n+     */\n+    double addElementRolling(double value);\n+\n+    /**\n+     * Returns a double[] array containing the elements of this \n+     * <code>DoubleArray</code>.  If the underlying implementation is \n+     * array-based, this method should always return a copy, rather than a \n+     * reference to the underlying array so that changes made to the returned\n+     *  array have no effect on the <code>DoubleArray.</code>\n+     *\n+     * @return all elements added to the array\n+     */\n+    double[] getElements();\n+\n+    /**\n+     * Clear the double array\n+     */\n+    void clear();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.util;\n+\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Some useful additions to the built-in functions in {@link Math}.\n+ * @version $Revision$ $Date$\n+ */\n+public final class MathUtils {\n+\n+    /** Smallest positive number such that 1 - EPSILON is not numerically equal to 1. */\n+    public static final double EPSILON = 0x1.0p-53;\n+\n+    /** Safe minimum, such that 1 / SAFE_MIN does not overflow.\n+     * <p>In IEEE 754 arithmetic, this is also the smallest normalized\n+     * number 2<sup>-1022</sup>.</p>\n+     */\n+    public static final double SAFE_MIN = 0x1.0p-1022;\n+\n+    /** -1.0 cast as a byte. */\n+    private static final byte  NB = (byte)-1;\n+\n+    /** -1.0 cast as a short. */\n+    private static final short NS = (short)-1;\n+\n+    /** 1.0 cast as a byte. */\n+    private static final byte  PB = (byte)1;\n+\n+    /** 1.0 cast as a short. */\n+    private static final short PS = (short)1;\n+\n+    /** 0.0 cast as a byte. */\n+    private static final byte  ZB = (byte)0;\n+\n+    /** 0.0 cast as a short. */\n+    private static final short ZS = (short)0;\n+\n+    /** 2 &pi;. */\n+    private static final double TWO_PI = 2 * Math.PI;\n+\n+    /** Gap between NaN and regular numbers. */\n+    private static final int NAN_GAP = 4 * 1024 * 1024;\n+\n+    /** Offset to order signed double numbers lexicographically. */\n+    private static final long SGN_MASK = 0x8000000000000000L;\n+\n+    /**\n+     * Private Constructor\n+     */\n+    private MathUtils() {\n+        super();\n+    }\n+\n+    /**\n+     * Add two integers, checking for overflow.\n+     * \n+     * @param x an addend\n+     * @param y an addend\n+     * @return the sum <code>x+y</code>\n+     * @throws ArithmeticException if the result can not be represented as an\n+     *         int\n+     * @since 1.1\n+     */\n+    public static int addAndCheck(int x, int y) {\n+        long s = (long)x + (long)y;\n+        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: add\");\n+        }\n+        return (int)s;\n+    }\n+\n+    /**\n+     * Add two long integers, checking for overflow.\n+     * \n+     * @param a an addend\n+     * @param b an addend\n+     * @return the sum <code>a+b</code>\n+     * @throws ArithmeticException if the result can not be represented as an\n+     *         long\n+     * @since 1.2\n+     */\n+    public static long addAndCheck(long a, long b) {\n+        return addAndCheck(a, b, \"overflow: add\");\n+    }\n+    \n+    /**\n+     * Add two long integers, checking for overflow.\n+     * \n+     * @param a an addend\n+     * @param b an addend\n+     * @param msg the message to use for any thrown exception.\n+     * @return the sum <code>a+b</code>\n+     * @throws ArithmeticException if the result can not be represented as an\n+     *         long\n+     * @since 1.2\n+     */\n+    private static long addAndCheck(long a, long b, String msg) {\n+        long ret;\n+        if (a > b) {\n+            // use symmetry to reduce boundary cases\n+            ret = addAndCheck(b, a, msg);\n+        } else {\n+            // assert a <= b\n+            \n+            if (a < 0) {\n+                if (b < 0) {\n+                    // check for negative overflow\n+                    if (Long.MIN_VALUE - b <= a) {\n+                        ret = a + b;\n+                    } else {\n+                        throw new ArithmeticException(msg);\n+                    }\n+                } else {\n+                    // opposite sign addition is always safe\n+                    ret = a + b;\n+                }\n+            } else {\n+                // assert a >= 0\n+                // assert b >= 0\n+\n+                // check for positive overflow\n+                if (a <= Long.MAX_VALUE - b) {\n+                    ret = a + b;\n+                } else {\n+                    throw new ArithmeticException(msg);\n+                }\n+            }\n+        }\n+        return ret;\n+    }\n+    \n+    /**\n+     * Returns an exact representation of the <a\n+     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n+     * Coefficient</a>, \"<code>n choose k</code>\", the number of\n+     * <code>k</code>-element subsets that can be selected from an\n+     * <code>n</code>-element set.\n+     * <p>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n+     * <li> <code>0 <= k <= n </code> (otherwise\n+     * <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li> The result is small enough to fit into a <code>long</code>. The\n+     * largest value of <code>n</code> for which all coefficients are\n+     * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds\n+     * <code>Long.MAX_VALUE</code> an <code>ArithMeticException</code> is\n+     * thrown.</li>\n+     * </ul></p>\n+     * \n+     * @param n the size of the set\n+     * @param k the size of the subsets to be counted\n+     * @return <code>n choose k</code>\n+     * @throws IllegalArgumentException if preconditions are not met.\n+     * @throws ArithmeticException if the result is too large to be represented\n+     *         by a long integer.\n+     */\n+    public static long binomialCoefficient(final int n, final int k) {\n+        checkBinomial(n, k);\n+        if ((n == k) || (k == 0)) {\n+            return 1;\n+        }\n+        if ((k == 1) || (k == n - 1)) {\n+            return n;\n+        }\n+        // Use symmetry for large k\n+        if (k > n / 2)\n+            return binomialCoefficient(n, n - k);\n+        \n+        // We use the formula\n+        // (n choose k) = n! / (n-k)! / k!\n+        // (n choose k) == ((n-k+1)*...*n) / (1*...*k)\n+        // which could be written\n+        // (n choose k) == (n-1 choose k-1) * n / k\n+        long result = 1;\n+        if (n <= 61) {\n+            // For n <= 61, the naive implementation cannot overflow.\n+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n+                result = result * i / j;\n+            }\n+        } else if (n <= 66) {\n+            // For n > 61 but n <= 66, the result cannot overflow,\n+            // but we must take care not to overflow intermediate values.\n+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n+                // We know that (result * i) is divisible by j,\n+                // but (result * i) may overflow, so we split j:\n+                // Filter out the gcd, d, so j/d and i/d are integer.\n+                // result is divisible by (j/d) because (j/d)\n+                // is relative prime to (i/d) and is a divisor of\n+                // result * (i/d).\n+                long d = gcd(i, j);\n+                result = (result / (j / d)) * (i / d);\n+            }\n+        } else {\n+            // For n > 66, a result overflow might occur, so we check\n+            // the multiplication, taking care to not overflow\n+            // unnecessary.\n+            for (int j = 1, i = n - k + 1; j <= k; i++, j++) {\n+                long d = gcd(i, j);\n+                result = mulAndCheck((result / (j / d)), (i / d));\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a <code>double</code> representation of the <a\n+     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n+     * Coefficient</a>, \"<code>n choose k</code>\", the number of\n+     * <code>k</code>-element subsets that can be selected from an\n+     * <code>n</code>-element set.\n+     * <p>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n+     * <li> <code>0 <= k <= n </code> (otherwise\n+     * <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li> The result is small enough to fit into a <code>double</code>. The\n+     * largest value of <code>n</code> for which all coefficients are <\n+     * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,\n+     * Double.POSITIVE_INFINITY is returned</li>\n+     * </ul></p>\n+     * \n+     * @param n the size of the set\n+     * @param k the size of the subsets to be counted\n+     * @return <code>n choose k</code>\n+     * @throws IllegalArgumentException if preconditions are not met.\n+     */\n+    public static double binomialCoefficientDouble(final int n, final int k) {\n+        checkBinomial(n, k);\n+        if ((n == k) || (k == 0)) {\n+            return 1d;\n+        }\n+        if ((k == 1) || (k == n - 1)) {\n+            return n;\n+        }\n+        if (k > n/2) {\n+            return binomialCoefficientDouble(n, n - k);\n+        }\n+        if (n < 67) {\n+            return binomialCoefficient(n,k);\n+        }\n+        \n+        double result = 1d;\n+        for (int i = 1; i <= k; i++) {\n+             result *= (double)(n - k + i) / (double)i;\n+        }\n+  \n+        return Math.floor(result + 0.5);\n+    }\n+    \n+    /**\n+     * Returns the natural <code>log</code> of the <a\n+     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n+     * Coefficient</a>, \"<code>n choose k</code>\", the number of\n+     * <code>k</code>-element subsets that can be selected from an\n+     * <code>n</code>-element set.\n+     * <p>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n+     * <li> <code>0 <= k <= n </code> (otherwise\n+     * <code>IllegalArgumentException</code> is thrown)</li>\n+     * </ul></p>\n+     * \n+     * @param n the size of the set\n+     * @param k the size of the subsets to be counted\n+     * @return <code>n choose k</code>\n+     * @throws IllegalArgumentException if preconditions are not met.\n+     */\n+    public static double binomialCoefficientLog(final int n, final int k) {\n+        checkBinomial(n, k);\n+        if ((n == k) || (k == 0)) {\n+            return 0;\n+        }\n+        if ((k == 1) || (k == n - 1)) {\n+            return Math.log(n);\n+        }\n+        \n+        /*\n+         * For values small enough to do exact integer computation,\n+         * return the log of the exact value \n+         */\n+        if (n < 67) {  \n+            return Math.log(binomialCoefficient(n,k));\n+        }\n+        \n+        /*\n+         * Return the log of binomialCoefficientDouble for values that will not\n+         * overflow binomialCoefficientDouble\n+         */\n+        if (n < 1030) { \n+            return Math.log(binomialCoefficientDouble(n, k));\n+        } \n+\n+        if (k > n / 2) {\n+            return binomialCoefficientLog(n, n - k);\n+        }\n+\n+        /*\n+         * Sum logs for values that could overflow\n+         */\n+        double logSum = 0;\n+\n+        // n!/(n-k)!\n+        for (int i = n - k + 1; i <= n; i++) {\n+            logSum += Math.log(i);\n+        }\n+\n+        // divide by k!\n+        for (int i = 2; i <= k; i++) {\n+            logSum -= Math.log(i);\n+        }\n+\n+        return logSum;      \n+    }\n+\n+    /**\n+     * Check binomial preconditions.\n+     * @param n the size of the set\n+     * @param k the size of the subsets to be counted\n+     * @exception IllegalArgumentException if preconditions are not met.\n+     */\n+    private static void checkBinomial(final int n, final int k)\n+        throws IllegalArgumentException {\n+        if (n < k) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"must have n >= k for binomial coefficient (n,k), got n = {0}, k = {1}\",\n+                n, k);\n+        }\n+        if (n < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"must have n >= 0 for binomial coefficient (n,k), got n = {0}\",\n+                  n);\n+        }\n+    }\n+    \n+    /**\n+     * Compares two numbers given some amount of allowed error.\n+     * \n+     * @param x the first number\n+     * @param y the second number\n+     * @param eps the amount of error to allow when checking for equality\n+     * @return <ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li>\n+     *       <li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x &lt; y</li>\n+     *       <li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x > y</li></ul>\n+     */\n+    public static int compareTo(double x, double y, double eps) {\n+        if (equals(x, y, eps)) {\n+            return 0;\n+        } else if (x < y) {\n+          return -1;\n+        }\n+        return 1;\n+    }\n+    \n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\">\n+     * hyperbolic cosine</a> of x.\n+     * \n+     * @param x double value for which to find the hyperbolic cosine\n+     * @return hyperbolic cosine of x\n+     */\n+    public static double cosh(double x) {\n+        return (Math.exp(x) + Math.exp(-x)) / 2.0;\n+    }\n+    \n+    /**\n+     * Returns true iff both arguments are NaN or neither is NaN and they are\n+     * equal\n+     * \n+     * @param x first value\n+     * @param y second value\n+     * @return true if the values are equal or both are NaN\n+     */\n+    public static boolean equals(double x, double y) {\n+        return ((Double.isNaN(x) && Double.isNaN(y)) || x == y);\n+    }\n+\n+    /**\n+     * Returns true iff both arguments are equal or within the range of allowed\n+     * error (inclusive).\n+     * <p>\n+     * Two NaNs are considered equals, as are two infinities with same sign.\n+     * </p>\n+     * \n+     * @param x first value\n+     * @param y second value\n+     * @param eps the amount of absolute error to allow\n+     * @return true if the values are equal or within range of each other\n+     */\n+    public static boolean equals(double x, double y, double eps) {\n+      return equals(x, y) || (Math.abs(y - x) <= eps);\n+    }\n+    \n+    /**\n+     * Returns true iff both arguments are equal or within the range of allowed\n+     * error (inclusive).\n+     * Adapted from <a\n+     * href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\">\n+     * Bruce Dawson</a>\n+     *\n+     * @param x first value\n+     * @param y second value\n+     * @param maxUlps {@code (maxUlps - 1)} is the number of floating point\n+     * values between {@code x} and {@code y}.\n+     * @return {@code true} if there are less than {@code maxUlps} floating\n+     * point values between {@code x} and {@code y}\n+     */\n+    public static boolean equals(double x, double y, int maxUlps) {\n+        // Check that \"maxUlps\" is non-negative and small enough so that the\n+        // default NAN won't compare as equal to anything.\n+        assert maxUlps > 0 && maxUlps < NAN_GAP;\n+\n+        long xInt = Double.doubleToLongBits(x);\n+        long yInt = Double.doubleToLongBits(y);\n+\n+        // Make lexicographically ordered as a two's-complement integer.\n+        if (xInt < 0) {\n+            xInt = SGN_MASK - xInt;\n+        }\n+        if (yInt < 0) {\n+            yInt = SGN_MASK - yInt;\n+        }\n+\n+        return Math.abs(xInt - yInt) <= maxUlps;\n+    }\n+\n+    /**\n+     * Returns true iff both arguments are null or have same dimensions\n+     * and all their elements are {@link #equals(double,double) equals}\n+     * \n+     * @param x first array\n+     * @param y second array\n+     * @return true if the values are both null or have same dimension\n+     * and equal elements\n+     * @since 1.2\n+     */\n+    public static boolean equals(double[] x, double[] y) {\n+        if ((x == null) || (y == null)) {\n+            return !((x == null) ^ (y == null));\n+        }\n+        if (x.length != y.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < x.length; ++i) {\n+            if (!equals(x[i], y[i])) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    /** All long-representable factorials */\n+    private static final long[] factorials = new long[] \n+       {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 39916800,\n+        479001600, 6227020800l, 87178291200l, 1307674368000l, 20922789888000l,\n+        355687428096000l, 6402373705728000l, 121645100408832000l,\n+        2432902008176640000l};\n+\n+    /**\n+     * Returns n!. Shorthand for <code>n</code> <a\n+     * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n+     * product of the numbers <code>1,...,n</code>.\n+     * <p>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n+     * <li> <code>n >= 0</code> (otherwise\n+     * <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li> The result is small enough to fit into a <code>long</code>. The\n+     * largest value of <code>n</code> for which <code>n!</code> <\n+     * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>\n+     * an <code>ArithMeticException </code> is thrown.</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param n argument\n+     * @return <code>n!</code>\n+     * @throws ArithmeticException if the result is too large to be represented\n+     *         by a long integer.\n+     * @throws IllegalArgumentException if n < 0\n+     */\n+    public static long factorial(final int n) {\n+        if (n < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"must have n >= 0 for n!, got n = {0}\",\n+                  n);\n+        }\n+        if (n > 20) {\n+            throw new ArithmeticException(\n+                    \"factorial value is too large to fit in a long\");\n+        }\n+        return factorials[n];\n+    }\n+\n+    /**\n+     * Returns n!. Shorthand for <code>n</code> <a\n+     * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n+     * product of the numbers <code>1,...,n</code> as a <code>double</code>.\n+     * <p>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n+     * <li> <code>n >= 0</code> (otherwise\n+     * <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li> The result is small enough to fit into a <code>double</code>. The\n+     * largest value of <code>n</code> for which <code>n!</code> <\n+     * Double.MAX_VALUE</code> is 170. If the computed value exceeds\n+     * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>\n+     * </ul>\n+     * </p>\n+     * \n+     * @param n argument\n+     * @return <code>n!</code>\n+     * @throws IllegalArgumentException if n < 0\n+     */\n+    public static double factorialDouble(final int n) {\n+        if (n < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"must have n >= 0 for n!, got n = {0}\",\n+                  n);\n+        }\n+        if (n < 21) {\n+            return factorial(n);\n+        }\n+        return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n+    }\n+\n+    /**\n+     * Returns the natural logarithm of n!.\n+     * <p>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n+     * <li> <code>n >= 0</code> (otherwise\n+     * <code>IllegalArgumentException</code> is thrown)</li>\n+     * </ul></p>\n+     * \n+     * @param n argument\n+     * @return <code>n!</code>\n+     * @throws IllegalArgumentException if preconditions are not met.\n+     */\n+    public static double factorialLog(final int n) {\n+        if (n < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"must have n >= 0 for n!, got n = {0}\",\n+                  n);\n+        }\n+        if (n < 21) {\n+            return Math.log(factorial(n));\n+        }\n+        double logSum = 0;\n+        for (int i = 2; i <= n; i++) {\n+            logSum += Math.log(i);\n+        }\n+        return logSum;\n+    }\n+\n+    /**\n+     * <p>\n+     * Gets the greatest common divisor of the absolute value of two numbers,\n+     * using the \"binary gcd\" method which avoids division and modulo\n+     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n+     * Stein (1961).\n+     * </p>\n+     * Special cases:\n+     * <ul>\n+     * <li>The invocations\n+     * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,\n+     * <code>gcd(Integer.MIN_VALUE, 0)</code> and\n+     * <code>gcd(0, Integer.MIN_VALUE)</code> throw an\n+     * <code>ArithmeticException</code>, because the result would be 2^31, which\n+     * is too large for an int value.</li>\n+     * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and\n+     * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except\n+     * for the special cases above.\n+     * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns\n+     * <code>0</code>.</li>\n+     * </ul>\n+     * \n+     * @param p any number\n+     * @param q any number\n+     * @return the greatest common divisor, never negative\n+     * @throws ArithmeticException\n+     *             if the result cannot be represented as a nonnegative int\n+     *             value\n+     * @since 1.1\n+     */\n+    public static int gcd(final int p, final int q) {\n+        int u = p;\n+        int v = q;\n+        if ((u == 0) || (v == 0)) {\n+            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n+                throw MathRuntimeException.createArithmeticException(\n+                        \"overflow: gcd({0}, {1}) is 2^31\",\n+                        p, q);\n+            }\n+            return (Math.abs(u) + Math.abs(v));\n+        }\n+        // keep u and v negative, as negative integers range down to\n+        // -2^31, while positive numbers can only be as large as 2^31-1\n+        // (i.e. we can't necessarily negate a negative number without\n+        // overflow)\n+        /* assert u!=0 && v!=0; */\n+        if (u > 0) {\n+            u = -u;\n+        } // make u negative\n+        if (v > 0) {\n+            v = -v;\n+        } // make v negative\n+        // B1. [Find power of 2]\n+        int k = 0;\n+        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n+                                                            // both even...\n+            u /= 2;\n+            v /= 2;\n+            k++; // cast out twos.\n+        }\n+        if (k == 31) {\n+            throw MathRuntimeException.createArithmeticException(\n+                    \"overflow: gcd({0}, {1}) is 2^31\",\n+                    p, q);\n+        }\n+        // B2. Initialize: u and v have been divided by 2^k and at least\n+        // one is odd.\n+        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n+        // t negative: u was odd, v may be even (t replaces v)\n+        // t positive: u was even, v is odd (t replaces u)\n+        do {\n+            /* assert u<0 && v<0; */\n+            // B4/B3: cast out twos from t.\n+            while ((t & 1) == 0) { // while t is even..\n+                t /= 2; // cast out twos\n+            }\n+            // B5 [reset max(u,v)]\n+            if (t > 0) {\n+                u = -t;\n+            } else {\n+                v = t;\n+            }\n+            // B6/B3. at this point both u and v should be odd.\n+            t = (v - u) / 2;\n+            // |u| larger: t positive (replace u)\n+            // |v| larger: t negative (replace v)\n+        } while (t != 0);\n+        return -u * (1 << k); // gcd is u*2^k\n+    }\n+\n+    /**\n+     * Returns an integer hash code representing the given double value.\n+     * \n+     * @param value the value to be hashed\n+     * @return the hash code\n+     */\n+    public static int hash(double value) {\n+        return new Double(value).hashCode();\n+    }\n+\n+    /**\n+     * Returns an integer hash code representing the given double array.\n+     * \n+     * @param value the value to be hashed (may be null)\n+     * @return the hash code\n+     * @since 1.2\n+     */\n+    public static int hash(double[] value) {\n+        return Arrays.hashCode(value);\n+    }\n+\n+    /**\n+     * For a byte value x, this method returns (byte)(+1) if x >= 0 and\n+     * (byte)(-1) if x < 0.\n+     * \n+     * @param x the value, a byte\n+     * @return (byte)(+1) or (byte)(-1), depending on the sign of x\n+     */\n+    public static byte indicator(final byte x) {\n+        return (x >= ZB) ? PB : NB;\n+    }\n+\n+    /**\n+     * For a double precision value x, this method returns +1.0 if x >= 0 and\n+     * -1.0 if x < 0. Returns <code>NaN</code> if <code>x</code> is\n+     * <code>NaN</code>.\n+     * \n+     * @param x the value, a double\n+     * @return +1.0 or -1.0, depending on the sign of x\n+     */\n+    public static double indicator(final double x) {\n+        if (Double.isNaN(x)) {\n+            return Double.NaN;\n+        }\n+        return (x >= 0.0) ? 1.0 : -1.0;\n+    }\n+\n+    /**\n+     * For a float value x, this method returns +1.0F if x >= 0 and -1.0F if x <\n+     * 0. Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.\n+     * \n+     * @param x the value, a float\n+     * @return +1.0F or -1.0F, depending on the sign of x\n+     */\n+    public static float indicator(final float x) {\n+        if (Float.isNaN(x)) {\n+            return Float.NaN;\n+        }\n+        return (x >= 0.0F) ? 1.0F : -1.0F;\n+    }\n+\n+    /**\n+     * For an int value x, this method returns +1 if x >= 0 and -1 if x < 0.\n+     * \n+     * @param x the value, an int\n+     * @return +1 or -1, depending on the sign of x\n+     */\n+    public static int indicator(final int x) {\n+        return (x >= 0) ? 1 : -1;\n+    }\n+\n+    /**\n+     * For a long value x, this method returns +1L if x >= 0 and -1L if x < 0.\n+     * \n+     * @param x the value, a long\n+     * @return +1L or -1L, depending on the sign of x\n+     */\n+    public static long indicator(final long x) {\n+        return (x >= 0L) ? 1L : -1L;\n+    }\n+\n+    /**\n+     * For a short value x, this method returns (short)(+1) if x >= 0 and\n+     * (short)(-1) if x < 0.\n+     * \n+     * @param x the value, a short\n+     * @return (short)(+1) or (short)(-1), depending on the sign of x\n+     */\n+    public static short indicator(final short x) {\n+        return (x >= ZS) ? PS : NS;\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns the least common multiple of the absolute value of two numbers,\n+     * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.\n+     * </p>\n+     * Special cases:\n+     * <ul>\n+     * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)</code> and\n+     * <code>lcm(n, Integer.MIN_VALUE)</code>, where <code>abs(n)</code> is a\n+     * power of 2, throw an <code>ArithmeticException</code>, because the result\n+     * would be 2^31, which is too large for an int value.</li>\n+     * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is\n+     * <code>0</code> for any <code>x</code>.\n+     * </ul>\n+     * \n+     * @param a any number\n+     * @param b any number\n+     * @return the least common multiple, never negative\n+     * @throws ArithmeticException\n+     *             if the result cannot be represented as a nonnegative int\n+     *             value\n+     * @since 1.1\n+     */\n+    public static int lcm(int a, int b) {\n+        if (a==0 || b==0){\n+            return 0;\n+        }\n+        int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n+        if (lcm == Integer.MIN_VALUE){\n+            throw new ArithmeticException(\"overflow: lcm is 2^31\");\n+        }\n+        return lcm;\n+    }\n+\n+    /** \n+     * <p>Returns the \n+     * <a href=\"http://mathworld.wolfram.com/Logarithm.html\">logarithm</a>\n+     * for base <code>b</code> of <code>x</code>.\n+     * </p>\n+     * <p>Returns <code>NaN<code> if either argument is negative.  If \n+     * <code>base</code> is 0 and <code>x</code> is positive, 0 is returned.\n+     * If <code>base</code> is positive and <code>x</code> is 0, \n+     * <code>Double.NEGATIVE_INFINITY</code> is returned.  If both arguments\n+     * are 0, the result is <code>NaN</code>.</p>\n+     * \n+     * @param base the base of the logarithm, must be greater than 0\n+     * @param x argument, must be greater than 0\n+     * @return the value of the logarithm - the number y such that base^y = x.\n+     * @since 1.2\n+     */ \n+    public static double log(double base, double x) {\n+        return Math.log(x)/Math.log(base);\n+    }\n+\n+    /**\n+     * Multiply two integers, checking for overflow.\n+     * \n+     * @param x a factor\n+     * @param y a factor\n+     * @return the product <code>x*y</code>\n+     * @throws ArithmeticException if the result can not be represented as an\n+     *         int\n+     * @since 1.1\n+     */\n+    public static int mulAndCheck(int x, int y) {\n+        long m = ((long)x) * ((long)y);\n+        if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: mul\");\n+        }\n+        return (int)m;\n+    }\n+\n+    /**\n+     * Multiply two long integers, checking for overflow.\n+     * \n+     * @param a first value\n+     * @param b second value\n+     * @return the product <code>a * b</code>\n+     * @throws ArithmeticException if the result can not be represented as an\n+     *         long\n+     * @since 1.2\n+     */\n+    public static long mulAndCheck(long a, long b) {\n+        long ret;\n+        String msg = \"overflow: multiply\";\n+        if (a > b) {\n+            // use symmetry to reduce boundary cases\n+            ret = mulAndCheck(b, a);\n+        } else {\n+            if (a < 0) {\n+                if (b < 0) {\n+                    // check for positive overflow with negative a, negative b\n+                    if (a >= Long.MAX_VALUE / b) {\n+                        ret = a * b;\n+                    } else {\n+                        throw new ArithmeticException(msg);\n+                    }\n+                } else if (b > 0) {\n+                    // check for negative overflow with negative a, positive b\n+                    if (Long.MIN_VALUE / b <= a) {\n+                        ret = a * b;\n+                    } else {\n+                        throw new ArithmeticException(msg);\n+                        \n+                    }\n+                } else {\n+                    // assert b == 0\n+                    ret = 0;\n+                }\n+            } else if (a > 0) {\n+                // assert a > 0\n+                // assert b > 0\n+                \n+                // check for positive overflow with positive a, positive b\n+                if (a <= Long.MAX_VALUE / b) {\n+                    ret = a * b;\n+                } else {\n+                    throw new ArithmeticException(msg);\n+                }\n+            } else {\n+                // assert a == 0\n+                ret = 0;\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Get the next machine representable number after a number, moving\n+     * in the direction of another number.\n+     * <p>\n+     * If <code>direction</code> is greater than or equal to<code>d</code>,\n+     * the smallest machine representable number strictly greater than\n+     * <code>d</code> is returned; otherwise the largest representable number\n+     * strictly less than <code>d</code> is returned.</p>\n+     * <p>\n+     * If <code>d</code> is NaN or Infinite, it is returned unchanged.</p>\n+     * \n+     * @param d base number\n+     * @param direction (the only important thing is whether\n+     * direction is greater or smaller than d)\n+     * @return the next machine representable number in the specified direction\n+     * @since 1.2\n+     */\n+    public static double nextAfter(double d, double direction) {\n+\n+        // handling of some important special cases\n+        if (Double.isNaN(d) || Double.isInfinite(d)) {\n+                return d;\n+        } else if (d == 0) {\n+                return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n+        }\n+        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n+        // are handled just as normal numbers\n+\n+        // split the double in raw components\n+        long bits     = Double.doubleToLongBits(d);\n+        long sign     = bits & 0x8000000000000000L;\n+        long exponent = bits & 0x7ff0000000000000L;\n+        long mantissa = bits & 0x000fffffffffffffL;\n+\n+        if (d * (direction - d) >= 0) {\n+                // we should increase the mantissa\n+                if (mantissa == 0x000fffffffffffffL) {\n+                        return Double.longBitsToDouble(sign |\n+                                        (exponent + 0x0010000000000000L));\n+                } else {\n+                        return Double.longBitsToDouble(sign |\n+                                        exponent | (mantissa + 1));\n+                }\n+        } else {\n+                // we should decrease the mantissa\n+                if (mantissa == 0L) {\n+                        return Double.longBitsToDouble(sign |\n+                                        (exponent - 0x0010000000000000L) |\n+                                        0x000fffffffffffffL);\n+                } else {\n+                        return Double.longBitsToDouble(sign |\n+                                        exponent | (mantissa - 1));\n+                }\n+        }\n+\n+    }\n+\n+    /**\n+     * Scale a number by 2<sup>scaleFactor</sup>.\n+     * <p>If <code>d</code> is 0 or NaN or Infinite, it is returned unchanged.</p>\n+     * \n+     * @param d base number\n+     * @param scaleFactor power of two by which d sould be multiplied\n+     * @return d &times; 2<sup>scaleFactor</sup>\n+     * @since 2.0\n+     */\n+    public static double scalb(final double d, final int scaleFactor) {\n+\n+        // handling of some important special cases\n+        if ((d == 0) || Double.isNaN(d) || Double.isInfinite(d)) {\n+            return d;\n+        }\n+\n+        // split the double in raw components\n+        final long bits     = Double.doubleToLongBits(d);\n+        final long exponent = bits & 0x7ff0000000000000L;\n+        final long rest     = bits & 0x800fffffffffffffL;\n+\n+        // shift the exponent\n+        final long newBits = rest | (exponent + (((long) scaleFactor) << 52));\n+        return Double.longBitsToDouble(newBits);\n+\n+    }\n+\n+    /**\n+     * Normalize an angle in a 2&pi wide interval around a center value.\n+     * <p>This method has three main uses:</p>\n+     * <ul>\n+     *   <li>normalize an angle between 0 and 2&pi;:<br/>\n+     *       <code>a = MathUtils.normalizeAngle(a, Math.PI);</code></li>\n+     *   <li>normalize an angle between -&pi; and +&pi;<br/>\n+     *       <code>a = MathUtils.normalizeAngle(a, 0.0);</code></li>\n+     *   <li>compute the angle between two defining angular positions:<br>\n+     *       <code>angle = MathUtils.normalizeAngle(end, start) - start;</code></li>\n+     * </ul>\n+     * <p>Note that due to numerical accuracy and since &pi; cannot be represented\n+     * exactly, the result interval is <em>closed</em>, it cannot be half-closed\n+     * as would be more satisfactory in a purely mathematical view.</p>\n+     * @param a angle to normalize\n+     * @param center center of the desired 2&pi; interval for the result\n+     * @return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi;\n+     * @since 1.2\n+     */\n+     public static double normalizeAngle(double a, double center) {\n+         return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);\n+     }\n+\n+    /**\n+     * Round the given value to the specified number of decimal places. The\n+     * value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n+     * \n+     * @param x the value to round.\n+     * @param scale the number of digits to the right of the decimal point.\n+     * @return the rounded value.\n+     * @since 1.1\n+     */\n+    public static double round(double x, int scale) {\n+        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n+    }\n+\n+    /**\n+     * Round the given value to the specified number of decimal places. The\n+     * value is rounded using the given method which is any method defined in\n+     * {@link BigDecimal}.\n+     * \n+     * @param x the value to round.\n+     * @param scale the number of digits to the right of the decimal point.\n+     * @param roundingMethod the rounding method as defined in\n+     *        {@link BigDecimal}.\n+     * @return the rounded value.\n+     * @since 1.1\n+     */\n+    public static double round(double x, int scale, int roundingMethod) {\n+        try {\n+            return (new BigDecimal\n+                   (Double.toString(x))\n+                   .setScale(scale, roundingMethod))\n+                   .doubleValue();\n+        } catch (NumberFormatException ex) {\n+            if (Double.isInfinite(x)) {\n+                return x;          \n+            } else {\n+                return Double.NaN;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Round the given value to the specified number of decimal places. The\n+     * value is rounding using the {@link BigDecimal#ROUND_HALF_UP} method.\n+     * \n+     * @param x the value to round.\n+     * @param scale the number of digits to the right of the decimal point.\n+     * @return the rounded value.\n+     * @since 1.1\n+     */\n+    public static float round(float x, int scale) {\n+        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n+    }\n+\n+    /**\n+     * Round the given value to the specified number of decimal places. The\n+     * value is rounded using the given method which is any method defined in\n+     * {@link BigDecimal}.\n+     * \n+     * @param x the value to round.\n+     * @param scale the number of digits to the right of the decimal point.\n+     * @param roundingMethod the rounding method as defined in\n+     *        {@link BigDecimal}.\n+     * @return the rounded value.\n+     * @since 1.1\n+     */\n+    public static float round(float x, int scale, int roundingMethod) {\n+        float sign = indicator(x);\n+        float factor = (float)Math.pow(10.0f, scale) * sign;\n+        return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;\n+    }\n+\n+    /**\n+     * Round the given non-negative, value to the \"nearest\" integer. Nearest is\n+     * determined by the rounding method specified. Rounding methods are defined\n+     * in {@link BigDecimal}.\n+     * \n+     * @param unscaled the value to round.\n+     * @param sign the sign of the original, scaled value.\n+     * @param roundingMethod the rounding method as defined in\n+     *        {@link BigDecimal}.\n+     * @return the rounded value.\n+     * @since 1.1\n+     */\n+    private static double roundUnscaled(double unscaled, double sign,\n+        int roundingMethod) {\n+        switch (roundingMethod) {\n+        case BigDecimal.ROUND_CEILING :\n+            if (sign == -1) {\n+                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+            } else {\n+                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n+            }\n+            break;\n+        case BigDecimal.ROUND_DOWN :\n+            unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+            break;\n+        case BigDecimal.ROUND_FLOOR :\n+            if (sign == -1) {\n+                unscaled = Math.ceil(nextAfter(unscaled, Double.POSITIVE_INFINITY));\n+            } else {\n+                unscaled = Math.floor(nextAfter(unscaled, Double.NEGATIVE_INFINITY));\n+            }\n+            break;\n+        case BigDecimal.ROUND_HALF_DOWN : {\n+            unscaled = nextAfter(unscaled, Double.NEGATIVE_INFINITY);\n+            double fraction = unscaled - Math.floor(unscaled);\n+            if (fraction > 0.5) {\n+                unscaled = Math.ceil(unscaled);\n+            } else {\n+                unscaled = Math.floor(unscaled);\n+            }\n+            break;\n+        }\n+        case BigDecimal.ROUND_HALF_EVEN : {\n+            double fraction = unscaled - Math.floor(unscaled);\n+            if (fraction > 0.5) {\n+                unscaled = Math.ceil(unscaled);\n+            } else if (fraction < 0.5) {\n+                unscaled = Math.floor(unscaled);\n+            } else {\n+                // The following equality test is intentional and needed for rounding purposes\n+                if (Math.floor(unscaled) / 2.0 == Math.floor(Math\n+                    .floor(unscaled) / 2.0)) { // even\n+                    unscaled = Math.floor(unscaled);\n+                } else { // odd\n+                    unscaled = Math.ceil(unscaled);\n+                }\n+            }\n+            break;\n+        }\n+        case BigDecimal.ROUND_HALF_UP : {\n+            unscaled = nextAfter(unscaled, Double.POSITIVE_INFINITY);\n+            double fraction = unscaled - Math.floor(unscaled);\n+            if (fraction >= 0.5) {\n+                unscaled = Math.ceil(unscaled);\n+            } else {\n+                unscaled = Math.floor(unscaled);\n+            }\n+            break;\n+        }\n+        case BigDecimal.ROUND_UNNECESSARY :\n+            if (unscaled != Math.floor(unscaled)) {\n+                throw new ArithmeticException(\"Inexact result from rounding\");\n+            }\n+            break;\n+        case BigDecimal.ROUND_UP :\n+            unscaled = Math.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n+            break;\n+        default :\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"invalid rounding method {0}, valid methods: {1} ({2}), {3} ({4}),\" +\n+                  \" {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})\",\n+                  roundingMethod,\n+                  \"ROUND_CEILING\",     BigDecimal.ROUND_CEILING,\n+                  \"ROUND_DOWN\",        BigDecimal.ROUND_DOWN,\n+                  \"ROUND_FLOOR\",       BigDecimal.ROUND_FLOOR,\n+                  \"ROUND_HALF_DOWN\",   BigDecimal.ROUND_HALF_DOWN,\n+                  \"ROUND_HALF_EVEN\",   BigDecimal.ROUND_HALF_EVEN,\n+                  \"ROUND_HALF_UP\",     BigDecimal.ROUND_HALF_UP,\n+                  \"ROUND_UNNECESSARY\", BigDecimal.ROUND_UNNECESSARY,\n+                  \"ROUND_UP\",          BigDecimal.ROUND_UP);\n+        }\n+        return unscaled;\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n+     * for byte value <code>x</code>.\n+     * <p>\n+     * For a byte value x, this method returns (byte)(+1) if x > 0, (byte)(0) if\n+     * x = 0, and (byte)(-1) if x < 0.</p>\n+     * \n+     * @param x the value, a byte\n+     * @return (byte)(+1), (byte)(0), or (byte)(-1), depending on the sign of x\n+     */\n+    public static byte sign(final byte x) {\n+        return (x == ZB) ? ZB : (x > ZB) ? PB : NB;\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n+     * for double precision <code>x</code>.\n+     * <p>\n+     * For a double value <code>x</code>, this method returns\n+     * <code>+1.0</code> if <code>x > 0</code>, <code>0.0</code> if\n+     * <code>x = 0.0</code>, and <code>-1.0</code> if <code>x < 0</code>.\n+     * Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.</p>\n+     * \n+     * @param x the value, a double\n+     * @return +1.0, 0.0, or -1.0, depending on the sign of x\n+     */\n+    public static double sign(final double x) {\n+        if (Double.isNaN(x)) {\n+            return Double.NaN;\n+        }\n+        return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n+     * for float value <code>x</code>.\n+     * <p>\n+     * For a float value x, this method returns +1.0F if x > 0, 0.0F if x =\n+     * 0.0F, and -1.0F if x < 0. Returns <code>NaN</code> if <code>x</code>\n+     * is <code>NaN</code>.</p>\n+     * \n+     * @param x the value, a float\n+     * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x\n+     */\n+    public static float sign(final float x) {\n+        if (Float.isNaN(x)) {\n+            return Float.NaN;\n+        }\n+        return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n+     * for int value <code>x</code>.\n+     * <p>\n+     * For an int value x, this method returns +1 if x > 0, 0 if x = 0, and -1\n+     * if x < 0.</p>\n+     * \n+     * @param x the value, an int\n+     * @return +1, 0, or -1, depending on the sign of x\n+     */\n+    public static int sign(final int x) {\n+        return (x == 0) ? 0 : (x > 0) ? 1 : -1;\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n+     * for long value <code>x</code>.\n+     * <p>\n+     * For a long value x, this method returns +1L if x > 0, 0L if x = 0, and\n+     * -1L if x < 0.</p>\n+     * \n+     * @param x the value, a long\n+     * @return +1L, 0L, or -1L, depending on the sign of x\n+     */\n+    public static long sign(final long x) {\n+        return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n+     * for short value <code>x</code>.\n+     * <p>\n+     * For a short value x, this method returns (short)(+1) if x > 0, (short)(0)\n+     * if x = 0, and (short)(-1) if x < 0.</p>\n+     * \n+     * @param x the value, a short\n+     * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign of\n+     *         x\n+     */\n+    public static short sign(final short x) {\n+        return (x == ZS) ? ZS : (x > ZS) ? PS : NS;\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\">\n+     * hyperbolic sine</a> of x.\n+     * \n+     * @param x double value for which to find the hyperbolic sine\n+     * @return hyperbolic sine of x\n+     */\n+    public static double sinh(double x) {\n+        return (Math.exp(x) - Math.exp(-x)) / 2.0;\n+    }\n+\n+    /**\n+     * Subtract two integers, checking for overflow.\n+     * \n+     * @param x the minuend\n+     * @param y the subtrahend\n+     * @return the difference <code>x-y</code>\n+     * @throws ArithmeticException if the result can not be represented as an\n+     *         int\n+     * @since 1.1\n+     */\n+    public static int subAndCheck(int x, int y) {\n+        long s = (long)x - (long)y;\n+        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: subtract\");\n+        }\n+        return (int)s;\n+    }\n+\n+    /**\n+     * Subtract two long integers, checking for overflow.\n+     * \n+     * @param a first value\n+     * @param b second value\n+     * @return the difference <code>a-b</code>\n+     * @throws ArithmeticException if the result can not be represented as an\n+     *         long\n+     * @since 1.2\n+     */\n+    public static long subAndCheck(long a, long b) {\n+        long ret;\n+        String msg = \"overflow: subtract\";\n+        if (b == Long.MIN_VALUE) {\n+            if (a < 0) {\n+                ret = a - b;\n+            } else {\n+                throw new ArithmeticException(msg);\n+            }\n+        } else {\n+            // use additive inverse\n+            ret = addAndCheck(a, -b, msg);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Raise an int to an int power.\n+     * @param k number to raise\n+     * @param e exponent (must be positive or null)\n+     * @return k<sup>e</sup>\n+     * @exception IllegalArgumentException if e is negative\n+     */\n+    public static int pow(final int k, int e)\n+        throws IllegalArgumentException {\n+\n+        if (e < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"cannot raise an integral value to a negative power ({0}^{1})\",\n+                k, e);\n+        }\n+\n+        int result = 1;\n+        int k2p    = k;\n+        while (e != 0) {\n+            if ((e & 0x1) != 0) {\n+                result *= k2p;\n+            }\n+            k2p *= k2p;\n+            e = e >> 1;\n+        }\n+\n+        return result;\n+\n+    }\n+\n+    /**\n+     * Raise an int to a long power.\n+     * @param k number to raise\n+     * @param e exponent (must be positive or null)\n+     * @return k<sup>e</sup>\n+     * @exception IllegalArgumentException if e is negative\n+     */\n+    public static int pow(final int k, long e)\n+        throws IllegalArgumentException {\n+\n+        if (e < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"cannot raise an integral value to a negative power ({0}^{1})\",\n+                k, e);\n+        }\n+\n+        int result = 1;\n+        int k2p    = k;\n+        while (e != 0) {\n+            if ((e & 0x1) != 0) {\n+                result *= k2p;\n+            }\n+            k2p *= k2p;\n+            e = e >> 1;\n+        }\n+\n+        return result;\n+\n+    }\n+\n+    /**\n+     * Raise a long to an int power.\n+     * @param k number to raise\n+     * @param e exponent (must be positive or null)\n+     * @return k<sup>e</sup>\n+     * @exception IllegalArgumentException if e is negative\n+     */\n+    public static long pow(final long k, int e)\n+        throws IllegalArgumentException {\n+\n+        if (e < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"cannot raise an integral value to a negative power ({0}^{1})\",\n+                k, e);\n+        }\n+\n+        long result = 1l;\n+        long k2p    = k;\n+        while (e != 0) {\n+            if ((e & 0x1) != 0) {\n+                result *= k2p;\n+            }\n+            k2p *= k2p;\n+            e = e >> 1;\n+        }\n+\n+        return result;\n+\n+    }\n+\n+    /**\n+     * Raise a long to a long power.\n+     * @param k number to raise\n+     * @param e exponent (must be positive or null)\n+     * @return k<sup>e</sup>\n+     * @exception IllegalArgumentException if e is negative\n+     */\n+    public static long pow(final long k, long e)\n+        throws IllegalArgumentException {\n+\n+        if (e < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"cannot raise an integral value to a negative power ({0}^{1})\",\n+                k, e);\n+        }\n+\n+        long result = 1l;\n+        long k2p    = k;\n+        while (e != 0) {\n+            if ((e & 0x1) != 0) {\n+                result *= k2p;\n+            }\n+            k2p *= k2p;\n+            e = e >> 1;\n+        }\n+\n+        return result;\n+\n+    }\n+\n+    /**\n+     * Raise a BigInteger to an int power.\n+     * @param k number to raise\n+     * @param e exponent (must be positive or null)\n+     * @return k<sup>e</sup>\n+     * @exception IllegalArgumentException if e is negative\n+     */\n+    public static BigInteger pow(final BigInteger k, int e)\n+        throws IllegalArgumentException {\n+\n+        if (e < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"cannot raise an integral value to a negative power ({0}^{1})\",\n+                k, e);\n+        }\n+\n+        return k.pow(e);\n+\n+    }\n+\n+    /**\n+     * Raise a BigInteger to a long power.\n+     * @param k number to raise\n+     * @param e exponent (must be positive or null)\n+     * @return k<sup>e</sup>\n+     * @exception IllegalArgumentException if e is negative\n+     */\n+    public static BigInteger pow(final BigInteger k, long e)\n+        throws IllegalArgumentException {\n+\n+        if (e < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"cannot raise an integral value to a negative power ({0}^{1})\",\n+                k, e);\n+        }\n+\n+        BigInteger result = BigInteger.ONE;\n+        BigInteger k2p    = k;\n+        while (e != 0) {\n+            if ((e & 0x1) != 0) {\n+                result = result.multiply(k2p);\n+            }\n+            k2p = k2p.multiply(k2p);\n+            e = e >> 1;\n+        }\n+\n+        return result;\n+\n+    }\n+\n+    /**\n+     * Raise a BigInteger to a BigInteger power.\n+     * @param k number to raise\n+     * @param e exponent (must be positive or null)\n+     * @return k<sup>e</sup>\n+     * @exception IllegalArgumentException if e is negative\n+     */\n+    public static BigInteger pow(final BigInteger k, BigInteger e)\n+        throws IllegalArgumentException {\n+\n+        if (e.compareTo(BigInteger.ZERO) < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"cannot raise an integral value to a negative power ({0}^{1})\",\n+                k, e);\n+        }\n+\n+        BigInteger result = BigInteger.ONE;\n+        BigInteger k2p    = k;\n+        while (!BigInteger.ZERO.equals(e)) {\n+            if (e.testBit(0)) {\n+                result = result.multiply(k2p);\n+            }\n+            k2p = k2p.multiply(k2p);\n+            e = e.shiftRight(1);\n+        }\n+\n+        return result;\n+\n+    }\n+\n+    /**\n+     * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n+     *\n+     * @param p1 the first point\n+     * @param p2 the second point\n+     * @return the L<sub>1</sub> distance between the two points\n+     */\n+    public static final double distance1(double[] p1, double[] p2) {\n+        double sum = 0;\n+        for (int i = 0; i < p1.length; i++) {\n+            sum += Math.abs(p1[i] - p2[i]);\n+        }\n+        return sum;\n+    }\n+    \n+    /**\n+     * Calculates the L<sub>1</sub> (sum of abs) distance between two points.\n+     *\n+     * @param p1 the first point\n+     * @param p2 the second point\n+     * @return the L<sub>1</sub> distance between the two points\n+     */\n+    public static final int distance1(int[] p1, int[] p2) {\n+      int sum = 0;\n+      for (int i = 0; i < p1.length; i++) {\n+          sum += Math.abs(p1[i] - p2[i]);\n+      }\n+      return sum;\n+    }\n+\n+    /**\n+     * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n+     *\n+     * @param p1 the first point\n+     * @param p2 the second point\n+     * @return the L<sub>2</sub> distance between the two points\n+     */\n+    public static final double distance(double[] p1, double[] p2) {\n+        double sum = 0;\n+        for (int i = 0; i < p1.length; i++) {\n+            final double dp = p1[i] - p2[i];\n+            sum += dp * dp;\n+        }\n+        return Math.sqrt(sum);\n+    }\n+    \n+    /**\n+     * Calculates the L<sub>2</sub> (Euclidean) distance between two points.\n+     *\n+     * @param p1 the first point\n+     * @param p2 the second point\n+     * @return the L<sub>2</sub> distance between the two points\n+     */\n+    public static final double distance(int[] p1, int[] p2) {\n+      int sum = 0;\n+      for (int i = 0; i < p1.length; i++) {\n+          final int dp = p1[i] - p2[i];\n+          sum += dp * dp;\n+      }\n+      return Math.sqrt(sum);\n+    }\n+    \n+    /**\n+     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n+     *\n+     * @param p1 the first point\n+     * @param p2 the second point\n+     * @return the L<sub>&infin;</sub> distance between the two points\n+     */\n+    public static final double distanceInf(double[] p1, double[] p2) {\n+        double max = 0;\n+        for (int i = 0; i < p1.length; i++) {\n+            max = Math.max(max, Math.abs(p1[i] - p2[i]));\n+        }\n+        return max;\n+    }\n+    \n+    /**\n+     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n+     *\n+     * @param p1 the first point\n+     * @param p2 the second point\n+     * @return the L<sub>&infin;</sub> distance between the two points\n+     */\n+    public static final int distanceInf(int[] p1, int[] p2) {\n+        int max = 0;\n+        for (int i = 0; i < p1.length; i++) {\n+            max = Math.max(max, Math.abs(p1[i] - p2[i]));\n+        }\n+        return max;\n+    }\n+\n+    \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/NumberTransformer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Subclasses implementing this interface can transform Objects to doubles.\n+ * @version $Revision$ $Date$\n+ * \n+ * No longer extends Serializable since 2.0\n+ * \n+ */\n+public interface NumberTransformer {\n+    \n+    /**\n+     * Implementing this interface provides a facility to transform\n+     * from Object to Double.\n+     * \n+     * @param o the Object to be transformed.\n+     * @return the double value of the Object.\n+     * @throws MathException if the Object can not be transformed into a Double. \n+     */\n+    double transform(Object o) throws MathException;\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/OpenIntToDoubleHashMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.util;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.Serializable;\n+import java.util.ConcurrentModificationException;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Open addressed map from int to double.\n+ * <p>This class provides a dedicated map from integers to doubles with a\n+ * much smaller memory overhead than standard <code>java.util.Map</code>.</p>\n+ * <p>This class is not synchronized. The specialized iterators returned by\n+ * {@link #iterator()} are fail-fast: they throw a\n+ * <code>ConcurrentModificationException</code> when they detect the map has been\n+ * modified during iteration.</p>\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class OpenIntToDoubleHashMap implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -3646337053166149105L;\n+\n+    /** Load factor for the map. */\n+    private static final float LOAD_FACTOR = 0.5f;\n+\n+    /** Default starting size.\n+     * <p>This must be a power of two for bit mask to work properly. </p>\n+     */\n+    private static final int DEFAULT_EXPECTED_SIZE = 16;\n+\n+    /** Multiplier for size growth when map fills up.\n+     * <p>This must be a power of two for bit mask to work properly. </p>\n+     */\n+    private static final int RESIZE_MULTIPLIER = 2;\n+\n+    /** Number of bits to perturb the index when probing for collision resolution. */\n+    private static final int PERTURB_SHIFT = 5;\n+\n+    /** Status indicator for free table entries. */\n+    protected static final byte FREE    = 0;\n+\n+    /** Status indicator for full table entries. */\n+    protected static final byte FULL    = 1;\n+\n+    /** Status indicator for removed table entries. */\n+    protected static final byte REMOVED = 2;\n+\n+    /** Keys table. */\n+    private int[] keys;\n+\n+    /** Values table. */\n+    private double[] values;\n+\n+    /** States table. */\n+    private byte[] states;\n+\n+    /** Return value for missing entries. */\n+    private final double missingEntries;\n+\n+    /** Current size of the map. */\n+    private int size;\n+\n+    /** Bit mask for hash values. */\n+    private int mask;\n+\n+    /** Modifications count. */\n+    private transient int count;\n+\n+    /**\n+     * Build an empty map with default size and using NaN for missing entries.\n+     */\n+    public OpenIntToDoubleHashMap() {\n+        this(DEFAULT_EXPECTED_SIZE, Double.NaN);\n+    }\n+\n+    /**\n+     * Build an empty map with default size\n+     * @param missingEntries value to return when a missing entry is fetched\n+     */\n+    public OpenIntToDoubleHashMap(final double missingEntries) {\n+        this(DEFAULT_EXPECTED_SIZE, missingEntries);\n+    }\n+\n+    /**\n+     * Build an empty map with specified size and using NaN for missing entries.\n+     * @param expectedSize expected number of elements in the map\n+     */\n+    public OpenIntToDoubleHashMap(final int expectedSize) {\n+        this(expectedSize, Double.NaN);\n+    }\n+\n+    /**\n+     * Build an empty map with specified size.\n+     * @param expectedSize expected number of elements in the map\n+     * @param missingEntries value to return when a missing entry is fetched\n+     */\n+    public OpenIntToDoubleHashMap(final int expectedSize,\n+                                  final double missingEntries) {\n+        final int capacity = computeCapacity(expectedSize);\n+        keys   = new int[capacity];\n+        values = new double[capacity];\n+        states = new byte[capacity];\n+        this.missingEntries = missingEntries;\n+        mask   = capacity - 1;\n+    }\n+\n+    /**\n+     * Copy constructor.\n+     * @param source map to copy\n+     */\n+    public OpenIntToDoubleHashMap(final OpenIntToDoubleHashMap source) {\n+        final int length = source.keys.length;\n+        keys = new int[length];\n+        System.arraycopy(source.keys, 0, keys, 0, length);\n+        values = new double[length];\n+        System.arraycopy(source.values, 0, values, 0, length);\n+        states = new byte[length];\n+        System.arraycopy(source.states, 0, states, 0, length);\n+        missingEntries = source.missingEntries;\n+        size  = source.size;\n+        mask  = source.mask;\n+        count = source.count;\n+    }\n+\n+    /**\n+     * Compute the capacity needed for a given size.\n+     * @param expectedSize expected size of the map\n+     * @return capacity to use for the specified size\n+     */\n+    private static int computeCapacity(final int expectedSize) {\n+        if (expectedSize == 0) {\n+            return 1;\n+        }\n+        final int capacity   = (int) Math.ceil(expectedSize / LOAD_FACTOR);\n+        final int powerOfTwo = Integer.highestOneBit(capacity);\n+        if (powerOfTwo == capacity) {\n+            return capacity;\n+        }\n+        return nextPowerOfTwo(capacity);\n+    }\n+\n+    /**\n+     * Find the smallest power of two greater than the input value\n+     * @param i input value\n+     * @return smallest power of two greater than the input value\n+     */\n+    private static int nextPowerOfTwo(final int i) {\n+        return Integer.highestOneBit(i) << 1;\n+    }\n+\n+    /**\n+     * Get the stored value associated with the given key\n+     * @param key key associated with the data\n+     * @return data associated with the key\n+     */\n+    public double get(final int key) {\n+\n+        final int hash  = hashOf(key);\n+        int index = hash & mask;\n+        if (containsKey(key, index)) {\n+            return values[index];\n+        }\n+\n+        if (states[index] == FREE) {\n+            return missingEntries;\n+        }\n+\n+        for (int perturb = perturb(hash), j = index; states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n+            j = probe(perturb, j);\n+            index = j & mask;\n+            if (containsKey(key, index)) {\n+                return values[index];\n+            }\n+        }\n+\n+        return missingEntries;\n+\n+    }\n+\n+    /**\n+     * Check if a value is associated with a key.\n+     * @param key key to check\n+     * @return true if a value is associated with key\n+     */\n+    public boolean containsKey(final int key) {\n+\n+        final int hash  = hashOf(key);\n+        int index = hash & mask;\n+        if (containsKey(key, index)) {\n+            return true;\n+        }\n+\n+        if (states[index] == FREE) {\n+            return false;\n+        }\n+\n+        for (int perturb = perturb(hash), j = index; states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n+            j = probe(perturb, j);\n+            index = j & mask;\n+            if (containsKey(key, index)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+\n+    }\n+\n+    /**\n+     * Get an iterator over map elements.\n+     * <p>The specialized iterators returned are fail-fast: they throw a\n+     * <code>ConcurrentModificationException</code> when they detect the map\n+     * has been modified during iteration.</p>\n+     * @return iterator over the map elements\n+     */\n+    public Iterator iterator() {\n+        return new Iterator();\n+    }\n+\n+    /**\n+     * Perturb the hash for starting probing.\n+     * @param hash initial hash\n+     * @return perturbed hash\n+     */\n+    private static int perturb(final int hash) {\n+        return hash & 0x7fffffff;\n+    }\n+\n+    /**\n+     * Find the index at which a key should be inserted\n+     * @param key key to lookup\n+     * @return index at which key should be inserted\n+     */\n+    private int findInsertionIndex(final int key) {\n+        return findInsertionIndex(keys, states, key, mask);\n+    }\n+\n+    /**\n+     * Find the index at which a key should be inserted\n+     * @param keys keys table\n+     * @param states states table\n+     * @param key key to lookup\n+     * @param mask bit mask for hash values\n+     * @return index at which key should be inserted\n+     */\n+    private static int findInsertionIndex(final int[] keys, final byte[] states,\n+                                          final int key, final int mask) {\n+        final int hash = hashOf(key);\n+        int index = hash & mask;\n+        if (states[index] == FREE) {\n+            return index;\n+        } else if (states[index] == FULL && keys[index] == key) {\n+            return changeIndexSign(index);\n+        }\n+\n+        int perturb = perturb(hash);\n+        int j = index;\n+        if (states[index] == FULL) {\n+            while (true) {\n+                j = probe(perturb, j);\n+                index = j & mask;\n+                perturb >>= PERTURB_SHIFT;\n+                \n+                if (states[index] != FULL || keys[index] == key) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (states[index] == FREE) {\n+            return index;\n+        } else if (states[index] == FULL) {\n+            // due to the loop exit condition,\n+            // if (states[index] == FULL) then keys[index] == key\n+            return changeIndexSign(index);\n+        }\n+\n+        final int firstRemoved = index;\n+        while (true) {\n+            j = probe(perturb, j);\n+            index = j & mask;\n+\n+            if (states[index] == FREE) {\n+                return firstRemoved;\n+            } else if (states[index] == FULL && keys[index] == key) {\n+                return changeIndexSign(index);\n+            }\n+\n+            perturb >>= PERTURB_SHIFT;\n+\n+        }\n+\n+    }\n+\n+    /**\n+     * Compute next probe for collision resolution\n+     * @param perturb perturbed hash\n+     * @param j previous probe\n+     * @return next probe\n+     */\n+    private static int probe(final int perturb, final int j) {\n+        return (j << 2) + j + perturb + 1;\n+    }\n+\n+    /**\n+     * Change the index sign\n+     * @param index initial index\n+     * @return changed index\n+     */\n+    private static int changeIndexSign(final int index) {\n+        return -index - 1;\n+    }\n+\n+    /**\n+     * Get the number of elements stored in the map.\n+     * @return number of elements stored in the map\n+     */\n+    public int size() {\n+        return size;\n+    }\n+\n+    \n+    /**\n+     * Remove the value associated with a key.\n+     * @param key key to which the value is associated\n+     * @return removed value\n+     */\n+    public double remove(final int key) {\n+\n+        final int hash  = hashOf(key);\n+        int index = hash & mask;\n+        if (containsKey(key, index)) {\n+            return doRemove(index);\n+        }\n+\n+        if (states[index] == FREE) {\n+            return missingEntries;\n+        }\n+\n+        for (int perturb = perturb(hash), j = index; states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n+            j = probe(perturb, j);\n+            index = j & mask;\n+            if (containsKey(key, index)) {\n+                return doRemove(index);\n+            }\n+        }\n+\n+        return missingEntries;\n+\n+    }\n+\n+    /**\n+     * Check if the tables contain an element associated with specified key\n+     * at specified index.\n+     * @param key key to check\n+     * @param index index to check\n+     * @return true if an element is associated with key at index\n+     */\n+    private boolean containsKey(final int key, final int index) {\n+        return (key != 0 || states[index] == FULL) && keys[index] == key;\n+    }\n+\n+    /**\n+     * Remove an element at specified index.\n+     * @param index index of the element to remove\n+     * @return removed value\n+     */\n+    private double doRemove(int index) {\n+        keys[index]   = 0;\n+        states[index] = REMOVED;\n+        final double previous = values[index];\n+        values[index] = missingEntries;\n+        --size;\n+        ++count;\n+        return previous;\n+    }\n+\n+    /**\n+     * Put a value associated with a key in the map.\n+     * @param key key to which value is associated\n+     * @param value value to put in the map\n+     * @return previous value associated with the key\n+     */\n+    public double put(final int key, final double value) {\n+        int index = findInsertionIndex(key);\n+        double previous = missingEntries;\n+        boolean newMapping = true;\n+        if (index < 0) {\n+            index = changeIndexSign(index);\n+            previous = values[index];\n+            newMapping = false;\n+        }\n+        keys[index]   = key;\n+        states[index] = FULL;\n+        values[index] = value;\n+        if (newMapping) {\n+            ++size;\n+            if (shouldGrowTable()) {\n+                growTable();\n+            }\n+            ++count;\n+        }\n+        return previous;\n+\n+    }\n+\n+    /**\n+     * Grow the tables.\n+     */\n+    private void growTable() {\n+\n+        final int oldLength      = states.length;\n+        final int[] oldKeys      = keys;\n+        final double[] oldValues = values;\n+        final byte[] oldStates   = states;\n+\n+        final int newLength = RESIZE_MULTIPLIER * oldLength;\n+        final int[] newKeys = new int[newLength];\n+        final double[] newValues = new double[newLength];\n+        final byte[] newStates = new byte[newLength];\n+        final int newMask = newLength - 1;\n+        for (int i = 0; i < oldLength; ++i) {\n+            if (oldStates[i] == FULL) {\n+                final int key = oldKeys[i];\n+                final int index = findInsertionIndex(newKeys, newStates, key, newMask);\n+                newKeys[index]   = key;\n+                newValues[index] = oldValues[i];\n+                newStates[index] = FULL;\n+            }\n+        }\n+\n+        mask   = newMask;\n+        keys   = newKeys;\n+        values = newValues;\n+        states = newStates;\n+\n+    }\n+\n+    /**\n+     * Check if tables should grow due to increased size.\n+     * @return true if  tables should grow\n+     */\n+    private boolean shouldGrowTable() {\n+        return size > (mask + 1) * LOAD_FACTOR;\n+    }\n+\n+    /**\n+     * Compute the hash value of a key\n+     * @param key key to hash\n+     * @return hash value of the key\n+     */\n+    private static int hashOf(final int key) {\n+        final int h = key ^ ((key >>> 20) ^ (key >>> 12));\n+        return h ^ (h >>> 7) ^ (h >>> 4);\n+    }\n+\n+    \n+    /** Iterator class for the map. */\n+    public class Iterator {\n+\n+        /** Reference modification count. */\n+        private final int referenceCount;\n+\n+        /** Index of current element. */\n+        private int current;\n+\n+        /** Index of next element. */\n+        private int next;\n+\n+        /**\n+         * Simple constructor.\n+         */\n+        private Iterator() {\n+\n+            // preserve the modification count of the map to detect concurrent modifications later\n+            referenceCount = count;\n+\n+            // initialize current index\n+            next = -1;\n+            try {\n+                advance();\n+            } catch (NoSuchElementException nsee) {\n+                // ignored\n+            }\n+\n+        }\n+\n+        /**\n+         * Check if there is a next element in the map.\n+         * @return true if there is a next element\n+         */\n+        public boolean hasNext() {\n+            return next >= 0;\n+        }\n+\n+        /**\n+         * Get the key of current entry.\n+         * @return key of current entry\n+         * @exception ConcurrentModificationException if the map is modified during iteration\n+         * @exception NoSuchElementException if there is no element left in the map\n+         */\n+        public int key()\n+            throws ConcurrentModificationException, NoSuchElementException {\n+            if (referenceCount != count) {\n+                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\");\n+            }\n+            if (current < 0) {\n+                throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\");\n+            }\n+            return keys[current];\n+        }\n+\n+        /**\n+         * Get the value of current entry.\n+         * @return value of current entry\n+         * @exception ConcurrentModificationException if the map is modified during iteration\n+         * @exception NoSuchElementException if there is no element left in the map\n+         */\n+        public double value()\n+            throws ConcurrentModificationException, NoSuchElementException {\n+            if (referenceCount != count) {\n+                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\");\n+            }\n+            if (current < 0) {\n+                throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\");\n+            }\n+            return values[current];\n+        }\n+\n+        /**\n+         * Advance iterator one step further.\n+         * @exception ConcurrentModificationException if the map is modified during iteration\n+         * @exception NoSuchElementException if there is no element left in the map\n+         */\n+        public void advance()\n+            throws ConcurrentModificationException, NoSuchElementException {\n+\n+            if (referenceCount != count) {\n+                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\");\n+            }\n+\n+            // advance on step\n+            current = next;\n+\n+            // prepare next step\n+            try {\n+                while (states[++next] != FULL) {\n+                    // nothing to do\n+                }\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                next = -2;\n+                if (current < 0) {\n+                    throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\");\n+                }\n+            }\n+\n+        }\n+\n+    }\n+\n+    /**\n+     * Read a serialized object.\n+     * @param stream input stream\n+     * @throws IOException if object cannot be read\n+     * @throws ClassNotFoundException if the class corresponding\n+     * to the serialized object cannot be found\n+     */\n+    private void readObject(final ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        count = 0;\n+    }\n+\n+            \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/OpenIntToFieldHashMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.Serializable;\n+import java.lang.reflect.Array;\n+import java.util.ConcurrentModificationException;\n+import java.util.NoSuchElementException;\n+\n+import org.apache.commons.math.Field;\n+import org.apache.commons.math.FieldElement;\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * Open addressed map from int to FieldElement.\n+ * <p>This class provides a dedicated map from integers to FieldElements with a\n+ * much smaller memory overhead than standard <code>java.util.Map</code>.</p>\n+ * <p>This class is not synchronized. The specialized iterators returned by\n+ * {@link #iterator()} are fail-fast: they throw a\n+ * <code>ConcurrentModificationException</code> when they detect the map has been\n+ * modified during iteration.</p>\n+ * @param <T> the type of the field elements\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class OpenIntToFieldHashMap<T extends FieldElement<T>> implements Serializable {\n+    \n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -9179080286849120720L;\n+\n+    /** Load factor for the map. */\n+    private static final float LOAD_FACTOR = 0.5f;\n+\n+    /** Default starting size.\n+     * <p>This must be a power of two for bit mask to work properly. </p>\n+     */\n+    private static final int DEFAULT_EXPECTED_SIZE = 16;\n+\n+    /** Multiplier for size growth when map fills up.\n+     * <p>This must be a power of two for bit mask to work properly. </p>\n+     */\n+    private static final int RESIZE_MULTIPLIER = 2;\n+\n+    /** Number of bits to perturb the index when probing for collision resolution. */\n+    private static final int PERTURB_SHIFT = 5;\n+\n+    /** Status indicator for free table entries. */\n+    protected static final byte FREE    = 0;\n+\n+    /** Status indicator for full table entries. */\n+    protected static final byte FULL    = 1;\n+\n+    /** Status indicator for removed table entries. */\n+    protected static final byte REMOVED = 2;\n+\n+    /** Field to which the elements belong. */\n+    private final Field<T> field;\n+    \n+    /** Keys table. */\n+    private int[] keys;\n+\n+    /** Values table. */\n+    private T[] values;\n+\n+    /** States table. */\n+    private byte[] states;\n+\n+    /** Return value for missing entries. */\n+    private final T missingEntries;\n+\n+    /** Current size of the map. */\n+    private int size;\n+\n+    /** Bit mask for hash values. */\n+    private int mask;\n+\n+    /** Modifications count. */\n+    private transient int count;\n+\n+    /**\n+     * Build an empty map with default size and using zero for missing entries.\n+     * @param field field to which the elements belong\n+     */\n+    public OpenIntToFieldHashMap(final Field<T>field) {\n+        this(field, DEFAULT_EXPECTED_SIZE, field.getZero());\n+    }\n+\n+    /**\n+     * Build an empty map with default size\n+     * @param field field to which the elements belong\n+     * @param missingEntries value to return when a missing entry is fetched\n+     */\n+    public OpenIntToFieldHashMap(final Field<T>field, final T missingEntries) {\n+        this(field,DEFAULT_EXPECTED_SIZE, missingEntries);\n+    }\n+\n+    /**\n+     * Build an empty map with specified size and using zero for missing entries.\n+     * @param field field to which the elements belong\n+     * @param expectedSize expected number of elements in the map\n+     */\n+    public OpenIntToFieldHashMap(final Field<T> field,final int expectedSize) {\n+        this(field,expectedSize, field.getZero());\n+    }\n+\n+    /**\n+     * Build an empty map with specified size.\n+     * @param field field to which the elements belong\n+     * @param expectedSize expected number of elements in the map\n+     * @param missingEntries value to return when a missing entry is fetched\n+     */\n+    public OpenIntToFieldHashMap(final Field<T> field,final int expectedSize,\n+                                  final T missingEntries) {\n+        this.field = field;\n+        final int capacity = computeCapacity(expectedSize);\n+        keys   = new int[capacity];\n+        values = buildArray(capacity);\n+        states = new byte[capacity];\n+        this.missingEntries = missingEntries;\n+        mask   = capacity - 1;\n+    }\n+\n+    /**\n+     * Copy constructor.\n+     * @param source map to copy\n+     */\n+    public OpenIntToFieldHashMap(final OpenIntToFieldHashMap<T> source) {\n+        field = source.field;\n+        final int length = source.keys.length;\n+        keys = new int[length];\n+        System.arraycopy(source.keys, 0, keys, 0, length);\n+        values = buildArray(length);\n+        System.arraycopy(source.values, 0, values, 0, length);\n+        states = new byte[length];\n+        System.arraycopy(source.states, 0, states, 0, length);\n+        missingEntries = source.missingEntries;\n+        size  = source.size;\n+        mask  = source.mask;\n+        count = source.count;\n+    }\n+\n+    /**\n+     * Compute the capacity needed for a given size.\n+     * @param expectedSize expected size of the map\n+     * @return capacity to use for the specified size\n+     */\n+    private static int computeCapacity(final int expectedSize) {\n+        if (expectedSize == 0) {\n+            return 1;\n+        }\n+        final int capacity   = (int) Math.ceil(expectedSize / LOAD_FACTOR);\n+        final int powerOfTwo = Integer.highestOneBit(capacity);\n+        if (powerOfTwo == capacity) {\n+            return capacity;\n+        }\n+        return nextPowerOfTwo(capacity);\n+    }\n+\n+    /**\n+     * Find the smallest power of two greater than the input value\n+     * @param i input value\n+     * @return smallest power of two greater than the input value\n+     */\n+    private static int nextPowerOfTwo(final int i) {\n+        return Integer.highestOneBit(i) << 1;\n+    }\n+\n+    /**\n+     * Get the stored value associated with the given key\n+     * @param key key associated with the data\n+     * @return data associated with the key\n+     */\n+    public T get(final int key) {\n+\n+        final int hash  = hashOf(key);\n+        int index = hash & mask;\n+        if (containsKey(key, index)) {\n+            return values[index];\n+        }\n+\n+        if (states[index] == FREE) {\n+            return missingEntries;\n+        }\n+\n+        for (int perturb = perturb(hash), j = index; states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n+            j = probe(perturb, j);\n+            index = j & mask;\n+            if (containsKey(key, index)) {\n+                return values[index];\n+            }\n+        }\n+\n+        return missingEntries;\n+\n+    }\n+\n+    /**\n+     * Check if a value is associated with a key.\n+     * @param key key to check\n+     * @return true if a value is associated with key\n+     */\n+    public boolean containsKey(final int key) {\n+\n+        final int hash  = hashOf(key);\n+        int index = hash & mask;\n+        if (containsKey(key, index)) {\n+            return true;\n+        }\n+\n+        if (states[index] == FREE) {\n+            return false;\n+        }\n+\n+        for (int perturb = perturb(hash), j = index; states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n+            j = probe(perturb, j);\n+            index = j & mask;\n+            if (containsKey(key, index)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+\n+    }\n+\n+    /**\n+     * Get an iterator over map elements.\n+     * <p>The specialized iterators returned are fail-fast: they throw a\n+     * <code>ConcurrentModificationException</code> when they detect the map\n+     * has been modified during iteration.</p>\n+     * @return iterator over the map elements\n+     */\n+    public Iterator iterator() {\n+        return new Iterator();\n+    }\n+\n+    /**\n+     * Perturb the hash for starting probing.\n+     * @param hash initial hash\n+     * @return perturbed hash\n+     */\n+    private static int perturb(final int hash) {\n+        return hash & 0x7fffffff;\n+    }\n+\n+    /**\n+     * Find the index at which a key should be inserted\n+     * @param key key to lookup\n+     * @return index at which key should be inserted\n+     */\n+    private int findInsertionIndex(final int key) {\n+        return findInsertionIndex(keys, states, key, mask);\n+    }\n+\n+    /**\n+     * Find the index at which a key should be inserted\n+     * @param keys keys table\n+     * @param states states table\n+     * @param key key to lookup\n+     * @param mask bit mask for hash values\n+     * @return index at which key should be inserted\n+     */\n+    private static int findInsertionIndex(final int[] keys, final byte[] states,\n+                                          final int key, final int mask) {\n+        final int hash = hashOf(key);\n+        int index = hash & mask;\n+        if (states[index] == FREE) {\n+            return index;\n+        } else if (states[index] == FULL && keys[index] == key) {\n+            return changeIndexSign(index);\n+        }\n+\n+        int perturb = perturb(hash);\n+        int j = index;\n+        if (states[index] == FULL) {\n+            while (true) {\n+                j = probe(perturb, j);\n+                index = j & mask;\n+                perturb >>= PERTURB_SHIFT;\n+                \n+                if (states[index] != FULL || keys[index] == key) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (states[index] == FREE) {\n+            return index;\n+        } else if (states[index] == FULL) {\n+            // due to the loop exit condition,\n+            // if (states[index] == FULL) then keys[index] == key\n+            return changeIndexSign(index);\n+        }\n+\n+        final int firstRemoved = index;\n+        while (true) {\n+            j = probe(perturb, j);\n+            index = j & mask;\n+\n+            if (states[index] == FREE) {\n+                return firstRemoved;\n+            } else if (states[index] == FULL && keys[index] == key) {\n+                return changeIndexSign(index);\n+            }\n+\n+            perturb >>= PERTURB_SHIFT;\n+\n+        }\n+\n+    }\n+\n+    /**\n+     * Compute next probe for collision resolution\n+     * @param perturb perturbed hash\n+     * @param j previous probe\n+     * @return next probe\n+     */\n+    private static int probe(final int perturb, final int j) {\n+        return (j << 2) + j + perturb + 1;\n+    }\n+\n+    /**\n+     * Change the index sign\n+     * @param index initial index\n+     * @return changed index\n+     */\n+    private static int changeIndexSign(final int index) {\n+        return -index - 1;\n+    }\n+\n+    /**\n+     * Get the number of elements stored in the map.\n+     * @return number of elements stored in the map\n+     */\n+    public int size() {\n+        return size;\n+    }\n+\n+    \n+    /**\n+     * Remove the value associated with a key.\n+     * @param key key to which the value is associated\n+     * @return removed value\n+     */\n+    public T remove(final int key) {\n+\n+        final int hash  = hashOf(key);\n+        int index = hash & mask;\n+        if (containsKey(key, index)) {\n+            return doRemove(index);\n+        }\n+\n+        if (states[index] == FREE) {\n+            return missingEntries;\n+        }\n+\n+        for (int perturb = perturb(hash), j = index; states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n+            j = probe(perturb, j);\n+            index = j & mask;\n+            if (containsKey(key, index)) {\n+                return doRemove(index);\n+            }\n+        }\n+\n+        return missingEntries;\n+\n+    }\n+\n+    /**\n+     * Check if the tables contain an element associated with specified key\n+     * at specified index.\n+     * @param key key to check\n+     * @param index index to check\n+     * @return true if an element is associated with key at index\n+     */\n+    private boolean containsKey(final int key, final int index) {\n+        return (key != 0 || states[index] == FULL) && keys[index] == key;\n+    }\n+\n+    /**\n+     * Remove an element at specified index.\n+     * @param index index of the element to remove\n+     * @return removed value\n+     */\n+    private T doRemove(int index) {\n+        keys[index]   = 0;\n+        states[index] = REMOVED;\n+        final T previous = values[index];\n+        values[index] = missingEntries;\n+        --size;\n+        ++count;\n+        return previous;\n+    }\n+\n+    /**\n+     * Put a value associated with a key in the map.\n+     * @param key key to which value is associated\n+     * @param value value to put in the map\n+     * @return previous value associated with the key\n+     */\n+    public T put(final int key, final T value) {\n+        int index = findInsertionIndex(key);\n+        T previous = missingEntries;\n+        boolean newMapping = true;\n+        if (index < 0) {\n+            index = changeIndexSign(index);\n+            previous = values[index];\n+            newMapping = false;\n+        }\n+        keys[index]   = key;\n+        states[index] = FULL;\n+        values[index] = value;\n+        if (newMapping) {\n+            ++size;\n+            if (shouldGrowTable()) {\n+                growTable();\n+            }\n+            ++count;\n+        }\n+        return previous;\n+\n+    }\n+\n+    /**\n+     * Grow the tables.\n+     */\n+    private void growTable() {\n+\n+        final int oldLength      = states.length;\n+        final int[] oldKeys      = keys;\n+        final T[] oldValues = values;\n+        final byte[] oldStates   = states;\n+\n+        final int newLength = RESIZE_MULTIPLIER * oldLength;\n+        final int[] newKeys = new int[newLength];\n+        final T[] newValues = buildArray(newLength);\n+        final byte[] newStates = new byte[newLength];\n+        final int newMask = newLength - 1;\n+        for (int i = 0; i < oldLength; ++i) {\n+            if (oldStates[i] == FULL) {\n+                final int key = oldKeys[i];\n+                final int index = findInsertionIndex(newKeys, newStates, key, newMask);\n+                newKeys[index]   = key;\n+                newValues[index] = oldValues[i];\n+                newStates[index] = FULL;\n+            }\n+        }\n+\n+        mask   = newMask;\n+        keys   = newKeys;\n+        values = newValues;\n+        states = newStates;\n+\n+    }\n+\n+    /**\n+     * Check if tables should grow due to increased size.\n+     * @return true if  tables should grow\n+     */\n+    private boolean shouldGrowTable() {\n+        return size > (mask + 1) * LOAD_FACTOR;\n+    }\n+\n+    /**\n+     * Compute the hash value of a key\n+     * @param key key to hash\n+     * @return hash value of the key\n+     */\n+    private static int hashOf(final int key) {\n+        final int h = key ^ ((key >>> 20) ^ (key >>> 12));\n+        return h ^ (h >>> 7) ^ (h >>> 4);\n+    }\n+\n+    \n+    /** Iterator class for the map. */\n+    public class Iterator {\n+\n+        /** Reference modification count. */\n+        private final int referenceCount;\n+\n+        /** Index of current element. */\n+        private int current;\n+\n+        /** Index of next element. */\n+        private int next;\n+\n+        /**\n+         * Simple constructor.\n+         */\n+        private Iterator() {\n+\n+            // preserve the modification count of the map to detect concurrent modifications later\n+            referenceCount = count;\n+\n+            // initialize current index\n+            next = -1;\n+            try {\n+                advance();\n+            } catch (NoSuchElementException nsee) {\n+                // ignored\n+            }\n+\n+        }\n+\n+        /**\n+         * Check if there is a next element in the map.\n+         * @return true if there is a next element\n+         */\n+        public boolean hasNext() {\n+            return next >= 0;\n+        }\n+\n+        /**\n+         * Get the key of current entry.\n+         * @return key of current entry\n+         * @exception ConcurrentModificationException if the map is modified during iteration\n+         * @exception NoSuchElementException if there is no element left in the map\n+         */\n+        public int key()\n+            throws ConcurrentModificationException, NoSuchElementException {\n+            if (referenceCount != count) {\n+                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\");\n+            }\n+            if (current < 0) {\n+                throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\");\n+            }\n+            return keys[current];\n+        }\n+\n+        /**\n+         * Get the value of current entry.\n+         * @return value of current entry\n+         * @exception ConcurrentModificationException if the map is modified during iteration\n+         * @exception NoSuchElementException if there is no element left in the map\n+         */\n+        public T value()\n+            throws ConcurrentModificationException, NoSuchElementException {\n+            if (referenceCount != count) {\n+                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\");\n+            }\n+            if (current < 0) {\n+                throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\");\n+            }\n+            return values[current];\n+        }\n+\n+        /**\n+         * Advance iterator one step further.\n+         * @exception ConcurrentModificationException if the map is modified during iteration\n+         * @exception NoSuchElementException if there is no element left in the map\n+         */\n+        public void advance()\n+            throws ConcurrentModificationException, NoSuchElementException {\n+\n+            if (referenceCount != count) {\n+                throw MathRuntimeException.createConcurrentModificationException(\"map has been modified while iterating\");\n+            }\n+\n+            // advance on step\n+            current = next;\n+\n+            // prepare next step\n+            try {\n+                while (states[++next] != FULL) {\n+                    // nothing to do\n+                }\n+            } catch (ArrayIndexOutOfBoundsException e) {\n+                next = -2;\n+                if (current < 0) {\n+                    throw MathRuntimeException.createNoSuchElementException(\"iterator exhausted\");\n+                }\n+            }\n+\n+        }\n+\n+    }\n+\n+    /**\n+     * Read a serialized object.\n+     * @param stream input stream\n+     * @throws IOException if object cannot be read\n+     * @throws ClassNotFoundException if the class corresponding\n+     * to the serialized object cannot be found\n+     */\n+    private void readObject(final ObjectInputStream stream)\n+        throws IOException, ClassNotFoundException {\n+        stream.defaultReadObject();\n+        count = 0;\n+    }\n+\n+    /** Build an array of elements.\n+     * @param length size of the array to build\n+     * @return a new array\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    private T[] buildArray(final int length) {\n+        return (T[]) Array.newInstance(field.getZero().getClass(), length);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/ResizableDoubleArray.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.MathRuntimeException;\n+\n+/**\n+ * <p>\n+ * A variable length {@link DoubleArray} implementation that automatically \n+ * handles expanding and contracting its internal storage array as elements \n+ * are added and removed.\n+ * </p>\n+ * <p>\n+ *  The internal storage array starts with capacity determined by the\n+ * <code>initialCapacity</code> property, which can be set by the constructor.\n+ * The default initial capacity is 16.  Adding elements using \n+ * {@link #addElement(double)} appends elements to the end of the array.  When \n+ * there are no open entries at the end of the internal storage array, the \n+ * array is expanded.  The size of the expanded array depends on the \n+ * <code>expansionMode</code> and <code>expansionFactor</code> properties.  \n+ * The <code>expansionMode</code> determines whether the size of the array is \n+ * multiplied by the <code>expansionFactor</code> (MULTIPLICATIVE_MODE) or if \n+ * the expansion is additive (ADDITIVE_MODE -- <code>expansionFactor</code>\n+ * storage locations added).  The default <code>expansionMode</code> is \n+ * MULTIPLICATIVE_MODE and the default <code>expansionFactor</code>\n+ * is 2.0.\n+ * </p>\n+ * <p>\n+ * The {@link #addElementRolling(double)} method adds a new element to the end\n+ * of the internal storage array and adjusts the \"usable window\" of the \n+ * internal array forward by one position (effectively making what was the \n+ * second element the first, and so on).  Repeated activations of this method\n+ * (or activation of {@link #discardFrontElements(int)}) will effectively orphan\n+ * the storage locations at the beginning of the internal storage array.  To\n+ * reclaim this storage, each time one of these methods is activated, the size\n+ * of the internal storage array is compared to the number of addressable \n+ * elements (the <code>numElements</code> property) and if the difference\n+ * is too large, the internal array is contracted to size \n+ * <code>numElements + 1.</code>  The determination of when the internal\n+ * storage array is \"too large\" depends on the <code>expansionMode</code> and\n+ * <code>contractionFactor</code> properties.  If  the <code>expansionMode</code>\n+ * is <code>MULTIPLICATIVE_MODE</code>, contraction is triggered when the\n+ * ratio between storage array length and <code>numElements</code> exceeds\n+ * <code>contractionFactor.</code>  If the <code>expansionMode</code>\n+ * is <code>ADDITIVE_MODE,</code> the number of excess storage locations\n+ * is compared to <code>contractionFactor.</code>  \n+ * </p>\n+ * <p>\n+ * To avoid cycles of expansions and contractions, the \n+ * <code>expansionFactor</code> must not exceed the \n+ * <code>contractionFactor.</code> Constructors and mutators for both of these\n+ * properties enforce this requirement, throwing IllegalArgumentException if it\n+ * is violated.\n+ * </p>\n+ * @version $Revision$ $Date$\n+ */\n+public class ResizableDoubleArray implements DoubleArray, Serializable {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -3485529955529426875L; \n+    \n+    /** additive expansion mode */\n+    public static final int ADDITIVE_MODE = 1;\n+    \n+    /** multiplicative expansion mode */\n+    public static final int MULTIPLICATIVE_MODE = 0;\n+   \n+    /** \n+     * The contraction criteria determines when the internal array will be \n+     * contracted to fit the number of elements contained in the element\n+     *  array + 1.\n+     */\n+    protected float contractionCriteria = 2.5f;\n+\n+    /** \n+     * The expansion factor of the array.  When the array needs to be expanded, \n+     * the new array size will be \n+     * <code>internalArray.length * expansionFactor</code>\n+     * if <code>expansionMode</code> is set to MULTIPLICATIVE_MODE, or\n+     * <code>internalArray.length + expansionFactor</code> if \n+     * <code>expansionMode</code> is set to ADDITIVE_MODE.\n+     */\n+    protected float expansionFactor = 2.0f;\n+    \n+    /**\n+     * Determines whether array expansion by <code>expansionFactor</code>\n+     * is additive or multiplicative.\n+     */\n+    protected int expansionMode = MULTIPLICATIVE_MODE;\n+\n+    /**\n+     * The initial capacity of the array.  Initial capacity is not exposed as a\n+     * property as it is only meaningful when passed to a constructor.\n+     */\n+    protected int initialCapacity = 16;\n+    \n+    /** \n+     * The internal storage array.\n+     */\n+    protected double[] internalArray;\n+\n+    /** \n+     * The number of addressable elements in the array.  Note that this\n+     * has nothing to do with the length of the internal storage array.\n+     */\n+    protected int numElements = 0;\n+\n+    /** \n+     * The position of the first addressable element in the internal storage\n+     * array.  The addressable elements in the array are <code>\n+     * internalArray[startIndex],...,internalArray[startIndex + numElements -1]\n+     * </code>\n+     */\n+    protected int startIndex = 0;\n+\n+    /**\n+     * Create a ResizableArray with default properties.\n+     * <ul>\n+     * <li><code>initialCapacity = 16</code></li>\n+     * <li><code>expansionMode = MULTIPLICATIVE_MODE</code></li>\n+     * <li><code>expansionFactor = 2.5</code></li>\n+     * <li><code>contractionFactor = 2.0</code></li>\n+     * </ul>\n+     */\n+    public ResizableDoubleArray() {\n+        internalArray = new double[initialCapacity];\n+    }\n+\n+    /**\n+     * Create a ResizableArray with the specified initial capacity.  Other\n+     * properties take default values:\n+      * <ul>\n+     * <li><code>expansionMode = MULTIPLICATIVE_MODE</code></li>\n+     * <li><code>expansionFactor = 2.5</code></li>\n+     * <li><code>contractionFactor = 2.0</code></li>\n+     * </ul>\n+     * @param initialCapacity The initial size of the internal storage array\n+     * @throws IllegalArgumentException if initialCapacity is not > 0\n+     */\n+    public ResizableDoubleArray(int initialCapacity) {\n+        setInitialCapacity(initialCapacity);\n+        internalArray = new double[this.initialCapacity];\n+    }\n+\n+    /**\n+     * <p>\n+     * Create a ResizableArray with the specified initial capacity \n+     * and expansion factor.  The remaining properties take default\n+     * values:\n+     * <ul>\n+     * <li><code>expansionMode = MULTIPLICATIVE_MODE</code></li>\n+     * <li><code>contractionFactor = 0.5 + expansionFactor</code></li>\n+     * </ul></p>\n+     * <p>\n+     * Throws IllegalArgumentException if the following conditions are\n+     * not met:\n+     * <ul>\n+     * <li><code>initialCapacity > 0</code></li>\n+     * <li><code>expansionFactor > 1</code></li>\n+     * </ul></p>\n+     * \n+     * @param initialCapacity The initial size of the internal storage array\n+     * @param expansionFactor the array will be expanded based on this \n+     *                        parameter\n+     * @throws IllegalArgumentException if parameters are not valid\n+     */\n+    public ResizableDoubleArray(int initialCapacity, float expansionFactor) {\n+        this.expansionFactor = expansionFactor;\n+        setInitialCapacity(initialCapacity);\n+        internalArray = new double[initialCapacity];\n+        setContractionCriteria(expansionFactor +0.5f);\n+    }\n+\n+    /**\n+     * <p>\n+     * Create a ResizableArray with the specified initialCapacity, \n+     * expansionFactor, and contractionCriteria. The <code>expansionMode</code>\n+     * will default to <code>MULTIPLICATIVE_MODE.</code></p>\n+     * <p>\n+     * Throws IllegalArgumentException if the following conditions are\n+     * not met:\n+     * <ul>\n+     * <li><code>initialCapacity > 0</code></li>\n+     * <li><code>expansionFactor > 1</code></li>\n+     * <li><code>contractionFactor >= expansionFactor</code></li>\n+     * </ul></p>\n+     * @param initialCapacity The initial size of the internal storage array\n+     * @param expansionFactor the array will be expanded based on this \n+     *                        parameter\n+     * @param contractionCriteria The contraction Criteria.\n+     * @throws IllegalArgumentException if parameters are not valid\n+     */\n+    public ResizableDoubleArray(int initialCapacity, float expansionFactor,\n+        float contractionCriteria) {\n+        this.expansionFactor = expansionFactor;\n+        setContractionCriteria(contractionCriteria);\n+        setInitialCapacity(initialCapacity);\n+        internalArray = new double[initialCapacity];\n+    }\n+    \n+    /**\n+     * <p>\n+     * Create a ResizableArray with the specified properties.</p>\n+    * <p>\n+     * Throws IllegalArgumentException if the following conditions are\n+     * not met:\n+     * <ul>\n+     * <li><code>initialCapacity > 0</code></li>\n+     * <li><code>expansionFactor > 1</code></li>\n+     * <li><code>contractionFactor >= expansionFactor</code></li>\n+     * <li><code>expansionMode in {MULTIPLICATIVE_MODE, ADDITIVE_MODE}</code>\n+     * </li>\n+     * </ul></p>\n+     * \n+     * @param initialCapacity the initial size of the internal storage array\n+     * @param expansionFactor the array will be expanded based on this \n+     *                        parameter\n+     * @param contractionCriteria the contraction Criteria\n+     * @param expansionMode  the expansion mode\n+     * @throws IllegalArgumentException if parameters are not valid\n+     */\n+    public ResizableDoubleArray(int initialCapacity, float expansionFactor,\n+            float contractionCriteria, int expansionMode) {\n+        this.expansionFactor = expansionFactor;\n+        setContractionCriteria(contractionCriteria);\n+        setInitialCapacity(initialCapacity);\n+        setExpansionMode(expansionMode);\n+        internalArray = new double[initialCapacity];\n+    }\n+    \n+    /**\n+     * Copy constructor.  Creates a new ResizableDoubleArray that is a deep,\n+     * fresh copy of the original. Needs to acquire synchronization lock\n+     * on original.  Original may not be null; otherwise a NullPointerException\n+     * is thrown.\n+     * \n+     * @param original array to copy\n+     * @since 2.0\n+     */\n+    public ResizableDoubleArray(ResizableDoubleArray original) {\n+        copy(original, this);\n+    }\n+\n+    /**\n+     * Adds an element to the end of this expandable array.\n+     * \n+     * @param value to be added to end of array\n+     */\n+    public synchronized void addElement(double value) {\n+        numElements++;\n+        if ((startIndex + numElements) > internalArray.length) {\n+            expand();\n+        }\n+        internalArray[startIndex + (numElements - 1)] = value;\n+        if (shouldContract()) {\n+            contract();\n+        }\n+    }\n+\n+    /**\n+     * <p>\n+     * Adds an element to the end of the array and removes the first\n+     * element in the array.  Returns the discarded first element.\n+     * The effect is similar to a push operation in a FIFO queue.\n+     * </p>\n+     * <p>\n+     * Example: If the array contains the elements 1, 2, 3, 4 (in that order)\n+     * and addElementRolling(5) is invoked, the result is an array containing\n+     * the entries 2, 3, 4, 5 and the value returned is 1.\n+     * </p>\n+     * \n+     * @param value the value to be added to the array\n+     * @return the value which has been discarded or \"pushed\" out of the array\n+     *         by this rolling insert\n+     */\n+    public synchronized double addElementRolling(double value) {\n+        double discarded = internalArray[startIndex];\n+\n+        if ((startIndex + (numElements + 1)) > internalArray.length) {\n+            expand();\n+        }\n+        // Increment the start index\n+        startIndex += 1;\n+\n+        // Add the new value\n+        internalArray[startIndex + (numElements - 1)] = value;\n+\n+        // Check the contraction criteria\n+        if (shouldContract()) {\n+            contract();\n+        }\n+        return discarded;\n+    }\n+       \n+    /**\n+     * Substitutes <code>value</code> for the most recently added value.\n+     * Returns the value that has been replaced. If the array is empty (i.e. \n+     * if {@link #numElements} is zero), a MathRuntimeException is thrown.\n+     * \n+     * @param value new value to substitute for the most recently added value\n+     * @return value that has been replaced in the array\n+     * @since 2.0\n+     */\n+    public synchronized double substituteMostRecentElement(double value) {\n+        if (numElements < 1) {\n+            throw MathRuntimeException.createArrayIndexOutOfBoundsException(\n+                    \"cannot substitute an element from an empty array\");\n+        }\n+\n+        double discarded = internalArray[startIndex + (numElements - 1)];\n+\n+        internalArray[startIndex + (numElements - 1)] = value;\n+\n+        return discarded;\n+    }\n+\n+    \n+    /**\n+     * Checks the expansion factor and the contraction criteria and throws an \n+     * IllegalArgumentException if the contractionCriteria is less than the \n+     * expansionCriteria\n+     * \n+     * @param expansionFactor factor to be checked\n+     * @param contractionCriteria criteria to be checked\n+     * @throws IllegalArgumentException if the contractionCriteria is less than\n+     *         the expansionCriteria.\n+     */\n+    protected void checkContractExpand(\n+        float contractionCriteria,\n+        float expansionFactor) {\n+\n+        if (contractionCriteria < expansionFactor) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"contraction criteria ({0}) smaller than the expansion factor ({1}).  This would \" +\n+                    \"lead to a never ending loop of expansion and contraction as a newly expanded \" +\n+                    \"internal storage array would immediately satisfy the criteria for contraction\",\n+                    contractionCriteria, expansionFactor);\n+        }\n+\n+        if (contractionCriteria <= 1.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"contraction criteria smaller than one ({0}).  This would lead to a never ending \" +\n+                    \"loop of expansion and contraction as an internal storage array length equal \" +\n+                    \"to the number of elements would satisfy the contraction criteria.\",\n+                    contractionCriteria);\n+        }\n+\n+        if (expansionFactor <= 1.0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"expansion factor smaller than one ({0})\",\n+                    expansionFactor);\n+        }\n+    }\n+    \n+    /**\n+     * Clear the array, reset the size to the initialCapacity and the number \n+     * of elements to zero.\n+     */\n+    public synchronized void clear() {\n+        numElements = 0;\n+        startIndex = 0;\n+        internalArray = new double[initialCapacity];\n+    }\n+    \n+    /**\n+     * Contracts the storage array to the (size of the element set) + 1 - to \n+     * avoid a zero length array. This function also resets the startIndex to \n+     * zero. \n+     */\n+    public synchronized void contract() {\n+        double[] tempArray = new double[numElements + 1];\n+\n+        // Copy and swap - copy only the element array from the src array.\n+        System.arraycopy(internalArray, startIndex, tempArray, 0, numElements);\n+        internalArray = tempArray;\n+\n+        // Reset the start index to zero\n+        startIndex = 0;\n+    }\n+\n+    /**\n+     * Discards the <code>i<code> initial elements of the array.  For example,\n+     * if the array contains the elements 1,2,3,4, invoking \n+     * <code>discardFrontElements(2)</code> will cause the first two elements \n+     * to be discarded, leaving 3,4 in the array.  Throws illegalArgumentException\n+     * if i exceeds numElements.\n+     * \n+     * @param i  the number of elements to discard from the front of the array\n+     * @throws IllegalArgumentException if i is greater than numElements.\n+     * @since 2.0\n+     */\n+    public synchronized void discardFrontElements(int i) {\n+\n+        discardExtremeElements(i,true);\n+        \n+    }\n+\n+    /**\n+     * Discards the <code>i<code> last elements of the array.  For example,\n+     * if the array contains the elements 1,2,3,4, invoking \n+     * <code>discardMostRecentElements(2)</code> will cause the last two elements \n+     * to be discarded, leaving 1,2 in the array.  Throws illegalArgumentException\n+     * if i exceeds numElements.\n+     * \n+     * @param i  the number of elements to discard from the end of the array\n+     * @throws IllegalArgumentException if i is greater than numElements.\n+     * @since 2.0\n+     */\n+    public synchronized void discardMostRecentElements(int i) {\n+\n+        discardExtremeElements(i,false);\n+        \n+    }\n+    \n+    /**\n+     * Discards the <code>i<code> first or last elements of the array,\n+     * depending on the value of <code>front</code>.\n+     * For example, if the array contains the elements 1,2,3,4, invoking \n+     * <code>discardExtremeElements(2,false)</code> will cause the last two elements \n+     * to be discarded, leaving 1,2 in the array.\n+     * For example, if the array contains the elements 1,2,3,4, invoking \n+     * <code>discardExtremeElements(2,true)</code> will cause the first two elements \n+     * to be discarded, leaving 3,4 in the array.\n+     * Throws illegalArgumentException\n+     * if i exceeds numElements.\n+     * \n+     * @param i  the number of elements to discard from the front/end of the array\n+     * @param front true if elements are to be discarded from the front\n+     * of the array, false if elements are to be discarded from the end\n+     * of the array \n+     * @throws IllegalArgumentException if i is greater than numElements.\n+     * @since 2.0\n+     */\n+    private synchronized void discardExtremeElements(int i,boolean front) {\n+        if (i > numElements) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"cannot discard {0} elements from a {1} elements array\",\n+                    i, numElements);\n+       } else if (i < 0) {\n+           throw MathRuntimeException.createIllegalArgumentException(\n+                   \"cannot discard a negative number of elements ({0})\",\n+                   i);\n+        } else {\n+            // \"Subtract\" this number of discarded from numElements \n+            numElements -= i;\n+            if (front) startIndex += i;\n+        }\n+        if (shouldContract()) {\n+            contract();\n+        }\n+    }\n+\n+    /**\n+     * Expands the internal storage array using the expansion factor.\n+     * <p>\n+     * if <code>expansionMode</code> is set to MULTIPLICATIVE_MODE,\n+     * the new array size will be <code>internalArray.length * expansionFactor.</code>\n+     * If <code>expansionMode</code> is set to ADDITIVE_MODE,  the length\n+     * after expansion will be <code>internalArray.length + expansionFactor</code>\n+     * </p>\n+     */\n+    protected synchronized void expand() {\n+\n+        // notice the use of Math.ceil(), this guarantees that we will always \n+        // have an array of at least currentSize + 1.   Assume that the \n+        // current initial capacity is 1 and the expansion factor\n+        // is 1.000000000000000001.  The newly calculated size will be \n+        // rounded up to 2 after the multiplication is performed.\n+        int newSize = 0;\n+        if (expansionMode == MULTIPLICATIVE_MODE) {\n+            newSize = (int) Math.ceil(internalArray.length * expansionFactor);\n+        } else {\n+            newSize = internalArray.length + Math.round(expansionFactor);\n+        }\n+        double[] tempArray = new double[newSize];\n+\n+        // Copy and swap\n+        System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n+        internalArray = tempArray;\n+    }\n+    \n+    /**\n+     * Expands the internal storage array to the specified size.\n+     * \n+     * @param size Size of the new internal storage array\n+     */\n+    private synchronized void expandTo(int size) {\n+        double[] tempArray = new double[size];\n+        // Copy and swap\n+        System.arraycopy(internalArray, 0, tempArray, 0, internalArray.length);\n+        internalArray = tempArray;\n+    }\n+\n+    /**\n+     * The contraction criteria defines when the internal array will contract \n+     * to store only the number of elements in the element array.   \n+     * If  the <code>expansionMode</code> is <code>MULTIPLICATIVE_MODE</code>,\n+     * contraction is triggered when the ratio between storage array length \n+     * and <code>numElements</code> exceeds <code>contractionFactor</code>.\n+     * If the <code>expansionMode</code> is <code>ADDITIVE_MODE</code>, the\n+     * number of excess storage locations is compared to \n+     * <code>contractionFactor.</code>   \n+     * \n+     * @return the contraction criteria used to reclaim memory.\n+     */\n+    public float getContractionCriteria() {\n+        return contractionCriteria;\n+    }\n+    \n+    /**\n+     * Returns the element at the specified index\n+     * \n+     * @param index index to fetch a value from\n+     * @return value stored at the specified index\n+     * @throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n+     *         zero or is greater than <code>getNumElements() - 1</code>.\n+     */\n+    public synchronized double getElement(int index) {\n+        if (index >= numElements) {\n+            throw MathRuntimeException.createArrayIndexOutOfBoundsException(\n+                    \"the index specified: {0} is larger than the current maximal index {1}\",\n+                    index, numElements - 1);\n+        } else if (index >= 0) {\n+            return internalArray[startIndex + index];\n+        } else {\n+            throw MathRuntimeException.createArrayIndexOutOfBoundsException(\n+                    \"elements cannot be retrieved from a negative array index {0}\",\n+                    index);\n+        }\n+    }\n+    \n+     /**\n+     * Returns a double array containing the elements of this \n+     * <code>ResizableArray</code>.  This method returns a copy, not a\n+     * reference to the underlying array, so that changes made to the returned\n+     *  array have no effect on this <code>ResizableArray.</code>\n+     * @return the double array.\n+     */\n+    public synchronized double[] getElements() {\n+        double[] elementArray = new double[numElements];\n+        System.arraycopy( internalArray, startIndex, elementArray, 0,\n+                numElements);\n+        return elementArray;\n+    }\n+    \n+    /**\n+     * The expansion factor controls the size of a new array when an array \n+     * needs to be expanded.  The <code>expansionMode</code>\n+     * determines whether the size of the array is multiplied by the \n+     * <code>expansionFactor</code> (MULTIPLICATIVE_MODE) or if \n+     * the expansion is additive (ADDITIVE_MODE -- <code>expansionFactor</code>\n+     * storage locations added).  The default <code>expansionMode</code> is \n+     * MULTIPLICATIVE_MODE and the default <code>expansionFactor</code>\n+     * is 2.0.\n+     * \n+     * @return the expansion factor of this expandable double array\n+     */\n+    public float getExpansionFactor() {\n+        return expansionFactor;\n+    }\n+    \n+    /**\n+     * The <code>expansionMode</code> determines whether the internal storage \n+     * array grows additively (ADDITIVE_MODE) or multiplicatively \n+     * (MULTIPLICATIVE_MODE) when it is expanded.\n+     * \n+     * @return Returns the expansionMode.\n+     */\n+    public int getExpansionMode() {\n+        return expansionMode;\n+    }\n+    \n+    /**\n+     * Notice the package scope on this method.   This method is simply here \n+     * for the JUnit test, it allows us check if the expansion is working \n+     * properly after a number of expansions.  This is not meant to be a part \n+     * of the public interface of this class.\n+     * \n+     * @return the length of the internal storage array.\n+     */\n+    synchronized int getInternalLength() {\n+        return (internalArray.length);\n+    }\n+\n+    /**\n+     * Returns the number of elements currently in the array.  Please note\n+     * that this is different from the length of the internal storage array.  \n+     *\n+     * @return number of elements\n+     */\n+    public synchronized int getNumElements() {\n+        return (numElements);\n+    }\n+    \n+    /**\n+     * Returns the internal storage array.  Note that this method returns\n+     * a reference to the internal storage array, not a copy, and to correctly\n+     * address elements of the array, the <code>startIndex</code> is\n+     * required (available via the {@link #start} method).  This method should\n+     * only be used in cases where copying the internal array is not practical.\n+     * The {@link #getElements} method should be used in all other cases.\n+     *\n+     * \n+     * @return the internal storage array used by this object\n+     * @deprecated replaced by {@link #getInternalValues()} as of 2.0\n+     */\n+    @Deprecated\n+    public synchronized double[] getValues() {\n+        return (internalArray);\n+    }\n+\n+    /**\n+     * Returns the internal storage array.  Note that this method returns\n+     * a reference to the internal storage array, not a copy, and to correctly\n+     * address elements of the array, the <code>startIndex</code> is\n+     * required (available via the {@link #start} method).  This method should\n+     * only be used in cases where copying the internal array is not practical.\n+     * The {@link #getElements} method should be used in all other cases.\n+     *\n+     * \n+     * @return the internal storage array used by this object\n+     * @since 2.0\n+     */\n+    public synchronized double[] getInternalValues() {\n+        return (internalArray);\n+    }\n+\n+    /**\n+     * Sets the contraction criteria for this ExpandContractDoubleArray. \n+     * \n+     * @param contractionCriteria contraction criteria\n+     */\n+    public void setContractionCriteria(float contractionCriteria) {\n+        checkContractExpand(contractionCriteria, getExpansionFactor());\n+        synchronized(this) {\n+            this.contractionCriteria = contractionCriteria;\n+        }\n+    }\n+    \n+\n+    /**\n+     * Sets the element at the specified index.  If the specified index is greater than\n+     * <code>getNumElements() - 1</code>, the <code>numElements</code> property\n+     * is increased to <code>index +1</code> and additional storage is allocated \n+     * (if necessary) for the new element and all  (uninitialized) elements \n+     * between the new element and the previous end of the array).\n+     * \n+     * @param index index to store a value in\n+     * @param value value to store at the specified index\n+     * @throws ArrayIndexOutOfBoundsException if <code>index</code> is less than\n+     *         zero.\n+     */\n+    public synchronized void setElement(int index, double value) {\n+        if (index < 0) {\n+            throw MathRuntimeException.createArrayIndexOutOfBoundsException(\n+                    \"cannot set an element at a negative index {0}\",\n+                    index);\n+        }\n+        if (index + 1 > numElements) {\n+            numElements = index + 1;\n+        }       \n+        if ((startIndex + index) >= internalArray.length) {\n+            expandTo(startIndex + (index + 1));\n+        }    \n+        internalArray[startIndex + index] = value;\n+    }\n+\n+    /**\n+     * Sets the expansionFactor.  Throws IllegalArgumentException if the \n+     * the following conditions are not met:\n+     * <ul>\n+     * <li><code>expansionFactor > 1</code></li>\n+     * <li><code>contractionFactor >= expansionFactor</code></li>\n+     * </ul>\n+     * @param expansionFactor the new expansion factor value.\n+     * @throws IllegalArgumentException if expansionFactor is <= 1 or greater\n+     * than contractionFactor\n+     */\n+    public void setExpansionFactor(float expansionFactor) {\n+        checkContractExpand(getContractionCriteria(), expansionFactor);\n+        // The check above verifies that the expansion factor is > 1.0;\n+        synchronized(this) {\n+            this.expansionFactor = expansionFactor;\n+        }\n+    }\n+\n+    /**\n+     * Sets the <code>expansionMode</code>. The specified value must be one of\n+     * ADDITIVE_MODE, MULTIPLICATIVE_MODE.\n+     * \n+     * @param expansionMode The expansionMode to set.\n+     * @throws IllegalArgumentException if the specified mode value is not valid\n+     */\n+    public void setExpansionMode(int expansionMode) {\n+        if (expansionMode != MULTIPLICATIVE_MODE && \n+                expansionMode != ADDITIVE_MODE) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"unsupported expansion mode {0}, supported modes are {1} ({2}) and {3} ({4})\",\n+                    expansionMode, MULTIPLICATIVE_MODE, \"MULTIPLICATIVE_MODE\",\n+                    ADDITIVE_MODE, \"ADDITIVE_MODE\");\n+        }\n+        synchronized(this) {\n+            this.expansionMode = expansionMode;\n+        }\n+    }\n+    \n+    /**\n+     * Sets the initial capacity.  Should only be invoked by constructors.\n+     * \n+     * @param initialCapacity of the array\n+     * @throws IllegalArgumentException if <code>initialCapacity</code> is not\n+     *         positive.\n+     */\n+    protected void setInitialCapacity(int initialCapacity) {\n+        if (initialCapacity > 0) {\n+            synchronized(this) {\n+                this.initialCapacity = initialCapacity;\n+            }\n+        } else {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"initial capacity ({0}) is not positive\",\n+                    initialCapacity);\n+        }\n+    }\n+    \n+    /**\n+     * This function allows you to control the number of elements contained \n+     * in this array, and can be used to \"throw out\" the last n values in an \n+     * array. This function will also expand the internal array as needed.\n+     * \n+     * @param i a new number of elements\n+     * @throws IllegalArgumentException if <code>i</code> is negative.\n+     */\n+    public synchronized void setNumElements(int i) {\n+\n+        // If index is negative thrown an error\n+        if (i < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"index ({0}) is not positive\",\n+                    i);\n+        }\n+\n+        // Test the new num elements, check to see if the array needs to be \n+        // expanded to accommodate this new number of elements\n+        if ((startIndex + i) > internalArray.length) {\n+            expandTo(startIndex + i);\n+        }\n+\n+        // Set the new number of elements to new value\n+        numElements = i;\n+    }\n+\n+    /**\n+     * Returns true if the internal storage array has too many unused \n+     * storage positions.  \n+     * \n+     * @return true if array satisfies the contraction criteria\n+     */\n+    private synchronized boolean shouldContract() {\n+        if (expansionMode == MULTIPLICATIVE_MODE) { \n+            return (internalArray.length / ((float) numElements)) > contractionCriteria;\n+        } else {\n+            return (internalArray.length - numElements) > contractionCriteria;\n+        }\n+    }\n+\n+    /**\n+     * Returns the starting index of the internal array.  The starting index is\n+     * the position of the first addressable element in the internal storage\n+     * array.  The addressable elements in the array are <code>\n+     * internalArray[startIndex],...,internalArray[startIndex + numElements -1]\n+     * </code>\n+     *\n+     * @return starting index\n+     */\n+    public synchronized int start() {\n+        return startIndex;\n+    }\n+    \n+    /**\n+     * <p>Copies source to dest, copying the underlying data, so dest is\n+     * a new, independent copy of source.  Does not contract before\n+     * the copy.</p>\n+     * \n+     * <p>Obtains synchronization locks on both source and dest\n+     * (in that order) before performing the copy.</p>\n+     * \n+     * <p>Neither source nor dest may be null; otherwise a NullPointerException\n+     * is thrown</p>\n+     * \n+     * @param source ResizableDoubleArray to copy\n+     * @param dest ResizableArray to replace with a copy of the source array\n+     * @since 2.0\n+     * \n+     */\n+    public static void copy(ResizableDoubleArray source, ResizableDoubleArray dest) {\n+       synchronized(source) {\n+           synchronized(dest) {\n+               dest.initialCapacity = source.initialCapacity;\n+               dest.contractionCriteria = source.contractionCriteria;\n+               dest.expansionFactor = source.expansionFactor;\n+               dest.expansionMode = source.expansionMode;\n+               dest.internalArray = new double[source.internalArray.length];\n+               System.arraycopy(source.internalArray, 0, dest.internalArray,\n+                       0, dest.internalArray.length);\n+               dest.numElements = source.numElements;\n+               dest.startIndex = source.startIndex;\n+           }\n+       }\n+    }\n+    \n+    /**\n+     * Returns a copy of the ResizableDoubleArray.  Does not contract before\n+     * the copy, so the returned object is an exact copy of this.\n+     * \n+     * @return a new ResizableDoubleArray with the same data and configuration\n+     * properties as this\n+     * @since 2.0\n+     */\n+    public synchronized ResizableDoubleArray copy() {\n+        ResizableDoubleArray result = new ResizableDoubleArray();\n+        copy(this, result);\n+        return result;\n+    }\n+    \n+    /**\n+     * Returns true iff object is a ResizableDoubleArray with the same properties\n+     * as this and an identical internal storage array.\n+     * \n+     * @param object object to be compared for equality with this\n+     * @return true iff object is a ResizableDoubleArray with the same data and\n+     * properties as this\n+     * @since 2.0\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (object == this ) {\n+            return true;\n+        }\n+       if (object instanceof ResizableDoubleArray == false) {\n+            return false;\n+        }\n+       synchronized(this) {\n+           synchronized(object) {\n+               boolean result = true;\n+               ResizableDoubleArray other = (ResizableDoubleArray) object;\n+               result = result && (other.initialCapacity == initialCapacity);\n+               result = result && (other.contractionCriteria == contractionCriteria);\n+               result = result && (other.expansionFactor == expansionFactor);\n+               result = result && (other.expansionMode == expansionMode);\n+               result = result && (other.numElements == numElements);\n+               result = result && (other.startIndex == startIndex);\n+               if (!result) { \n+                   return false;\n+               } else {\n+                   return Arrays.equals(internalArray, other.internalArray);\n+               }\n+           }\n+       }\n+    }\n+    \n+    /**\n+     * Returns a hash code consistent with equals.\n+     * \n+     * @return hash code representing this ResizableDoubleArray\n+     * @since 2.0\n+     */\n+    @Override\n+    public synchronized int hashCode() {\n+        int[] hashData = new int[7];\n+        hashData[0] = new Float(expansionFactor).hashCode();\n+        hashData[1] = new Float(contractionCriteria).hashCode();\n+        hashData[2] = expansionMode;\n+            hashData[3] = Arrays.hashCode(internalArray);\n+            hashData[4] = initialCapacity;\n+            hashData[5] = numElements;\n+            hashData[6] = startIndex;\n+        return Arrays.hashCode(hashData);\n+    }\n+         \n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/util/TransformerMap.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * This TansformerMap automates the transformation of mixed object types.\n+ * It provides a means to set NumberTransformers that will be selected \n+ * based on the Class of the object handed to the Maps\n+ * <code>double transform(Object o)</code> method.\n+ * @version $Revision$ $Date$\n+ */\n+public class TransformerMap implements NumberTransformer, Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 4605318041528645258L;\n+\n+    /**\n+     * A default Number Transformer for Numbers and numeric Strings.\n+     */\n+    private NumberTransformer defaultTransformer = null;\n+\n+    /**\n+     * The internal Map.\n+     */\n+    private Map<Class<?>, NumberTransformer> map = null;\n+\n+    /**\n+     * Build a map containing only the default transformer.\n+     */\n+    public TransformerMap() {\n+        map = new HashMap<Class<?>, NumberTransformer>();\n+        defaultTransformer = new DefaultTransformer();\n+    }\n+\n+    /**\n+     * Tests if a Class is present in the TransformerMap.\n+     * @param key Class to check\n+     * @return true|false\n+     */\n+    public boolean containsClass(Class<?> key) {\n+        return map.containsKey(key);\n+    }\n+\n+    /**\n+     * Tests if a NumberTransformer is present in the TransformerMap.\n+     * @param value NumberTransformer to check\n+     * @return true|false\n+     */\n+    public boolean containsTransformer(NumberTransformer value) {\n+        return map.containsValue(value);\n+    }\n+\n+    /**\n+     * Returns the Transformer that is mapped to a class\n+     * if mapping is not present, this returns null.\n+     * @param key The Class of the object\n+     * @return the mapped NumberTransformer or null.\n+     */\n+    public NumberTransformer getTransformer(Class<?> key) {\n+        return map.get(key);\n+    }\n+\n+    /**\n+     * Sets a Class to Transformer Mapping in the Map. If\n+     * the Class is already present, this overwrites that\n+     * mapping.\n+     * @param key The Class\n+     * @param transformer The NumberTransformer\n+     * @return the replaced transformer if one is present\n+     */\n+    public NumberTransformer putTransformer(Class<?> key, NumberTransformer transformer) {\n+        return map.put(key, transformer);\n+    }\n+\n+    /**\n+     * Removes a Class to Transformer Mapping in the Map.\n+     * @param key The Class\n+     * @return the removed transformer if one is present or\n+     * null if none was present.\n+     */\n+    public NumberTransformer removeTransformer(Class<?> key) {\n+        return map.remove(key);\n+    }\n+\n+    /**\n+     * Clears all the Class to Transformer mappings.\n+     */\n+    public void clear() {\n+        map.clear();\n+    }\n+\n+    /**\n+     * Returns the Set of Classes used as keys in the map.\n+     * @return Set of Classes\n+     */\n+    public Set<Class<?>> classes() {\n+        return map.keySet();\n+    }\n+\n+    /**\n+     * Returns the Set of NumberTransformers used as values \n+     * in the map.\n+     * @return Set of NumberTransformers\n+     */\n+    public Collection<NumberTransformer> transformers() {\n+        return map.values();\n+    }\n+\n+    /**\n+     * Attempts to transform the Object against the map of\n+     * NumberTransformers. Otherwise it returns Double.NaN.\n+     * \n+     * @param o the Object to be transformed.\n+     * @return the double value of the Object.\n+     * @throws MathException if the Object can not be transformed into a Double. \n+     * @see org.apache.commons.math.util.NumberTransformer#transform(java.lang.Object)\n+     */\n+    public double transform(Object o) throws MathException {\n+        double value = Double.NaN;\n+\n+        if (o instanceof Number || o instanceof String) {\n+            value = defaultTransformer.transform(o);\n+        } else {\n+            NumberTransformer trans = getTransformer(o.getClass());\n+            if (trans != null) {\n+                value = trans.transform(o);\n+            }\n+        }\n+\n+        return value;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean equals(Object other) {\n+        if (this == other) { \n+            return true;\n+        }\n+        if (other == null) {\n+            return false;\n+        }\n+        try {\n+            TransformerMap rhs = (TransformerMap) other;\n+            if (! defaultTransformer.equals(rhs.defaultTransformer)) {\n+                return false;\n+            }\n+            if (map.size() != rhs.map.size()) {\n+                return false;\n+            }\n+            for (Map.Entry<Class<?>, NumberTransformer> entry : map.entrySet()) {\n+                if (! entry.getValue().equals(rhs.map.get(entry.getKey()))) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        } catch (ClassCastException cce) {\n+            return false;\n+        }\n+    }\n+    \n+    /** {@inheritDoc} */\n+    @Override\n+    public int hashCode() {\n+        int hash = defaultTransformer.hashCode();\n+        for (NumberTransformer t : map.values()) {\n+            hash = hash * 31 + t.hashCode();\n+        }\n+        return hash;\n+    }\n+\n+}", "timestamp": 1249137025, "metainfo": ""}