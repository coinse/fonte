{"sha": "927739c1a1acd8be4ff27a07d2b9029fbf357200", "log": "added the addToentry and multiplyEntry methods to allow in-place operation for matrices  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n                                    final int startColumn, final int endColumn)\n         throws MatrixIndexException {\n \n-        checkRowIndex(startRow);\n-        checkRowIndex(endRow);\n-        if (startRow > endRow) {\n-            throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n-                                           new Object[] { startRow, endRow });\n-        }\n-\n-        checkColumnIndex(startColumn);\n-        checkColumnIndex(endColumn);\n-        if (startColumn > endColumn) {\n-            throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n-                                           new Object[] { startColumn, endColumn });\n-        }\n+        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n \n         final RealMatrix subMatrix =\n             createMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n     public RealMatrix getSubMatrix(int[] selectedRows, int[] selectedColumns)\n         throws MatrixIndexException {\n \n-        if (selectedRows.length * selectedColumns.length == 0) {\n-            if (selectedRows.length == 0) {\n-                throw new MatrixIndexException(\"empty selected row index array\", null);\n-            }\n-            throw new MatrixIndexException(\"empty selected column index array\", null);\n-        }\n+        checkSubMatrixIndex(selectedRows, selectedColumns);\n \n         final RealMatrix subMatrix =\n             createMatrix(selectedRows.length, selectedColumns.length);\n-        try  {\n-            for (int i = 0; i < selectedRows.length; i++) {\n-                for (int j = 0; j < selectedColumns.length; j++) {\n-                    subMatrix.setEntry(i, j, getEntry(selectedRows[i], selectedColumns[j]));\n-                }\n-            }\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            // we redo the loop with checks enabled\n-            // in order to generate an appropriate message\n-            for (final int row : selectedRows) {\n-                checkRowIndex(row);\n-            }\n-            for (final int column : selectedColumns) {\n-                checkColumnIndex(column);\n+        for (int i = 0; i < selectedRows.length; i++) {\n+            for (int j = 0; j < selectedColumns.length; j++) {\n+                subMatrix.setEntry(i, j, getEntry(selectedRows[i], selectedColumns[j]));\n             }\n         }\n \n \n     /** {@inheritDoc} */\n     public abstract void setEntry(int row, int column, double value)\n+        throws MatrixIndexException;\n+\n+    /** {@inheritDoc} */\n+    public abstract void addToEntry(int row, int column, double increment)\n+        throws MatrixIndexException;\n+\n+    /** {@inheritDoc} */\n+    public abstract void multiplyEntry(int row, int column, double factor)\n         throws MatrixIndexException;\n \n     /** {@inheritDoc} */\n     }\n \n     /**\n+     * Check if submatrix ranges indices are valid.\n+     * Rows and columns are indicated counting from 0 to n-1.\n+     *\n+     * @param startRow Initial row index\n+     * @param endRow Final row index\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception MatrixIndexException  if the indices are not valid\n+     */\n+    protected void checkSubMatrixIndex(final int startRow, final int endRow,\n+                                       final int startColumn, final int endColumn) {\n+        checkRowIndex(startRow);\n+        checkRowIndex(endRow);\n+        if (startRow > endRow) {\n+            throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n+                                           new Object[] { startRow, endRow });\n+        }\n+\n+        checkColumnIndex(startColumn);\n+        checkColumnIndex(endColumn);\n+        if (startColumn > endColumn) {\n+            throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n+                                           new Object[] { startColumn, endColumn });\n+        }\n+\n+    \n+    }\n+\n+    /**\n+     * Check if submatrix ranges indices are valid.\n+     * Rows and columns are indicated counting from 0 to n-1.\n+     *\n+     * @param selectedRows Array of row indices.\n+     * @param selectedColumns Array of column indices.\n+     * @exception MatrixIndexException if row or column selections are not valid\n+     */\n+    protected void checkSubMatrixIndex(final int[] selectedRows, final int[] selectedColumns) {\n+        if (selectedRows.length * selectedColumns.length == 0) {\n+            if (selectedRows.length == 0) {\n+                throw new MatrixIndexException(\"empty selected row index array\", null);\n+            }\n+            throw new MatrixIndexException(\"empty selected column index array\", null);\n+        }\n+\n+        for (final int row : selectedRows) {\n+            checkRowIndex(row);\n+        }\n+        for (final int column : selectedColumns) {\n+            checkColumnIndex(column);\n+        }\n+    }\n+\n+    /**\n      * Check if a matrix is addition compatible with the instance\n      * @param m matrix to check\n      * @exception IllegalArgumentException if matrix is not addition compatible with instance\n--- a/src/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrix.java\n     void setEntry(int row, int column, double value) throws MatrixIndexException;\n \n     /**\n+     * Change an entry in the specified row and column.\n+     * <p>\n+     * Row and column indices start at 0 and must satisfy \n+     * <ul>\n+     * <li><code>0 <= row < rowDimension</code></li>\n+     * <li><code> 0 <= column < columnDimension</code></li>\n+     * </ul>\n+     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n+     * \n+     * @param row  row location of entry to be set\n+     * @param column  column location of entry to be set\n+     * @param increment value to add to the current matrix entry in row,column\n+     * @throws MatrixIndexException if the row or column index is not valid\n+     * @since 2.0\n+     */\n+    void addToEntry(int row, int column, double increment) throws MatrixIndexException;\n+\n+    /**\n+     * Change an entry in the specified row and column.\n+     * <p>\n+     * Row and column indices start at 0 and must satisfy \n+     * <ul>\n+     * <li><code>0 <= row < rowDimension</code></li>\n+     * <li><code> 0 <= column < columnDimension</code></li>\n+     * </ul>\n+     * otherwise a <code>MatrixIndexException</code> is thrown.</p>\n+     * \n+     * @param row  row location of entry to be set\n+     * @param column  column location of entry to be set\n+     * @param factor multiplication factor for the current matrix entry in row,column\n+     * @throws MatrixIndexException if the row or column index is not valid\n+     * @since 2.0\n+     */\n+    void multiplyEntry(int row, int column, double factor) throws MatrixIndexException;\n+\n+    /**\n      * Returns the transpose of this matrix.\n      *\n      * @return transpose matrix\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n     }\n \n     /** {@inheritDoc} */\n+    public void addToEntry(final int row, final int column, final double increment)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] += increment;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                                           new Object[] {\n+                                               row, column,\n+                                               getRowDimension(), getColumnDimension()\n+                                           });\n+        }      \n+    }\n+\n+    /** {@inheritDoc} */\n+    public void multiplyEntry(final int row, final int column, final double factor)\n+        throws MatrixIndexException {\n+        try {\n+            data[row][column] *= factor;\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new MatrixIndexException(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n+                                           new Object[] {\n+                                               row, column,\n+                                               getRowDimension(), getColumnDimension()\n+                                           });\n+        }      \n+    }\n+\n+    /** {@inheritDoc} */\n     public int getRowDimension() {\n         return (data == null) ? 0 : data.length;\n     }\n--- a/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n             (new double[][] {{3.0,4.0,5.0},{4.0,7.0,5.0},{3.0,2.0,10.0}});\n         assertEquals(expected, m);   \n         \n-        // javadoc example\n-        RealMatrixImpl matrix = (RealMatrixImpl) MatrixUtils.createRealMatrix\n-            (new double[][] {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 0, 1 , 2}});\n-        matrix.setSubMatrix(new double[][] {{3, 4}, {5, 6}}, 1, 1);\n-        expected = MatrixUtils.createRealMatrix\n-            (new double[][] {{1, 2, 3, 4}, {5, 3, 4, 8}, {9, 5 ,6, 2}});\n-        assertEquals(expected, matrix);   \n-        \n         // dimension overflow\n         try {  \n             m.setSubMatrix(testData,1,1);", "timestamp": 1229730791, "metainfo": ""}