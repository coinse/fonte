{"sha": "44492acc710f898ea50257275adf3064f1025fff", "log": "Added WeightedEvaluation interface and added evaluate(values, weights) to weighted statistics implementations. JIRA: MATH-287.  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/WeightedEvaluation.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+/**\n+ * Weighted evaluation for statistics.\n+ *\n+ * @since 2.1\n+ * @version $Revision$ $Date$\n+ */\n+public interface WeightedEvaluation {\n+\n+    /**\n+     * Returns the result of evaluating the statistic over the input array,\n+     * using the supplied weights.\n+     *\n+     * @param values input array\n+     * @param weights array of weights\n+     * @return the value of the statistic applied to the input array\n+     */\n+    double evaluate(double[] values, double[] weights);\n+\n+    /**\n+     * Returns the result of evaluating the statistic over the specified entries\n+     * in the input array, using corresponding entries in the supplied weights array.\n+     *\n+     * @param values the input array\n+     * @param weights array of weights\n+     * @param begin the index of the first element to include\n+     * @param length the number of elements to include\n+     * @return the value of the statistic applied to the included array entries\n+     */\n+    double evaluate(double[] values, double[] weights, int begin, int length);\n+\n+}\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n import java.io.Serializable;\n \n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.WeightedEvaluation;\n import org.apache.commons.math.stat.descriptive.summary.Sum;\n \n /**\n  * @version $Revision$ $Date$\n  */\n public class Mean extends AbstractStorelessUnivariateStatistic\n-    implements Serializable {\n+    implements Serializable, WeightedEvaluation {\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -1296043746617791564L;\n         }\n         return Double.NaN;\n     }\n+    \n+    /**\n+     * Returns the weighted arithmetic mean of the entries in the input array.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if either array is null.</p>\n+     * <p>\n+     * See {@link Mean} for details on the computing algorithm. The two-pass algorithm\n+     * described above is used here, with weights applied in computing both the original\n+     * estimate and the correction factor.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n+     * <ul><li>the values array is null</li>\n+     *     <li>the weights array is null</li>\n+     *     <li>the weights array does not have the same length as the values array</li>\n+     *     <li>the weights array contains one or more infinite values</li>\n+     *     <li>the weights array contains one or more NaN values</li>\n+     *     <li>the weights array contains negative values</li>\n+     * </ul></p>\n+     *\n+     * @param values the input array\n+     * @param weights the weights array\n+     * @return the mean of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final double[] weights) {\n+        return evaluate(values, weights, 0, values.length);\n+    }\n \n     /**\n      * {@inheritDoc}\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.stat.descriptive.WeightedEvaluation;\n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n \n /**\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Variance extends AbstractStorelessUnivariateStatistic implements Serializable {\n+public class Variance extends AbstractStorelessUnivariateStatistic implements Serializable, WeightedEvaluation {\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -9111962718267217978L;\n      * @param weights the weights array\n      * @param begin index of the first array element to include\n      * @param length the number of elements to include\n-     * @return the variance of the values or Double.NaN if length = 0\n+     * @return the weighted variance of the values or Double.NaN if length = 0\n      * @throws IllegalArgumentException if the parameters are not valid\n      */\n     public double evaluate(final double[] values, final double[] weights,\n             }\n         }\n         return var;\n+    }\n+    \n+    /**\n+     * <p>\n+     * Returns the weighted variance of the entries in the the input array.</p>\n+     * <p>\n+     * Uses the formula <pre>\n+     *   &Sigma;(weights[i]*(values[i] - weightedMean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n+     * </pre>\n+     * where weightedMean is the weighted mean</p>\n+     * <p>\n+     * This formula will not return the same result as the unweighted variance when all\n+     * weights are equal, unless all weights are equal to 1. The formula assumes that\n+     * weights are to be treated as \"expansion values,\" as will be the case if for example\n+     * the weights represent frequency counts. To normalize weights so that the denominator\n+     * in the variance computation equals the length of the input vector minus one, use <pre>\n+     *   <code>evaluate(values, MathUtils.normalizeArray(weights, values.length)); </code>\n+     * </pre>\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n+     * <ul><li>the values array is null</li>\n+     *     <li>the weights array is null</li>\n+     *     <li>the weights array does not have the same length as the values array</li>\n+     *     <li>the weights array contains one or more infinite values</li>\n+     *     <li>the weights array contains one or more NaN values</li>\n+     *     <li>the weights array contains negative values</li>\n+     * </ul></p>\n+     * <p>\n+     * Does not change the internal state of the statistic.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if either array is null.</p>\n+     *\n+     * @param values the input array\n+     * @param weights the weights array\n+     * @return the weighted variance of the values\n+     * @throws IllegalArgumentException if the parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final double[] weights) {\n+        return evaluate(values, weights, 0, values.length);\n     }\n \n     /**\n         }\n         return var;\n     }\n+    \n+    /**\n+     * Returns the variance of the entries in the input array, using the\n+     * precomputed mean value.  Returns <code>Double.NaN</code> if the array\n+     * is empty.\n+     * <p>\n+     * See {@link Variance} for details on the computing algorithm.</p>\n+     * <p>\n+     * If <code>isBiasCorrected</code> is <code>true</code> the formula used\n+     * assumes that the supplied mean value is the arithmetic mean of the\n+     * sample data, not a known population parameter.  If the mean is a known\n+     * population parameter, or if the \"population\" version of the variance is\n+     * desired, set <code>isBiasCorrected</code> to <code>false</code> before\n+     * invoking this method.</p>\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n+     * <p>\n+     * Does not change the internal state of the statistic.</p>\n+     *\n+     * @param values the input array\n+     * @param mean the precomputed mean value\n+     * @return the variance of the values or Double.NaN if the array is empty\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public double evaluate(final double[] values, final double mean) {\n+        return evaluate(values, mean, 0, values.length);\n+    }\n \n     /**\n      * Returns the weighted variance of the entries in the specified portion of\n      * weights are to be treated as \"expansion values,\" as will be the case if for example\n      * the weights represent frequency counts. To normalize weights so that the denominator\n      * in the variance computation equals the length of the input vector minus one, use <pre>\n-     *   <code>evaluate(values, MathUtils.normalizeArray(weights, values.length)); </code>\n+     *   <code>evaluate(values, MathUtils.normalizeArray(weights, values.length), mean); </code>\n      * </pre>\n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n         }\n         return var;\n     }\n-\n-    /**\n-     * Returns the variance of the entries in the input array, using the\n-     * precomputed mean value.  Returns <code>Double.NaN</code> if the array\n-     * is empty.\n-     * <p>\n-     * See {@link Variance} for details on the computing algorithm.</p>\n-     * <p>\n-     * If <code>isBiasCorrected</code> is <code>true</code> the formula used\n-     * assumes that the supplied mean value is the arithmetic mean of the\n-     * sample data, not a known population parameter.  If the mean is a known\n-     * population parameter, or if the \"population\" version of the variance is\n-     * desired, set <code>isBiasCorrected</code> to <code>false</code> before\n-     * invoking this method.</p>\n-     * <p>\n-     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n-     * <p>\n-     * Throws <code>IllegalArgumentException</code> if the array is null.</p>\n-     * <p>\n-     * Does not change the internal state of the statistic.</p>\n-     *\n-     * @param values the input array\n-     * @param mean the precomputed mean value\n-     * @return the variance of the values or Double.NaN if the array is empty\n-     * @throws IllegalArgumentException if the array is null\n-     */\n-    public double evaluate(final double[] values, final double mean) {\n-        return evaluate(values, mean, 0, values.length);\n+    \n+    /**\n+     * <p>Returns the weighted variance of the values in the input array, using\n+     * the precomputed weighted mean value.</p>\n+     * <p>\n+     * Uses the formula <pre>\n+     *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n+     * </pre></p>\n+     * <p>\n+     * The formula used assumes that the supplied mean value is the weighted arithmetic\n+     * mean of the sample data, not a known population parameter. This method\n+     * is supplied only to save computation when the mean has already been\n+     * computed.</p>\n+     * <p>\n+     * This formula will not return the same result as the unweighted variance when all\n+     * weights are equal, unless all weights are equal to 1. The formula assumes that\n+     * weights are to be treated as \"expansion values,\" as will be the case if for example\n+     * the weights represent frequency counts. To normalize weights so that the denominator\n+     * in the variance computation equals the length of the input vector minus one, use <pre>\n+     *   <code>evaluate(values, MathUtils.normalizeArray(weights, values.length), mean); </code>\n+     * </pre>\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n+     * <ul><li>the values array is null</li>\n+     *     <li>the weights array is null</li>\n+     *     <li>the weights array does not have the same length as the values array</li>\n+     *     <li>the weights array contains one or more infinite values</li>\n+     *     <li>the weights array contains one or more NaN values</li>\n+     *     <li>the weights array contains negative values</li>\n+     * </ul></p>\n+     * <p>\n+     * Does not change the internal state of the statistic.</p>\n+     *\n+     * @param values the input array\n+     * @param weights the weights array\n+     * @param mean the precomputed weighted mean value\n+     * @return the variance of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final double[] weights, final double mean) {\n+        return evaluate(values, weights, mean, 0, values.length);\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n import java.io.Serializable;\n \n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.WeightedEvaluation;\n \n /**\n  * Returns the product of the available values.\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Product extends AbstractStorelessUnivariateStatistic implements Serializable {\n+public class Product extends AbstractStorelessUnivariateStatistic implements Serializable, WeightedEvaluation {\n \n     /** Serializable version identifier */\n     private static final long serialVersionUID = 2824226005990582538L;\n         }\n         return product;\n     }\n+    \n+    /**\n+     * <p>Returns the weighted product of the entries in the input array.</p>\n+     *\n+     * <p>Throws <code>IllegalArgumentException</code> if any of the following are true:\n+     * <ul><li>the values array is null</li>\n+     *     <li>the weights array is null</li>\n+     *     <li>the weights array does not have the same length as the values array</li>\n+     *     <li>the weights array contains one or more infinite values</li>\n+     *     <li>the weights array contains one or more NaN values</li>\n+     *     <li>the weights array contains negative values</li>\n+     * </ul></p>\n+     *\n+     * <p>Uses the formula, <pre>\n+     *    weighted product = &prod;values[i]<sup>weights[i]</sup>\n+     * </pre>\n+     * that is, the weights are applied as exponents when computing the weighted product.</p>\n+     *\n+     * @param values the input array\n+     * @param weights the weights array\n+     * @return the product of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final double[] weights) {\n+        return evaluate(values, weights, 0, values.length);\n+    }\n+\n \n     /**\n      * {@inheritDoc}\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n import java.io.Serializable;\n \n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.WeightedEvaluation;\n+\n \n /**\n   * Returns the sum of the available values.\n         }\n         return sum;\n     }\n+    \n+    /**\n+     * The weighted sum of the entries in the the input array.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n+     * <ul><li>the values array is null</li>\n+     *     <li>the weights array is null</li>\n+     *     <li>the weights array does not have the same length as the values array</li>\n+     *     <li>the weights array contains one or more infinite values</li>\n+     *     <li>the weights array contains one or more NaN values</li>\n+     *     <li>the weights array contains negative values</li>\n+     * </ul></p>\n+     * <p>\n+     * Uses the formula, <pre>\n+     *    weighted sum = &Sigma;(values[i] * weights[i])\n+     * </pre></p>\n+     *\n+     * @param values the input array\n+     * @param weights the weights array\n+     * @return the sum of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final double[] weights) {\n+        return evaluate(values, weights, 0, values.length);\n+    }\n \n     /**\n      * {@inheritDoc}\n--- a/src/test/java/org/apache/commons/math/stat/descriptive/UnivariateStatisticAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/UnivariateStatisticAbstractTest.java\n         // See if this statistic computes weighted statistics\n         // If not, skip this test\n         UnivariateStatistic statistic = getUnivariateStatistic();\n-        Method evaluateMethod = null;\n-        try {\n-            evaluateMethod = statistic.getClass().getDeclaredMethod(\"evaluate\",\n-                double[].class, double[].class, int.class, int.class);\n-        } catch (NoSuchMethodException ex) {\n-            return;  // skip test\n+        if (!(statistic instanceof WeightedEvaluation)) {\n+            return;\n         }\n \n         // Create arrays of values and corresponding integral weights\n \n         // Compare result of weighted statistic computation with direct computation\n         // on array of repeated values\n-        double weightedResult = (Double) evaluateMethod.invoke(\n-                statistic, values, weights, 0, values.length);\n-        TestUtils.assertRelativelyEquals(\n-                statistic.evaluate(repeatedValues), weightedResult, 10E-14);\n+        WeightedEvaluation weightedStatistic = (WeightedEvaluation) statistic;\n+        TestUtils.assertRelativelyEquals(statistic.evaluate(repeatedValues),\n+                weightedStatistic.evaluate(values, weights, 0, values.length),\n+                10E-14);\n+        \n+        // Check consistency of weighted evaluation methods\n+        assertEquals(weightedStatistic.evaluate(values, weights, 0, values.length),\n+                weightedStatistic.evaluate(values, weights), Double.MIN_VALUE);       \n \n     }\n ", "timestamp": 1262116669, "metainfo": ""}