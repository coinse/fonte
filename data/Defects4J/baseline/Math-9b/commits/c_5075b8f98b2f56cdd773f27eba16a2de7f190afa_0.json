{"sha": "5075b8f98b2f56cdd773f27eba16a2de7f190afa", "log": "Javadoc, formatting.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/FunctionUtils.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/FunctionUtils.java\n     private FunctionUtils() {}\n \n     /**\n-     * Compose functions.  The functions in the argument list are composed\n-     * sequentially, in the order given.  For example, compose(f1,f2,f3)\n-     * acts like f1(f2(f3(x))).\n+     * Composew functions.\n+     * <br/>\n+     * The functions in the argument list are composed sequentially, in the\n+     * given order.  For example, compose(f1,f2,f3) acts like f1(f2(f3(x))).\n      *\n      * @param f List of functions.\n      * @return the composite function.\n     }\n \n     /**\n-     * Compose functions.  The functions in the argument list are composed\n-     * sequentially, in the order given.  For example, compose(f1,f2,f3)\n-     * acts like f1(f2(f3(x))).\n+     * Composes functions.\n+     * <br/>\n+     * The functions in the argument list are composed sequentially, in the\n+     * given order.  For example, compose(f1,f2,f3) acts like f1(f2(f3(x))).\n      *\n      * @param f List of functions.\n      * @return the composite function.\n     }\n \n     /**\n-     * Add functions.\n+     * Adds functions.\n      *\n      * @param f List of functions.\n      * @return a function that computes the sum of the functions.\n     }\n \n     /**\n-     * Add functions.\n+     * Adds functions.\n      *\n      * @param f List of functions.\n      * @return a function that computes the sum of the functions.\n     }\n \n     /**\n-     * Multiply functions.\n+     * Multiplies functions.\n      *\n      * @param f List of functions.\n      * @return a function that computes the product of the functions.\n     }\n \n     /**\n-     * Multiply functions.\n+     * Multiplies functions.\n      *\n      * @param f List of functions.\n      * @return a function that computes the product of the functions.\n      * @return the composite function.\n      */\n     public static UnivariateFunction combine(final BivariateFunction combiner,\n-                                                 final UnivariateFunction f,\n-                                                 final UnivariateFunction g) {\n+                                             final UnivariateFunction f,\n+                                             final UnivariateFunction g) {\n         return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n      * @return a collector function.\n      */\n     public static MultivariateFunction collector(final BivariateFunction combiner,\n-                                                     final UnivariateFunction f,\n-                                                     final double initialValue) {\n+                                                 final UnivariateFunction f,\n+                                                 final double initialValue) {\n         return new MultivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double[] point) {\n      * @return a collector function.\n      */\n     public static MultivariateFunction collector(final BivariateFunction combiner,\n-                                                     final double initialValue) {\n+                                                 final double initialValue) {\n         return collector(combiner, new Identity(), initialValue);\n     }\n \n     /**\n-     * Create a unary function by fixing the first argument of a binary function.\n+     * Creates a unary function by fixing the first argument of a binary function.\n      *\n      * @param f Binary function.\n      * @param fixed Value to which the first argument of {@code f} is set.\n      * @return the unary function h(x) = f(fixed, x)\n      */\n     public static UnivariateFunction fix1stArgument(final BivariateFunction f,\n-                                                        final double fixed) {\n+                                                    final double fixed) {\n         return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n         };\n     }\n     /**\n-     * Create a unary function by fixing the second argument of a binary function.\n+     * Creates a unary function by fixing the second argument of a binary function.\n      *\n      * @param f Binary function.\n      * @param fixed Value to which the second argument of {@code f} is set.\n      * @return the unary function h(x) = f(x, fixed)\n      */\n     public static UnivariateFunction fix2ndArgument(final BivariateFunction f,\n-                                                        final double fixed) {\n+                                                    final double fixed) {\n         return new UnivariateFunction() {\n             /** {@inheritDoc} */\n             public double value(double x) {\n     }\n \n     /**\n-     * <p>\n      * Samples the specified univariate real function on the specified interval.\n-     * </p>\n-     * <p>\n+     * <br/>\n      * The interval is divided equally into {@code n} sections and sample points\n      * are taken from {@code min} to {@code max - (max - min) / n}; therefore\n      * {@code f} is not sampled at the upper bound {@code max}.\n-     * </p>\n-     *\n-     * @param f the function to be sampled\n-     * @param min the (inclusive) lower bound of the interval\n-     * @param max the (exclusive) upper bound of the interval\n-     * @param n the number of sample points\n-     * @return the array of samples\n+     *\n+     * @param f Function to be sampled\n+     * @param min Lower bound of the interval (included).\n+     * @param max Upper bound of the interval (excluded).\n+     * @param n Number of sample points.\n+     * @return the array of samples.\n      * @throws NumberIsTooLargeException if the lower bound {@code min} is\n-     * greater than, or equal to the upper bound {@code max}\n+     * greater than, or equal to the upper bound {@code max}.\n      * @throws NotStrictlyPositiveException if the number of sample points\n-     * {@code n} is negative\n+     * {@code n} is negative.\n      */\n     public static double[] sample(UnivariateFunction f,\n                                   double min, double max, int n) {", "timestamp": 1344014138, "metainfo": ""}