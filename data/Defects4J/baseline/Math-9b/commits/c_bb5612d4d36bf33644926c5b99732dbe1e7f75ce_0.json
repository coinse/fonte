{"sha": "bb5612d4d36bf33644926c5b99732dbe1e7f75ce", "log": "Fixed checkstyle warnings.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/interpolation/HermiteInterpolator.java\n             public double[] value(double x) {\n                 return derivative(x);\n             }\n-            \n+\n         };\n     }\n \n      * @exception MathIllegalStateException if interpolation cannot be performed\n      * because sample is empty\n      */\n-    private void checkInterpolation() throws MathIllegalStateException {        \n+    private void checkInterpolation() throws MathIllegalStateException {\n         if (abscissae.isEmpty()) {\n             throw new MathIllegalStateException(LocalizedFormats.EMPTY_INTERPOLATION_SAMPLE);\n         }\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Rotation.java\n \n   }\n \n+  /** Build the rotation that transforms a pair of vector into another pair.\n+\n+   * <p>Except for possible scale factors, if the instance were applied to\n+   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n+   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n+\n+   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n+   * not the same as the angular separation between v<sub>1</sub> and\n+   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n+   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n+   * v<sub>2</sub>) plane.</p>\n+\n+   * @param u1 first vector of the origin pair\n+   * @param u2 second vector of the origin pair\n+   * @param v1 desired image of u1 by the rotation\n+   * @param v2 desired image of u2 by the rotation\n+   * @exception MathIllegalArgumentException if the norm of one of the vectors is zero,\n+   * or if one of the pair is degenerated (i.e. the vectors of the pair are colinear)\n+   */\n+  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2)\n+      throws MathIllegalArgumentException {\n+\n+      // build orthonormalized base from u1, u2\n+      // this fails when vectors are null or colinear, which is forbidden to define a rotation\n+      final Vector3D u3 = u1.crossProduct(u2).normalize();\n+      u2 = u3.crossProduct(u1).normalize();\n+      u1 = u1.normalize();\n+\n+      // build an orthonormalized base from v1, v2\n+      // this fails when vectors are null or colinear, which is forbidden to define a rotation\n+      final Vector3D v3 = v1.crossProduct(v2).normalize();\n+      v2 = v3.crossProduct(v1).normalize();\n+      v1 = v1.normalize();\n+\n+      // buid a matrix transforming the first base into the second one\n+      final double[][] m = new double[][] {\n+          {\n+              MathArrays.linearCombination(u1.getX(), v1.getX(), u2.getX(), v2.getX(), u3.getX(), v3.getX()),\n+              MathArrays.linearCombination(u1.getY(), v1.getX(), u2.getY(), v2.getX(), u3.getY(), v3.getX()),\n+              MathArrays.linearCombination(u1.getZ(), v1.getX(), u2.getZ(), v2.getX(), u3.getZ(), v3.getX())\n+          },\n+          {\n+              MathArrays.linearCombination(u1.getX(), v1.getY(), u2.getX(), v2.getY(), u3.getX(), v3.getY()),\n+              MathArrays.linearCombination(u1.getY(), v1.getY(), u2.getY(), v2.getY(), u3.getY(), v3.getY()),\n+              MathArrays.linearCombination(u1.getZ(), v1.getY(), u2.getZ(), v2.getY(), u3.getZ(), v3.getY())\n+          },\n+          {\n+              MathArrays.linearCombination(u1.getX(), v1.getZ(), u2.getX(), v2.getZ(), u3.getX(), v3.getZ()),\n+              MathArrays.linearCombination(u1.getY(), v1.getZ(), u2.getY(), v2.getZ(), u3.getY(), v3.getZ()),\n+              MathArrays.linearCombination(u1.getZ(), v1.getZ(), u2.getZ(), v2.getZ(), u3.getZ(), v3.getZ())\n+          }\n+      };\n+\n+      double[] quat = mat2quat(m);\n+      q0 = quat[0];\n+      q1 = quat[1];\n+      q2 = quat[2];\n+      q3 = quat[3];\n+\n+  }\n+\n+  /** Build one of the rotations that transform one vector into another one.\n+\n+   * <p>Except for a possible scale factor, if the instance were\n+   * applied to the vector u it will produce the vector v. There is an\n+   * infinite number of such rotations, this constructor choose the\n+   * one with the smallest associated angle (i.e. the one whose axis\n+   * is orthogonal to the (u, v) plane). If u and v are colinear, an\n+   * arbitrary rotation axis is chosen.</p>\n+\n+   * @param u origin vector\n+   * @param v desired image of u by the rotation\n+   * @exception MathIllegalArgumentException if the norm of one of the vectors is zero\n+   */\n+  public Rotation(Vector3D u, Vector3D v) {\n+\n+    double normProduct = u.getNorm() * v.getNorm();\n+    if (normProduct == 0) {\n+        throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n+    }\n+\n+    double dot = u.dotProduct(v);\n+\n+    if (dot < ((2.0e-15 - 1.0) * normProduct)) {\n+      // special case u = -v: we select a PI angle rotation around\n+      // an arbitrary vector orthogonal to u\n+      Vector3D w = u.orthogonal();\n+      q0 = 0.0;\n+      q1 = -w.getX();\n+      q2 = -w.getY();\n+      q3 = -w.getZ();\n+    } else {\n+      // general case: (u, v) defines a plane, we select\n+      // the shortest possible rotation: axis orthogonal to this plane\n+      q0 = FastMath.sqrt(0.5 * (1.0 + dot / normProduct));\n+      double coeff = 1.0 / (2.0 * q0 * normProduct);\n+      Vector3D q = v.crossProduct(u);\n+      q1 = coeff * q.getX();\n+      q2 = coeff * q.getY();\n+      q3 = coeff * q.getZ();\n+    }\n+\n+  }\n+\n+  /** Build a rotation from three Cardan or Euler elementary rotations.\n+\n+   * <p>Cardan rotations are three successive rotations around the\n+   * canonical axes X, Y and Z, each axis being used once. There are\n+   * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n+   * rotations are three successive rotations around the canonical\n+   * axes X, Y and Z, the first and last rotations being around the\n+   * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n+   * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n+   * <p>Beware that many people routinely use the term Euler angles even\n+   * for what really are Cardan angles (this confusion is especially\n+   * widespread in the aerospace business where Roll, Pitch and Yaw angles\n+   * are often wrongly tagged as Euler angles).</p>\n+\n+   * @param order order of rotations to use\n+   * @param alpha1 angle of the first elementary rotation\n+   * @param alpha2 angle of the second elementary rotation\n+   * @param alpha3 angle of the third elementary rotation\n+   */\n+  public Rotation(RotationOrder order,\n+                  double alpha1, double alpha2, double alpha3) {\n+    Rotation r1 = new Rotation(order.getA1(), alpha1);\n+    Rotation r2 = new Rotation(order.getA2(), alpha2);\n+    Rotation r3 = new Rotation(order.getA3(), alpha3);\n+    Rotation composed = r1.applyTo(r2.applyTo(r3));\n+    q0 = composed.q0;\n+    q1 = composed.q1;\n+    q2 = composed.q2;\n+    q3 = composed.q3;\n+  }\n+\n   /** Convert an orthogonal rotation matrix to a quaternion.\n    * @param ort orthogonal rotation matrix\n    * @return quaternion corresponding to the matrix\n \n   }\n \n-  /** Build the rotation that transforms a pair of vector into another pair.\n-\n-   * <p>Except for possible scale factors, if the instance were applied to\n-   * the pair (u<sub>1</sub>, u<sub>2</sub>) it will produce the pair\n-   * (v<sub>1</sub>, v<sub>2</sub>).</p>\n-\n-   * <p>If the angular separation between u<sub>1</sub> and u<sub>2</sub> is\n-   * not the same as the angular separation between v<sub>1</sub> and\n-   * v<sub>2</sub>, then a corrected v'<sub>2</sub> will be used rather than\n-   * v<sub>2</sub>, the corrected vector will be in the (v<sub>1</sub>,\n-   * v<sub>2</sub>) plane.</p>\n-\n-   * @param u1 first vector of the origin pair\n-   * @param u2 second vector of the origin pair\n-   * @param v1 desired image of u1 by the rotation\n-   * @param v2 desired image of u2 by the rotation\n-   * @exception MathIllegalArgumentException if the norm of one of the vectors is zero,\n-   * or if one of the pair is degenerated (i.e. the vectors of the pair are colinear)\n-   */\n-  public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2)\n-      throws MathIllegalArgumentException {\n-\n-      // build orthonormalized base from u1, u2\n-      // this fails when vectors are null or colinear, which is forbidden to define a rotation\n-      final Vector3D u3 = u1.crossProduct(u2).normalize();\n-      u2 = u3.crossProduct(u1).normalize();\n-      u1 = u1.normalize();\n-\n-      // build an orthonormalized base from v1, v2\n-      // this fails when vectors are null or colinear, which is forbidden to define a rotation\n-      final Vector3D v3 = v1.crossProduct(v2).normalize();\n-      v2 = v3.crossProduct(v1).normalize();\n-      v1 = v1.normalize();\n-\n-      // buid a matrix transforming the first base into the second one\n-      final double[][] m = new double[][] {\n-          {\n-              MathArrays.linearCombination(u1.getX(), v1.getX(), u2.getX(), v2.getX(), u3.getX(), v3.getX()),\n-              MathArrays.linearCombination(u1.getY(), v1.getX(), u2.getY(), v2.getX(), u3.getY(), v3.getX()),\n-              MathArrays.linearCombination(u1.getZ(), v1.getX(), u2.getZ(), v2.getX(), u3.getZ(), v3.getX())\n-          },\n-          {\n-              MathArrays.linearCombination(u1.getX(), v1.getY(), u2.getX(), v2.getY(), u3.getX(), v3.getY()),\n-              MathArrays.linearCombination(u1.getY(), v1.getY(), u2.getY(), v2.getY(), u3.getY(), v3.getY()),\n-              MathArrays.linearCombination(u1.getZ(), v1.getY(), u2.getZ(), v2.getY(), u3.getZ(), v3.getY())\n-          },\n-          {\n-              MathArrays.linearCombination(u1.getX(), v1.getZ(), u2.getX(), v2.getZ(), u3.getX(), v3.getZ()),\n-              MathArrays.linearCombination(u1.getY(), v1.getZ(), u2.getY(), v2.getZ(), u3.getY(), v3.getZ()),\n-              MathArrays.linearCombination(u1.getZ(), v1.getZ(), u2.getZ(), v2.getZ(), u3.getZ(), v3.getZ())\n-          }\n-      };\n-\n-      double[] quat = mat2quat(m);\n-      q0 = quat[0];\n-      q1 = quat[1];\n-      q2 = quat[2];\n-      q3 = quat[3];\n-\n-  }\n-\n-  /** Build one of the rotations that transform one vector into another one.\n-\n-   * <p>Except for a possible scale factor, if the instance were\n-   * applied to the vector u it will produce the vector v. There is an\n-   * infinite number of such rotations, this constructor choose the\n-   * one with the smallest associated angle (i.e. the one whose axis\n-   * is orthogonal to the (u, v) plane). If u and v are colinear, an\n-   * arbitrary rotation axis is chosen.</p>\n-\n-   * @param u origin vector\n-   * @param v desired image of u by the rotation\n-   * @exception MathIllegalArgumentException if the norm of one of the vectors is zero\n-   */\n-  public Rotation(Vector3D u, Vector3D v) {\n-\n-    double normProduct = u.getNorm() * v.getNorm();\n-    if (normProduct == 0) {\n-        throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n-    }\n-\n-    double dot = u.dotProduct(v);\n-\n-    if (dot < ((2.0e-15 - 1.0) * normProduct)) {\n-      // special case u = -v: we select a PI angle rotation around\n-      // an arbitrary vector orthogonal to u\n-      Vector3D w = u.orthogonal();\n-      q0 = 0.0;\n-      q1 = -w.getX();\n-      q2 = -w.getY();\n-      q3 = -w.getZ();\n-    } else {\n-      // general case: (u, v) defines a plane, we select\n-      // the shortest possible rotation: axis orthogonal to this plane\n-      q0 = FastMath.sqrt(0.5 * (1.0 + dot / normProduct));\n-      double coeff = 1.0 / (2.0 * q0 * normProduct);\n-      Vector3D q = v.crossProduct(u);\n-      q1 = coeff * q.getX();\n-      q2 = coeff * q.getY();\n-      q3 = coeff * q.getZ();\n-    }\n-\n-  }\n-\n-  /** Build a rotation from three Cardan or Euler elementary rotations.\n-\n-   * <p>Cardan rotations are three successive rotations around the\n-   * canonical axes X, Y and Z, each axis being used once. There are\n-   * 6 such sets of rotations (XYZ, XZY, YXZ, YZX, ZXY and ZYX). Euler\n-   * rotations are three successive rotations around the canonical\n-   * axes X, Y and Z, the first and last rotations being around the\n-   * same axis. There are 6 such sets of rotations (XYX, XZX, YXY,\n-   * YZY, ZXZ and ZYZ), the most popular one being ZXZ.</p>\n-   * <p>Beware that many people routinely use the term Euler angles even\n-   * for what really are Cardan angles (this confusion is especially\n-   * widespread in the aerospace business where Roll, Pitch and Yaw angles\n-   * are often wrongly tagged as Euler angles).</p>\n-\n-   * @param order order of rotations to use\n-   * @param alpha1 angle of the first elementary rotation\n-   * @param alpha2 angle of the second elementary rotation\n-   * @param alpha3 angle of the third elementary rotation\n-   */\n-  public Rotation(RotationOrder order,\n-                  double alpha1, double alpha2, double alpha3) {\n-    Rotation r1 = new Rotation(order.getA1(), alpha1);\n-    Rotation r2 = new Rotation(order.getA2(), alpha2);\n-    Rotation r3 = new Rotation(order.getA3(), alpha3);\n-    Rotation composed = r1.applyTo(r2.applyTo(r3));\n-    q0 = composed.q0;\n-    q1 = composed.q1;\n-    q2 = composed.q2;\n-    q3 = composed.q3;\n-  }\n-\n   /** Revert a rotation.\n    * Build a rotation which reverse the effect of another\n    * rotation. This means that if r(u) = v, then r.revert(v) = u. The", "timestamp": 1340014420, "metainfo": ""}