{"sha": "5b6969f0980eb50a2b6aec9f6b193ecc6f5aa7a6", "log": "split the analysis package into several sub-packages  ", "commit": "\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/integration/RombergIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Romberg integrator.\n+ * <p>\n+ * Romberg algorithm is very fast for good behavior integrand. Test runs\n+ * show that for a default relative accuracy of 1E-6, it generally takes\n+ * takes less than 5 iterations for the integral to converge.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class RombergIntegratorTest extends TestCase {\n+\n+    /**\n+     * Test of integrator for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new RombergIntegrator(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = Math.PI; expected = 2;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -Math.PI/3; max = 0; expected = -0.5;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of integrator for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealIntegrator integrator = new RombergIntegrator(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = 1; expected = -1.0/48;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0; max = 0.5; expected = 11.0/768;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the integrator.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new RombergIntegrator(f);\n+\n+        try {\n+            // bad interval\n+            integrator.integrate(1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            integrator.setMinimalIterationCount(5);\n+            integrator.setMaximalIterationCount(4);\n+            integrator.integrate(-1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            integrator.setMinimalIterationCount(10);\n+            integrator.setMaximalIterationCount(50);\n+            integrator.integrate(-1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/integration/SimpsonIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Simpson integrator.\n+ * <p>\n+ * Test runs show that for a default relative accuracy of 1E-6, it\n+ * generally takes 5 to 10 iterations for the integral to converge.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class SimpsonIntegratorTest extends TestCase {\n+\n+    /**\n+     * Test of integrator for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new SimpsonIntegrator(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = Math.PI; expected = 2;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -Math.PI/3; max = 0; expected = -0.5;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of integrator for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealIntegrator integrator = new SimpsonIntegrator(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = 1; expected = -1.0/48;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0; max = 0.5; expected = 11.0/768;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the integrator.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new SimpsonIntegrator(f);\n+\n+        try {\n+            // bad interval\n+            integrator.integrate(1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            integrator.setMinimalIterationCount(5);\n+            integrator.setMaximalIterationCount(4);\n+            integrator.integrate(-1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            integrator.setMinimalIterationCount(10);\n+            integrator.setMaximalIterationCount(99);\n+            integrator.integrate(-1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/integration/TrapezoidIntegratorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.integration;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for trapezoid integrator.\n+ * <p>\n+ * Test runs show that for a default relative accuracy of 1E-6, it\n+ * generally takes 10 to 15 iterations for the integral to converge.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class TrapezoidIntegratorTest extends TestCase {\n+\n+    /**\n+     * Test of integrator for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new TrapezoidIntegrator(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = Math.PI; expected = 2;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -Math.PI/3; max = 0; expected = -0.5;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of integrator for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealIntegrator integrator = new TrapezoidIntegrator(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 0; max = 1; expected = -1.0/48;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0; max = 0.5; expected = 11.0/768;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1; max = 4; expected = 2048/3.0 - 78 + 1.0/48;\n+        tolerance = Math.abs(expected * integrator.getRelativeAccuracy());\n+        result = integrator.integrate(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the integrator.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealIntegrator integrator = new TrapezoidIntegrator(f);\n+\n+        try {\n+            // bad interval\n+            integrator.integrate(1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            integrator.setMinimalIterationCount(5);\n+            integrator.setMaximalIterationCount(4);\n+            integrator.integrate(-1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad iteration limits\n+            integrator.setMinimalIterationCount(10);\n+            integrator.setMaximalIterationCount(99);\n+            integrator.integrate(-1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad iteration limits\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/interpolation/DividedDifferenceInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.Expm1Function;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Divided Difference interpolator.\n+ * <p>\n+ * The error of polynomial interpolation is\n+ *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n!\n+ * where f^(n) is the n-th derivative of the approximated function and\n+ * zeta is some point in the interval determined by x[] and z.\n+ * <p>\n+ * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound\n+ * it and use the absolute value upper bound for estimates. For reference,\n+ * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class DividedDifferenceInterpolatorTest extends TestCase {\n+\n+    /**\n+     * Test of interpolator for the sine function.\n+     * <p>\n+     * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n+        double x[], y[], z, expected, result, tolerance;\n+\n+        // 6 interpolating points on interval [0, 2*PI]\n+        int n = 6;\n+        double min = 0.0, max = 2 * Math.PI;\n+        x = new double[n];\n+        y = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            x[i] = min + i * (max - min) / n;\n+            y[i] = f.value(x[i]);\n+        }\n+        double derivativebound = 1.0;\n+        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+\n+        z = Math.PI / 4; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = Math.PI * 1.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of interpolator for the exponential function.\n+     * <p>\n+     * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]\n+     */\n+    public void testExpm1Function() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n+        double x[], y[], z, expected, result, tolerance;\n+\n+        // 5 interpolating points on interval [-1, 1]\n+        int n = 5;\n+        double min = -1.0, max = 1.0;\n+        x = new double[n];\n+        y = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            x[i] = min + i * (max - min) / n;\n+            y[i] = f.value(x[i]);\n+        }\n+        double derivativebound = Math.E;\n+        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+\n+        z = 0.0; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 0.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -0.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the interpolator.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator();\n+\n+        try {\n+            // bad abscissas array\n+            double x[] = { 1.0, 2.0, 2.0, 4.0 };\n+            double y[] = { 0.0, 4.0, 4.0, 2.5 };\n+            UnivariateRealFunction p = interpolator.interpolate(x, y);\n+            p.value(0.0);\n+            fail(\"Expecting MathException - bad abscissas array\");\n+        } catch (MathException ex) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!\n+     */\n+    protected double partialerror(double x[], double z) throws\n+        IllegalArgumentException {\n+\n+        if (x.length < 1) {\n+            throw new IllegalArgumentException\n+                (\"Interpolation array cannot be empty.\");\n+        }\n+        double out = 1;\n+        for (int i = 0; i < x.length; i++) {\n+            out *= (z - x[i]) / (i + 1);\n+        }\n+        return out;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/interpolation/NevilleInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.Expm1Function;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Neville interpolator.\n+ * <p>\n+ * The error of polynomial interpolation is\n+ *     f(z) - p(z) = f^(n)(zeta) * (z-x[0])(z-x[1])...(z-x[n-1]) / n!\n+ * where f^(n) is the n-th derivative of the approximated function and\n+ * zeta is some point in the interval determined by x[] and z.\n+ * <p>\n+ * Since zeta is unknown, f^(n)(zeta) cannot be calculated. But we can bound\n+ * it and use the absolute value upper bound for estimates. For reference,\n+ * see <b>Introduction to Numerical Analysis</b>, ISBN 038795452X, chapter 2.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class NevilleInterpolatorTest extends TestCase {\n+\n+    /**\n+     * Test of interpolator for the sine function.\n+     * <p>\n+     * |sin^(n)(zeta)| <= 1.0, zeta in [0, 2*PI]\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n+        double x[], y[], z, expected, result, tolerance;\n+\n+        // 6 interpolating points on interval [0, 2*PI]\n+        int n = 6;\n+        double min = 0.0, max = 2 * Math.PI;\n+        x = new double[n];\n+        y = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            x[i] = min + i * (max - min) / n;\n+            y[i] = f.value(x[i]);\n+        }\n+        double derivativebound = 1.0;\n+        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+\n+        z = Math.PI / 4; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = Math.PI * 1.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of interpolator for the exponential function.\n+     * <p>\n+     * |expm1^(n)(zeta)| <= e, zeta in [-1, 1]\n+     */\n+    public void testExpm1Function() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n+        double x[], y[], z, expected, result, tolerance;\n+\n+        // 5 interpolating points on interval [-1, 1]\n+        int n = 5;\n+        double min = -1.0, max = 1.0;\n+        x = new double[n];\n+        y = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            x[i] = min + i * (max - min) / n;\n+            y[i] = f.value(x[i]);\n+        }\n+        double derivativebound = Math.E;\n+        UnivariateRealFunction p = interpolator.interpolate(x, y);\n+\n+        z = 0.0; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 0.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -0.5; expected = f.value(z); result = p.value(z);\n+        tolerance = Math.abs(derivativebound * partialerror(x, z));\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the interpolator.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealInterpolator interpolator = new NevilleInterpolator();\n+\n+        try {\n+            // bad abscissas array\n+            double x[] = { 1.0, 2.0, 2.0, 4.0 };\n+            double y[] = { 0.0, 4.0, 4.0, 2.5 };\n+            UnivariateRealFunction p = interpolator.interpolate(x, y);\n+            p.value(0.0);\n+            fail(\"Expecting MathException - bad abscissas array\");\n+        } catch (MathException ex) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * Returns the partial error term (z-x[0])(z-x[1])...(z-x[n-1])/n!\n+     */\n+    protected double partialerror(double x[], double z) throws\n+        IllegalArgumentException {\n+\n+        if (x.length < 1) {\n+            throw new IllegalArgumentException\n+                (\"Interpolation array cannot be empty.\");\n+        }\n+        double out = 1;\n+        for (int i = 0; i < x.length; i++) {\n+            out *= (z - x[i]) / (i + 1);\n+        }\n+        return out;\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/interpolation/SplineInterpolatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.interpolation;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math.analysis.polynomials.PolynomialSplineFunction;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test the SplineInterpolator.\n+ *\n+ * @version $Revision$ $Date$ \n+ */\n+public class SplineInterpolatorTest extends TestCase {\n+    \n+    /** error tolerance for spline interpolator value at knot points */\n+    protected double knotTolerance = 1E-12;\n+   \n+    /** error tolerance for interpolating polynomial coefficients */\n+    protected double coefficientTolerance = 1E-6;\n+    \n+    /** error tolerance for interpolated values -- high value is from sin test */\n+    protected double interpolationTolerance = 1E-2;\n+\n+    public SplineInterpolatorTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SplineInterpolatorTest.class);\n+        suite.setName(\"UnivariateRealInterpolator Tests\");\n+        return suite;\n+    }\n+\n+    public void testInterpolateLinearDegenerateTwoSegment()\n+        throws Exception {\n+        double x[] = { 0.0, 0.5, 1.0 };\n+        double y[] = { 0.0, 0.5, 1.0 };\n+        UnivariateRealInterpolator i = new SplineInterpolator();\n+        UnivariateRealFunction f = i.interpolate(x, y);\n+        verifyInterpolation(f, x, y);\n+        verifyConsistency((PolynomialSplineFunction) f, x);\n+        \n+        // Verify coefficients using analytical values\n+        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();\n+        double target[] = {y[0], 1d, 0d, 0d};\n+        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[1], 1d, 0d, 0d};\n+        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);\n+        \n+        // Check interpolation\n+        assertEquals(0.0,f.value(0.0), interpolationTolerance);\n+        assertEquals(0.4,f.value(0.4), interpolationTolerance);\n+        assertEquals(1.0,f.value(1.0), interpolationTolerance);\n+    }\n+\n+    public void testInterpolateLinearDegenerateThreeSegment()\n+        throws Exception {\n+        double x[] = { 0.0, 0.5, 1.0, 1.5 };\n+        double y[] = { 0.0, 0.5, 1.0, 1.5 };\n+        UnivariateRealInterpolator i = new SplineInterpolator();\n+        UnivariateRealFunction f = i.interpolate(x, y);\n+        verifyInterpolation(f, x, y);\n+        \n+        // Verify coefficients using analytical values\n+        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();\n+        double target[] = {y[0], 1d, 0d, 0d};\n+        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[1], 1d, 0d, 0d};\n+        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[2], 1d, 0d, 0d};\n+        TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);\n+        \n+        // Check interpolation\n+        assertEquals(0,f.value(0), interpolationTolerance);\n+        assertEquals(1.4,f.value(1.4), interpolationTolerance);\n+        assertEquals(1.5,f.value(1.5), interpolationTolerance);\n+    }\n+\n+    public void testInterpolateLinear() throws Exception {\n+        double x[] = { 0.0, 0.5, 1.0 };\n+        double y[] = { 0.0, 0.5, 0.0 };\n+        UnivariateRealInterpolator i = new SplineInterpolator();\n+        UnivariateRealFunction f = i.interpolate(x, y);\n+        verifyInterpolation(f, x, y);\n+        verifyConsistency((PolynomialSplineFunction) f, x);\n+        \n+        // Verify coefficients using analytical values\n+        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();\n+        double target[] = {y[0], 1.5d, 0d, -2d};\n+        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[1], 0d, -3d, 2d};\n+        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);    \n+    }\n+    \n+    public void testInterpolateSin() throws Exception {\n+        double x[] =\n+            {\n+                0.0,\n+                Math.PI / 6d,\n+                Math.PI / 2d,\n+                5d * Math.PI / 6d,\n+                Math.PI,\n+                7d * Math.PI / 6d,\n+                3d * Math.PI / 2d,\n+                11d * Math.PI / 6d,\n+                2.d * Math.PI };\n+        double y[] = { 0d, 0.5d, 1d, 0.5d, 0d, -0.5d, -1d, -0.5d, 0d };\n+        UnivariateRealInterpolator i = new SplineInterpolator();\n+        UnivariateRealFunction f = i.interpolate(x, y);\n+        verifyInterpolation(f, x, y);\n+        verifyConsistency((PolynomialSplineFunction) f, x);\n+        \n+        /* Check coefficients against values computed using R (version 1.8.1, Red Hat Linux 9)\n+         * \n+         * To replicate in R:\n+         *     x[1] <- 0\n+         *     x[2] <- pi / 6, etc, same for y[] (could use y <- scan() for y values)\n+         *     g <- splinefun(x, y, \"natural\")\n+         *     splinecoef <- eval(expression(z), envir = environment(g))\n+         *     print(splinecoef) \n+         */\n+        PolynomialFunction polynomials[] = ((PolynomialSplineFunction) f).getPolynomials();\n+        double target[] = {y[0], 1.002676d, 0d, -0.17415829d};\n+        TestUtils.assertEquals(polynomials[0].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[1], 8.594367e-01, -2.735672e-01, -0.08707914};\n+        TestUtils.assertEquals(polynomials[1].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[2], 1.471804e-17,-5.471344e-01, 0.08707914};\n+        TestUtils.assertEquals(polynomials[2].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[3], -8.594367e-01, -2.735672e-01, 0.17415829};\n+        TestUtils.assertEquals(polynomials[3].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[4], -1.002676, 6.548562e-17, 0.17415829};\n+        TestUtils.assertEquals(polynomials[4].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[5], -8.594367e-01, 2.735672e-01, 0.08707914};\n+        TestUtils.assertEquals(polynomials[5].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[6], 3.466465e-16, 5.471344e-01, -0.08707914};\n+        TestUtils.assertEquals(polynomials[6].getCoefficients(), target, coefficientTolerance);\n+        target = new double[]{y[7], 8.594367e-01, 2.735672e-01, -0.17415829};\n+        TestUtils.assertEquals(polynomials[7].getCoefficients(), target, coefficientTolerance); \n+        \n+        //Check interpolation\n+        assertEquals(Math.sqrt(2d) / 2d,f.value(Math.PI/4d),interpolationTolerance);\n+        assertEquals(Math.sqrt(2d) / 2d,f.value(3d*Math.PI/4d),interpolationTolerance);     \n+    }\n+    \n+\n+    public void testIllegalArguments() throws MathException {\n+        // Data set arrays of different size.\n+        UnivariateRealInterpolator i = new SplineInterpolator();\n+        try {\n+            double xval[] = { 0.0, 1.0 };\n+            double yval[] = { 0.0, 1.0, 2.0 };\n+            i.interpolate(xval, yval);\n+            fail(\"Failed to detect data set array with different sizes.\");\n+        } catch (IllegalArgumentException iae) {\n+        }\n+        // X values not sorted.\n+        try {\n+            double xval[] = { 0.0, 1.0, 0.5 };\n+            double yval[] = { 0.0, 1.0, 2.0 };\n+            i.interpolate(xval, yval);\n+            fail(\"Failed to detect unsorted arguments.\");\n+        } catch (IllegalArgumentException iae) {\n+        }\n+    }\n+    \n+    /**\n+     * verifies that f(x[i]) = y[i] for i = 0..n-1 where n is common length.\n+     */\n+    protected void verifyInterpolation(UnivariateRealFunction f, double x[], double y[])  \n+        throws Exception{\n+        for (int i = 0; i < x.length; i++) {\n+            assertEquals(f.value(x[i]), y[i], knotTolerance);\n+        }     \n+    }\n+    \n+    /**\n+     * Verifies that interpolating polynomials satisfy consistency requirement:\n+     *    adjacent polynomials must agree through two derivatives at knot points\n+     */\n+    protected void verifyConsistency(PolynomialSplineFunction f, double x[]) \n+        throws Exception {\n+        PolynomialFunction polynomials[] = f.getPolynomials();\n+        for (int i = 1; i < x.length - 2; i++) {\n+            // evaluate polynomials and derivatives at x[i + 1]  \n+            assertEquals(polynomials[i].value(x[i +1] - x[i]), polynomials[i + 1].value(0), 0.1); \n+            assertEquals(polynomials[i].derivative().value(x[i +1] - x[i]), \n+                    polynomials[i + 1].derivative().value(0), 0.5); \n+            assertEquals(polynomials[i].polynomialDerivative().derivative().value(x[i +1] - x[i]), \n+                    polynomials[i + 1].polynomialDerivative().derivative().value(0), 0.5); \n+        }\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/polynomials/PolynomialFunctionLagrangeFormTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Lagrange form of polynomial function.\n+ * <p>\n+ * We use n+1 points to interpolate a polynomial of degree n. This should\n+ * give us the exact same polynomial as result. Thus we can use a very\n+ * small tolerance to account only for round-off errors.\n+ *\n+ * @version $Revision$ $Date$ \n+ */\n+public final class PolynomialFunctionLagrangeFormTest extends TestCase {\n+\n+    /**\n+     * Test of polynomial for the linear function.\n+     */\n+    public void testLinearFunction() throws MathException {\n+        PolynomialFunctionLagrangeForm p;\n+        double c[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = 1.5x - 4\n+        double x[] = { 0.0, 3.0 };\n+        double y[] = { -4.0, 0.5 };\n+        p = new PolynomialFunctionLagrangeForm(x, y);\n+\n+        z = 2.0; expected = -1.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 4.5; expected = 2.75; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 6.0; expected = 5.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(1, p.degree());\n+\n+        c = p.getCoefficients();\n+        assertEquals(2, c.length);\n+        assertEquals(-4.0, c[0], tolerance);\n+        assertEquals(1.5, c[1], tolerance);\n+    }\n+\n+    /**\n+     * Test of polynomial for the quadratic function.\n+     */\n+    public void testQuadraticFunction() throws MathException {\n+        PolynomialFunctionLagrangeForm p;\n+        double c[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = 2x^2 + 5x - 3 = (2x - 1)(x + 3)\n+        double x[] = { 0.0, -1.0, 0.5 };\n+        double y[] = { -3.0, -6.0, 0.0 };\n+        p = new PolynomialFunctionLagrangeForm(x, y);\n+\n+        z = 1.0; expected = 4.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 2.5; expected = 22.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -2.0; expected = -5.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(2, p.degree());\n+\n+        c = p.getCoefficients();\n+        assertEquals(3, c.length);\n+        assertEquals(-3.0, c[0], tolerance);\n+        assertEquals(5.0, c[1], tolerance);\n+        assertEquals(2.0, c[2], tolerance);\n+    }\n+\n+    /**\n+     * Test of polynomial for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        PolynomialFunctionLagrangeForm p;\n+        double c[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x = x(x^2 - 1)(x + 2)(x - 3)\n+        double x[] = { 1.0, -1.0, 2.0, 3.0, -3.0, 0.5 };\n+        double y[] = { 0.0, 0.0, -24.0, 0.0, -144.0, 2.34375 };\n+        p = new PolynomialFunctionLagrangeForm(x, y);\n+\n+        z = 0.0; expected = 0.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -2.0; expected = 0.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 4.0; expected = 360.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(5, p.degree());\n+\n+        c = p.getCoefficients();\n+        assertEquals(6, c.length);\n+        assertEquals(0.0, c[0], tolerance);\n+        assertEquals(6.0, c[1], tolerance);\n+        assertEquals(1.0, c[2], tolerance);\n+        assertEquals(-7.0, c[3], tolerance);\n+        assertEquals(-1.0, c[4], tolerance);\n+        assertEquals(1.0, c[5], tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the polynomial.\n+     */\n+    public void testParameters() throws Exception {\n+\n+        try {\n+            // bad input array length\n+            double x[] = { 1.0 };\n+            double y[] = { 2.0 };\n+            new PolynomialFunctionLagrangeForm(x, y);\n+            fail(\"Expecting IllegalArgumentException - bad input array length\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // mismatch input arrays\n+            double x[] = { 1.0, 2.0, 3.0, 4.0 };\n+            double y[] = { 0.0, -4.0, -24.0 };\n+            new PolynomialFunctionLagrangeForm(x, y);\n+            fail(\"Expecting IllegalArgumentException - mismatch input arrays\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/polynomials/PolynomialFunctionNewtonFormTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+import org.apache.commons.math.MathException;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Newton form of polynomial function.\n+ * <p>\n+ * The small tolerance number is used only to account for round-off errors.\n+ *\n+ * @version $Revision$ $Date$ \n+ */\n+public final class PolynomialFunctionNewtonFormTest extends TestCase {\n+\n+    /**\n+     * Test of polynomial for the linear function.\n+     */\n+    public void testLinearFunction() throws MathException {\n+        PolynomialFunctionNewtonForm p;\n+        double coefficients[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = 1.5x - 4 = 2 + 1.5(x-4)\n+        double a[] = { 2.0, 1.5 };\n+        double c[] = { 4.0 };\n+        p = new PolynomialFunctionNewtonForm(a, c);\n+\n+        z = 2.0; expected = -1.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 4.5; expected = 2.75; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 6.0; expected = 5.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(1, p.degree());\n+\n+        coefficients = p.getCoefficients();\n+        assertEquals(2, coefficients.length);\n+        assertEquals(-4.0, coefficients[0], tolerance);\n+        assertEquals(1.5, coefficients[1], tolerance);\n+    }\n+\n+    /**\n+     * Test of polynomial for the quadratic function.\n+     */\n+    public void testQuadraticFunction() throws MathException {\n+        PolynomialFunctionNewtonForm p;\n+        double coefficients[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = 2x^2 + 5x - 3 = 4 + 3(x-1) + 2(x-1)(x+2)\n+        double a[] = { 4.0, 3.0, 2.0 };\n+        double c[] = { 1.0, -2.0 };\n+        p = new PolynomialFunctionNewtonForm(a, c);\n+\n+        z = 1.0; expected = 4.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 2.5; expected = 22.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -2.0; expected = -5.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(2, p.degree());\n+\n+        coefficients = p.getCoefficients();\n+        assertEquals(3, coefficients.length);\n+        assertEquals(-3.0, coefficients[0], tolerance);\n+        assertEquals(5.0, coefficients[1], tolerance);\n+        assertEquals(2.0, coefficients[2], tolerance);\n+    }\n+\n+    /**\n+     * Test of polynomial for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        PolynomialFunctionNewtonForm p;\n+        double coefficients[], z, expected, result, tolerance = 1E-12;\n+\n+        // p(x) = x^5 - x^4 - 7x^3 + x^2 + 6x\n+        //      = 6x - 6x^2 -6x^2(x-1) + x^2(x-1)(x+1) + x^2(x-1)(x+1)(x-2)\n+        double a[] = { 0.0, 6.0, -6.0, -6.0, 1.0, 1.0 };\n+        double c[] = { 0.0, 0.0, 1.0, -1.0, 2.0 };\n+        p = new PolynomialFunctionNewtonForm(a, c);\n+\n+        z = 0.0; expected = 0.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = -2.0; expected = 0.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        z = 4.0; expected = 360.0; result = p.value(z);\n+        assertEquals(expected, result, tolerance);\n+\n+        assertEquals(5, p.degree());\n+\n+        coefficients = p.getCoefficients();\n+        assertEquals(6, coefficients.length);\n+        assertEquals(0.0, coefficients[0], tolerance);\n+        assertEquals(6.0, coefficients[1], tolerance);\n+        assertEquals(1.0, coefficients[2], tolerance);\n+        assertEquals(-7.0, coefficients[3], tolerance);\n+        assertEquals(-1.0, coefficients[4], tolerance);\n+        assertEquals(1.0, coefficients[5], tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the polynomial.\n+     */\n+    public void testParameters() throws Exception {\n+\n+        try {\n+            // bad input array length\n+            double a[] = { 1.0 };\n+            double c[] = { 2.0 };\n+            new PolynomialFunctionNewtonForm(a, c);\n+            fail(\"Expecting IllegalArgumentException - bad input array length\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // mismatch input arrays\n+            double a[] = { 1.0, 2.0, 3.0, 4.0 };\n+            double c[] = { 4.0, 3.0, 2.0, 1.0 };\n+            new PolynomialFunctionNewtonForm(a, c);\n+            fail(\"Expecting IllegalArgumentException - mismatch input arrays\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/polynomials/PolynomialFunctionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+// commons-math\n+import org.apache.commons.math.MathException;\n+\n+// junit\n+import junit.framework.TestCase;\n+\n+/**\n+ * Tests the PolynomialFunction implementation of a UnivariateRealFunction.\n+ *\n+ * @version $Revision$\n+ * @author Matt Cliff <matt@mattcliff.com>\n+ */\n+public final class PolynomialFunctionTest extends TestCase {\n+\n+    /** Error tolerance for tests */\n+    protected double tolerance = 1.0e-12;\n+\n+    /**\n+     * tests the value of a constant polynomial.\n+     *\n+     * <p>value of this is 2.5 everywhere.</p>\n+     */\n+    public void testConstants() throws MathException {\n+        double[] c = { 2.5 };\n+        PolynomialFunction f = new PolynomialFunction( c );\n+\n+        // verify that we are equal to c[0] at several (nonsymmetric) places\n+        assertEquals( f.value( 0.0), c[0], tolerance );\n+        assertEquals( f.value( -1.0), c[0], tolerance );\n+        assertEquals( f.value( -123.5), c[0], tolerance );\n+        assertEquals( f.value( 3.0), c[0], tolerance );\n+        assertEquals( f.value( 456.89), c[0], tolerance );\n+        \n+        assertEquals(f.degree(), 0);\n+        assertEquals(f.derivative().value(0), 0, tolerance);\n+        \n+        assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance);\n+    }\n+\n+    /**\n+     * tests the value of a linear polynomial.\n+     *\n+     * <p>This will test the function f(x) = 3*x - 1.5</p>\n+     * <p>This will have the values \n+     *  <tt>f(0.0) = -1.5, f(-1.0) = -4.5, f(-2.5) = -9.0,\n+     *      f(0.5) = 0.0, f(1.5) = 3.0</tt> and <tt>f(3.0) = 7.5</tt>\n+     * </p>\n+     */\n+    public void testLinear() throws MathException {\n+        double[] c = { -1.5, 3.0 };\n+        PolynomialFunction f = new PolynomialFunction( c );\n+\n+        // verify that we are equal to c[0] when x=0\n+        assertEquals( f.value( 0.0), c[0], tolerance );\n+\n+        // now check a few other places\n+        assertEquals( -4.5, f.value( -1.0), tolerance );\n+        assertEquals( -9.0, f.value( -2.5), tolerance );\n+        assertEquals( 0.0, f.value( 0.5), tolerance );\n+        assertEquals( 3.0, f.value( 1.5), tolerance );\n+        assertEquals( 7.5, f.value( 3.0), tolerance );\n+        \n+        assertEquals(f.degree(), 1);\n+        \n+        assertEquals(f.polynomialDerivative().derivative().value(0), 0, tolerance);\n+    \n+    }\n+\n+\n+    /**\n+     * Tests a second order polynomial.\n+     * <p> This will test the function f(x) = 2x^2 - 3x -2 = (2x+1)(x-2)</p>\n+     *\n+     */\n+    public void testQuadratic() throws MathException {\n+        double[] c = { -2.0, -3.0, 2.0 };\n+        PolynomialFunction f = new PolynomialFunction( c );\n+\n+        // verify that we are equal to c[0] when x=0\n+        assertEquals( f.value( 0.0), c[0], tolerance );\n+\n+        // now check a few other places\n+        assertEquals( 0.0, f.value( -0.5), tolerance );\n+        assertEquals( 0.0, f.value( 2.0), tolerance );\n+        assertEquals( -2.0, f.value( 1.5), tolerance );\n+        assertEquals( 7.0, f.value( -1.5), tolerance );\n+        assertEquals( 265.5312, f.value( 12.34), tolerance );\n+    \n+    }    \n+\n+\n+    /** \n+     * This will test the quintic function \n+     *   f(x) = x^2(x-5)(x+3)(x-1) = x^5 - 3x^4 -13x^3 + 15x^2</p>\n+     *\n+     */\n+    public void testQuintic() throws MathException {\n+        double[] c = { 0.0, 0.0, 15.0, -13.0, -3.0, 1.0 };\n+        PolynomialFunction f = new PolynomialFunction( c );\n+\n+        // verify that we are equal to c[0] when x=0\n+        assertEquals( f.value( 0.0), c[0], tolerance );\n+\n+        // now check a few other places\n+        assertEquals( 0.0, f.value( 5.0), tolerance );\n+        assertEquals( 0.0, f.value( 1.0), tolerance );\n+        assertEquals( 0.0, f.value( -3.0), tolerance );\n+        assertEquals( 54.84375, f.value( -1.5), tolerance );\n+        assertEquals( -8.06637, f.value( 1.3), tolerance );\n+        \n+        assertEquals(f.degree(), 5);\n+    \n+    }    \n+\n+\n+    /**\n+     * tests the firstDerivative function by comparison\n+     *\n+     * <p>This will test the functions \n+     * <tt>f(x) = x^3 - 2x^2 + 6x + 3, g(x) = 3x^2 - 4x + 6</tt>\n+     * and <tt>h(x) = 6x - 4</tt>\n+     */\n+    public void testfirstDerivativeComparison() throws MathException {\n+        double[] f_coeff = { 3.0, 6.0, -2.0, 1.0 };\n+        double[] g_coeff = { 6.0, -4.0, 3.0 };\n+        double[] h_coeff = { -4.0, 6.0 };\n+\n+        PolynomialFunction f = new PolynomialFunction( f_coeff );\n+        PolynomialFunction g = new PolynomialFunction( g_coeff );\n+        PolynomialFunction h = new PolynomialFunction( h_coeff );\n+\n+        // compare f' = g\n+        assertEquals( f.derivative().value(0.0), g.value(0.0), tolerance );\n+        assertEquals( f.derivative().value(1.0), g.value(1.0), tolerance );\n+        assertEquals( f.derivative().value(100.0), g.value(100.0), tolerance );\n+        assertEquals( f.derivative().value(4.1), g.value(4.1), tolerance );\n+        assertEquals( f.derivative().value(-3.25), g.value(-3.25), tolerance );\n+\n+        // compare g' = h\n+        assertEquals( g.derivative().value(Math.PI), h.value(Math.PI), tolerance );\n+        assertEquals( g.derivative().value(Math.E),  h.value(Math.E),  tolerance );\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/polynomials/PolynomialSplineFunctionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.polynomials;\n+\n+import java.util.Arrays;\n+import junit.framework.TestCase;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+/**\n+ * Tests the PolynomialSplineFunction implementation.\n+ *\n+ * @version $Revision$\n+ */\n+public class PolynomialSplineFunctionTest extends TestCase {\n+\n+    /** Error tolerance for tests */\n+    protected double tolerance = 1.0e-12;\n+    \n+    /** \n+     * Quadratic polynomials used in tests: \n+     * \n+     * x^2 + x            [-1, 0)\n+     * x^2 + x + 2        [0, 1)\n+     * x^2 + x + 4        [1, 2)\n+     * \n+     * Defined so that evaluation using PolynomialSplineFunction evaluation\n+     * algorithm agrees at knot point boundaries.\n+     */\n+    protected PolynomialFunction[] polynomials = {\n+        new PolynomialFunction(new double[] {0d, 1d, 1d}), \n+        new PolynomialFunction(new double[] {2d, 1d, 1d}),\n+        new PolynomialFunction(new double[] {4d, 1d, 1d})\n+    };\n+    \n+    /** Knot points  */\n+    protected double[] knots = {-1, 0, 1, 2};\n+    \n+    /** Derivative of test polynomials -- 2x + 1  */\n+    protected PolynomialFunction dp = \n+        new PolynomialFunction(new double[] {1d, 2d});\n+    \n+    \n+    public void testConstructor() {\n+        PolynomialSplineFunction spline = \n+            new PolynomialSplineFunction(knots, polynomials);\n+        assertTrue(Arrays.equals(knots, spline.getKnots()));\n+        assertEquals(1d, spline.getPolynomials()[0].getCoefficients()[2], 0);\n+        assertEquals(3, spline.getN());\n+        \n+        try { // too few knots\n+            new PolynomialSplineFunction(new double[] {0}, polynomials);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        try { // too many knots\n+            new PolynomialSplineFunction(new double[] {0,1,2,3,4}, polynomials);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        \n+        try { // knots not increasing\n+            new PolynomialSplineFunction(new double[] {0,1, 3, 2}, polynomials);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testValues() throws Exception {\n+        PolynomialSplineFunction spline = \n+            new PolynomialSplineFunction(knots, polynomials);\n+        UnivariateRealFunction dSpline = spline.derivative();\n+        \n+        /**\n+         * interior points -- spline value at x should equal p(x - knot)\n+         * where knot is the largest knot point less than or equal to x and p \n+         * is the polynomial defined over the knot segment to which x belongs.\n+         */\n+        double x = -1;\n+        int index = 0;\n+        for (int i = 0; i < 10; i++) {\n+           x+=0.25;\n+           index = findKnot(knots, x);\n+           assertEquals(\"spline function evaluation failed for x=\" + x, \n+                   polynomials[index].value(x - knots[index]), spline.value(x), tolerance);\n+           assertEquals(\"spline derivative evaluation failed for x=\" + x,\n+                   dp.value(x - knots[index]), dSpline.value(x), tolerance);\n+        }\n+        \n+        // knot points -- centering should zero arguments\n+        for (int i = 0; i < 3; i++) {\n+            assertEquals(\"spline function evaluation failed for knot=\" + knots[i],\n+                    polynomials[i].value(0), spline.value(knots[i]), tolerance);\n+            assertEquals(\"spline function evaluation failed for knot=\" + knots[i],\n+                    dp.value(0), dSpline.value(knots[i]), tolerance);\n+        }\n+        \n+        try { //outside of domain -- under min\n+            x = spline.value(-1.5);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (FunctionEvaluationException ex) {\n+            // expected\n+        }\n+        \n+        try { //outside of domain -- over max\n+            x = spline.value(2.5);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (FunctionEvaluationException ex) {\n+            // expected\n+        }         \n+    }  \n+    \n+    /**\n+     *  Do linear search to find largest knot point less than or equal to x.\n+     *  Implementation does binary search.\n+     */\n+     protected int findKnot(double[] knots, double x) {\n+         if (x < knots[0] || x >= knots[knots.length -1]) {\n+             throw new IllegalArgumentException(\"x is out of range\");\n+         }\n+         for (int i = 0; i < knots.length; i++) {\n+             if (knots[i] > x) {\n+                 return i -1;\n+             }\n+         }\n+         throw new IllegalArgumentException(\"x is out of range\");\n+     }\n+}\n+    \n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/solvers/BisectionSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public final class BisectionSolverTest extends TestCase {\n+\n+    @Deprecated\n+    public void testDeprecated() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        double result;\n+        \n+        UnivariateRealSolver solver = new BisectionSolver(f);\n+        result = solver.solve(3, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(1, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+    }\n+\n+    public void testSinZero() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        double result;\n+        \n+        UnivariateRealSolver solver = new BisectionSolver();\n+        result = solver.solve(f, 3, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 1, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+    }\n+\n+   public void testQuinticZero() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        double result;\n+\n+        UnivariateRealSolver solver = new BisectionSolver();\n+        result = solver.solve(f, -0.2, 0.2);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, -0.1, 0.3);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, -0.3, 0.45);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.3, 0.7);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.2, 0.6);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.05, 0.95);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.85, 1.25);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.8, 1.2);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.85, 1.75);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.55, 1.45);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.85, 5);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        \n+        assertEquals(result, solver.getResult(), 0);\n+        assertTrue(solver.getIterationCount() > 0);\n+    }\n+    \n+    /**\n+     * \n+     */\n+    public void testSetFunctionValueAccuracy(){\n+        double expected = 1.0e-2;    \n+        UnivariateRealSolver solver = new BisectionSolver();\n+        solver.setFunctionValueAccuracy(expected);\n+        assertEquals(expected, solver.getFunctionValueAccuracy(), 1.0e-2);\n+    }        \n+    \n+    /**\n+     * \n+     */\n+    public void testResetFunctionValueAccuracy(){\n+        double newValue = 1.0e-2;    \n+        UnivariateRealSolver solver = new BisectionSolver();\n+        double oldValue = solver.getFunctionValueAccuracy();\n+        solver.setFunctionValueAccuracy(newValue);\n+        solver.resetFunctionValueAccuracy();\n+        assertEquals(oldValue, solver.getFunctionValueAccuracy(), 1.0e-2);\n+    }        \n+    \n+    /**\n+     * \n+     */\n+    public void testSetAbsoluteAccuracy(){\n+        double expected = 1.0e-2; \n+        UnivariateRealSolver solver = new BisectionSolver();\n+        solver.setAbsoluteAccuracy(expected);\n+        assertEquals(expected, solver.getAbsoluteAccuracy(), 1.0e-2); \n+    }        \n+    \n+    /**\n+     * \n+     */\n+    public void testResetAbsoluteAccuracy(){\n+        double newValue = 1.0e-2;       \n+        UnivariateRealSolver solver = new BisectionSolver();\n+        double oldValue = solver.getAbsoluteAccuracy();\n+        solver.setAbsoluteAccuracy(newValue);\n+        solver.resetAbsoluteAccuracy();\n+        assertEquals(oldValue, solver.getAbsoluteAccuracy(), 1.0e-2);\n+    }        \n+    \n+    /**\n+     * \n+     */\n+    public void testSetMaximalIterationCount(){\n+        int expected = 100;\n+        UnivariateRealSolver solver = new BisectionSolver();\n+        solver.setMaximalIterationCount(expected);\n+        assertEquals(expected, solver.getMaximalIterationCount());\n+    }        \n+    \n+    /**\n+     * \n+     */\n+    public void testResetMaximalIterationCount(){\n+        int newValue = 10000;\n+        UnivariateRealSolver solver = new BisectionSolver();\n+        int oldValue = solver.getMaximalIterationCount();\n+        solver.setMaximalIterationCount(newValue);\n+        solver.resetMaximalIterationCount();\n+        assertEquals(oldValue, solver.getMaximalIterationCount());\n+    }        \n+    \n+    /**\n+     * \n+     */\n+    public void testSetRelativeAccuracy(){\n+        double expected = 1.0e-2;\n+        UnivariateRealSolver solver = new BisectionSolver();\n+        solver.setRelativeAccuracy(expected);\n+        assertEquals(expected, solver.getRelativeAccuracy(), 1.0e-2);\n+    }        \n+    \n+    /**\n+     * \n+     */\n+    public void testResetRelativeAccuracy(){\n+        double newValue = 1.0e-2;        \n+        UnivariateRealSolver solver = new BisectionSolver();\n+        double oldValue = solver.getRelativeAccuracy();\n+        solver.setRelativeAccuracy(newValue);\n+        solver.resetRelativeAccuracy();\n+        assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);\n+    }        \n+    \n+    /**\n+     * Test Serialization and Recovery\n+     */\n+   public void testSerialization() throws MathException {\n+       UnivariateRealFunction f = (UnivariateRealFunction)TestUtils.serializeAndRecover(new QuinticFunction());\n+       double result;\n+       \n+       BisectionSolver solver = new BisectionSolver();\n+       UnivariateRealSolver solver2 = (UnivariateRealSolver)TestUtils.serializeAndRecover(solver);\n+       \n+       result = solver.solve(f, -0.2, 0.2);\n+       assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(f, -0.2, 0.2), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, -0.1, 0.3);\n+       assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(f, -0.1, 0.3), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, -0.3, 0.45);\n+       assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(f, -0.3, 0.45), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, 0.3, 0.7);\n+       assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(f, 0.3, 0.7), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, 0.2, 0.6);\n+       assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(f, 0.2, 0.6), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, 0.05, 0.95);\n+       assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(f, 0.05, 0.95), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, 0.85, 1.25);\n+       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(f, 0.85, 1.25), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, 0.8, 1.2);\n+       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(f, 0.8, 1.2), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, 0.85, 1.75);\n+       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(f, 0.85, 1.75), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, 0.55, 1.45);\n+       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(f, 0.55, 1.45), result, solver2.getAbsoluteAccuracy());\n+       \n+       result = solver.solve(f, 0.85, 5);\n+       assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+       assertEquals(solver2.solve(f, 0.85, 5), result, solver2.getAbsoluteAccuracy());\n+       \n+       /* Test Reset */\n+       double newValue = 1.0e-2;\n+       f = (UnivariateRealFunction)TestUtils.serializeAndRecover(new QuinticFunction());\n+       solver = new BisectionSolver();\n+       \n+       double oldValue = solver.getRelativeAccuracy();\n+       solver.setRelativeAccuracy(newValue);\n+       solver.resetRelativeAccuracy();\n+       assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);\n+       \n+       solver2 = (UnivariateRealSolver)TestUtils.serializeAndRecover(solver); \n+       \n+       assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);\n+       \n+       solver2.setRelativeAccuracy(newValue);\n+       solver2.resetRelativeAccuracy();\n+       \n+       assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);\n+       \n+   }\n+   \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/solvers/BrentSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.MonitoredFunction;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Testcase for UnivariateRealSolver.\n+ * Because Brent-Dekker is guaranteed to converge in less than the default\n+ * maximum iteration count due to bisection fallback, it is quite hard to\n+ * debug. I include measured iteration counts plus one in order to detect\n+ * regressions. On average Brent-Dekker should use 4..5 iterations for the\n+ * default absolute accuracy of 10E-8 for sinus and the quintic function around\n+ * zero, and 5..10 iterations for the other zeros.\n+ * \n+ * @version $Revision:670469 $ $Date:2008-06-23 10:01:38 +0200 (lun., 23 juin 2008) $ \n+ */\n+public final class BrentSolverTest extends TestCase {\n+\n+    public BrentSolverTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(BrentSolverTest.class);\n+        suite.setName(\"UnivariateRealSolver Tests\");\n+        return suite;\n+    }\n+\n+    @Deprecated\n+    public void testDeprecated() throws MathException {\n+        // The sinus function is behaved well around the root at #pi. The second\n+        // order derivative is zero, which means linar approximating methods will\n+        // still converge quadratically. \n+        UnivariateRealFunction f = new SinFunction();\n+        double result;\n+        UnivariateRealSolver solver = new BrentSolver(f);\n+        // Somewhat benign interval. The function is monotone.\n+        result = solver.solve(3, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 4 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 5);\n+        // Larger and somewhat less benign interval. The function is grows first.\n+        result = solver.solve(1, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        solver = new SecantSolver(f);\n+        result = solver.solve(3, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 4 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 5);\n+        result = solver.solve(1, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        assertEquals(result, solver.getResult(), 0);\n+    }\n+\n+    public void testSinZero() throws MathException {\n+        // The sinus function is behaved well around the root at #pi. The second\n+        // order derivative is zero, which means linar approximating methods will\n+        // still converge quadratically. \n+        UnivariateRealFunction f = new SinFunction();\n+        double result;\n+        UnivariateRealSolver solver = new BrentSolver();\n+        // Somewhat benign interval. The function is monotone.\n+        result = solver.solve(f, 3, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 4 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 5);\n+        // Larger and somewhat less benign interval. The function is grows first.\n+        result = solver.solve(f, 1, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        solver = new SecantSolver();\n+        result = solver.solve(f, 3, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 4 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 5);\n+        result = solver.solve(f, 1, 4);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        assertEquals(result, solver.getResult(), 0);\n+    }\n+\n+   public void testQuinticZero() throws MathException {\n+        // The quintic function has zeros at 0, +-0.5 and +-1.\n+        // Around the root of 0 the function is well behaved, with a second derivative\n+        // of zero a 0.\n+        // The other roots are less well to find, in particular the root at 1, because\n+        // the function grows fast for x>1.\n+        // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n+        // intervals containing these values are harder for the solvers.\n+        UnivariateRealFunction f = new QuinticFunction();\n+        double result;\n+        // Brent-Dekker solver.\n+        UnivariateRealSolver solver = new BrentSolver();\n+        // Symmetric bracket around 0. Test whether solvers can handle hitting\n+        // the root in the first iteration.\n+        result = solver.solve(f, -0.2, 0.2);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        assertTrue(solver.getIterationCount() <= 2);\n+        // 1 iterations on i586 JDK 1.4.1.\n+        // Asymmetric bracket around 0, just for fun. Contains extremum.\n+        result = solver.solve(f, -0.1, 0.3);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        // Large bracket around 0. Contains two extrema.\n+        result = solver.solve(f, -0.3, 0.45);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        // Benign bracket around 0.5, function is monotonous.\n+        result = solver.solve(f, 0.3, 0.7);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        // Less benign bracket around 0.5, contains one extremum.\n+        result = solver.solve(f, 0.2, 0.6);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        // Large, less benign bracket around 0.5, contains both extrema.\n+        result = solver.solve(f, 0.05, 0.95);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        // Relatively benign bracket around 1, function is monotonous. Fast growth for x>1\n+        // is still a problem.\n+        result = solver.solve(f, 0.85, 1.25);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        // Less benign bracket around 1 with extremum.\n+        result = solver.solve(f, 0.8, 1.2);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        // Large bracket around 1. Monotonous.\n+        result = solver.solve(f, 0.85, 1.75);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 10 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 11);\n+        // Large bracket around 1. Interval contains extremum.\n+        result = solver.solve(f, 0.55, 1.45);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 7 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 8);\n+        // Very large bracket around 1 for testing fast growth behaviour.\n+        result = solver.solve(f, 0.85, 5);\n+        //System.out.println(\n+       //     \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 12 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 13);\n+        // Secant solver.\n+        solver = new SecantSolver();\n+        result = solver.solve(f, -0.2, 0.2);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 1 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 2);\n+        result = solver.solve(f, -0.1, 0.3);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 5 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 6);\n+        result = solver.solve(f, -0.3, 0.45);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        result = solver.solve(f, 0.3, 0.7);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 7 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 8);\n+        result = solver.solve(f, 0.2, 0.6);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 6 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 7);\n+        result = solver.solve(f, 0.05, 0.95);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        result = solver.solve(f, 0.85, 1.25);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 10 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 11);\n+        result = solver.solve(f, 0.8, 1.2);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 8 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 9);\n+        result = solver.solve(f, 0.85, 1.75);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 14 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 15);\n+        // The followig is especially slow because the solver first has to reduce\n+        // the bracket to exclude the extremum. After that, convergence is rapide.\n+        result = solver.solve(f, 0.55, 1.45);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 7 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 8);\n+        result = solver.solve(f, 0.85, 5);\n+        //System.out.println(\n+        //    \"Root: \" + result + \" Iterations: \" + solver.getIterationCount());\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        // 14 iterations on i586 JDK 1.4.1.\n+        assertTrue(solver.getIterationCount() <= 15);\n+        // Static solve method\n+        result = UnivariateRealSolverUtils.solve(f, -0.2, 0.2);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        result = UnivariateRealSolverUtils.solve(f, -0.1, 0.3);\n+        assertEquals(result, 0, 1E-8);\n+        result = UnivariateRealSolverUtils.solve(f, -0.3, 0.45);\n+        assertEquals(result, 0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.3, 0.7);\n+        assertEquals(result, 0.5, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.2, 0.6);\n+        assertEquals(result, 0.5, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.05, 0.95);\n+        assertEquals(result, 0.5, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.25);\n+        assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.8, 1.2);\n+        assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.85, 1.75);\n+        assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.55, 1.45);\n+        assertEquals(result, 1.0, 1E-6);\n+        result = UnivariateRealSolverUtils.solve(f, 0.85, 5);\n+        assertEquals(result, 1.0, 1E-6);\n+    }\n+    \n+    public void testRootEndpoints() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new BrentSolver();\n+        \n+        // endpoint is root\n+        double result = solver.solve(f, Math.PI, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 3, Math.PI);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+    }\n+    \n+    public void testBadEndpoints() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new BrentSolver();\n+        try {  // bad interval\n+            solver.solve(f, 1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {  // no bracket\n+            solver.solve(f, 1, 1.5);\n+            fail(\"Expecting IllegalArgumentException - non-bracketing\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+\n+    public void testInitialGuess() throws MathException {\n+\n+        MonitoredFunction f = new MonitoredFunction(new QuinticFunction());\n+        UnivariateRealSolver solver = new BrentSolver();\n+        double result;\n+\n+        // no guess\n+        result = solver.solve(f, 0.6, 7.0);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        int referenceCallsCount = f.getCallsCount();\n+        assertTrue(referenceCallsCount >= 13);\n+ \n+        // invalid guess (it *is* a root, but outside of the range)\n+        try {\n+          result = solver.solve(f, 0.6, 7.0, 0.0);\n+          fail(\"an IllegalArgumentException was expected\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behaviour\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught: \" + e.getMessage());\n+        }\n+ \n+        // bad guess\n+        f.setCallsCount(0);\n+        result = solver.solve(f, 0.6, 7.0, 0.61);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        assertTrue(f.getCallsCount() > referenceCallsCount);\n+ \n+        // good guess\n+        f.setCallsCount(0);\n+        result = solver.solve(f, 0.6, 7.0, 0.999999);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        assertTrue(f.getCallsCount() < referenceCallsCount);\n+\n+        // perfect guess\n+        f.setCallsCount(0);\n+        result = solver.solve(f, 0.6, 7.0, 1.0);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        assertEquals(0, solver.getIterationCount());\n+        assertEquals(1, f.getCallsCount());\n+ \n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/solvers/LaguerreSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n+import org.apache.commons.math.complex.Complex;\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Laguerre solver.\n+ * <p>\n+ * Laguerre's method is very efficient in solving polynomials. Test runs\n+ * show that for a default absolute accuracy of 1E-6, it generally takes\n+ * less than 5 iterations to find one root, provided solveAll() is not\n+ * invoked, and 15 to 20 iterations to find all roots for quintic function.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class LaguerreSolverTest extends TestCase {\n+\n+    /**\n+     * Test deprecated APIs.\n+     */\n+    @Deprecated\n+    public void testDeprecated() throws MathException {\n+        double min, max, expected, result, tolerance;\n+\n+        // p(x) = 4x - 1\n+        double coefficients[] = { -1.0, 4.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        UnivariateRealSolver solver = new LaguerreSolver(f);\n+\n+        min = 0.0; max = 1.0; expected = 0.25;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the linear function.\n+     */\n+    public void testLinearFunction() throws MathException {\n+        double min, max, expected, result, tolerance;\n+\n+        // p(x) = 4x - 1\n+        double coefficients[] = { -1.0, 4.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        UnivariateRealSolver solver = new LaguerreSolver();\n+\n+        min = 0.0; max = 1.0; expected = 0.25;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quadratic function.\n+     */\n+    public void testQuadraticFunction() throws MathException {\n+        double min, max, expected, result, tolerance;\n+\n+        // p(x) = 2x^2 + 5x - 3 = (x+3)(2x-1)\n+        double coefficients[] = { -3.0, 5.0, 2.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        UnivariateRealSolver solver = new LaguerreSolver();\n+\n+        min = 0.0; max = 2.0; expected = 0.5;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -4.0; max = -1.0; expected = -3.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        double min, max, expected, result, tolerance;\n+\n+        // p(x) = x^5 - x^4 - 12x^3 + x^2 - x - 12 = (x+1)(x+3)(x-4)(x^2-x+1)\n+        double coefficients[] = { -12.0, -1.0, 1.0, -12.0, -1.0, 1.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        UnivariateRealSolver solver = new LaguerreSolver();\n+\n+        min = -2.0; max = 2.0; expected = -1.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -5.0; max = -2.5; expected = -3.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 3.0; max = 6.0; expected = 4.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function using solveAll().\n+     */\n+    public void testQuinticFunction2() throws MathException {\n+        double initial = 0.0, tolerance;\n+        Complex expected, result[];\n+\n+        // p(x) = x^5 + 4x^3 + x^2 + 4 = (x+1)(x^2-x+1)(x^2+4)\n+        double coefficients[] = { 4.0, 0.0, 1.0, 4.0, 0.0, 1.0 };\n+        LaguerreSolver solver = new LaguerreSolver();\n+        result = solver.solveAll(coefficients, initial);\n+\n+        expected = new Complex(0.0, -2.0);\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        TestUtils.assertContains(result, expected, tolerance);\n+\n+        expected = new Complex(0.0, 2.0);\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        TestUtils.assertContains(result, expected, tolerance);\n+\n+        expected = new Complex(0.5, 0.5 * Math.sqrt(3.0));\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        TestUtils.assertContains(result, expected, tolerance);\n+\n+        expected = new Complex(-1.0, 0.0);\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        TestUtils.assertContains(result, expected, tolerance);\n+        \n+        expected = new Complex(0.5, -0.5 * Math.sqrt(3.0));\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected.abs() * solver.getRelativeAccuracy()));\n+        TestUtils.assertContains(result, expected, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the solver.\n+     */\n+    public void testParameters() throws Exception {\n+        double coefficients[] = { -3.0, 5.0, 2.0 };\n+        PolynomialFunction f = new PolynomialFunction(coefficients);\n+        UnivariateRealSolver solver = new LaguerreSolver();\n+\n+        try {\n+            // bad interval\n+            solver.solve(f, 1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // no bracketing\n+            solver.solve(f, 2, 3);\n+            fail(\"Expecting IllegalArgumentException - no bracketing\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // bad function\n+            solver.solve(new SinFunction(), -1, 1);\n+            fail(\"Expecting IllegalArgumentException - bad function\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/solvers/MullerSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.Expm1Function;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Muller solver.\n+ * <p>\n+ * Muller's method converges almost quadratically near roots, but it can\n+ * be very slow in regions far away from zeros. Test runs show that for\n+ * reasonably good initial values, for a default absolute accuracy of 1E-6,\n+ * it generally takes 5 to 10 iterations for the solver to converge.\n+ * <p>\n+ * Tests for the exponential function illustrate the situations where\n+ * Muller solver performs poorly.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class MullerSolverTest extends TestCase {\n+\n+    /**\n+     * Test deprecated APIs.\n+     */\n+    @Deprecated\n+    public void testDeprecated() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new MullerSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 3.0; max = 4.0; expected = Math.PI;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1.0; max = 1.5; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test deprecated APIs.\n+     */\n+    @Deprecated\n+    public void testDeprecated2() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        MullerSolver solver = new MullerSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = -0.4; max = 0.2; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0.75; max = 1.5; expected = 1.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -0.9; max = -0.2; expected = -0.5;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new MullerSolver();\n+        double min, max, expected, result, tolerance;\n+\n+        min = 3.0; max = 4.0; expected = Math.PI;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1.0; max = 1.5; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the sine function using solve2().\n+     */\n+    public void testSinFunction2() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        MullerSolver solver = new MullerSolver();\n+        double min, max, expected, result, tolerance;\n+\n+        min = 3.0; max = 4.0; expected = Math.PI;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1.0; max = 1.5; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealSolver solver = new MullerSolver();\n+        double min, max, expected, result, tolerance;\n+\n+        min = -0.4; max = 0.2; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0.75; max = 1.5; expected = 1.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -0.9; max = -0.2; expected = -0.5;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function using solve2().\n+     */\n+    public void testQuinticFunction2() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        MullerSolver solver = new MullerSolver();\n+        double min, max, expected, result, tolerance;\n+\n+        min = -0.4; max = 0.2; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0.75; max = 1.5; expected = 1.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -0.9; max = -0.2; expected = -0.5;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the exponential function.\n+     * <p>\n+     * It takes 10 to 15 iterations for the last two tests to converge.\n+     * In fact, if not for the bisection alternative, the solver would\n+     * exceed the default maximal iteration of 100.\n+     */\n+    public void testExpm1Function() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateRealSolver solver = new MullerSolver();\n+        double min, max, expected, result, tolerance;\n+\n+        min = -1.0; max = 2.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -20.0; max = 10.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -50.0; max = 100.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the exponential function using solve2().\n+     * <p>\n+     * It takes 25 to 50 iterations for the last two tests to converge.\n+     */\n+    public void testExpm1Function2() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        MullerSolver solver = new MullerSolver();\n+        double min, max, expected, result, tolerance;\n+\n+        min = -1.0; max = 2.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -20.0; max = 10.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -50.0; max = 100.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve2(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the solver.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new MullerSolver();\n+\n+        try {\n+            // bad interval\n+            solver.solve(f, 1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // no bracketing\n+            solver.solve(f, 2, 3);\n+            fail(\"Expecting IllegalArgumentException - no bracketing\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/solvers/NewtonSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public final class NewtonSolverTest extends TestCase {\n+\n+    @Deprecated\n+    public void testDeprecated() throws MathException {\n+        DifferentiableUnivariateRealFunction f = new SinFunction();\n+        double result;\n+        \n+        UnivariateRealSolver solver = new NewtonSolver(f);\n+        result = solver.solve(3, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(1, 4);\n+        assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+        \n+        //TODO:  create abstract solver test class, move these there\n+        assertEquals(result, solver.getResult(), 0);\n+        assertTrue(solver.getIterationCount() > 0);\n+    }\n+\n+    /**\n+    *\n+    */\n+   public void testSinZero() throws MathException {\n+       DifferentiableUnivariateRealFunction f = new SinFunction();\n+       double result;\n+       \n+       UnivariateRealSolver solver = new NewtonSolver();\n+       result = solver.solve(f, 3, 4);\n+       assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+\n+       result = solver.solve(f, 1, 4);\n+       assertEquals(result, Math.PI, solver.getAbsoluteAccuracy());\n+       \n+       //TODO:  create abstract solver test class, move these there\n+       assertEquals(result, solver.getResult(), 0);\n+       assertTrue(solver.getIterationCount() > 0);\n+   }\n+\n+   /**\n+     *\n+     */\n+    public void testQuinticZero() throws MathException {\n+        DifferentiableUnivariateRealFunction f = new QuinticFunction();\n+        double result;\n+\n+        UnivariateRealSolver solver = new NewtonSolver();\n+        result = solver.solve(f, -0.2, 0.2);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, -0.1, 0.3);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, -0.3, 0.45);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.3, 0.7);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.2, 0.6);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.05, 0.95);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.85, 1.25);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.8, 1.2);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.85, 1.75);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.55, 1.45);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+\n+        result = solver.solve(f, 0.85, 5);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+    }\n+    \n+    /**\n+     * Test Serialization and Recovery\n+     */\n+    public void testSerialization() throws MathException {\n+        DifferentiableUnivariateRealFunction f = new QuinticFunction();\n+        double result;\n+        \n+        NewtonSolver solver = new NewtonSolver();\n+        NewtonSolver solver2 = (NewtonSolver)TestUtils.serializeAndRecover(solver);\n+        \n+        result = solver.solve(f, -0.2, 0.2);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, -0.2, 0.2), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(f, -0.1, 0.3);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, -0.1, 0.3), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(f, -0.3, 0.45);\n+        assertEquals(result, 0, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, -0.3, 0.45), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(f, 0.3, 0.7);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, 0.3, 0.7), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(f, 0.2, 0.6);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, 0.2, 0.6), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(f, 0.05, 0.95);\n+        assertEquals(result, 0.5, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, 0.05, 0.95), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(f, 0.85, 1.25);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, 0.85, 1.25), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(f, 0.8, 1.2);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, 0.8, 1.2), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(f, 0.85, 1.75);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, 0.85, 1.75), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(f, 0.55, 1.45);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, 0.55, 1.45), result, solver2.getAbsoluteAccuracy());\n+        \n+        result = solver.solve(f, 0.85, 5);\n+        assertEquals(result, 1.0, solver.getAbsoluteAccuracy());\n+        assertEquals(solver2.solve(f, 0.85, 5), result, solver2.getAbsoluteAccuracy());\n+        \n+        /* Test Reset */\n+        double newValue = 1.0e-2;\n+        f = new QuinticFunction();\n+        solver = new NewtonSolver();\n+        \n+        double oldValue = solver.getRelativeAccuracy();\n+        solver.setRelativeAccuracy(newValue);\n+        solver.resetRelativeAccuracy();\n+        assertEquals(oldValue, solver.getRelativeAccuracy(), 1.0e-2);\n+        \n+        solver2 = (NewtonSolver)TestUtils.serializeAndRecover(solver); \n+        \n+        assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);\n+        \n+        solver2.setRelativeAccuracy(newValue);\n+        solver2.resetRelativeAccuracy();\n+        \n+        assertEquals(oldValue, solver2.getRelativeAccuracy(), 1.0e-2);\n+        \n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/solvers/RiddersSolverTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.Expm1Function;\n+import org.apache.commons.math.analysis.QuinticFunction;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Testcase for Ridders solver.\n+ * <p>\n+ * Ridders' method converges superlinearly, more specific, its rate of\n+ * convergence is sqrt(2). Test runs show that for a default absolute\n+ * accuracy of 1E-6, it generally takes less than 5 iterations for close\n+ * initial bracket and 5 to 10 iterations for distant initial bracket\n+ * to converge.\n+ * \n+ * @version $Revision$ $Date$ \n+ */\n+public final class RiddersSolverTest extends TestCase {\n+\n+    /**\n+     * Test the deprecated APIs.\n+     */\n+    @Deprecated\n+    public void testDeprecated() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new RiddersSolver(f);\n+        double min, max, expected, result, tolerance;\n+\n+        min = 3.0; max = 4.0; expected = Math.PI;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1.0; max = 1.5; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the sine function.\n+     */\n+    public void testSinFunction() throws MathException {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new RiddersSolver();\n+        double min, max, expected, result, tolerance;\n+\n+        min = 3.0; max = 4.0; expected = Math.PI;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -1.0; max = 1.5; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the quintic function.\n+     */\n+    public void testQuinticFunction() throws MathException {\n+        UnivariateRealFunction f = new QuinticFunction();\n+        UnivariateRealSolver solver = new RiddersSolver();\n+        double min, max, expected, result, tolerance;\n+\n+        min = -0.4; max = 0.2; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = 0.75; max = 1.5; expected = 1.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -0.9; max = -0.2; expected = -0.5;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of solver for the exponential function.\n+     */\n+    public void testExpm1Function() throws MathException {\n+        UnivariateRealFunction f = new Expm1Function();\n+        UnivariateRealSolver solver = new RiddersSolver();\n+        double min, max, expected, result, tolerance;\n+\n+        min = -1.0; max = 2.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -20.0; max = 10.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+\n+        min = -50.0; max = 100.0; expected = 0.0;\n+        tolerance = Math.max(solver.getAbsoluteAccuracy(),\n+                    Math.abs(expected * solver.getRelativeAccuracy()));\n+        result = solver.solve(f, min, max);\n+        assertEquals(expected, result, tolerance);\n+    }\n+\n+    /**\n+     * Test of parameters for the solver.\n+     */\n+    public void testParameters() throws Exception {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = new RiddersSolver();\n+\n+        try {\n+            // bad interval\n+            solver.solve(f, 1, -1);\n+            fail(\"Expecting IllegalArgumentException - bad interval\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            // no bracketing\n+            solver.solve(f, 2, 3);\n+            fail(\"Expecting IllegalArgumentException - no bracketing\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/solvers/UnivariateRealSolverFactoryImplTest.java\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ *  contributor license agreements.  See the NOTICE file distributed with\n+ *  this work for additional information regarding copyright ownership.\n+ *  The ASF licenses this file to You under the Apache License, Version 2.0\n+ *  (the \"License\"); you may not use this file except in compliance with\n+ *  the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class UnivariateRealSolverFactoryImplTest extends TestCase {\n+    \n+    /** solver factory */\n+    private UnivariateRealSolverFactory factory;\n+    \n+    /**\n+     * @throws java.lang.Exception\n+     * @see junit.framework.TestCase#tearDown()\n+     */\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        factory = new UnivariateRealSolverFactoryImpl();\n+    }\n+    \n+    /**\n+     * @throws java.lang.Exception\n+     * @see junit.framework.TestCase#tearDown()\n+     */\n+    protected void tearDown() throws Exception {\n+        factory = null;\n+        super.tearDown();\n+    }\n+\n+    public void testNewBisectionSolverValid() {\n+        UnivariateRealSolver solver = factory.newBisectionSolver();\n+        assertNotNull(solver);\n+        assertTrue(solver instanceof BisectionSolver);\n+    }\n+\n+    public void testNewNewtonSolverValid() {\n+        UnivariateRealSolver solver = factory.newNewtonSolver();\n+        assertNotNull(solver);\n+        assertTrue(solver instanceof NewtonSolver);\n+    }\n+\n+    public void testNewBrentSolverValid() {\n+        UnivariateRealSolver solver = factory.newBrentSolver();\n+        assertNotNull(solver);\n+        assertTrue(solver instanceof BrentSolver);\n+    }\n+\n+    public void testNewSecantSolverValid() {\n+        UnivariateRealSolver solver = factory.newSecantSolver();\n+        assertNotNull(solver);\n+        assertTrue(solver instanceof SecantSolver);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtilsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+import org.apache.commons.math.ConvergenceException;\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision$ $Date$\n+ */\n+public class UnivariateRealSolverUtilsTest extends TestCase {\n+    \n+    protected UnivariateRealFunction sin = new SinFunction();\n+    \n+    public void testSolveNull() throws MathException {\n+        try {\n+            UnivariateRealSolverUtils.solve(null, 0.0, 4.0);\n+            fail();\n+        } catch(IllegalArgumentException ex){\n+            // success\n+        }\n+    }\n+    \n+    public void testSolveBadParameters() throws MathException {\n+        try { // bad endpoints\n+            UnivariateRealSolverUtils.solve(sin,0.0, 4.0, 4.0); \n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }    \n+        try { // bad accuracy\n+            UnivariateRealSolverUtils.solve(sin, 0.0, 4.0, 0.0); \n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }        \n+    }\n+    \n+    public void testSolveSin() throws MathException {     \n+        double x = UnivariateRealSolverUtils.solve(sin, 1.0, 4.0);\n+        assertEquals(Math.PI, x, 1.0e-4);\n+    }\n+    \n+    public void testSolveAccuracyNull()  throws MathException {\n+        try {\n+            double accuracy = 1.0e-6;\n+            UnivariateRealSolverUtils.solve(null, 0.0, 4.0, accuracy);\n+            fail();\n+        } catch(IllegalArgumentException ex){\n+            // success\n+        }\n+    }\n+    \n+    public void testSolveAccuracySin() throws MathException {\n+        double accuracy = 1.0e-6;\n+        double x = UnivariateRealSolverUtils.solve(sin, 1.0,\n+                4.0, accuracy);\n+        assertEquals(Math.PI, x, accuracy);\n+    }\n+    \n+    public void testSolveNoRoot() throws MathException {\n+        try {\n+            UnivariateRealSolverUtils.solve(sin, 1.0, 1.5);  \n+            fail(\"Expecting IllegalArgumentException \");  \n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testBracketSin() throws MathException {\n+        double[] result = UnivariateRealSolverUtils.bracket(sin, \n+                0.0, -2.0, 2.0);\n+        assertTrue(sin.value(result[0]) < 0);\n+        assertTrue(sin.value(result[1]) > 0);\n+    }\n+    \n+    public void testBracketCornerSolution() throws MathException {\n+        try {\n+            UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0); \n+            fail(\"Expecting ConvergenceException\");\n+        } catch (ConvergenceException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testBadParameters() throws MathException {\n+        try { // null function\n+            UnivariateRealSolverUtils.bracket(null, 1.5, 0, 2.0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try { // initial not between endpoints\n+            UnivariateRealSolverUtils.bracket(sin, 2.5, 0, 2.0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try { // endpoints not valid\n+            UnivariateRealSolverUtils.bracket(sin, 1.5, 2.0, 1.0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try { // bad maximum iterations\n+            UnivariateRealSolverUtils.bracket(sin, 1.5, 0, 2.0, 0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }        \n+    }\n+    \n+}", "timestamp": 1232284678, "metainfo": ""}