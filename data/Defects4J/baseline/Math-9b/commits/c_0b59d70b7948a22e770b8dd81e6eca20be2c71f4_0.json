{"sha": "0b59d70b7948a22e770b8dd81e6eca20be2c71f4", "log": "added new constructors for Fractions JIRA: MATH-181  ", "commit": "\n--- a/src/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/java/org/apache/commons/math/fraction/Fraction.java\n \n     /** A fraction representing \"0 / 1\". */\n     public static final Fraction ZERO = new Fraction(0, 1);\n+\n+    /**\n+     * The maximal number of denominator digits that can be requested for double to fraction\n+     * conversion.\n+     * <p>\n+     * When <code>d</code> digits are requested, an integer threshold is\n+     * initialized with the value 10<sup>d</sup>. Therefore, <code>d</code>\n+     * cannot be larger than this constant. Since the java language uses 32 bits\n+     * signed integers, the value for this constant is 9.\n+     * </p>\n+     * \n+     * @see #Fraction(double,int)\n+     */\n+    public static final int MAX_DENOMINATOR_DIGITS = 9;\n     \n     /** Serializable version identifier */\n-    private static final long serialVersionUID = 6222990762865980424L;\n-\n+    private static final long serialVersionUID = 5463066929751300926L;\n     \n     /** The denominator. */\n     private int denominator;\n     }\n \n     /**\n-     * Create a fraction given the double value.\n+     * Create a fraction given the double value and maximum error allowed.\n      * <p>\n      * References:\n      * <ul>\n     public Fraction(double value, double epsilon, int maxIterations)\n         throws FractionConversionException\n     {\n+        this(value, epsilon, Integer.MAX_VALUE, maxIterations);\n+    }\n+\n+    /**\n+     * Convert a number of denominator digits to a denominator max value.\n+     * @param denominatorDigits The maximum number of denominator digits.\n+     * @return the maximal value for denominator\n+     * @throws IllegalArgumentException if more than {@link #MAX_DENOMINATOR_DIGITS}\n+     *         are requested\n+     */\n+    private static int maxDenominator(int denominatorDigits)\n+        throws IllegalArgumentException\n+    {\n+        if (denominatorDigits > MAX_DENOMINATOR_DIGITS) {\n+            throw new IllegalArgumentException(\"too many digits requested\");\n+        }\n+        return (int)Math.pow(10, denominatorDigits);\n+    }\n+\n+    /**\n+     * Create a fraction given the double value and maximum number of\n+     * denominator digits.\n+     * <p>\n+     * References:\n+     * <ul>\n+     * <li><a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">\n+     * Continued Fraction</a> equations (11) and (22)-(26)</li>\n+     * </ul>\n+     * </p>\n+     * @param value the double value to convert to a fraction.\n+     * @param denominatorDigits The maximum number of denominator digits.\n+     * @throws FractionConversionException if the continued fraction failed to\n+     *         converge\n+     * @throws IllegalArgumentException if more than {@link #MAX_DENOMINATOR_DIGITS}\n+     *         are requested\n+     */\n+    public Fraction(double value, int denominatorDigits)\n+        throws FractionConversionException, IllegalArgumentException\n+    {\n+       this(value, 0, maxDenominator(denominatorDigits), 100);\n+    }\n+\n+    /**\n+     * Create a fraction given the double value and either the maximum error\n+     * allowed or the maximum number of denominator digits.\n+     * <p>\n+     *\n+     * NOTE: This constructor is called with EITHER\n+     *   - a valid epsilon value and the maxDenominator set to Integer.MAX_VALUE\n+     *     (that way the maxDenominator has no effect).\n+     * OR\n+     *   - a valid maxDenominator value and the epsilon value set to zero\n+     *     (that way epsilon only has effect if there is an exact match before\n+     *     the maxDenominator value is reached).\n+     * <p>\n+     *\n+     * It has been done this way so that the same code can be (re)used for both\n+     * scenarios. However this could be confusing to users if it were part of\n+     * the public API and this constructor should therefore remain PRIVATE.\n+     * </p>\n+     *\n+     * See JIRA issue ticket MATH-181 for more details:\n+     *\n+     *     https://issues.apache.org/jira/browse/MATH-181\n+     *\n+     * @param value the double value to convert to a fraction.\n+     * @param epsilon maximum error allowed.  The resulting fraction is within\n+     *        <code>epsilon</code> of <code>value</code>, in absolute terms.\n+     * @param maxDenominator maximum denominator value allowed.\n+     * @param maxIterations maximum number of convergents\n+     * @throws FractionConversionException if the continued fraction failed to\n+     *         converge.\n+     */\n+    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n+        throws FractionConversionException\n+    {\n         double r0 = value;\n         int a0 = (int)Math.floor(r0);\n \n             q2 = (a1 * q1) + q0;\n             \n             double convergent = (double)p2 / (double)q2;\n-            if (n < maxIterations && Math.abs(convergent - value) > epsilon) {\n+            if (n < maxIterations && Math.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                 p0 = p1;\n                 p1 = p2;\n                 q0 = q1;\n             throw new FractionConversionException(value, maxIterations);\n         }\n         \n-        this.numerator = p2;\n-        this.denominator = q2;\n+        if (q2 < maxDenominator) {\n+            this.numerator = p2;\n+            this.denominator = q2;\n+        } else {\n+            this.numerator = p1;\n+            this.denominator = q1;\n+        }\n         reduce();\n     }\n     \n--- a/src/test/org/apache/commons/math/fraction/FractionTest.java\n+++ b/src/test/org/apache/commons/math/fraction/FractionTest.java\n         assertFraction(10, 11, new Fraction((double)10 / (double)11));\n     }\n \n+    // MATH-181\n+    public void testDigitLimitConstructor() throws ConvergenceException  {\n+        assertFraction(2, 5, new Fraction(0.4, 1));\n+        assertFraction(2, 5, new Fraction(0.4, 2));\n+        assertFraction(2, 5, new Fraction(0.4, 3));\n+\n+        assertFraction(3, 5,      new Fraction(0.6152, 1));\n+        assertFraction(8, 13,     new Fraction(0.6152, 2));\n+        assertFraction(510, 829,  new Fraction(0.6152, 3));\n+        assertFraction(769, 1250, new Fraction(0.6152, 4));\n+\n+        try {\n+            new Fraction(0.6152, 15);\n+            fail(\"an exception should have been thrown\");\n+        } catch (IllegalArgumentException iae) {\n+            // expected behavior\n+        } catch (Exception e) {\n+            fail(\"wrong exception caught\");\n+        }\n+    }\n+\n+    public void testEpsilonLimitConstructor() throws ConvergenceException  {\n+        assertFraction(2, 5, new Fraction(0.4, 1.0e-5, 100));\n+\n+        assertFraction(3, 5,      new Fraction(0.6152, 0.02, 100));\n+        assertFraction(8, 13,     new Fraction(0.6152, 1.0e-3, 100));\n+        assertFraction(251, 408,  new Fraction(0.6152, 1.0e-4, 100));\n+        assertFraction(251, 408,  new Fraction(0.6152, 1.0e-5, 100));\n+        assertFraction(510, 829,  new Fraction(0.6152, 1.0e-6, 100));\n+        assertFraction(769, 1250, new Fraction(0.6152, 1.0e-7, 100));\n+    }\n+\n     public void testCompareTo() {\n         Fraction first = new Fraction(1, 2);\n         Fraction second = new Fraction(1, 3);", "timestamp": 1201521475, "metainfo": ""}