{"sha": "48151d54b0def6a00175b41d56ebfc7b449355ea", "log": "MATH-698 Made \"CMAESOptimizer\" a subclass of \"BaseAbstractMultivariateSimpleBoundsOptimizer\". The original code does not support mixing finite and infinite bounds (no constraints) on the variables; a check for this incompatibility is thus performed, throwing a \"MathUnsuppportedException\" if failing.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n \n import org.apache.commons.math3.analysis.MultivariateFunction;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n-import org.apache.commons.math3.exception.NoDataException;\n+import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.exception.TooManyEvaluationsException;\n  */\n \n public class CMAESOptimizer\n-    extends BaseAbstractMultivariateOptimizer<MultivariateFunction>\n+    extends BaseAbstractMultivariateSimpleBoundsOptimizer<MultivariateFunction>\n     implements MultivariateOptimizer {\n     /** Default value for {@link #checkFeasableCount}: {@value}. */\n     public static final int DEFAULT_CHECKFEASABLECOUNT = 0;\n      * @param lambda Population size.\n      */\n     public CMAESOptimizer(int lambda) {\n-        this(lambda, null, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n+        this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n              DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n              DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);\n     }\n     /**\n      * @param lambda Population size.\n      * @param inputSigma Initial search volume; sigma of offspring objective variables.\n-     * @param boundaries Boundaries for objective variables.\n-     */\n-    public CMAESOptimizer(int lambda, double[] inputSigma,\n-                          double[][] boundaries) {\n-        this(lambda, inputSigma, boundaries, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n+     */\n+    public CMAESOptimizer(int lambda, double[] inputSigma) {\n+        this(lambda, inputSigma, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n              DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n              DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);\n     }\n     /**\n      * @param lambda Population size.\n      * @param inputSigma Initial search volume; sigma of offspring objective variables.\n-     * @param boundaries Boundaries for objective variables.\n      * @param maxIterations Maximal number of iterations.\n      * @param stopFitness Whether to stop if objective function value is smaller than\n      * {@code stopFitness}.\n      * @param generateStatistics Whether statistic data is collected.\n      */\n     public CMAESOptimizer(int lambda, double[] inputSigma,\n-                          double[][] boundaries, int maxIterations, double stopFitness,\n+                          int maxIterations, double stopFitness,\n                           boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\n                           RandomGenerator random, boolean generateStatistics) {\n-        this(lambda, inputSigma, boundaries, maxIterations, stopFitness, isActiveCMA,\n+        this(lambda, inputSigma, maxIterations, stopFitness, isActiveCMA,\n              diagonalOnly, checkFeasableCount, random, generateStatistics,\n              new SimpleValueChecker());\n     }\n     /**\n      * @param lambda Population size.\n      * @param inputSigma Initial search volume; sigma of offspring objective variables.\n-     * @param boundaries Boundaries for objective variables.\n      * @param maxIterations Maximal number of iterations.\n      * @param stopFitness Whether to stop if objective function value is smaller than\n      * {@code stopFitness}.\n      * @param checker Convergence checker.\n      */\n     public CMAESOptimizer(int lambda, double[] inputSigma,\n-                          double[][] boundaries, int maxIterations, double stopFitness,\n+                          int maxIterations, double stopFitness,\n                           boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\n                           RandomGenerator random, boolean generateStatistics,\n                           ConvergenceChecker<PointValuePair> checker) {\n         super(checker);\n         this.lambda = lambda;\n         this.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone();\n-        if (boundaries == null) {\n-            this.boundaries = null;\n-        } else {\n-            final int len = boundaries.length;\n-            this.boundaries = new double[len][];\n-            for (int i = 0; i < len; i++) {\n-                this.boundaries[i] =\n-                    boundaries[i] == null ? null : (double[]) boundaries[i].clone();\n-            }\n-        }\n         this.maxIterations = maxIterations;\n         this.stopFitness = stopFitness;\n         this.isActiveCMA = isActiveCMA;\n      * Checks dimensions and values of boundaries and inputSigma if defined.\n      */\n     private void checkParameters() {\n-        double[] init = getStartPoint();\n-        if (boundaries != null) {\n-            if (boundaries.length != 2) {\n-                throw new DimensionMismatchException(boundaries.length, 2);\n-            }\n-            if (boundaries[0] == null || boundaries[1] == null) {\n-                throw new NoDataException();\n-            }\n-            if (boundaries[0].length != init.length) {\n-                throw new DimensionMismatchException(boundaries[0].length, init.length);\n-            }\n-            if (boundaries[1].length != init.length) {\n-                throw new DimensionMismatchException(boundaries[1].length, init.length);\n-            }\n-            for (int i = 0; i < init.length; i++) {\n-                if (boundaries[0][i] > init[i] || boundaries[1][i] < init[i]) {\n-                    throw new OutOfRangeException(init[i], boundaries[0][i],\n-                            boundaries[1][i]);\n-                }\n-            }\n-        }\n+        final double[] init = getStartPoint();\n+        final double[] lB = getLowerBound();\n+        final double[] uB = getUpperBound();\n+\n+        // Checks whether there is at least one finite bound value.\n+        boolean hasFiniteBounds = false;\n+        for (int i = 0; i < lB.length; i++) {\n+            if (!Double.isInfinite(lB[i]) ||\n+                !Double.isInfinite(uB[i])) {\n+                hasFiniteBounds = true;\n+                break;\n+            }\n+        }\n+        // Checks whether there is at least one infinite bound value.\n+        boolean hasInfiniteBounds = false;\n+        if (hasFiniteBounds) {\n+            for (int i = 0; i < lB.length; i++) {\n+                if (Double.isInfinite(lB[i]) ||\n+                    Double.isInfinite(uB[i])) {\n+                    hasInfiniteBounds = true;\n+                    break;\n+                }\n+            }\n+\n+            if (hasInfiniteBounds) {\n+                // If there is at least one finite bound, none can be infinite,\n+                // because mixed cases are not supported by the current code.\n+                throw new MathUnsupportedOperationException();\n+            } else {\n+                // Convert API to internal handling of boundaries.\n+                boundaries = new double[2][];\n+                boundaries[0] = lB;\n+                boundaries[1] = uB;\n+            }\n+        } else {\n+            // Convert API to internal handling of boundaries.\n+            boundaries = null;\n+        }\n+\n         if (inputSigma != null) {\n             if (inputSigma.length != init.length) {\n                 throw new DimensionMismatchException(inputSigma.length, init.length);\n--- a/src/test/java/org/apache/commons/math3/optimization/direct/CMAESOptimizerTest.java\n+++ b/src/test/java/org/apache/commons/math3/optimization/direct/CMAESOptimizerTest.java\n import org.apache.commons.math3.Retry;\n import org.apache.commons.math3.RetryRunner;\n import org.apache.commons.math3.analysis.MultivariateFunction;\n+import org.apache.commons.math3.exception.NumberIsTooLargeException;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n import org.apache.commons.math3.exception.DimensionMismatchException;\n-import org.apache.commons.math3.exception.NoDataException;\n+import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.OutOfRangeException;\n import org.apache.commons.math3.optimization.GoalType;\n     static final int DIM = 13;\n     static final int LAMBDA = 4 + (int)(3.*Math.log(DIM));\n    \n-    @Test(expected = OutOfRangeException.class)\n-    public void testInitOutofbounds() {\n+    @Test(expected = NumberIsTooLargeException.class)\n+    public void testInitOutofbounds1() {\n         double[] startPoint = point(DIM,3);\n+        double[] insigma = null;\n+        double[][] boundaries = boundaries(DIM,-1,2);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,1.0),0.0);\n+        doTest(new Rosen(), startPoint, insigma, boundaries,\n+                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n+                1e-13, 1e-6, 100000, expected);\n+    }\n+    @Test(expected = NumberIsTooSmallException.class)\n+    public void testInitOutofbounds2() {\n+        double[] startPoint = point(DIM, -2);\n         double[] insigma = null;\n         double[][] boundaries = boundaries(DIM,-1,2);\n         PointValuePair expected =\n                 1e-13, 1e-6, 100000, expected);\n     }\n \n-    @Test(expected = NoDataException.class)\n-    public void testBoundariesNoData() {\n+    @Test(expected = MathUnsupportedOperationException.class)\n+    public void testUnsupportedBoundaries1() {\n         double[] startPoint = point(DIM,0.5);\n         double[] insigma = null;\n-        double[][] boundaries = boundaries(DIM,-1,2);\n-        boundaries[1] = null;\n+        double[][] boundaries = boundaries(DIM,-1, Double.POSITIVE_INFINITY);\n+        PointValuePair expected =\n+            new PointValuePair(point(DIM,1.0),0.0);\n+        doTest(new Rosen(), startPoint, insigma, boundaries,\n+                GoalType.MINIMIZE, LAMBDA, true, 0, 1e-13,\n+                1e-13, 1e-6, 100000, expected);\n+    }\n+\n+    @Test(expected = MathUnsupportedOperationException.class)\n+    public void testUnsupportedBoundaries2() {\n+        double[] startPoint = point(DIM, 0.5);\n+        double[] insigma = null;\n+        final double[] lB = new double[] { -1, -1, -1, -1, -1, Double.NEGATIVE_INFINITY, -1, -1, -1, -1, -1, -1, -1 };\n+        final double[] uB = new double[] { 2, 2, 2, Double.POSITIVE_INFINITY, 2, 2, 2, 2, 2, 2, 2, 2, 2 };\n+        double[][] boundaries = new double[2][];\n+        boundaries[0] = lB;\n+        boundaries[1] = uB;\n         PointValuePair expected =\n             new PointValuePair(point(DIM,1.0),0.0);\n         doTest(new Rosen(), startPoint, insigma, boundaries,\n             PointValuePair expected) {\n         int dim = startPoint.length;\n         // test diagonalOnly = 0 - slow but normally fewer feval#\n-        MultivariateOptimizer optim =\n-            new CMAESOptimizer(\n-                    lambda, inSigma, boundaries, 30000,\n-                    stopValue, isActive, diagonalOnly, 0, new MersenneTwister(),false);\n-        PointValuePair result = optim.optimize(maxEvaluations, func, goal, startPoint);\n+        CMAESOptimizer optim = new CMAESOptimizer( lambda, inSigma, 30000,\n+                                                   stopValue, isActive, diagonalOnly,\n+                                                   0, new MersenneTwister(), false);\n+        final double[] lB = boundaries == null ? null : boundaries[0];\n+        final double[] uB = boundaries == null ? null : boundaries[1];\n+        PointValuePair result = optim.optimize(maxEvaluations, func, goal, startPoint, lB, uB);\n         Assert.assertEquals(expected.getValue(),\n                 result.getValue(), fTol);\n         for (int i = 0; i < dim; i++) {", "timestamp": 1329609682, "metainfo": ""}