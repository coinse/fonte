{"sha": "e434abd116ba6e0dfc54dc70ca956626b8fd07a3", "log": "MATH-762 Created an inner class to collect statements that were duplicated.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math3/util/FastMath.java\n     }\n \n     /**\n-     *  Sine function.\n-     *  @param x a number\n-     *  @return sin(x)\n+     * Sine function.\n+     *\n+     * @param x Argument.\n+     * @return sin(x)\n      */\n     public static double sin(double x) {\n         boolean negative = false;\n             xa = reduceResults[1];\n             xb = reduceResults[2];\n         } else if (xa > 1.5707963267948966) {\n-            /* Inline the Cody/Waite reduction for performance */\n-\n-            // Estimate k\n-            //k = (int)(xa / 1.5707963267948966);\n-            int k = (int)(xa * 0.6366197723675814);\n-\n-            // Compute remainder\n-            double remA;\n-            double remB;\n-            while (true) {\n-                double a = -k * 1.570796251296997;\n-                remA = xa + a;\n-                remB = -(remA - xa - a);\n-\n-                a = -k * 7.549789948768648E-8;\n-                double b = remA;\n-                remA = a + b;\n-                remB += -(remA - b - a);\n-\n-                a = -k * 6.123233995736766E-17;\n-                b = remA;\n-                remA = a + b;\n-                remB += -(remA - b - a);\n-\n-                if (remA > 0.0) {\n-                    break;\n-                }\n-\n-                // Remainder is negative, so decrement k and try again.\n-                // This should only happen if the input is very close\n-                // to an even multiple of pi/2\n-                k--;\n-            }\n-            quadrant = k & 3;\n-            xa = remA;\n-            xb = remB;\n+            final CodyWaite cw = new CodyWaite(xa, xb);\n+            quadrant = cw.getK() & 3;\n+            xa = cw.getRemA();\n+            xb = cw.getRemB();\n         }\n \n         if (negative) {\n     }\n \n     /**\n-     *  Cosine function\n-     *  @param x a number\n-     *  @return cos(x)\n+     * Cosine function.\n+     *\n+     * @param x Argument.\n+     * @return cos(x)\n      */\n     public static double cos(double x) {\n         int quadrant = 0;\n             xa = reduceResults[1];\n             xb = reduceResults[2];\n         } else if (xa > 1.5707963267948966) {\n-            /* Inline the Cody/Waite reduction for performance */\n-\n-            // Estimate k\n-            //k = (int)(xa / 1.5707963267948966);\n-            int k = (int)(xa * 0.6366197723675814);\n-\n-            // Compute remainder\n-            double remA;\n-            double remB;\n-            while (true) {\n-                double a = -k * 1.570796251296997;\n-                remA = xa + a;\n-                remB = -(remA - xa - a);\n-\n-                a = -k * 7.549789948768648E-8;\n-                double b = remA;\n-                remA = a + b;\n-                remB += -(remA - b - a);\n-\n-                a = -k * 6.123233995736766E-17;\n-                b = remA;\n-                remA = a + b;\n-                remB += -(remA - b - a);\n-\n-                if (remA > 0.0) {\n-                    break;\n-                }\n-\n-                // Remainder is negative, so decrement k and try again.\n-                // This should only happen if the input is very close\n-                // to an even multiple of pi/2\n-                k--;\n-            }\n-            quadrant = k & 3;\n-            xa = remA;\n-            xb = remB;\n+            final CodyWaite cw = new CodyWaite(xa, xb);\n+            quadrant = cw.getK() & 3;\n+            xa = cw.getRemA();\n+            xb = cw.getRemB();\n         }\n \n         //if (negative)\n     }\n \n     /**\n-     *   Tangent function\n-     *  @param x a number\n-     *  @return tan(x)\n+     * Tangent function.\n+     *\n+     * @param x Argument.\n+     * @return tan(x)\n      */\n     public static double tan(double x) {\n         boolean negative = false;\n             xa = reduceResults[1];\n             xb = reduceResults[2];\n         } else if (xa > 1.5707963267948966) {\n-            /* Inline the Cody/Waite reduction for performance */\n-\n-            // Estimate k\n-            //k = (int)(xa / 1.5707963267948966);\n-            int k = (int)(xa * 0.6366197723675814);\n-\n-            // Compute remainder\n-            double remA;\n-            double remB;\n-            while (true) {\n-                double a = -k * 1.570796251296997;\n-                remA = xa + a;\n-                remB = -(remA - xa - a);\n-\n-                a = -k * 7.549789948768648E-8;\n-                double b = remA;\n-                remA = a + b;\n-                remB += -(remA - b - a);\n-\n-                a = -k * 6.123233995736766E-17;\n-                b = remA;\n-                remA = a + b;\n-                remB += -(remA - b - a);\n-\n-                if (remA > 0.0) {\n-                    break;\n-                }\n-\n-                // Remainder is negative, so decrement k and try again.\n-                // This should only happen if the input is very close\n-                // to an even multiple of pi/2\n-                k--;\n-            }\n-            quadrant = k & 3;\n-            xa = remA;\n-            xb = remB;\n+            final CodyWaite cw = new CodyWaite(xa, xb);\n+            quadrant = cw.getK() & 3;\n+            xa = cw.getRemA();\n+            xb = cw.getRemB();\n         }\n \n         if (xa > 1.5) {\n-            // Accurracy suffers between 1.5 and PI/2\n+            // Accuracy suffers between 1.5 and PI/2\n             final double pi2a = 1.5707963267948966;\n             final double pi2b = 6.123233995736766E-17;\n \n             }\n         }\n     }\n+\n+    /** Enclose the Cody/Waite reduction (used in \"sin\", \"cos\" and \"tan\"). */\n+    private static class CodyWaite {\n+        /** k */\n+        private final int finalK;\n+        /** remA */\n+        private final double finalRemA;\n+        /** remB */\n+        private final double finalRemB;\n+\n+        /**\n+         * @param xa Argument.\n+         * @param xb Argument.\n+         */\n+        CodyWaite(double xa,\n+                  double xb) {\n+            // Estimate k.\n+            //k = (int)(xa / 1.5707963267948966);\n+            int k = (int)(xa * 0.6366197723675814);\n+\n+            // Compute remainder.\n+            double remA;\n+            double remB;\n+            while (true) {\n+                double a = -k * 1.570796251296997;\n+                remA = xa + a;\n+                remB = -(remA - xa - a);\n+\n+                a = -k * 7.549789948768648E-8;\n+                double b = remA;\n+                remA = a + b;\n+                remB += -(remA - b - a);\n+\n+                a = -k * 6.123233995736766E-17;\n+                b = remA;\n+                remA = a + b;\n+                remB += -(remA - b - a);\n+\n+                if (remA > 0) {\n+                    break;\n+                }\n+\n+                // Remainder is negative, so decrement k and try again.\n+                // This should only happen if the input is very close\n+                // to an even multiple of pi/2.\n+                --k;\n+            }\n+\n+            this.finalK = k;\n+            this.finalRemA = remA;\n+            this.finalRemB = remB;\n+        }\n+\n+        /**\n+         * @return k\n+         */\n+        int getK() {\n+            return finalK;\n+        }\n+        /**\n+         * @return remA\n+         */\n+        double getRemA() {\n+            return finalRemA;\n+        }\n+        /**\n+         * @return remB\n+         */\n+        double getRemB() {\n+            return finalRemB;\n+        }\n+    }\n }", "timestamp": 1343400970, "metainfo": ""}