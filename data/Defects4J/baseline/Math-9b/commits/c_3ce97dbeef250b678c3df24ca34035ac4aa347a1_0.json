{"sha": "3ce97dbeef250b678c3df24ca34035ac4aa347a1", "log": "Read bound values from base class instead of duplicating the data.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n      */\n     private int checkFeasableCount;\n     /**\n-     * Lower and upper boundaries of the objective variables.\n-     */\n-    private double[][] boundaries;\n-    /**\n      * Values in \"inputSigma\" define the initial coordinate-wise\n      * standard deviations for sampling new search points around the\n      * initial guess.\n         final double[] lB = getLowerBound();\n         final double[] uB = getUpperBound();\n \n-        // Convert API to internal handling of boundaries.\n-        boundaries = new double[2][];\n-        boundaries[0] = lB;\n-        boundaries[1] = uB;\n-\n         if (inputSigma != null) {\n             if (inputSigma.length != init.length) {\n                 throw new DimensionMismatchException(inputSigma.length, init.length);\n                 if (inputSigma[i] < 0) {\n                     throw new NotPositiveException(inputSigma[i]);\n                 }\n-                if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n-                    throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n+                if (inputSigma[i] > uB[i] - lB[i]) {\n+                    throw new OutOfRangeException(inputSigma[i], 0, uB[i] - lB[i]);\n                 }\n             }\n         }\n          * @return {@code true} if in bounds.\n          */\n         public boolean isFeasible(final double[] x) {\n+            final double[] lB = CMAESOptimizer.this.getLowerBound();\n+            final double[] uB = CMAESOptimizer.this.getUpperBound();\n+\n             for (int i = 0; i < x.length; i++) {\n-                if (x[i] < boundaries[0][i]) {\n+                if (x[i] < lB[i]) {\n                     return false;\n                 }\n-                if (x[i] > boundaries[1][i]) {\n+                if (x[i] > uB[i]) {\n                     return false;\n                 }\n             }\n          * @return the repaired objective variables - all in bounds.\n          */\n         private double[] repair(final double[] x) {\n+            final double[] lB = CMAESOptimizer.this.getLowerBound();\n+            final double[] uB = CMAESOptimizer.this.getUpperBound();\n+\n             final double[] repaired = new double[x.length];\n             for (int i = 0; i < x.length; i++) {\n-                if (x[i] < boundaries[0][i]) {\n-                    repaired[i] = boundaries[0][i];\n-                } else if (x[i] > boundaries[1][i]) {\n-                    repaired[i] = boundaries[1][i];\n+                if (x[i] < lB[i]) {\n+                    repaired[i] = lB[i];\n+                } else if (x[i] > uB[i]) {\n+                    repaired[i] = uB[i];\n                 } else {\n                     repaired[i] = x[i];\n                 }", "timestamp": 1349346342, "metainfo": ""}