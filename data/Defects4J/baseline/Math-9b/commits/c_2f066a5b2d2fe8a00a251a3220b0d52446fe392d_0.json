{"sha": "2f066a5b2d2fe8a00a251a3220b0d52446fe392d", "log": "MATH-631 Work around infinite loop.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n \n             // Update the bounds with the new approximation.\n             if (f1 * fx < 0) {\n-                // We had [x0..x1]. We update it to [x1, x]. Note that the\n-                // value of x1 has switched to the other bound, thus inverting\n+                // The value of x1 has switched to the other bound, thus inverting\n                 // the interval.\n                 x0 = x1;\n                 f0 = f1;\n-                x1 = x;\n-                f1 = fx;\n                 inverted = !inverted;\n             } else {\n-                // We had [x0..x1]. We update it to [x0, x].\n-                if (method == Method.ILLINOIS) {\n+                switch (method) {\n+                case ILLINOIS:\n                     f0 *= 0.5;\n+                    break;\n+                case PEGASUS:\n+                    f0 *= f1 / (f1 + fx);\n+                    break;\n+                case REGULA_FALSI:\n+                    if (x == x1) {\n+                        final double delta = FastMath.max(rtol * FastMath.abs(x1),\n+                                                          atol);\n+                        // Update formula cannot make any progress: Update the\n+                        // search interval.\n+                        x0 = 0.5 * (x0 + x1 - delta);\n+                        f0 = computeObjectiveValue(x0);\n+                    }\n+                    break;\n+                default:\n+                    // Should never happen.\n+                    throw new MathInternalError();\n                 }\n-                if (method == Method.PEGASUS) {\n-                    f0 *= f1 / (f1 + fx);\n-                }\n-                x1 = x;\n-                f1 = fx;\n-            }\n+            }\n+            // Update from [x0, x1] to [x0, x].\n+            x1 = x;\n+            f1 = fx;\n \n             // If the function value of the last approximation is too small,\n             // given the function value accuracy, then we can't get closer to\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/RegulaFalsiSolverTest.java\n \n package org.apache.commons.math.analysis.solvers;\n \n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.junit.Test;\n+import org.junit.Assert;\n+\n /**\n  * Test case for {@link RegulaFalsiSolver Regula Falsi} solver.\n  *\n         // even a million iterations. As such, it was disabled.\n         return new int[] {3, 7, 8, 19, 18, 11, 67, 55, 288, 151, -1};\n     }\n+\n+    @Test\n+    public void testIssue631() {\n+        final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                @Override\n+                public double value(double x) {\n+                    return Math.exp(x) - Math.pow(Math.PI, 3.0);\n+                }\n+            };\n+\n+        final UnivariateRealSolver solver = new RegulaFalsiSolver();\n+        final double root = solver.solve(3624, f, 1, 10);\n+        Assert.assertEquals(3.4341896575482003, root, 1e-15);\n+\t}\n }", "timestamp": 1312669615, "metainfo": ""}