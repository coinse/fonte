{"sha": "f6effc01997ee890a3e61d2dfd648d7364eb1945", "log": "Improved errors messages consistency and added tests for translations.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math3/exception/util/LocalizedFormats.java\n     NOT_MULTIPLICATION_COMPATIBLE_MATRICES(\"{0}x{1} and {2}x{3} matrices are not multiplication compatible\"),\n     ALPHA(\"alpha\"), /* keep */\n     BETA(\"beta\"), /* keep */\n-    NOT_POSITIVE_COLUMNDIMENSION(\"invalid column dimension: {0} (must be positive)\"),\n     NOT_POSITIVE_DEFINITE_MATRIX(\"not positive definite matrix\"), /* keep */\n     NON_POSITIVE_DEFINITE_MATRIX(\"not positive definite matrix: diagonal element at ({1},{1}) is smaller than {2} ({0})\"),\n     NON_POSITIVE_DEFINITE_OPERATOR(\"non positive definite linear operator\"), /* keep */\n     NO_SUCH_MATRIX_ENTRY(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\"),\n     NAN_NOT_ALLOWED(\"NaN is not allowed\"),\n     NULL_NOT_ALLOWED(\"null is not allowed\"), /* keep */\n-    ARRAY_ZERO_LENGTH_OR_NULL_NOTALLOWED(\"A null or zero length array not allowed\"),\n+    ARRAY_ZERO_LENGTH_OR_NULL_NOT_ALLOWED(\"a null or zero length array not allowed\"),\n     COVARIANCE_MATRIX(\"covariance matrix\"), /* keep */\n     DENOMINATOR(\"denominator\"), /* keep */\n     DENOMINATOR_FORMAT(\"denominator format\"), /* keep */\n     POLYNOMIAL(\"polynomial\"), /* keep */\n     POLYNOMIAL_INTERPOLANTS_MISMATCH_SEGMENTS(\"number of polynomial interpolants must match the number of segments ({0} != {1} - 1)\"),\n     POPULATION_LIMIT_NOT_POSITIVE(\"population limit has to be positive\"),\n-    POSITION_SIZE_MISMATCH_INPUT_ARRAY(\"position {0} and size {1} don't fit to the size of the input array {2}\"),\n     POWER_NEGATIVE_PARAMETERS(\"cannot raise an integral value to a negative power ({0}^{1})\"),\n     PROPAGATION_DIRECTION_MISMATCH(\"propagation direction mismatch\"),\n     RANDOMKEY_MUTATION_WRONG_CLASS(\"RandomKeyMutation works only with RandomKeys, not {0}\"),\n     TOO_LARGE_CUTOFF_SINGULAR_VALUE(\"cutoff singular value is {0}, should be at most {1}\"),\n     TOO_LARGE_TOURNAMENT_ARITY(\"tournament arity ({0}) cannot be bigger than population size ({1})\"),\n     TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY(\"cannot discard {0} elements from a {1} elements array\"),\n-    TOO_MUCH_CANCELLATION(\"too much cancellation in a denominator\"),\n     TOO_MANY_REGRESSORS(\"too many regressors ({0}) specified, only {1} in the model\"),\n     TOO_SMALL_COST_RELATIVE_TOLERANCE(\"cost relative tolerance is too small ({0}), no further reduction in the sum of squares is possible\"),\n     TOO_SMALL_INTEGRATION_INTERVAL(\"too small integration interval: length = {0}\"),\n--- a/src/main/java/org/apache/commons/math3/stat/regression/SimpleRegression.java\n+++ b/src/main/java/org/apache/commons/math3/stat/regression/SimpleRegression.java\n      */\n     public RegressionResults regress(int[] variablesToInclude) throws ModelSpecificationException{\n         if( variablesToInclude == null || variablesToInclude.length == 0){\n-          throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_ZERO_LENGTH_OR_NULL_NOTALLOWED);\n+          throw new MathIllegalArgumentException(LocalizedFormats.ARRAY_ZERO_LENGTH_OR_NULL_NOT_ALLOWED);\n         }\n         if( variablesToInclude.length > 2 || (variablesToInclude.length > 1 && !hasIntercept) ){\n             throw new ModelSpecificationException(\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math3/exception/util/LocalizedFormatsTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+/**\n+ * This file is an adapted version of OrekitMessagesTest test class\n+ * for the <a href=\"https://www.orekit.org/forge/projects/orekit\">orekit</a> library.\n+ * The original file is distributed under the terms of the Apache 2 license and is:\n+ * Copyright 2010 CS Communication & Syst\u00e8mes\n+ */\n+package org.apache.commons.math3.exception.util;\n+\n+\n+import java.text.MessageFormat;\n+import java.util.Enumeration;\n+import java.util.Locale;\n+import java.util.ResourceBundle;\n+\n+import junit.framework.Assert;\n+\n+import org.junit.Test;\n+\n+public class LocalizedFormatsTest {\n+\n+    @Test\n+    public void testMessageNumber() {\n+        Assert.assertEquals(311, LocalizedFormats.values().length);\n+    }\n+\n+    @Test\n+    public void testAllKeysPresentInPropertiesFiles() {\n+        for (final String language : new String[] { \"fr\" } ) {\n+            ResourceBundle bundle =\n+                ResourceBundle.getBundle(\"META-INF/localization/LocalizedFormats\", new Locale(language));\n+            for (LocalizedFormats message : LocalizedFormats.values()) {\n+                final String messageKey = message.toString();\n+                boolean keyPresent = false;\n+                for (final Enumeration<String> keys = bundle.getKeys(); keys.hasMoreElements();) {\n+                    keyPresent |= messageKey.equals(keys.nextElement());\n+                }\n+                Assert.assertTrue(\"missing key \\\"\" + message.name() + \"\\\" for language \" + language,\n+                                  keyPresent);\n+            }\n+            Assert.assertEquals(language, bundle.getLocale().getLanguage());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testAllPropertiesCorrespondToKeys() {\n+        for (final String language : new String[] { \"fr\" } ) {\n+            ResourceBundle bundle =\n+                ResourceBundle.getBundle(\"META-INF/localization/LocalizedFormats\", new Locale(language));\n+            for (final Enumeration<String> keys = bundle.getKeys(); keys.hasMoreElements();) {\n+                final String propertyKey = keys.nextElement();\n+                try {\n+                    Assert.assertNotNull(LocalizedFormats.valueOf(propertyKey));\n+                } catch (IllegalArgumentException iae) {\n+                    Assert.fail(\"unknown key \\\"\" + propertyKey + \"\\\" in language \" + language);\n+                }\n+            }\n+            Assert.assertEquals(language, bundle.getLocale().getLanguage());\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testNoMissingFrenchTranslation() {\n+        for (LocalizedFormats message : LocalizedFormats.values()) {\n+            String translated = message.getLocalizedString(Locale.FRENCH);\n+            Assert.assertFalse(message.name(), translated.toLowerCase().contains(\"missing translation\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testNoOpEnglishTranslation() {\n+        for (LocalizedFormats message : LocalizedFormats.values()) {\n+            String translated = message.getLocalizedString(Locale.ENGLISH);\n+            Assert.assertEquals(message.getSourceString(), translated);\n+        }\n+    }\n+\n+    @Test\n+    public void testVariablePartsConsistency() {\n+        for (final String language : new String[] { \"fr\" } ) {\n+            Locale locale = new Locale(language);\n+            for (LocalizedFormats message : LocalizedFormats.values()) {\n+                MessageFormat source     = new MessageFormat(message.getSourceString());\n+                MessageFormat translated = new MessageFormat(message.getLocalizedString(locale));\n+                Assert.assertEquals(message.name() + \" (\" + language + \")\",\n+                                    source.getFormatsByArgumentIndex().length,\n+                                    translated.getFormatsByArgumentIndex().length);\n+            }\n+        }\n+    }\n+\n+}", "timestamp": 1329338790, "metainfo": ""}