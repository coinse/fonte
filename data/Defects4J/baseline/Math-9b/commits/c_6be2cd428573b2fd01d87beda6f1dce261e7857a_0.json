{"sha": "6be2cd428573b2fd01d87beda6f1dce261e7857a", "log": "Replaced temporary matrices / entry mutators with double[][] arrays to speed computation in loops.  JIRA: MATH-612.  Reported and patched by Christopher Nix.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/QRDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/QRDecomposition.java\n             // R is supposed to be m x n\n             final int n = qrt.length;\n             final int m = qrt[0].length;\n-            cachedR = MatrixUtils.createRealMatrix(m, n);\n-\n+            double[][] ra = new double[m][n];         \n             // copy the diagonal from rDiag and the upper triangle of qr\n             for (int row = FastMath.min(m, n) - 1; row >= 0; row--) {\n-                cachedR.setEntry(row, row, rDiag[row]);\n+                ra[row][row] = rDiag[row];\n                 for (int col = row + 1; col < n; col++) {\n-                    cachedR.setEntry(row, col, qrt[col][row]);\n-                }\n-            }\n+                    ra[row][col] = qrt[col][row];\n+                }\n+            }\n+            cachedR = MatrixUtils.createRealMatrix(ra);\n         }\n \n         // return the cached matrix\n             // QT is supposed to be m x m\n             final int n = qrt.length;\n             final int m = qrt[0].length;\n-            cachedQT = MatrixUtils.createRealMatrix(m, m);\n+            double[][] qta = new double[m][m];\n \n             /*\n              * Q = Q1 Q2 ... Q_m, so Q is formed by first constructing Q_m and then\n              * succession to the result\n              */\n             for (int minor = m - 1; minor >= FastMath.min(m, n); minor--) {\n-                cachedQT.setEntry(minor, minor, 1.0);\n+                qta[minor][minor] = 1.0d;\n             }\n \n             for (int minor = FastMath.min(m, n)-1; minor >= 0; minor--){\n                 final double[] qrtMinor = qrt[minor];\n-                cachedQT.setEntry(minor, minor, 1.0);\n+                qta[minor][minor] = 1.0d;\n                 if (qrtMinor[minor] != 0.0) {\n                     for (int col = minor; col < m; col++) {\n                         double alpha = 0;\n                         for (int row = minor; row < m; row++) {\n-                            alpha -= cachedQT.getEntry(col, row) * qrtMinor[row];\n+                            alpha -= qta[col][row] * qrtMinor[row];\n                         }\n                         alpha /= rDiag[minor] * qrtMinor[minor];\n \n                         for (int row = minor; row < m; row++) {\n-                            cachedQT.addToEntry(col, row, -alpha * qrtMinor[row]);\n+                            qta[col][row] += -alpha * qrtMinor[row];\n                         }\n                     }\n                 }\n             }\n+            cachedQT = MatrixUtils.createRealMatrix(qta);\n         }\n \n         // return the cached matrix\n \n             final int n = qrt.length;\n             final int m = qrt[0].length;\n-            cachedH = MatrixUtils.createRealMatrix(m, n);\n+            double[][] ha = new double[m][n];\n             for (int i = 0; i < m; ++i) {\n                 for (int j = 0; j < FastMath.min(i + 1, n); ++j) {\n-                    cachedH.setEntry(i, j, qrt[j][i] / -rDiag[j]);\n-                }\n-            }\n+                    ha[i][j] = qrt[j][i] / -rDiag[j];\n+                }\n+            }\n+            cachedH = MatrixUtils.createRealMatrix(ha);\n         }\n \n         // return the cached matrix", "timestamp": 1318627113, "metainfo": ""}