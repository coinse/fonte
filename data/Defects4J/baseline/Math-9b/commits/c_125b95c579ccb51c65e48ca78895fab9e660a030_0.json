{"sha": "125b95c579ccb51c65e48ca78895fab9e660a030", "log": "In o.a.c.m3.distribution.GammaDistribution,   - renamed class variable alpha to shape,   - renamed class variable beta to scale. Updated javadoc accordingly. See MATH-791.     ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/distribution/GammaDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/GammaDistribution.java\n     public static final double DEFAULT_INVERSE_ABSOLUTE_ACCURACY = 1e-9;\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -3239549463135430361L;\n+    private static final long serialVersionUID = 20120522L;\n \n     /** The shape parameter. */\n-    private final double alpha;\n+    private final double shape;\n \n     /** The scale parameter. */\n-    private final double beta;\n-\n-    /**\n-     * The constant value of {@code alpha + g + 0.5}, where {@code alpha} is\n-     * the shape parameter, and {@code g} is the Lanczos constant\n-     * {@link Gamma#LANCZOS_G}.\n+    private final double scale;\n+\n+    /**\n+     * The constant value of {@code shape + g + 0.5}, where {@code g} is the\n+     * Lanczos constant {@link Gamma#LANCZOS_G}.\n      */\n     private final double shiftedShape;\n \n     /**\n      * The constant value of\n-     * {@code alpha / beta * sqrt(e / (2 * pi * (alpha + g + 0.5))) / L(alpha)},\n-     * where {@code alpha} is the shape parameter, {@code beta} is the scale\n-     * parameter, and {@code L(alpha)} is the Lanczos approximation returned by\n+     * {@code shape / scale * sqrt(e / (2 * pi * (shape + g + 0.5))) / L(shape)},\n+     * where {@code L(shape)} is the Lanczos approximation returned by\n      * {@link Gamma#lanczos(double)}. This prefactor is used in\n      * {@link #density(double)}, when no overflow occurs with the natural\n      * calculation.\n \n     /**\n      * The constant value of\n-     * {@code alpha * sqrt(e / (2 * pi * (alpha + g + 0.5))) / L(alpha)},\n-     * where {@code alpha} is the shape parameter, and {@code L(alpha)} is the\n-     * Lanczos approximation returned by {@link Gamma#lanczos(double)}. This\n-     * prefactor is used in {@link #density(double)}, when overflow occurs with\n-     * the natural calculation.\n+     * {@code shape * sqrt(e / (2 * pi * (shape + g + 0.5))) / L(shape)},\n+     * where {@code L(shape)} is the Lanczos approximation returned by\n+     * {@link Gamma#lanczos(double)}. This prefactor is used in\n+     * {@link #density(double)}, when overflow occurs with the natural\n+     * calculation.\n      */\n     private final double densityPrefactor2;\n \n     /**\n-     * Lower bound on {@code y = x / beta} for the selection of the computation\n+     * Lower bound on {@code y = x / scale} for the selection of the computation\n      * method in {@link #density(double)}. For {@code y <= minY}, the natural\n-     * calculation overflows. {@code beta} is the shape parameter.\n+     * calculation overflows.\n      */\n     private final double minY;\n \n     /**\n-     * Upper bound on {@code log(y)} ({@code y = x / beta}) for the selection of\n-     * the computation method in {@link #density(double)}. For\n+     * Upper bound on {@code log(y)} ({@code y = x / scale}) for the selection\n+     * of the computation method in {@link #density(double)}. For\n      * {@code log(y) >= maxLogY}, the natural calculation overflows.\n-     * {@code beta} is the shape parameter.\n      */\n     private final double maxLogY;\n \n     private final double solverAbsoluteAccuracy;\n \n     /**\n-     * Create a new gamma distribution with the given {@code alpha} and\n-     * {@code beta} values.\n-     * @param alpha the shape parameter.\n-     * @param beta the scale parameter.\n-     */\n-    public GammaDistribution(double alpha, double beta) {\n-        this(alpha, beta, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n-    }\n-\n-    /**\n-     * Create a new gamma distribution with the given {@code alpha} and\n-     * {@code beta} values.\n-     *\n-     * @param alpha Shape parameter.\n-     * @param beta Scale parameter.\n-     * @param inverseCumAccuracy Maximum absolute error in inverse\n+     * Creates a new gamma distribution with specified values of the shape and\n+     * scale parameters.\n+     *\n+     * @param shape the shape parameter\n+     * @param scale the scale parameter\n+     */\n+    public GammaDistribution(double shape, double scale) {\n+        this(shape, scale, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n+    }\n+\n+    /**\n+     * Creates a new gamma distribution with specified values of the shape and\n+     * scale parameters.\n+     *\n+     * @param shape the shape parameter\n+     * @param scale the scale parameter\n+     * @param inverseCumAccuracy the aximum absolute error in inverse\n      * cumulative probability estimates (defaults to\n      * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n-     * @throws NotStrictlyPositiveException if {@code alpha <= 0} or\n-     * {@code beta <= 0}.\n+     * @throws NotStrictlyPositiveException if {@code shape <= 0} or\n+     * {@code scale <= 0}.\n      * @since 2.1\n      */\n-    public GammaDistribution(double alpha, double beta, double inverseCumAccuracy)\n+    public GammaDistribution(double shape, double scale, double inverseCumAccuracy)\n         throws NotStrictlyPositiveException {\n-        if (alpha <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.ALPHA, alpha);\n-        }\n-        if (beta <= 0) {\n-            throw new NotStrictlyPositiveException(LocalizedFormats.BETA, beta);\n-        }\n-\n-        this.alpha = alpha;\n-        this.beta = beta;\n+        if (shape <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.ALPHA, shape);\n+        }\n+        if (scale <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.BETA, scale);\n+        }\n+\n+        this.shape = shape;\n+        this.scale = scale;\n         this.solverAbsoluteAccuracy = inverseCumAccuracy;\n-        this.shiftedShape = alpha + Gamma.LANCZOS_G + 0.5;\n+        this.shiftedShape = shape + Gamma.LANCZOS_G + 0.5;\n         final double aux = FastMath.E / (2.0 * FastMath.PI * shiftedShape);\n-        this.densityPrefactor2 = alpha * FastMath.sqrt(aux) / Gamma.lanczos(alpha);\n-        this.densityPrefactor1 = this.densityPrefactor2 / beta *\n-                FastMath.pow(shiftedShape, -alpha) *\n-                FastMath.exp(alpha + Gamma.LANCZOS_G);\n-        this.minY = alpha + Gamma.LANCZOS_G - FastMath.log(Double.MAX_VALUE);\n-        this.maxLogY = FastMath.log(Double.MAX_VALUE) / (alpha - 1.0);\n-    }\n-\n-    /**\n-     * Access the {@code alpha} shape parameter.\n-     *\n-     * @return {@code alpha}.\n+        this.densityPrefactor2 = shape * FastMath.sqrt(aux) / Gamma.lanczos(shape);\n+        this.densityPrefactor1 = this.densityPrefactor2 / scale *\n+                FastMath.pow(shiftedShape, -shape) *\n+                FastMath.exp(shape + Gamma.LANCZOS_G);\n+        this.minY = shape + Gamma.LANCZOS_G - FastMath.log(Double.MAX_VALUE);\n+        this.maxLogY = FastMath.log(Double.MAX_VALUE) / (shape - 1.0);\n+    }\n+\n+    /**\n+     * Returns the shape parameter of {@code this} distribution.\n+     *\n+     * @return the shape parameter\n      */\n     public double getAlpha() {\n-        return alpha;\n-    }\n-\n-    /**\n-     * Access the {@code beta} scale parameter.\n-     *\n-     * @return {@code beta}.\n+        return shape;\n+    }\n+\n+    /**\n+     * Returns the scale parameter of {@code this} distribution.\n+     *\n+     * @return the scale parameter\n      */\n     public double getBeta() {\n-        return beta;\n+        return scale;\n     }\n \n     /**\n         if (x < 0) {\n             return 0;\n         }\n-        final double y = x / beta;\n+        final double y = x / scale;\n         if ((y <= minY) || (FastMath.log(y) >= maxLogY)) {\n             /*\n              * Overflow.\n              */\n             final double aux1 = (y - shiftedShape) / shiftedShape;\n-            final double aux2 = alpha * (FastMath.log1p(aux1) - aux1);\n+            final double aux2 = shape * (FastMath.log1p(aux1) - aux1);\n             final double aux3 = -y * (Gamma.LANCZOS_G + 0.5) / shiftedShape +\n                     Gamma.LANCZOS_G + aux2;\n             return densityPrefactor2 / x * FastMath.exp(aux3);\n          * Natural calculation.\n          */\n         return densityPrefactor1  * FastMath.exp(-y) *\n-                FastMath.pow(y, alpha - 1);\n+                FastMath.pow(y, shape - 1);\n     }\n \n     /**\n         if (x <= 0) {\n             ret = 0;\n         } else {\n-            ret = Gamma.regularizedGammaP(alpha, x / beta);\n+            ret = Gamma.regularizedGammaP(shape, x / scale);\n         }\n \n         return ret;", "timestamp": 1337668477, "metainfo": ""}