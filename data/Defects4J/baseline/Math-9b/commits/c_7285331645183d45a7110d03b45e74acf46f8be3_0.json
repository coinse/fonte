{"sha": "7285331645183d45a7110d03b45e74acf46f8be3", "log": "MATH-441 Removed occurences of \"FunctionEvaluationException\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateRealOptimizer.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n \n /**\n      * @param startPoint Start point for optimization.\n      * @return the point/value pair giving the optimal value for objective\n      * function.\n-     * @throws org.apache.commons.math.exception.FunctionEvaluationException if the\n-     * objective function throws one during the search.\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if the start point dimension is wrong.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * @throws org.apache.commons.math.exception.NullArgumentException if\n      * any argument is {@code null}.\n      */\n-    RealPointValuePair optimize(FUNC f, GoalType goalType, double[] startPoint)\n-        throws FunctionEvaluationException;\n+    RealPointValuePair optimize(FUNC f, GoalType goalType, double[] startPoint);\n }\n--- a/src/main/java/org/apache/commons/math/optimization/BaseMultivariateVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/BaseMultivariateVectorialOptimizer.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n \n /**\n      * @param startPoint Start point for optimization.\n      * @return the point/value pair giving the optimal value for objective\n      * function.\n-     * @throws FunctionEvaluationException if the objective function throws one\n-     * during the search.\n      * @throws org.apache.commons.math.exception.DimensionMismatchException\n      * if the start point dimension is wrong.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * any argument is {@code null}.\n      */\n     VectorialPointValuePair optimize(FUNC f, double[] target, double[] weight,\n-                                     double[] startPoint)\n-        throws FunctionEvaluationException;\n+                                     double[] startPoint);\n }\n--- a/src/main/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n \n package org.apache.commons.math.optimization;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n      * </p>\n      * <p>\n      * The array computed by the objective function, the observations array and the\n-     * weights array must have consistent sizes or a {@link FunctionEvaluationException} will be\n-     * triggered while computing the scalar objective.\n+     * weights array must have consistent sizes or a {@link DimensionMismatchException}\n+     * will be triggered while computing the scalar objective.\n      * </p>\n      * @param function vectorial residuals function to wrap\n      * @param observations observations to be compared to objective function to compute residuals\n      * @param weights weights to apply to the residuals\n-     * @exception IllegalArgumentException if the observations vector and the weights\n-     * vector dimensions don't match (objective function dimension is checked only when\n+     * @exception DimensionMismatchException if the observations vector and the weights\n+     * vector dimensions do not match (objective function dimension is checked only when\n      * the {@link #value(double[])} method is called)\n      */\n     public LeastSquaresConverter(final MultivariateVectorialFunction function,\n                                  final double[] observations, final double[] weights)\n         throws IllegalArgumentException {\n         if (observations.length != weights.length) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n-                    observations.length, weights.length);\n+            throw new DimensionMismatchException(observations.length, weights.length);\n         }\n         this.function     = function;\n         this.observations = observations.clone();\n      * </p>\n      * <p>\n      * The array computed by the objective function, the observations array and the\n-     * the scaling matrix must have consistent sizes or a {@link FunctionEvaluationException}\n+     * the scaling matrix must have consistent sizes or a {@link DimensionMismatchException}\n      * will be triggered while computing the scalar objective.\n      * </p>\n      * @param function vectorial residuals function to wrap\n      * @param observations observations to be compared to objective function to compute residuals\n      * @param scale scaling matrix\n-     * @exception IllegalArgumentException if the observations vector and the scale\n-     * matrix dimensions don't match (objective function dimension is checked only when\n+     * @throws DimensionMismatchException if the observations vector and the scale\n+     * matrix dimensions do not match (objective function dimension is checked only when\n      * the {@link #value(double[])} method is called)\n      */\n     public LeastSquaresConverter(final MultivariateVectorialFunction function,\n-                                 final double[] observations, final RealMatrix scale)\n-        throws IllegalArgumentException {\n+                                 final double[] observations, final RealMatrix scale) {\n         if (observations.length != scale.getColumnDimension()) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n-                    observations.length, scale.getColumnDimension());\n+            throw new DimensionMismatchException(observations.length, scale.getColumnDimension());\n         }\n         this.function     = function;\n         this.observations = observations.clone();\n     }\n \n     /** {@inheritDoc} */\n-    public double value(final double[] point) throws FunctionEvaluationException {\n-\n+    public double value(final double[] point) {\n         // compute residuals\n         final double[] residuals = function.value(point);\n         if (residuals.length != observations.length) {\n-            throw new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\n-                                                  residuals.length, observations.length);\n+            throw new DimensionMismatchException(residuals.length, observations.length);\n         }\n         for (int i = 0; i < residuals.length; ++i) {\n             residuals[i] -= observations[i];\n         }\n \n         return sumSquares;\n-\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/optimization/direct/AbstractSimplex.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/AbstractSimplex.java\n import java.util.Arrays;\n import java.util.Comparator;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n      * @param evaluationFunction Evaluation function.\n      * @param comparator Comparator to use to sort simplex vertices from best\n      * to worst.\n-     * @throws FunctionEvaluationException if the function cannot be evaluated\n-     * at some point.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the algorithm fails to converge.\n      */\n     public abstract void iterate(final MultivariateRealFunction evaluationFunction,\n-                                 final Comparator<RealPointValuePair> comparator)\n-        throws FunctionEvaluationException;\n+                                 final Comparator<RealPointValuePair> comparator);\n \n     /**\n      * Build an initial simplex.\n      *\n      * @param evaluationFunction Evaluation function.\n      * @param comparator Comparator to use to sort simplex vertices from best to worst.\n-     * @throws FunctionEvaluationException if no value can be computed for the parameters.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the maximal number of evaluations is exceeded.\n      */\n     public void evaluate(final MultivariateRealFunction evaluationFunction,\n-                         final Comparator<RealPointValuePair> comparator)\n-        throws FunctionEvaluationException {\n-\n+                         final Comparator<RealPointValuePair> comparator) {\n         // Evaluate the objective function at all non-evaluated simplex points.\n         for (int i = 0; i < simplex.length; i++) {\n             final RealPointValuePair vertex = simplex[i];\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractScalarOptimizer.java\n \n package org.apache.commons.math.optimization.direct;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.util.Incrementor;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n      *\n      * @param point Point at which the objective function must be evaluated.\n      * @return the objective function value at the specified point.\n-     * @throws FunctionEvaluationException if the function cannot be evaluated.\n      * @throws TooManyEvaluationsException if the maximal number of\n      * evaluations is exceeded.\n      */\n-    protected double computeObjectiveValue(double[] point)\n-        throws FunctionEvaluationException {\n+    protected double computeObjectiveValue(double[] point) {\n         try {\n             evaluations.incrementCount();\n         } catch (MaxCountExceededException e) {\n     /** {@inheritDoc} */\n     public RealPointValuePair optimize(FUNC f,\n                                        GoalType goalType,\n-                                       double[] startPoint)\n-        throws FunctionEvaluationException {\n+                                       double[] startPoint) {\n         // Checks.\n         if (f == null) {\n             throw new NullArgumentException();\n     /**\n      * Perform the bulk of the optimization algorithm.\n      *\n-     * @return the point/value pair giving the optimal value for objective function\n-     * @throws FunctionEvaluationException if the objective function throws one during\n-     * the search\n+     * @return the point/value pair giving the optimal value for objective function.\n      */\n-    protected abstract RealPointValuePair doOptimize()\n-        throws FunctionEvaluationException;\n+    protected abstract RealPointValuePair doOptimize();\n }\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractVectorialOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BaseAbstractVectorialOptimizer.java\n \n package org.apache.commons.math.optimization.direct;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.util.Incrementor;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n      *\n      * @param point Point at which the objective function must be evaluated.\n      * @return the objective function value at the specified point.\n-     * @throws FunctionEvaluationException if the function cannot be evaluated.\n      * @throws TooManyEvaluationsException if the maximal number of evaluations is\n      * exceeded.\n      */\n-    protected double[] computeObjectiveValue(double[] point)\n-        throws FunctionEvaluationException {\n+    protected double[] computeObjectiveValue(double[] point) {\n         try {\n             evaluations.incrementCount();\n         } catch (MaxCountExceededException e) {\n     /** {@inheritDoc} */\n     public VectorialPointValuePair optimize(FUNC f,\n                                             double[] t, double[] w,\n-                                            double[] startPoint)\n-        throws FunctionEvaluationException {\n+                                            double[] startPoint) {\n         // Checks.\n         if (f == null) {\n             throw new NullArgumentException();\n      * Perform the bulk of the optimization algorithm.\n      *\n      * @return the point/value pair giving the optimal value for objective function\n-     * @throws FunctionEvaluationException if the objective function throws one during\n-     * the search\n      */\n-    protected abstract VectorialPointValuePair doOptimize()\n-        throws FunctionEvaluationException;\n+    protected abstract VectorialPointValuePair doOptimize();\n \n     /**\n      * @return a reference to the {@link #target array}.\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionalSimplex.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectionalSimplex.java\n \n import java.util.Comparator;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.optimization.RealPointValuePair;\n \n     /** {@inheritDoc} */\n     @Override\n     public void iterate(final MultivariateRealFunction evaluationFunction,\n-                        final Comparator<RealPointValuePair> comparator)\n-        throws FunctionEvaluationException {\n+                        final Comparator<RealPointValuePair> comparator) {\n         // Save the original simplex.\n         final RealPointValuePair[] original = getPoints();\n         final RealPointValuePair best = original[0];\n      * @param comparator Comparator to use to sort simplex vertices from best\n      * to poorest.\n      * @return the best point in the transformed simplex.\n-     * @throws FunctionEvaluationException if the function cannot be\n-     * evaluated at some point.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the maximal number of evaluations is exceeded.\n      */\n     private RealPointValuePair evaluateNewSimplex(final MultivariateRealFunction evaluationFunction,\n                                                   final RealPointValuePair[] original,\n                                                   final double coeff,\n-                                                  final Comparator<RealPointValuePair> comparator)\n-        throws FunctionEvaluationException {\n+                                                  final Comparator<RealPointValuePair> comparator) {\n         final double[] xSmallest = original[0].getPointRef();\n         // Perform a linear transformation on all the simplex points,\n         // except the first one.\n--- a/src/main/java/org/apache/commons/math/optimization/direct/NelderMeadSimplex.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/NelderMeadSimplex.java\n \n import java.util.Comparator;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.optimization.RealPointValuePair;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n \n     /** {@inheritDoc} */\n     @Override\n     public void iterate(final MultivariateRealFunction evaluationFunction,\n-                        final Comparator<RealPointValuePair> comparator)\n-        throws FunctionEvaluationException {\n-\n+                        final Comparator<RealPointValuePair> comparator) {\n         // The simplex has n + 1 points if dimension is n.\n         final int n = getDimension();\n \n--- a/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n \n package org.apache.commons.math.optimization.direct;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n \n     /** {@inheritDoc} */\n     @Override\n-    protected RealPointValuePair doOptimize()\n-        throws FunctionEvaluationException {\n+    protected RealPointValuePair doOptimize() {\n         final GoalType goal = getGoalType();\n         final double[] guess = getStartPoint();\n         final int n = guess.length;\n          * @param p Starting point.\n          * @param d Search direction.\n          * @return the optimum.\n-         * @throws FunctionEvaluationException if the function evaluation\n-         * fails.\n          * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n          * if the number of evaluations is exceeded.\n          */\n         public UnivariateRealPointValuePair search(final double[] p,\n-                                                   final double[] d)\n-            throws FunctionEvaluationException {\n-\n+                                                   final double[] d) {\n             final int n = p.length;\n             final UnivariateRealFunction f = new UnivariateRealFunction() {\n-                    public double value(double alpha)\n-                        throws FunctionEvaluationException {\n+                    public double value(double alpha) {\n                         final double[] x = new double[n];\n                         for (int i = 0; i < n; i++) {\n                             x[i] = p[i] + alpha * d[i];\n--- a/src/main/java/org/apache/commons/math/optimization/direct/SimplexOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/SimplexOptimizer.java\n \n import java.util.Comparator;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.MultivariateRealFunction;\n import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.optimization.GoalType;\n \n     /** {@inheritDoc} */\n     @Override\n-    protected RealPointValuePair doOptimize()\n-        throws FunctionEvaluationException {\n+    protected RealPointValuePair doOptimize() {\n         if (simplex == null) {\n             throw new NullArgumentException();\n         }\n         // evaluations counter.\n         final MultivariateRealFunction evalFunc\n             = new MultivariateRealFunction() {\n-                public double value(double[] point)\n-                    throws FunctionEvaluationException {\n+                public double value(double[] point) {\n                     return computeObjectiveValue(point);\n                 }\n             };\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/CurveFitter.java\n import java.util.ArrayList;\n import java.util.List;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateVectorialFunction;\n import org.apache.commons.math.analysis.MultivariateMatrixFunction;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n \n     /** Add an observed (x,y) point to the sample with unit weight.\n      * <p>Calling this method is equivalent to call\n-     * <code>addObservedPoint(1.0, x, y)</code>.</p>\n+     * {@code addObservedPoint(1.0, x, y)}.</p>\n      * @param x abscissa of the point\n      * @param y observed value of the point at x, after fitting we should\n      * have f(x) as close as possible to this value\n      * @param f parametric function to fit\n      * @param initialGuess first guess of the function parameters\n      * @return fitted parameters\n-     * @exception FunctionEvaluationException if the objective function throws one during\n-     * the search\n      * @exception org.apache.commons.math.exception.ConvergenceException\n      * if the algorithm failed to converge.\n      * @exception org.apache.commons.math.exception.DimensionMismatchException\n      * if the start point dimension is wrong.\n      */\n     public double[] fit(final ParametricRealFunction f,\n-                        final double[] initialGuess)\n-        throws FunctionEvaluationException {\n-\n+                        final double[] initialGuess) {\n         // prepare least squares problem\n         double[] target  = new double[observations.size()];\n         double[] weights = new double[observations.size()];\n     /** Vectorial function computing function theoretical values. */\n     private class TheoreticalValuesFunction\n         implements DifferentiableMultivariateVectorialFunction {\n-\n         /** Function to fit. */\n         private final ParametricRealFunction f;\n \n         /** {@inheritDoc} */\n         public MultivariateMatrixFunction jacobian() {\n             return new MultivariateMatrixFunction() {\n-                public double[][] value(double[] point)\n-                    throws FunctionEvaluationException, IllegalArgumentException {\n-\n+                public double[][] value(double[] point) {\n                     final double[][] jacobian = new double[observations.size()][];\n \n                     int i = 0;\n                     }\n \n                     return jacobian;\n-\n                 }\n             };\n         }\n \n         /** {@inheritDoc} */\n-        public double[] value(double[] point)\n-                throws FunctionEvaluationException, IllegalArgumentException {\n-\n+        public double[] value(double[] point) {\n             // compute the residuals\n             final double[] values = new double[observations.size()];\n             int i = 0;\n             }\n \n             return values;\n-\n         }\n-\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianDerivativeFunction.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianDerivativeFunction.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n /**\n  * The derivative of {@link GaussianFunction}.  Specifically:\n  * <p>\n- * <tt>f'(x) = (-b / (d^2)) * (x - c) * exp(-((x - c)^2) / (2*(d^2)))</tt>\n+ * {@code f'(x) = (-b / (d^2)) * (x - c) * exp(-((x - c)^2) / (2*(d^2)))}\n  * <p>\n  * Notation key:\n  * <ul>\n- * <li><tt>x^n</tt>: <tt>x</tt> raised to the power of <tt>n</tt>\n- * <li><tt>exp(x)</tt>: <i>e</i><tt>^x</tt>\n+ * <li>{@code x^n}: {@code x} raised to the power of {@code n}\n+ * <li>{@code exp(x)}: <i>e</i><sup>x</sup>\n  * </ul>\n  *\n  * @since 2.2\n  * @version $Revision$ $Date$\n  */\n public class GaussianDerivativeFunction implements UnivariateRealFunction, Serializable {\n-\n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -6500229089670174766L;\n-\n     /** Parameter b of this function. */\n     private final double b;\n-\n     /** Parameter c of this function. */\n     private final double c;\n-\n     /** Square of the parameter d of this function. */\n     private final double d2;\n \n     /**\n      * Constructs an instance with the specified parameters.\n      *\n-     * @param b <tt>b</tt> parameter value\n-     * @param c <tt>c</tt> parameter value\n-     * @param d <tt>d</tt> parameter value\n+     * @param b {@code b} parameter value.\n+     * @param c {@code c} parameter value.\n+     * @param d {@code d} parameter value.\n      *\n      * @throws IllegalArgumentException if <code>d</code> is 0\n      */\n     /**\n      * Constructs an instance with the specified parameters.\n      *\n-     * @param parameters <tt>b</tt>, <tt>c</tt>, and <tt>d</tt> parameter values\n-     *\n-     * @throws IllegalArgumentException if <code>parameters</code> is null,\n-     *         <code>parameters</code> length is not 3, or if\n-     *         <code>parameters[2]</code> is 0\n+     * @param parameters {@code b}, {@code c} and {@code d} parameter values.\n+     * @throws NullArgumentException if {@code parameters} is {@code null}.\n+     * @throws DimensionMismatchException if the size of {@code parameters} is\n+     * not 3.\n+     * @throws ZeroException if {@code parameters[2]} is 0.\n      */\n     public GaussianDerivativeFunction(double[] parameters) {\n         if (parameters == null) {\n     }\n \n     /** {@inheritDoc} */\n-    public double value(double x) throws FunctionEvaluationException {\n+    public double value(double x) {\n         final double xMc = x - c;\n         return (-b / d2) * xMc * Math.exp(-(xMc * xMc) / (2.0 * d2));\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n \n package org.apache.commons.math.optimization.fitting;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.OptimizationException;\n import org.apache.commons.math.optimization.fitting.CurveFitter;\n  *   fitter.addObservedPoint(4.07525716, 1447024.0);\n  *   fitter.addObservedPoint(4.08237071, 717104.0);\n  *   fitter.addObservedPoint(4.08366408, 620014.0);\n- *  GaussianFunction fitFunction = fitter.fit();\n+ *   GaussianFunction fitFunction = fitter.fit();\n  * </pre>\n  *\n  * @see ParametricGaussianFunction\n  * @version $Revision$ $Date$\n  */\n public class GaussianFitter {\n-\n     /** Fitter used for fitting. */\n     private final CurveFitter fitter;\n \n     }\n \n     /**\n-     * Adds point (<code>x</code>, <code>y</code>) to list of observed points\n-     * with a weight of 1.0.\n+     * Adds point ({@code x}, {@code y}) to list of observed points\n+     * with a weight of 1.\n      *\n-     * @param x <tt>x</tt> point value\n-     * @param y <tt>y</tt> point value\n+     * @param x Abscissa value.\n+     * @param y Ordinate value.\n      */\n     public void addObservedPoint(double x, double y) {\n-        addObservedPoint(1.0, x, y);\n+        addObservedPoint(1, x, y);\n     }\n \n     /**\n-     * Adds point (<code>x</code>, <code>y</code>) to list of observed points\n-     * with a weight of <code>weight</code>.\n+     * Adds point ({@code x}, {@code y}) to list of observed points\n+     * with a weight of {@code weight}.\n      *\n-     * @param weight weight assigned to point\n-     * @param x <tt>x</tt> point value\n-     * @param y <tt>y</tt> point value\n+     * @param weight Weight assigned to the given point.\n+     * @param x Abscissa value.\n+     * @param y Ordinate value.\n      */\n     public void addObservedPoint(double weight, double x, double y) {\n         fitter.addObservedPoint(weight, x, y);\n \n     /**\n      * Fits Gaussian function to the observed points.\n+     * It will call {@link CurveFitter#fit()}.\n      *\n-     * @return Gaussian function best fitting the observed points\n-     *\n-     * @throws FunctionEvaluationException if <code>CurveFitter.fit</code>\n-     *         throws it\n-     * @throws OptimizationException if <code>CurveFitter.fit</code> throws it\n-     * @throws IllegalArgumentException if <code>CurveFitter.fit</code> throws\n-     *         it\n-     *\n+     * @return the Gaussian function that best fits the observed points.\n      * @see CurveFitter\n      */\n-    public GaussianFunction fit()\n-        throws FunctionEvaluationException, OptimizationException {\n+    public GaussianFunction fit() {\n         return new GaussianFunction(fitter.fit(new ParametricGaussianFunction(),\n                                                createParametersGuesser(fitter.getObservations()).guess()));\n     }\n \n     /**\n-     * Factory method to create a <code>GaussianParametersGuesser</code>\n+     * Factory method to create a {@code GaussianParametersGuesser}\n      * instance initialized with the specified observations.\n      *\n      * @param observations points used to initialize the created\n-     *        <code>GaussianParametersGuesser</code> instance\n-     *\n-     * @return new <code>GaussianParametersGuesser</code> instance\n+     * {@code GaussianParametersGuesser} instance.\n+     * @return a new {@code GaussianParametersGuesser} instance.\n      */\n     protected GaussianParametersGuesser createParametersGuesser(WeightedObservedPoint[] observations) {\n         return new GaussianParametersGuesser(observations);\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFunction.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFunction.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.exception.DimensionMismatchException;\n     }\n \n     /** {@inheritDoc} */\n-    public double value(double x) throws FunctionEvaluationException {\n+    public double value(double x) {\n         final double xMc = x - c;\n         return a + b * Math.exp(-xMc * xMc / (2.0 * (d * d)));\n     }\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/HarmonicFitter.java\n \n package org.apache.commons.math.optimization.fitting;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n import org.apache.commons.math.optimization.OptimizationException;\n         fitter.addObservedPoint(weight, x, y);\n     }\n \n-    /** Fit an harmonic function to the observed points.\n-     * @return harmonic function best fitting the observed points\n-     * @throws OptimizationException if the sample is too short or if\n-     * the first guess cannot be computed\n+    /**\n+     * Fit an harmonic function to the observed points.\n+     *\n+     * @return harmonic Function that best fits the observed points.\n+     * @throws NumberIsTooSmallException if the sample is too short or if\n+     * the first guess cannot be computed.\n      */\n     public HarmonicFunction fit() throws OptimizationException {\n-        try {\n-\n-            // shall we compute the first guess of the parameters ourselves ?\n-            if (parameters == null) {\n-                final WeightedObservedPoint[] observations = fitter.getObservations();\n-                if (observations.length < 4) {\n-                    throw new OptimizationException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE,\n-                                                    observations.length, 4);\n-                }\n-\n-                HarmonicCoefficientsGuesser guesser = new HarmonicCoefficientsGuesser(observations);\n-                guesser.guess();\n-                parameters = new double[] {\n-                                 guesser.getGuessedAmplitude(),\n-                                 guesser.getGuessedPulsation(),\n-                                 guesser.getGuessedPhase()\n-                            };\n-\n+        // shall we compute the first guess of the parameters ourselves ?\n+        if (parameters == null) {\n+            final WeightedObservedPoint[] observations = fitter.getObservations();\n+            if (observations.length < 4) {\n+                throw new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE,\n+                                                    observations.length, 4, true);\n             }\n \n-            double[] fitted = fitter.fit(new ParametricHarmonicFunction(), parameters);\n-            return new HarmonicFunction(fitted[0], fitted[1], fitted[2]);\n+            HarmonicCoefficientsGuesser guesser = new HarmonicCoefficientsGuesser(observations);\n+            guesser.guess();\n+            parameters = new double[] {\n+                guesser.getGuessedAmplitude(),\n+                guesser.getGuessedPulsation(),\n+                guesser.getGuessedPhase()\n+            };    \n+        }\n \n-        } catch (FunctionEvaluationException fee) {\n-            // this should never happen\n-            throw MathRuntimeException.createInternalError(fee);\n-        }\n+        double[] fitted = fitter.fit(new ParametricHarmonicFunction(), parameters);\n+        return new HarmonicFunction(fitted[0], fitted[1], fitted[2]);\n     }\n \n     /** Parametric harmonic function. */\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/ParametricGaussianFunction.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/ParametricGaussianFunction.java\n \n import java.io.Serializable;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.DimensionMismatchException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.exception.ZeroException;\n /**\n  * A Gaussian function.  Specifically:\n  * <p>\n- * <tt>f(x) = a + b*exp(-((x - c)^2 / (2*d^2)))</tt>\n+ * {@code f(x) = a + b*exp(-((x - c)^2 / (2*d^2)))}\n  * <p>\n  * The parameters have the following meaning:\n  * <ul>\n- * <li><tt>a</tt> is a constant offset that shifts <tt>f(x)</tt> up or down\n- * <li><tt>b</tt> is the height of the peak\n- * <li><tt>c</tt> is the position of the center of the peak\n- * <li><tt>d</tt> is related to the FWHM by <tt>FWHM = 2*sqrt(2*ln(2))*d</tt>\n+ * <li>{@code a} is a constant offset that shifts {@code f(x)} up or down\n+ * <li>{@code b} is the height of the peak\n+ * <li>{@code c} is the position of the center of the peak\n+ * <li>{@code d} is related to the FWHM by {@code FWHM = 2*sqrt(2*ln(2))*d}\n  * </ul>\n  * Notation key:\n  * <ul>\n- * <li><tt>x^n</tt>: <tt>x</tt> raised to the power of <tt>n</tt>\n- * <li><tt>exp(x)</tt>: <i>e</i><tt>^x</tt>\n- * <li><tt>sqrt(x)</tt>: the square root of <tt>x</tt>\n- * <li><tt>ln(x)</tt>: the natural logarithm of <tt>x</tt>\n+ * <li>{@code x^n}: {@code x} raised to the power of {@code n}\n+ * <li>{@code exp(x)}: e<sup>x</sup>\n+ * <li>{@code sqrt(x)}: square root of {@code x}\n+ * <li>{@code ln(x)}: natural logarithm of {@code x}\n  * </ul>\n  * References:\n  * <ul>\n  * @version $Revision$ $Date$\n  */\n public class ParametricGaussianFunction implements ParametricRealFunction, Serializable {\n-\n     /** Serializable version Id. */\n     private static final long serialVersionUID = -3875578602503903233L;\n \n     /**\n-     * Constructs an instance.\n+     * Computes value of function {@code f(x)} for the specified {@code x} and\n+     * parameters {@code a}, {@code b}, {@code c}, and {@code d}.\n+     *\n+     * @param x Value at which to compute the function.\n+     * @return {@code f(x)}.\n+     * @param parameters Values of {@code a}, {@code b}, {@code c}, and {@code d}.\n+     * @throws NullArgumentException if {@code parameters} is {@code null}.\n+     * @throws DimensionMismatchException if the size of {@code parameters} is\n+     * not 4.\n+     * @throws ZeroException if {@code parameters[3]} is 0.\n      */\n-    public ParametricGaussianFunction() {\n-    }\n-\n-    /**\n-     * Computes value of function <tt>f(x)</tt> for the specified <tt>x</tt> and\n-     * parameters <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, and <tt>d</tt>.\n-     *\n-     * @param x <tt>x</tt> value\n-     * @param parameters values of <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, and\n-     *        <tt>d</tt>\n-     *\n-     * @return value of <tt>f(x)</tt> evaluated at <tt>x</tt> with the specified\n-     *         parameters\n-     *\n-     * @throws IllegalArgumentException if <code>parameters</code> is invalid as\n-     *         determined by {@link #validateParameters(double[])}\n-     * @throws FunctionEvaluationException if <code>parameters</code> values are\n-     *         invalid as determined by {@link #validateParameters(double[])}\n-     */\n-    public double value(double x, double[] parameters) throws FunctionEvaluationException {\n+    public double value(double x, double[] parameters) {\n         validateParameters(parameters);\n         final double a = parameters[0];\n         final double b = parameters[1];\n \n     /**\n      * Computes the gradient vector for a four variable version of the function\n-     * where the parameters, <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, and <tt>d</tt>,\n-     * are considered the variables, not <tt>x</tt>.  That is, instead of\n-     * computing the gradient vector for the function <tt>f(x)</tt> (which would\n-     * just be the derivative of <tt>f(x)</tt> with respect to <tt>x</tt> since\n+     * where the parameters, {@code a}, {@code b}, {@code c}, and {@code d},\n+     * are considered the variables, not {@code x}.  That is, instead of\n+     * computing the gradient vector for the function {@code f(x)} (which would\n+     * just be the derivative of {@code f(x)} with respect to {@code x} since\n      * it's a one-dimensional function), computes the gradient vector for the\n-     * function <tt>f(a, b, c, d) = a + b*exp(-((x - c)^2 / (2*d^2)))</tt>\n-     * treating the specified <tt>x</tt> as a constant.\n+     * function {@code f(a, b, c, d) = a + b*exp(-((x - c)^2 / (2*d^2)))}\n+     * treating the specified {@code x} as a constant.\n      * <p>\n      * The components of the computed gradient vector are the partial\n-     * derivatives of <tt>f(a, b, c, d)</tt> with respect to each variable.\n-     * That is, the partial derivative of <tt>f(a, b, c, d)</tt> with respect to\n-     * <tt>a</tt>, the partial derivative of <tt>f(a, b, c, d)</tt> with respect\n-     * to <tt>b</tt>, the partial derivative of <tt>f(a, b, c, d)</tt> with\n-     * respect to <tt>c</tt>, and the partial derivative of <tt>f(a, b, c,\n-     * d)</tt> with respect to <tt>d</tt>.\n+     * derivatives of {@code f(a, b, c, d)} with respect to each variable.\n+     * That is, the partial derivative of {@code f(a, b, c, d)} with respect to\n+     * {@code a}, the partial derivative of {@code f(a, b, c, d)} with respect\n+     * to {@code b}, the partial derivative of {@code f(a, b, c, d)} with\n+     * respect to {@code c}, and the partial derivative of {@code f(a, b, c,\n+     * d)} with respect to {@code d}.\n      *\n-     * @param x <tt>x</tt> value to be used as constant in <tt>f(a, b, c,\n-     *        d)</tt>\n-     * @param parameters values of <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, and\n-     *        <tt>d</tt> for computation of gradient vector of <tt>f(a, b, c,\n-     *        d)</tt>\n-     *\n-     * @return gradient vector of <tt>f(a, b, c, d)</tt>\n-     *\n-     * @throws IllegalArgumentException if <code>parameters</code> is invalid as\n-     *         determined by {@link #validateParameters(double[])}\n-     * @throws FunctionEvaluationException if <code>parameters</code> values are\n-     *         invalid as determined by {@link #validateParameters(double[])}\n+     * @param x {@code x} value to be used as constant in {@code f(a, b, c, d)}.\n+     * @param parameters values of {@code a}, {@code b}, {@code c}, and\n+     * {@code d} for computation of gradient vector of {@code f(a, b, c, d)}.\n+     * @return the gradient vector of {@code f(a, b, c, d)}.\n+     * @param parameters Values of {@code a}, {@code b}, {@code c}, and {@code d}.\n+     * @throws NullArgumentException if {@code parameters} is {@code null}.\n+     * @throws DimensionMismatchException if the size of {@code parameters} is\n+     * not 4.\n+     * @throws ZeroException if {@code parameters[3]} is 0.\n      */\n-    public double[] gradient(double x, double[] parameters) throws FunctionEvaluationException {\n-\n+    public double[] gradient(double x, double[] parameters) {\n         validateParameters(parameters);\n         final double b = parameters[1];\n         final double c = parameters[2];\n         final double f    = b * exp * xMc / d2;\n \n         return new double[] { 1.0, exp, f, f * xMc / d };\n-\n     }\n \n     /**\n      * Validates parameters to ensure they are appropriate for the evaluation of\n-     * the <code>value</code> and <code>gradient</code> methods.\n+     * the {@code value} and {@code gradient} methods.\n      *\n-     * @param parameters values of <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, and\n-     *        <tt>d</tt>\n-     *\n-     * @throws IllegalArgumentException if <code>parameters</code> is\n-     *         <code>null</code> or if <code>parameters</code> does not have\n-     *         length == 4\n-     * @throws FunctionEvaluationException if <code>parameters[3]</code>\n-     *         (<tt>d</tt>) is 0\n+     * @param parameters Values of {@code a}, {@code b}, {@code c}, and {@code d}.\n+     * @throws NullArgumentException if {@code parameters} is {@code null}.\n+     * @throws DimensionMismatchException if the size of {@code parameters} is\n+     * not 4.\n+     * @throws ZeroException if {@code parameters[3]} is 0.\n      */\n-    private void validateParameters(double[] parameters) throws FunctionEvaluationException {\n+    private void validateParameters(double[] parameters) {\n         if (parameters == null) {\n             throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n         }\n         if (parameters.length != 4) {\n             throw new DimensionMismatchException(4, parameters.length);\n         }\n-        if (parameters[3] == 0.0) {\n+        if (parameters[3] == 0) {\n             throw new ZeroException();\n         }\n     }\n-\n }\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/ParametricRealFunction.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/ParametricRealFunction.java\n \n package org.apache.commons.math.optimization.fitting;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n-\n /**\n  * An interface representing a real function that depends on one independent\n  * variable plus some extra parameters.\n  * @version $Revision$ $Date$\n  */\n public interface ParametricRealFunction {\n-\n     /**\n      * Compute the value of the function.\n-     * @param x the point for which the function value should be computed\n-     * @param parameters function parameters\n-     * @return the value\n-     * @throws FunctionEvaluationException if the function evaluation fails\n+     *\n+     * @param x Point for which the function value should be computed.\n+     * @param parameters Function parameters.\n+     * @return the value.\n      */\n-    double value(double x, double[] parameters)\n-        throws FunctionEvaluationException;\n+    double value(double x, double[] parameters);\n \n     /**\n      * Compute the gradient of the function with respect to its parameters.\n-     * @param x the point for which the function value should be computed\n-     * @param parameters function parameters\n-     * @return the value\n-     * @throws FunctionEvaluationException if the function evaluation fails\n+     *\n+     * @param x Point for which the function value should be computed.\n+     * @param parameters Function parameters.\n+     * @return the value.\n      */\n-    double[] gradient(double x, double[] parameters)\n-        throws FunctionEvaluationException;\n-\n+    double[] gradient(double x, double[] parameters);\n }\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/PolynomialFitter.java\n \n package org.apache.commons.math.optimization.fitting;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.polynomials.PolynomialFunction;\n import org.apache.commons.math.optimization.DifferentiableMultivariateVectorialOptimizer;\n \n      * if the algorithm failed to converge.\n      */\n     public PolynomialFunction fit() {\n-        try {\n-            return new PolynomialFunction(fitter.fit(new ParametricPolynomial(), new double[degree + 1]));\n-        } catch (FunctionEvaluationException fee) {\n-            // this should never happen\n-            throw MathRuntimeException.createInternalError(fee);\n-        }\n+        return new PolynomialFunction(fitter.fit(new ParametricPolynomial(), new double[degree + 1]));\n     }\n \n     /**\n     private static class ParametricPolynomial implements ParametricRealFunction {\n \n         /** {@inheritDoc} */\n-        public double[] gradient(double x, double[] parameters)\n-                throws FunctionEvaluationException {\n+        public double[] gradient(double x, double[] parameters) {\n             final double[] gradient = new double[parameters.length];\n             double xn = 1.0;\n             for (int i = 0; i < parameters.length; ++i) {\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java\n     /**\n      * Update the jacobian matrix.\n      *\n-     * @throws org.apache.commons.math.exception.FunctionEvaluationException\n-     * if the function Jacobian cannot be evaluated.\n      * @throws DimensionMismatchException if the Jacobian dimension does not\n      * match problem dimension.\n      */\n \n     /**\n      * Update the residuals array and cost function value.\n-     * @throws org.apache.commons.math.exception.FunctionEvaluationException\n-     * if the function cannot be evaluated.\n      * @throws DimensionMismatchException if the dimension does not match the\n      * problem dimension.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * Get the covariance matrix of the optimized parameters.\n      *\n      * @return the covariance matrix.\n-     * @throws org.apache.commons.math.exception.FunctionEvaluationException\n-     * if the function Jacobian cannot be evaluated.\n      * @throws org.apache.commons.math.exception.SingularMatrixException\n      * if the covariance matrix cannot be computed (singular problem).\n      */\n      * Guessing is covariance-based: It only gives a rough order of magnitude.\n      *\n      * @return errors in optimized parameters\n-     * @throws org.apache.commons.math.exception.FunctionEvaluationException\n-     * if the function Jacobian cannot be evaluated.\n      * @throws org.apache.commons.math.exception.SingularMatrixException if\n      * the covariances matrix cannot be computed.\n      * @throws NumberIsTooSmallException if the number of degrees of freedom is not\n--- a/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/AbstractScalarDifferentiableOptimizer.java\n \n package org.apache.commons.math.optimization.general;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.DifferentiableMultivariateRealFunction;\n import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.optimization.DifferentiableMultivariateRealOptimizer;\n      *\n      * @param evaluationPoint Point at which the gradient must be evaluated.\n      * @return the gradient at the specified point.\n-     * @throws FunctionEvaluationException if the function gradient cannot be\n-     * evaluated.\n      * @throws org.apache.commons.math.exception.TooManyEvaluationsException\n      * if the allowed number of evaluations is exceeded.\n      */\n-    protected double[] computeObjectiveGradient(final double[] evaluationPoint)\n-        throws FunctionEvaluationException {\n+    protected double[] computeObjectiveGradient(final double[] evaluationPoint) {\n         return gradient.value(evaluationPoint);\n     }\n \n     @Override\n     public RealPointValuePair optimize(final DifferentiableMultivariateRealFunction f,\n                                        final GoalType goalType,\n-                                       final double[] startPoint)\n-        throws FunctionEvaluationException {\n+                                       final double[] startPoint) {\n         // Store optimization problem characteristics.\n         gradient = f.gradient();\n \n--- a/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/GaussNewtonOptimizer.java\n package org.apache.commons.math.optimization.general;\n \n import org.apache.commons.math.exception.SingularMatrixException;\n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.linear.BlockRealMatrix;\n \n     /** {@inheritDoc} */\n     @Override\n-    public VectorialPointValuePair doOptimize()\n-        throws FunctionEvaluationException {\n+    public VectorialPointValuePair doOptimize() {\n \n         final ConvergenceChecker<VectorialPointValuePair> checker\n             = getConvergenceChecker();\n--- a/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/LevenbergMarquardtOptimizer.java\n \n import java.util.Arrays;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.optimization.VectorialPointValuePair;\n \n     /** {@inheritDoc} */\n     @Override\n-    protected VectorialPointValuePair doOptimize()\n-        throws FunctionEvaluationException {\n+    protected VectorialPointValuePair doOptimize() {\n         // arrays shared with the other private methods\n         solvedCols  = FastMath.min(rows, cols);\n         diagR       = new double[cols];\n--- a/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/NonLinearConjugateGradientOptimizer.java\n \n package org.apache.commons.math.optimization.general;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.exception.MathIllegalStateException;\n import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n \n     /** {@inheritDoc} */\n     @Override\n-    protected RealPointValuePair doOptimize()\n-        throws FunctionEvaluationException {\n+    protected RealPointValuePair doOptimize() {\n         // Initialization.\n         if (preconditioner == null) {\n             preconditioner = new IdentityPreconditioner();\n     }\n \n     /**\n-     * Find the upper bound b ensuring bracketing of a root between a and b\n-     * @param f function whose root must be bracketed\n-     * @param a lower bound of the interval\n-     * @param h initial step to try\n-     * @return b such that f(a) and f(b) have opposite signs\n-     * @exception FunctionEvaluationException if the function cannot be computed\n-     * @exception MathIllegalStateException if no bracket can be found\n+     * Find the upper bound b ensuring bracketing of a root between a and b.\n+     *\n+     * @param f function whose root must be bracketed.\n+     * @param a lower bound of the interval.\n+     * @param h initial step to try.\n+     * @return b such that f(a) and f(b) have opposite signs.\n+     * @exception MathIllegalStateException if no bracket can be found.\n      */\n     private double findUpperBound(final UnivariateRealFunction f,\n-                                  final double a, final double h)\n-        throws FunctionEvaluationException {\n+                                  final double a, final double h) {\n         final double yA = f.value(a);\n         double yB = yA;\n         for (double step = h; step < Double.MAX_VALUE; step *= FastMath.max(2, yA / yB)) {\n         }\n \n         /** {@inheritDoc} */\n-        public double value(double x) throws FunctionEvaluationException {\n+        public double value(double x) {\n \n             // current point in the search direction\n             final double[] shiftedPoint = point.clone();\n--- a/src/main/java/org/apache/commons/math/optimization/general/Preconditioner.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/Preconditioner.java\n \n package org.apache.commons.math.optimization.general;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n-\n /**\n  * This interface represents a preconditioner for differentiable scalar\n  * objective function optimizers.\n  * @since 2.0\n  */\n public interface Preconditioner {\n-\n     /**\n      * Precondition a search direction.\n      * <p>\n      * @param point current point at which the search direction was computed\n      * @param r raw search direction (i.e. opposite of the gradient)\n      * @return approximation of H<sup>-1</sup>r where H is the objective function hessian\n-     * @exception FunctionEvaluationException if no cost can be computed for the parameters\n-     * @exception IllegalArgumentException if point dimension is wrong\n      */\n-    double[] precondition(double[] point, double[] r)\n-        throws FunctionEvaluationException, IllegalArgumentException;\n-\n+    double[] precondition(double[] point, double[] r);\n }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n \n package org.apache.commons.math.optimization.univariate;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.util.Incrementor;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n      *\n      * @param point Point at which the objective function must be evaluated.\n      * @return the objective function value at specified point.\n-     * @throws FunctionEvaluationException if the function cannot be\n-     * evaluated.\n      * @throws TooManyEvaluationsException if the maximal number of evaluations\n      * is exceeded.\n      */\n-    protected double computeObjectiveValue(double point)\n-        throws FunctionEvaluationException {\n+    protected double computeObjectiveValue(double point) {\n         try {\n             evaluations.incrementCount();\n         } catch (MaxCountExceededException e) {\n     public UnivariateRealPointValuePair optimize(UnivariateRealFunction f,\n                                                  GoalType goalType,\n                                                  double min, double max,\n-                                                 double startValue)\n-        throws FunctionEvaluationException {\n+                                                 double startValue) {\n         // Checks.\n         if (f == null) {\n             throw new NullArgumentException();\n     /** {@inheritDoc} */\n     public UnivariateRealPointValuePair optimize(UnivariateRealFunction f,\n                                                  GoalType goalType,\n-                                                 double min, double max)\n-        throws FunctionEvaluationException {\n+                                                 double min, double max) {\n         return optimize(f, goalType, min, max, min + 0.5 * (max - min));\n     }\n \n      * @return the optimum and its corresponding function value.\n      * @throws TooManyEvaluationsException if the maximal number of evaluations\n      * is exceeded.\n-     * @throws FunctionEvaluationException if an error occurs evaluating\n-     * the function.\n      */\n-    protected abstract UnivariateRealPointValuePair doOptimize()\n-        throws FunctionEvaluationException;\n+    protected abstract UnivariateRealPointValuePair doOptimize();\n }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BaseUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BaseUnivariateRealOptimizer.java\n \n package org.apache.commons.math.optimization.univariate;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.optimization.BaseOptimizer;\n import org.apache.commons.math.optimization.GoalType;\n      * if the maximum evaluation count is exceeded.\n      * @throws org.apache.commons.math.exception.ConvergenceException\n      * if the optimizer detects a convergence problem.\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function.\n      * @throws IllegalArgumentException if {@code min > max} or the endpoints\n      * do not satisfy the requirements specified by the optimizer.\n      */\n     UnivariateRealPointValuePair optimize(FUNC f, GoalType goalType,\n-                                          double min, double max)\n-        throws FunctionEvaluationException;\n+                                          double min, double max);\n \n     /**\n      * Find an optimum in the given interval, start at startValue.\n      * if the maximum evaluation count is exceeded.\n      * @throws org.apache.commons.math.exception.ConvergenceException if the\n      * optimizer detects a convergence problem.\n-     * @throws FunctionEvaluationException if an error occurs evaluating the\n-     * function.\n      * @throws IllegalArgumentException if {@code min > max} or the endpoints\n      * do not satisfy the requirements specified by the optimizer.\n      * @throws org.apache.commons.math.exception.NullArgumentException if any\n      */\n     UnivariateRealPointValuePair optimize(FUNC f, GoalType goalType,\n                                           double min, double max,\n-                                          double startValue)\n-        throws FunctionEvaluationException;\n+                                          double startValue);\n }\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BracketFinder.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BracketFinder.java\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.optimization.GoalType;\n \n      * @param xB Initial point.\n      * @throws TooManyEvaluationsException if the maximum number of evaluations\n      * is exceeded.\n-     * @throws FunctionEvaluationException if an error occurs evaluating\n-     * the function.\n      */\n     public void search(UnivariateRealFunction func,\n                        GoalType goal,\n                        double xA,\n-                       double xB)\n-        throws FunctionEvaluationException {\n+                       double xB) {\n         evaluations.resetCount();\n         final boolean isMinim = goal == GoalType.MINIMIZE;\n \n      * @param f Function.\n      * @param x Argument.\n      * @return {@code f(x)}\n-     * @throws FunctionEvaluationException if function cannot be evaluated.\n      * @throws TooManyEvaluationsException if the maximal number of evaluations is\n      * exceeded.\n      */\n     private double eval(UnivariateRealFunction f,\n-                        double x)\n-        throws FunctionEvaluationException {\n+                        double x) {\n         try {\n             evaluations.incrementCount();\n         } catch (MaxCountExceededException e) {\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n  */\n package org.apache.commons.math.optimization.univariate;\n \n-import org.apache.commons.math.exception.FunctionEvaluationException;\n import org.apache.commons.math.util.MathUtils;\n import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n \n     /** {@inheritDoc} */\n     @Override\n-    protected UnivariateRealPointValuePair doOptimize()\n-        throws FunctionEvaluationException {\n+    protected UnivariateRealPointValuePair doOptimize() {\n         final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n         final double lo = getMin();\n         final double mid = getStartValue();", "timestamp": 1289742073, "metainfo": ""}