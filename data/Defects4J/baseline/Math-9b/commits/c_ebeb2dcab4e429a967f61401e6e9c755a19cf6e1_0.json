{"sha": "ebeb2dcab4e429a967f61401e6e9c755a19cf6e1", "log": "Added javadoc to FixedDA and altered exceptions in DoubleArray  * One should be able to use a DoubleArray in a similar way to a regular double[], to this effect methods for accessing element values will no longer throw NoSuchElementExceptions when an index is outside of the element set.  These method all throw ArrayIndexOutOfBoundException if a bad index is supplied.  * Filled out javadoc in FixedDoubleArray.   ", "commit": "\n--- a/src/java/org/apache/commons/math/DoubleArray.java\n+++ b/src/java/org/apache/commons/math/DoubleArray.java\n import java.util.NoSuchElementException;\n \n /**\n- * Provides an interface to implemntations which function as an array\n- * of double primitives.\n+ * Provides a single interface for dealing with various flavors\n+ * of double arrays.  This arrays framework follows the model of the\n+ * Collections API by allowing a user to select from a number of \n+ * array implementations with support for various storage mechanisms\n+ * such as automatic expansion, contraction, and array \"rolling\".\n  * \n  * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n  */\n      */\n     int getNumElements();\n \n-    //TODO: Throwing a NoSuchElementException might not be the right\n-    //thing to do, it may be more helpful to just throw ArrayOutOfBounds...\n-\n     /**\n-     * Returns the element at the specified index\n+     * Returns the element at the specified index.  Note that if an\n+     * out of bounds index is supplied a ArrayIndexOutOfBoundsException \n+     * will be thrown.\n      * \n      * @param index index to fetch a value from\n      * @return value stored at the specified index\n-     * @throws NoSuchElementException exception thrown if the array index\n-     *         exceeds the known boundaries of this array.  \n      *\n      */\n-    double getElement(int index) throws NoSuchElementException;\n+    double getElement(int index);\n \n     /**\n      * Sets the element at the specified index.  This method will expand the \n--- a/src/java/org/apache/commons/math/ExpandableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/ExpandableDoubleArray.java\n package org.apache.commons.math;\n \n import java.io.Serializable;\n-import java.util.NoSuchElementException;\n+\n \n /**\n  * An array of double primitives which can expand as needed.\n \n         // The expansion factor *must* be larger than 1.0, otherwise we'll \n         // have an inconsistency upon expansion we'll start shrinking which \n-        // will lead to ArrayOutOfBound exceptions.\n+        // will lead to ArrayIndexOutOfBound exceptions.\n         if (expansionFactor > 1.0) {\n             this.expansionFactor = expansionFactor;\n         } else {\n      * @param index index to fetch a value from\n      * @return value stored at the specified index\n      */\n-    public double getElement(int index) throws NoSuchElementException {\n+    public double getElement(int index) {\n         double value = Double.NaN;\n         if (index >= numElements) {\n             String msg = \"The index specified: \" + index + \n                 \" is larger than the current number of elements\";\n-            throw new NoSuchElementException(msg);\n+            throw new ArrayIndexOutOfBoundsException(msg);\n         } else if (index >= 0) {\n             value = internalArray[startIndex + index];\n         } else {\n             String msg = \"Elements cannot be retrieved from a negative \" +\n                 \"array index\";\n-            throw new IllegalArgumentException(msg);\n+            throw new ArrayIndexOutOfBoundsException(msg);\n         }\n         return value;\n     }\n \t\t\n \t\tif (index < 0) {\n             String msg = \"Cannot set an element at a negative index\";\n-            throw new IllegalArgumentException(msg);\n+            throw new ArrayIndexOutOfBoundsException(msg);\n         }\n \n         if ((startIndex + index) >= internalArray.length) {\n--- a/src/java/org/apache/commons/math/FixedDoubleArray.java\n+++ b/src/java/org/apache/commons/math/FixedDoubleArray.java\n  */\n package org.apache.commons.math;\n \n-import java.util.NoSuchElementException;\n \n /**\n- * Provides a fixed size implementation of the DoubleArray with\n- * support to true \"rolling\" functionality.  If a program attempts to add\n- * a value to a fixed array which has reach a maximum number of \n- * elements a ArrayIndexOutOfBoundsException will be thrown.   \n+ * <p>\n+ * Provides an implementation of the DoubleArray with a maximum number of\n+ * elements.  Creating an array implementation with an upper limit on the\n+ * number of elements allows us to support a more efficient \"rolling\" \n+ * mechanism to support addElementRoling(double). Please note that this\n+ * implementation will not preserve the order of the values supplied to\n+ * this array, calling getValues() will return an array of indeterminate\n+ * order.\n+ * </p>\n  * \n+ * <p>\n+ * Values are added to this array by calling addElement(double) or \n+ * addElementRolling(double).  If addElement(double) is called on \n+ * an array that already contains the maximum number of elements, an\n+ * ArrayIndexOutOfBoundsException will be thrown to reflect an attempt to\n+ * add a value beyond the boundaries of the fixed length array - in this\n+ * respect a FixedDoubleArray can be considered \"full\".  Calling \n+ * addElementRolling(double) on an array which contains the maximum\n+ * number of elements will cause the array to overwrite the \"oldest\"\n+ * value in the array.\n+ * </p>\n+ *\n+ * <p>\n+ * This class is called FixedDoubleArray not because it is of a fixed size.\n+ * The name is appropriate because the internal storage array remains \n+ * \"fixed\" in memory, this implementation will never allocate, or copy\n+ * the internal storage array to a new array instance.\n+ * </p>\n+ *\n  * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n  */\n public class FixedDoubleArray implements DoubleArray {\n \n+    // This is the internal storage array.  This array is assigned\n+    // a known fixed size in the constructor.\n     double[] internalArray;\n \n+    // Size determined the number of elements in the array at\n+    // any given time. When an array is created is maxElements\n+    // of 100, it is of size 0, and size increases as values are\n+    // added.\n     int size = 0;\n+\n+    // This index points to the location of the next update.  Next\n+    // add, cycles from 0 to (maxElement-1)\n     int nextAdd = 0;\n+\n+    // The maximum number of elements in the FixedDoubleArray\n     int maxElements = 0;\n \n+    /**\n+     * Create a fixed array for double primitives which can hold up to\n+     * <code>maxElements</codec> doubles.  This implementation of \n+     * DoubleArray was created to provide a more \"performance-oriented\"\n+     * in-place rolling mechanism for calculations which need to\n+     * operate on a rolling window of values.\n+     *\n+     * @param maxElements the maximum number of elements this \n+     *        FixeddoubleArray may contain.\n+     */\n     public FixedDoubleArray(int maxElements) {\n         this.maxElements = maxElements;\n         internalArray = new double[maxElements];\n     }\n \n-    /* (non-Javadoc)\n+    /**\n+     * Retrieves the current size of the array.\n      * @see org.apache.commons.math.DoubleArray#getNumElements()\n      */\n     public int getNumElements() {\n         return size;\n     }\n \n-    /* (non-Javadoc)\n+    /**\n+     * Returns the element value at the specified index.  Please note that\n+     * the size of the element array is not directly related to the \n+     * maximum number of elements which this array can contain.  One can\n+     * create an instance of FixedDoubleArray with a maximum of\n+     * ten elements, add three items, and get any items from index 0 to index\n+     * 2 - trying to retrieve an element outside of the current element\n+     * array will throw an ArrayIndexOutOfBoundsException.\n+     *\n      * @see org.apache.commons.math.DoubleArray#getElement(int)\n      */\n-    public double getElement(int index) throws NoSuchElementException {\n+    public double getElement(int index) {\n         if (index > (size-1)) {\n             String msg = \"Attempted to retrieve an element outside of \" +\n                 \"the element array\";\n             throw new ArrayIndexOutOfBoundsException(msg);\n         } else {\n+\t    // Return the element requested, if the index supplied\n+\t    // is negative this statement may also throw an\n+\t    // ArrayIndexOutOfBoundException.\n             return internalArray[index];\n         }\n     }\n \n-    /* (non-Javadoc)\n+    /**\n+     * <p>\n+     * Sets the element at the specified index to the value supplied.\n+     * </p>\n+     *\n+     * <p>Implementation Notes:\n+     * <ul>\n+     *  This implementation will not expand the array to the specified\n+     *  size.  Unlike the expandable double array implementation calling\n+     *  setElement(10, 3.0) on an array with 5 elements will throw an\n+     *  ArrayIndexOutOfBoundsException.\n+     * </ul>\n+     * <ul>\n+     *  The number of elements in an array corresponds to the number\n+     *  of elements that have been added to this FixedDoubleArray.  This\n+     *  is not the same as the maximum number of elements which can be\n+     *  contained in this array.  A FixedDoubleArray instance can be\n+     *  created with a maximum upper limit of 10 elements, until 10\n+     *  elements have been added to this array, the size of the array\n+     *  reflects the number of elements added.\n+     * </ul>\n+     * </p>\n+     *\n      * @see org.apache.commons.math.DoubleArray#setElement(int, double)\n      */\n     public void setElement(int index, double value) {\n         }\n     }\n \n-    /* (non-Javadoc)\n+    /** \n+     * Add an element to the current array, testing to see if \n+     * this array has already met or exceeded the maximum number\n+     * of elements\n+     *\n      * @see org.apache.commons.math.DoubleArray#addElement(double)\n      */\n     public void addElement(double value) {\n \n             internalArray[nextAdd] = value;\n \n+\t    // Incremenet nextAdd and then modulo it against maxElements\n+\t    // this has the effect of repeatedly \"cycling\" nextAdd\n+\t    // between 0 and (maxElements-1) endlessly.\n             nextAdd++;\n             nextAdd = nextAdd % (maxElements);\n \n         } else {\n+\t    // If the array has ALREADY reached the maximum size allowable,\n+\t    // we throw an ArrayIndexOutOfBoundsException - the end-user\n+\t    // is trying to add an element beyond the boundaries of the\n+\t    // fixed array.\n             String msg = \"Attempted to add a value to an array of fixed \" +\n                 \"size, please use addElementRolling to avoid this exception\";\n             throw new ArrayIndexOutOfBoundsException(msg);\n-\t\t}\n-    }\n-\n-    /* (non-Javadoc)\n+\t}\n+    }\n+\n+    /**\n+     * <p>\n+     * Adds an element by \"rolling\" the new value into the current array \n+     * while discarding the element which was added <code>maxElement</code>\n+     * add operations ago.  The value replaced is returned from this \n+     * method.  Until an array contains the maximum number of element, this\n+     * method has the same result as the addElement(double) operation.  Once\n+     * the maximum number of elements has been reached this implementation\n+     * inserts the new values starting at index 0 of the internal storage \n+     * array.  This allows for efficient rolling, but prevents us from \n+     * preserving the order of the added values.\n+     * </p>\n+     *\n+     * <p>\n+     * <b>Note:</b> This function will return <code>Double.NaN</code> if\n+     * no value has been discarded in this roll.  This can happen when\n+     * the array has not met the size limitation introduced in the \n+     * constructor.\n+     * </p>\n+     *\n+     * @return Returns the value which a has been \"removed\" from the \n+     *         database.  <b>Important:</b> If the element array has\n+     *         not reached the maximum size, then it is possible that\n+     *         no element will be discarded from a given roll.  In this\n+     *         case this method will return a <code>Double.NaN</code> value.\n+     *\n      * @see org.apache.commons.math.DoubleArray#addElementRolling(double)\n      */\n     public double addElementRolling(double value) {\n+\n+\t// Create the discarded primitive.  If no element is\n+\t// discarded by this roll, this method will return a\n+\t// Double.NaN value.\n+\tdouble discarded = Double.NaN;\n+\n         if (size < internalArray.length) {\n             size++;\n-        } \n-\n-        double discarded = internalArray[nextAdd];\n+        } else {\n+\t    // If we've reached the length of the internal\n+\t    // storage array, we have to start \"discarding\"\n+\t    // values from the original array.\n+\n+\t    // Obtain the value discarded by this overwrite\n+\t    discarded = internalArray[nextAdd];\n+\t}\n \n         internalArray[nextAdd] = value;\n \n+\t// nextAdd cycles between 0 and (maxElements-1).\n         nextAdd++;\n         nextAdd = nextAdd % maxElements;\t\n \n         return (discarded);\t\t\n     }\n \n-    /* (non-Javadoc)\n+    /**\n+     * Provides an array of double[] which contain the\n+     * number of elements added to this array.  This  \n+     * method will return an array from zero to maxElements in length.\n+     * \n+     * @return The array of elements added to this DoubleArray\n+     *         implementation.\n      * @see org.apache.commons.math.DoubleArray#getElements()\n      */\n     public double[] getElements() {\n-        double[] copy = new double[internalArray.length];\n-        System.arraycopy(internalArray, 0, copy, 0, internalArray.length);\n+        double[] copy = new double[size];\n+        System.arraycopy(internalArray, 0, copy, 0, size);\n         return copy;\n     }\n \n-    /* (non-Javadoc)\n+    /**\n+     * Clear the array - drop all the data and start with a blank\n+     * internal array.  This implementation takes care of\n+     * setting the size of the array back to zero, and reinitializing\n+     * the internal storage array.\n+     *\n      * @see org.apache.commons.math.DoubleArray#clear()\n      */\n     public void clear() {\n         internalArray = new double[maxElements];\n     }\n \n-    /* (non-Javadoc)\n+    /**\n+     * This method is not implemented in this implemetnation of\n+     * DoubleArray.  Until the size of the element array meets the\n+     * maxElements condition introduced in the constructor this is\n+     * a regular array.  When the size of the array is at a maximum\n+     * this array starts to function more as a circular list of \n+     * double primitives.  In a circular \"rolling\" data structure it\n+     * make little sense to allow people to \"drop\" objects from the\n+     * \"front\". \n+     *\n+     * @param number of elements to discard.\n+     *\n      * @see org.apache.commons.math.DoubleArray#discardFrontElements(int)\n      */\n     public void discardFrontElements(int i) {\n         throw new RuntimeException(msg);\n     }\n \n-    /* (non-Javadoc)\n+    /**\n+     * Retrieves the minimum double value contained in this array.\n+     *\n+     * @return The number less than all other numbers in this \n+     *         array.\n      * @see org.apache.commons.math.DoubleArray#getMin()\n      */\n     public double getMin() {\n         return min;\n     }\n \n-    /* (non-Javadoc)\n+    /**\n+     * Retrieves the maximum double value contained in this array.\n+     * \n+     * @return The number greater than all other numbers in this\n+     *         array.\n      * @see org.apache.commons.math.DoubleArray#getMax()\n      */\n     public double getMax() {", "timestamp": 1053496105, "metainfo": ""}