{"sha": "bee3b2bf43e36a9b07296b02b045842f43b8ff4a", "log": "Initial Commit of BigMatrix classes. PR #28819 Submitted by Matthew Inger   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/BigMatrix.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * Interface defining a real-valued matrix with basic algebraic operations, using\n+ * BigDecimal representations for the entries.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/06/06 04:20:45 $\n+ */\n+public interface BigMatrix {\n+\n+    /**\n+     * Returns a (deep) copy of this.\n+     *\n+     * @return matrix copy\n+     */\n+    BigMatrix copy();\n+    \n+    /**\n+     * Compute the sum of this and m.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @exception  IllegalArgumentException if m is not the same size as this\n+     */\n+    BigMatrix add(BigMatrix m) throws IllegalArgumentException;\n+    \n+    /**\n+     * Compute this minus m.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @exception  IllegalArgumentException if m is not the same size as this\n+     */\n+    BigMatrix subtract(BigMatrix m) throws IllegalArgumentException;\n+    \n+     /**\n+     * Returns the result of adding d to each entry of this.\n+     *\n+     * @param d    value to be added to each entry\n+     * @return     d + this\n+     */\n+    BigMatrix scalarAdd(BigDecimal d);\n+    \n+    /**\n+     * Returns the result multiplying each entry of this by d.\n+     *\n+     * @param d    value to multiply all entries by\n+     * @return     d * this\n+     */\n+    BigMatrix scalarMultiply(BigDecimal d);\n+    \n+    /**\n+     * Returns the result postmultiplying this by m.\n+     *\n+     * @param m    matrix to postmultiply by\n+     * @return     this * m\n+     * @throws     IllegalArgumentException \n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    BigMatrix multiply(BigMatrix m) throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns the result premultiplying this by <code>m</code>.\n+     * @param m    matrix to premultiply by\n+     * @return     m * this\n+     * @throws     IllegalArgumentException\n+     *             if rowDimension(this) != columnDimension(m)\n+     */\n+    public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns matrix entries as a two-dimensional array.\n+     *\n+     * @return    2-dimensional array of entries\n+     */\n+    BigDecimal[][] getData();\n+\n+    /**\n+     * Returns matrix entries as a two-dimensional array.\n+     *\n+     * @return    2-dimensional array of entries\n+     */\n+    double [][] getDataAsDoubleArray();\n+\n+    /**\n+     * Overwrites the underlying data for the matrix with\n+     * a fresh copy of <code>data</code>.\n+     *\n+     * @param  data  2-dimensional array of entries\n+     */\n+    void setData(BigDecimal[][] data);\n+\n+    /**\n+     * Overwrites the underlying data for the matrix with\n+     * a fresh copy of <code>data</code>.\n+     *\n+     * @param  data  2-dimensional array of entries\n+     */\n+    void setData(double[][] data);\n+\n+    /***\n+     * Sets the rounding mode to use when dividing values\n+     * @see java.math.BigDecimal\n+     * @param roundingMode\n+     */\n+    void setRoundingMode(int roundingMode);\n+\n+    /***\n+     * Gets the rounding mode\n+     * @return\n+     */\n+    int getRoundingMode();\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/MaximumAbsoluteRowSumNorm.html\">\n+     * maximum absolute row sum norm</a> of the matrix.\n+     *\n+     * @return norm\n+     */\n+    BigDecimal getNorm();\n+    \n+    /**\n+     * Returns the entries in row number <code>row</code> as an array.\n+     *\n+     * @param row the row to be fetched\n+     * @return array of entries in the row\n+     * @throws org.apache.commons.math.linear.MatrixIndexException if the specified row is greater\n+     *                              than the number of rows in this matrix\n+     */\n+    BigDecimal[] getRow(int row) throws MatrixIndexException;\n+\n+    /**\n+     * Returns the entries in row number <code>row</code> as an array\n+     * of double values.\n+     *\n+     * @param row the row to be fetched\n+     * @return array of entries in the row\n+     * @throws org.apache.commons.math.linear.MatrixIndexException if the specified row is greater\n+     *                              than the number of rows in this matrix\n+     */\n+    double [] getRowAsDoubleArray(int row) throws MatrixIndexException;\n+\n+    /**\n+     * Returns the entries in column number <code>col</code> as an array.\n+     *\n+     * @param col  column to fetch\n+     * @return array of entries in the column\n+     * @throws org.apache.commons.math.linear.MatrixIndexException if the specified column is greater\n+     *                              than the number of columns in this matrix\n+     */\n+    BigDecimal[] getColumn(int col) throws MatrixIndexException;\n+\n+    /**\n+     * Returns the entries in column number <code>col</code> as an array\n+     * of double values.\n+     *\n+     * @param col  column to fetch\n+     * @return array of entries in the column\n+     * @throws org.apache.commons.math.linear.MatrixIndexException if the specified column is greater\n+     *                              than the number of columns in this matrix\n+     */\n+    double [] getColumnAsDoubleArray(int col) throws MatrixIndexException;\n+\n+    /**\n+     * Returns the entry in the specified row and column.\n+     *\n+     * @param row  row location of entry to be fetched  \n+     * @param column  column location of entry to be fetched\n+     * @return matrix entry in row,column\n+     * @throws org.apache.commons.math.linear.MatrixIndexException if the specified coordinate is outside\n+     *                              the dimensions of this matrix\n+     */\n+    BigDecimal getEntry(int row, int column) throws MatrixIndexException;\n+    \n+    /**\n+     * Returns the entry in the specified row and column as a double\n+     *\n+     * @param row  row location of entry to be fetched\n+     * @param column  column location of entry to be fetched\n+     * @return matrix entry in row,column\n+     * @throws org.apache.commons.math.linear.MatrixIndexException if the specified coordinate is outside\n+     *                              the dimensions of this matrix\n+     */\n+    double getEntryAsDouble(int row, int column) throws MatrixIndexException;\n+\n+    /**\n+     * Sets the entry in the specified row and column to the specified value.\n+     *\n+     * @param row    row location of entry to be set \n+     * @param column    column location of entry to be set\n+     * @param value  value to set \n+     * @throws org.apache.commons.math.linear.MatrixIndexException if the specified coordinate is outside\n+     *                              he dimensions of this matrix\n+     */\n+    void setEntry(int row, int column, BigDecimal value)\n+        throws MatrixIndexException;\n+    \n+    /**\n+     * Sets the entry in the specified row and column to the specified value.\n+     *\n+     * @param row    row location of entry to be set\n+     * @param column    column location of entry to be set\n+     * @param value  value to set\n+     * @throws org.apache.commons.math.linear.MatrixIndexException if the specified coordinate is outside\n+     *                              he dimensions of this matrix\n+     */\n+    void setEntry(int row, int column, double value)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Returns the transpose of this matrix.\n+     *\n+     * @return transpose matrix\n+     */\n+    BigMatrix transpose();\n+    \n+    /**\n+     * Returns the inverse of this matrix.\n+     *\n+     * @return inverse matrix\n+     * @throws org.apache.commons.math.linear.InvalidMatrixException if  this is not invertible\n+     */\n+    BigMatrix inverse() throws InvalidMatrixException;\n+    \n+    /**\n+     * Returns the determinant of this matrix.\n+     *\n+     * @return determinant\n+      *@throws InvalidMatrixException if matrix is not square\n+     */\n+    BigDecimal getDeterminant();\n+    \n+    /**\n+     * Is this a square matrix?\n+     * @return true if the matrix is square (rowDimension = columnDimension)\n+     */\n+    boolean isSquare();\n+    \n+    /**\n+     * Is this a singular matrix?\n+     * @return true if the matrix is singular\n+     */\n+    boolean isSingular();\n+    \n+    /**\n+     * Returns the number of rows in the matrix.\n+     *\n+     * @return rowDimension\n+     */\n+    int getRowDimension();\n+    \n+    /**\n+     * Returns the number of columns in the matrix.\n+     *\n+     * @return columnDimension\n+     */\n+    int getColumnDimension();\n+    \n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/MatrixTrace.html\">\n+     * trace</a> of the matrix (the sum of the elements on the main diagonal).\n+     *\n+     * @return trace\n+     */\n+    BigDecimal getTrace();\n+    \n+    /**\n+     * Returns the result of multiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the vector to operate on\n+     * @return this*v\n+     * @throws IllegalArgumentException if columnDimension != v.size()\n+     */\n+    BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException;\n+\n+    /**\n+     * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the row vector to premultiply by\n+     * @return v*this\n+     * @throws IllegalArgumentException if rowDimension != v.size()\n+     */\n+    BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException;\n+    \n+    /**\n+     * Returns the solution vector for a linear system with coefficient\n+     * matrix = this and constant vector = <code>b</code>.\n+     *\n+     * @param b  constant vector\n+     * @return vector of solution values to AX = b, where A is *this\n+     * @throws IllegalArgumentException if this.rowDimension != b.length \n+     * @throws org.apache.commons.math.linear.InvalidMatrixException if this matrix is not square or is singular\n+     */\n+    BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException;\n+\n+    /**\n+     * Returns a matrix of (column) solution vectors for linear systems with\n+     * coefficient matrix = this and constant vectors = columns of\n+     * <code>b</code>. \n+     *\n+     * @param b  matrix of constant vectors forming RHS of linear systems to\n+     * to solve\n+     * @return matrix of solution vectors\n+     * @throws IllegalArgumentException if this.rowDimension != row dimension\n+     * @throws org.apache.commons.math.linear.InvalidMatrixException if this matrix is not square or is singular\n+     */\n+    BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException;\n+}\n+\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+import java.io.Serializable;\n+import java.math.BigDecimal;\n+\n+/**\n+ * Implementation for {@link BigMatrix} using a BigDecimal[][] array to store entries\n+ * and <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n+ * LU decompostion</a> to support linear system \n+ * solution and inverse.\n+ * <p>\n+ * The LU decompostion is performed as needed, to support the following operations: <ul>\n+ * <li>solve</li>\n+ * <li>isSingular</li>\n+ * <li>getDeterminant</li>\n+ * <li>inverse</li> </ul>\n+ * <p>\n+ * <strong>Usage note</strong>:<br>\n+ * The LU decomposition is stored and reused on subsequent calls.  If matrix\n+ * data are modified using any of the public setXxx methods, the saved \n+ * decomposition is discarded.  If data are modified via references to the\n+ * underlying array obtained using <code>getDataRef()</code>, then the stored\n+ * LU decomposition will not be discarded.  In this case, you need to \n+ * explicitly invoke <code>LUDecompose()</code> to recompute the decomposition\n+ * before using any of the methods above.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/06/06 04:20:45 $\n+ */\n+public class BigMatrixImpl implements BigMatrix, Serializable {\n+    \n+    /** Serialization id */\n+    static final long serialVersionUID = -1011428905656140431L;\n+    \n+    private static final BigDecimal ZERO = new BigDecimal(0);\n+    private static final BigDecimal ONE = new BigDecimal(1);\n+    \n+    /** Entries of the matrix */\n+    private BigDecimal data[][] = null;\n+    \n+    /** Entries of cached LU decomposition.\n+     *  All updates to data (other than luDecompose()) *must* set this to null\n+     */\n+    private BigDecimal lu[][] = null;\n+    \n+    /** Permutation associated with LU decompostion */\n+    private int[] permutation = null;\n+    \n+    /** Parity of the permutation associated with the LU decomposition */\n+    private int parity = 1;\n+    \n+    /** Rounding mode for divisions **/\n+    private int roundingMode = BigDecimal.ROUND_HALF_UP;\n+    \n+    /*** BigDecimal scale ***/\n+    private int scale = 64;\n+    \n+    /** Bound to determine effective singularity in LU decomposition */\n+    protected static BigDecimal TOO_SMALL = new BigDecimal(10E-12);\n+    \n+    /** \n+     * Creates a matrix with no data\n+     */\n+    public BigMatrixImpl() {\n+    }\n+    \n+    /**\n+     * Create a new BigMatrix with the supplied row and column dimensions.\n+     *\n+     * @param rowDimension      the number of rows in the new matrix\n+     * @param columnDimension   the number of columns in the new matrix\n+     */\n+    public BigMatrixImpl(int rowDimension, int columnDimension) {\n+        data = new BigDecimal[rowDimension][columnDimension];\n+        lu = null;\n+    }\n+    \n+    /**\n+     * Create a new BigMatrix using the <code>data</code> as the underlying\n+     * data array.\n+     * <p>\n+     * The input array is copied, not referenced.\n+     *\n+     * @param d data for new matrix\n+     */\n+    public BigMatrixImpl(BigDecimal[][] d) {\n+        this.copyIn(d);\n+        lu = null;\n+    }\n+    \n+    /**\n+     * Create a new BigMatrix using the <code>data</code> as the underlying\n+     * data array.\n+     * <p>\n+     * The input array is copied, not referenced.\n+     *\n+     * @param d data for new matrix\n+     */\n+    public BigMatrixImpl(double[][] d) {\n+        this.copyIn(d);\n+        lu = null;\n+    }\n+    \n+    /**\n+     * Create a new (column) BigMatrix using <code>v</code> as the\n+     * data for the unique column of the <code>v.length x 1</code> matrix \n+     * created.\n+     * <p>\n+     * The input array is copied, not referenced.\n+     *\n+     * @param v column vector holding data for new matrix\n+     */\n+    public BigMatrixImpl(BigDecimal[] v) {\n+        int nRows = v.length;\n+        data = new BigDecimal[nRows][1];\n+        for (int row = 0; row < nRows; row++) {\n+            data[row][0] = v[row];\n+        }\n+    }\n+    \n+    /**\n+     * Create a new BigMatrix which is a copy of this.\n+     *\n+     * @return  the cloned matrix\n+     */\n+    public BigMatrix copy() {\n+        return new BigMatrixImpl(this.copyOut());\n+    }\n+    \n+    /**\n+     * Compute the sum of this and <code>m</code>.\n+     *\n+     * @param m    matrix to be added\n+     * @return     this + m\n+     * @exception  IllegalArgumentException if m is not the same size as this\n+     */\n+    public BigMatrix add(BigMatrix m) throws IllegalArgumentException {\n+        if (this.getColumnDimension() != m.getColumnDimension() ||\n+                this.getRowDimension() != m.getRowDimension()) {\n+            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n+        }\n+        int rowCount = this.getRowDimension();\n+        int columnCount = this.getColumnDimension();\n+        BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+        BigDecimal[][] mData = m.getData();\n+        for (int row = 0; row < rowCount; row++) {\n+            for (int col = 0; col < columnCount; col++) {\n+                outData[row][col] = data[row][col].add(mData[row][col]);\n+            }\n+        }\n+        return new BigMatrixImpl(outData);\n+    }\n+    \n+    /**\n+     * Compute  this minus <code>m</code>.\n+     *\n+     * @param m    matrix to be subtracted\n+     * @return     this + m\n+     * @exception  IllegalArgumentException if m is not the same size as *this\n+     */\n+    public BigMatrix subtract(BigMatrix m) throws IllegalArgumentException {\n+        if (this.getColumnDimension() != m.getColumnDimension() ||\n+                this.getRowDimension() != m.getRowDimension()) {\n+            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n+        }\n+        int rowCount = this.getRowDimension();\n+        int columnCount = this.getColumnDimension();\n+        BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+        BigDecimal[][] mData = m.getData();\n+        for (int row = 0; row < rowCount; row++) {\n+            for (int col = 0; col < columnCount; col++) {\n+                outData[row][col] = data[row][col].subtract(mData[row][col]);\n+            }\n+        }\n+        return new BigMatrixImpl(outData);\n+    }\n+    \n+    /**\n+     * Returns the result of adding d to each entry of this.\n+     *\n+     * @param d    value to be added to each entry\n+     * @return     d + this\n+     */\n+    public BigMatrix scalarAdd(BigDecimal d) {\n+        int rowCount = this.getRowDimension();\n+        int columnCount = this.getColumnDimension();\n+        BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+        for (int row = 0; row < rowCount; row++) {\n+            for (int col = 0; col < columnCount; col++) {\n+                outData[row][col] = data[row][col].add(d);\n+            }\n+        }\n+        return new BigMatrixImpl(outData);\n+    }\n+    \n+    /**\n+     * Returns the result multiplying each entry of this by <code>d</code>\n+     * @param d  value to multiply all entries by\n+     * @return d * this\n+     */\n+    public BigMatrix scalarMultiply(BigDecimal d) {\n+        int rowCount = this.getRowDimension();\n+        int columnCount = this.getColumnDimension();\n+        BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n+        for (int row = 0; row < rowCount; row++) {\n+            for (int col = 0; col < columnCount; col++) {\n+                outData[row][col] = data[row][col].multiply(d);\n+            }\n+        }\n+        return new BigMatrixImpl(outData);\n+    }\n+    \n+    /**\n+     * Returns the result postmultiplying this by <code>m</code>.\n+     * @param m    matrix to postmultiply by\n+     * @return     this*m\n+     * @throws     IllegalArgumentException\n+     *             if columnDimension(this) != rowDimension(m)\n+     */\n+    public BigMatrix multiply(BigMatrix m) throws IllegalArgumentException {\n+        if (this.getColumnDimension() != m.getRowDimension()) {\n+            throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n+        }\n+        int nRows = this.getRowDimension();\n+        int nCols = m.getColumnDimension();\n+        int nSum = this.getColumnDimension();\n+        BigDecimal[][] mData = m.getData();\n+        BigDecimal[][] outData = new BigDecimal[nRows][nCols];\n+        BigDecimal sum = ZERO;\n+        for (int row = 0; row < nRows; row++) {\n+            for (int col = 0; col < nCols; col++) {\n+                sum = ZERO;\n+                for (int i = 0; i < nSum; i++) {\n+                    sum = sum.add(data[row][i].multiply(mData[i][col]));\n+                }\n+                outData[row][col] = sum;\n+            }\n+        }\n+        return new BigMatrixImpl(outData);\n+    }\n+    \n+    /**\n+     * Returns the result premultiplying this by <code>m</code>.\n+     * @param m    matrix to premultiply by\n+     * @return     m * this\n+     * @throws     IllegalArgumentException\n+     *             if rowDimension(this) != columnDimension(m)\n+     */\n+    public BigMatrix preMultiply(BigMatrix m) throws IllegalArgumentException {\n+        return m.multiply(this);\n+    }\n+    \n+    /**\n+     * Returns matrix entries as a two-dimensional array.\n+     * <p>\n+     * Makes a fresh copy of the underlying data.\n+     *\n+     * @return    2-dimensional array of entries\n+     */\n+    public BigDecimal[][] getData() {\n+        return copyOut();\n+    }\n+    \n+    public double[][] getDataAsDoubleArray() {\n+        int nRows = getRowDimension();\n+        int nCols = getColumnDimension();\n+        double d[][] = new double[nRows][nCols];\n+        for (int i = 0; i < nRows; i++) {\n+            for (int j=0; j<nCols;j++) {\n+                d[i][j] = data[i][j].doubleValue();\n+            }\n+        }\n+        return d;\n+    }\n+    \n+    /**\n+     * Overwrites the underlying data for the matrix\n+     * with a fresh copy of <code>inData</code>.\n+     *\n+     * @param  inData 2-dimensional array of entries\n+     */\n+    public void setData(BigDecimal[][] inData) {\n+        copyIn(inData);\n+        lu = null;\n+    }\n+    \n+    public void setData(double[][] inData) {\n+        copyIn(inData);\n+        lu = null;\n+    }\n+    \n+    /**\n+     * Returns a reference to the underlying data array.\n+     * <p>\n+     * Does not make a fresh copy of the underlying data.\n+     *\n+     * @return 2-dimensional array of entries\n+     */\n+    public BigDecimal[][] getDataRef() {\n+        return data;\n+    }\n+    \n+    /**\n+     * Overwrites the underlying data for the matrix\n+     * with a reference to <code>inData</code>.\n+     * <p>\n+     * Does not make a fresh copy of <code>data</code>.\n+     *\n+     * @param  inData 2-dimensional array of entries\n+     */\n+    public void setDataRef(BigDecimal[][] inData) {\n+        this.data = inData;\n+        lu = null;\n+    }\n+    \n+    /***\n+     * Gets the rounding mode for division operations\n+     * The default is {@link BigDecimal.ROUND_HALF_UP}\n+     * @see BigDecimal\n+     * @return\n+     */ \n+    public int getRoundingMode() {\n+        return roundingMode;\n+    }\n+    \n+    /***\n+     * Sets the rounding mode for decimal divisions.\n+     * @see BigDecimal\n+     * @param roundingMode\n+     */\n+    public void setRoundingMode(int roundingMode) {\n+        this.roundingMode = roundingMode;\n+    }\n+    \n+    /***\n+     * Sets the scale for division operations.\n+     * The default is 64\n+     * @see BigDecimal\n+     * @return\n+     */\n+    public int getScale() {\n+        return scale;\n+    }\n+    \n+    /***\n+     * Sets the scale for division operations.\n+     * @see BigDecimal\n+     * @param scale\n+     */\n+    public void setScale(int scale) {\n+        this.scale = scale;\n+    }\n+    \n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/MaximumAbsoluteRowSumNorm.html\">\n+     * maximum absolute row sum norm</a> of the matrix.\n+     *\n+     * @return norm\n+     */\n+    public BigDecimal getNorm() {\n+        BigDecimal maxColSum = ZERO;\n+        for (int col = 0; col < this.getColumnDimension(); col++) {\n+            BigDecimal sum = ZERO;\n+            for (int row = 0; row < this.getRowDimension(); row++) {\n+                sum = sum.add(data[row][col].abs());\n+            }\n+            maxColSum = maxColSum.max(sum);\n+        }\n+        return maxColSum;\n+    }\n+    \n+    /**\n+     * Returns the entries in row number <code>row</code> as an array.\n+     *\n+     * @param row the row to be fetched\n+     * @return array of entries in the row\n+     * @throws MatrixIndexException if the specified row is greater \n+     *                              than the number of rows in this matrix\n+     */\n+    public BigDecimal[] getRow(int row) throws MatrixIndexException {\n+        if ( !isValidCoordinate( row, 1 ) ) {\n+            throw new MatrixIndexException(\"illegal row argument\");\n+        }\n+        int ncols = this.getColumnDimension();\n+        BigDecimal[] out = new BigDecimal[ncols];\n+        System.arraycopy(data[row - 1], 0, out, 0, ncols);\n+        return out;\n+    }\n+    \n+    /**\n+     * Returns the entries in row number <code>row</code> as an array\n+     * of double values.\n+     *\n+     * @param row the row to be fetched\n+     * @return array of entries in the row\n+     * @throws org.apache.commons.math.linear.MatrixIndexException if the specified row is greater\n+     *                              than the number of rows in this matrix\n+     */\n+    public double[] getRowAsDoubleArray(int row) throws MatrixIndexException {\n+        if ( !isValidCoordinate( row, 1 ) ) {\n+            throw new MatrixIndexException(\"illegal row argument\");\n+        }\n+        int ncols = this.getColumnDimension();\n+        double[] out = new double[ncols];\n+        for (int i=0;i<ncols;i++) {\n+            out[i] = data[row-1][i].doubleValue();\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     * Returns the entries in column number <code>col</code> as an array.\n+     *\n+     * @param col  column to fetch\n+     * @return array of entries in the column\n+     * @throws MatrixIndexException if the specified column is greater\n+     *                              than the number of columns in this matrix\n+     */\n+    public BigDecimal[] getColumn(int col) throws MatrixIndexException {\n+        if ( !isValidCoordinate(1, col) ) {\n+            throw new MatrixIndexException(\"illegal column argument\");\n+        }\n+        int nRows = this.getRowDimension();\n+        BigDecimal[] out = new BigDecimal[nRows];\n+        for (int i = 0; i < nRows; i++) {\n+            out[i] = data[i][col - 1];\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     * Returns the entries in column number <code>col</code> as an array\n+     * of double values.\n+     *\n+     * @param col  column to fetch\n+     * @return array of entries in the column\n+     * @throws org.apache.commons.math.linear.MatrixIndexException if the specified column is greater\n+     *                              than the number of columns in this matrix\n+     */\n+    public double[] getColumnAsDoubleArray(int col) throws MatrixIndexException {\n+        if ( !isValidCoordinate( 1, col ) ) {\n+            throw new MatrixIndexException(\"illegal column argument\");\n+        }\n+        int nrows = this.getRowDimension();\n+        double[] out = new double[nrows];\n+        for (int i=0;i<nrows;i++) {\n+            out[i] = data[i][col-1].doubleValue();\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     * Returns the entry in the specified row and column.\n+     *\n+     * @param row  row location of entry to be fetched  \n+     * @param column  column location of entry to be fetched\n+     * @return matrix entry in row,column\n+     * @throws MatrixIndexException if the specified coordinate is outside \n+     *                              the dimensions of this matrix\n+     */\n+    public BigDecimal getEntry(int row, int column)\n+    throws MatrixIndexException {\n+        if (!isValidCoordinate(row,column)) {\n+            throw new MatrixIndexException(\"matrix entry does not exist\");\n+        }\n+        return data[row - 1][column - 1];\n+    }\n+    \n+    /**\n+     * Returns the entry in the specified row and column as a double\n+     *\n+     * @param row  row location of entry to be fetched\n+     * @param column  column location of entry to be fetched\n+     * @return matrix entry in row,column\n+     * @throws org.apache.commons.math.linear.MatrixIndexException if the specified coordinate is outside\n+     *                              the dimensions of this matrix\n+     */\n+    public double getEntryAsDouble(int row, int column) throws MatrixIndexException {\n+        return getEntry(row,column).doubleValue();\n+    }\n+    \n+    /**\n+     * Sets the entry in the specified row and column to the specified value.\n+     *\n+     * @param row    row location of entry to be set \n+     * @param column    column location of entry to be set\n+     * @param value  value to set \n+     * @throws MatrixIndexException if the specified coordinate is outside\n+     *                              he dimensions of this matrix\n+     */\n+    public void setEntry(int row, int column, BigDecimal value)\n+    throws MatrixIndexException {\n+        if (!isValidCoordinate(row,column)) {\n+            throw new MatrixIndexException(\"matrix entry does not exist\");\n+        }\n+        data[row - 1][column - 1] = value;\n+        lu = null;\n+    }\n+    \n+    /**\n+     * Sets the entry in the specified row and column to the specified value.\n+     *\n+     * @param row    row location of entry to be set\n+     * @param column    column location of entry to be set\n+     * @param value  value to set\n+     * @throws org.apache.commons.math.linear.MatrixIndexException if the specified coordinate is outside\n+     *                              he dimensions of this matrix\n+     */\n+    public void setEntry(int row, int column, double value) throws MatrixIndexException {\n+        setEntry(row, column, new BigDecimal(value));\n+    }\n+    \n+    /**\n+     * Returns the transpose matrix.\n+     *\n+     * @return transpose matrix\n+     */\n+    public BigMatrix transpose() {\n+        int nRows = this.getRowDimension();\n+        int nCols = this.getColumnDimension();\n+        BigMatrixImpl out = new BigMatrixImpl(nCols, nRows);\n+        BigDecimal[][] outData = out.getDataRef();\n+        for (int row = 0; row < nRows; row++) {\n+            for (int col = 0; col < nCols; col++) {\n+                outData[col][row] = data[row][col];\n+            }\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     * Returns the inverse matrix if this matrix is invertible.\n+     * \n+     * @return inverse matrix\n+     * @throws InvalidMatrixException if this is not invertible\n+     */\n+    public BigMatrix inverse() throws InvalidMatrixException {\n+        return solve(getIdentity(this.getRowDimension()));\n+    }\n+    \n+    /**\n+     * Returns the determinant of this matrix.\n+     *\n+     * @return determinant\n+     * @throws InvalidMatrixException if matrix is not square\n+     */\n+    public BigDecimal getDeterminant() throws InvalidMatrixException {\n+        if (!isSquare()) {\n+            throw new InvalidMatrixException(\"matrix is not square\");\n+        }\n+        if (isSingular()) {   // note: this has side effect of attempting LU decomp if lu == null\n+            return ZERO;\n+        } else {\n+            BigDecimal det = (parity == 1) ? ONE : ONE.negate();\n+            for (int i = 0; i < this.getRowDimension(); i++) {\n+                det = det.multiply(lu[i][i]);\n+            }\n+            return det;\n+        }\n+    }\n+    \n+     /**\n+     * Is this a square matrix?\n+     * @return true if the matrix is square (rowDimension = columnDimension)\n+     */\n+    public boolean isSquare() {\n+        return (this.getColumnDimension() == this.getRowDimension());\n+    }\n+    \n+    /**\n+     * Is this a singular matrix?\n+     * @return true if the matrix is singular\n+     */\n+    public boolean isSingular() {\n+        if (lu == null) {\n+            try {\n+                luDecompose();\n+                return false;\n+            } catch (InvalidMatrixException ex) {\n+                return true;\n+            }\n+        } else { // LU decomp must have been successfully performed\n+            return false; // so the matrix is not singular\n+        }\n+    }\n+    \n+    /**\n+     * Returns the number of rows in the matrix.\n+     *\n+     * @return rowDimension\n+     */\n+    public int getRowDimension() {\n+        return data.length;\n+    }\n+    \n+    /**\n+     * Returns the number of columns in the matrix.\n+     *\n+     * @return columnDimension\n+     */\n+    public int getColumnDimension() {\n+        return data[0].length;\n+    }\n+    \n+     /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/MatrixTrace.html\">\n+     * trace</a> of the matrix (the sum of the elements on the main diagonal).\n+     *\n+     * @return trace\n+     */\n+    public BigDecimal getTrace() throws IllegalArgumentException {\n+        if (!isSquare()) {\n+            throw new IllegalArgumentException(\"matrix is not square\");\n+        }\n+        BigDecimal trace = data[0][0];\n+        for (int i = 1; i < this.getRowDimension(); i++) {\n+            trace = trace.add(data[i][i]);\n+        }\n+        return trace;\n+    }\n+    \n+    /**\n+     * Returns the result of multiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the vector to operate on\n+     * @return this*v\n+     * @throws IllegalArgumentException if columnDimension != v.size()\n+     */\n+    public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n+        if (v.length != this.getColumnDimension()) {\n+            throw new IllegalArgumentException(\"vector has wrong length\");\n+        }\n+        int nRows = this.getRowDimension();\n+        int nCols = this.getColumnDimension();\n+        BigDecimal[] out = new BigDecimal[v.length];\n+        for (int row = 0; row < nRows; row++) {\n+            BigDecimal sum = ZERO;\n+            for (int i = 0; i < nCols; i++) {\n+                sum = sum.add(data[row][i].multiply(v[i]));\n+            }\n+            out[row] = sum;\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     * Returns the result of multiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the vector to operate on\n+     * @return this*v\n+     * @throws IllegalArgumentException if columnDimension != v.size()\n+     */\n+    public BigDecimal[] operate(double[] v) throws IllegalArgumentException {\n+        BigDecimal bd[] = new BigDecimal[v.length];\n+        for (int i=0;i<bd.length;i++) {\n+            bd[i] = new BigDecimal(v[i]);\n+        }\n+        return operate(bd);\n+    }\n+    \n+    /**\n+     * Returns the (row) vector result of premultiplying this by the vector <code>v</code>.\n+     *\n+     * @param v the row vector to premultiply by\n+     * @return v*this\n+     * @throws IllegalArgumentException if rowDimension != v.size()\n+     */\n+    public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n+        int nRows = this.getRowDimension();\n+        if (v.length != nRows) {\n+            throw new IllegalArgumentException(\"vector has wrong length\");\n+        }\n+        int nCols = this.getColumnDimension();\n+        BigDecimal[] out = new BigDecimal[nCols];\n+        for (int col = 0; col < nCols; col++) {\n+            BigDecimal sum = ZERO;\n+            for (int i = 0; i < nRows; i++) {\n+                sum = sum.add(data[i][col].multiply(v[i]));\n+            }\n+            out[col] = sum;\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     * Returns a matrix of (column) solution vectors for linear systems with\n+     * coefficient matrix = this and constant vectors = columns of\n+     * <code>b</code>. \n+     *\n+     * @param b  array of constants forming RHS of linear systems to\n+     * to solve\n+     * @return solution array\n+     * @throws IllegalArgumentException if this.rowDimension != row dimension\n+     * @throws InvalidMatrixException if this matrix is not square or is singular\n+     */\n+    public BigDecimal[] solve(BigDecimal[] b) throws IllegalArgumentException, InvalidMatrixException {\n+        int nRows = this.getRowDimension();\n+        if (b.length != nRows) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+        BigMatrix bMatrix = new BigMatrixImpl(b);\n+        BigDecimal[][] solution = ((BigMatrixImpl) (solve(bMatrix))).getDataRef();\n+        BigDecimal[] out = new BigDecimal[nRows];\n+        for (int row = 0; row < nRows; row++) {\n+            out[row] = solution[row][0];\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     * Returns a matrix of (column) solution vectors for linear systems with\n+     * coefficient matrix = this and constant vectors = columns of\n+     * <code>b</code>. \n+     *\n+     * @param b  array of constants forming RHS of linear systems to\n+     * to solve\n+     * @return solution array\n+     * @throws IllegalArgumentException if this.rowDimension != row dimension\n+     * @throws InvalidMatrixException if this matrix is not square or is singular\n+     */\n+    public BigDecimal[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n+        BigDecimal bd[] = new BigDecimal[b.length];\n+        for (int i=0;i<bd.length;i++) {\n+            bd[i] = new BigDecimal(b[i]);\n+        }\n+        return solve(bd);\n+    }\n+    \n+    /**\n+     * Returns a matrix of (column) solution vectors for linear systems with\n+     * coefficient matrix = this and constant vectors = columns of\n+     * <code>b</code>. \n+     *\n+     * @param b  matrix of constant vectors forming RHS of linear systems to\n+     * to solve\n+     * @return matrix of solution vectors\n+     * @throws IllegalArgumentException if this.rowDimension != row dimension\n+     * @throws InvalidMatrixException if this matrix is not square or is singular\n+     */\n+    public BigMatrix solve(BigMatrix b) throws IllegalArgumentException, InvalidMatrixException  {\n+        if (b.getRowDimension() != this.getRowDimension()) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+        if (!this.isSquare()) {\n+            throw new InvalidMatrixException(\"coefficient matrix is not square\");\n+        }\n+        if (this.isSingular()) { // side effect: compute LU decomp\n+            throw new InvalidMatrixException(\"Matrix is singular.\");\n+        }\n+        \n+        int nCol = this.getColumnDimension();\n+        int nColB = b.getColumnDimension();\n+        int nRowB = b.getRowDimension();\n+        \n+        // Apply permutations to b\n+        BigDecimal[][] bv = b.getData();\n+        BigDecimal[][] bp = new BigDecimal[nRowB][nColB];\n+        for (int row = 0; row < nRowB; row++) {\n+            for (int col = 0; col < nColB; col++) {\n+                bp[row][col] = bv[permutation[row]][col];\n+            }\n+        }\n+        bv = null;\n+        \n+        // Solve LY = b\n+        for (int col = 0; col < nCol; col++) {\n+            for (int i = col + 1; i < nCol; i++) {\n+                for (int j = 0; j < nColB; j++) {\n+                    bp[i][j] = bp[i][j].subtract(bp[col][j].multiply(lu[i][col]));\n+                }\n+            }\n+        }\n+        \n+        // Solve UX = Y\n+        for (int col = nCol - 1; col >= 0; col--) {\n+            for (int j = 0; j < nColB; j++) {\n+                bp[col][j] = bp[col][j].divide(lu[col][col], scale, roundingMode);\n+            }\n+            for (int i = 0; i < col; i++) {\n+                for (int j = 0; j < nColB; j++) {\n+                    bp[i][j] = bp[i][j].subtract(bp[col][j].multiply(lu[i][col]));\n+                }\n+            }\n+        }\n+        \n+        BigMatrixImpl outMat = new BigMatrixImpl(bp);\n+        return outMat;\n+    }\n+    \n+    /**\n+     * Computes a new \n+     * <a href=\"http://www.math.gatech.edu/~bourbaki/math2601/Web-notes/2num.pdf\">\n+     * LU decompostion</a> for this matrix, storing the result for use by other methods. \n+     * <p>\n+     * <strong>Implementation Note</strong>:<br>\n+     * Uses <a href=\"http://www.damtp.cam.ac.uk/user/fdl/people/sd/lectures/nummeth98/linear.htm\">\n+     * Crout's algortithm</a>, with partial pivoting.\n+     * <p>\n+     * <strong>Usage Note</strong>:<br>\n+     * This method should rarely be invoked directly. Its only use is\n+     * to force recomputation of the LU decomposition when changes have been\n+     * made to the underlying data using direct array references. Changes\n+     * made using setXxx methods will trigger recomputation when needed\n+     * automatically.\n+     *\n+     * @throws InvalidMatrixException if the matrix is non-square or singular.\n+     */\n+    public void luDecompose() throws InvalidMatrixException {\n+        \n+        int nRows = this.getRowDimension();\n+        int nCols = this.getColumnDimension();\n+        if (nRows != nCols) {\n+            throw new InvalidMatrixException(\"LU decomposition requires that the matrix be square.\");\n+        }\n+        lu = this.getData();\n+        \n+        // Initialize permutation array and parity\n+        permutation = new int[nRows];\n+        for (int row = 0; row < nRows; row++) {\n+            permutation[row] = row;\n+        }\n+        parity = 1;\n+        \n+        // Loop over columns\n+        for (int col = 0; col < nCols; col++) {\n+            \n+            BigDecimal sum = ZERO;\n+            \n+            // upper\n+            for (int row = 0; row < col; row++) {\n+                sum = lu[row][col];\n+                for (int i = 0; i < row; i++) {\n+                    sum = sum.subtract(lu[row][i].multiply(lu[i][col]));\n+                }\n+                lu[row][col] = sum;\n+            }\n+            \n+            // lower\n+            int max = col; // permutation row\n+            BigDecimal largest = ZERO;\n+            for (int row = col; row < nRows; row++) {\n+                sum = lu[row][col];\n+                for (int i = 0; i < col; i++) {\n+                    sum = sum.subtract(lu[row][i].multiply(lu[i][col]));\n+                }\n+                lu[row][col] = sum;\n+                \n+                // maintain best permutation choice\n+                if (sum.abs().compareTo(largest) == 1) {\n+                    largest = sum.abs();\n+                    max = row;\n+                }\n+            }\n+            \n+            // Singularity check\n+            if (lu[max][col].abs().compareTo(TOO_SMALL) <= 0) {\n+                lu = null;\n+                throw new InvalidMatrixException(\"matrix is singular\");\n+            }\n+            \n+            // Pivot if necessary\n+            if (max != col) {\n+                BigDecimal tmp = ZERO;\n+                for (int i = 0; i < nCols; i++) {\n+                    tmp = lu[max][i];\n+                    lu[max][i] = lu[col][i];\n+                    lu[col][i] = tmp;\n+                }\n+                int temp = permutation[max];\n+                permutation[max] = permutation[col];\n+                permutation[col] = temp;\n+                parity = -parity;\n+            }\n+            \n+            //Divide the lower elements by the \"winning\" diagonal elt.\n+            for (int row = col + 1; row < nRows; row++) {\n+                lu[row][col] = lu[row][col].divide(lu[col][col], scale, roundingMode);\n+            }\n+            \n+        }\n+        \n+    }\n+    \n+    /**\n+     * \n+     * @see Object#toString()\n+     */\n+    public String toString() {\n+        StringBuffer res = new StringBuffer();\n+        res.append(\"BigMatrixImpl{\");\n+        for (int i = 0; i < data.length; i++) {\n+            if (i > 0)\n+                res.append(\",\");\n+            res.append(\"{\");\n+            for (int j = 0; j < data[0].length; j++) {\n+                if (j > 0)\n+                    res.append(\",\");\n+                res.append(data[i][j]);\n+            } //for\n+            res.append(\"}\");\n+        } //for\n+        res.append(\"}\");\n+        return res.toString();\n+    } //toString\n+    \n+    //------------------------ Protected methods\n+    \n+    /**\n+     * Returns <code>dimension x dimension</code> identity matrix.\n+     *\n+     * @param dimension dimension of identity matrix to generate\n+     * @return identity matrix\n+     */\n+    protected BigMatrix getIdentity(int dimension) {\n+        BigMatrixImpl out = new BigMatrixImpl(dimension, dimension);\n+        BigDecimal[][] d = out.getDataRef();\n+        for (int row = 0; row < dimension; row++) {\n+            for (int col = 0; col < dimension; col++) {\n+                d[row][col] = row == col ? ONE : ZERO;\n+            }\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     *  Returns the LU decomposition as a BigMatrix.\n+     *  Returns a fresh copy of the cached LU matrix if this has been computed; \n+     *  otherwise the composition is computed and cached for use by other methods.   \n+     *  Since a copy is returned in either case, changes to the returned matrix do not \n+     *  affect the LU decomposition property. \n+     * <p>\n+     * The matrix returned is a compact representation of the LU decomposition. \n+     * Elements below the main diagonal correspond to entries of the \"L\" matrix;   \n+     * elements on and above the main diagonal correspond to entries of the \"U\"\n+     * matrix.\n+     * <p>\n+     * Example: <pre>\n+     * \n+     *     Returned matrix                L                  U\n+     *         2  3  1                   1  0  0            2  3  1          \n+     *         5  4  6                   5  1  0            0  4  6\n+     *         1  7  8                   1  7  1            0  0  8          \n+     * </pre>\n+     * \n+     * The L and U matrices satisfy the matrix equation LU = permuteRows(this), <br>\n+     *  where permuteRows reorders the rows of the matrix to follow the order determined\n+     *  by the <a href=#getPermutation()>permutation</a> property.\n+     * \n+     * @return LU decomposition matrix\n+     * @throws InvalidMatrixException if the matrix is non-square or singular.\n+     */\n+    protected BigMatrix getLUMatrix() throws InvalidMatrixException {\n+        if (lu == null) {\n+            luDecompose();\n+        }\n+        return new BigMatrixImpl(lu);\n+    }\n+    \n+    /**\n+     * Returns the permutation associated with the lu decomposition.\n+     * The entries of the array represent a permutation of the numbers 0, ... , nRows - 1.\n+     * <p>\n+     * Example:\n+     * permutation = [1, 2, 0] means current 2nd row is first, current third row is second\n+     * and current first row is last.\n+     * <p>\n+     * Returns a fresh copy of the array.\n+     * \n+     * @return the permutation\n+     */\n+    protected int[] getPermutation() {\n+        int[] out = new int[permutation.length];\n+        System.arraycopy(permutation, 0, out, 0, permutation.length);\n+        return out;\n+    }\n+    \n+    //------------------------ Private methods\n+    \n+    /**\n+     * Returns a fresh copy of the underlying data array.\n+     *\n+     * @return a copy of the underlying data array.\n+     */\n+    private BigDecimal[][] copyOut() {\n+        int nRows = this.getRowDimension();\n+        BigDecimal[][] out = new BigDecimal[nRows][this.getColumnDimension()];\n+        // can't copy 2-d array in one shot, otherwise get row references\n+        for (int i = 0; i < nRows; i++) {\n+            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n+        }\n+        return out;\n+    }\n+    \n+    /**\n+     * Replaces data with a fresh copy of the input array.\n+     *\n+     * @param in data to copy in\n+     */\n+    private void copyIn(BigDecimal[][] in) {\n+        int nRows = in.length;\n+        int nCols = in[0].length;\n+        data = new BigDecimal[nRows][nCols];\n+        System.arraycopy(in, 0, data, 0, in.length);\n+        for (int i = 0; i < nRows; i++) {\n+            System.arraycopy(in[i], 0, data[i], 0, nCols);\n+        }\n+        lu = null;\n+    }\n+    \n+    /**\n+     * Replaces data with a fresh copy of the input array.\n+     *\n+     * @param in data to copy in\n+     */\n+    private void copyIn(double[][] in) {\n+        int nRows = in.length;\n+        int nCols = in[0].length;\n+        data = new BigDecimal[nRows][nCols];\n+        for (int i = 0; i < nRows; i++) {\n+            for (int j=0; j < nCols; j++) {\n+                data[i][j] = new BigDecimal(in[i][j]);\n+            }\n+        }\n+        lu = null;\n+    }\n+    \n+    /**\n+     * Tests a given coordinate as being valid or invalid\n+     *\n+     * @param row the row index.\n+     * @param col the column index.\n+     * @return true if the coordinate is with the current dimensions\n+     */\n+    private boolean isValidCoordinate(int row, int col) {\n+        int nRows = this.getRowDimension();\n+        int nCols = this.getColumnDimension();\n+        \n+        return !(row < 1 || row > nRows || col < 1 || col > nCols);\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/linear/BigMatrixImplTest.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.linear;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import java.math.BigDecimal;\n+\n+/**\n+ * Test cases for the {@link BigMatrixImpl} class.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/06/06 04:20:45 $\n+ */\n+\n+public final class BigMatrixImplTest extends TestCase {\n+    \n+    private double[][] testData = { {1d,2d,3d}, {2d,5d,3d}, {1d,0d,8d} };\n+    private double[][] testDataLU = {{2d, 5d, 3d}, {.5d, -2.5d, 6.5d}, {0.5d, 0.2d, .2d}};\n+    private double[][] testDataPlus2 = { {3d,4d,5d}, {4d,7d,5d}, {3d,2d,10d} };\n+    private double[][] testDataMinus = { {-1d,-2d,-3d}, {-2d,-5d,-3d}, \n+       {-1d,0d,-8d} };\n+    private double[] testDataRow1 = {1d,2d,3d};\n+    private double[] testDataCol3 = {3d,3d,8d};\n+    private double[][] testDataInv = \n+        { {-40d,16d,9d}, {13d,-5d,-3d}, {5d,-2d,-1d} };\n+    private double[] preMultTest = {8,12,33};\n+    private double[][] testData2 ={ {1d,2d,3d}, {2d,5d,3d}};\n+    private double[][] testData2T = { {1d,2d}, {2d,5d}, {3d,3d}};\n+    private double[][] testDataPlusInv = \n+        { {-39d,18d,12d}, {15d,0d,0d}, {6d,-2d,7d} };\n+    private double[][] id = { {1d,0d,0d}, {0d,1d,0d}, {0d,0d,1d} };\n+    private double[][] luData = { {2d,3d,3d}, {0d,5d,7d}, {6d,9d,8d} };\n+    private double[][] luDataLUDecomposition = { {6d,9d,8d}, {0d,5d,7d}, {0.33333333333333,0d,0.33333333333333} };\n+    private double[][] singular = { {2d,3d}, {2d,3d} };\n+    private double[][] bigSingular = {{1d,2d,3d,4d}, {2d,5d,3d,4d},\n+        {7d,3d,256d,1930d}, {3d,7d,6d,8d}}; // 4th row = 1st + 2nd\n+    private double[][] detData = { {1d,2d,3d}, {4d,5d,6d}, {7d,8d,10d} };\n+    private double[][] detData2 = { {1d, 3d}, {2d, 4d}};\n+    private double[] testVector = {1,2,3};\n+    private double[] testVector2 = {1,2,3,4};\n+    private double entryTolerance = 10E-16;\n+    private double normTolerance = 10E-14;\n+    \n+    public BigMatrixImplTest(String name) {\n+        super(name);\n+    }\n+    \n+    public void setUp() {\n+        \n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(BigMatrixImplTest.class);\n+        suite.setName(\"BigMatrixImpl Tests\");\n+        return suite;\n+    }\n+\n+    public static final double[] asDouble(BigDecimal[] data) {\n+        double d[] = new double[data.length];\n+        for (int i=0;i<d.length;i++) {\n+            d[i] = data[i].doubleValue();\n+        }\n+        return d;\n+    }\n+\n+    public static final double[][] asDouble(BigDecimal[][] data) {\n+        double d[][] = new double[data.length][data[0].length];\n+        for (int i=0;i<d.length;i++) {\n+            for (int j=0;j<d[i].length;j++)\n+            d[i][j] = data[i][j].doubleValue();\n+        }\n+        return d;\n+    }\n+\n+    public static final BigDecimal[] asBigDecimal(double [] data) {\n+        BigDecimal d[] = new BigDecimal[data.length];\n+        for (int i=0;i<d.length;i++) {\n+            d[i] = new BigDecimal(data[i]);\n+        }\n+        return d;\n+    }\n+\n+    public static final BigDecimal[][] asBigDecimal(double [][] data) {\n+        BigDecimal d[][] = new BigDecimal[data.length][data[0].length];\n+        for (int i=0;i<d.length;i++) {\n+            for (int j=0;j<data[i].length;j++) {\n+                d[i][j] = new BigDecimal(data[i][j]);\n+            }\n+        }\n+        return d;\n+    }\n+\n+    /** test dimensions */\n+    public void testDimensions() {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrixImpl m2 = new BigMatrixImpl(testData2);\n+        assertEquals(\"testData row dimension\",3,m.getRowDimension());\n+        assertEquals(\"testData column dimension\",3,m.getColumnDimension());\n+        assertTrue(\"testData is square\",m.isSquare());\n+        assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n+        assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n+        assertTrue(\"testData2 is not square\",!m2.isSquare());\n+        BigMatrixImpl m3 = new BigMatrixImpl();\n+        m3.setData(testData);\n+    } \n+    \n+    /** test copy functions */\n+    public void testCopyFunctions() {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrixImpl m2 = new BigMatrixImpl(testData2);\n+        m2.setData(m.getData());\n+        assertClose(\"getData\",m2,m,entryTolerance);\n+        // no dangling reference...\n+        m2.setEntry(1,1,2000d);\n+        BigMatrixImpl m3 = new BigMatrixImpl(testData);\n+        assertClose(\"no getData side effect\",m,m3,entryTolerance);\n+        m3 = (BigMatrixImpl) m.copy();\n+        double[][] stompMe = {{1d,2d,3d}};\n+        m3.setDataRef(asBigDecimal(stompMe));\n+        assertClose(\"no copy side effect\",m,new BigMatrixImpl(testData),\n+            entryTolerance);\n+    }           \n+    \n+    /** test add */\n+    public void testAdd() {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);\n+        BigMatrixImpl mPlusMInv = (BigMatrixImpl)m.add(mInv);\n+        double[][] sumEntries = asDouble(mPlusMInv.getData());\n+        for (int row = 0; row < m.getRowDimension(); row++) {\n+            for (int col = 0; col < m.getColumnDimension(); col++) {\n+                assertEquals(\"sum entry entry\",\n+                    testDataPlusInv[row][col],sumEntries[row][col],\n+                        entryTolerance);\n+            }\n+        }    \n+    }\n+    \n+    /** test add failure */\n+    public void testAddFail() {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrixImpl m2 = new BigMatrixImpl(testData2);\n+        try {\n+            BigMatrixImpl mPlusMInv = (BigMatrixImpl)m.add(m2);\n+            fail(\"IllegalArgumentException expected\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+    }\n+    \n+    /** test norm */\n+    public void testNorm() {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrixImpl m2 = new BigMatrixImpl(testData2);\n+        assertEquals(\"testData norm\",14d,m.getNorm().doubleValue(),entryTolerance);\n+        assertEquals(\"testData2 norm\",7d,m2.getNorm().doubleValue(),entryTolerance);\n+    }\n+    \n+     /** test m-n = m + -n */\n+    public void testPlusMinus() {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrixImpl m2 = new BigMatrixImpl(testDataInv);\n+        assertClose(\"m-n = m + -n\",m.subtract(m2),\n+            m2.scalarMultiply(new BigDecimal(-1d)).add(m),entryTolerance);\n+        try {\n+            BigMatrix a = m.subtract(new BigMatrixImpl(testData2));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }\n+   \n+    /** test multiply */\n+     public void testMultiply() {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);\n+        BigMatrixImpl identity = new BigMatrixImpl(id);\n+        BigMatrixImpl m2 = new BigMatrixImpl(testData2);\n+        assertClose(\"inverse multiply\",m.multiply(mInv),\n+            identity,entryTolerance);\n+        assertClose(\"inverse multiply\",mInv.multiply(m),\n+            identity,entryTolerance);\n+        assertClose(\"identity multiply\",m.multiply(identity),\n+            m,entryTolerance);\n+        assertClose(\"identity multiply\",identity.multiply(mInv),\n+            mInv,entryTolerance);\n+        assertClose(\"identity multiply\",m2.multiply(identity),\n+            m2,entryTolerance); \n+        try {\n+            BigMatrix a = m.multiply(new BigMatrixImpl(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }   \n+    \n+    //Additional Test for BigMatrixImplTest.testMultiply\n+\n+    private double[][] d3 = new double[][] {{1,2,3,4},{5,6,7,8}};\n+    private double[][] d4 = new double[][] {{1},{2},{3},{4}};\n+    private double[][] d5 = new double[][] {{30},{70}};\n+     \n+    public void testMultiply2() { \n+       BigMatrix m3 = new BigMatrixImpl(d3);\n+       BigMatrix m4 = new BigMatrixImpl(d4);\n+       BigMatrix m5 = new BigMatrixImpl(d5);\n+       assertClose(\"m3*m4=m5\", m3.multiply(m4), m5, entryTolerance);\n+   }  \n+        \n+    /** test isSingular */\n+    public void testIsSingular() {\n+        BigMatrixImpl m = new BigMatrixImpl(singular);\n+        assertTrue(\"singular\",m.isSingular());\n+        m = new BigMatrixImpl(bigSingular);\n+        assertTrue(\"big singular\",m.isSingular());\n+        m = new BigMatrixImpl(id);\n+        assertTrue(\"identity nonsingular\",!m.isSingular());\n+        m = new BigMatrixImpl(testData);\n+        assertTrue(\"testData nonsingular\",!m.isSingular());\n+    }\n+        \n+    /** test inverse */\n+    public void testInverse() {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrix mInv = new BigMatrixImpl(testDataInv);\n+        assertClose(\"inverse\",mInv,m.inverse(),normTolerance);\n+        assertClose(\"inverse^2\",m,m.inverse().inverse(),10E-12);\n+        \n+        // Not square\n+        m = new BigMatrixImpl(testData2);\n+        try {\n+            m.inverse();\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+        \n+        // Singular\n+        m = new BigMatrixImpl(singular);\n+        try {\n+            m.inverse();\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    /** test solve */\n+    public void testSolve() {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrix mInv = new BigMatrixImpl(testDataInv);\n+        // being a bit slothful here -- actually testing that X = A^-1 * B\n+        assertClose(\"inverse-operate\",\n+                    asDouble(mInv.operate(asBigDecimal(testVector))),\n+                    asDouble(m.solve(asBigDecimal(testVector))),\n+                    normTolerance);\n+        try {\n+            double[] x = asDouble(m.solve(asBigDecimal(testVector2)));\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }       \n+        BigMatrix bs = new BigMatrixImpl(bigSingular);\n+        try {\n+            BigMatrix a = bs.solve(bs);\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            ;\n+        }\n+        try {\n+            BigMatrix a = m.solve(bs);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            BigMatrix a = (new BigMatrixImpl(testData2)).solve(bs);\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        } \n+        try {\n+            (new BigMatrixImpl(testData2)).luDecompose();\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            ;\n+        }  \n+    }\n+    \n+    /** test determinant */\n+    public void testDeterminant() {       \n+        BigMatrix m = new BigMatrixImpl(bigSingular);\n+        assertEquals(\"singular determinant\",0,m.getDeterminant().doubleValue(),0);\n+        m = new BigMatrixImpl(detData);\n+        assertEquals(\"nonsingular test\",-3d,m.getDeterminant().doubleValue(),normTolerance);\n+        \n+        // Examples verified against R (version 1.8.1, Red Hat Linux 9)\n+        m = new BigMatrixImpl(detData2);\n+        assertEquals(\"nonsingular R test 1\",-2d,m.getDeterminant().doubleValue(),normTolerance);\n+        m = new BigMatrixImpl(testData);\n+        assertEquals(\"nonsingular  R test 2\",-1d,m.getDeterminant().doubleValue(),normTolerance);\n+\n+        try {\n+            double a = new BigMatrixImpl(testData2).getDeterminant().doubleValue();\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            ;\n+        }      \n+    }\n+    \n+    /** test trace */\n+    public void testTrace() {\n+        BigMatrix m = new BigMatrixImpl(id);\n+        assertEquals(\"identity trace\",3d,m.getTrace().doubleValue(),entryTolerance);\n+        m = new BigMatrixImpl(testData2);\n+        try {\n+            double x = m.getTrace().doubleValue();\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }\n+    \n+    /** test sclarAdd */\n+    public void testScalarAdd() {\n+        BigMatrix m = new BigMatrixImpl(testData);\n+        assertClose(\"scalar add\",new BigMatrixImpl(testDataPlus2),\n+            m.scalarAdd(new BigDecimal(2d)),entryTolerance);\n+    }\n+                    \n+    /** test operate */\n+    public void testOperate() {\n+        BigMatrix m = new BigMatrixImpl(id);\n+        double[] x = asDouble(m.operate(asBigDecimal(testVector)));\n+        assertClose(\"identity operate\",testVector,x,entryTolerance);\n+        m = new BigMatrixImpl(bigSingular);\n+        try {\n+            x = asDouble(m.operate(asBigDecimal(testVector)));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }\n+    \n+    /** test transpose */\n+    public void testTranspose() {\n+        BigMatrix m = new BigMatrixImpl(testData);\n+        assertClose(\"inverse-transpose\",m.inverse().transpose(),\n+            m.transpose().inverse(),normTolerance);\n+        m = new BigMatrixImpl(testData2);\n+        BigMatrix mt = new BigMatrixImpl(testData2T);\n+        assertClose(\"transpose\",mt,m.transpose(),normTolerance);\n+    }\n+    \n+    /** test preMultiply by vector */\n+    public void testPremultiplyVector() {\n+        BigMatrix m = new BigMatrixImpl(testData);\n+        assertClose(\"premultiply\",asDouble(m.preMultiply(asBigDecimal(testVector))),preMultTest,normTolerance);\n+        m = new BigMatrixImpl(bigSingular);\n+        try {\n+            m.preMultiply(asBigDecimal(testVector));\n+            fail(\"expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+    }\n+    \n+    public void testPremultiply() {\n+        BigMatrix m3 = new BigMatrixImpl(d3);\n+        BigMatrix m4 = new BigMatrixImpl(d4);\n+        BigMatrix m5 = new BigMatrixImpl(d5);\n+        assertClose(\"m3*m4=m5\", m4.preMultiply(m3), m5, entryTolerance);\n+        \n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrixImpl mInv = new BigMatrixImpl(testDataInv);\n+        BigMatrixImpl identity = new BigMatrixImpl(id);\n+        BigMatrixImpl m2 = new BigMatrixImpl(testData2);\n+        assertClose(\"inverse multiply\",m.preMultiply(mInv),\n+                identity,entryTolerance);\n+        assertClose(\"inverse multiply\",mInv.preMultiply(m),\n+                identity,entryTolerance);\n+        assertClose(\"identity multiply\",m.preMultiply(identity),\n+                m,entryTolerance);\n+        assertClose(\"identity multiply\",identity.preMultiply(mInv),\n+                mInv,entryTolerance);\n+        try {\n+            BigMatrix a = m.preMultiply(new BigMatrixImpl(bigSingular));\n+            fail(\"Expecting illegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }      \n+    }\n+    \n+    public void testGetVectors() {\n+        BigMatrix m = new BigMatrixImpl(testData);\n+        assertClose(\"get row\",m.getRowAsDoubleArray(1),testDataRow1,entryTolerance);\n+        assertClose(\"get col\",m.getColumnAsDoubleArray(3),testDataCol3,entryTolerance);\n+        try {\n+            double[] x = m.getRowAsDoubleArray(10);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            ;\n+        }\n+        try {\n+            double[] x = m.getColumnAsDoubleArray(-1);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            ;\n+        }\n+    }\n+    \n+    public void testEntryMutators() {\n+        BigMatrix m = new BigMatrixImpl(testData);\n+        assertEquals(\"get entry\",m.getEntry(1,2).doubleValue(),2d,entryTolerance);\n+        m.setEntry(1,2,100d);\n+        assertEquals(\"get entry\",m.getEntry(1,2).doubleValue(),100d,entryTolerance);\n+        try {\n+            double x = m.getEntry(0,2).doubleValue();\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            ;\n+        }\n+        try {\n+            m.setEntry(1,4,200d);\n+            fail(\"expecting MatrixIndexException\");\n+        } catch (MatrixIndexException ex) {\n+            ;\n+        }\n+    }\n+        \n+    public void testLUDecomposition() throws Exception {\n+        BigMatrixImpl m = new BigMatrixImpl(testData);\n+        BigMatrix lu = m.getLUMatrix();\n+        assertClose(\"LU decomposition\", lu, (BigMatrix) new BigMatrixImpl(testDataLU), normTolerance);\n+        verifyDecomposition(m, lu);\n+        m = new BigMatrixImpl(luData);\n+        lu = m.getLUMatrix();\n+        assertClose(\"LU decomposition\", lu, (BigMatrix) new BigMatrixImpl(luDataLUDecomposition), normTolerance);\n+        verifyDecomposition(m, lu);\n+        m = new BigMatrixImpl(testDataMinus);\n+        lu = m.getLUMatrix();\n+        verifyDecomposition(m, lu);\n+        m = new BigMatrixImpl(id);\n+        lu = m.getLUMatrix();\n+        verifyDecomposition(m, lu);\n+        try {\n+            m = new BigMatrixImpl(bigSingular); // singular\n+            lu = m.getLUMatrix();\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+        try {\n+            m = new BigMatrixImpl(testData2);  // not square\n+            lu = m.getLUMatrix();\n+            fail(\"Expecting InvalidMatrixException\");\n+        } catch (InvalidMatrixException ex) {\n+            // expected\n+        }\n+    }\n+    \n+    //--------------- -----------------Protected methods\n+        \n+    /** verifies that two matrices are close (1-norm) */              \n+    protected void assertClose(String msg, BigMatrix m, BigMatrix n,\n+        double tolerance) {\n+        assertTrue(msg,m.subtract(n).getNorm().doubleValue() < tolerance);\n+    }\n+    \n+    /** verifies that two vectors are close (sup norm) */\n+    protected void assertClose(String msg, double[] m, double[] n,\n+        double tolerance) {\n+        if (m.length != n.length) {\n+            fail(\"vectors not same length\");\n+        }\n+        for (int i = 0; i < m.length; i++) {\n+            assertEquals(msg + \" \" +  i + \" elements differ\", \n+                m[i],n[i],tolerance);\n+        }\n+    }\n+    \n+    /** extracts the l  and u matrices from compact lu representation */\n+    protected void splitLU(BigMatrix lu, BigMatrix lower, BigMatrix upper) throws InvalidMatrixException {\n+        if (!lu.isSquare() || !lower.isSquare() || !upper.isSquare() ||\n+                lower.getRowDimension() != upper.getRowDimension() \n+                || lower.getRowDimension() != lu.getRowDimension()) {\n+            throw new InvalidMatrixException(\"incorrect dimensions\");\n+        }    \n+        int n = lu.getRowDimension();\n+        for (int i = 1; i <= n; i++) {\n+            for (int j = 1; j <= n; j++) {\n+                if (j < i) {\n+                    lower.setEntry(i, j, lu.getEntry(i, j));\n+                    upper.setEntry(i, j, 0d);\n+                } else if (i == j) {\n+                    lower.setEntry(i, j, 1d);\n+                    upper.setEntry(i, j, lu.getEntry(i, j));\n+                } else {\n+                    lower.setEntry(i, j, 0d);\n+                    upper.setEntry(i, j, lu.getEntry(i, j));\n+                }   \n+            }\n+        }\n+    }\n+    \n+    /** Returns the result of applying the given row permutation to the matrix */\n+    protected BigMatrix permuteRows(BigMatrix matrix, int[] permutation) {\n+        if (!matrix.isSquare() || matrix.getRowDimension() != permutation.length) {\n+            throw new IllegalArgumentException(\"dimension mismatch\");\n+        }\n+        int n = matrix.getRowDimension();\n+        BigMatrix out = new BigMatrixImpl(n, n);\n+        for (int i =1; i <= n; i++) {\n+            for (int j = 1; j <= n; j++) {\n+                out.setEntry(i, j, matrix.getEntry(permutation[i -1] + 1, j));\n+            }\n+        }\n+        return out;\n+    }\n+    \n+    /** Extracts l and u matrices from lu and verifies that matrix = l times u modulo permutation */\n+    protected void verifyDecomposition(BigMatrix matrix, BigMatrix lu) throws Exception{\n+        int n = matrix.getRowDimension();\n+        BigMatrix lower = new BigMatrixImpl(n, n);\n+        BigMatrix upper = new BigMatrixImpl(n, n);\n+        splitLU(lu, lower, upper);\n+        int[] permutation = ((BigMatrixImpl) matrix).getPermutation();\n+        BigMatrix permuted = permuteRows(matrix, permutation);\n+        assertClose(\"lu decomposition does not work\", permuted, lower.multiply(upper), normTolerance);\n+    }\n+      \n+    \n+    /** Useful for debugging */\n+    private void dumpMatrix(BigMatrix m) {\n+          for (int i = 0; i < m.getRowDimension(); i++) {\n+              String os = \"\";\n+              for (int j = 0; j < m.getColumnDimension(); j++) {\n+                  os += m.getEntry(i+1, j+1) + \" \";\n+              }\n+              System.out.println(os);\n+          }\n+    }\n+        \n+}\n+", "timestamp": 1086495645, "metainfo": ""}