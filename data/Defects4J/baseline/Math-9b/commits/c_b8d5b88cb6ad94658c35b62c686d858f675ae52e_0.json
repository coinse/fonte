{"sha": "b8d5b88cb6ad94658c35b62c686d858f675ae52e", "log": "MATH-621 Original contribution due to Dietmar Wolz: Fortran code translated in Java. This commit is for reference only; work is under way to adapt the code into a more maintainable version.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     NEGATIVE_NUMBER_OF_SUCCESSES(\"number of successes must be non-negative ({0})\"),\n     NUMBER_OF_SUCCESSES(\"number of successes ({0})\"), /* keep */\n     NEGATIVE_NUMBER_OF_TRIALS(\"number of trials must be non-negative ({0})\"),\n+    NUMBER_OF_INTERPOLATION_POINTS(\"number of interpolation points ({0})\"), /* keep */\n     NUMBER_OF_TRIALS(\"number of trials ({0})\"),\n     ROBUSTNESS_ITERATIONS(\"number of robustness iterations ({0})\"),\n     START_POSITION(\"start position ({0})\"), /* keep */\n     N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED(\"{0} points Legendre-Gauss integrator not supported, number of points must be in the {1}-{2} range\"),\n     OBSERVED_COUNTS_ALL_ZERO(\"observed counts are all 0 in observed array {0}\"),\n     OBSERVED_COUNTS_BOTTH_ZERO_FOR_ENTRY(\"observed counts are both zero for entry {0}\"),\n+    BOBYQA_BOUND_DIFFERENCE_CONDITION(\"the difference between the upper and lower bound must be larger than twice the initial trust region radius ({0})\"),\n     OUT_OF_BOUNDS_QUANTILE_VALUE(\"out of bounds quantile value: {0}, must be in (0, 100]\"),\n     OUT_OF_BOUND_SIGNIFICANCE_LEVEL(\"out of bounds significance level {0}, must be between {1} and {2}\"),\n     SIGNIFICANCE_LEVEL(\"significance level ({0})\"), /* keep */\n     SUBARRAY_ENDS_AFTER_ARRAY_END(\"subarray ends after array end\"),\n     TOO_LARGE_CUTOFF_SINGULAR_VALUE(\"cutoff singular value is {0}, should be at most {1}\"),\n     TOO_MANY_ELEMENTS_TO_DISCARD_FROM_ARRAY(\"cannot discard {0} elements from a {1} elements array\"),\n+    TOO_MUCH_CANCELLATION(\"too much cancellation in a denominator\"),\n     TOO_MANY_REGRESSORS(\"too many regressors ({0}) specified, only {1} in the model\"),\n     TOO_SMALL_COST_RELATIVE_TOLERANCE(\"cost relative tolerance is too small ({0}), no further reduction in the sum of squares is possible\"),\n     TOO_SMALL_INTEGRATION_INTERVAL(\"too small integration interval: length = {0}\"),\n     TOO_SMALL_ORTHOGONALITY_TOLERANCE(\"orthogonality tolerance is too small ({0}), solution is orthogonal to the jacobian\"),\n     TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE(\"parameters relative tolerance is too small ({0}), no further improvement in the approximate solution is possible\"),\n+    TRUST_REGION_STEP_FAILED(\"trust region step has failed to reduce Q\"),\n     TWO_OR_MORE_CATEGORIES_REQUIRED(\"two or more categories required, got {0}\"),\n     TWO_OR_MORE_VALUES_IN_CATEGORY_REQUIRED(\"two or more values required in each category, one has {0}\"),\n     UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH(\"unable to bracket optimum in line search\"),\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import java.util.Arrays;\n+\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.MathIllegalStateException;\n+import org.apache.commons.math.exception.MultiDimensionMismatchException;\n+import org.apache.commons.math.exception.NoDataException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+\n+/**\n+ * BOBYQA algorithm. This code is translated and adapted from the Fortran version\n+ * of this algorithm as implemented in http://plato.asu.edu/ftp/other_software/bobyqa.zip .\n+ * <em>http://</em>. <br>\n+ * See <em>http://www.optimization-online.org/DB_HTML/2010/05/2616.html</em>\n+ * for an introduction.\n+ *\n+ * <p>BOBYQA is particularly well suited for high dimensional problems\n+ * where derivatives are not available. In most cases it outperforms the\n+ * PowellOptimizer significantly. Stochastic algorithms like CMAESOptimizer\n+ * succeed more often than BOBYQA, but are more expensive. BOBYQA could\n+ * also be considered if you currently use a derivative based (Differentiable)\n+ * optimizer approximating the derivatives by finite differences.\n+ *\n+ * Comments of the subroutines were copied directly from the original sources.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+\n+public class BOBYQAOptimizer extends\n+BaseAbstractScalarOptimizer<MultivariateRealFunction> implements\n+MultivariateRealOptimizer {\n+\n+    /** Default value for {@link #initialTrustRegionRadius}: {@value} . */\n+    public static final double DEFAULT_INITIAL_RADIUS = 10.0;\n+    /** Default value for {@link #stoppingTrustRegionRadius}: {@value} . */\n+    public static final double DEFAULT_STOPPING_RADIUS = 1E-8;\n+\n+    /**\n+     * numberOfInterpolationPoints\n+     */\n+    private int numberOfInterpolationPoints;\n+    /**\n+     * initialTrustRegionRadius;\n+     */\n+    private double initialTrustRegionRadius;\n+    /**\n+     * stoppingTrustRegionRadius;\n+     */\n+    private double stoppingTrustRegionRadius;\n+    /**\n+     * Lower and upper boundaries of the objective variables. boundaries == null\n+     * means no boundaries.\n+     */\n+    private double[][] boundaries;\n+    /** Number of objective variables/problem dimension */\n+    private int dimension;\n+    /** goal (minimize or maximize) */\n+    private boolean isMinimize = true;\n+\n+    /**\n+     * Default constructor, uses default parameters\n+     */\n+    public BOBYQAOptimizer() {\n+        this(null);\n+    }\n+\n+    /**\n+     * @param boundaries\n+     *             Boundaries for objective variables.\n+     */\n+    public BOBYQAOptimizer(double[][] boundaries) {\n+        this(boundaries, -1, DEFAULT_INITIAL_RADIUS,\n+                DEFAULT_STOPPING_RADIUS);\n+    }\n+\n+    /**\n+     * @param boundaries\n+     *            Boundaries for objective variables.\n+     * @param numberOfInterpolationPoints\n+     *            number of interpolation conditions. Its value must be for\n+     *            dimension=N in the interval [N+2,(N+1)(N+2)/2]. Choices that\n+     *            exceed 2*N+1 are not recommended. -1 means undefined, then\n+     *            2*N+1 is used as default.\n+     * @param initialTrustRegionRadius\n+     *            initial trust region radius.\n+     * @param stoppingTrustRegionRadius\n+     *            stopping trust region radius.\n+     */\n+    public BOBYQAOptimizer(double[][] boundaries,\n+            int numberOfInterpolationPoints, double initialTrustRegionRadius,\n+            double stoppingTrustRegionRadius) {\n+        this.boundaries = boundaries;\n+        this.numberOfInterpolationPoints = numberOfInterpolationPoints;\n+        this.initialTrustRegionRadius = initialTrustRegionRadius;\n+        this.stoppingTrustRegionRadius = stoppingTrustRegionRadius;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    protected RealPointValuePair doOptimize() {\n+        // -------------------- Initialization --------------------------------\n+        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n+        final double[] guess = getStartPoint();\n+        // number of objective variables/problem dimension\n+        dimension = guess.length;\n+        checkParameters();\n+        if (numberOfInterpolationPoints < 0)\n+            numberOfInterpolationPoints = 2 * dimension + 1;\n+        ScopedPtr x = new ScopedPtr(guess.clone(), 0);\n+        ScopedPtr xl;\n+        ScopedPtr xu;\n+        if (boundaries != null) {\n+            xl = new ScopedPtr(boundaries[0].clone(), 0);\n+            xu = new ScopedPtr(boundaries[1].clone(), 0);\n+            double minDiff = Double.MAX_VALUE;\n+            for (int i = 0; i < dimension; i++) {\n+                double diff = boundaries[1][i] - boundaries[0][i];\n+                minDiff = Math.min(minDiff, diff);\n+            }\n+            if (minDiff < 2 * initialTrustRegionRadius)\n+                initialTrustRegionRadius = minDiff / 3.0;\n+        } else {\n+            xl = new ScopedPtr(point(dimension, -1e300), 0);\n+            xu = new ScopedPtr(point(dimension, 1e300), 0);\n+        }\n+        double value = bobyqa(dimension, numberOfInterpolationPoints, x, xl,\n+                xu, initialTrustRegionRadius, stoppingTrustRegionRadius,\n+                getMaxEvaluations());\n+        return new RealPointValuePair(x.getAll(), isMinimize ? value : -value);\n+    }\n+\n+    /**\n+     *     This subroutine seeks the least value of a function of many variables,\n+     *     by applying a trust region method that forms quadratic models by\n+     *     interpolation. There is usually some freedom in the interpolation\n+     *     conditions, which is taken up by minimizing the Frobenius norm of\n+     *     the change to the second derivative of the model, beginning with the\n+     *     zero matrix. The values of the variables are constrained by upper and\n+     *     lower bounds. The arguments of the subroutine are as follows.\n+     *\n+     *     N must be set to the number of variables and must be at least two.\n+     *     NPT is the number of interpolation conditions. Its value must be in\n+     *       the interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not\n+     *       recommended.\n+     *     Initial values of the variables must be set in X(1),X(2),...,X(N). They\n+     *       will be changed to the values that give the least calculated F.\n+     *     For I=1,2,...,N, XL(I) and XU(I) must provide the lower and upper\n+     *       bounds, respectively, on X(I). The construction of quadratic models\n+     *       requires XL(I) to be strictly less than XU(I) for each I. Further,\n+     *       the contribution to a model from changes to the I-th variable is\n+     *       damaged severely by rounding errors if XU(I)-XL(I) is too small.\n+     *     RHOBEG and RHOEND must be set to the initial and final values of a trust\n+     *       region radius, so both must be positive with RHOEND no greater than\n+     *       RHOBEG. Typically, RHOBEG should be about one tenth of the greatest\n+     *       expected change to a variable, while RHOEND should indicate the\n+     *       accuracy that is required in the final values of the variables. An\n+     *       error return occurs if any of the differences XU(I)-XL(I), I=1,...,N,\n+     *       is less than 2*RHOBEG.\n+     *     MAXFUN must be set to an upper bound on the number of calls of CALFUN.\n+     *     The array W will be used for working space. Its length must be at least\n+     *       (NPT+5)*(NPT+N)+3*N*(N+5)/2.\n+     * @param n\n+     * @param npt\n+     * @param x\n+     * @param xl\n+     * @param xu\n+     * @param rhobeg\n+     * @param rhoend\n+     * @param maxfun\n+     * @return\n+     */\n+    private double bobyqa(\n+            int n,\n+            int npt,\n+            ScopedPtr x,\n+            ScopedPtr xl,\n+            ScopedPtr xu,\n+            double rhobeg,\n+            double rhoend,\n+            int maxfun\n+    ) {\n+\n+        ScopedPtr w = new ScopedPtr(new double[(npt+5)*(npt+n)+3*n*(n+5)/2],0);\n+\n+        // System generated locals\n+        int i__1;\n+        double d__1, d__2;\n+\n+        // Local variables\n+        int j, id_, np, iw, igo, ihq, ixb, ixa, ifv, isl, jsl, ipq, ivl, ixn, ixo, ixp, isu, jsu, ndim;\n+        double temp, zero;\n+        int ibmat, izmat;\n+\n+        // Parameter adjustments\n+        w = w.ptr(-1);\n+        xu = xu.ptr(-1);\n+        xl = xl.ptr(-1);\n+        x = x.ptr(-1);\n+\n+        // Function Body\n+        np = n + 1;\n+\n+        // Return if the value of NPT is unacceptable.\n+        if (npt < n + 2 || npt > (n + 2) * np / 2)\n+            throw new MathIllegalArgumentException(LocalizedFormats.NUMBER_OF_INTERPOLATION_POINTS, npt);\n+\n+        // Partition the working space array, so that different parts of it can\n+        // be treated separately during the calculation of BOBYQB. The partition\n+        // requires the first (NPT+2)*(NPT+N)+3*N*(N+5)/2 elements of W plus the\n+        // space that is taken by the last array in the argument list of BOBYQB.\n+\n+        ndim = npt + n;\n+        ixb = 1;\n+        ixp = ixb + n;\n+        ifv = ixp + n * npt;\n+        ixo = ifv + npt;\n+        igo = ixo + n;\n+        ihq = igo + n;\n+        ipq = ihq + n * np / 2;\n+        ibmat = ipq + npt;\n+        izmat = ibmat + ndim * n;\n+        isl = izmat+ npt * (npt - np);\n+        isu = isl + n;\n+        ixn = isu + n;\n+        ixa = ixn + n;\n+        id_ = ixa + n;\n+        ivl = id_ + n;\n+        iw = ivl + ndim;\n+\n+        // Return if there is insufficient space between the bounds. Modify the\n+        // initial X if necessary in order to avoid conflicts between the bounds\n+        // and the construction of the first quadratic model. The lower and upper\n+        // bounds on moves from the updated X are set now, in the ISL and ISU\n+        // partitions of W, in order to provide useful and exact information about\n+        // components of X that become within distance RHOBEG from their bounds.\n+\n+        zero = 0.;\n+        i__1 = n;\n+        for (j = 1; j <= i__1; j++) {\n+            temp = xu.get(j) - xl.get(j);\n+            if (temp < rhobeg + rhobeg) {\n+                throw new NumberIsTooSmallException(temp, rhobeg + rhobeg, true);\n+            }\n+            jsl = isl + j - 1;\n+            jsu = jsl + n;\n+            w.set(jsl, xl.get(j) - x.get(j));\n+            w.set(jsu, xu.get(j) - x.get(j));\n+            if (w.get(jsl) >= -rhobeg) {\n+                if (w.get(jsl) >= zero) {\n+                    x.set(j, xl.get(j));\n+                    w.set(jsl, zero);\n+                    w.set(jsu, temp);\n+                } else {\n+                    x.set(j, xl.get(j) + rhobeg);\n+                    w.set(jsl, -rhobeg);\n+                    // Computing MAX\n+                    d__1 = xu.get(j) - x.get(j);\n+                    w.set(jsu, Math.max(d__1,rhobeg));\n+                }\n+            } else if (w.get(jsu) <= rhobeg) {\n+                if (w.get(jsu) <= zero) {\n+                    x.set(j, xu.get(j));\n+                    w.set(jsl, -temp);\n+                    w.set(jsu, zero);\n+                } else {\n+                    x.set(j, xu.get(j) - rhobeg);\n+                    // Computing MIN\n+                    d__1 = xl.get(j) - x.get(j);\n+                    d__2 = -rhobeg;\n+                    w.set(jsl, Math.min(d__1,d__2));\n+                    w.set(jsu, rhobeg);\n+                }\n+            }\n+        }\n+\n+        // Make the call of BOBYQB.\n+\n+        return bobyqb(n, npt, x, xl, xu, rhobeg, rhoend, maxfun,\n+                w.ptr(ixb-1), w.ptr(ixp-npt-1), w.ptr(ifv-1), w.ptr(ixo-1), w.ptr(igo-1), w.ptr(ihq-1), w.ptr(ipq-1),\n+                w.ptr(ibmat-ndim-1), w.ptr(izmat-npt-1), ndim, w.ptr(isl-1), w.ptr(isu-1), w.ptr(ixn-1), w.ptr(ixa-1),\n+                w.ptr(id_-1), w.ptr(ivl-1), w.ptr(iw-1));\n+    } // bobyqa\n+\n+    // ----------------------------------------------------------------------------------------\n+\n+    /**\n+     *     The arguments N, NPT, X, XL, XU, RHOBEG, RHOEND, IPRINT and MAXFUN\n+     *       are identical to the corresponding arguments in SUBROUTINE BOBYQA.\n+     *     XBASE holds a shift of origin that should reduce the contributions\n+     *       from rounding errors to values of the model and Lagrange functions.\n+     *     XPT is a two-dimensional array that holds the coordinates of the\n+     *       interpolation points relative to XBASE.\n+     *     FVAL holds the values of F at the interpolation points.\n+     *     XOPT is set to the displacement from XBASE of the trust region centre.\n+     *     GOPT holds the gradient of the quadratic model at XBASE+XOPT.\n+     *     HQ holds the explicit second derivatives of the quadratic model.\n+     *     PQ contains the parameters of the implicit second derivatives of the\n+     *       quadratic model.\n+     *     BMAT holds the last N columns of H.\n+     *     ZMAT holds the factorization of the leading NPT by NPT submatrix of H,\n+     *       this factorization being ZMAT times ZMAT^T, which provides both the\n+     *       correct rank and positive semi-definiteness.\n+     *     NDIM is the first dimension of BMAT and has the value NPT+N.\n+     *     SL and SU hold the differences XL-XBASE and XU-XBASE, respectively.\n+     *       All the components of every XOPT are going to satisfy the bounds\n+     *       SL(I) .LEQ. XOPT(I) .LEQ. SU(I), with appropriate equalities when\n+     *       XOPT is on a constraint boundary.\n+     *     XNEW is chosen by SUBROUTINE TRSBOX or ALTMOV. Usually XBASE+XNEW is the\n+     *       vector of variables for the next call of CALFUN. XNEW also satisfies\n+     *       the SL and SU constraints in the way that has just been mentioned.\n+     *     XALT is an alternative to XNEW, chosen by ALTMOV, that may replace XNEW\n+     *       in order to increase the denominator in the updating of UPDATE.\n+     *     D is reserved for a trial step from XOPT, which is usually XNEW-XOPT.\n+     *     VLAG contains the values of the Lagrange functions at a new point X.\n+     *       They are part of a product that requires VLAG to be of length NDIM.\n+     *     W is a one-dimensional array that is used for working space. Its length\n+     *       must be at least 3*NDIM = 3*(NPT+N).\n+     *\n+     * @param n\n+     * @param npt\n+     * @param x\n+     * @param xl\n+     * @param xu\n+     * @param rhobeg\n+     * @param rhoend\n+     * @param maxfun\n+     * @param xbase\n+     * @param xpt\n+     * @param fval\n+     * @param xopt\n+     * @param gopt\n+     * @param hq\n+     * @param pq\n+     * @param bmat\n+     * @param zmat\n+     * @param ndim\n+     * @param sl\n+     * @param su\n+     * @param xnew\n+     * @param xalt\n+     * @param d__\n+     * @param vlag\n+     * @param w\n+     * @return\n+     */\n+    private double bobyqb(\n+            int n,\n+            int npt,\n+            ScopedPtr x,\n+            ScopedPtr xl,\n+            ScopedPtr xu,\n+            double rhobeg,\n+            double rhoend,\n+            int maxfun,\n+            ScopedPtr xbase, \n+            ScopedPtr xpt,\n+            ScopedPtr fval,\n+            ScopedPtr xopt,\n+            ScopedPtr gopt,\n+            ScopedPtr hq,\n+            ScopedPtr pq,\n+            ScopedPtr bmat,\n+            ScopedPtr zmat,\n+            int ndim,\n+            ScopedPtr sl,\n+            ScopedPtr su, \n+            ScopedPtr xnew,\n+            ScopedPtr xalt,\n+            ScopedPtr d__,\n+            ScopedPtr vlag,\n+            ScopedPtr w\n+    ) {\n+        // System generated locals\n+        int xpt_dim1, bmat_dim1, zmat_dim1; \n+        int i__1, i__2, i__3;\n+        double d__1, d__2, d__3, d__4;\n+\n+        // Local variables\n+        double f = 0;\n+        int i__, j, k, ih, jj, nh, ip, jp;\n+        double dx;\n+        int np;\n+        double den = 0, one = 0, ten = 0, rho = 0, sum = 0, two = 0, diff = 0, half = 0, beta = 0, gisq = 0;\n+        int knew = 0;\n+        double temp, suma, sumb, bsum, fopt;\n+        int nptm;\n+        double zero, curv;\n+        int ksav;\n+        double gqsq = 0, dist = 0, sumw = 0, sumz = 0, diffa = 0, diffb = 0, diffc = 0, hdiag = 0;\n+        int kbase;\n+        double delta = 0, adelt = 0, denom = 0, fsave = 0, bdtol = 0, delsq = 0;\n+        int nresc, nfsav;\n+        double ratio = 0, dnorm = 0, vquad = 0, pqold = 0, tenth = 0;\n+        int itest;\n+        double sumpq, scaden;\n+        double errbig, fracsq, biglsq, densav;\n+        double bdtest;\n+        double frhosq;\n+        double distsq = 0;\n+        int ntrits;\n+        double xoptsq;\n+\n+        // Set some constants.\n+        // Parameter adjustments\n+        zmat_dim1 = npt;\n+        xpt_dim1 = npt;\n+        bmat_dim1 = ndim;\n+ \n+        // Function Body\n+        half = .5;\n+        one = 1.;\n+        ten = 10.;\n+        tenth = .1;\n+        two = 2.;\n+        zero = 0.;\n+        np = n + 1;\n+        nptm = npt - np;\n+        nh = n * np / 2;\n+\n+        // The call of PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n+        // BMAT and ZMAT for the first iteration, with the corresponding values of\n+        // of NF and KOPT, which are the number of calls of CALFUN so far and the\n+        // index of the interpolation point at the trust region centre. Then the\n+        // initial XOPT is set too. The branch to label 720 occurs if MAXFUN is\n+        // less than NPT. GOPT will be updated if KOPT is different from KBASE.\n+\n+        IntRef nf = new IntRef(0);\n+        IntRef kopt = new IntRef(0);\n+        DoubleRef dsq = new DoubleRef(0);\n+        DoubleRef crvmin = new DoubleRef(0);\n+        DoubleRef cauchy = new DoubleRef(0);\n+        DoubleRef alpha = new DoubleRef(0);\n+\n+        prelim(n, npt, x, xl, xu, rhobeg, maxfun, xbase,\n+                xpt, fval, gopt, hq, pq, bmat,\n+                zmat, ndim, sl, su, nf, kopt);\n+        xoptsq = zero;\n+        i__1 = n;\n+        for (i__ = 1; i__ <= i__1; i__++) {\n+            xopt.set(i__, xpt.get(kopt.value + i__ * xpt_dim1));\n+            // Computing 2nd power\n+            d__1 = xopt.get(i__);\n+            xoptsq += d__1 * d__1;\n+        }\n+        fsave = fval.get(1);\n+        if (nf.value < npt) { // should not happen\n+            throw new RuntimeException(\"Return from BOBYQA because the objective function has been called \" +\n+                    nf.value + \" times.\");\n+        }\n+        kbase = 1;\n+\n+        // Complete the settings that are required for the iterative procedure.\n+\n+        rho = rhobeg;\n+        delta = rho;\n+        nresc = nf.value;\n+        ntrits = 0;\n+        diffa = zero;\n+        diffb = zero;\n+        itest = 0;\n+        nfsav = nf.value;\n+\n+        // Update GOPT if necessary before the first iteration and after each\n+        // call of RESCUE that makes a call of CALFUN.\n+\n+        int state = 20;\n+        for(;;) switch (state) {\n+        case 20: {\n+            if (kopt.value != kbase) {\n+                ih = 0;\n+                i__1 = n;\n+                for (j = 1; j <= i__1; j++) {\n+                    i__2 = j;\n+                    for (i__ = 1; i__ <= i__2; i__++) {\n+                        ++ih;\n+                        if (i__ < j) {\n+                            gopt.set(j,  gopt.get(j) + hq.get(ih) * xopt.get(i__));\n+                        }\n+                        gopt.set(i__,  gopt.get(i__) + hq.get(ih) * xopt.get(j));\n+                    }\n+                }\n+                if (nf.value > npt) {\n+                    i__2 = npt;\n+                    for (k = 1; k <= i__2; k++) {\n+                        temp = zero;\n+                        i__1 = n;\n+                        for (j = 1; j <= i__1; j++) {\n+                            temp += xpt.get(k + j * xpt_dim1) * xopt.get(j);\n+                        }\n+                        temp = pq.get(k) * temp;\n+                        i__1 = n;\n+                        for (i__ = 1; i__ <= i__1; i__++) {\n+                            gopt.set(i__, gopt.get(i__) + temp * xpt.get(k + i__ * xpt_dim1));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Generate the next point in the trust region that provides a small value\n+            // of the quadratic model subject to the constraints on the variables.\n+            // The int NTRITS is set to the number \"trust region\" iterations that\n+            // have occurred since the last \"alternative\" iteration. If the length\n+            // of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to\n+            // label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW.\n+\n+        }\n+        case 60: {\t        \n+            trsbox(n, npt, xpt, xopt, gopt, hq, pq, sl,\n+                    su, delta, xnew, d__, w, w.ptr(np-1), w.ptr(np+n-1),\n+                    w.ptr(np + (n << 1)-1), w.ptr(np + n*3-1), dsq, crvmin);\n+\n+            // Computing MIN\n+            d__1 = delta;\n+            d__2 = Math.sqrt(dsq.value);\n+            dnorm = Math.min(d__1,d__2);\n+            if (dnorm < half * rho) {\n+                ntrits = -1;\n+                // Computing 2nd power\n+                d__1 = ten * rho;\n+                distsq = d__1 * d__1;\n+                if (nf.value <= nfsav + 2) {\n+                    state = 650; break;\n+                }\n+\n+                // The following choice between labels 650 and 680 depends on whether or\n+                // not our work with the current RHO seems to be complete. Either RHO is\n+                // decreased or termination occurs if the errors in the quadratic model at\n+                // the last three interpolation points compare favourably with predictions\n+                // of likely improvements to the model within distance HALF*RHO of XOPT.\n+\n+                // Computing MAX\n+                d__1 = Math.max(diffa,diffb);\n+                errbig = Math.max(d__1,diffc);\n+                frhosq = rho * .125 * rho;\n+                if (crvmin.value > zero && errbig > frhosq * crvmin.value) {\n+                    state = 650; break;\n+                }\n+                bdtol = errbig / rho;\n+                i__1 = n;\n+                for (j = 1; j <= i__1; j++) {\n+                    bdtest = bdtol;\n+                    if (xnew.get(j) == sl.get(j)) {\n+                        bdtest = w.get(j);\n+                    }\n+                    if (xnew.get(j) == su.get(j)) {\n+                        bdtest = -w.get(j);\n+                    }\n+                    if (bdtest < bdtol) {\n+                        curv = hq.get((j + j * j) / 2);\n+                        i__2 = npt;\n+                        for (k = 1; k <= i__2; k++) {\n+                            // Computing 2nd power\n+                            d__1 = xpt.get(k + j * xpt_dim1);\n+                            curv += pq.get(k) * (d__1 * d__1);\n+                        }\n+                        bdtest += half * curv * rho;\n+                        if (bdtest < bdtol) {\n+                            state = 650; break;\n+                        }\n+                    }\n+                }\n+                state = 680; break;\n+            }\n+            ++ntrits;\n+\n+            // Severe cancellation is likely to occur if XOPT is too far from XBASE.\n+            // If the following test holds, then XBASE is shifted so that XOPT becomes\n+            // zero. The appropriate changes are made to BMAT and to the second\n+            // derivatives of the current model, beginning with the changes to BMAT\n+            // that do not depend on ZMAT. VLAG is used temporarily for working space.\n+\n+        }\n+        case 90: {\n+            if (dsq.value <= xoptsq * .001) {\n+                fracsq = xoptsq * .25;\n+                sumpq = zero;\n+                i__1 = npt;\n+                for (k = 1; k <= i__1; k++) {\n+                    sumpq += pq.get(k);\n+                    sum = -half * xoptsq;\n+                    i__2 = n;\n+                    for (i__ = 1; i__ <= i__2; i__++) {\n+                        sum += xpt.get(k + i__ * xpt_dim1) * xopt.get(i__);\n+                    }\n+                    w.set(npt + k, sum);\n+                    temp = fracsq - half * sum;\n+                    i__2 = n;\n+                    for (i__ = 1; i__ <= i__2; i__++) {\n+                        w.set(i__, bmat.get(k + i__ * bmat_dim1));\n+                        vlag.set(i__, sum * xpt.get(k + i__ * xpt_dim1) + temp * xopt.get(i__));\n+                        ip = npt + i__;\n+                        i__3 = i__;\n+                        for (j = 1; j <= i__3; j++) {\n+                            bmat.set(ip + j * bmat_dim1, bmat.get(ip + j *\n+                                    bmat_dim1) + w.get(i__) * vlag.get(j) + vlag.get(i__) * w.get(j));\n+                        }\n+                    }\n+                }\n+\n+                // Then the revisions of BMAT that depend on ZMAT are calculated.\n+\n+                i__3 = nptm;\n+                for (jj = 1; jj <= i__3; jj++) {\n+                    sumz = zero;\n+                    sumw = zero;\n+                    i__2 = npt;\n+                    for (k = 1; k <= i__2; k++) {\n+                        sumz += zmat.get(k + jj * zmat_dim1);\n+                        vlag.set(k, w.get(npt + k) * zmat.get(k + jj * zmat_dim1));\n+                        sumw += vlag.get(k);\n+                    }\n+                    i__2 = n;\n+                    for (j = 1; j <= i__2; j++) {\n+                        sum = (fracsq * sumz - half * sumw) * xopt.get(j);\n+                        i__1 = npt;\n+                        for (k = 1; k <= i__1; k++) {\n+                            sum += vlag.get(k) * xpt.get(k + j * xpt_dim1);\n+                        }\n+                        w.set(j, sum);\n+                        i__1 = npt;\n+                        for (k = 1; k <= i__1; k++) {\n+                            bmat.set(k + j * bmat_dim1,  bmat.get(k + j * bmat_dim1) +\n+                                    sum * zmat.get(k + jj * zmat_dim1));\n+                        }\n+                    }\n+                    i__1 = n;\n+                    for (i__ = 1; i__ <= i__1; i__++) {\n+                        ip = i__ + npt;\n+                        temp = w.get(i__);\n+                        i__2 = i__;\n+                        for (j = 1; j <= i__2; j++) {\n+                            bmat.set(ip + j * bmat_dim1,  bmat.get(ip + j * bmat_dim1) +\n+                                    temp * w.get(j));\n+                        }\n+                    }\n+                }\n+\n+                // The following instructions complete the shift, including the changes\n+                // to the second derivative parameters of the quadratic model.\n+\n+                ih = 0;\n+                i__2 = n;\n+                for (j = 1; j <= i__2; j++) {\n+                    w.set(j, -half * sumpq * xopt.get(j));\n+                    i__1 = npt;\n+                    for (k = 1; k <= i__1; k++) {\n+                        w.set(j, w.get(j) + pq.get(k) * xpt.get(k + j * xpt_dim1));\n+                        xpt.set(k + j * xpt_dim1, xpt.get(k + j * xpt_dim1) - xopt.get(j));\n+                    }\n+                    i__1 = j;\n+                    for (i__ = 1; i__ <= i__1; i__++) {\n+                        ++ih;\n+                        hq.set(ih, hq.get(ih) + w.get(i__) * xopt.get(j) + xopt.get(i__) * w.get(j));\n+                        bmat.set(npt + i__ + j * bmat_dim1, bmat.get(npt + j + i__ * bmat_dim1));\n+                    }\n+                }\n+                i__1 = n;\n+                for (i__ = 1; i__ <= i__1; i__++) {\n+                    xbase.set(i__, xbase.get(i__) + xopt.get(i__));\n+                    xnew.set(i__, xnew.get(i__) - xopt.get(i__));\n+                    sl.set(i__, sl.get(i__) - xopt.get(i__));\n+                    su.set(i__, su.get(i__) - xopt.get(i__));\n+                    xopt.set(i__, zero);\n+                }\n+                xoptsq = zero;\n+            }\n+            if (ntrits == 0) {\n+                state = 210; break;\n+            }\n+            state = 230; break;\n+\n+            // XBASE is also moved to XOPT by a call of RESCUE. This calculation is\n+            // more expensive than the previous shift, because new matrices BMAT and\n+            // ZMAT are generated from scratch, which may include the replacement of\n+            // interpolation points whose positions seem to be causing near linear\n+            // dependence in the interpolation conditions. Therefore RESCUE is called\n+            // only if rounding errors have reduced by at least a factor of two the\n+            // denominator of the formula for updating the H matrix. It provides a\n+            // useful safeguard, but is not invoked in most applications of BOBYQA.\n+\n+        }\n+        case 190: {\n+            nfsav = nf.value;\n+            kbase = kopt.value;\n+\n+            rescue(n, npt, xl, xu, maxfun, xbase, xpt,\n+                    fval, xopt, gopt, hq, pq, bmat,\n+                    zmat, ndim,  sl, su, nf, delta,\n+                    kopt, vlag, w.ptr(-2), w.ptr(n+np-1), w.ptr(ndim+np-1));\n+\n+            // XOPT is updated now in case the branch below to label 720 is taken.\n+            // Any updating of GOPT occurs after the branch below to label 20, which\n+            // leads to a trust region iteration as does the branch to label 60.\n+\n+            xoptsq = zero;\n+            if (kopt.value != kbase) {\n+                i__1 = n;\n+                for (i__ = 1; i__ <= i__1; i__++) {\n+                    xopt.set(i__, xpt.get(kopt.value + i__ * xpt_dim1));\n+                    // Computing 2nd power\n+                    d__1 = xopt.get(i__);\n+                    xoptsq += d__1 * d__1;\n+                }\n+            }\n+            nresc = nf.value;\n+            if (nfsav < nf.value) {\n+                nfsav = nf.value;\n+                state = 20; break;\n+            }\n+            if (ntrits > 0) {\n+                state = 60; break;\n+            }\n+        }\n+        case 210: {\n+            // Pick two alternative vectors of variables, relative to XBASE, that\n+            // are suitable as new positions of the KNEW-th interpolation point.\n+            // Firstly, XNEW is set to the point on a line through XOPT and another\n+            // interpolation point that minimizes the predicted value of the next\n+            // denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL\n+            // and SU bounds. Secondly, XALT is set to the best feasible point on\n+            // a constrained version of the Cauchy step of the KNEW-th Lagrange\n+            // function, the corresponding value of the square of this function\n+            // being returned in CAUCHY. The choice between these alternatives is\n+            // going to be made when the denominator is calculated.\n+\n+            altmov(n, npt, xpt, xopt,\n+                    bmat, zmat,\n+                    ndim, sl, su, kopt.value, knew, adelt, xnew, xalt, alpha, cauchy,\n+                    w, w.ptr(np-1), w.ptr(ndim));\n+            i__1 = n;\n+            for (i__ = 1; i__ <= i__1; i__++) {\n+                d__.set(i__, xnew.get(i__) - xopt.get(i__));\n+            }\n+\n+            // Calculate VLAG and BETA for the current choice of D. The scalar\n+            // product of D with XPT(K,.) is going to be held in W(NPT+K) for\n+            // use when VQUAD is calculated.\n+\n+        }\n+        case 230: {\n+            i__1 = npt;\n+            for (k = 1; k <= i__1; k++) {\n+                suma = zero;\n+                sumb = zero;\n+                sum = zero;\n+                i__2 = n;\n+                for (j = 1; j <= i__2; j++) {\n+                    suma += xpt.get(k + j * xpt_dim1) * d__.get(j);\n+                    sumb += xpt.get(k + j * xpt_dim1) * xopt.get(j);\n+                    sum += bmat.get(k + j * bmat_dim1) * d__.get(j);\n+                }\n+                w.set(k, suma * (half * suma + sumb));\n+                vlag.set(k, sum);\n+                w.set(npt + k, suma);\n+            }\n+            beta = zero;\n+            i__1 = nptm;\n+            for (jj = 1; jj <= i__1; jj++) {\n+                sum = zero;\n+                i__2 = npt;\n+                for (k = 1; k <= i__2; k++) {\n+                    sum += zmat.get(k + jj * zmat_dim1) * w.get(k);\n+                }\n+                beta -= sum * sum;\n+                i__2 = npt;\n+                for (k = 1; k <= i__2; k++) {\n+                    vlag.set(k, vlag.get(k) + sum * zmat.get(k + jj * zmat_dim1));\n+                }\n+            }\n+            dsq.value = zero;\n+            bsum = zero;\n+            dx = zero;\n+            i__2 = n;\n+            for (j = 1; j <= i__2; j++) {\n+                // Computing 2nd power\n+                d__1 = d__.get(j);\n+                dsq.value += d__1 * d__1;\n+                sum = zero;\n+                i__1 = npt;\n+                for (k = 1; k <= i__1; k++) {\n+                    sum += w.get(k) * bmat.get(k + j * bmat_dim1);\n+                }\n+                bsum += sum * d__.get(j);\n+                jp = npt + j;\n+                i__1 = n;\n+                for (i__ = 1; i__ <= i__1; i__++) {\n+                    sum += bmat.get(jp + i__ * bmat_dim1) * d__.get(i__);\n+                }\n+                vlag.set(jp, sum);\n+                bsum += sum * d__.get(j);\n+                dx += d__.get(j) * xopt.get(j);\n+            }\n+            beta = dx * dx + dsq.value * (xoptsq + dx + dx + half * dsq.value) + beta - bsum;\n+            vlag.set(kopt.value, vlag.get(kopt.value) + one);\n+\n+            // If NTRITS is zero, the denominator may be increased by replacing\n+            // the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if\n+            // rounding errors have damaged the chosen denominator.\n+\n+            if (ntrits == 0) {\n+                // Computing 2nd power\n+                d__1 = vlag.get(knew);\n+                denom = d__1 * d__1 + alpha.value * beta;\n+                if (denom < cauchy.value && cauchy.value > zero) {\n+                    i__2 = n;\n+                    for (i__ = 1; i__ <= i__2; i__++) {\n+                        xnew.set(i__, xalt.get(i__));\n+                        d__.set(i__, xnew.get(i__) - xopt.get(i__));\n+                    }\n+                    cauchy.value = zero;\n+                    state = 230; break;\n+                }\n+                // Computing 2nd power\n+                d__1 = vlag.get(knew);\n+                if (denom <= half * (d__1 * d__1)) {\n+                    if (nf.value > nresc) {\n+                        state = 190; break;\n+                    }\n+                    throw new MathIllegalStateException(LocalizedFormats.TOO_MUCH_CANCELLATION, vquad);\n+                }\n+\n+                // Alternatively, if NTRITS is positive, then set KNEW to the index of\n+                // the next interpolation point to be deleted to make room for a trust\n+                // region step. Again RESCUE may be called if rounding errors have damaged\n+                // the chosen denominator, which is the reason for attempting to select\n+                // KNEW before calculating the next value of the objective function.\n+\n+            } else {\n+                delsq = delta * delta;\n+                scaden = zero;\n+                biglsq = zero;\n+                knew = 0;\n+                i__2 = npt;\n+                for (k = 1; k <= i__2; k++) {\n+                    if (k == kopt.value) {\n+                        continue;\n+                    }\n+                    hdiag = zero;\n+                    i__1 = nptm;\n+                    for (jj = 1; jj <= i__1; jj++) {\n+                        // Computing 2nd power\n+                        d__1 = zmat.get(k + jj * zmat_dim1);\n+                        hdiag += d__1 * d__1;\n+                    }\n+                    // Computing 2nd power\n+                    d__1 = vlag.get(k);\n+                    den = beta * hdiag + d__1 * d__1;\n+                    distsq = zero;\n+                    i__1 = n;\n+                    for (j = 1; j <= i__1; j++) {\n+                        // Computing 2nd power\n+                        d__1 = xpt.get(k + j * xpt_dim1) - xopt.get(j);\n+                        distsq += d__1 * d__1;\n+                    }\n+                    // Computing MAX\n+                    // Computing 2nd power\n+                    d__3 = distsq / delsq;\n+                    d__1 = one;\n+                    d__2 = d__3 * d__3;\n+                    temp = Math.max(d__1,d__2);\n+                    if (temp * den > scaden) {\n+                        scaden = temp * den;\n+                        knew = k;\n+                        denom = den;\n+                    }\n+                    // Computing MAX\n+                    // Computing 2nd power\n+                    d__3 = vlag.get(k);\n+                    d__1 = biglsq;\n+                    d__2 = temp * (d__3 * d__3);\n+                    biglsq = Math.max(d__1,d__2);\n+                }\n+                if (scaden <= half * biglsq) {\n+                    if (nf.value > nresc) {\n+                        state = 190; break;\n+                    }\n+                    throw new MathIllegalStateException(LocalizedFormats.TOO_MUCH_CANCELLATION, vquad);\n+                }\n+            }\n+\n+            // Put the variables for the next calculation of the objective function\n+            //   in XNEW, with any adjustments for the bounds.\n+\n+            // Calculate the value of the objective function at XBASE+XNEW, unless\n+            //   the limit on the number of calculations of F has been reached.\n+\n+        }\n+        case 360: {\n+            i__2 = n;\n+            for (i__ = 1; i__ <= i__2; i__++) {\n+                // Computing MIN\n+                // Computing MAX\n+                d__3 = xl.get(i__);\n+                d__4 = xbase.get(i__) + xnew.get(i__);\n+                d__1 = Math.max(d__3,d__4);\n+                d__2 = xu.get(i__);\n+                x.set(i__, Math.min(d__1,d__2));\n+                if (xnew.get(i__) == sl.get(i__)) {\n+                    x.set(i__, xl.get(i__));\n+                }\n+                if (xnew.get(i__) == su.get(i__)) {\n+                    x.set(i__, xu.get(i__));\n+                }\n+            }\n+            if (nf.value > maxfun) { // should not happen,\n+                // TooManyEvaluationsException is thrown before\n+                throw new RuntimeException(\"Return from BOBYQA because the objective function has been called max_f_evals times.\");\n+            }\n+            nf.value++;\n+            f = computeObjectiveValue(x.getAll());\n+            if (!isMinimize)\n+                f = -f;\n+            if (ntrits == -1) {\n+                fsave = f;\n+                state = 720; break;\n+            }\n+\n+            // Use the quadratic model to predict the change in F due to the step D,\n+            //   and set DIFF to the error of this prediction.\n+\n+            fopt = fval.get(kopt.value);\n+            vquad = zero;\n+            ih = 0;\n+            i__2 = n;\n+            for (j = 1; j <= i__2; j++) {\n+                vquad += d__.get(j) * gopt.get(j);\n+                i__1 = j;\n+                for (i__ = 1; i__ <= i__1; i__++) {\n+                    ++ih;\n+                    temp = d__.get(i__) * d__.get(j);\n+                    if (i__ == j) {\n+                        temp = half * temp;\n+                    }\n+                    vquad += hq.get(ih) * temp;\n+                }\n+            }\n+            i__1 = npt;\n+            for (k = 1; k <= i__1; k++) {\n+                // Computing 2nd power\n+                d__1 = w.get(npt + k);\n+                vquad += half * pq.get(k) * (d__1 * d__1);\n+            }\n+            diff = f - fopt - vquad;\n+            diffc = diffb;\n+            diffb = diffa;\n+            diffa = Math.abs(diff);\n+            if (dnorm > rho) {\n+                nfsav = nf.value;\n+            }\n+\n+            // Pick the next value of DELTA after a trust region step.\n+\n+            if (ntrits > 0) {\n+                if (vquad >= zero) {\n+                    throw new MathIllegalStateException(LocalizedFormats.TRUST_REGION_STEP_FAILED, vquad);\n+                }\n+                ratio = (f - fopt) / vquad;\n+                if (ratio <= tenth) {\n+                    // Computing MIN\n+                    d__1 = half * delta;\n+                    delta = Math.min(d__1,dnorm);\n+                } else if (ratio <= .7) {\n+                    // Computing MAX\n+                    d__1 = half * delta;\n+                    delta = Math.max(d__1,dnorm);\n+                } else {\n+                    // Computing MAX\n+                    d__1 = half * delta;\n+                    d__2 = dnorm + dnorm;\n+                    delta = Math.max(d__1,d__2);\n+                }\n+                if (delta <= rho * 1.5) {\n+                    delta = rho;\n+                }\n+\n+                // Recalculate KNEW and DENOM if the new F is less than FOPT.\n+\n+                if (f < fopt) {\n+                    ksav = knew;\n+                    densav = denom;\n+                    delsq = delta * delta;\n+                    scaden = zero;\n+                    biglsq = zero;\n+                    knew = 0;\n+                    i__1 = npt;\n+                    for (k = 1; k <= i__1; k++) {\n+                        hdiag = zero;\n+                        i__2 = nptm;\n+                        for (jj = 1; jj <= i__2; jj++) {\n+                            // Computing 2nd power\n+                            d__1 = zmat.get(k + jj * zmat_dim1);\n+                            hdiag += d__1 * d__1;\n+                        }\n+                        // Computing 2nd power\n+                        d__1 = vlag.get(k);\n+                        den = beta * hdiag + d__1 * d__1;\n+                        distsq = zero;\n+                        i__2 = n;\n+                        for (j = 1; j <= i__2; j++) {\n+                            // Computing 2nd power\n+                            d__1 = xpt.get(k + j * xpt_dim1) - xnew.get(j);\n+                            distsq += d__1 * d__1;\n+                        }\n+                        // Computing MAX\n+                        // Computing 2nd power\n+                        d__3 = distsq / delsq;\n+                        d__1 = one;\n+                        d__2 = d__3 * d__3;\n+                        temp = Math.max(d__1,d__2);\n+                        if (temp * den > scaden) {\n+                            scaden = temp * den;\n+                            knew = k;\n+                            denom = den;\n+                        }\n+                        // Computing MAX\n+                        // Computing 2nd power\n+                        d__3 = vlag.get(k);\n+                        d__1 = biglsq;\n+                        d__2 = temp * (d__3 * d__3);\n+                        biglsq = Math.max(d__1,d__2);\n+                    }\n+                    if (scaden <= half * biglsq) {\n+                        knew = ksav;\n+                        denom = densav;\n+                    }\n+                }\n+            }\n+\n+            // Update BMAT and ZMAT, so that the KNEW-th interpolation point can be\n+            // moved. Also update the second derivative terms of the model.\n+\n+            update(n, npt, bmat, zmat, ndim, vlag,\n+                    beta, denom, knew, w);\n+\n+            ih = 0;\n+            pqold = pq.get(knew);\n+            pq.set(knew, zero);\n+            i__1 = n;\n+            for (i__ = 1; i__ <= i__1; i__++) {\n+                temp = pqold * xpt.get(knew + i__ * xpt_dim1);\n+                i__2 = i__;\n+                for (j = 1; j <= i__2; j++) {\n+                    ++ih;\n+                    hq.set(ih, hq.get(ih) + temp * xpt.get(knew + j * xpt_dim1));\n+                }\n+            }\n+            i__2 = nptm;\n+            for (jj = 1; jj <= i__2; jj++) {\n+                temp = diff * zmat.get(knew + jj * zmat_dim1);\n+                i__1 = npt;\n+                for (k = 1; k <= i__1; k++) {\n+                    pq.set(k, pq.get(k) + temp * zmat.get(k + jj * zmat_dim1));\n+                }\n+            }\n+\n+            // Include the new interpolation point, and make the changes to GOPT at\n+            // the old XOPT that are caused by the updating of the quadratic model.\n+\n+            fval.set(knew,  f);\n+            i__1 = n;\n+            for (i__ = 1; i__ <= i__1; i__++) {\n+                xpt.set(knew + i__ * xpt_dim1, xnew.get(i__));\n+                w.set(i__, bmat.get(knew + i__ * bmat_dim1));\n+            }\n+            i__1 = npt;\n+            for (k = 1; k <= i__1; k++) {\n+                suma = zero;\n+                i__2 = nptm;\n+                for (jj = 1; jj <= i__2; jj++) {\n+                    suma += zmat.get(knew + jj * zmat_dim1) * zmat.get(k + jj * zmat_dim1);\n+                }\n+                sumb = zero;\n+                i__2 = n;\n+                for (j = 1; j <= i__2; j++) {\n+                    sumb += xpt.get(k + j * xpt_dim1) * xopt.get(j);\n+                }\n+                temp = suma * sumb;\n+                i__2 = n;\n+                for (i__ = 1; i__ <= i__2; i__++) {\n+                    w.set(i__, w.get(i__) + temp * xpt.get(k + i__ * xpt_dim1));\n+                }\n+            }\n+            i__2 = n;\n+            for (i__ = 1; i__ <= i__2; i__++) {\n+                gopt.set(i__, gopt.get(i__) + diff * w.get(i__));\n+            }\n+\n+            // Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT.\n+\n+            if (f < fopt) {\n+                kopt.value = knew;\n+                xoptsq = zero;\n+                ih = 0;\n+                i__2 = n;\n+                for (j = 1; j <= i__2; j++) {\n+                    xopt.set(j, xnew.get(j));\n+                    // Computing 2nd power\n+                    d__1 = xopt.get(j);\n+                    xoptsq += d__1 * d__1;\n+                    i__1 = j;\n+                    for (i__ = 1; i__ <= i__1; i__++) {\n+                        ++ih;\n+                        if (i__ < j) {\n+                            gopt.set(j, gopt.get(j) + hq.get(ih) * d__.get(i__));\n+                        }\n+                        gopt.set(i__, gopt.get(i__) + hq.get(ih) * d__.get(j));\n+                    }\n+                }\n+                i__1 = npt;\n+                for (k = 1; k <= i__1; k++) {\n+                    temp = zero;\n+                    i__2 = n;\n+                    for (j = 1; j <= i__2; j++) {\n+                        temp += xpt.get(k + j * xpt_dim1) * d__.get(j);\n+                    }\n+                    temp = pq.get(k) * temp;\n+                    i__2 = n;\n+                    for (i__ = 1; i__ <= i__2; i__++) {\n+                        gopt.set(i__, gopt.get(i__) + temp * xpt.get(k + i__ * xpt_dim1));\n+                    }\n+                }\n+            }\n+\n+            // Calculate the parameters of the least Frobenius norm interpolant to\n+            // the current data, the gradient of this interpolant at XOPT being put\n+            // into VLAG(NPT+I), I=1,2,...,N.\n+\n+            if (ntrits > 0) {\n+                i__2 = npt;\n+                for (k = 1; k <= i__2; k++) {\n+                    vlag.set(k, fval.get(k) - fval.get(kopt.value));\n+                    w.set(k, zero);\n+                }\n+                i__2 = nptm;\n+                for (j = 1; j <= i__2; j++) {\n+                    sum = zero;\n+                    i__1 = npt;\n+                    for (k = 1; k <= i__1; k++) {\n+                        sum += zmat.get(k + j * zmat_dim1) * vlag.get(k);\n+                    }\n+                    i__1 = npt;\n+                    for (k = 1; k <= i__1; k++) {\n+                        w.set(k, w.get(k) + sum * zmat.get(k + j * zmat_dim1));\n+                    }\n+                }\n+                i__1 = npt;\n+                for (k = 1; k <= i__1; k++) {\n+                    sum = zero;\n+                    i__2 = n;\n+                    for (j = 1; j <= i__2; j++) {\n+                        sum += xpt.get(k + j * xpt_dim1) * xopt.get(j);\n+                    }\n+                    w.set(k + npt, w.get(k));\n+                    w.set(k, sum * w.get(k));\n+                }\n+                gqsq = zero;\n+                gisq = zero;\n+                i__1 = n;\n+                for (i__ = 1; i__ <= i__1; i__++) {\n+                    sum = zero;\n+                    i__2 = npt;\n+                    for (k = 1; k <= i__2; k++) {\n+                        sum = sum + bmat.get(k + i__ * bmat_dim1) *\n+                        vlag.get(k) + xpt.get(k + i__ * xpt_dim1) * w.get(k);\n+                    }\n+                    if (xopt.get(i__) == sl.get(i__)) {\n+                        // Computing MIN\n+                        d__2 = zero;\n+                        d__3 = gopt.get(i__);\n+                        // Computing 2nd power\n+                        d__1 = Math.min(d__2,d__3);\n+                        gqsq += d__1 * d__1;\n+                        // Computing 2nd power\n+                        d__1 = Math.min(zero,sum);\n+                        gisq += d__1 * d__1;\n+                    } else if (xopt.get(i__) == su.get(i__)) {\n+                        // Computing MAX\n+                        d__2 = zero;\n+                        d__3 = gopt.get(i__);\n+                        // Computing 2nd power\n+                        d__1 = Math.max(d__2,d__3);\n+                        gqsq += d__1 * d__1;\n+                        // Computing 2nd power\n+                        d__1 = Math.max(zero,sum);\n+                        gisq += d__1 * d__1;\n+                    } else {\n+                        // Computing 2nd power\n+                        d__1 = gopt.get(i__);\n+                        gqsq += d__1 * d__1;\n+                        gisq += sum * sum;\n+                    }\n+                    vlag.set(npt + i__, sum);\n+                }\n+\n+                // Test whether to replace the new quadratic model by the least Frobenius\n+                // norm interpolant, making the replacement if the test is satisfied.\n+\n+                ++itest;\n+                if (gqsq < ten * gisq) {\n+                    itest = 0;\n+                }\n+                if (itest >= 3) {\n+                    i__1 = Math.max(npt,nh);\n+                    for (i__ = 1; i__ <= i__1; i__++) {\n+                        if (i__ <= n) {\n+                            gopt.set(i__, vlag.get(npt + i__));\n+                        }\n+                        if (i__ <= npt) {\n+                            pq.set(i__, w.get(npt + i__));\n+                        }\n+                        if (i__ <= nh) {\n+                            hq.set(i__, zero);\n+                        }\n+                        itest = 0;\n+                    }\n+                }\n+            }\n+\n+            // If a trust region step has provided a sufficient decrease in F, then\n+            // branch for another trust region calculation. The case NTRITS=0 occurs\n+            // when the new interpolation point was reached by an alternative step.\n+\n+            if (ntrits == 0) {\n+                state = 60; break;\n+            }\n+            if (f <= fopt + tenth * vquad) {\n+                state = 60; break;\n+            }\n+\n+            // Alternatively, find out if the interpolation points are close enough\n+            //   to the best point so far.\n+\n+            // Computing MAX\n+            // Computing 2nd power\n+            d__3 = two * delta;\n+            // Computing 2nd power\n+            d__4 = ten * rho;\n+            d__1 = d__3 * d__3;\n+            d__2 = d__4 * d__4;\n+            distsq = Math.max(d__1,d__2);\n+        }\n+        case 650: {\n+            knew = 0;\n+            i__1 = npt;\n+            for (k = 1; k <= i__1; k++) {\n+                sum = zero;\n+                i__2 = n;\n+                for (j = 1; j <= i__2; j++) {\n+                    // Computing 2nd power\n+                    d__1 = xpt.get(k + j * xpt_dim1) - xopt.get(j);\n+                    sum += d__1 * d__1;\n+                }\n+                if (sum > distsq) {\n+                    knew = k;\n+                    distsq = sum;\n+                }\n+            }\n+\n+            // If KNEW is positive, then ALTMOV finds alternative new positions for\n+            // the KNEW-th interpolation point within distance ADELT of XOPT. It is\n+            // reached via label 90. Otherwise, there is a branch to label 60 for\n+            // another trust region iteration, unless the calculations with the\n+            // current RHO are complete.\n+\n+            if (knew > 0) {\n+                dist = Math.sqrt(distsq);\n+                if (ntrits == -1) {\n+                    // Computing MIN\n+                    d__1 = tenth * delta;\n+                    d__2 = half * dist;\n+                    delta = Math.min(d__1,d__2);\n+                    if (delta <= rho * 1.5) {\n+                        delta = rho;\n+                    }\n+                }\n+                ntrits = 0;\n+                // Computing MAX\n+                // Computing MIN\n+                d__2 = tenth * dist;\n+                d__1 = Math.min(d__2,delta);\n+                adelt = Math.max(d__1,rho);\n+                dsq.value = adelt * adelt;\n+                state = 90; break;\n+            }\n+            if (ntrits == -1) {\n+                state = 680; break;\n+            }\n+            if (ratio > zero) {\n+                state = 60; break;\n+            }\n+            if (Math.max(delta,dnorm) > rho) {\n+                state = 60; break;\n+            }\n+\n+            // The calculations with the current value of RHO are complete. Pick the\n+            //   next values of RHO and DELTA.\n+        }\n+        case 680: {\n+            if (rho > rhoend) {\n+                delta = half * rho;\n+                ratio = rho / rhoend;\n+                if (ratio <= 16.) {\n+                    rho = rhoend;\n+                } else if (ratio <= 250.) {\n+                    rho = Math.sqrt(ratio) * rhoend;\n+                } else {\n+                    rho = tenth * rho;\n+                }\n+                delta = Math.max(delta,rho);\n+                ntrits = 0;\n+                nfsav = nf.value;\n+                state = 60; break;\n+            }\n+\n+            // Return from the calculation, after another Newton-Raphson step, if\n+            //   it is too short to have been tried before.\n+\n+            if (ntrits == -1) {\n+                state = 360; break;\n+            }\n+        }\n+        case 720: {\n+            if (fval.get(kopt.value) <= fsave) {\n+                i__1 = n;\n+                for (i__ = 1; i__ <= i__1; i__++) {\n+                    // Computing MIN\n+                    // Computing MAX\n+                    d__3 = xl.get(i__);\n+                    d__4 = xbase.get(i__) + xopt.get(i__);\n+                    d__1 = Math.max(d__3,d__4);\n+                    d__2 = xu.get(i__);\n+                    x.set(i__, Math.min(d__1,d__2));\n+                    if (xopt.get(i__) == sl.get(i__)) {\n+                        x.set(i__, xl.get(i__));\n+                    }\n+                    if (xopt.get(i__) == su.get(i__)) {\n+                        x.set(i__, xu.get(i__));\n+                    }\n+                }\n+                f = fval.get(kopt.value);\n+            }\n+            return f;\n+        }}\n+    } // bobyqb\n+\n+    // ----------------------------------------------------------------------------------------\n+\n+    /**\n+     *     The arguments N, NPT, XPT, XOPT, BMAT, ZMAT, NDIM, SL and SU all have\n+     *       the same meanings as the corresponding arguments of BOBYQB.\n+     *     KOPT is the index of the optimal interpolation point.\n+     *     KNEW is the index of the interpolation point that is going to be moved.\n+     *     ADELT is the current trust region bound.\n+     *     XNEW will be set to a suitable new position for the interpolation point\n+     *       XPT(KNEW,.). Specifically, it satisfies the SL, SU and trust region\n+     *       bounds and it should provide a large denominator in the next call of\n+     *       UPDATE. The step XNEW-XOPT from XOPT is restricted to moves along the\n+     *       straight lines through XOPT and another interpolation point.\n+     *     XALT also provides a large value of the modulus of the KNEW-th Lagrange\n+     *       function subject to the constraints that have been mentioned, its main\n+     *       difference from XNEW being that XALT-XOPT is a constrained version of\n+     *       the Cauchy step within the trust region. An exception is that XALT is\n+     *       not calculated if all components of GLAG (see below) are zero.\n+     *     ALPHA will be set to the KNEW-th diagonal element of the H matrix.\n+     *     CAUCHY will be set to the square of the KNEW-th Lagrange function at\n+     *       the step XALT-XOPT from XOPT for the vector XALT that is returned,\n+     *       except that CAUCHY is set to zero if XALT is not calculated.\n+     *     GLAG is a working space vector of length N for the gradient of the\n+     *       KNEW-th Lagrange function at XOPT.\n+     *     HCOL is a working space vector of length NPT for the second derivative\n+     *       coefficients of the KNEW-th Lagrange function.\n+     *     W is a working space vector of length 2N that is going to hold the\n+     *       constrained Cauchy step from XOPT of the Lagrange function, followed\n+     *       by the downhill version of XALT when the uphill step is calculated.\n+     *\n+     *     Set the first NPT components of W to the leading elements of the\n+     *     KNEW-th column of the H matrix.\n+     * @param n\n+     * @param npt\n+     * @param xpt\n+     * @param xopt\n+     * @param bmat\n+     * @param zmat\n+     * @param ndim\n+     * @param sl\n+     * @param su\n+     * @param kopt\n+     * @param knew\n+     * @param adelt\n+     * @param xnew\n+     * @param xalt\n+     * @param alpha\n+     * @param cauchy\n+     * @param glag\n+     * @param hcol\n+     * @param w\n+     */\n+    private void altmov(\n+            int n,\n+            int npt,\n+            ScopedPtr xpt,\n+            ScopedPtr xopt,\n+            ScopedPtr bmat,\n+            ScopedPtr zmat,\n+            int ndim, \n+            ScopedPtr sl,\n+            ScopedPtr su,\n+            int kopt,\n+            int knew,\n+            double adelt,\n+            ScopedPtr xnew,\n+            ScopedPtr xalt,\n+            DoubleRef alpha,\n+            DoubleRef cauchy,\n+            ScopedPtr glag,\n+            ScopedPtr hcol,\n+            ScopedPtr w\n+    ) {\n+        // System generated locals\n+        int xpt_dim1, bmat_dim1, zmat_dim1, i__1, i__2;\n+        double d__1, d__2, d__3, d__4;\n+\n+        // Local variables\n+        int i__, j, k;\n+        double ha, gw, one, diff, half;\n+        int ilbd, isbd;\n+        double slbd;\n+        int iubd;\n+        double vlag, subd, temp;\n+        int ksav = 0;\n+        double step = 0, zero = 0, curv = 0;\n+        int iflag;\n+        double scale = 0, csave = 0, tempa = 0, tempb = 0, tempd = 0, const__ = 0, sumin = 0, \n+        ggfree = 0;\n+        int ibdsav = 0;\n+        double dderiv = 0, bigstp = 0, predsq = 0, presav = 0, distsq = 0, stpsav = 0, wfixsq = 0, wsqsav = 0;\n+\n+\n+        zmat_dim1 = npt;\n+        xpt_dim1 = npt;\n+        bmat_dim1 = ndim;\n+\n+        // Function Body\n+        half = .5;\n+        one = 1.;\n+        zero = 0.;\n+        const__ = one + Math.sqrt(2.);\n+        i__1 = npt;\n+        for (k = 1; k <= i__1; k++) {\n+            hcol.set(k, zero);\n+        }\n+        i__1 = npt - n - 1;\n+        for (j = 1; j <= i__1; j++) {\n+            temp = zmat.get(knew + j * zmat_dim1);\n+            i__2 = npt;\n+            for (k = 1; k <= i__2; k++) {\n+                hcol.set(k, hcol.get(k) + temp * zmat.get(k + j * zmat_dim1));\n+            }\n+        }\n+        alpha.value = hcol.get(knew);\n+        ha = half * alpha.value;\n+\n+        // Calculate the gradient of the KNEW-th Lagrange function at XOPT.\n+\n+        i__2 = n;\n+        for (i__ = 1; i__ <= i__2; i__++) {\n+            glag.set(i__, bmat.get(knew + i__ * bmat_dim1));\n+        }\n+        i__2 = npt;\n+        for (k = 1; k <= i__2; k++) {\n+            temp = zero;\n+            i__1 = n;\n+            for (j = 1; j <= i__1; j++) {\n+                temp += xpt.get(k + j * xpt_dim1) * xopt.get(j);\n+            }\n+            temp = hcol.get(k) * temp;\n+            i__1 = n;\n+            for (i__ = 1; i__ <= i__1; i__++) {\n+                glag.set(i__, glag.get(i__) + temp * xpt.get(k + i__ * xpt_dim1));\n+            }\n+        }\n+\n+        // Search for a large denominator along the straight lines through XOPT\n+        // and another interpolation point. SLBD and SUBD will be lower and upper\n+        // bounds on the step along each of these lines in turn. PREDSQ will be\n+        // set to the square of the predicted denominator for each line. PRESAV\n+        // will be set to the largest admissible value of PREDSQ that occurs.\n+\n+        presav = zero;\n+        i__1 = npt;\n+        for (k = 1; k <= i__1; k++) {\n+            if (k == kopt) {\n+                continue;\n+            }\n+            dderiv = zero;\n+            distsq = zero;\n+            i__2 = n;\n+            for (i__ = 1; i__ <= i__2; i__++) {\n+                temp = xpt.get(k + i__ * xpt_dim1) - xopt.get(i__);\n+                dderiv += glag.get(i__) * temp;\n+                distsq += temp * temp;\n+            }\n+            subd = adelt / Math.sqrt(distsq);\n+            slbd = -subd;\n+            ilbd = 0;\n+            iubd = 0;\n+            sumin = Math.min(one,subd);\n+\n+            // Revise SLBD and SUBD if necessary because of the bounds in SL and SU.\n+\n+            i__2 = n;\n+            for (i__ = 1; i__ <= i__2; i__++) {\n+                temp = xpt.get(k + i__ * xpt_dim1) - xopt.get(i__);\n+                if (temp > zero) {\n+                    if (slbd * temp < sl.get(i__) - xopt.get(i__)) {\n+                        slbd = (sl.get(i__) - xopt.get(i__)) / temp;\n+                        ilbd = -i__;\n+                    }\n+                    if (subd * temp > su.get(i__) - xopt.get(i__)) {\n+                        // Computing MAX\n+                        d__1 = sumin;\n+                        d__2 = (su.get(i__) - xopt.get(i__)) / temp;\n+                        subd = Math.max(d__1,d__2);\n+                        iubd = i__;\n+                    }\n+                } else if (temp < zero) {\n+                    if (slbd * temp > su.get(i__) - xopt.get(i__)) {\n+                        slbd = (su.get(i__) - xopt.get(i__)) / temp;\n+                        ilbd = i__;\n+                    }\n+                    if (subd * temp < sl.get(i__) - xopt.get(i__)) {\n+                        // Computing MAX\n+                        d__1 = sumin;\n+                        d__2 = (sl.get(i__) - xopt.get(i__)) / temp;\n+                        subd = Math.max(d__1,d__2);\n+                        iubd = -i__;\n+                    }\n+                }\n+            }\n+\n+            // Seek a large modulus of the KNEW-th Lagrange function when the index\n+            // of the other interpolation point on the line through XOPT is KNEW.\n+\n+            if (k == knew) {\n+                diff = dderiv - one;\n+                step = slbd;\n+                vlag = slbd * (dderiv - slbd * diff);\n+                isbd = ilbd;\n+                temp = subd * (dderiv - subd * diff);\n+                if (Math.abs(temp) > Math.abs(vlag)) {\n+                    step = subd;\n+                    vlag = temp;\n+                    isbd = iubd;\n+                }\n+                tempd = half * dderiv;\n+                tempa = tempd - diff * slbd;\n+                tempb = tempd - diff * subd;\n+                if (tempa * tempb < zero) {\n+                    temp = tempd * tempd / diff;\n+                    if (Math.abs(temp) > Math.abs(vlag)) {\n+                        step = tempd / diff;\n+                        vlag = temp;\n+                        isbd = 0;\n+                    }\n+                }\n+\n+                // Search along each of the other lines through XOPT and another point.\n+\n+            } else {\n+                step = slbd;\n+                vlag = slbd * (one - slbd);\n+                isbd = ilbd;\n+                temp = subd * (one - subd);\n+                if (Math.abs(temp) > Math.abs(vlag)) {\n+                    step = subd;\n+                    vlag = temp;\n+                    isbd = iubd;\n+                }\n+                if (subd > half) {\n+                    if (Math.abs(vlag) < .25) {\n+                        step = half;\n+                        vlag = .25;\n+                        isbd = 0;\n+                    }\n+                }\n+                vlag *= dderiv;\n+            }\n+\n+            // Calculate PREDSQ for the current line search and maintain PRESAV.\n+\n+            temp = step * (one - step) * distsq;\n+            predsq = vlag * vlag * (vlag * vlag + ha * temp * temp);\n+            if (predsq > presav) {\n+                presav = predsq;\n+                ksav = k;\n+                stpsav = step;\n+                ibdsav = isbd;\n+            }\n+        }\n+\n+        // Construct XNEW in a way that satisfies the bound constraints exactly.\n+\n+        i__1 = n;\n+        for (i__ = 1; i__ <= i__1; i__++) {\n+            temp = xopt.get(i__) + stpsav * (xpt.get(ksav + i__ * xpt_dim1) - xopt.get(i__));\n+            // Computing MAX\n+            // Computing MIN\n+            d__3 = su.get(i__);\n+            d__1 = sl.get(i__);\n+            d__2 = Math.min(d__3,temp);\n+            xnew.set(i__, Math.max(d__1,d__2));\n+        }\n+        if (ibdsav < 0) {\n+            xnew.set(-ibdsav, sl.get(-ibdsav));\n+        }\n+        if (ibdsav > 0) {\n+            xnew.set(ibdsav, su.get(ibdsav));\n+        }\n+\n+        // Prepare for the iterative method that assembles the constrained Cauchy\n+        // step in W. The sum of squares of the fixed components of W is formed in\n+        // WFIXSQ, and the free components of W are set to BIGSTP.\n+\n+        bigstp = adelt + adelt;\n+        iflag = 0;\n+\n+        L100: for(;;) {\n+            wfixsq = zero;\n+            ggfree = zero;\n+            i__1 = n;\n+            for (i__ = 1; i__ <= i__1; i__++) {\n+                w.set(i__, zero);\n+                // Computing MIN\n+                d__1 = xopt.get(i__) - sl.get(i__);\n+                d__2 = glag.get(i__);\n+                tempa = Math.min(d__1,d__2);\n+                // Computing MAX\n+                d__1 = xopt.get(i__) - su.get(i__);\n+                d__2 = glag.get(i__);\n+                tempb = Math.max(d__1,d__2);\n+                if (tempa > zero || tempb < zero) {\n+                    w.set(i__, bigstp);\n+                    // Computing 2nd power\n+                    d__1 = glag.get(i__);\n+                    ggfree += d__1 * d__1;\n+                }\n+            }\n+            if (ggfree == zero) {\n+                cauchy.value = zero;\n+                return;\n+            }\n+\n+            // Investigate whether more components of W can be fixed.\n+            L120: {\n+                temp = adelt * adelt - wfixsq;\n+                if (temp > zero) {\n+                    wsqsav = wfixsq;\n+                    step = Math.sqrt(temp / ggfree);\n+                    ggfree = zero;\n+                    i__1 = n;\n+                    for (i__ = 1; i__ <= i__1; i__++) {\n+                        if (w.get(i__) == bigstp) {\n+                            temp = xopt.get(i__) - step * glag.get(i__);\n+                            if (temp <= sl.get(i__)) {\n+                                w.set(i__, sl.get(i__) - xopt.get(i__));\n+                                // Computing 2nd power\n+                                d__1 = w.get(i__);\n+                                wfixsq += d__1 * d__1;\n+                            } else if (temp >= su.get(i__)) {\n+                                w.set(i__, su.get(i__) - xopt.get(i__));\n+                                // Computing 2nd power\n+                                d__1 = w.get(i__);\n+                                wfixsq += d__1 * d__1;\n+                            } else {\n+                                // Computing 2nd power\n+                                d__1 = glag.get(i__);\n+                                ggfree += d__1 * d__1;\n+                            }\n+                        }\n+                    }\n+                    if (!(wfixsq > wsqsav && ggfree > zero)) {\n+                        break L120;\n+                    }\n+                }} // end L120\n+\n+            // Set the remaining free components of W and all components of XALT,\n+            // except that W may be scaled later.\n+\n+            gw = zero;\n+            i__1 = n;\n+            for (i__ = 1; i__ <= i__1; i__++) {\n+                if (w.get(i__) == bigstp) {\n+                    w.set(i__, -step * glag.get(i__));\n+                    // Computing MAX\n+                    // Computing MIN\n+                    d__3 = su.get(i__);\n+                    d__4 = xopt.get(i__) + w.get(i__);\n+                    d__1 = sl.get(i__);\n+                    d__2 = Math.min(d__3,d__4);\n+                    xalt.set(i__, Math.max(d__1,d__2));\n+                } else if (w.get(i__) == zero) {\n+                    xalt.set(i__, xopt.get(i__));\n+                } else if (glag.get(i__) > zero) {\n+                    xalt.set(i__, sl.get(i__));\n+                } else {\n+                    xalt.set(i__, su.get(i__));\n+                }\n+                gw += glag.get(i__) * w.get(i__);\n+            }\n+\n+            // Set CURV to the curvature of the KNEW-th Lagrange function along W.\n+            // Scale W by a factor less than one if that can reduce the modulus of\n+            // the Lagrange function at XOPT+W. Set CAUCHY to the final value of\n+            // the square of this function.\n+\n+            curv = zero;\n+            i__1 = npt;\n+            for (k = 1; k <= i__1; k++) {\n+                temp = zero;\n+                i__2 = n;\n+                for (j = 1; j <= i__2; j++) {\n+                    temp += xpt.get(k + j * xpt_dim1) * w.get(j);\n+                }\n+                curv += hcol.get(k) * temp * temp;\n+            }\n+            if (iflag == 1) {\n+                curv = -curv;\n+            }\n+            if (curv > -gw && curv < -const__ * gw) {\n+                scale = -gw / curv;\n+                i__1 = n;\n+                for (i__ = 1; i__ <= i__1; i__++) {\n+                    temp = xopt.get(i__) + scale * w.get(i__);\n+                    // Computing MAX\n+                    // Computing MIN\n+                    d__3 = su.get(i__);\n+                    d__1 = sl.get(i__);\n+                    d__2 = Math.min(d__3,temp);\n+                    xalt.set(i__, Math.max(d__1,d__2));\n+                }\n+                // Computing 2nd power\n+                d__1 = half * gw * scale;\n+                cauchy.value = d__1 * d__1;\n+            } else {\n+                // Computing 2nd power\n+                d__1 = gw + half * curv;\n+                cauchy.value = d__1 * d__1;\n+            }\n+\n+            // If IFLAG is zero, then XALT is calculated as before after reversing\n+            // the sign of GLAG. Thus two XALT vectors become available. The one that\n+            // is chosen is the one that gives the larger value of CAUCHY.\n+\n+            if (iflag == 0) {\n+                i__1 = n;\n+                for (i__ = 1; i__ <= i__1; i__++) {\n+                    glag.set(i__, -glag.get(i__));\n+                    w.set(n + i__, xalt.get(i__));\n+                }\n+                csave = cauchy.value;\n+                iflag = 1;\n+            } else {\n+                break L100;\n+            }} // end L100\n+        if (csave > cauchy.value) {\n+            i__1 = n;\n+            for (i__ = 1; i__ <= i__1; i__++) {\n+                xalt.set(i__, w.get(n + i__));\n+            }\n+            cauchy.value = csave;\n+        }\n+    } // altmov\n+\n+    // ----------------------------------------------------------------------------------------\n+\n+    /**\n+     *     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n+     *     BMAT and ZMAT for the first iteration, and it maintains the values of\n+     *     NF and KOPT. The vector X is also changed by PRELIM.\n+     *\n+     *     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the\n+     *       same as the corresponding arguments in SUBROUTINE BOBYQA.\n+     *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU\n+     *       are the same as the corresponding arguments in BOBYQB, the elements\n+     *       of SL and SU being set in BOBYQA.\n+     *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but\n+     *       it is set by PRELIM to the gradient of the quadratic model at XBASE.\n+     *       If XOPT is nonzero, BOBYQB will change it to its usual value later.\n+     *     NF is maintaned as the number of calls of CALFUN so far.\n+     *     KOPT will be such that the least calculated value of F so far is at\n+     *       the point XPT(KOPT,.)+XBASE in the space of the variables.\n+     *\n+     * @param n\n+     * @param npt\n+     * @param x\n+     * @param xl\n+     * @param xu\n+     * @param rhobeg\n+     * @param maxfun\n+     * @param xbase\n+     * @param xpt\n+     * @param fval\n+     * @param gopt\n+     * @param hq\n+     * @param pq\n+     * @param bmat\n+     * @param zmat\n+     * @param ndim\n+     * @param sl\n+     * @param su\n+     * @param nf\n+     * @param kopt\n+     */\n+    private void prelim(\n+            int n,\n+            int npt,\n+            ScopedPtr x,\n+            ScopedPtr xl,\n+            ScopedPtr xu,\n+            double rhobeg,\n+            int maxfun,\n+            ScopedPtr xbase,\n+            ScopedPtr xpt,\n+            ScopedPtr fval,\n+            ScopedPtr gopt,\n+            ScopedPtr hq,\n+            ScopedPtr pq,\n+            ScopedPtr bmat,\n+            ScopedPtr zmat,\n+            int ndim,\n+            ScopedPtr sl,\n+            ScopedPtr su,\n+            IntRef nf,\n+            IntRef kopt\n+    ) {\n+        // System generated locals\n+        int xpt_dim1, bmat_dim1, zmat_dim1, i__1, i__2;\n+        double d__1, d__2, d__3, d__4;\n+\n+        // Local variables\n+        double f;\n+        int i__, j, k, ih, np, nfm;\n+        double one;\n+        int nfx = 0, ipt = 0, jpt = 0;\n+        double two = 0, fbeg = 0, diff = 0, half = 0, temp = 0, zero = 0, recip = 0, stepa = 0, stepb = 0;\n+        int itemp;\n+        double rhosq;\n+\n+        // Set some constants.\n+\n+        zmat_dim1 = npt;\n+        xpt_dim1 = npt;\n+        bmat_dim1 = ndim;\n+\n+        // Function Body\n+        half = .5;\n+        one = 1.;\n+        two = 2.;\n+        zero = 0.;\n+        rhosq = rhobeg * rhobeg;\n+        recip = one / rhosq;\n+        np = n + 1;\n+\n+        // Set XBASE to the initial vector of variables, and set the initial\n+        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n+\n+        i__1 = n;\n+        for (j = 1; j <= i__1; j++) {\n+            xbase.set(j, x.get(j));\n+            i__2 = npt;\n+            for (k = 1; k <= i__2; k++) {\n+                xpt.set(k + j * xpt_dim1, zero);\n+            }\n+            i__2 = ndim;\n+            for (i__ = 1; i__ <= i__2; i__++) {\n+                bmat.set(i__ + j * bmat_dim1, zero);\n+            }\n+        }\n+        i__2 = n * np / 2;\n+        for (ih = 1; ih <= i__2; ih++) {\n+            hq.set(ih, zero);\n+        }\n+        i__2 = npt;\n+        for (k = 1; k <= i__2; k++) {\n+            pq.set(k, zero);\n+            i__1 = npt - np;\n+            for (j = 1; j <= i__1; j++) {\n+                zmat.set(k + j * zmat_dim1, zero);\n+            }\n+        }\n+\n+        // Begin the initialization procedure. NF becomes one more than the number\n+        // of function values so far. The coordinates of the displacement of the\n+        // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n+\n+        nf.value = 0;\n+        do {\n+            nfm = nf.value;\n+            nfx = nf.value - n;\n+            nf.value++;\n+            if (nfm <= n << 1) {\n+                if (nfm >= 1 && nfm <= n) {\n+                    stepa = rhobeg;\n+                    if (su.get(nfm) == zero) {\n+                        stepa = -stepa;\n+                    }\n+                    xpt.set(nf.value + nfm * xpt_dim1, stepa);\n+                } else if (nfm > n) {\n+                    stepa = xpt.get(nf.value - n + nfx * xpt_dim1);\n+                    stepb = -rhobeg;\n+                    if (sl.get(nfx) == zero) {\n+                        // Computing MIN\n+                        d__1 = two * rhobeg;\n+                        d__2 = su.get(nfx);\n+                        stepb = Math.min(d__1,d__2);\n+                    }\n+                    if (su.get(nfx) == zero) {\n+                        // Computing MAX\n+                        d__1 = -two * rhobeg;\n+                        d__2 = sl.get(nfx);\n+                        stepb = Math.max(d__1,d__2);\n+                    }\n+                    xpt.set(nf.value + nfx * xpt_dim1, stepb);\n+                }\n+            } else {\n+                itemp = (nfm - np) / n;\n+                jpt = nfm - itemp * n - n;\n+                ipt = jpt + itemp;\n+                if (ipt > n) {\n+                    itemp = jpt;\n+                    jpt = ipt - n;\n+                    ipt = itemp;\n+                }\n+                xpt.set(nf.value + ipt * xpt_dim1, xpt.get(ipt + 1 + ipt * xpt_dim1));\n+                xpt.set(nf.value + jpt * xpt_dim1, xpt.get(jpt + 1 + jpt * xpt_dim1));\n+            }\n+\n+            // Calculate the next value of F. The least function value so far and\n+            // its index are required.\n+\n+            i__1 = n;\n+            for (j = 1; j <= i__1; j++) {\n+                // Computing MIN\n+                // Computing MAX\n+                d__3 = xl.get(j);\n+                d__4 = xbase.get(j) + xpt.get(nf.value + j * xpt_dim1);\n+                d__1 = Math.max(d__3,d__4);\n+                d__2 = xu.get(j);\n+                x.set(j, Math.min(d__1,d__2));\n+                if (xpt.get(nf.value + j * xpt_dim1) == sl.get(j)) {\n+                    x.set(j, xl.get(j));\n+                }\n+                if (xpt.get(nf.value + j * xpt_dim1) == su.get(j)) {\n+                    x.set(j, xu.get(j));\n+                }\n+            }\n+            f = computeObjectiveValue(x.getAll());\n+            if (!isMinimize)\n+                f = -f;\n+            fval.set(nf.value, f);\n+            if (nf.value == 1) {\n+                fbeg = f;\n+                kopt.value = 1;\n+            } else if (f < fval.get(kopt.value)) {\n+                kopt.value = nf.value;\n+            }\n+\n+            // Set the nonzero initial elements of BMAT and the quadratic model in the\n+            // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n+            // of the NF-th and (NF-N)-th interpolation points may be switched, in\n+            // order that the function value at the first of them contributes to the\n+            // off-diagonal second derivative terms of the initial quadratic model.\n+\n+            if (nf.value <= (n << 1) + 1) {\n+                if (nf.value >= 2 && nf.value <= n + 1) {\n+                    gopt.set( nfm, (f - fbeg) / stepa);\n+                    if (npt < nf.value + n) {\n+                        bmat.set( nfm * bmat_dim1 + 1, -one / stepa);\n+                        bmat.set( nf.value + nfm * bmat_dim1, one / stepa);\n+                        bmat.set( npt + nfm + nfm * bmat_dim1, -half * rhosq);\n+                    }\n+                } else if (nf.value >= n + 2) {\n+                    ih = nfx * (nfx + 1) / 2;\n+                    temp = (f - fbeg) / stepb;\n+                    diff = stepb - stepa;\n+                    hq.set(ih, two * (temp - gopt.get(nfx)) / diff);\n+                    gopt.set(nfx, (gopt.get(nfx) * stepb - temp * stepa) / diff);\n+                    if (stepa * stepb < zero) {\n+                        if (f < fval.get(nf.value - n)) {\n+                            fval.set(nf.value, fval.get(nf.value - n));\n+                            fval.set(nf.value - n, f);\n+                            if (kopt.value == nf.value) {\n+                                kopt.value = nf.value - n;\n+                            }\n+                            xpt.set(nf.value - n + nfx * xpt_dim1, stepb);\n+                            xpt.set(nf.value + nfx * xpt_dim1, stepa);\n+                        }\n+                    }\n+                    bmat.set( nfx * bmat_dim1 + 1, -(stepa + stepb) / (stepa * stepb));\n+                    bmat.set( nf.value + nfx * bmat_dim1, -half /\n+                            xpt.get(nf.value - n + nfx * xpt_dim1));\n+                    bmat.set( nf.value - n + nfx * bmat_dim1, -bmat.get( nfx * bmat_dim1 + 1) -\n+                            bmat.get( nf.value + nfx * bmat_dim1));\n+                    zmat.set( nfx * zmat_dim1 + 1, Math.sqrt(two) / (stepa * stepb));\n+                    zmat.set( nf.value + nfx * zmat_dim1, Math.sqrt(half) / rhosq);\n+                    zmat.set( nf.value - n + nfx * zmat_dim1, -zmat.get( nfx * zmat_dim1 + 1) -\n+                            zmat.get( nf.value + nfx * zmat_dim1));\n+                }\n+\n+                // Set the off-diagonal second derivatives of the Lagrange functions and\n+                // the initial quadratic model.\n+\n+            } else {\n+                ih = ipt * (ipt - 1) / 2 + jpt;\n+                zmat.set( nfx * zmat_dim1 + 1, recip);\n+                zmat.set( nf.value + nfx * zmat_dim1, recip);\n+                zmat.set(ipt + 1 + nfx * zmat_dim1, -recip);\n+                zmat.set( jpt + 1 + nfx * zmat_dim1, -recip);\n+                temp = xpt.get(nf.value + ipt * xpt_dim1) * xpt.get(nf.value + jpt * xpt_dim1);\n+                hq.set(ih, (fbeg - fval.get(ipt + 1) - fval.get(jpt + 1) + f) / temp);\n+            }\n+        } while (nf.value < npt && nf.value < maxfun);\n+    } // prelim\n+\n+    // ----------------------------------------------------------------------------------------\n+\n+    /**\n+     *     The first NDIM+NPT elements of the array W are used for working space.\n+     *     The final elements of BMAT and ZMAT are set in a well-conditioned way\n+     *       to the values that are appropriate for the new interpolation points.\n+     *     The elements of GOPT, HQ and PQ are also revised to the values that are\n+     *       appropriate to the final quadratic model.\n+     *\n+     *     The arguments N, NPT, XL, XU, IPRINT, MAXFUN, XBASE, XPT, FVAL, XOPT,\n+     *       GOPT, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU have the same meanings as\n+     *       the corresponding arguments of BOBYQB on the entry to RESCUE.\n+     *     NF is maintained as the number of calls of CALFUN so far, except that\n+     *       NF is set to -1 if the value of MAXFUN prevents further progress.\n+     *     KOPT is maintained so that FVAL(KOPT) is the least calculated function\n+     *       value. Its correct value must be given on entry. It is updated if a\n+     *       new least function value is found, but the corresponding changes to\n+     *       XOPT and GOPT have to be made later by the calling program.\n+     *     DELTA is the current trust region radius.\n+     *     VLAG is a working space vector that will be used for the values of the\n+     *       provisional Lagrange functions at each of the interpolation points.\n+     *       They are part of a product that requires VLAG to be of length NDIM.\n+     *     PTSAUX is also a working space array. For J=1,2,...,N, PTSAUX(1,J) and\n+     *       PTSAUX(2,J) specify the two positions of provisional interpolation\n+     *       points when a nonzero step is taken along e_J (the J-th coordinate\n+     *       direction) through XBASE+XOPT, as specified below. Usually these\n+     *       steps have length DELTA, but other lengths are chosen if necessary\n+     *       in order to satisfy the given bounds on the variables.\n+     *     PTSID is also a working space array. It has NPT components that denote\n+     *       provisional new positions of the original interpolation points, in\n+     *       case changes are needed to restore the linear independence of the\n+     *       interpolation conditions. The K-th point is a candidate for change\n+     *       if and only if PTSID(K) is nonzero. In this case let p and q be the\n+     *       int parts of PTSID(K) and (PTSID(K)-p) multiplied by N+1. If p\n+     *       and q are both positive, the step from XBASE+XOPT to the new K-th\n+     *       interpolation point is PTSAUX(1,p)*e_p + PTSAUX(1,q)*e_q. Otherwise\n+     *       the step is PTSAUX(1,p)*e_p or PTSAUX(2,q)*e_q in the cases q=0 or\n+     *       p=0, respectively.\n+     * @param n\n+     * @param npt\n+     * @param xl\n+     * @param xu\n+     * @param maxfun\n+     * @param xbase\n+     * @param xpt\n+     * @param fval\n+     * @param xopt\n+     * @param gopt\n+     * @param hq\n+     * @param pq\n+     * @param bmat\n+     * @param zmat\n+     * @param ndim\n+     * @param sl\n+     * @param su\n+     * @param nf\n+     * @param delta\n+     * @param kopt\n+     * @param vlag\n+     * @param ptsaux\n+     * @param ptsid\n+     * @param w\n+     */\n+    private void rescue (\n+            int n,\n+            int npt,\n+            ScopedPtr xl,\n+            ScopedPtr xu,\n+            int maxfun,\n+            ScopedPtr xbase,\n+            ScopedPtr xpt,\n+            ScopedPtr fval,\n+            ScopedPtr xopt,\n+            ScopedPtr gopt,\n+            ScopedPtr hq,\n+            ScopedPtr pq,\n+            ScopedPtr bmat,\n+            ScopedPtr zmat,\n+            int ndim,\n+            ScopedPtr sl,\n+            ScopedPtr su,\n+            IntRef nf,\n+            double delta,\n+            IntRef kopt,\n+            ScopedPtr vlag,\n+            ScopedPtr ptsaux,\n+            ScopedPtr ptsid,\n+            ScopedPtr w\n+    ) {\n+        // System generated locals\n+        int xpt_dim1, bmat_dim1, zmat_dim1,\n+        i__1, i__2, i__3;\n+        double d__1, d__2, d__3, d__4;\n+\n+\n+        // Local variables\n+        double f;\n+        int i__, j, k, ih, jp, ip, iq, np;\n+        double xp = 0, xq = 0, den = 0;\n+        int ihp = 0;\n+        double one;\n+        int jpn, kpt;\n+        double sum = 0, diff = 0, half = 0, beta = 0;\n+        int kold;\n+        double winc;\n+        int nrem, knew;\n+        double temp, bsum;\n+        int nptm;\n+        double zero = 0, hdiag = 0, fbase = 0, sfrac = 0, denom = 0, vquad = 0, sumpq = 0;\n+        double dsqmin, distsq, vlmxsq;\n+\n+        // Set some constants.\n+        zmat_dim1 = npt;\n+        xpt_dim1 = npt;\n+        bmat_dim1 = ndim;\n+\n+        // Function Body\n+        half = .5;\n+        one = 1.;\n+        zero = 0.;\n+        np = n + 1;\n+        sfrac = half / (double) np;\n+        nptm = npt - np;\n+\n+        // Shift the interpolation points so that XOPT becomes the origin, and set\n+        // the elements of ZMAT to zero. The value of SUMPQ is required in the\n+        // updating of HQ below. The squares of the distances from XOPT to the\n+        // other interpolation points are set at the end of W. Increments of WINC\n+        // may be added later to these squares to balance the consideration of\n+        // the choice of point that is going to become current.\n+\n+        sumpq = zero;\n+        winc = zero;\n+        i__1 = npt;\n+        for (k = 1; k <= i__1; k++) {\n+            distsq = zero;\n+            i__2 = n;\n+            for (j = 1; j <= i__2; j++) {\n+                xpt.set(k + j * xpt_dim1, xpt.get(k + j * xpt_dim1) - xopt.get(j));\n+                // Computing 2nd power\n+                d__1 = xpt.get(k + j * xpt_dim1);\n+                distsq += d__1 * d__1;\n+            }\n+            sumpq += pq.get(k);\n+            w.set(ndim + k, distsq);\n+            winc = Math.max(winc,distsq);\n+            i__2 = nptm;\n+            for (j = 1; j <= i__2; j++) {\n+                zmat.set(k + j * zmat_dim1, zero);\n+            }\n+        }\n+\n+        // Update HQ so that HQ and PQ define the second derivatives of the model\n+        // after XBASE has been shifted to the trust region centre.\n+\n+        ih = 0;\n+        i__2 = n;\n+        for (j = 1; j <= i__2; j++) {\n+            w.set(j, half * sumpq * xopt.get(j));\n+            i__1 = npt;\n+            for (k = 1; k <= i__1; k++) {\n+                w.set(j, w.get(j) + pq.get(k) * xpt.get(k + j * xpt_dim1));\n+            }\n+            i__1 = j;\n+            for (i__ = 1; i__ <= i__1; i__++) {\n+                ++ih;\n+                hq.set(ih, hq.get(ih) + w.get(i__) * xopt.get(j) + w.get(j) * xopt.get(i__));\n+            }\n+        }\n+\n+        // Shift XBASE, SL, SU and XOPT. Set the elements of BMAT to zero, and\n+        // also set the elements of PTSAUX.\n+\n+        i__1 = n;\n+        for (j = 1; j <= i__1; j++) {\n+            xbase.set(j, xbase.get(j) + xopt.get(j));\n+            sl.set(j, sl.get(j) - xopt.get(j));\n+            su.set(j, su.get(j) - xopt.get(j));\n+            xopt.set(j, zero);\n+            // Computing MIN\n+            d__1 = delta;\n+            d__2 = su.get(j);\n+            ptsaux.set((j << 1) + 1, Math.min(d__1,d__2));\n+            // Computing MAX\n+            d__1 = -delta;\n+            d__2 = sl.get(j);\n+            ptsaux.set((j << 1) + 2, Math.max(d__1,d__2));\n+            if (ptsaux.get((j << 1) + 1) + ptsaux.get((j << 1) + 2) < zero) {\n+                temp = ptsaux.get((j << 1) + 1);\n+                ptsaux.set((j << 1) + 1, ptsaux.get((j << 1) + 2));\n+                ptsaux.set((j << 1) + 2, temp);\n+            }\n+            d__2 = ptsaux.get((j << 1) + 2);\n+            d__1 = ptsaux.get((j << 1) + 1);\n+            if (Math.abs(d__2) < half * Math.abs(d__1)) {\n+                ptsaux.set((j << 1) + 2, half * ptsaux.get((j << 1) + 1));\n+            }\n+            i__2 = ndim;\n+            for (i__ = 1; i__ <= i__2; i__++) {\n+                bmat.set(i__ + j * bmat_dim1, zero);\n+            }\n+        }\n+        fbase = fval.get(kopt.value);\n+\n+        // Set the identifiers of the artificial interpolation points that are\n+        // along a coordinate direction from XOPT, and set the corresponding\n+        // nonzero elements of BMAT and ZMAT.\n+\n+        ptsid.set(1, sfrac);\n+        i__2 = n;\n+        for (j = 1; j <= i__2; j++) {\n+            jp = j + 1;\n+            jpn = jp + n;\n+            ptsid.set(jp, (double) j + sfrac);\n+            if (jpn <= npt) {\n+                ptsid.set(jpn, (double) j / (double) np + sfrac);\n+                temp = one / (ptsaux.get((j << 1) + 1) - ptsaux.get((j << 1) + 2));\n+                bmat.set(jp + j * bmat_dim1, -temp + one / ptsaux.get((j << 1) + 1));\n+                bmat.set(jpn + j * bmat_dim1, temp + one / ptsaux.get((j << 1) + 2));\n+                bmat.set(j * bmat_dim1 + 1, -bmat.get(jp + j * bmat_dim1) - bmat.get(jpn +\n+                        j * bmat_dim1));\n+                d__1 = ptsaux.get((j << 1) + 1) * ptsaux.get((j << 1) + 2);\n+                zmat.set(j * zmat_dim1 + 1,  Math.sqrt(2.) / Math.abs(d__1));\n+                zmat.set(jp + j * zmat_dim1, zmat.get(j * zmat_dim1 + 1) *\n+                        ptsaux.get((j << 1) + 2) * temp);\n+                zmat.set(jpn + j * zmat_dim1, -zmat.get(j * zmat_dim1 + 1) *\n+                        ptsaux.get((j << 1) + 1) * temp);\n+            } else {\n+                bmat.set(j * bmat_dim1 + 1, -one / ptsaux.get((j << 1) + 1));\n+                bmat.set(jp + j * bmat_dim1, one / ptsaux.get((j << 1) + 1));\n+                // Computing 2nd power\n+                d__1 = ptsaux.get((j << 1) + 1);\n+                bmat.set(j + npt + j * bmat_dim1, -half * (d__1 * d__1));\n+            }\n+        }\n+\n+        // Set any remaining identifiers with their nonzero elements of ZMAT.\n+\n+        if (npt >= n + np) {\n+            i__2 = npt;\n+            for (k = np << 1; k <= i__2; k++) {\n+                int iw = (int) (((double) (k - np) - half) / (double) n);\n+                ip = k - np - iw * n;\n+                iq = ip + iw;\n+                if (iq > n) {\n+                    iq -= n;\n+                }\n+                ptsid.set(k, (double) ip + (double) iq / (double) np +\n+                        sfrac);\n+                temp = one / (ptsaux.get((ip << 1) + 1) * ptsaux.get((iq << 1) + 1));\n+                zmat.set((k - np) * zmat_dim1 + 1, temp);\n+                zmat.set(ip + 1 + (k - np) * zmat_dim1, -temp);\n+                zmat.set(iq + 1 + (k - np) * zmat_dim1, -temp);\n+                zmat.set(k + (k - np) * zmat_dim1, temp);\n+            }\n+        }\n+        nrem = npt;\n+        kold = 1;\n+        knew = kopt.value;\n+\n+        // Reorder the provisional points in the way that exchanges PTSID(KOLD)\n+        // with PTSID(KNEW).\n+\n+        int state = 80;\n+        for(;;) switch (state) {\n+        case 80: {\n+            i__2 = n;\n+            for (j = 1; j <= i__2; j++) {\n+                temp = bmat.get(kold + j * bmat_dim1);\n+                bmat.set(kold + j * bmat_dim1, bmat.get(knew + j * bmat_dim1));\n+                bmat.set(knew + j * bmat_dim1, temp);\n+            }\n+            i__2 = nptm;\n+            for (j = 1; j <= i__2; j++) {\n+                temp = zmat.get(kold + j * zmat_dim1);\n+                zmat.set(kold + j * zmat_dim1, zmat.get(knew + j * zmat_dim1));\n+                zmat.set(knew + j * zmat_dim1, temp);\n+            }\n+            ptsid.set(kold, ptsid.get(knew));\n+            ptsid.set(knew, zero);\n+            w.set(ndim + knew, zero);\n+            --nrem;\n+            if (knew != kopt.value) {\n+                temp = vlag.get(kold);\n+                vlag.set(kold, vlag.get(knew));\n+                vlag.set(knew, temp);\n+\n+                // Update the BMAT and ZMAT matrices so that the status of the KNEW-th\n+                // interpolation point can be changed from provisional to original. The\n+                // branch to label 350 occurs if all the original points are reinstated.\n+                // The nonnegative values of W(NDIM+K) are required in the search below.\n+\n+                update(n, npt, bmat, zmat, ndim, vlag,\n+                        beta, denom, knew, w);\n+\n+                if (nrem == 0) {\n+                    return;\n+                }\n+                i__2 = npt;\n+                for (k = 1; k <= i__2; k++) {\n+                    d__1 = w.get(ndim + k);\n+                    w.set(ndim + k, Math.abs(d__1));\n+                }\n+            }\n+\n+            // Pick the index KNEW of an original interpolation point that has not\n+            // yet replaced one of the provisional interpolation points, giving\n+            // attention to the closeness to XOPT and to previous tries with KNEW.\n+        }\n+        case 120: {\n+            dsqmin = zero;\n+            i__2 = npt;\n+            for (k = 1; k <= i__2; k++) {\n+                if (w.get(ndim + k) > zero) {\n+                    if (dsqmin == zero || w.get(ndim + k) < dsqmin) {\n+                        knew = k;\n+                        dsqmin = w.get(ndim + k);\n+                    }\n+                }\n+            }\n+            if (dsqmin == zero) {\n+                state = 260; break;\n+            }\n+\n+            // Form the W-vector of the chosen original interpolation point.\n+\n+            i__2 = n;\n+            for (j = 1; j <= i__2; j++) {\n+                w.set(npt + j, xpt.get(knew + j * xpt_dim1));\n+            }\n+            i__2 = npt;\n+            for (k = 1; k <= i__2; k++) {\n+                sum = zero;\n+                if (k == kopt.value) {\n+                } else if (ptsid.get(k) == zero) {\n+                    i__1 = n;\n+                    for (j = 1; j <= i__1; j++) {\n+                        sum += w.get(npt + j) * xpt.get(k + j * xpt_dim1);\n+                    }\n+                } else {\n+                    ip = (int) ptsid.get(k);\n+                    if (ip > 0) {\n+                        sum = w.get(npt + ip) * ptsaux.get((ip << 1) + 1);\n+                    }\n+                    iq = (int) ((double) np * ptsid.get(k) - (double) (ip * np));\n+                    if (iq > 0) {\n+                        int iw = 1;\n+                        if (ip == 0) {\n+                            iw = 2;\n+                        }\n+                        sum += w.get(npt + iq) * ptsaux.get(iw + (iq << 1));\n+                    }\n+                }\n+                w.set(k, half * sum * sum);\n+            }\n+\n+            // Calculate VLAG and BETA for the required updating of the H matrix if\n+            // XPT(KNEW,.) is reinstated in the set of interpolation points.\n+\n+            i__2 = npt;\n+            for (k = 1; k <= i__2; k++) {\n+                sum = zero;\n+                i__1 = n;\n+                for (j = 1; j <= i__1; j++) {\n+                    sum += bmat.get(k + j * bmat_dim1) * w.get(npt + j);\n+                }\n+                vlag.set(k, sum);\n+            }\n+            beta = zero;\n+            i__2 = nptm;\n+            for (j = 1; j <= i__2; j++) {\n+                sum = zero;\n+                i__1 = npt;\n+                for (k = 1; k <= i__1; k++) {\n+                    sum += zmat.get(k + j * zmat_dim1) * w.get(k);\n+                }\n+                beta -= sum * sum;\n+                i__1 = npt;\n+                for (k = 1; k <= i__1; k++) {\n+                    vlag.set(k, vlag.get(k) + sum * zmat.get(k + j * zmat_dim1));\n+                }\n+            }\n+            bsum = zero;\n+            distsq = zero;\n+            i__1 = n;\n+            for (j = 1; j <= i__1; j++) {\n+                sum = zero;\n+                i__2 = npt;\n+                for (k = 1; k <= i__2; k++) {\n+                    sum += bmat.get(k + j * bmat_dim1) * w.get(k);\n+                }\n+                jp = j + npt;\n+                bsum += sum * w.get(jp);\n+                i__2 = ndim;\n+                for (ip = npt; ip <= i__2; ip++) {\n+                    sum += bmat.get(ip + j * bmat_dim1) * w.get(ip);\n+                }\n+                bsum += sum * w.get(jp);\n+                vlag.set(jp, sum);\n+                // Computing 2nd power\n+                d__1 = xpt.get(knew + j * xpt_dim1);\n+                distsq += d__1 * d__1;\n+            }\n+            beta = half * distsq * distsq + beta - bsum;\n+            vlag.set(kopt.value, vlag.get(kopt.value) + one);\n+\n+            // KOLD is set to the index of the provisional interpolation point that is\n+            // going to be deleted to make way for the KNEW-th original interpolation\n+            // point. The choice of KOLD is governed by the avoidance of a small value\n+            // of the denominator in the updating calculation of UPDATE.\n+\n+            denom = zero;\n+            vlmxsq = zero;\n+            i__1 = npt;\n+            for (k = 1; k <= i__1; k++) {\n+                if (ptsid.get(k) != zero) {\n+                    hdiag = zero;\n+                    i__2 = nptm;\n+                    for (j = 1; j <= i__2; j++) {\n+                        // Computing 2nd power\n+                        d__1 = zmat.get(k + j * zmat_dim1);\n+                        hdiag += d__1 * d__1;\n+                    }\n+                    // Computing 2nd power\n+                    d__1 = vlag.get(k);\n+                    den = beta * hdiag + d__1 * d__1;\n+                    if (den > denom) {\n+                        kold = k;\n+                        denom = den;\n+                    }\n+                }\n+                // Computing MAX\n+                // Computing 2nd power\n+                d__3 = vlag.get(k);\n+                d__1 = vlmxsq;\n+                d__2 = d__3 * d__3;\n+                vlmxsq = Math.max(d__1,d__2);\n+            }\n+            if (denom <= vlmxsq * .01) {\n+                w.set(ndim + knew, -w.get(ndim + knew) - winc);\n+                state = 120; break;\n+            }\n+            state = 80; break;\n+\n+            // When label 260 is reached, all the final positions of the interpolation\n+            // points have been chosen although any changes have not been included yet\n+            // in XPT. Also the final BMAT and ZMAT matrices are complete, but, apart\n+            // from the shift of XBASE, the updating of the quadratic model remains to\n+            // be done. The following cycle through the new interpolation points begins\n+            // by putting the new point in XPT(KPT,.) and by setting PQ(KPT) to zero,\n+            // except that a RETURN occurs if MAXFUN prohibits another value of F.\n+\n+        }\n+        case 260: {\n+            i__1 = npt;\n+            for (kpt = 1; kpt <= i__1; kpt++) {\n+                if (ptsid.get(kpt) == zero) {\n+                    continue;\n+                }\n+                if (nf.value >= maxfun) {\n+                    nf.value = -1;\n+                    return;\n+                }\n+                ih = 0;\n+                i__2 = n;\n+                for (j = 1; j <= i__2; j++) {\n+                    w.set(j, xpt.get(kpt + j * xpt_dim1));\n+                    xpt.set(kpt + j * xpt_dim1, zero);\n+                    temp = pq.get(kpt) * w.get(j);\n+                    i__3 = j;\n+                    for (i__ = 1; i__ <= i__3; i__++) {\n+                        ++ih;\n+                        hq.set(ih, hq.get(ih) + temp * w.get(i__));\n+                    }\n+                }\n+                pq.set(kpt, zero);\n+                ip = (int) ptsid.get(kpt);\n+                iq = (int) ((double) np * ptsid.get(kpt) - (double) (ip * np))\n+                ;\n+                if (ip > 0) {\n+                    xp = ptsaux.get((ip << 1) + 1);\n+                    xpt.set(kpt + ip * xpt_dim1, xp);\n+                }\n+                if (iq > 0) {\n+                    xq = ptsaux.get((iq << 1) + 1);\n+                    if (ip == 0) {\n+                        xq = ptsaux.get((iq << 1) + 2);\n+                    }\n+                    xpt.set(kpt + iq * xpt_dim1, xq);\n+                }\n+\n+                // Set VQUAD to the value of the current model at the new point.\n+\n+                vquad = fbase;\n+                if (ip > 0) {\n+                    ihp = (ip + ip * ip) / 2;\n+                    vquad += xp * (gopt.get(ip) + half * xp * hq.get(ihp));\n+                }\n+                if (iq > 0) {\n+                    int ihq = (iq + iq * iq) / 2;\n+                    vquad += xq * (gopt.get(iq) + half * xq * hq.get(ihq));\n+                    if (ip > 0) {\n+                        i__3 = ip - iq;\n+                        int iiw = Math.max(ihp,ihq) - Math.abs(i__3);\n+                        vquad += xp * xq * hq.get(iiw);\n+                    }\n+                }\n+                i__3 = npt;\n+                for (k = 1; k <= i__3; k++) {\n+                    temp = zero;\n+                    if (ip > 0) {\n+                        temp += xp * xpt.get(k + ip * xpt_dim1);\n+                    }\n+                    if (iq > 0) {\n+                        temp += xq * xpt.get(k + iq * xpt_dim1);\n+                    }\n+                    vquad += half * pq.get(k) * temp * temp;\n+                }\n+\n+                // Calculate F at the new interpolation point, and set DIFF to the factor\n+                // that is going to multiply the KPT-th Lagrange function when the model\n+                // is updated to provide interpolation to the new function value.\n+\n+                i__3 = n;\n+                for (i__ = 1; i__ <= i__3; i__++) {\n+                    // Computing MIN\n+                    // Computing MAX\n+                    d__3 = xl.get(i__);\n+                    d__4 = xbase.get(i__) + xpt.get(kpt + i__ * xpt_dim1);\n+                    d__1 = Math.max(d__3,d__4);\n+                    d__2 = xu.get(i__);\n+                    w.set(i__, Math.min(d__1,d__2));\n+                    if (xpt.get(kpt + i__ * xpt_dim1) == sl.get(i__)) {\n+                        w.set(i__, xl.get(i__));\n+                    }\n+                    if (xpt.get(kpt + i__ * xpt_dim1) == su.get(i__)) {\n+                        w.set(i__, xu.get(i__));\n+                    }\n+                }\n+                nf.value++;\n+                f = computeObjectiveValue(w.getAll(1,n));\n+                if (!isMinimize)\n+                    f = -f;\n+                fval.set(kpt, f);\n+                if (f < fval.get(kopt.value)) {\n+                    kopt.value = kpt;\n+                }\n+                diff = f - vquad;\n+\n+                // Update the quadratic model. The RETURN from the subroutine occurs when\n+                // all the new interpolation points are included in the model.\n+\n+                i__3 = n;\n+                for (i__ = 1; i__ <= i__3; i__++) {\n+                    gopt.set(i__, gopt.get(i__) + diff * bmat.get(kpt + i__ * bmat_dim1));\n+                }\n+                i__3 = npt;\n+                for (k = 1; k <= i__3; k++) {\n+                    sum = zero;\n+                    i__2 = nptm;\n+                    for (j = 1; j <= i__2; j++) {\n+                        sum += zmat.get(k + j * zmat_dim1) * zmat.get(kpt + j * zmat_dim1);\n+                    }\n+                    temp = diff * sum;\n+                    if (ptsid.get(k) == zero) {\n+                        pq.set(k, pq.get(k) + temp);\n+                    } else {\n+                        ip = (int) ptsid.get(k);\n+                        iq = (int) ((double) np * ptsid.get(k) - (double) (ip * np));\n+                        int ihq = (iq * iq + iq) / 2;\n+                        if (ip == 0) {\n+                            // Computing 2nd power\n+                            d__1 = ptsaux.get((iq << 1) + 2);\n+                            hq.set(ihq, hq.get(ihq) + temp * (d__1 * d__1));\n+                        } else {\n+                            ihp = (ip * ip + ip) / 2;\n+                            // Computing 2nd power\n+                            d__1 = ptsaux.get((ip << 1) + 1);\n+                            hq.set(ihp, hq.get(ihp) + temp * (d__1 * d__1));\n+                            if (iq > 0) {\n+                                // Computing 2nd power\n+                                d__1 = ptsaux.get((iq << 1) + 1);\n+                                hq.set(ihq, hq.get(ihq) + temp * (d__1 * d__1));\n+                                i__2 = iq - ip;\n+                                int iw = Math.max(ihp,ihq) - Math.abs(i__2);\n+                                hq.set(iw, hq.get(iw) + temp * ptsaux.get((ip << 1) + 1) * ptsaux.get((iq <<\n+                                        1) + 1));\n+                            }\n+                        }\n+                    }\n+                }\n+                ptsid.set(kpt, zero);\n+            }\n+            return;\n+        }}\n+    } // rescue\n+\n+\n+    // ----------------------------------------------------------------------------------------\n+\n+    /**\n+     *     A version of the truncated conjugate gradient is applied. If a line\n+     *     search is restricted by a constraint, then the procedure is restarted,\n+     *     the values of the variables that are at their bounds being fixed. If\n+     *     the trust region boundary is reached, then further changes may be made\n+     *     to D, each one being in the two dimensional space that is spanned\n+     *     by the current D and the gradient of Q at XOPT+D, staying on the trust\n+     *     region boundary. Termination occurs when the reduction in Q seems to\n+     *     be close to the greatest reduction that can be achieved.\n+     *     The arguments N, NPT, XPT, XOPT, GOPT, HQ, PQ, SL and SU have the same\n+     *       meanings as the corresponding arguments of BOBYQB.\n+     *     DELTA is the trust region radius for the present calculation, which\n+     *       seeks a small value of the quadratic model within distance DELTA of\n+     *       XOPT subject to the bounds on the variables.\n+     *     XNEW will be set to a new vector of variables that is approximately\n+     *       the one that minimizes the quadratic model within the trust region\n+     *       subject to the SL and SU constraints on the variables. It satisfies\n+     *       as equations the bounds that become active during the calculation.\n+     *     D is the calculated trial step from XOPT, generated iteratively from an\n+     *       initial value of zero. Thus XNEW is XOPT+D after the final iteration.\n+     *     GNEW holds the gradient of the quadratic model at XOPT+D. It is updated\n+     *       when D is updated.\n+     *     xbdi.get( is a working space vector. For I=1,2,...,N, the element xbdi.get((I) is\n+     *       set to -1.0, 0.0, or 1.0, the value being nonzero if and only if the\n+     *       I-th variable has become fixed at a bound, the bound being SL(I) or\n+     *       SU(I) in the case xbdi.get((I)=-1.0 or xbdi.get((I)=1.0, respectively. This\n+     *       information is accumulated during the construction of XNEW.\n+     *     The arrays S, HS and HRED are also used for working space. They hold the\n+     *       current search direction, and the changes in the gradient of Q along S\n+     *       and the reduced D, respectively, where the reduced D is the same as D,\n+     *       except that the components of the fixed variables are zero.\n+     *     DSQ will be set to the square of the length of XNEW-XOPT.\n+     *     CRVMIN is set to zero if D reaches the trust region boundary. Otherwise\n+     *       it is set to the least curvature of H that occurs in the conjugate\n+     *       gradient searches that are not restricted by any constraints. The\n+     *       value CRVMIN=-1.0D0 is set, however, if all of these searches are\n+     *       constrained.\n+     * @param n\n+     * @param npt\n+     * @param xpt\n+     * @param xopt\n+     * @param gopt\n+     * @param hq\n+     * @param pq\n+     * @param sl\n+     * @param su\n+     * @param delta\n+     * @param xnew\n+     * @param d__\n+     * @param gnew\n+     * @param xbdi\n+     * @param s\n+     * @param hs\n+     * @param hred\n+     * @param dsq\n+     * @param crvmin\n+     */\n+    private void trsbox(\n+            int n,\n+            int npt,\n+            ScopedPtr xpt,\n+            ScopedPtr xopt,\n+            ScopedPtr gopt,\n+            ScopedPtr hq,\n+            ScopedPtr pq,\n+            ScopedPtr sl,\n+            ScopedPtr su,\n+            double delta,\n+            ScopedPtr xnew,\n+            ScopedPtr d__,\n+            ScopedPtr gnew,\n+            ScopedPtr xbdi,\n+            ScopedPtr s,\n+            ScopedPtr hs,\n+            ScopedPtr hred,\n+            DoubleRef dsq,\n+            DoubleRef crvmin\n+    ) {\n+        // System generated locals\n+        int xpt_dim1, i__1, i__2;\n+        double d__1, d__2, d__3, d__4;\n+\n+        // Local variables\n+        int i__, j, k, ih;\n+        double ds;\n+        int iu;\n+        double dhd, dhs, cth, one, shs, sth, ssq, half, beta=0, sdec, blen;\n+        int iact = 0, nact = 0;\n+        double angt = 0, qred;\n+        int isav;\n+        double temp = 0, zero = 0, xsav = 0, xsum = 0, angbd = 0, dredg = 0, sredg = 0;\n+        int iterc;\n+        double resid = 0, delsq = 0, ggsav = 0, tempa = 0, tempb = 0,\n+        redmax = 0, dredsq = 0, redsav = 0, onemin = 0, gredsq = 0, rednew = 0;\n+        int itcsav = 0;\n+        double rdprev = 0, rdnext = 0, stplen = 0, stepsq = 0;\n+        int itermax = 0;\n+\n+        // Set some constants.\n+        xpt_dim1 = npt;\n+\n+        // Function Body\n+        half = .5;\n+        one = 1.;\n+        onemin = -1.;\n+        zero = 0.;\n+\n+        // The sign of GOPT(I) gives the sign of the change to the I-th variable\n+        // that will reduce Q from its value at XOPT. Thus xbdi.get((I) shows whether\n+        // or not to fix the I-th variable at one of its bounds initially, with\n+        // NACT being set to the number of fixed variables. D and GNEW are also\n+        // set for the first iteration. DELSQ is the upper bound on the sum of\n+        // squares of the free variables. QRED is the reduction in Q so far.\n+\n+        iterc = 0;\n+        nact = 0;\n+        i__1 = n;\n+        for (i__ = 1; i__ <= i__1; i__++) {\n+            xbdi.set(i__, zero);\n+            if (xopt.get(i__) <= sl.get(i__)) {\n+                if (gopt.get(i__) >= zero) {\n+                    xbdi.set(i__, onemin);\n+                }\n+            } else if (xopt.get(i__) >= su.get(i__)) {\n+                if (gopt.get(i__) <= zero) {\n+                    xbdi.set(i__, one);\n+                }\n+            }\n+            if (xbdi.get(i__) != zero) {\n+                ++nact;\n+            }\n+            d__.set(i__, zero);\n+            gnew.set(i__, gopt.get(i__));\n+        }\n+        delsq = delta * delta;\n+        qred = zero;\n+        crvmin.value = onemin;\n+\n+        // Set the next search direction of the conjugate gradient method. It is\n+        // the steepest descent direction initially and when the iterations are\n+        // restarted because a variable has just been fixed by a bound, and of\n+        // course the components of the fixed variables are zero. ITERMAX is an\n+        // upper bound on the indices of the conjugate gradient iterations.\n+\n+        int state = 20;\n+        for(;;) switch (state) {\n+\n+        case 20: {\n+            beta = zero;\n+        }\n+        case 30: {\n+            stepsq = zero;\n+            i__1 = n;\n+            for (i__ = 1; i__ <= i__1; i__++) {\n+                if (xbdi.get(i__) != zero) {\n+                    s.set(i__, zero);\n+                } else if (beta == zero) {\n+                    s.set(i__, -gnew.get(i__));\n+                } else {\n+                    s.set(i__, beta * s.get(i__) - gnew.get(i__));\n+                }\n+                // Computing 2nd power\n+                d__1 = s.get(i__);\n+                stepsq += d__1 * d__1;\n+            }\n+            if (stepsq == zero) {\n+                state = 190; break;\n+            }\n+            if (beta == zero) {\n+                gredsq = stepsq;\n+                itermax = iterc + n - nact;\n+            }\n+            if (gredsq * delsq <= qred * 1e-4 * qred) {\n+                state = 190; break;\n+            }\n+\n+            // Multiply the search direction by the second derivative matrix of Q and\n+            // calculate some scalars for the choice of steplength. Then set BLEN to\n+            // the length of the the step to the trust region boundary and STPLEN to\n+            // the steplength, ignoring the simple bounds.\n+\n+            state = 210; break;\n+        }\n+        case 50: {\n+            resid = delsq;\n+            ds = zero;\n+            shs = zero;\n+            i__1 = n;\n+            for (i__ = 1; i__ <= i__1; i__++) {\n+                if (xbdi.get(i__) == zero) {\n+                    // Computing 2nd power\n+                    d__1 = d__.get(i__);\n+                    resid -= d__1 * d__1;\n+                    ds += s.get(i__) * d__.get(i__);\n+                    shs += s.get(i__) * hs.get(i__);\n+                }\n+            }\n+            if (resid <= zero) {\n+                state = 90; break;\n+            }\n+            temp = Math.sqrt(stepsq * resid + ds * ds);\n+            if (ds < zero) {\n+                blen = (temp - ds) / stepsq;\n+            } else {\n+                blen = resid / (temp + ds);\n+            }\n+            stplen = blen;\n+            if (shs > zero) {\n+                // Computing MIN\n+                d__1 = blen;\n+                d__2 = gredsq / shs;\n+                stplen = Math.min(d__1,d__2);\n+            }\n+\n+            // Reduce STPLEN if necessary in order to preserve the simple bounds,\n+            // letting IACT be the index of the new constrained variable.\n+\n+            iact = 0;\n+            i__1 = n;\n+            for (i__ = 1; i__ <= i__1; i__++) {\n+                if (s.get(i__) != zero) {\n+                    xsum = xopt.get(i__) + d__.get(i__);\n+                    if (s.get(i__) > zero) {\n+                        temp = (su.get(i__) - xsum) / s.get(i__);\n+                    } else {\n+                        temp = (sl.get(i__) - xsum) / s.get(i__);\n+                    }\n+                    if (temp < stplen) {\n+                        stplen = temp;\n+                        iact = i__;\n+                    }\n+                }\n+            }\n+\n+            // Update CRVMIN, GNEW and D. Set SDEC to the decrease that occurs in Q.\n+\n+            sdec = zero;\n+            if (stplen > zero) {\n+                ++iterc;\n+                temp = shs / stepsq;\n+                if (iact == 0 && temp > zero) {\n+                    crvmin.value = Math.min(crvmin.value,temp);\n+                    if (crvmin.value == onemin) {\n+                        crvmin.value = temp;\n+                    }\n+                }\n+                ggsav = gredsq;\n+                gredsq = zero;\n+                i__1 = n;\n+                for (i__ = 1; i__ <= i__1; i__++) {\n+                    gnew.set(i__, gnew.get(i__) + stplen * hs.get(i__));\n+                    if (xbdi.get(i__) == zero) {\n+                        // Computing 2nd power\n+                        d__1 = gnew.get(i__);\n+                        gredsq += d__1 * d__1;\n+                    }\n+                    d__.set(i__, d__.get(i__) + stplen * s.get(i__));\n+                }\n+                // Computing MAX\n+                d__1 = stplen * (ggsav - half * stplen * shs);\n+                sdec = Math.max(d__1,zero);\n+                qred += sdec;\n+            }\n+\n+            // Restart the conjugate gradient method if it has hit a new bound.\n+\n+            if (iact > 0) {\n+                ++nact;\n+                xbdi.set(iact, one);\n+                if (s.get(iact) < zero) {\n+                    xbdi.set(iact, onemin);\n+                }\n+                // Computing 2nd power\n+                d__1 = d__.get(iact);\n+                delsq -= d__1 * d__1;\n+                if (delsq <= zero) {\n+                    state = 190; break;\n+                }\n+                state = 20; break;\n+            }\n+\n+            // If STPLEN is less than BLEN, then either apply another conjugate\n+            // gradient iteration or RETURN.\n+\n+            if (stplen < blen) {\n+                if (iterc == itermax) {\n+                    state = 190; break;\n+                }\n+                if (sdec <= qred * .01) {\n+                    state = 190; break;\n+                }\n+                beta = gredsq / ggsav;\n+                state = 30; break;\n+            }\n+        }\n+        case 90: {\n+            crvmin.value = zero;\n+\n+            // Prepare for the alternative iteration by calculating some scalars\n+            // and by multiplying the reduced D by the second derivative matrix of\n+            // Q, where S holds the reduced D in the call of GGMULT.\n+\n+        }\n+        case 100: {\n+            if (nact >= n - 1) {\n+                state = 190; break;\n+            }\n+            dredsq = zero;\n+            dredg = zero;\n+            gredsq = zero;\n+            i__1 = n;\n+            for (i__ = 1; i__ <= i__1; i__++) {\n+                if (xbdi.get(i__) == zero) {\n+                    // Computing 2nd power\n+                    d__1 = d__.get(i__);\n+                    dredsq += d__1 * d__1;\n+                    dredg += d__.get(i__) * gnew.get(i__);\n+                    // Computing 2nd power\n+                    d__1 = gnew.get(i__);\n+                    gredsq += d__1 * d__1;\n+                    s.set(i__, d__.get(i__));\n+                } else {\n+                    s.set(i__, zero);\n+                }\n+            }\n+            itcsav = iterc;\n+            state = 210; break;\n+            // Let the search direction S be a linear combination of the reduced D\n+            // and the reduced G that is orthogonal to the reduced D.\n+        }\n+        case 120: {\n+            ++iterc;\n+            temp = gredsq * dredsq - dredg * dredg;\n+            if (temp <= qred * 1e-4 * qred) {\n+                state = 190; break;\n+            }\n+            temp = Math.sqrt(temp);\n+            i__1 = n;\n+            for (i__ = 1; i__ <= i__1; i__++) {\n+                if (xbdi.get(i__) == zero) {\n+                    s.set(i__, (dredg * d__.get(i__) - dredsq * gnew.get(i__)) / temp);\n+                } else {\n+                    s.set(i__, zero);\n+                }\n+            }\n+            sredg = -temp;\n+\n+            // By considering the simple bounds on the variables, calculate an upper\n+            // bound on the tangent of half the angle of the alternative iteration,\n+            // namely ANGBD, except that, if already a free variable has reached a\n+            // bound, there is a branch back to label 100 after fixing that variable.\n+\n+            angbd = one;\n+            iact = 0;\n+            i__1 = n;\n+            for (i__ = 1; i__ <= i__1; i__++) {\n+                if (xbdi.get(i__) == zero) {\n+                    tempa = xopt.get(i__) + d__.get(i__) - sl.get(i__);\n+                    tempb = su.get(i__) - xopt.get(i__) - d__.get(i__);\n+                    if (tempa <= zero) {\n+                        ++nact;\n+                        xbdi.set(i__, onemin);\n+                        state = 100; break;\n+                    } else if (tempb <= zero) {\n+                        ++nact;\n+                        xbdi.set(i__, one);\n+                        state = 100; break;\n+                    }\n+                    // Computing 2nd power\n+                    d__1 = d__.get(i__);\n+                    // Computing 2nd power\n+                    d__2 = s.get(i__);\n+                    ssq = d__1 * d__1 + d__2 * d__2;\n+                    // Computing 2nd power\n+                    d__1 = xopt.get(i__) - sl.get(i__);\n+                    temp = ssq - d__1 * d__1;\n+                    if (temp > zero) {\n+                        temp = Math.sqrt(temp) - s.get(i__);\n+                        if (angbd * temp > tempa) {\n+                            angbd = tempa / temp;\n+                            iact = i__;\n+                            xsav = onemin;\n+                        }\n+                    }\n+                    // Computing 2nd power\n+                    d__1 = su.get(i__) - xopt.get(i__);\n+                    temp = ssq - d__1 * d__1;\n+                    if (temp > zero) {\n+                        temp = Math.sqrt(temp) + s.get(i__);\n+                        if (angbd * temp > tempb) {\n+                            angbd = tempb / temp;\n+                            iact = i__;\n+                            xsav = one;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            // Calculate HHD and some curvatures for the alternative iteration.\n+\n+            state = 210; break;\n+        }\n+        case 150: {\n+            shs = zero;\n+            dhs = zero;\n+            dhd = zero;\n+            i__1 = n;\n+            for (i__ = 1; i__ <= i__1; i__++) {\n+                if (xbdi.get(i__) == zero) {\n+                    shs += s.get(i__) * hs.get(i__);\n+                    dhs += d__.get(i__) * hs.get(i__);\n+                    dhd += d__.get(i__) * hred.get(i__);\n+                }\n+            }\n+\n+            // Seek the greatest reduction in Q for a range of equally spaced values\n+            // of ANGT in [0,ANGBD], where ANGT is the tangent of half the angle of\n+            // the alternative iteration.\n+\n+            redmax = zero;\n+            isav = 0;\n+            redsav = zero;\n+            iu = (int) (angbd * 17. + 3.1);\n+            i__1 = iu;\n+            for (i__ = 1; i__ <= i__1; i__++) {\n+                angt = angbd * (double) i__ / (double) iu;\n+                sth = (angt + angt) / (one + angt * angt);\n+                temp = shs + angt * (angt * dhd - dhs - dhs);\n+                rednew = sth * (angt * dredg - sredg - half * sth * temp);\n+                if (rednew > redmax) {\n+                    redmax = rednew;\n+                    isav = i__;\n+                    rdprev = redsav;\n+                } else if (i__ == isav + 1) {\n+                    rdnext = rednew;\n+                }\n+                redsav = rednew;\n+            }\n+\n+            // Return if the reduction is zero. Otherwise, set the sine and cosine\n+            // of the angle of the alternative iteration, and calculate SDEC.\n+\n+            if (isav == 0) {\n+                state = 190; break;\n+            }\n+            if (isav < iu) {\n+                temp = (rdnext - rdprev) / (redmax + redmax - rdprev - rdnext);\n+                angt = angbd * ((double) isav + half * temp) / (double) iu;\n+            }\n+            cth = (one - angt * angt) / (one + angt * angt);\n+            sth = (angt + angt) / (one + angt * angt);\n+            temp = shs + angt * (angt * dhd - dhs - dhs);\n+            sdec = sth * (angt * dredg - sredg - half * sth * temp);\n+            if (sdec <= zero) {\n+                state = 190; break;\n+            }\n+\n+            // Update GNEW, D and HRED. If the angle of the alternative iteration\n+            // is restricted by a bound on a free variable, that variable is fixed\n+            // at the bound.\n+\n+            dredg = zero;\n+            gredsq = zero;\n+            i__1 = n;\n+            for (i__ = 1; i__ <= i__1; i__++) {\n+                gnew.set(i__, gnew.get(i__) + (cth - one) * hred.get(i__) + sth * hs.get(i__));\n+                if (xbdi.get(i__) == zero) {\n+                    d__.set(i__, cth * d__.get(i__) + sth * s.get(i__));\n+                    dredg += d__.get(i__) * gnew.get(i__);\n+                    // Computing 2nd power\n+                    d__1 = gnew.get(i__);\n+                    gredsq += d__1 * d__1;\n+                }\n+                hred.set(i__, cth * hred.get(i__) + sth * hs.get(i__));\n+            }\n+            qred += sdec;\n+            if (iact > 0 && isav == iu) {\n+                ++nact;\n+                xbdi.set(iact, xsav);\n+                state = 100; break;\n+            }\n+\n+            // If SDEC is sufficiently small, then RETURN after setting XNEW to\n+            // XOPT+D, giving careful attention to the bounds.\n+\n+            if (sdec > qred * .01) {\n+                state = 120; break;\n+            }\n+        }\n+        case 190: {\n+            dsq.value = zero;\n+            i__1 = n;\n+            for (i__ = 1; i__ <= i__1; i__++) {\n+                // Computing MAX\n+                // Computing MIN\n+                d__3 = xopt.get(i__) + d__.get(i__);\n+                d__4 = su.get(i__);\n+                d__1 = Math.min(d__3,d__4);\n+                d__2 = sl.get(i__);\n+                xnew.set(i__, Math.max(d__1,d__2));\n+                if (xbdi.get(i__) == onemin) {\n+                    xnew.set(i__, sl.get(i__));\n+                }\n+                if (xbdi.get(i__) == one) {\n+                    xnew.set(i__, su.get(i__));\n+                }\n+                d__.set(i__, xnew.get(i__) - xopt.get(i__));\n+                // Computing 2nd power\n+                d__1 = d__.get(i__);\n+                dsq.value += d__1 * d__1;\n+            }\n+            return;\n+            // The following instructions multiply the current S-vector by the second\n+            // derivative matrix of the quadratic model, putting the product in HS.\n+            // They are reached from three different parts of the software above and\n+            // they can be regarded as an external subroutine.\n+        }\n+        case 210: {\n+            ih = 0;\n+            i__1 = n;\n+            for (j = 1; j <= i__1; j++) {\n+                hs.set(j, zero);\n+                i__2 = j;\n+                for (i__ = 1; i__ <= i__2; i__++) {\n+                    ++ih;\n+                    if (i__ < j) {\n+                        hs.set(j, hs.get(j) + hq.get(ih) * s.get(i__));\n+                    }\n+                    hs.set(i__, hs.get(i__) + hq.get(ih) * s.get(j));\n+                }\n+            }\n+            i__2 = npt;\n+            for (k = 1; k <= i__2; k++) {\n+                if (pq.get(k) != zero) {\n+                    temp = zero;\n+                    i__1 = n;\n+                    for (j = 1; j <= i__1; j++) {\n+                        temp += xpt.get(k + j * xpt_dim1) * s.get(j);\n+                    }\n+                    temp *= pq.get(k);\n+                    i__1 = n;\n+                    for (i__ = 1; i__ <= i__1; i__++) {\n+                        hs.set(i__, hs.get(i__) + temp * xpt.get(k + i__ * xpt_dim1));\n+                    }\n+                }\n+            }\n+            if (crvmin.value != zero) {\n+                state = 50; break;\n+            }\n+            if (iterc > itcsav) {\n+                state = 150; break;\n+            }\n+            i__2 = n;\n+            for (i__ = 1; i__ <= i__2; i__++) {\n+                hred.set(i__, hs.get(i__));\n+            }\n+            state = 120; break;\n+        }}\n+    } // trsbox\n+\n+    // ----------------------------------------------------------------------------------------\n+\n+    /**\n+     *     The arrays BMAT and ZMAT are updated, as required by the new position\n+     *     of the interpolation point that has the index KNEW. The vector VLAG has\n+     *     N+NPT components, set on entry to the first NPT and last N components\n+     *     of the product Hw in equation (4.11) of the Powell (2006) paper on\n+     *     NEWUOA. Further, BETA is set on entry to the value of the parameter\n+     *     with that name, and DENOM is set to the denominator of the updating\n+     *     formula. Elements of ZMAT may be treated as zero if their moduli are\n+     *     at most ZTEST. The first NDIM elements of W are used for working space.\n+     * @param n\n+     * @param npt\n+     * @param bmat\n+     * @param zmat\n+     * @param ndim\n+     * @param vlag\n+     * @param beta\n+     * @param denom\n+     * @param knew\n+     * @param w\n+     */\n+    private void update(\n+            int n,\n+            int npt,\n+            ScopedPtr bmat,\n+            ScopedPtr zmat,\n+            int ndim,\n+            ScopedPtr vlag,\n+            double beta,\n+            double denom,\n+            int knew,\n+            ScopedPtr w\n+    ) {\n+        // System generated locals\n+        int bmat_dim1, zmat_dim1, i__1, i__2;\n+        double d__1, d__2, d__3;\n+\n+        // Local variables\n+        int i__, j, k, jp;\n+        double one, tau, temp;\n+        int nptm;\n+        double zero, alpha, tempa, tempb, ztest;\n+\n+        zmat_dim1 = npt;\n+        bmat_dim1 = ndim;\n+\n+        // Function Body\n+        one = 1.;\n+        zero = 0.;\n+        nptm = npt - n - 1;\n+        ztest = zero;\n+        i__1 = npt;\n+        for (k = 1; k <= i__1; k++) {\n+            i__2 = nptm;\n+            for (j = 1; j <= i__2; j++) {\n+                // Computing MAX\n+                d__2 = ztest;\n+                d__1 = zmat.get(k + j * zmat_dim1);\n+                d__3 = Math.abs(d__1);\n+                ztest = Math.max(d__2,d__3);\n+            }\n+        }\n+        ztest *= 1e-20;\n+\n+        // Apply the rotations that put zeros in the KNEW-th row of ZMAT.\n+\n+        i__2 = nptm;\n+        for (j = 2; j <= i__2; j++) {\n+            d__1 = zmat.get(knew + j * zmat_dim1);\n+            if (Math.abs(d__1) > ztest) {\n+                // Computing 2nd power\n+                d__1 = zmat.get(knew + zmat_dim1);\n+                // Computing 2nd power\n+                d__2 = zmat.get(knew + j * zmat_dim1);\n+                temp = Math.sqrt(d__1 * d__1 + d__2 * d__2);\n+                tempa = zmat.get(knew + zmat_dim1) / temp;\n+                tempb = zmat.get(knew + j * zmat_dim1) / temp;\n+                i__1 = npt;\n+                for (i__ = 1; i__ <= i__1; i__++) {\n+                    temp = tempa * zmat.get(i__ + zmat_dim1) + tempb * zmat.get(i__ + j *\n+                            zmat_dim1);\n+                    zmat.set(i__ + j * zmat_dim1, tempa * zmat.get(i__ + j * zmat_dim1) -\n+                            tempb * zmat.get(i__ + zmat_dim1));\n+                    zmat.set(i__ + zmat_dim1, temp);\n+                }\n+            }\n+            zmat.set(knew + j * zmat_dim1, zero);\n+        }\n+\n+        // Put the first NPT components of the KNEW-th column of HLAG into W,\n+        // and calculate the parameters of the updating formula.\n+\n+        i__2 = npt;\n+        for (i__ = 1; i__ <= i__2; i__++) {\n+            w.set(i__, zmat.get(knew + zmat_dim1) * zmat.get(i__ + zmat_dim1));\n+        }\n+        alpha = w.get(knew);\n+        tau = vlag.get(knew);\n+        vlag.set(knew, vlag.get(knew) - one);\n+\n+        // Complete the updating of ZMAT.\n+\n+        temp = Math.sqrt(denom);\n+        tempb = zmat.get(knew + zmat_dim1) / temp;\n+        tempa = tau / temp;\n+        i__2 = npt;\n+        for (i__ = 1; i__ <= i__2; i__++) {\n+            zmat.set(i__ + zmat_dim1, tempa * zmat.get(i__ + zmat_dim1) -\n+                    tempb * vlag.get(i__));\n+        }\n+\n+        // Finally, update the matrix BMAT.\n+\n+        i__2 = n;\n+        for (j = 1; j <= i__2; j++) {\n+            jp = npt + j;\n+            w.set(jp, bmat.get(knew + j * bmat_dim1));\n+            tempa = (alpha * vlag.get(jp) - tau * w.get(jp)) / denom;\n+            tempb = (-beta * w.get(jp) - tau * vlag.get(jp)) / denom;\n+            i__1 = jp;\n+            for (i__ = 1; i__ <= i__1; i__++) {\n+                bmat.set(i__ + j * bmat_dim1, bmat.get(i__ + j * bmat_dim1) + tempa *\n+                        vlag.get(i__) + tempb * w.get(i__));\n+                if (i__ > npt) {\n+                    bmat.set(jp + (i__ - npt) * bmat_dim1, bmat.get(i__ + j * bmat_dim1));\n+                }\n+            }\n+        }\n+    } // update\n+\n+    /**\n+     * Checks dimensions and values of boundaries and inputSigma if defined.\n+     */\n+    private void checkParameters() {\n+        double[] init = getStartPoint();\n+        if (boundaries != null) {\n+            if (boundaries.length != 2) {\n+                throw new MultiDimensionMismatchException(\n+                        new Integer[] { boundaries.length },\n+                        new Integer[] { 2 });\n+            }\n+            if (boundaries[0] == null || boundaries[1] == null) {\n+                throw new NoDataException();\n+            }\n+            if (boundaries[0].length != init.length) {\n+                throw new MultiDimensionMismatchException(\n+                        new Integer[] { boundaries[0].length },\n+                        new Integer[] { init.length });\n+            }\n+            if (boundaries[1].length != init.length) {\n+                throw new MultiDimensionMismatchException(\n+                        new Integer[] { boundaries[1].length },\n+                        new Integer[] { init.length });\n+            }\n+            for (int i = 0; i < init.length; i++) {\n+                if (boundaries[0][i] > init[i] || boundaries[1][i] < init[i]) {\n+                    throw new OutOfRangeException(init[i], boundaries[0][i],\n+                            boundaries[1][i]);\n+                }\n+            }\n+        }\n+    }\n+\n+    // auxiliary subclasses\n+\n+    /**\n+     * Double reference\n+     */\n+    private static class DoubleRef {\n+        /**\n+         * stored double value.\n+         */\n+        private double value;\n+\n+        /**\n+         * @param value stored double value.\n+         */\n+        DoubleRef(double value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    /**\n+     * Integer reference\n+     */\n+    private static class IntRef {\n+        /**\n+         * stored int value.\n+         */\n+        private int value;\n+\n+        /**\n+         * @param value stored int value.\n+         */\n+        IntRef(int value) {\n+            this.value = value;\n+        }\n+    }\n+\n+    /**\n+     * Used to simulate Fortran pointers.\n+     */\n+    private static class ScopedPtr {\n+        /**\n+         * array storing elements.\n+         */\n+        private double[] w;\n+        /**\n+         * base index for access.\n+         */\n+        private int base;\n+\n+        /**\n+         * @param w array storing elements.\n+         * @param base base index for access.\n+         */\n+        ScopedPtr(double[] w, int base) {\n+            this.w = w;\n+            this.base = base;\n+        }\n+\n+        /**\n+         * @param index realtive index of returned ScopedPtr\n+         * @return ScopedPtr with new base = this.base + index\n+         */\n+        ScopedPtr ptr(int index) {\n+            return new ScopedPtr(w, base + index);\n+        }\n+\n+        /**\n+         * @param index of accessed element relative to base.\n+         * @return value returned value at index.\n+         */\n+        double get(int index) {\n+            return w[base + index];\n+        }\n+\n+        /**\n+         * @param index of accessed elements relative to base.\n+         * @param n number of values to be returned.\n+         * @return n values starting at index.\n+         */\n+        double[] getAll(int index, int n) {\n+            return Arrays.copyOfRange(w, base+index, base+index+n);\n+        }\n+\n+        /**\n+         * @return all elements.\n+         */\n+        double[] getAll() {\n+            return w;\n+        }\n+\n+        /**\n+         * @param index index of accessed element relative to base.\n+         * @param value stored at index.\n+         */\n+        void set(int index, double value) {\n+            w[base + index] = value;\n+        }\n+\n+        /* (non-Javadoc)\n+         * @see java.lang.Object#toString()\n+         */\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            for (int i = 0; i < 20; i++)\n+                if (base + i >= 0 && base + i < w.length)\n+                    sb.append(\"\" + i + \":\" + w[base + i] + \"\\n\");\n+            return sb.toString();\n+        }\n+\n+    }\n+\n+    /**\n+     * @param n dimension.\n+     * @param value value set for each element.\n+     * @return array containing n values.\n+     */\n+    private static double[] point(int n, double value) {\n+        double[] ds = new double[n];\n+        Arrays.fill(ds, value);\n+        return ds;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizerTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.optimization.direct;\n+\n+import static org.junit.Assert.fail;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.exception.MultiDimensionMismatchException;\n+import org.apache.commons.math.exception.NoDataException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.MultivariateRealOptimizer;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test for {@link BOBYQAOptimizer}.\n+ */\n+public class BOBYQAOptimizerTest {\n+\n+    static final int DIM = 13;\n+ \n+    @Test(expected = OutOfRangeException.class)\n+    public void testInitOutofbounds() {\n+        double[] startPoint = point(DIM,3);\n+        double[][] boundaries = boundaries(DIM,-1,2);\n+        RealPointValuePair expected =\n+            new RealPointValuePair(point(DIM,1.0),0.0);\n+        doTest(new Rosen(), startPoint, boundaries,\n+                GoalType.MINIMIZE, \n+                1e-13, 1e-6, 2000, expected);\n+    }\n+    \n+    @Test(expected = MultiDimensionMismatchException.class)\n+    public void testBoundariesDimensionMismatch() {\n+        double[] startPoint = point(DIM,0.5);\n+        double[][] boundaries = boundaries(DIM+1,-1,2);\n+        RealPointValuePair expected =\n+            new RealPointValuePair(point(DIM,1.0),0.0);\n+        doTest(new Rosen(), startPoint, boundaries,\n+                GoalType.MINIMIZE, \n+                1e-13, 1e-6, 2000, expected);\n+    }\n+\n+    @Test(expected = NoDataException.class)\n+    public void testBoundariesNoData() {\n+        double[] startPoint = point(DIM,0.5);\n+        double[][] boundaries = boundaries(DIM,-1,2);\n+        boundaries[1] = null;\n+        RealPointValuePair expected =\n+            new RealPointValuePair(point(DIM,1.0),0.0);\n+        doTest(new Rosen(), startPoint, boundaries,\n+                GoalType.MINIMIZE, \n+                1e-13, 1e-6, 2000, expected);\n+    }\n+    \n+    @Test\n+    public void testRosen() {\n+        double[] startPoint = point(DIM,0.1);\n+        double[][] boundaries = null;\n+        RealPointValuePair expected =\n+            new RealPointValuePair(point(DIM,1.0),0.0);\n+        doTest(new Rosen(), startPoint, boundaries,\n+                GoalType.MINIMIZE, \n+                1e-13, 1e-6, 2000, expected);\n+     }\n+    \n+    @Test\n+    public void testRescue() {\n+        double[] startPoint = point(13,1.0);\n+        double[][] boundaries = null;\n+        RealPointValuePair expected =\n+            new RealPointValuePair(point(13,0.0),0);\n+        try {\n+            doTest(new MinusElli(), startPoint, boundaries,\n+                GoalType.MINIMIZE, \n+                1e-13, 1e-6, 1000, expected);\n+            fail(\"An TooManyEvaluationsException should have been thrown\");\n+        } catch(TooManyEvaluationsException e) {\n+        }\n+    }\n+\n+    @Test\n+    public void testMaximize() {\n+        double[] startPoint = point(DIM,1.0);\n+        double[][] boundaries = null;\n+        RealPointValuePair expected =\n+            new RealPointValuePair(point(DIM,0.0),1.0);\n+        doTest(new MinusElli(), startPoint, boundaries,\n+                GoalType.MAXIMIZE, \n+                2e-10, 5e-6, 1000, expected);\n+        boundaries = boundaries(DIM,-0.3,0.3); \n+        startPoint = point(DIM,0.1);\n+        doTest(new MinusElli(), startPoint, boundaries,\n+                GoalType.MAXIMIZE, \n+                2e-10, 5e-6, 1000, expected);\n+    }\n+\n+    @Test\n+    public void testEllipse() {\n+        double[] startPoint = point(DIM,1.0);\n+        double[][] boundaries = null;\n+        RealPointValuePair expected =\n+            new RealPointValuePair(point(DIM,0.0),0.0);\n+        doTest(new Elli(), startPoint, boundaries,\n+                GoalType.MINIMIZE, \n+                1e-13, 1e-6, 1000, expected);\n+     }\n+\n+    @Test\n+    public void testElliRotated() {\n+        double[] startPoint = point(DIM,1.0);\n+        double[][] boundaries = null;\n+        RealPointValuePair expected =\n+            new RealPointValuePair(point(DIM,0.0),0.0);\n+        doTest(new ElliRotated(), startPoint, boundaries,\n+                GoalType.MINIMIZE, \n+                1e-12, 1e-6, 10000, expected);\n+    }\n+\n+    @Test\n+    public void testCigar() {\n+        double[] startPoint = point(DIM,1.0);\n+        double[][] boundaries = null;\n+        RealPointValuePair expected =\n+            new RealPointValuePair(point(DIM,0.0),0.0);\n+        doTest(new Cigar(), startPoint, boundaries,\n+                GoalType.MINIMIZE, \n+                1e-13, 1e-6, 100, expected);\n+    }\n+\n+    @Test\n+    public void testTwoAxes() {\n+        double[] startPoint = point(DIM,1.0);\n+        double[][] boundaries = null;\n+        RealPointValuePair expected =\n+            new RealPointValuePair(point(DIM,0.0),0.0);\n+        doTest(new TwoAxes(), startPoint, boundaries,\n+                GoalType.MINIMIZE, 2*\n+                1e-13, 1e-6, 100, expected);\n+     }\n+\n+    @Test\n+    public void testCigTab() {\n+        double[] startPoint = point(DIM,1.0);\n+        double[][] boundaries = null;\n+        RealPointValuePair expected =\n+            new RealPointValuePair(point(DIM,0.0),0.0);\n+        doTest(new CigTab(), startPoint, boundaries,\n+                GoalType.MINIMIZE, \n+                1e-13, 5e-5, 100, expected);\n+     }\n+\n+    @Test\n+    public void testSphere() {\n+        double[] startPoint = point(DIM,1.0);\n+        double[][] boundaries = null;\n+        RealPointValuePair expected =\n+            new RealPointValuePair(point(DIM,0.0),0.0);\n+        doTest(new Sphere(), startPoint, boundaries,\n+                GoalType.MINIMIZE, \n+                1e-13, 1e-6, 100, expected);\n+    }\n+\n+    @Test\n+    public void testTablet() {\n+        double[] startPoint = point(DIM,1.0); \n+        double[][] boundaries = null;\n+        RealPointValuePair expected =\n+            new RealPointValuePair(point(DIM,0.0),0.0);\n+        doTest(new Tablet(), startPoint, boundaries,\n+                GoalType.MINIMIZE, \n+                1e-13, 1e-6, 100, expected);\n+    }\n+\n+    @Test\n+    public void testDiffPow() {\n+        double[] startPoint = point(DIM/2,1.0);\n+        double[][] boundaries = null;\n+        RealPointValuePair expected =\n+            new RealPointValuePair(point(DIM/2,0.0),0.0);\n+        doTest(new DiffPow(), startPoint, boundaries,\n+                GoalType.MINIMIZE, \n+                1e-8, 1e-1, 12000, expected);\n+    }\n+\n+    @Test\n+    public void testSsDiffPow() {\n+        double[] startPoint = point(DIM/2,1.0);\n+        double[][] boundaries = null;\n+        RealPointValuePair expected =\n+            new RealPointValuePair(point(DIM/2,0.0),0.0);\n+        doTest(new SsDiffPow(), startPoint, boundaries,\n+                GoalType.MINIMIZE, \n+                1e-2, 1.3e-1, 50000, expected);\n+    }\n+\n+    @Test\n+    public void testAckley() {\n+        double[] startPoint = point(DIM,0.1);\n+        double[][] boundaries = null;\n+        RealPointValuePair expected =\n+            new RealPointValuePair(point(DIM,0.0),0.0);\n+        doTest(new Ackley(), startPoint, boundaries,\n+                GoalType.MINIMIZE,\n+                1e-8, 1e-5, 1000, expected);\n+    }\n+\n+    @Test\n+    public void testRastrigin() {\n+        double[] startPoint = point(DIM,1.0);\n+\n+        double[][] boundaries = null;\n+        RealPointValuePair expected =\n+            new RealPointValuePair(point(DIM,0.0),0.0);\n+        doTest(new Rastrigin(), startPoint, boundaries,\n+                GoalType.MINIMIZE, \n+                1e-13, 1e-6, 1000, expected);\n+    }\n+\n+    @Test\n+    public void testConstrainedRosen() {\n+        double[] startPoint = point(DIM,0.1);\n+\n+        double[][] boundaries = boundaries(DIM,-1,2);\n+        RealPointValuePair expected =\n+            new RealPointValuePair(point(DIM,1.0),0.0);\n+        doTest(new Rosen(), startPoint, boundaries,\n+                GoalType.MINIMIZE,\n+                1e-13, 1e-6, 2000, expected);\n+    }\n+\n+    @Test\n+    public void testDiagonalRosen() {\n+        double[] startPoint = point(DIM,0.1);\n+        double[][] boundaries = null;\n+        RealPointValuePair expected =\n+            new RealPointValuePair(point(DIM,1.0),0.0);\n+        doTest(new Rosen(), startPoint, boundaries,\n+                GoalType.MINIMIZE, \n+                1e-10, 1e-4, 2000, expected);\n+     }\n+\n+    /**\n+     * @param func Function to optimize.\n+     * @param startPoint Starting point.\n+     * @param boundaries Upper / lower point limit.\n+     * @param goal Minimization or maximization.\n+     * @param fTol Tolerance relative error on the objective function.\n+     * @param pointTol Tolerance for checking that the optimum is correct.\n+     * @param maxEvaluations Maximum number of evaluations.\n+     * @param expected Expected point / value.\n+     */\n+    private void doTest(MultivariateRealFunction func,\n+            double[] startPoint,\n+            double[][] boundaries,\n+            GoalType goal,\n+            double fTol,\n+            double pointTol,\n+            int maxEvaluations,\n+            RealPointValuePair expected) {\n+        int dim = startPoint.length;\n+//        MultivariateRealOptimizer optim =\n+//            new PowellOptimizer(1e-13, Math.ulp(1d));\n+//        RealPointValuePair result = optim.optimize(100000, func, goal, startPoint);\n+        MultivariateRealOptimizer optim =\n+            new BOBYQAOptimizer(boundaries);\n+        RealPointValuePair result = optim.optimize(maxEvaluations, func, goal, startPoint);        \n+//        System.out.println(func.getClass().getName() + \" = \" \n+//        \t\t+ optim.getEvaluations() + \" f(\");\n+//        for (double x: result.getPoint())  System.out.print(x + \" \");\n+//        System.out.println(\") = \" +  result.getValue());\n+        Assert.assertEquals(expected.getValue(),\n+                result.getValue(), fTol);\n+        for (int i = 0; i < dim; i++) {\n+            Assert.assertEquals(expected.getPoint()[i],\n+                    result.getPoint()[i], pointTol);\n+        }\n+    }\n+\n+    private static double[] point(int n, double value) {\n+        double[] ds = new double[n];\n+        Arrays.fill(ds, value);\n+        return ds;\n+    }\n+\n+    private static double[][] boundaries(int dim,\n+            double lower, double upper) {\n+        double[][] boundaries = new double[2][dim];\n+        for (int i = 0; i < dim; i++)\n+            boundaries[0][i] = lower;\n+        for (int i = 0; i < dim; i++)\n+            boundaries[1][i] = upper;\n+        return boundaries;\n+    }\n+\n+    private static class Sphere implements MultivariateRealFunction {\n+\n+        public double value(double[] x) {\n+            double f = 0;\n+            for (int i = 0; i < x.length; ++i)\n+                f += x[i] * x[i];\n+            return f;\n+        }\n+    }\n+\n+    private static class Cigar implements MultivariateRealFunction {\n+        private double factor;\n+\n+        Cigar() {\n+            this(1e3);\n+        }\n+\n+        Cigar(double axisratio) {\n+            factor = axisratio * axisratio;\n+        }\n+\n+        public double value(double[] x) {\n+            double f = x[0] * x[0];\n+            for (int i = 1; i < x.length; ++i)\n+                f += factor * x[i] * x[i];\n+            return f;\n+        }\n+    }\n+\n+    private static class Tablet implements MultivariateRealFunction {\n+        private double factor;\n+\n+        Tablet() {\n+            this(1e3);\n+        }\n+\n+        Tablet(double axisratio) {\n+            factor = axisratio * axisratio;\n+        }\n+\n+        public double value(double[] x) {\n+            double f = factor * x[0] * x[0];\n+            for (int i = 1; i < x.length; ++i)\n+                f += x[i] * x[i];\n+            return f;\n+        }\n+    }\n+\n+    private static class CigTab implements MultivariateRealFunction {\n+        private double factor;\n+\n+        CigTab() {\n+            this(1e4);\n+        }\n+\n+        CigTab(double axisratio) {\n+            factor = axisratio;\n+        }\n+\n+        public double value(double[] x) {\n+            int end = x.length - 1;\n+            double f = x[0] * x[0] / factor + factor * x[end] * x[end];\n+            for (int i = 1; i < end; ++i)\n+                f += x[i] * x[i];\n+            return f;\n+        }\n+    }\n+\n+    private static class TwoAxes implements MultivariateRealFunction {\n+\n+        private double factor;\n+\n+        TwoAxes() {\n+            this(1e6);\n+        }\n+\n+        TwoAxes(double axisratio) {\n+            factor = axisratio * axisratio;\n+        }\n+\n+        public double value(double[] x) {\n+            double f = 0;\n+            for (int i = 0; i < x.length; ++i)\n+                f += (i < x.length / 2 ? factor : 1) * x[i] * x[i];\n+            return f;\n+        }\n+    }\n+\n+    private static class ElliRotated implements MultivariateRealFunction {\n+        private Basis B = new Basis();\n+        private double factor;\n+\n+        ElliRotated() {\n+            this(1e3);\n+        }\n+\n+        ElliRotated(double axisratio) {\n+            factor = axisratio * axisratio;\n+        }\n+\n+        public double value(double[] x) {\n+            double f = 0;\n+            x = B.Rotate(x);\n+            for (int i = 0; i < x.length; ++i)\n+                f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i];\n+            return f;\n+        }\n+    }\n+\n+    private static class Elli implements MultivariateRealFunction {\n+\n+        private double factor;\n+\n+        Elli() {\n+            this(1e3);\n+        }\n+\n+        Elli(double axisratio) {\n+            factor = axisratio * axisratio;\n+        }\n+\n+        public double value(double[] x) {\n+            double f = 0;\n+            for (int i = 0; i < x.length; ++i)\n+                f += Math.pow(factor, i / (x.length - 1.)) * x[i] * x[i];\n+            return f;\n+        }\n+    }\n+\n+    private static class MinusElli implements MultivariateRealFunction {\n+        private int fcount = 0;\n+        public double value(double[] x) {\n+          double f = 1.0-(new Elli().value(x));\n+//          System.out.print(\"\" + (fcount++) + \") \");\n+//          for (int i = 0; i < x.length; i++)\n+//              System.out.print(x[i] +  \" \");\n+//          System.out.println(\" = \" + f);\n+          return f;\n+       }\n+    }\n+\n+    private static class DiffPow implements MultivariateRealFunction {\n+        private int fcount = 0;\n+        public double value(double[] x) {\n+            double f = 0;\n+            for (int i = 0; i < x.length; ++i)\n+                f += Math.pow(Math.abs(x[i]), 2. + 10 * (double) i\n+                        / (x.length - 1.));\n+//            System.out.print(\"\" + (fcount++) + \") \");\n+//            for (int i = 0; i < x.length; i++)\n+//                System.out.print(x[i] +  \" \");\n+//            System.out.println(\" = \" + f);\n+            return f;\n+        }\n+    }\n+\n+    private static class SsDiffPow implements MultivariateRealFunction {\n+\n+        public double value(double[] x) {\n+            double f = Math.pow(new DiffPow().value(x), 0.25);\n+            return f;\n+        }\n+    }\n+\n+    private static class Rosen implements MultivariateRealFunction {\n+\n+        public double value(double[] x) {\n+            double f = 0;\n+            for (int i = 0; i < x.length - 1; ++i)\n+                f += 1e2 * (x[i] * x[i] - x[i + 1]) * (x[i] * x[i] - x[i + 1])\n+                + (x[i] - 1.) * (x[i] - 1.);\n+            return f;\n+        }\n+    }\n+\n+    private static class Ackley implements MultivariateRealFunction {\n+        private double axisratio;\n+\n+        Ackley(double axra) {\n+            axisratio = axra;\n+        }\n+\n+        public Ackley() {\n+            this(1);\n+        }\n+\n+        public double value(double[] x) {\n+            double f = 0;\n+            double res2 = 0;\n+            double fac = 0;\n+            for (int i = 0; i < x.length; ++i) {\n+                fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.));\n+                f += fac * fac * x[i] * x[i];\n+                res2 += Math.cos(2. * Math.PI * fac * x[i]);\n+            }\n+            f = (20. - 20. * Math.exp(-0.2 * Math.sqrt(f / x.length))\n+                    + Math.exp(1.) - Math.exp(res2 / x.length));\n+            return f;\n+        }\n+    }\n+\n+    private static class Rastrigin implements MultivariateRealFunction {\n+\n+        private double axisratio;\n+        private double amplitude;\n+\n+        Rastrigin() {\n+            this(1, 10);\n+        }\n+\n+        Rastrigin(double axisratio, double amplitude) {\n+            this.axisratio = axisratio;\n+            this.amplitude = amplitude;\n+        }\n+\n+        public double value(double[] x) {\n+            double f = 0;\n+            double fac;\n+            for (int i = 0; i < x.length; ++i) {\n+                fac = Math.pow(axisratio, (i - 1.) / (x.length - 1.));\n+                if (i == 0 && x[i] < 0)\n+                    fac *= 1.;\n+                f += fac * fac * x[i] * x[i] + amplitude\n+                * (1. - Math.cos(2. * Math.PI * fac * x[i]));\n+            }\n+            return f;\n+        }\n+    }\n+\n+    private static class Basis {\n+        double[][] basis;\n+        Random rand = new Random(2); // use not always the same basis\n+\n+        double[] Rotate(double[] x) {\n+            GenBasis(x.length);\n+            double[] y = new double[x.length];\n+            for (int i = 0; i < x.length; ++i) {\n+                y[i] = 0;\n+                for (int j = 0; j < x.length; ++j)\n+                    y[i] += basis[i][j] * x[j];\n+            }\n+            return y;\n+        }\n+\n+        void GenBasis(int DIM) {\n+            if (basis != null ? basis.length == DIM : false)\n+                return;\n+\n+            double sp;\n+            int i, j, k;\n+\n+            /* generate orthogonal basis */\n+            basis = new double[DIM][DIM];\n+            for (i = 0; i < DIM; ++i) {\n+                /* sample components gaussian */\n+                for (j = 0; j < DIM; ++j)\n+                    basis[i][j] = rand.nextGaussian();\n+                /* substract projection of previous vectors */\n+                for (j = i - 1; j >= 0; --j) {\n+                    for (sp = 0., k = 0; k < DIM; ++k)\n+                        sp += basis[i][k] * basis[j][k]; /* scalar product */\n+                    for (k = 0; k < DIM; ++k)\n+                        basis[i][k] -= sp * basis[j][k]; /* substract */\n+                }\n+                /* normalize */\n+                for (sp = 0., k = 0; k < DIM; ++k)\n+                    sp += basis[i][k] * basis[i][k]; /* squared norm */\n+                for (k = 0; k < DIM; ++k)\n+                    basis[i][k] /= Math.sqrt(sp);\n+            }\n+        }\n+    }\n+}", "timestamp": 1312649679, "metainfo": ""}