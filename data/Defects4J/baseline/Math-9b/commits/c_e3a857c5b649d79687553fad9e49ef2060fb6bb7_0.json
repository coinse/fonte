{"sha": "e3a857c5b649d79687553fad9e49ef2060fb6bb7", "log": "Changed implementation to wrap, rather than extend SumOfLogs.   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/univariate/moment/GeometricMean.java\n+++ b/src/java/org/apache/commons/math/stat/univariate/moment/GeometricMean.java\n  */\n package org.apache.commons.math.stat.univariate.moment;\n \n-import java.io.Serializable;\n-\n+import org.apache.commons.math.stat.univariate.AbstractStorelessUnivariateStatistic;\n import org.apache.commons.math.stat.univariate.summary.SumOfLogs;\n \n /**\n  * Returns the <a href=\"http://www.xycoon.com/geometric_mean.htm\">\n  * geometric mean </a> of the available values.\n  * <p>\n- * Uses {@link SumOfLogs} superclass to compute sum of logs and returns\n+ * Uses a {@link SumOfLogs} instance to compute sum of logs and returns\n  * <code> exp( 1/n  (sum of logs) ).</code>  Therefore,\n  * <ul>\n  * <li>If any of values are < 0, the result is <code>NaN.</code></li>\n- * <li>If all values are non-negative and less than <code>Double.POSITIVE_INFINITY</code>, \n- * but at least one value is 0, the result is <code>0.</code></li>\n+ * <li>If all values are non-negative and less than \n+ * <code>Double.POSITIVE_INFINITY</code>,  but at least one value is 0, the \n+ * result is <code>0.</code></li>\n  * <li>If both <code>Double.POSITIVE_INFINITY</code> and \n  * <code>Double.NEGATIVE_INFINITY</code> are among the values, the result is\n  * <code>NaN.</code></li>\n  * <code>clear()</code> method, it must be synchronized externally.\n  * \n  *\n- * @version $Revision: 1.21 $ $Date: 2004/07/04 09:02:36 $\n+ * @version $Revision: 1.22 $ $Date: 2004/07/18 04:37:08 $\n  */\n-public class GeometricMean extends SumOfLogs implements Serializable{\n+public class GeometricMean extends AbstractStorelessUnivariateStatistic {\n \n     /** Serializable version identifier */\n     static final long serialVersionUID = -8178734905303459453L;  \n-      \n-    /**Number of values that have been added */\n-    protected long n = 0;\n+    \n+    /** Wrapped SumOfLogs instance */\n+    private SumOfLogs sumOfLogs;\n \n+    /**\n+     * Create a GeometricMean instance\n+     */\n+    public GeometricMean() {\n+        sumOfLogs = new SumOfLogs();\n+    }\n+    \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#increment(double)\n      */\n     public void increment(final double d) {\n-        n++;\n-        super.increment(d);\n+        sumOfLogs.increment(d);\n     }\n \n     /**\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getResult()\n      */\n     public double getResult() {\n-        if (n > 0) {\n-            return Math.exp(super.getResult() / (double) n);\n+        if (sumOfLogs.getN() > 0) {\n+            return Math.exp(sumOfLogs.getResult() / (double) sumOfLogs.getN());\n         } else {\n             return Double.NaN;\n         }\n      * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#clear()\n      */\n     public void clear() {\n-        super.clear();\n-        n = 0;\n+        sumOfLogs.clear();\n     }\n \n     /**\n      * index parameters are not valid\n      */\n     public double evaluate(\n-        final double[] values,\n-        final int begin,\n-        final int length) {\n+        final double[] values, final int begin, final int length) {\n         return Math.exp(\n-            super.evaluate(values, begin, length) / (double) length);\n+            sumOfLogs.evaluate(values, begin, length) / (double) length);\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.univariate.StorelessUnivariateStatistic#getN()\n+     */\n+    public long getN() {\n+        return sumOfLogs.getN();\n     }\n \n }", "timestamp": 1090125428, "metainfo": ""}