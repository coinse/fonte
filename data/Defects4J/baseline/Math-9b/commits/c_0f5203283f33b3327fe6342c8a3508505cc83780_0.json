{"sha": "0f5203283f33b3327fe6342c8a3508505cc83780", "log": "Modified tests to work with immutable BigMatrix.   ", "commit": "\n--- a/src/test/org/apache/commons/math/linear/BigMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/BigMatrixImplTest.java\n /**\n  * Test cases for the {@link BigMatrixImpl} class.\n  *\n- * @version $Revision: 1.4 $ $Date: 2004/10/25 02:23:29 $\n+ * @version $Revision: 1.5 $ $Date: 2004/10/25 03:13:31 $\n  */\n \n public final class BigMatrixImplTest extends TestCase {\n         assertEquals(\"testData2 row dimension\",m2.getRowDimension(),2);\n         assertEquals(\"testData2 column dimension\",m2.getColumnDimension(),3);\n         assertTrue(\"testData2 is not square\",!m2.isSquare());\n-        BigMatrixImpl m3 = new BigMatrixImpl();\n-        m3.setData(testData);\n     } \n     \n     /** test copy functions */\n     public void testCopyFunctions() {\n         BigMatrixImpl m = new BigMatrixImpl(testData);\n-        BigMatrixImpl m2 = new BigMatrixImpl(testData2);\n-        m2.setData(m.getData());\n-        assertClose(\"getData\",m2,m,entryTolerance);\n-        // no dangling reference...\n-        m2.setEntry(1,1,2000d);\n-        BigMatrixImpl m3 = new BigMatrixImpl(testData);\n-        assertClose(\"no getData side effect\",m,m3,entryTolerance);\n-        m3 = (BigMatrixImpl) m.copy();\n-        double[][] stompMe = {{1d,2d,3d}};\n-        m3.setDataRef(asBigDecimal(stompMe));\n-        assertClose(\"no copy side effect\",m,new BigMatrixImpl(testData),\n-            entryTolerance);\n+        BigMatrixImpl m2 = new BigMatrixImpl(m.getData());\n+        assertEquals(m2,m);\n     }\n     \n     /** test constructors */\n             ;\n         }\n     }\n-    \n-    public void testEntryMutators() {\n-        BigMatrix m = new BigMatrixImpl(testData);\n-        assertEquals(\"get entry\",m.getEntry(0,1).doubleValue(),2d,entryTolerance);\n-        m.setEntry(0,1,100d);\n-        assertEquals(\"get entry\",m.getEntry(0,1).doubleValue(),100d,entryTolerance);\n-        try {\n-            double x = m.getEntry(-1,2).doubleValue();\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n-            ;\n-        }\n-        try {\n-            m.setEntry(1,3,200d);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n-            ;\n-        }\n-        m.setEntry(1, 2, \"0.1\");\n-        m.setEntry(1, 1, 0.1d);\n-        assertFalse(m.getEntry(1, 2).equals(m.getEntry(1, 1)));\n-        assertTrue(m.getEntry(1, 2).equals(new BigDecimal(\"0.1\")));\n-        try {\n-            m.setEntry(1, 2, \"not a number\");\n-            fail(\"Expecting NumberFormatException\");\n-        } catch (NumberFormatException ex) {\n-            ;\n-        }     \n-    }\n-        \n+      \n     public void testLUDecomposition() throws Exception {\n         BigMatrixImpl m = new BigMatrixImpl(testData);\n         BigMatrix lu = m.getLUMatrix();\n     }\n     \n     /** extracts the l  and u matrices from compact lu representation */\n-    protected void splitLU(BigMatrix lu, BigMatrix lower, BigMatrix upper) throws InvalidMatrixException {\n-        if (!lu.isSquare() || !lower.isSquare() || !upper.isSquare() ||\n-                lower.getRowDimension() != upper.getRowDimension() \n-                || lower.getRowDimension() != lu.getRowDimension()) {\n+    protected void splitLU(BigMatrix lu, BigDecimal[][] lowerData, BigDecimal[][] upperData) throws InvalidMatrixException {\n+        if (!lu.isSquare() || lowerData.length != lowerData[0].length || upperData.length != upperData[0].length ||\n+                lowerData.length != upperData.length\n+                || lowerData.length != lu.getRowDimension()) {\n             throw new InvalidMatrixException(\"incorrect dimensions\");\n         }    \n         int n = lu.getRowDimension();\n         for (int i = 0; i < n; i++) {\n             for (int j = 0; j < n; j++) {\n                 if (j < i) {\n-                    lower.setEntry(i, j, lu.getEntry(i, j));\n-                    upper.setEntry(i, j, 0d);\n+                    lowerData[i][j] = lu.getEntry(i, j);\n+                    upperData[i][j] = new BigDecimal(0);\n                 } else if (i == j) {\n-                    lower.setEntry(i, j, 1d);\n-                    upper.setEntry(i, j, lu.getEntry(i, j));\n+                    lowerData[i][j] = new BigDecimal(1);\n+                    upperData[i][j] = lu.getEntry(i, j);\n                 } else {\n-                    lower.setEntry(i, j, 0d);\n-                    upper.setEntry(i, j, lu.getEntry(i, j));\n+                    lowerData[i][j] = new BigDecimal(0);\n+                    upperData[i][j] = lu.getEntry(i, j);\n                 }   \n             }\n         }\n             throw new IllegalArgumentException(\"dimension mismatch\");\n         }\n         int n = matrix.getRowDimension();\n-        BigMatrix out = new BigMatrixImpl(n, n);\n+        int m = matrix.getColumnDimension();\n+        BigDecimal out[][] = new BigDecimal[m][n];\n         for (int i = 0; i < n; i++) {\n-            for (int j = 0; j < n; j++) {\n-                out.setEntry(i, j, matrix.getEntry(permutation[i], j));\n+            for (int j = 0; j < m; j++) {\n+                out[i][j] = matrix.getEntry(permutation[i], j);\n             }\n         }\n-        return out;\n+        return new BigMatrixImpl(out);\n     }\n     \n     /** Extracts l and u matrices from lu and verifies that matrix = l times u modulo permutation */\n     protected void verifyDecomposition(BigMatrix matrix, BigMatrix lu) throws Exception{\n         int n = matrix.getRowDimension();\n-        BigMatrix lower = new BigMatrixImpl(n, n);\n-        BigMatrix upper = new BigMatrixImpl(n, n);\n-        splitLU(lu, lower, upper);\n+        BigDecimal[][] lowerData = new BigDecimal[n][n];\n+        BigDecimal[][] upperData = new BigDecimal[n][n];\n+        splitLU(lu, lowerData, upperData);\n+        BigMatrix lower =new BigMatrixImpl(lowerData);\n+        BigMatrix upper = new BigMatrixImpl(upperData);\n         int[] permutation = ((BigMatrixImpl) matrix).getPermutation();\n         BigMatrix permuted = permuteRows(matrix, permutation);\n-        assertClose(\"lu decomposition does not work\", permuted, lower.multiply(upper), normTolerance);\n-    }\n-      \n-    \n+        assertClose(\"lu decomposition does not work\", permuted,\n+                lower.multiply(upper), normTolerance);\n+    }\n+         \n     /** Useful for debugging */\n     private void dumpMatrix(BigMatrix m) {\n           for (int i = 0; i < m.getRowDimension(); i++) {", "timestamp": 1098674011, "metainfo": ""}