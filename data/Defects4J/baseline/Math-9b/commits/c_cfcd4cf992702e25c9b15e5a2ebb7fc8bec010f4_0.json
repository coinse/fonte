{"sha": "cfcd4cf992702e25c9b15e5a2ebb7fc8bec010f4", "log": "Added BELOW_SIDE and ABOVE_SIDE in the possible allowed solutions for bracketing solvers.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/AllowedSolutions.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/AllowedSolutions.java\n package org.apache.commons.math.analysis.solvers;\n \n \n-/** The kinds of solutions that a {@link UnivariateRealSolver (univariate real)\n- * root-finding algorithm} may accept as solutions. This basically controls\n- * whether or not under-approximations and over-approximations are allowed.\n+/** The kinds of solutions that a {@link BracketedUnivariateRealSolver\n+ * (bracketed univariate real) root-finding algorithm} may accept as solutions.\n+ * This basically controls whether or not under-approximations and\n+ * over-approximations are allowed.\n  *\n  * <p>If all solutions are accepted ({@link #EITHER_SIDE}), then the solution\n  * that the root-finding algorithm returns for a given root may be equal to the\n  * tolerances. In certain cases however, in particular for\n  * {@link org.apache.commons.math.ode.events.EventHandler state events} of\n  * {@link org.apache.commons.math.ode.ODEIntegrator ODE solvers}, it\n- * may be necessary to guarantee that a solution is returned that does not\n- * under-approximate the solution.</p>\n+ * may be necessary to guarantee that a solution is returned that lies on a\n+ * specific side the solution.</p>\n  *\n  * @see BracketedUnivariateRealSolver\n  * @since 3.0\n public enum AllowedSolutions {\n     /** There are no additional side restriction on the solutions for\n      * root-finding. That is, both under-approximations and over-approximations\n-     * are allowed. So, if a function f(x) has a root at x = y, then the\n-     * root-finding result s may be smaller than y, equal to y, or greater\n-     * than y.\n+     * are allowed. So, if a function f(x) has a root at x = x0, then the\n+     * root-finding result s may be smaller than x0, equal to x0, or greater\n+     * than x0.\n      */\n     EITHER_SIDE,\n \n     /** Only solutions that are less than or equal to the actual root are\n      * acceptable as solutions for root-finding. In other words,\n      * over-approximations are not allowed. So, if a function f(x) has a root\n-     * at x = y, then the root-finding result s must satisfy s &lt;= y.\n+     * at x = x0, then the root-finding result s must satisfy s &lt;= x0.\n      */\n     LEFT_SIDE,\n \n     /** Only solutions that are greater than or equal to the actual root are\n      * acceptable as solutions for root-finding. In other words,\n      * under-approximations are not allowed. So, if a function f(x) has a root\n-     * at x = y, then the root-finding result s must satisfy s &gt;= y.\n+     * at x = x0, then the root-finding result s must satisfy s &gt;= x0.\n      */\n-    RIGHT_SIDE;\n+    RIGHT_SIDE,\n+\n+    /** Only solutions for which values are less than or equal to zero are\n+     * acceptable as solutions for root-finding. So, if a function f(x) has\n+     * a root at x = x0, then the root-finding result s must satisfy f(s) &lt;= 0.\n+     */\n+    BELOW_SIDE,\n+\n+    /** Only solutions for which values are greater than or equal to zero are\n+     * acceptable as solutions for root-finding. So, if a function f(x) has\n+     * a root at x = x0, then the root-finding result s must satisfy f(s) &gt;= 0.\n+     */\n+    ABOVE_SIDE;\n+\n }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n         final double atol = getAbsoluteAccuracy();\n         final double rtol = getRelativeAccuracy();\n \n-        // Variables to hold new bounds.\n-        double x;\n-        double fx;\n-\n         // Keep track of inverted intervals, meaning that the left bound is\n         // larger than the right bound. Not used for the original Secant\n         // method.\n         // Keep finding better approximations.\n         while (true) {\n             // Calculate the next approximation.\n-            x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n-            fx = computeObjectiveValue(x);\n+            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n+            final double fx = computeObjectiveValue(x);\n \n             // If the new approximation is the exact root, return it. Since\n             // this is not an under-approximation or an over-approximation,\n             }\n \n             // If the function value of the last approximation is too small,\n-            // given the function value accuracy, then we can't get close to\n+            // given the function value accuracy, then we can't get closer to\n             // the root than we already are.\n             if (FastMath.abs(f1) <= ftol) {\n                 switch (allowedSolutions) {\n                     break;\n                 case RIGHT_SIDE:\n                     if (!inverted) {\n+                        return x1;\n+                    }\n+                    break;\n+                case BELOW_SIDE:\n+                    if (f1 <= 0) {\n+                        return x1;\n+                    }\n+                    break;\n+                case ABOVE_SIDE:\n+                    if (f1 >= 0) {\n                         return x1;\n                     }\n                     break;\n                     return inverted ? x1 : x0;\n                 case RIGHT_SIDE:\n                     return inverted ? x0 : x1;\n+                case BELOW_SIDE:\n+                    return (f1 <= 0) ? x1 : x0;\n+                case ABOVE_SIDE:\n+                    return (f1 >= 0) ? x1 : x0;\n                 default:\n                     throw new MathInternalError();\n                 }\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverAbstractTest.java\n             right += 0.3;\n         }\n     }\n+    @Test\n+    public void testSolutionBelowSide() {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = getSolver();\n+        if (!(solver instanceof BracketedUnivariateRealSolver)) return;\n+        ((BracketedUnivariateRealSolver)solver).setAllowedSolutions(AllowedSolutions.BELOW_SIDE);\n+        double left = -1.5;\n+        double right = 0.05;\n+        for(int i = 0; i < 10; i++) {\n+            // Test whether the allowed solutions are taken into account.\n+            double solution = solver.solve(100, f, left, right);\n+            Assert.assertTrue(f.value(solution) <= 0.0);\n+\n+            // Prepare for next test.\n+            left -= 0.1;\n+            right += 0.3;\n+        }\n+    }\n+\n+    @Test\n+    public void testSolutionAboveSide() {\n+        UnivariateRealFunction f = new SinFunction();\n+        UnivariateRealSolver solver = getSolver();\n+        if (!(solver instanceof BracketedUnivariateRealSolver)) return;\n+        ((BracketedUnivariateRealSolver)solver).setAllowedSolutions(AllowedSolutions.ABOVE_SIDE);\n+        double left = -1.5;\n+        double right = 0.05;\n+        for(int i = 0; i < 10; i++) {\n+            // Test whether the allowed solutions are taken into account.\n+            double solution = solver.solve(100, f, left, right);\n+            Assert.assertTrue(f.value(solution) >= 0.0);\n+\n+            // Prepare for next test.\n+            left -= 0.1;\n+            right += 0.3;\n+        }\n+    }\n+\n }", "timestamp": 1309624023, "metainfo": ""}