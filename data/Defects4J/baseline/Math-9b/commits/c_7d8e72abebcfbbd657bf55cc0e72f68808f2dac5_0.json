{"sha": "7d8e72abebcfbbd657bf55cc0e72f68808f2dac5", "log": "Last commit got formated with tabs, this is formated with spaces   ", "commit": "\n--- a/src/java/org/apache/commons/math/stat/UnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/stat/UnivariateImpl.java\n  *\n  * 3. The end-user documentation included with the redistribution, if\n  *    any, must include the following acknowlegement:\n- *       \"This sumLog includes software developed by the\n+ *       \"This product includes software developed by the\n  *        Apache Software Foundation (http://www.apache.org/).\"\n  *    Alternately, this acknowlegement may appear in the software itself,\n  *    if and wherever such third-party acknowlegements normally appear.\n  * @author <a href=\"mailto:mdiggory@apache.org\">Mark Diggory</a>\n  * @author Brent Worden\n  * @author <a href=\"mailto:HotFusionMan@Yahoo.com\">Albert Davidson Chou</a>\n- * @version $Revision: 1.10 $ $Date: 2003/06/18 13:47:35 $\n+ * @version $Revision: 1.11 $ $Date: 2003/06/18 13:57:24 $\n  *\n */\n public class UnivariateImpl implements Univariate, Serializable {\n \n-\t/** hold the window size **/\n-\tprivate int windowSize = Univariate.INFINITE_WINDOW;\n-\n-\t/** Just in case the windowSize is not infinite, we need to\n-\t *  keep an array to remember values 0 to N\n-\t */\n-\tprivate DoubleArray doubleArray;\n-\n-\t/** count of values that have been added */\n-\tprivate int n = 0;\n-\n-\t/** sum of values that have been added */\n-\tprivate double sum = Double.NaN;\n-\n-\t/** sum of the square of each value that has been added */\n-\tprivate double sumsq = Double.NaN;\n-\n-\t/** min of values that have been added */\n-\tprivate double min = Double.NaN;\n-\n-\t/** max of values that have been added */\n-\tprivate double max = Double.NaN;\n-\n-\t/** sumLog of values that have been added */\n-\tprivate double sumLog = Double.NaN;\n-\n-\t/** mean of values that have been added */\n-\tprivate double mean = Double.NaN;\n-\n-\t/** second moment of values that have been added */\n-\tprivate double s2 = Double.NaN;\n-\n-\t/** third moment of values that have been added */\n-\tprivate double s3 = Double.NaN;\n-\n-\t/** fourth moment of values that have been added */\n-\tprivate double s4 = Double.NaN;\n-\n-\t/** variance of values that have been added */\n-\tprivate double variance = Double.NaN;\n-\n-\t/** skewness of values that have been added */\n-\tprivate double skewness = Double.NaN;\n-\n-\t/** kurtosis of values that have been added */\n-\tprivate double kurtosis = Double.NaN;\n-\n-\t/** Creates new univariate with an infinite window */\n-\tpublic UnivariateImpl() {\n-\t}\n-\n-\t/** Creates a new univariate with a fixed window **/\n-\tpublic UnivariateImpl(int window) {\n-\t\tsetWindowSize(window);\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.stat.Univariate#getN()\n-\t */\n-\tpublic int getN() {\n-\t\treturn n;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.stat.Univariate#getSum()\n-\t */\n-\tpublic double getSum() {\n-\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n-\t\t\treturn StatUtils.sum(doubleArray.getElements());\n-\t\t}\n-\n-\t\treturn sum;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.stat.Univariate#getSumsq()\n-\t */\n-\tpublic double getSumsq() {\n-\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n-\t\t\treturn StatUtils.sumSq(doubleArray.getElements());\n-\t\t}\n-\n-\t\treturn sumsq;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.stat.Univariate#getMean()\n-\t */\n-\tpublic double getMean() {\n-\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n-\t\t\treturn StatUtils.mean(doubleArray.getElements());\n-\t\t}\n-\n-\t\treturn mean;\n-\t}\n-\n-\t/**\n-\t * Returns the standard deviation for this collection of values\n-\t * @see org.apache.commons.math.stat.Univariate#getStandardDeviation()\n-\t */\n-\tpublic double getStandardDeviation() {\n-\t\tdouble stdDev = Double.NaN;\n-\t\tif (getN() != 0) {\n-\t\t\tstdDev = Math.sqrt(getVariance());\n-\t\t}\n-\t\treturn (stdDev);\n-\t}\n-\n-\t/**\n-\t * Returns the variance of the values that have been added via West's\n-\t * algorithm as described by\n-\t * <a href=\"http://doi.acm.org/10.1145/359146.359152\">Chan, T. F. and\n-\t * J. G. Lewis 1979, <i>Communications of the ACM</i>,\n-\t * vol. 22 no. 9, pp. 526-531.</a>.\n-\t *\n-\t * @return The variance of a set of values.  Double.NaN is returned for\n-\t *         an empty set of values and 0.0 is returned for a &lt;= 1 value set.\n-\t */\n-\tpublic double getVariance() {\n-\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n-\t\t\tvariance = StatUtils.variance(doubleArray.getElements());\n-\t\t}\n-\t\treturn variance;\n-\t}\n-\n-\t/**\n-\t * Returns the skewness of the values that have been added as described by\n-\t * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (6) for k-Statistics</a>.\n-\t *\n-\t * @return The skew of a set of values.  Double.NaN is returned for\n-\t *         an empty set of values and 0.0 is returned for a &lt;= 2 value set.\n-\t */\n-\tpublic double getSkewness() {\n-\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n-\t\t\treturn StatUtils.skewness(doubleArray.getElements());\n-\t\t}\n-\t\treturn skewness;\n-\t}\n-\n-\t/**\n-\t * Returns the kurtosis of the values that have been added as described by\n-\t * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (7) for k-Statistics</a>.\n-\t *\n-\t * @return The kurtosis of a set of values.  Double.NaN is returned for\n-\t *         an empty set of values and 0.0 is returned for a &lt;= 3 value set.\n-\t */\n-\tpublic double getKurtosis() {\n-\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n-\t\t\treturn StatUtils.kurtosis(doubleArray.getElements());\n-\t\t}\n-\t\treturn kurtosis;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.stat.Univariate#getMax()\n-\t */\n-\tpublic double getMax() {\n-\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n-\t\t\treturn StatUtils.max(doubleArray.getElements());\n-\t\t}\n-\t\treturn max;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.stat.Univariate#getMin()\n-\t */\n-\tpublic double getMin() {\n-\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n-\t\t\treturn StatUtils.min(doubleArray.getElements());\n-\t\t}\n-\t\treturn min;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.stat.Univariate#getProduct()\n-\t */\n-\tpublic double getProduct() {\n-\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n-\t\t\treturn StatUtils.product(doubleArray.getElements());\n-\t\t}\n-\n-\t\treturn sumLog;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t* @see org.apache.commons.math.stat.Univariate#getGeometricMean()\n-\t*/\n-\tpublic double getGeometricMean() {\n-\n-\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n-\t\t\treturn StatUtils.geometricMean(doubleArray.getElements());\n-\t\t}\n-\n-\t\tif (n == 0) {\n-\t\t\treturn Double.NaN;\n-\t\t} else {\n-\t\t\treturn Math.exp(sumLog / (double) n);\n-\t\t}\n-\t}\n-\n-\t/* If windowSize is set to Infinite, moments are calculated using the following \n-\t * <a href=\"http://www.spss.com/tech/stat/Algorithms/11.5/descriptives.pdf\">\n+    /** hold the window size **/\n+    private int windowSize = Univariate.INFINITE_WINDOW;\n+\n+    /** Just in case the windowSize is not infinite, we need to\n+     *  keep an array to remember values 0 to N\n+     */\n+    private DoubleArray doubleArray;\n+\n+    /** count of values that have been added */\n+    private int n = 0;\n+\n+    /** sum of values that have been added */\n+    private double sum = Double.NaN;\n+\n+    /** sum of the square of each value that has been added */\n+    private double sumsq = Double.NaN;\n+\n+    /** min of values that have been added */\n+    private double min = Double.NaN;\n+\n+    /** max of values that have been added */\n+    private double max = Double.NaN;\n+\n+    /** sumLog of values that have been added */\n+    private double sumLog = Double.NaN;\n+\n+    /** mean of values that have been added */\n+    private double mean = Double.NaN;\n+\n+    /** second moment of values that have been added */\n+    private double s2 = Double.NaN;\n+\n+    /** third moment of values that have been added */\n+    private double s3 = Double.NaN;\n+\n+    /** fourth moment of values that have been added */\n+    private double s4 = Double.NaN;\n+\n+    /** variance of values that have been added */\n+    private double variance = Double.NaN;\n+\n+    /** skewness of values that have been added */\n+    private double skewness = Double.NaN;\n+\n+    /** kurtosis of values that have been added */\n+    private double kurtosis = Double.NaN;\n+\n+    /** Creates new univariate with an infinite window */\n+    public UnivariateImpl() {\n+    }\n+\n+    /** Creates a new univariate with a fixed window **/\n+    public UnivariateImpl(int window) {\n+        setWindowSize(window);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.Univariate#getN()\n+     */\n+    public int getN() {\n+        return n;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.Univariate#getSum()\n+     */\n+    public double getSum() {\n+        if (windowSize != Univariate.INFINITE_WINDOW) {\n+            return StatUtils.sum(doubleArray.getElements());\n+        }\n+\n+        return sum;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.Univariate#getSumsq()\n+     */\n+    public double getSumsq() {\n+        if (windowSize != Univariate.INFINITE_WINDOW) {\n+            return StatUtils.sumSq(doubleArray.getElements());\n+        }\n+\n+        return sumsq;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.Univariate#getMean()\n+     */\n+    public double getMean() {\n+        if (windowSize != Univariate.INFINITE_WINDOW) {\n+            return StatUtils.mean(doubleArray.getElements());\n+        }\n+\n+        return mean;\n+    }\n+\n+    /**\n+     * Returns the standard deviation for this collection of values\n+     * @see org.apache.commons.math.stat.Univariate#getStandardDeviation()\n+     */\n+    public double getStandardDeviation() {\n+        double stdDev = Double.NaN;\n+        if (getN() != 0) {\n+            stdDev = Math.sqrt(getVariance());\n+        }\n+        return (stdDev);\n+    }\n+\n+    /**\n+     * Returns the variance of the values that have been added via West's\n+     * algorithm as described by\n+     * <a href=\"http://doi.acm.org/10.1145/359146.359152\">Chan, T. F. and\n+     * J. G. Lewis 1979, <i>Communications of the ACM</i>,\n+     * vol. 22 no. 9, pp. 526-531.</a>.\n+     *\n+     * @return The variance of a set of values.  Double.NaN is returned for\n+     *         an empty set of values and 0.0 is returned for a &lt;= 1 value set.\n+     */\n+    public double getVariance() {\n+        if (windowSize != Univariate.INFINITE_WINDOW) {\n+            variance = StatUtils.variance(doubleArray.getElements());\n+        }\n+        return variance;\n+    }\n+\n+    /**\n+     * Returns the skewness of the values that have been added as described by\n+     * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (6) for k-Statistics</a>.\n+     *\n+     * @return The skew of a set of values.  Double.NaN is returned for\n+     *         an empty set of values and 0.0 is returned for a &lt;= 2 value set.\n+     */\n+    public double getSkewness() {\n+        if (windowSize != Univariate.INFINITE_WINDOW) {\n+            return StatUtils.skewness(doubleArray.getElements());\n+        }\n+        return skewness;\n+    }\n+\n+    /**\n+     * Returns the kurtosis of the values that have been added as described by\n+     * <a href=\"http://mathworld.wolfram.com/k-Statistic.html\">Equation (7) for k-Statistics</a>.\n+     *\n+     * @return The kurtosis of a set of values.  Double.NaN is returned for\n+     *         an empty set of values and 0.0 is returned for a &lt;= 3 value set.\n+     */\n+    public double getKurtosis() {\n+        if (windowSize != Univariate.INFINITE_WINDOW) {\n+            return StatUtils.kurtosis(doubleArray.getElements());\n+        }\n+        return kurtosis;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.Univariate#getMax()\n+     */\n+    public double getMax() {\n+        if (windowSize != Univariate.INFINITE_WINDOW) {\n+            return StatUtils.max(doubleArray.getElements());\n+        }\n+        return max;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.Univariate#getMin()\n+     */\n+    public double getMin() {\n+        if (windowSize != Univariate.INFINITE_WINDOW) {\n+            return StatUtils.min(doubleArray.getElements());\n+        }\n+        return min;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.Univariate#getProduct()\n+     */\n+    public double getProduct() {\n+        if (windowSize != Univariate.INFINITE_WINDOW) {\n+            return StatUtils.product(doubleArray.getElements());\n+        }\n+\n+        return sumLog;\n+    }\n+\n+    /* (non-Javadoc)\n+    * @see org.apache.commons.math.stat.Univariate#getGeometricMean()\n+    */\n+    public double getGeometricMean() {\n+\n+        if (windowSize != Univariate.INFINITE_WINDOW) {\n+            return StatUtils.geometricMean(doubleArray.getElements());\n+        }\n+\n+        if (n == 0) {\n+            return Double.NaN;\n+        } else {\n+            return Math.exp(sumLog / (double) n);\n+        }\n+    }\n+\n+    /* If windowSize is set to Infinite, moments are calculated using the following \n+     * <a href=\"http://www.spss.com/tech/stat/Algorithms/11.5/descriptives.pdf\">\n      * recursive strategy\n      * </a>.\n      * Otherwise, stat methods delegate to StatUtils.\n-\t * @see org.apache.commons.math.stat.Univariate#addValue(double)\n-\t */\n-\tpublic void addValue(double value) {\n-\n-\t\tif (windowSize != Univariate.INFINITE_WINDOW) {\n-\t\t\t/* then all getters deligate to StatUtils\n-\t\t\t * and this clause simply adds/rolls a value in the storage array \n-\t\t\t */\n-\t\t\tif (windowSize == n) {\n-\t\t\t\tdoubleArray.addElementRolling(value);\n-\t\t\t} else {\n-\t\t\t\tn++;\n-\t\t\t\tdoubleArray.addElement(value);\n-\t\t\t}\n-\n-\t\t} else {\n-\t\t\t/* If the windowSize is infinite don't store any values and there \n-\t\t\t * is no need to discard the influence of any single item.\n-\t\t\t */\n-\t\t\tn++;\n-\n-\t\t\tif (n <= 1) {\n-\t\t\t\t/* if n <= 1, initialize the sumLog, min, max, mean, variance and pre-variance */\n-\t\t\t\tsumLog = 0.0;\n-\t\t\t\tsum = min = max = mean = value;\n-\t\t\t\tsumsq = Math.pow(value, 2);\n-\t\t\t\tvariance = s2 = 0.0;\n-\t\t\t\tskewness = kurtosis = 0.0;\n-\n-\t\t\t} else {\n-\t\t\t\t/* otherwise calc these values */\n-\t\t\t\tsumLog += Math.log(value);\n-\t\t\t\tsum += value;\n-\t\t\t\tsumsq += Math.pow(value, 2);\n-\t\t\t\tmin = Math.min(min, value);\n-\t\t\t\tmax = Math.max(max, value);\n-\n-\t\t\t\tdouble dev = value - mean;\n-\t\t\t\tdouble v = dev / ((double) n);\n-\t\t\t\tdouble v2 = Math.pow(v, 2);\n-\t\t\t\tdouble n1 = ((double) n - 1);\n-\n-\t\t\t\ts4 += v\n-\t\t\t\t\t* (\n-\t\t\t\t\t\t- 4.0 * s3\n-\t\t\t\t\t\t+ v * (6.0 * s2 + n1 * (1 + Math.pow((double) n, 3)) * v2));\n-\n-\t\t\t\ts3 += v * (-3.0 * s2 + (double) n * n1 * (n - 2) * Math.pow(v, 2));\n-\t\t\t\ts2 += n1 * dev * v;\n-\n-\t\t\t\tmean += v;\n-\t\t\t\tvariance = \n-                    (n <= 1) ? 0.0 : s2 / n1;\n-\t\t\t\tskewness =\n-\t\t\t\t\t(n <= 2) ? 0.0 : s3 / ((double) n * Math.sqrt(variance) * variance);\n-\t\t\t\tkurtosis =\n-\t\t\t\t\t(n <= 3) ? 0.0 : s4 / ((double) n * Math.pow(variance, 2)) - 3;\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Generates a text report displaying\n-\t * univariate statistics from values that\n-\t * have been added.\n-\t * @return String with line feeds displaying statistics\n-\t */\n-\tpublic String toString() {\n-\t\tStringBuffer outBuffer = new StringBuffer();\n-\t\toutBuffer.append(\"UnivariateImpl:\\n\");\n-\t\toutBuffer.append(\"n: \" + n + \"\\n\");\n-\t\toutBuffer.append(\"min: \" + min + \"\\n\");\n-\t\toutBuffer.append(\"max: \" + max + \"\\n\");\n-\t\toutBuffer.append(\"mean: \" + getMean() + \"\\n\");\n-\t\toutBuffer.append(\"std dev: \" + getStandardDeviation() + \"\\n\");\n-\t\toutBuffer.append(\"skewness: \" + getSkewness() + \"\\n\");\n-\t\toutBuffer.append(\"kurtosis: \" + getKurtosis() + \"\\n\");\n-\t\treturn outBuffer.toString();\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#clear()\n-\t */\n-\tpublic void clear() {\n-\t\tthis.n = 0;\n-\t\tthis.min = this.max = Double.NaN;\n-\t\tthis.sumLog = this.mean = Double.NaN;\n-\t\tthis.variance = this.skewness = this.kurtosis = Double.NaN;\n+     * @see org.apache.commons.math.stat.Univariate#addValue(double)\n+     */\n+    public void addValue(double value) {\n+\n+        if (windowSize != Univariate.INFINITE_WINDOW) {\n+            /* then all getters deligate to StatUtils\n+             * and this clause simply adds/rolls a value in the storage array \n+             */\n+            if (windowSize == n) {\n+                doubleArray.addElementRolling(value);\n+            } else {\n+                n++;\n+                doubleArray.addElement(value);\n+            }\n+\n+        } else {\n+            /* If the windowSize is infinite don't store any values and there \n+             * is no need to discard the influence of any single item.\n+             */\n+            n++;\n+\n+            if (n <= 1) {\n+                /* if n <= 1, initialize the sumLog, min, max, mean, variance and pre-variance */\n+                sumLog = 0.0;\n+                sum = min = max = mean = value;\n+                sumsq = Math.pow(value, 2);\n+                variance = s2 = 0.0;\n+                skewness = kurtosis = 0.0;\n+\n+            } else {\n+                /* otherwise calc these values */\n+                sumLog += Math.log(value);\n+                sum += value;\n+                sumsq += Math.pow(value, 2);\n+                min = Math.min(min, value);\n+                max = Math.max(max, value);\n+\n+                double dev = value - mean;\n+                double v = dev / ((double) n);\n+                double v2 = Math.pow(v, 2);\n+                double n1 = ((double) n - 1);\n+\n+                s4 += v\n+                    * (\n+                        - 4.0 * s3\n+                        + v\n+                            * (6.0 * s2\n+                                + n1 * (1 + Math.pow((double) n, 3)) * v2));\n+\n+                s3 += v\n+                    * (-3.0 * s2 + (double) n * n1 * (n - 2) * Math.pow(v, 2));\n+                s2 += n1 * dev * v;\n+\n+                mean += v;\n+                variance = (n <= 1) ? 0.0 : s2 / n1;\n+                skewness =\n+                    (n <= 2)\n+                        ? 0.0\n+                        : s3 / ((double) n * Math.sqrt(variance) * variance);\n+                kurtosis =\n+                    (n <= 3)\n+                        ? 0.0\n+                        : s4 / ((double) n * Math.pow(variance, 2)) - 3;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Generates a text report displaying\n+     * univariate statistics from values that\n+     * have been added.\n+     * @return String with line feeds displaying statistics\n+     */\n+    public String toString() {\n+        StringBuffer outBuffer = new StringBuffer();\n+        outBuffer.append(\"UnivariateImpl:\\n\");\n+        outBuffer.append(\"n: \" + n + \"\\n\");\n+        outBuffer.append(\"min: \" + min + \"\\n\");\n+        outBuffer.append(\"max: \" + max + \"\\n\");\n+        outBuffer.append(\"mean: \" + getMean() + \"\\n\");\n+        outBuffer.append(\"std dev: \" + getStandardDeviation() + \"\\n\");\n+        outBuffer.append(\"skewness: \" + getSkewness() + \"\\n\");\n+        outBuffer.append(\"kurtosis: \" + getKurtosis() + \"\\n\");\n+        return outBuffer.toString();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.Univariate#clear()\n+     */\n+    public void clear() {\n+        this.n = 0;\n+        this.min = this.max = Double.NaN;\n+        this.sumLog = this.mean = Double.NaN;\n+        this.variance = this.skewness = this.kurtosis = Double.NaN;\n         this.s2 = this.s3 = this.s4 = Double.NaN;\n-\t\tif (doubleArray != null)\n-\t\t\tdoubleArray = new FixedDoubleArray(windowSize);\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#getWindowSize()\n-\t */\n-\tpublic int getWindowSize() {\n-\t\treturn windowSize;\n-\t}\n-\n-\t/* (non-Javadoc)\n-\t * @see org.apache.commons.math.Univariate#setWindowSize(int)\n-\t */\n-\tpublic void setWindowSize(int windowSize) {\n-\t\tclear();\n-\t\tthis.windowSize = windowSize;\n-\t\tdoubleArray = new FixedDoubleArray(windowSize);\n-\t}\n+        if (doubleArray != null)\n+            doubleArray = new FixedDoubleArray(windowSize);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.Univariate#getWindowSize()\n+     */\n+    public int getWindowSize() {\n+        return windowSize;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.Univariate#setWindowSize(int)\n+     */\n+    public void setWindowSize(int windowSize) {\n+        clear();\n+        this.windowSize = windowSize;\n+        doubleArray = new FixedDoubleArray(windowSize);\n+    }\n \n }", "timestamp": 1055944644, "metainfo": ""}