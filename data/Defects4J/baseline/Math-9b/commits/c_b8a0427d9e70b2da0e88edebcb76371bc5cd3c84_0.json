{"sha": "b8a0427d9e70b2da0e88edebcb76371bc5cd3c84", "log": "MATH-518 Created new function object to replace \"HarmonicFunction\" (in package \"optimization.fitting\").   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/function/HarmonicOscillator.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.function;\n+\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.DifferentiableUnivariateRealFunction;\n+import org.apache.commons.math.analysis.ParametricUnivariateRealFunction;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.util.FastMath;\n+\n+/**\n+ * <a href=\"http://en.wikipedia.org/wiki/Harmonic_oscillator\">\n+ *  simple harmonic oscillator</a> function.\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 3.0\n+ */\n+public class HarmonicOscillator implements DifferentiableUnivariateRealFunction {\n+    /** Amplitude. */\n+    private final double amplitude;\n+    /** Angular requency. */\n+    private final double omega;\n+    /** Phase. */\n+    private final double phase;\n+\n+    /**\n+     * Harmonic oscillator function.\n+     *\n+     * @param amplitude Amplitude.\n+     * @param omega Angular frequency.\n+     * @param phase Phase.\n+     */\n+    public HarmonicOscillator(double amplitude,\n+                              double omega,\n+                              double phase) {\n+        this.amplitude = amplitude;\n+        this.omega = omega;\n+        this.phase = phase;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double value(double x) {\n+        return value(omega * x + phase, amplitude);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public UnivariateRealFunction derivative() {\n+        return new UnivariateRealFunction() {\n+            /** {@inheritDoc} */\n+            public double value(double x) {\n+                return -amplitude * omega * FastMath.sin(omega * x + phase);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Parametric function where the input array contains the parameters of\n+     * the harmonic oscillator function, ordered as follows:\n+     * <ul>\n+     *  <li>Amplitude</li>\n+     *  <li>Angular frequency</li>\n+     *  <li>Phase</li>\n+     * </ul>\n+     */\n+    public static class Parametric implements ParametricUnivariateRealFunction {\n+        /**\n+         * Computes the value of the harmonic oscillator at {@code x}.\n+         *\n+         * @param x Value for which the function must be computed.\n+         * @param param Values of norm, mean and standard deviation.\n+         * @return the value of the function.\n+         * @throws NullArgumentException if {@code param} is {@code null}.\n+         * @throws DimensionMismatchException if the size of {@code param} is\n+         * not 3.\n+         */\n+        public double value(double x,\n+                            double[] param) {\n+            validateParameters(param);\n+            return HarmonicOscillator.value(x * param[1] + param[2], param[0]);\n+        }\n+\n+        /**\n+         * Computes the value of the gradient at {@code x}.\n+         * The components of the gradient vector are the partial\n+         * derivatives of the function with respect to each of the\n+         * <em>parameters</em> (amplitude, angular frequency and phase).\n+         *\n+         * @param x Value at which the gradient must be computed.\n+         * @param param Values of amplitude, angular frequency and phase.\n+         * @return the gradient vector at {@code x}.\n+         * @throws NullArgumentException if {@code param} is {@code null}.\n+         * @throws DimensionMismatchException if the size of {@code param} is\n+         * not 3.\n+         */\n+        public double[] gradient(double x, double[] param) {\n+            validateParameters(param);\n+\n+            final double amplitude = param[0];\n+            final double omega = param[1];\n+            final double phase = param[2];\n+\n+            final double xTimesOmegaPlusPhase = omega * x + phase;\n+            final double a = HarmonicOscillator.value(xTimesOmegaPlusPhase, 1);\n+            final double p = -amplitude * FastMath.sin(xTimesOmegaPlusPhase);\n+            final double w = p * x;\n+\n+            return new double[] { a, w, p };\n+        }\n+\n+        /**\n+         * Validates parameters to ensure they are appropriate for the evaluation of\n+         * the {@link #value(double,double[])} and {@link #gradient(double,double[])}\n+         * methods.\n+         *\n+         * @param param Values of norm, mean and standard deviation.\n+         * @throws NullArgumentException if {@code param} is {@code null}.\n+         * @throws DimensionMismatchException if the size of {@code param} is\n+         * not 3.\n+         */\n+        private void validateParameters(double[] param) {\n+            if (param == null) {\n+                throw new NullArgumentException();\n+            }\n+            if (param.length != 3) {\n+                throw new DimensionMismatchException(param.length, 3);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * @param xTimesOmegaPlusPhase {@code omega * x + phase}.\n+     * @param amplitude Amplitude.\n+     * @return the value of the harmonic oscillator function at {@code x}.\n+     */\n+    private static double value(double xTimesOmegaPlusPhase,\n+                                double amplitude) {\n+        return amplitude * FastMath.cos(xTimesOmegaPlusPhase);\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/analysis/function/HarmonicOscillatorTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.function;\n+\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NullArgumentException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.util.FastMath;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test for class {@link HarmonicOscillator}.\n+ */\n+public class HarmonicOscillatorTest {\n+    private final double EPS = Math.ulp(1d);\n+\n+    @Test\n+    public void testSomeValues() {\n+        final double a = -1.2;\n+        final double w = 0.34;\n+        final double p = 5.6;\n+        final UnivariateRealFunction f = new HarmonicOscillator(a, w, p);\n+\n+        final double d = 0.12345;\n+        for (int i = 0; i < 10; i++) {\n+            final double v = i * d;\n+            Assert.assertEquals(a * FastMath.cos(w * v + p), f.value(v), 0);\n+        }\n+    }\n+\n+    @Test\n+    public void testDerivative() {\n+        final double a = -1.2;\n+        final double w = 0.34;\n+        final double p = 5.6;\n+        final HarmonicOscillator f = new HarmonicOscillator(a, w, p);\n+        final UnivariateRealFunction dfdx = f.derivative();\n+\n+        final double d = 0.12345;\n+        for (int i = 0; i < 10; i++) {\n+            final double v = i * d;\n+            Assert.assertEquals(-a * w * FastMath.sin(w * v + p), dfdx.value(v), 0);\n+        }\n+    }\n+\n+    @Test(expected=NullArgumentException.class)\n+    public void testParametricUsage1() {\n+        final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric();\n+        g.value(0, null);\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testParametricUsage2() {\n+        final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric();\n+        g.value(0, new double[] {0});\n+    }\n+\n+    @Test(expected=NullArgumentException.class)\n+    public void testParametricUsage3() {\n+        final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric();\n+        g.gradient(0, null);\n+    }\n+\n+    @Test(expected=DimensionMismatchException.class)\n+    public void testParametricUsage4() {\n+        final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric();\n+        g.gradient(0, new double[] {0});\n+    }\n+\n+    @Test\n+    public void testParametricValue() {\n+        final double amplitude = 2;\n+        final double omega = 3;\n+        final double phase = 4;\n+        final HarmonicOscillator f = new HarmonicOscillator(amplitude, omega, phase);\n+\n+        final HarmonicOscillator.Parametric g = new HarmonicOscillator.Parametric();\n+        Assert.assertEquals(f.value(-1), g.value(-1, new double[] {amplitude, omega, phase}), 0);\n+        Assert.assertEquals(f.value(0), g.value(0, new double[] {amplitude, omega, phase}), 0);\n+        Assert.assertEquals(f.value(2), g.value(2, new double[] {amplitude, omega, phase}), 0);\n+    }\n+\n+    @Test\n+    public void testParametricGradient() {\n+        final double amplitude = 2;\n+        final double omega = 3;\n+        final double phase = 4;\n+        final HarmonicOscillator.Parametric f = new HarmonicOscillator.Parametric();\n+\n+        final double x = 1;\n+        final double[] grad = f.gradient(1, new double[] {amplitude, omega, phase});\n+        final double xTimesOmegaPlusPhase = omega * x + phase;\n+        final double a = FastMath.cos(xTimesOmegaPlusPhase);\n+        Assert.assertEquals(a, grad[0], EPS);\n+        final double w = -amplitude * x * FastMath.sin(xTimesOmegaPlusPhase);\n+        Assert.assertEquals(w, grad[1], EPS);\n+        final double p = -amplitude * FastMath.sin(xTimesOmegaPlusPhase);\n+        Assert.assertEquals(p, grad[2], EPS);\n+    }\n+}", "timestamp": 1298388860, "metainfo": ""}