{"sha": "0aa6277c80b0aa1257f893f0c0699f8a58de2c83", "log": "Added a consistent classes hierarchy for Euclidean spaces in dimension 1, 2 and 3  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/Space.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry;\n+\n+import java.io.Serializable;\n+\n+/** This interface represents a generic space, with affine and vectorial counterparts.\n+ * @version $Id:$\n+ * @see Vector\n+ * @since 3.0\n+ */\n+public interface Space extends Serializable {\n+\n+    /** Get the dimension of the space.\n+     * @return dimension of the space\n+     */\n+    int getDimension();\n+\n+    /** Get the n-1 dimension subspace of this space.\n+     * @return n-1 dimension sub-space of this space\n+     * @see #getDimension()\n+     */\n+    Space getSubSpace();\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/Vector.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry;\n+\n+import java.io.Serializable;\n+import java.text.NumberFormat;\n+\n+/** This interface represents a generic vector in a vectorial space or a point in an affine space.\n+ * @version $Id:$\n+ * @see Space\n+ * @see Vector\n+ * @since 3.0\n+ */\n+public interface Vector<S extends Space> extends Serializable {\n+\n+    /** Get the space to which the vector belongs.\n+     * @return containing space\n+     */\n+    Space getSpace();\n+\n+    /** Get the null vector of the vetorial space or origin point of the affine space.\n+     * @return null vector of the vetorial space or origin point of the affine space\n+     */\n+    Vector<S> getZero();\n+\n+    /** Get the L<sub>1</sub> norm for the vector.\n+     * @return L<sub>1</sub> norm for the vector\n+     */\n+    double getNorm1();\n+\n+    /** Get the L<sub>2</sub> norm for the vector.\n+     * @return Euclidean norm for the vector\n+     */\n+    double getNorm();\n+\n+    /** Get the square of the norm for the vector.\n+     * @return square of the Euclidean norm for the vector\n+     */\n+    double getNormSq();\n+\n+    /** Get the L<sub>&infin;</sub> norm for the vector.\n+     * @return L<sub>&infin;</sub> norm for the vector\n+     */\n+    double getNormInf();\n+\n+    /** Add a vector to the instance.\n+     * @param v vector to add\n+     * @return a new vector\n+     */\n+    Vector<S> add(Vector<S> v);\n+\n+    /** Add a scaled vector to the instance.\n+     * @param factor scale factor to apply to v before adding it\n+     * @param v vector to add\n+     * @return a new vector\n+     */\n+    Vector<S> add(double factor, Vector<S> v);\n+\n+    /** Subtract a vector from the instance.\n+     * @param v vector to subtract\n+     * @return a new vector\n+     */\n+    Vector<S> subtract(Vector<S> v);\n+\n+    /** Subtract a scaled vector from the instance.\n+     * @param factor scale factor to apply to v before subtracting it\n+     * @param v vector to subtract\n+     * @return a new vector\n+     */\n+    Vector<S> subtract(double factor, Vector<S> v);\n+\n+    /**\n+     * Returns true if any coordinate of this vector is NaN; false otherwise\n+     * @return  true if any coordinate of this vector is NaN; false otherwise\n+     */\n+    boolean isNaN();\n+\n+    /**\n+     * Returns true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     * @return  true if any coordinate of this vector is infinite and none are NaN;\n+     * false otherwise\n+     */\n+    boolean isInfinite();\n+\n+    /** Compute the distance between the instance and another vector according to the L<sub>1</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNorm1()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the distance between the instance and p according to the L<sub>1</sub> norm\n+     */\n+    double distance1(Vector<S> v);\n+\n+    /** Compute the distance between the instance and another vector according to the L<sub>2</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNorm()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the distance between the instance and p according to the L<sub>2</sub> norm\n+     */\n+    double distance(Vector<S> v);\n+\n+    /** Compute the distance between the instance and another vector according to the L<sub>&infin;</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNormInf()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the distance between the instance and p according to the L<sub>&infin;</sub> norm\n+     */\n+    double distanceInf(Vector<S> v);\n+\n+    /** Compute the square of the distance between the instance and another vector.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>q.subtract(p).getNormSq()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v second vector\n+     * @return the square of the distance between the instance and p\n+     */\n+    double distanceSq(Vector<S> v);\n+\n+    /** Get a string representation of this vector.\n+     * @param format the custom format for components.\n+     */\n+    public String toString(final NumberFormat format);\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/VectorFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry;\n+\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.util.CompositeFormat;\n+import org.apache.commons.math.exception.MathParseException;\n+\n+/**\n+ * Formats a vector in components list format \"{x; y; ...}\".\n+ * <p>The prefix and suffix \"{\" and \"}\" and the separator \"; \" can be replaced by\n+ * any user-defined strings. The number format for components can be configured.</p>\n+ * <p>White space is ignored at parse time, even if it is in the prefix, suffix\n+ * or separator specifications. So even if the default separator does include a space\n+ * character that is used at format time, both input string \"{1;1;1}\" and\n+ * \" { 1 ; 1 ; 1 } \" will be parsed without error and the same vector will be\n+ * returned. In the second case, however, the parse position after parsing will be\n+ * just after the closing curly brace, i.e. just before the trailing space.</p>\n+ *\n+ * @version $Id:$\n+ * @since 3.0\n+ */\n+public abstract class VectorFormat<S extends Space> {\n+\n+    /** The default prefix: \"{\". */\n+    public static final String DEFAULT_PREFIX = \"{\";\n+\n+    /** The default suffix: \"}\". */\n+    public static final String DEFAULT_SUFFIX = \"}\";\n+\n+    /** The default separator: \", \". */\n+    public static final String DEFAULT_SEPARATOR = \"; \";\n+\n+    /** Prefix. */\n+    private final String prefix;\n+\n+    /** Suffix. */\n+    private final String suffix;\n+\n+    /** Separator. */\n+    private final String separator;\n+\n+    /** Trimmed prefix. */\n+    private final String trimmedPrefix;\n+\n+    /** Trimmed suffix. */\n+    private final String trimmedSuffix;\n+\n+    /** Trimmed separator. */\n+    private final String trimmedSeparator;\n+\n+    /** The format used for components. */\n+    private final NumberFormat format;\n+\n+    /**\n+     * Create an instance with default settings.\n+     * <p>The instance uses the default prefix, suffix and separator:\n+     * \"{\", \"}\", and \"; \" and the default number format for components.</p>\n+     */\n+    protected VectorFormat() {\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR,\n+             CompositeFormat.getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with a custom number format for components.\n+     * @param format the custom format for components.\n+     */\n+    protected VectorFormat(final NumberFormat format) {\n+        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix and separator.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param separator separator to use instead of the default \"; \"\n+     */\n+    protected VectorFormat(final String prefix, final String suffix,\n+                          final String separator) {\n+        this(prefix, suffix, separator, CompositeFormat.getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix, separator and format\n+     * for components.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param separator separator to use instead of the default \"; \"\n+     * @param format the custom format for components.\n+     */\n+    protected VectorFormat(final String prefix, final String suffix,\n+                          final String separator, final NumberFormat format) {\n+        this.prefix      = prefix;\n+        this.suffix      = suffix;\n+        this.separator   = separator;\n+        trimmedPrefix    = prefix.trim();\n+        trimmedSuffix    = suffix.trim();\n+        trimmedSeparator = separator.trim();\n+        this.format      = format;\n+    }\n+\n+    /**\n+     * Get the set of locales for which point/vector formats are available.\n+     * <p>This is the same set as the {@link NumberFormat} set.</p>\n+     * @return available point/vector format locales.\n+     */\n+    public static Locale[] getAvailableLocales() {\n+        return NumberFormat.getAvailableLocales();\n+    }\n+\n+    /**\n+     * Get the format prefix.\n+     * @return format prefix.\n+     */\n+    public String getPrefix() {\n+        return prefix;\n+    }\n+\n+    /**\n+     * Get the format suffix.\n+     * @return format suffix.\n+     */\n+    public String getSuffix() {\n+        return suffix;\n+    }\n+\n+    /**\n+     * Get the format separator between components.\n+     * @return format separator.\n+     */\n+    public String getSeparator() {\n+        return separator;\n+    }\n+\n+    /**\n+     * Get the components format.\n+     * @return components format.\n+     */\n+    public NumberFormat getFormat() {\n+        return format;\n+    }\n+\n+    /**\n+     * Formats a {@link Vector} object to produce a string.\n+     * @param vector the object to format.\n+     * @return a formatted string.\n+     */\n+    public String format(Vector<S> vector) {\n+        return format(vector, new StringBuffer(), new FieldPosition(0)).toString();\n+    }\n+\n+    /**\n+     * Formats a {@link Vector} object to produce a string.\n+     * @param vector the object to format.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @return the value passed in as toAppendTo.\n+     */\n+    public abstract StringBuffer format(Vector<S> vector,\n+                                        StringBuffer toAppendTo, FieldPosition pos);\n+\n+    /**\n+     * Formats the coordinates of a {@link Vector} to produce a string.\n+     * @param toAppendTo where the text is to be appended\n+     * @param pos On input: an alignment field, if desired. On output: the\n+     *            offsets of the alignment field\n+     * @param coordinates coordinates of the object to format.\n+     * @return the value passed in as toAppendTo.\n+     */\n+    protected StringBuffer format(StringBuffer toAppendTo, FieldPosition pos,\n+                                  double ... coordinates) {\n+\n+        pos.setBeginIndex(0);\n+        pos.setEndIndex(0);\n+\n+        // format prefix\n+        toAppendTo.append(prefix);\n+\n+        // format components\n+        for (int i = 0; i < coordinates.length; ++i) {\n+            if (i > 0) {\n+                toAppendTo.append(separator);\n+            }\n+            CompositeFormat.formatDouble(coordinates[i], format, toAppendTo, pos);\n+        }\n+\n+        // format suffix\n+        toAppendTo.append(suffix);\n+\n+        return toAppendTo;\n+\n+    }\n+\n+    /**\n+     * Parses a string to produce a {@link Vector} object.\n+     * @param source the string to parse\n+     * @return the parsed {@link Vector} object.\n+     * @throws MathParseException if the beginning of the specified string\n+     * cannot be parsed.\n+     */\n+    public abstract Vector<S> parse(String source);\n+\n+    /**\n+     * Parses a string to produce a {@link Vector} object.\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return the parsed {@link Vector} object.\n+     */\n+    public abstract Vector<S> parse(String source, ParsePosition pos);\n+\n+    /**\n+     * Parses a string to produce an array of coordinates.\n+     * @param dimension dimension of the space\n+     * @param source the string to parse\n+     * @param pos input/ouput parsing parameter.\n+     * @return coordinates array.\n+     */\n+    protected double[] parseCoordinates(int dimension, String source, ParsePosition pos) {\n+\n+        int initialIndex = pos.getIndex();\n+        double[] coordinates = new double[dimension];\n+\n+        // parse prefix\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        if (!CompositeFormat.parseFixedstring(source, trimmedPrefix, pos)) {\n+            return null;\n+        }\n+\n+        for (int i = 0; i < dimension; ++i) {\n+\n+            // skip whitespace\n+            CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+\n+            // parse separator\n+            if (i > 0) {\n+                if (!CompositeFormat.parseFixedstring(source, trimmedSeparator, pos)) {\n+                    return null;\n+                }\n+            }\n+\n+            // skip whitespace\n+            CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+\n+            // parse coordinate\n+            Number c = CompositeFormat.parseNumber(source, format, pos);\n+            if (c == null) {\n+                // invalid coordinate\n+                // set index back to initial, error index should already be set\n+                pos.setIndex(initialIndex);\n+                return null;\n+            }\n+\n+            // store coordinate\n+            coordinates[i] = c.doubleValue();\n+\n+        }\n+\n+        // parse suffix\n+        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n+        if (!CompositeFormat.parseFixedstring(source, trimmedSuffix, pos)) {\n+            return null;\n+        }\n+\n+        return coordinates;\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/oned/Euclidean1D.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry.euclidean.oned;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.exception.MathUnsupportedOperationException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.geometry.Space;\n+\n+/**\n+ * This class implements a one-dimensional space.\n+ * @version $Id:$\n+ * @since 3.0\n+ */\n+public class Euclidean1D implements Serializable, Space {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = -1178039568877797126L;\n+\n+    /** Private constructor for the singleton.\n+     */\n+    private Euclidean1D() {\n+    }\n+\n+    /** Get the unique instance.\n+     * @return the unique instance\n+     */\n+    public static Euclidean1D getInstance() {\n+        return LazyHolder.INSTANCE;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getDimension() {\n+        return 1;\n+    }\n+\n+    /** {@inheritDoc}\n+     * <p>\n+     * As the 1-dimension Euclidean space does not have proper sub-spaces,\n+     * this method always throws a {@link MathUnsupportedOperationException}\n+     * </p>\n+     * @return nothing\n+     * @throws MathUnsupportedOperationException in all cases\n+     */\n+    public Space getSubSpace() throws MathUnsupportedOperationException {\n+        throw new MathUnsupportedOperationException(LocalizedFormats.NOT_SUPPORTED_IN_DIMENSION_N, 1);\n+    }\n+\n+    // CHECKSTYLE: stop HideUtilityClassConstructor\n+    /** Holder for the instance.\n+     * <p>We use here the Initialization On Demand Holder Idiom.</p>\n+     */\n+    private static class LazyHolder {\n+        /** Cached field instance. */\n+        private static final Euclidean1D INSTANCE = new Euclidean1D();\n+    }\n+    // CHECKSTYLE: resume HideUtilityClassConstructor\n+\n+    /** Handle deserialization of the singleton.\n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        // return the singleton instance\n+        return LazyHolder.INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/oned/Vector1D.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.oned;\n+\n+import java.text.NumberFormat;\n+\n+import org.apache.commons.math.geometry.Vector;\n+import org.apache.commons.math.geometry.Space;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/** This class represents a 1D vector.\n+ * <p>Instances of this class are guaranteed to be immutable.</p>\n+ * @version $Id:$\n+ * @since 3.0\n+ */\n+public class Vector1D implements Vector<Euclidean1D> {\n+\n+    /** Origin (coordinates: 0). */\n+    public static final Vector1D ZERO = new Vector1D(0.0);\n+\n+    /** Unit (coordinates: 1). */\n+    public static final Vector1D ONE  = new Vector1D(1.0);\n+\n+    // CHECKSTYLE: stop ConstantName\n+    /** A vector with all coordinates set to NaN. */\n+    public static final Vector1D NaN = new Vector1D(Double.NaN);\n+    // CHECKSTYLE: resume ConstantName\n+\n+    /** A vector with all coordinates set to positive infinity. */\n+    public static final Vector1D POSITIVE_INFINITY =\n+        new Vector1D(Double.POSITIVE_INFINITY);\n+\n+    /** A vector with all coordinates set to negative infinity. */\n+    public static final Vector1D NEGATIVE_INFINITY =\n+        new Vector1D(Double.NEGATIVE_INFINITY);\n+\n+    /** Serializable UID. */\n+    private static final long serialVersionUID = 7556674948671647925L;\n+\n+    /** Abscissa. */\n+    private final double x;\n+\n+    /** Simple constructor.\n+     * Build a vector from its coordinates\n+     * @param x abscissa\n+     * @see #getX()\n+     */\n+    public Vector1D(double x) {\n+        this.x = x;\n+    }\n+\n+    /** Multiplicative constructor\n+     * Build a vector from another one and a scale factor.\n+     * The vector built will be a * u\n+     * @param a scale factor\n+     * @param u base (unscaled) vector\n+     */\n+    public Vector1D(double a, Vector1D u) {\n+        this.x = a * u.x;\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from two other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     */\n+    public Vector1D(double a1, Vector1D u1, double a2, Vector1D u2) {\n+        this.x = a1 * u1.x + a2 * u2.x;\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from three other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     */\n+    public Vector1D(double a1, Vector1D u1, double a2, Vector1D u2,\n+                   double a3, Vector1D u3) {\n+        this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x;\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from four other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     * @param a4 fourth scale factor\n+     * @param u4 fourth base (unscaled) vector\n+     */\n+    public Vector1D(double a1, Vector1D u1, double a2, Vector1D u2,\n+                   double a3, Vector1D u3, double a4, Vector1D u4) {\n+        this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;\n+    }\n+\n+    /** Get the abscissa of the vector.\n+     * @return abscissa of the vector\n+     * @see #Vector1D(double)\n+     */\n+    public double getX() {\n+        return x;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Space getSpace() {\n+        return Euclidean1D.getInstance();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector1D getZero() {\n+        return ZERO;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNorm1() {\n+        return FastMath.abs(x);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNorm() {\n+        return FastMath.abs(x);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNormSq() {\n+        return x * x;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNormInf() {\n+        return FastMath.abs(x);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector1D add(Vector<Euclidean1D> v) {\n+        Vector1D v1 = (Vector1D) v;\n+        return new Vector1D(x + v1.getX());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector1D add(double factor, Vector<Euclidean1D> v) {\n+        Vector1D v1 = (Vector1D) v;\n+        return new Vector1D(x + factor * v1.getX());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector1D subtract(Vector<Euclidean1D> p) {\n+        Vector1D p3 = (Vector1D) p;\n+        return new Vector1D(x - p3.x);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector1D subtract(double factor, Vector<Euclidean1D> v) {\n+        Vector1D v1 = (Vector1D) v;\n+        return new Vector1D(x - factor * v1.getX());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isNaN() {\n+        return Double.isNaN(x);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isInfinite() {\n+        return !isNaN() && Double.isInfinite(x);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double distance1(Vector<Euclidean1D> p) {\n+        Vector1D p3 = (Vector1D) p;\n+        final double dx = FastMath.abs(p3.x - x);\n+        return dx;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double distance(Vector<Euclidean1D> p) {\n+        Vector1D p3 = (Vector1D) p;\n+        final double dx = p3.x - x;\n+        return FastMath.abs(dx);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double distanceInf(Vector<Euclidean1D> p) {\n+        Vector1D p3 = (Vector1D) p;\n+        final double dx = FastMath.abs(p3.x - x);\n+        return dx;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double distanceSq(Vector<Euclidean1D> p) {\n+        Vector1D p3 = (Vector1D) p;\n+        final double dx = p3.x - x;\n+        return dx * dx;\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>2</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>p1.subtract(p2).getNorm()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param p1 first vector\n+     * @param p2 second vector\n+     * @return the distance between p1 and p2 according to the L<sub>2</sub> norm\n+     */\n+    public static double distance(Vector1D p1, Vector1D p2) {\n+        return p1.distance(p2);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>p1.subtract(p2).getNormInf()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param p1 first vector\n+     * @param p2 second vector\n+     * @return the distance between p1 and p2 according to the L<sub>&infin;</sub> norm\n+     */\n+    public static double distanceInf(Vector1D p1, Vector1D p2) {\n+        return p1.distanceInf(p2);\n+    }\n+\n+    /** Compute the square of the distance between two vectors.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>p1.subtract(p2).getNormSq()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param p1 first vector\n+     * @param p2 second vector\n+     * @return the square of the distance between p1 and p2\n+     */\n+    public static double distanceSq(Vector1D p1, Vector1D p2) {\n+        return p1.distanceSq(p2);\n+    }\n+\n+    /**\n+     * Test for the equality of two 1D vectors.\n+     * <p>\n+     * If all coordinates of two 1D vectors are exactly the same, and none are\n+     * <code>Double.NaN</code>, the two 1D vectors are considered to be equal.\n+     * </p>\n+     * <p>\n+     * <code>NaN</code> coordinates are considered to affect globally the vector\n+     * and be equals to each other - i.e, if either (or all) coordinates of the\n+     * 1D vector are equal to <code>Double.NaN</code>, the 1D vector is equal to\n+     * {@link #NaN}.\n+     * </p>\n+     *\n+     * @param other Object to test for equality to this\n+     * @return true if two 1D vector objects are equal, false if\n+     *         object is null, not an instance of Vector1D, or\n+     *         not equal to this Vector1D instance\n+     *\n+     */\n+    @Override\n+    public boolean equals(Object other) {\n+\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (other instanceof Vector1D) {\n+            final Vector1D rhs = (Vector1D)other;\n+            if (rhs.isNaN()) {\n+                return this.isNaN();\n+            }\n+\n+            return x == rhs.x;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Get a hashCode for the 1D vector.\n+     * <p>\n+     * All NaN values have the same hash code.</p>\n+     *\n+     * @return a hash code value for this object\n+     */\n+    @Override\n+    public int hashCode() {\n+        if (isNaN()) {\n+            return 7785;\n+        }\n+        return 997 * MathUtils.hash(x);\n+    }\n+\n+    /** Get a string representation of this vector.\n+     * @return a string representation of this vector\n+     */\n+    @Override\n+    public String toString() {\n+        return Vector1DFormat.getInstance().format(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public String toString(final NumberFormat format) {\n+        return new Vector1DFormat(format).format(this);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/oned/Vector1DFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry.euclidean.oned;\n+\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.exception.MathParseException;\n+import org.apache.commons.math.geometry.Vector;\n+import org.apache.commons.math.geometry.VectorFormat;\n+import org.apache.commons.math.util.CompositeFormat;\n+\n+/**\n+ * Formats a 1D vector in components list format \"{x}\".\n+ * <p>The prefix and suffix \"{\" and \"}\" can be replaced by\n+ * any user-defined strings. The number format for components can be configured.</p>\n+ * <p>White space is ignored at parse time, even if it is in the prefix, suffix\n+ * or separator specifications. So even if the default separator does include a space\n+ * character that is used at format time, both input string \"{1}\" and\n+ * \" { 1 } \" will be parsed without error and the same vector will be\n+ * returned. In the second case, however, the parse position after parsing will be\n+ * just after the closing curly brace, i.e. just before the trailing space.</p>\n+ *\n+ * @version $Id:$\n+ * @since 3.0\n+ */\n+public class Vector1DFormat extends VectorFormat<Euclidean1D> {\n+\n+    /**\n+     * Create an instance with default settings.\n+     * <p>The instance uses the default prefix, suffix and separator:\n+     * \"{\", \"}\", and \"; \" and the default number format for components.</p>\n+     */\n+    public Vector1DFormat() {\n+        super(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR,\n+              CompositeFormat.getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with a custom number format for components.\n+     * @param format the custom format for components.\n+     */\n+    public Vector1DFormat(final NumberFormat format) {\n+        super(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix and separator.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     */\n+    public Vector1DFormat(final String prefix, final String suffix) {\n+        super(prefix, suffix, DEFAULT_SEPARATOR, CompositeFormat.getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix, separator and format\n+     * for components.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param format the custom format for components.\n+     */\n+    public Vector1DFormat(final String prefix, final String suffix,\n+                         final NumberFormat format) {\n+        super(prefix, suffix, DEFAULT_SEPARATOR, format);\n+    }\n+\n+    /**\n+     * Returns the default 1D vector format for the current locale.\n+     * @return the default 1D vector format.\n+     */\n+    public static Vector1DFormat getInstance() {\n+        return getInstance(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Returns the default 1D vector format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the 1D vector format specific to the given locale.\n+     */\n+    public static Vector1DFormat getInstance(final Locale locale) {\n+        return new Vector1DFormat(CompositeFormat.getDefaultNumberFormat(locale));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public StringBuffer format(final Vector<Euclidean1D> vector, final StringBuffer toAppendTo,\n+                               final FieldPosition pos) {\n+        final Vector1D p1 = (Vector1D) vector;\n+        return format(toAppendTo, pos, p1.getX());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector1D parse(final String source) {\n+        ParsePosition parsePosition = new ParsePosition(0);\n+        Vector1D result = parse(source, parsePosition);\n+        if (parsePosition.getIndex() == 0) {\n+            throw new MathParseException(source,\n+                                         parsePosition.getErrorIndex(),\n+                                         Vector1D.class);\n+        }\n+        return result;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector1D parse(final String source, final ParsePosition pos) {\n+        final double[] coordinates = parseCoordinates(1, source, pos);\n+        if (coordinates == null) {\n+            return null;\n+        }\n+        return new Vector1D(coordinates[0]);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Euclidean3D.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry.euclidean.threed;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.geometry.Space;\n+import org.apache.commons.math.geometry.euclidean.twod.Euclidean2D;\n+\n+/**\n+ * This class implements a three-dimensional space.\n+ * @version $Id:$\n+ * @since 3.0\n+ */\n+public class Euclidean3D implements Serializable, Space {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 6249091865814886817L;\n+\n+    /** Private constructor for the singleton.\n+     */\n+    private Euclidean3D() {\n+    }\n+\n+    /** Get the unique instance.\n+     * @return the unique instance\n+     */\n+    public static Euclidean3D getInstance() {\n+        return LazyHolder.INSTANCE;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getDimension() {\n+        return 3;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Euclidean2D getSubSpace() {\n+        return Euclidean2D.getInstance();\n+    }\n+\n+    // CHECKSTYLE: stop HideUtilityClassConstructor\n+    /** Holder for the instance.\n+     * <p>We use here the Initialization On Demand Holder Idiom.</p>\n+     */\n+    private static class LazyHolder {\n+        /** Cached field instance. */\n+        private static final Euclidean3D INSTANCE = new Euclidean3D();\n+    }\n+    // CHECKSTYLE: resume HideUtilityClassConstructor\n+\n+    /** Handle deserialization of the singleton.\n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        // return the singleton instance\n+        return LazyHolder.INSTANCE;\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3D.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3D.java\n package org.apache.commons.math.geometry.euclidean.threed;\n \n import java.io.Serializable;\n+import java.text.NumberFormat;\n \n import org.apache.commons.math.exception.MathArithmeticException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.geometry.Vector;\n+import org.apache.commons.math.geometry.Space;\n+import org.apache.commons.math.util.FastMath;\n import org.apache.commons.math.util.MathUtils;\n-import org.apache.commons.math.util.FastMath;\n \n /**\n  * This class implements vectors in a three-dimensional space.\n  * <p>Instance of this class are guaranteed to be immutable.</p>\n- * @version $Revision$ $Date$\n+ * @version $Id$\n  * @since 1.2\n  */\n-public class Vector3D implements Serializable {\n-  /** Null vector (coordinates: 0, 0, 0). */\n-  public static final Vector3D ZERO   = new Vector3D(0, 0, 0);\n-\n-  /** First canonical vector (coordinates: 1, 0, 0). */\n-  public static final Vector3D PLUS_I = new Vector3D(1, 0, 0);\n-\n-  /** Opposite of the first canonical vector (coordinates: -1, 0, 0). */\n-  public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);\n-\n-  /** Second canonical vector (coordinates: 0, 1, 0). */\n-  public static final Vector3D PLUS_J = new Vector3D(0, 1, 0);\n-\n-  /** Opposite of the second canonical vector (coordinates: 0, -1, 0). */\n-  public static final Vector3D MINUS_J = new Vector3D(0, -1, 0);\n-\n-  /** Third canonical vector (coordinates: 0, 0, 1). */\n-  public static final Vector3D PLUS_K = new Vector3D(0, 0, 1);\n-\n-  /** Opposite of the third canonical vector (coordinates: 0, 0, -1).  */\n-  public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);\n-\n-  // CHECKSTYLE: stop ConstantName\n-  /** A vector with all coordinates set to NaN. */\n-  public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);\n-  // CHECKSTYLE: resume ConstantName\n-\n-  /** A vector with all coordinates set to positive infinity. */\n-  public static final Vector3D POSITIVE_INFINITY =\n-      new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n-\n-  /** A vector with all coordinates set to negative infinity. */\n-  public static final Vector3D NEGATIVE_INFINITY =\n-      new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n-\n-  /** Default format. */\n-  private static final Vector3DFormat DEFAULT_FORMAT =\n-      Vector3DFormat.getInstance();\n-\n-  /** Serializable version identifier. */\n-  private static final long serialVersionUID = 5133268763396045979L;\n-\n-  /** Abscissa. */\n-  private final double x;\n-\n-  /** Ordinate. */\n-  private final double y;\n-\n-  /** Height. */\n-  private final double z;\n-\n-  /** Simple constructor.\n-   * Build a vector from its coordinates\n-   * @param x abscissa\n-   * @param y ordinate\n-   * @param z height\n-   * @see #getX()\n-   * @see #getY()\n-   * @see #getZ()\n-   */\n-  public Vector3D(double x, double y, double z) {\n-    this.x = x;\n-    this.y = y;\n-    this.z = z;\n-  }\n-\n-  /** Simple constructor.\n-   * Build a vector from its azimuthal coordinates\n-   * @param alpha azimuth (&alpha;) around Z\n-   *              (0 is +X, &pi;/2 is +Y, &pi; is -X and 3&pi;/2 is -Y)\n-   * @param delta elevation (&delta;) above (XY) plane, from -&pi;/2 to +&pi;/2\n-   * @see #getAlpha()\n-   * @see #getDelta()\n-   */\n-  public Vector3D(double alpha, double delta) {\n-    double cosDelta = FastMath.cos(delta);\n-    this.x = FastMath.cos(alpha) * cosDelta;\n-    this.y = FastMath.sin(alpha) * cosDelta;\n-    this.z = FastMath.sin(delta);\n-  }\n-\n-  /** Multiplicative constructor\n-   * Build a vector from another one and a scale factor.\n-   * The vector built will be a * u\n-   * @param a scale factor\n-   * @param u base (unscaled) vector\n-   */\n-  public Vector3D(double a, Vector3D u) {\n-    this.x = a * u.x;\n-    this.y = a * u.y;\n-    this.z = a * u.z;\n-  }\n-\n-  /** Linear constructor\n-   * Build a vector from two other ones and corresponding scale factors.\n-   * The vector built will be a1 * u1 + a2 * u2\n-   * @param a1 first scale factor\n-   * @param u1 first base (unscaled) vector\n-   * @param a2 second scale factor\n-   * @param u2 second base (unscaled) vector\n-   */\n-  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\n-    this.x = a1 * u1.x + a2 * u2.x;\n-    this.y = a1 * u1.y + a2 * u2.y;\n-    this.z = a1 * u1.z + a2 * u2.z;\n-  }\n-\n-  /** Linear constructor\n-   * Build a vector from three other ones and corresponding scale factors.\n-   * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n-   * @param a1 first scale factor\n-   * @param u1 first base (unscaled) vector\n-   * @param a2 second scale factor\n-   * @param u2 second base (unscaled) vector\n-   * @param a3 third scale factor\n-   * @param u3 third base (unscaled) vector\n-   */\n-  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n-                  double a3, Vector3D u3) {\n-    this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x;\n-    this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y;\n-    this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z;\n-  }\n-\n-  /** Linear constructor\n-   * Build a vector from four other ones and corresponding scale factors.\n-   * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n-   * @param a1 first scale factor\n-   * @param u1 first base (unscaled) vector\n-   * @param a2 second scale factor\n-   * @param u2 second base (unscaled) vector\n-   * @param a3 third scale factor\n-   * @param u3 third base (unscaled) vector\n-   * @param a4 fourth scale factor\n-   * @param u4 fourth base (unscaled) vector\n-   */\n-  public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n-                  double a3, Vector3D u3, double a4, Vector3D u4) {\n-    this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;\n-    this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y + a4 * u4.y;\n-    this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z + a4 * u4.z;\n-  }\n-\n-  /** Get the abscissa of the vector.\n-   * @return abscissa of the vector\n-   * @see #Vector3D(double, double, double)\n-   */\n-  public double getX() {\n-    return x;\n-  }\n-\n-  /** Get the ordinate of the vector.\n-   * @return ordinate of the vector\n-   * @see #Vector3D(double, double, double)\n-   */\n-  public double getY() {\n-    return y;\n-  }\n-\n-  /** Get the height of the vector.\n-   * @return height of the vector\n-   * @see #Vector3D(double, double, double)\n-   */\n-  public double getZ() {\n-    return z;\n-  }\n-\n-  /** Get the L<sub>1</sub> norm for the vector.\n-   * @return L<sub>1</sub> norm for the vector\n-   */\n-  public double getNorm1() {\n-    return FastMath.abs(x) + FastMath.abs(y) + FastMath.abs(z);\n-  }\n-\n-  /** Get the L<sub>2</sub> norm for the vector.\n-   * @return euclidean norm for the vector\n-   */\n-  public double getNorm() {\n-    return FastMath.sqrt (x * x + y * y + z * z);\n-  }\n-\n-  /** Get the square of the norm for the vector.\n-   * @return square of the euclidean norm for the vector\n-   */\n-  public double getNormSq() {\n-    return x * x + y * y + z * z;\n-  }\n-\n-  /** Get the L<sub>&infin;</sub> norm for the vector.\n-   * @return L<sub>&infin;</sub> norm for the vector\n-   */\n-  public double getNormInf() {\n-    return FastMath.max(FastMath.max(FastMath.abs(x), FastMath.abs(y)), FastMath.abs(z));\n-  }\n-\n-  /** Get the azimuth of the vector.\n-   * @return azimuth (&alpha;) of the vector, between -&pi; and +&pi;\n-   * @see #Vector3D(double, double)\n-   */\n-  public double getAlpha() {\n-    return FastMath.atan2(y, x);\n-  }\n-\n-  /** Get the elevation of the vector.\n-   * @return elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2\n-   * @see #Vector3D(double, double)\n-   */\n-  public double getDelta() {\n-    return FastMath.asin(z / getNorm());\n-  }\n-\n-  /** Add a vector to the instance.\n-   * @param v vector to add\n-   * @return a new vector\n-   */\n-  public Vector3D add(Vector3D v) {\n-    return new Vector3D(x + v.x, y + v.y, z + v.z);\n-  }\n-\n-  /** Add a scaled vector to the instance.\n-   * @param factor scale factor to apply to v before adding it\n-   * @param v vector to add\n-   * @return a new vector\n-   */\n-  public Vector3D add(double factor, Vector3D v) {\n-    return new Vector3D(x + factor * v.x, y + factor * v.y, z + factor * v.z);\n-  }\n-\n-  /** Subtract a vector from the instance.\n-   * @param v vector to subtract\n-   * @return a new vector\n-   */\n-  public Vector3D subtract(Vector3D v) {\n-    return new Vector3D(x - v.x, y - v.y, z - v.z);\n-  }\n-\n-  /** Subtract a scaled vector from the instance.\n-   * @param factor scale factor to apply to v before subtracting it\n-   * @param v vector to subtract\n-   * @return a new vector\n-   */\n-  public Vector3D subtract(double factor, Vector3D v) {\n-    return new Vector3D(x - factor * v.x, y - factor * v.y, z - factor * v.z);\n-  }\n-\n-  /** Get a normalized vector aligned with the instance.\n-   * @return a new normalized vector\n-   * @exception ArithmeticException if the norm is zero\n-   */\n-  public Vector3D normalize() {\n-    double s = getNorm();\n-    if (s == 0) {\n-      throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n-    }\n-    return scalarMultiply(1 / s);\n-  }\n-\n-  /** Get a vector orthogonal to the instance.\n-   * <p>There are an infinite number of normalized vectors orthogonal\n-   * to the instance. This method picks up one of them almost\n-   * arbitrarily. It is useful when one needs to compute a reference\n-   * frame with one of the axes in a predefined direction. The\n-   * following example shows how to build a frame having the k axis\n-   * aligned with the known vector u :\n-   * <pre><code>\n-   *   Vector3D k = u.normalize();\n-   *   Vector3D i = k.orthogonal();\n-   *   Vector3D j = Vector3D.crossProduct(k, i);\n-   * </code></pre></p>\n-   * @return a new normalized vector orthogonal to the instance\n-   * @exception ArithmeticException if the norm of the instance is null\n-   */\n-  public Vector3D orthogonal() {\n-\n-    double threshold = 0.6 * getNorm();\n-    if (threshold == 0) {\n-      throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n-    }\n-\n-    if ((x >= -threshold) && (x <= threshold)) {\n-      double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n-      return new Vector3D(0, inverse * z, -inverse * y);\n-    } else if ((y >= -threshold) && (y <= threshold)) {\n-      double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n-      return new Vector3D(-inverse * z, 0, inverse * x);\n-    }\n-    double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n-    return new Vector3D(inverse * y, -inverse * x, 0);\n-\n-  }\n-\n-  /** Compute the angular separation between two vectors.\n-   * <p>This method computes the angular separation between two\n-   * vectors using the dot product for well separated vectors and the\n-   * cross product for almost aligned vectors. This allows to have a\n-   * good accuracy in all cases, even for vectors very close to each\n-   * other.</p>\n-   * @param v1 first vector\n-   * @param v2 second vector\n-   * @return angular separation between v1 and v2\n-   * @exception ArithmeticException if either vector has a null norm\n-   */\n-  public static double angle(Vector3D v1, Vector3D v2) {\n-\n-    double normProduct = v1.getNorm() * v2.getNorm();\n-    if (normProduct == 0) {\n-      throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n-    }\n-\n-    double dot = dotProduct(v1, v2);\n-    double threshold = normProduct * 0.9999;\n-    if ((dot < -threshold) || (dot > threshold)) {\n-      // the vectors are almost aligned, compute using the sine\n-      Vector3D v3 = crossProduct(v1, v2);\n-      if (dot >= 0) {\n-        return FastMath.asin(v3.getNorm() / normProduct);\n-      }\n-      return FastMath.PI - FastMath.asin(v3.getNorm() / normProduct);\n-    }\n-\n-    // the vectors are sufficiently separated to use the cosine\n-    return FastMath.acos(dot / normProduct);\n-\n-  }\n-\n-  /** Get the opposite of the instance.\n-   * @return a new vector which is opposite to the instance\n-   */\n-  public Vector3D negate() {\n-    return new Vector3D(-x, -y, -z);\n-  }\n-\n-  /** Multiply the instance by a scalar\n-   * @param a scalar\n-   * @return a new vector\n-   */\n-  public Vector3D scalarMultiply(double a) {\n-    return new Vector3D(a * x, a * y, a * z);\n-  }\n-\n-  /**\n-   * Returns true if any coordinate of this vector is NaN; false otherwise\n-   * @return  true if any coordinate of this vector is NaN; false otherwise\n-   */\n-  public boolean isNaN() {\n-      return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z);\n-  }\n-\n-  /**\n-   * Returns true if any coordinate of this vector is infinite and none are NaN;\n-   * false otherwise\n-   * @return  true if any coordinate of this vector is infinite and none are NaN;\n-   * false otherwise\n-   */\n-  public boolean isInfinite() {\n-      return !isNaN() && (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z));\n-  }\n-\n-  /**\n-   * Test for the equality of two 3D vectors.\n-   * <p>\n-   * If all coordinates of two 3D vectors are exactly the same, and none are\n-   * <code>Double.NaN</code>, the two 3D vectors are considered to be equal.\n-   * </p>\n-   * <p>\n-   * <code>NaN</code> coordinates are considered to affect globally the vector\n-   * and be equals to each other - i.e, if either (or all) coordinates of the\n-   * 3D vector are equal to <code>Double.NaN</code>, the 3D vector is equal to\n-   * {@link #NaN}.\n-   * </p>\n-   *\n-   * @param other Object to test for equality to this\n-   * @return true if two 3D vector objects are equal, false if\n-   *         object is null, not an instance of Vector3D, or\n-   *         not equal to this Vector3D instance\n-   *\n-   */\n-  @Override\n-  public boolean equals(Object other) {\n-\n-    if (this == other) {\n-      return true;\n-    }\n-\n-    if (other instanceof Vector3D) {\n-      final Vector3D rhs = (Vector3D)other;\n-      if (rhs.isNaN()) {\n-          return this.isNaN();\n-      }\n-\n-      return (x == rhs.x) && (y == rhs.y) && (z == rhs.z);\n-    }\n-    return false;\n-  }\n-\n-  /**\n-   * Get a hashCode for the 3D vector.\n-   * <p>\n-   * All NaN values have the same hash code.</p>\n-   *\n-   * @return a hash code value for this object\n-   */\n-  @Override\n-  public int hashCode() {\n-      if (isNaN()) {\n-          return 8;\n-      }\n-      return 31 * (23 * MathUtils.hash(x) +  19 * MathUtils.hash(y) +  MathUtils.hash(z));\n-  }\n-\n-  /** Compute the dot-product of two vectors.\n-   * @param v1 first vector\n-   * @param v2 second vector\n-   * @return the dot product v1.v2\n-   */\n-  public static double dotProduct(Vector3D v1, Vector3D v2) {\n-    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n-  }\n-\n-  /** Compute the cross-product of two vectors.\n-   * @param v1 first vector\n-   * @param v2 second vector\n-   * @return the cross product v1 ^ v2 as a new Vector\n-   */\n-  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n-\n-      final double n1 = v1.getNormSq();\n-      final double n2 = v2.getNormSq();\n-      if ((n1 * n2) < MathUtils.SAFE_MIN) {\n-          return ZERO;\n-      }\n-\n-      // rescale both vectors without losing precision,\n-      // to ensure their norm are the same order of magnitude\n-      final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;\n-      final double x1    = FastMath.scalb(v1.x, -deltaExp);\n-      final double y1    = FastMath.scalb(v1.y, -deltaExp);\n-      final double z1    = FastMath.scalb(v1.z, -deltaExp);\n-      final double x2    = FastMath.scalb(v2.x,  deltaExp);\n-      final double y2    = FastMath.scalb(v2.y,  deltaExp);\n-      final double z2    = FastMath.scalb(v2.z,  deltaExp);\n-\n-      // we reduce cancellation errors by preconditioning,\n-      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n-      // v3 without loss of precision. See Kahan lecture\n-      // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n-      // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n-\n-      // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n-      final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);\n-      final double rho   = FastMath.rint(256 * ratio) / 256;\n-\n-      final double x3 = x1 - rho * x2;\n-      final double y3 = y1 - rho * y2;\n-      final double z3 = z1 - rho * z2;\n-\n-      // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);\n-\n-  }\n-\n-  /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n-   * <p>Calling this method is equivalent to calling:\n-   * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n-   * vector is built</p>\n-   * @param v1 first vector\n-   * @param v2 second vector\n-   * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n-   */\n-  public static double distance1(Vector3D v1, Vector3D v2) {\n-    final double dx = FastMath.abs(v2.x - v1.x);\n-    final double dy = FastMath.abs(v2.y - v1.y);\n-    final double dz = FastMath.abs(v2.z - v1.z);\n-    return dx + dy + dz;\n-  }\n-\n-  /** Compute the distance between two vectors according to the L<sub>2</sub> norm.\n-   * <p>Calling this method is equivalent to calling:\n-   * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n-   * vector is built</p>\n-   * @param v1 first vector\n-   * @param v2 second vector\n-   * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n-   */\n-  public static double distance(Vector3D v1, Vector3D v2) {\n-    final double dx = v2.x - v1.x;\n-    final double dy = v2.y - v1.y;\n-    final double dz = v2.z - v1.z;\n-    return FastMath.sqrt(dx * dx + dy * dy + dz * dz);\n-  }\n-\n-  /** Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n-   * <p>Calling this method is equivalent to calling:\n-   * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n-   * vector is built</p>\n-   * @param v1 first vector\n-   * @param v2 second vector\n-   * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n-   */\n-  public static double distanceInf(Vector3D v1, Vector3D v2) {\n-    final double dx = FastMath.abs(v2.x - v1.x);\n-    final double dy = FastMath.abs(v2.y - v1.y);\n-    final double dz = FastMath.abs(v2.z - v1.z);\n-    return FastMath.max(FastMath.max(dx, dy), dz);\n-  }\n-\n-  /** Compute the square of the distance between two vectors.\n-   * <p>Calling this method is equivalent to calling:\n-   * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n-   * vector is built</p>\n-   * @param v1 first vector\n-   * @param v2 second vector\n-   * @return the square of the distance between v1 and v2\n-   */\n-  public static double distanceSq(Vector3D v1, Vector3D v2) {\n-    final double dx = v2.x - v1.x;\n-    final double dy = v2.y - v1.y;\n-    final double dz = v2.z - v1.z;\n-    return dx * dx + dy * dy + dz * dz;\n-  }\n-\n-  /** Get a string representation of this vector.\n-   * @return a string representation of this vector\n-   */\n-  @Override\n-  public String toString() {\n-      return DEFAULT_FORMAT.format(this);\n-  }\n+public class Vector3D implements Serializable, Vector<Euclidean3D> {\n+\n+    /** Serializable version id. */\n+    private static final long serialVersionUID = 1313493323784566947L;\n+\n+    /** Null vector (coordinates: 0, 0, 0). */\n+    public static final Vector3D ZERO   = new Vector3D(0, 0, 0);\n+\n+    /** First canonical vector (coordinates: 1, 0, 0). */\n+    public static final Vector3D PLUS_I = new Vector3D(1, 0, 0);\n+\n+    /** Opposite of the first canonical vector (coordinates: -1, 0, 0). */\n+    public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);\n+\n+    /** Second canonical vector (coordinates: 0, 1, 0). */\n+    public static final Vector3D PLUS_J = new Vector3D(0, 1, 0);\n+\n+    /** Opposite of the second canonical vector (coordinates: 0, -1, 0). */\n+    public static final Vector3D MINUS_J = new Vector3D(0, -1, 0);\n+\n+    /** Third canonical vector (coordinates: 0, 0, 1). */\n+    public static final Vector3D PLUS_K = new Vector3D(0, 0, 1);\n+\n+    /** Opposite of the third canonical vector (coordinates: 0, 0, -1).  */\n+    public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);\n+\n+    // CHECKSTYLE: stop ConstantName\n+    /** A vector with all coordinates set to NaN. */\n+    public static final Vector3D NaN = new Vector3D(Double.NaN, Double.NaN, Double.NaN);\n+    // CHECKSTYLE: resume ConstantName\n+\n+    /** A vector with all coordinates set to positive infinity. */\n+    public static final Vector3D POSITIVE_INFINITY =\n+        new Vector3D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+\n+    /** A vector with all coordinates set to negative infinity. */\n+    public static final Vector3D NEGATIVE_INFINITY =\n+        new Vector3D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n+\n+    /** Serializable version identifier. */\n+ \n+    /** Abscissa. */\n+    private final double x;\n+\n+    /** Ordinate. */\n+    private final double y;\n+\n+    /** Height. */\n+    private final double z;\n+\n+    /** Simple constructor.\n+     * Build a vector from its coordinates\n+     * @param x abscissa\n+     * @param y ordinate\n+     * @param z height\n+     * @see #getX()\n+     * @see #getY()\n+     * @see #getZ()\n+     */\n+    public Vector3D(double x, double y, double z) {\n+        this.x = x;\n+        this.y = y;\n+        this.z = z;\n+    }\n+\n+    /** Simple constructor.\n+     * Build a vector from its azimuthal coordinates\n+     * @param alpha azimuth (&alpha;) around Z\n+     *              (0 is +X, &pi;/2 is +Y, &pi; is -X and 3&pi;/2 is -Y)\n+     * @param delta elevation (&delta;) above (XY) plane, from -&pi;/2 to +&pi;/2\n+     * @see #getAlpha()\n+     * @see #getDelta()\n+     */\n+    public Vector3D(double alpha, double delta) {\n+        double cosDelta = FastMath.cos(delta);\n+        this.x = FastMath.cos(alpha) * cosDelta;\n+        this.y = FastMath.sin(alpha) * cosDelta;\n+        this.z = FastMath.sin(delta);\n+    }\n+\n+    /** Multiplicative constructor\n+     * Build a vector from another one and a scale factor.\n+     * The vector built will be a * u\n+     * @param a scale factor\n+     * @param u base (unscaled) vector\n+     */\n+    public Vector3D(double a, Vector3D u) {\n+        this.x = a * u.x;\n+        this.y = a * u.y;\n+        this.z = a * u.z;\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from two other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     */\n+    public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\n+        this.x = a1 * u1.x + a2 * u2.x;\n+        this.y = a1 * u1.y + a2 * u2.y;\n+        this.z = a1 * u1.z + a2 * u2.z;\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from three other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     */\n+    public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n+                    double a3, Vector3D u3) {\n+        this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x;\n+        this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y;\n+        this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z;\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from four other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     * @param a4 fourth scale factor\n+     * @param u4 fourth base (unscaled) vector\n+     */\n+    public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n+                    double a3, Vector3D u3, double a4, Vector3D u4) {\n+        this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;\n+        this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y + a4 * u4.y;\n+        this.z = a1 * u1.z + a2 * u2.z + a3 * u3.z + a4 * u4.z;\n+    }\n+\n+    /** Get the abscissa of the vector.\n+     * @return abscissa of the vector\n+     * @see #Vector3D(double, double, double)\n+     */\n+    public double getX() {\n+        return x;\n+    }\n+\n+    /** Get the ordinate of the vector.\n+     * @return ordinate of the vector\n+     * @see #Vector3D(double, double, double)\n+     */\n+    public double getY() {\n+        return y;\n+    }\n+\n+    /** Get the height of the vector.\n+     * @return height of the vector\n+     * @see #Vector3D(double, double, double)\n+     */\n+    public double getZ() {\n+        return z;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Space getSpace() {\n+        return Euclidean3D.getInstance();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector3D getZero() {\n+        return ZERO;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNorm1() {\n+        return FastMath.abs(x) + FastMath.abs(y) + FastMath.abs(z);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNorm() {\n+        return FastMath.sqrt (x * x + y * y + z * z);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNormSq() {\n+        return x * x + y * y + z * z;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNormInf() {\n+        return FastMath.max(FastMath.max(FastMath.abs(x), FastMath.abs(y)), FastMath.abs(z));\n+    }\n+\n+    /** Get the azimuth of the vector.\n+     * @return azimuth (&alpha;) of the vector, between -&pi; and +&pi;\n+     * @see #Vector3D(double, double)\n+     */\n+    public double getAlpha() {\n+        return FastMath.atan2(y, x);\n+    }\n+\n+    /** Get the elevation of the vector.\n+     * @return elevation (&delta;) of the vector, between -&pi;/2 and +&pi;/2\n+     * @see #Vector3D(double, double)\n+     */\n+    public double getDelta() {\n+        return FastMath.asin(z / getNorm());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector3D add(final Vector<Euclidean3D> v) {\n+        final Vector3D v3 = (Vector3D) v;\n+        return new Vector3D(x + v3.x, y + v3.y, z + v3.z);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector3D add(double factor, final Vector<Euclidean3D> v) {\n+        final Vector3D v3 = (Vector3D) v;\n+        return new Vector3D(x + factor * v3.x, y + factor * v3.y, z + factor * v3.z);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector3D subtract(final Vector<Euclidean3D> v) {\n+        final Vector3D v3 = (Vector3D) v;\n+        return new Vector3D(x - v3.x, y - v3.y, z - v3.z);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector3D subtract(final double factor, final Vector<Euclidean3D> v) {\n+        final Vector3D v3 = (Vector3D) v;\n+        return new Vector3D(x - factor * v3.x, y - factor * v3.y, z - factor * v3.z);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector3D normalize() {\n+        double s = getNorm();\n+        if (s == 0) {\n+            throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n+        }\n+        return scalarMultiply(1 / s);\n+    }\n+\n+    /** Get a vector orthogonal to the instance.\n+     * <p>There are an infinite number of normalized vectors orthogonal\n+     * to the instance. This method picks up one of them almost\n+     * arbitrarily. It is useful when one needs to compute a reference\n+     * frame with one of the axes in a predefined direction. The\n+     * following example shows how to build a frame having the k axis\n+     * aligned with the known vector u :\n+     * <pre><code>\n+     *   Vector3D k = u.normalize();\n+     *   Vector3D i = k.orthogonal();\n+     *   Vector3D j = Vector3D.crossProduct(k, i);\n+     * </code></pre></p>\n+     * @return a new normalized vector orthogonal to the instance\n+     * @exception MathArithmeticException if the norm of the instance is null\n+     */\n+    public Vector3D orthogonal() {\n+\n+        double threshold = 0.6 * getNorm();\n+        if (threshold == 0) {\n+            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n+        }\n+\n+        if ((x >= -threshold) && (x <= threshold)) {\n+            double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n+            return new Vector3D(0, inverse * z, -inverse * y);\n+        } else if ((y >= -threshold) && (y <= threshold)) {\n+            double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n+            return new Vector3D(-inverse * z, 0, inverse * x);\n+        }\n+        double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n+        return new Vector3D(inverse * y, -inverse * x, 0);\n+\n+    }\n+\n+    /** Compute the angular separation between two vectors.\n+     * <p>This method computes the angular separation between two\n+     * vectors using the dot product for well separated vectors and the\n+     * cross product for almost aligned vectors. This allows to have a\n+     * good accuracy in all cases, even for vectors very close to each\n+     * other.</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return angular separation between v1 and v2\n+     * @exception MathArithmeticException if either vector has a null norm\n+     */\n+    public static double angle(Vector3D v1, Vector3D v2) {\n+\n+        double normProduct = v1.getNorm() * v2.getNorm();\n+        if (normProduct == 0) {\n+            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n+        }\n+\n+        double dot = dotProduct(v1, v2);\n+        double threshold = normProduct * 0.9999;\n+        if ((dot < -threshold) || (dot > threshold)) {\n+            // the vectors are almost aligned, compute using the sine\n+            Vector3D v3 = crossProduct(v1, v2);\n+            if (dot >= 0) {\n+                return FastMath.asin(v3.getNorm() / normProduct);\n+            }\n+            return FastMath.PI - FastMath.asin(v3.getNorm() / normProduct);\n+        }\n+\n+        // the vectors are sufficiently separated to use the cosine\n+        return FastMath.acos(dot / normProduct);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector3D negate() {\n+        return new Vector3D(-x, -y, -z);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector3D scalarMultiply(double a) {\n+        return new Vector3D(a * x, a * y, a * z);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isNaN() {\n+        return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isInfinite() {\n+        return !isNaN() && (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z));\n+    }\n+\n+    /**\n+     * Test for the equality of two 3D vectors.\n+     * <p>\n+     * If all coordinates of two 3D vectors are exactly the same, and none are\n+     * <code>Double.NaN</code>, the two 3D vectors are considered to be equal.\n+     * </p>\n+     * <p>\n+     * <code>NaN</code> coordinates are considered to affect globally the vector\n+     * and be equals to each other - i.e, if either (or all) coordinates of the\n+     * 3D vector are equal to <code>Double.NaN</code>, the 3D vector is equal to\n+     * {@link #NaN}.\n+     * </p>\n+     *\n+     * @param other Object to test for equality to this\n+     * @return true if two 3D vector objects are equal, false if\n+     *         object is null, not an instance of Vector3D, or\n+     *         not equal to this Vector3D instance\n+     *\n+     */\n+    @Override\n+    public boolean equals(Object other) {\n+\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (other instanceof Vector3D) {\n+            final Vector3D rhs = (Vector3D)other;\n+            if (rhs.isNaN()) {\n+                return this.isNaN();\n+            }\n+\n+            return (x == rhs.x) && (y == rhs.y) && (z == rhs.z);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Get a hashCode for the 3D vector.\n+     * <p>\n+     * All NaN values have the same hash code.</p>\n+     *\n+     * @return a hash code value for this object\n+     */\n+    @Override\n+    public int hashCode() {\n+        if (isNaN()) {\n+            return 642;\n+        }\n+        return 643 * (164 * MathUtils.hash(x) +  3 * MathUtils.hash(y) +  MathUtils.hash(z));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double dotProduct(final Vector<Euclidean3D> v) {\n+        final Vector3D v3 = (Vector3D) v;\n+        return x * v3.x + y * v3.y + z * v3.z;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector3D crossProduct(final Vector<Euclidean3D> v) {\n+        final Vector3D v3 = (Vector3D) v;\n+\n+        final double n1 = getNormSq();\n+        final double n2 = v.getNormSq();\n+        if ((n1 * n2) < MathUtils.SAFE_MIN) {\n+            return ZERO;\n+        }\n+\n+        // rescale both vectors without losing precision,\n+        // to ensure their norm are the same order of magnitude\n+        final int deltaExp = (FastMath.getExponent(n1) - FastMath.getExponent(n2)) / 4;\n+        final double x1    = FastMath.scalb(x,   -deltaExp);\n+        final double y1    = FastMath.scalb(y,   -deltaExp);\n+        final double z1    = FastMath.scalb(z,   -deltaExp);\n+        final double x2    = FastMath.scalb(v3.x, deltaExp);\n+        final double y2    = FastMath.scalb(v3.y, deltaExp);\n+        final double z2    = FastMath.scalb(v3.z, deltaExp);\n+\n+        // we reduce cancellation errors by preconditioning,\n+        // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n+        // v3 without loss of precision. See Kahan lecture\n+        // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n+        // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n+\n+        // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n+        final double ratio = (x1 * x2 + y1 * y2 + z1 * z2) / FastMath.scalb(n2, 2 * deltaExp);\n+        final double rho   = FastMath.rint(256 * ratio) / 256;\n+\n+        final double x3 = x1 - rho * x2;\n+        final double y3 = y1 - rho * y2;\n+        final double z3 = z1 - rho * z2;\n+\n+        // compute cross product from v3 and v2 instead of v1 and v2\n+        return new Vector3D(y3 * z2 - z3 * y2, z3 * x2 - x3 * z2, x3 * y2 - y3 * x2);\n+\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double distance1(Vector<Euclidean3D> v) {\n+        final Vector3D v3 = (Vector3D) v;\n+        final double dx = FastMath.abs(v3.x - x);\n+        final double dy = FastMath.abs(v3.y - y);\n+        final double dz = FastMath.abs(v3.z - z);\n+        return dx + dy + dz;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double distance(Vector<Euclidean3D> v) {\n+        final Vector3D v3 = (Vector3D) v;\n+        final double dx = v3.x - x;\n+        final double dy = v3.y - y;\n+        final double dz = v3.z - z;\n+        return FastMath.sqrt(dx * dx + dy * dy + dz * dz);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double distanceInf(Vector<Euclidean3D> v) {\n+        final Vector3D v3 = (Vector3D) v;\n+        final double dx = FastMath.abs(v3.x - x);\n+        final double dy = FastMath.abs(v3.y - y);\n+        final double dz = FastMath.abs(v3.z - z);\n+        return FastMath.max(FastMath.max(dx, dy), dz);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double distanceSq(Vector<Euclidean3D> v) {\n+        final Vector3D v3 = (Vector3D) v;\n+        final double dx = v3.x - x;\n+        final double dy = v3.y - y;\n+        final double dz = v3.z - z;\n+        return dx * dx + dy * dy + dz * dz;\n+    }\n+\n+    /** Compute the dot-product of two vectors.\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the dot product v1.v2\n+     */\n+    public static double dotProduct(Vector3D v1, Vector3D v2) {\n+        return v1.dotProduct(v2);\n+    }\n+\n+    /** Compute the cross-product of two vectors.\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the cross product v1 ^ v2 as a new Vector\n+     */\n+    public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n+        return v1.crossProduct(v2);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNorm1()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the distance between v1 and v2 according to the L<sub>1</sub> norm\n+     */\n+    public static double distance1(Vector3D v1, Vector3D v2) {\n+        return v1.distance1(v2);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>2</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the distance between v1 and v2 according to the L<sub>2</sub> norm\n+     */\n+    public static double distance(Vector3D v1, Vector3D v2) {\n+        return v1.distance(v2);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNormInf()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the distance between v1 and v2 according to the L<sub>&infin;</sub> norm\n+     */\n+    public static double distanceInf(Vector3D v1, Vector3D v2) {\n+        return v1.distanceInf(v2);\n+    }\n+\n+    /** Compute the square of the distance between two vectors.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param v1 first vector\n+     * @param v2 second vector\n+     * @return the square of the distance between v1 and v2\n+     */\n+    public static double distanceSq(Vector3D v1, Vector3D v2) {\n+        return v1.distanceSq(v2);\n+    }\n+\n+    /** Get a string representation of this vector.\n+     * @return a string representation of this vector\n+     */\n+    @Override\n+    public String toString() {\n+        return Vector3DFormat.getInstance().format(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public String toString(final NumberFormat format) {\n+        return new Vector3DFormat(format).format(this);\n+    }\n \n }\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3DFormat.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Vector3DFormat.java\n import java.text.ParsePosition;\n import java.util.Locale;\n \n+import org.apache.commons.math.exception.MathParseException;\n+import org.apache.commons.math.geometry.Vector;\n+import org.apache.commons.math.geometry.VectorFormat;\n import org.apache.commons.math.util.CompositeFormat;\n-import org.apache.commons.math.exception.MathParseException;\n \n /**\n  * Formats a 3D vector in components list format \"{x; y; z}\".\n  * returned. In the second case, however, the parse position after parsing will be\n  * just after the closing curly brace, i.e. just before the trailing space.</p>\n  *\n- * @version $Revision$ $Date$\n+ * @version $Id:$\n  */\n-public class Vector3DFormat {\n-    /** Serializable version identifier */\n-    private static final long serialVersionUID = -5447606608652576301L;\n-    /** The default prefix: \"{\". */\n-    private static final String DEFAULT_PREFIX = \"{\";\n-    /** The default suffix: \"}\". */\n-    private static final String DEFAULT_SUFFIX = \"}\";\n-    /** The default separator: \", \". */\n-    private static final String DEFAULT_SEPARATOR = \"; \";\n-    /** Prefix. */\n-    private final String prefix;\n-    /** Suffix. */\n-    private final String suffix;\n-    /** Separator. */\n-    private final String separator;\n-    /** Trimmed prefix. */\n-    private final String trimmedPrefix;\n-    /** Trimmed suffix. */\n-    private final String trimmedSuffix;\n-    /** Trimmed separator. */\n-    private final String trimmedSeparator;\n-    /** The format used for components. */\n-    private final NumberFormat format;\n+public class Vector3DFormat extends VectorFormat<Euclidean3D> {\n \n     /**\n      * Create an instance with default settings.\n      * \"{\", \"}\", and \"; \" and the default number format for components.</p>\n      */\n     public Vector3DFormat() {\n-        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR,\n-             CompositeFormat.getDefaultNumberFormat());\n+        super(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR,\n+              CompositeFormat.getDefaultNumberFormat());\n     }\n \n     /**\n      * @param format the custom format for components.\n      */\n     public Vector3DFormat(final NumberFormat format) {\n-        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n+        super(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n     }\n \n     /**\n      * @param separator separator to use instead of the default \"; \"\n      */\n     public Vector3DFormat(final String prefix, final String suffix,\n-                          final String separator) {\n-        this(prefix, suffix, separator, CompositeFormat.getDefaultNumberFormat());\n+                         final String separator) {\n+        super(prefix, suffix, separator, CompositeFormat.getDefaultNumberFormat());\n     }\n \n     /**\n      * @param format the custom format for components.\n      */\n     public Vector3DFormat(final String prefix, final String suffix,\n-                          final String separator, final NumberFormat format) {\n-        this.prefix      = prefix;\n-        this.suffix      = suffix;\n-        this.separator   = separator;\n-        trimmedPrefix    = prefix.trim();\n-        trimmedSuffix    = suffix.trim();\n-        trimmedSeparator = separator.trim();\n-        this.format      = format;\n-    }\n-\n-    /**\n-     * Get the set of locales for which 3D vectors formats are available.\n-     * <p>This is the same set as the {@link NumberFormat} set.</p>\n-     * @return available 3D vector format locales.\n-     */\n-    public static Locale[] getAvailableLocales() {\n-        return NumberFormat.getAvailableLocales();\n-    }\n-\n-    /**\n-     * Get the format prefix.\n-     * @return format prefix.\n-     */\n-    public String getPrefix() {\n-        return prefix;\n-    }\n-\n-    /**\n-     * Get the format suffix.\n-     * @return format suffix.\n-     */\n-    public String getSuffix() {\n-        return suffix;\n-    }\n-\n-    /**\n-     * Get the format separator between components.\n-     * @return format separator.\n-     */\n-    public String getSeparator() {\n-        return separator;\n-    }\n-\n-    /**\n-     * Get the components format.\n-     * @return components format.\n-     */\n-    public NumberFormat getFormat() {\n-        return format;\n+                         final String separator, final NumberFormat format) {\n+        super(prefix, suffix, separator, format);\n     }\n \n     /**\n     }\n \n     /**\n-     * This method calls {@link #format(Vector3D,StringBuffer,FieldPosition)}.\n-     *\n-     * @param v Vector3D object to format.\n-     * @return a formatted vector.\n-     */\n-    public String format(Vector3D v) {\n-        return format(v, new StringBuffer(), new FieldPosition(0)).toString();\n-    }\n-\n-    /**\n      * Formats a {@link Vector3D} object to produce a string.\n      * @param vector the object to format.\n      * @param toAppendTo where the text is to be appended\n      *            offsets of the alignment field\n      * @return the value passed in as toAppendTo.\n      */\n-    public StringBuffer format(Vector3D vector, StringBuffer toAppendTo,\n-                               FieldPosition pos) {\n-\n-        pos.setBeginIndex(0);\n-        pos.setEndIndex(0);\n-\n-        // format prefix\n-        toAppendTo.append(prefix);\n-\n-        // format components\n-        CompositeFormat.formatDouble(vector.getX(), format, toAppendTo, pos);\n-        toAppendTo.append(separator);\n-        CompositeFormat.formatDouble(vector.getY(), format, toAppendTo, pos);\n-        toAppendTo.append(separator);\n-        CompositeFormat.formatDouble(vector.getZ(), format, toAppendTo, pos);\n-\n-        // format suffix\n-        toAppendTo.append(suffix);\n-\n-        return toAppendTo;\n+    public StringBuffer format(final Vector<Euclidean3D> vector, final StringBuffer toAppendTo,\n+                               final FieldPosition pos) {\n+        final Vector3D v3 = (Vector3D) vector;\n+        return format(toAppendTo, pos, v3.getX(), v3.getY(), v3.getZ());\n     }\n \n     /**\n      * @throws MathParseException if the beginning of the specified string\n      * cannot be parsed.\n      */\n-    public Vector3D parse(String source) {\n+    public Vector3D parse(final String source) {\n         ParsePosition parsePosition = new ParsePosition(0);\n         Vector3D result = parse(source, parsePosition);\n         if (parsePosition.getIndex() == 0) {\n      * @param pos input/ouput parsing parameter.\n      * @return the parsed {@link Vector3D} object.\n      */\n-    public Vector3D parse(String source, ParsePosition pos) {\n-        int initialIndex = pos.getIndex();\n-\n-        // parse prefix\n-        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n-        if (!CompositeFormat.parseFixedstring(source, trimmedPrefix, pos)) {\n+    public Vector3D parse(final String source, final ParsePosition pos) {\n+        final double[] coordinates = parseCoordinates(3, source, pos);\n+        if (coordinates == null) {\n             return null;\n         }\n+        return new Vector3D(coordinates[0], coordinates[1], coordinates[2]);\n+    }\n \n-        // parse X component\n-        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n-        Number x = CompositeFormat.parseNumber(source, format, pos);\n-        if (x == null) {\n-            // invalid abscissa\n-            // set index back to initial, error index should already be set\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n-\n-        // parse Y component\n-        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n-        if (!CompositeFormat.parseFixedstring(source, trimmedSeparator, pos)) {\n-            return null;\n-        }\n-        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n-        Number y = CompositeFormat.parseNumber(source, format, pos);\n-        if (y == null) {\n-            // invalid ordinate\n-            // set index back to initial, error index should already be set\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n-\n-        // parse Z component\n-        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n-        if (!CompositeFormat.parseFixedstring(source, trimmedSeparator, pos)) {\n-            return null;\n-        }\n-        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n-        Number z = CompositeFormat.parseNumber(source, format, pos);\n-        if (z == null) {\n-            // invalid height\n-            // set index back to initial, error index should already be set\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n-\n-        // parse suffix\n-        CompositeFormat.parseAndIgnoreWhitespace(source, pos);\n-        if (!CompositeFormat.parseFixedstring(source, trimmedSuffix, pos)) {\n-            return null;\n-        }\n-\n-        return new Vector3D(x.doubleValue(), y.doubleValue(), z.doubleValue());\n-    }\n }\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/Euclidean2D.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry.euclidean.twod;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.geometry.Space;\n+import org.apache.commons.math.geometry.euclidean.oned.Euclidean1D;\n+\n+/**\n+ * This class implements a three-dimensional space.\n+ * @version $Id:$\n+ * @since 3.0\n+ */\n+public class Euclidean2D implements Serializable, Space {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 4793432849757649566L;\n+\n+    /** Private constructor for the singleton.\n+     */\n+    private Euclidean2D() {\n+    }\n+\n+    /** Get the unique instance.\n+     * @return the unique instance\n+     */\n+    public static Euclidean2D getInstance() {\n+        return LazyHolder.INSTANCE;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public int getDimension() {\n+        return 2;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Euclidean1D getSubSpace() {\n+        return Euclidean1D.getInstance();\n+    }\n+\n+    // CHECKSTYLE: stop HideUtilityClassConstructor\n+    /** Holder for the instance.\n+     * <p>We use here the Initialization On Demand Holder Idiom.</p>\n+     */\n+    private static class LazyHolder {\n+        /** Cached field instance. */\n+        private static final Euclidean2D INSTANCE = new Euclidean2D();\n+    }\n+    // CHECKSTYLE: resume HideUtilityClassConstructor\n+\n+    /** Handle deserialization of the singleton.\n+     * @return the singleton instance\n+     */\n+    private Object readResolve() {\n+        // return the singleton instance\n+        return LazyHolder.INSTANCE;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/Vector2D.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.euclidean.twod;\n+\n+import java.text.NumberFormat;\n+\n+import org.apache.commons.math.geometry.Space;\n+import org.apache.commons.math.geometry.Vector;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/** This class represents a 2D vector.\n+ * <p>Instances of this class are guaranteed to be immutable.</p>\n+ * @version $Id:$\n+ * @since 3.0\n+ */\n+public class Vector2D implements Vector<Euclidean2D> {\n+\n+    /** Origin (coordinates: 0, 0). */\n+    public static final Vector2D ZERO   = new Vector2D(0, 0);\n+\n+    // CHECKSTYLE: stop ConstantName\n+    /** A vector with all coordinates set to NaN. */\n+    public static final Vector2D NaN = new Vector2D(Double.NaN, Double.NaN);\n+    // CHECKSTYLE: resume ConstantName\n+\n+    /** A vector with all coordinates set to positive infinity. */\n+    public static final Vector2D POSITIVE_INFINITY =\n+        new Vector2D(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+\n+    /** A vector with all coordinates set to negative infinity. */\n+    public static final Vector2D NEGATIVE_INFINITY =\n+        new Vector2D(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n+\n+    /** Serializable UID. */\n+    private static final long serialVersionUID = 266938651998679754L;\n+\n+    /** Abscissa. */\n+    private final double x;\n+\n+    /** Ordinate. */\n+    private final double y;\n+\n+    /** Simple constructor.\n+     * Build a vector from its coordinates\n+     * @param x abscissa\n+     * @param y ordinate\n+     * @see #getX()\n+     * @see #getY()\n+     */\n+    public Vector2D(double x, double y) {\n+        this.x = x;\n+        this.y = y;\n+    }\n+\n+    /** Multiplicative constructor\n+     * Build a vector from another one and a scale factor.\n+     * The vector built will be a * u\n+     * @param a scale factor\n+     * @param u base (unscaled) vector\n+     */\n+    public Vector2D(double a, Vector2D u) {\n+        this.x = a * u.x;\n+        this.y = a * u.y;\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from two other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     */\n+    public Vector2D(double a1, Vector2D u1, double a2, Vector2D u2) {\n+        this.x = a1 * u1.x + a2 * u2.x;\n+        this.y = a1 * u1.y + a2 * u2.y;\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from three other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     */\n+    public Vector2D(double a1, Vector2D u1, double a2, Vector2D u2,\n+                   double a3, Vector2D u3) {\n+        this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x;\n+        this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y;\n+    }\n+\n+    /** Linear constructor\n+     * Build a vector from four other ones and corresponding scale factors.\n+     * The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n+     * @param a1 first scale factor\n+     * @param u1 first base (unscaled) vector\n+     * @param a2 second scale factor\n+     * @param u2 second base (unscaled) vector\n+     * @param a3 third scale factor\n+     * @param u3 third base (unscaled) vector\n+     * @param a4 fourth scale factor\n+     * @param u4 fourth base (unscaled) vector\n+     */\n+    public Vector2D(double a1, Vector2D u1, double a2, Vector2D u2,\n+                   double a3, Vector2D u3, double a4, Vector2D u4) {\n+        this.x = a1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;\n+        this.y = a1 * u1.y + a2 * u2.y + a3 * u3.y + a4 * u4.y;\n+    }\n+\n+    /** Get the abscissa of the vector.\n+     * @return abscissa of the vector\n+     * @see #Vector2D(double, double)\n+     */\n+    public double getX() {\n+        return x;\n+    }\n+\n+    /** Get the ordinate of the vector.\n+     * @return ordinate of the vector\n+     * @see #Vector2D(double, double)\n+     */\n+    public double getY() {\n+        return y;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Space getSpace() {\n+        return Euclidean2D.getInstance();\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector2D getZero() {\n+        return ZERO;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector2D toVector() {\n+        return new Vector2D(x, y);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNorm1() {\n+        return FastMath.abs(x) + FastMath.abs(y);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNorm() {\n+        return FastMath.sqrt (x * x + y * y);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNormSq() {\n+        return x * x + y * y;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getNormInf() {\n+        return FastMath.max(FastMath.abs(x), FastMath.abs(y));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector2D add(Vector<Euclidean2D> v) {\n+        Vector2D v2 = (Vector2D) v;\n+        return new Vector2D(x + v2.getX(), y + v2.getY());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector2D add(double factor, Vector<Euclidean2D> v) {\n+        Vector2D v2 = (Vector2D) v;\n+        return new Vector2D(x + factor * v2.getX(), y + factor * v2.getY());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector2D subtract(Vector<Euclidean2D> p) {\n+        Vector2D p3 = (Vector2D) p;\n+        return new Vector2D(x - p3.x, y - p3.y);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector2D subtract(double factor, Vector<Euclidean2D> v) {\n+        Vector2D v2 = (Vector2D) v;\n+        return new Vector2D(x - factor * v2.getX(), y - factor * v2.getY());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isNaN() {\n+        return Double.isNaN(x) || Double.isNaN(y);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isInfinite() {\n+        return !isNaN() && (Double.isInfinite(x) || Double.isInfinite(y));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double distance1(Vector<Euclidean2D> p) {\n+        Vector2D p3 = (Vector2D) p;\n+        final double dx = FastMath.abs(p3.x - x);\n+        final double dy = FastMath.abs(p3.y - y);\n+        return dx + dy;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double distance(Vector<Euclidean2D> p) {\n+        Vector2D p3 = (Vector2D) p;\n+        final double dx = p3.x - x;\n+        final double dy = p3.y - y;\n+        return FastMath.sqrt(dx * dx + dy * dy);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double distanceInf(Vector<Euclidean2D> p) {\n+        Vector2D p3 = (Vector2D) p;\n+        final double dx = FastMath.abs(p3.x - x);\n+        final double dy = FastMath.abs(p3.y - y);\n+        return FastMath.max(dx, dy);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double distanceSq(Vector<Euclidean2D> p) {\n+        Vector2D p3 = (Vector2D) p;\n+        final double dx = p3.x - x;\n+        final double dy = p3.y - y;\n+        return dx * dx + dy * dy;\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>2</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>p1.subtract(p2).getNorm()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param p1 first vector\n+     * @param p2 second vector\n+     * @return the distance between p1 and p2 according to the L<sub>2</sub> norm\n+     */\n+    public static double distance(Vector2D p1, Vector2D p2) {\n+        return p1.distance(p2);\n+    }\n+\n+    /** Compute the distance between two vectors according to the L<sub>&infin;</sub> norm.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>p1.subtract(p2).getNormInf()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param p1 first vector\n+     * @param p2 second vector\n+     * @return the distance between p1 and p2 according to the L<sub>&infin;</sub> norm\n+     */\n+    public static double distanceInf(Vector2D p1, Vector2D p2) {\n+        return p1.distanceInf(p2);\n+    }\n+\n+    /** Compute the square of the distance between two vectors.\n+     * <p>Calling this method is equivalent to calling:\n+     * <code>p1.subtract(p2).getNormSq()</code> except that no intermediate\n+     * vector is built</p>\n+     * @param p1 first vector\n+     * @param p2 second vector\n+     * @return the square of the distance between p1 and p2\n+     */\n+    public static double distanceSq(Vector2D p1, Vector2D p2) {\n+        return p1.distanceSq(p2);\n+    }\n+\n+    /**\n+     * Test for the equality of two 2D vectors.\n+     * <p>\n+     * If all coordinates of two 2D vectors are exactly the same, and none are\n+     * <code>Double.NaN</code>, the two 2D vectors are considered to be equal.\n+     * </p>\n+     * <p>\n+     * <code>NaN</code> coordinates are considered to affect globally the vector\n+     * and be equals to each other - i.e, if either (or all) coordinates of the\n+     * 2D vector are equal to <code>Double.NaN</code>, the 2D vector is equal to\n+     * {@link #NaN}.\n+     * </p>\n+     *\n+     * @param other Object to test for equality to this\n+     * @return true if two 2D vector objects are equal, false if\n+     *         object is null, not an instance of Vector2D, or\n+     *         not equal to this Vector2D instance\n+     *\n+     */\n+    @Override\n+    public boolean equals(Object other) {\n+\n+        if (this == other) {\n+            return true;\n+        }\n+\n+        if (other instanceof Vector2D) {\n+            final Vector2D rhs = (Vector2D)other;\n+            if (rhs.isNaN()) {\n+                return this.isNaN();\n+            }\n+\n+            return (x == rhs.x) && (y == rhs.y);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Get a hashCode for the 2D vector.\n+     * <p>\n+     * All NaN values have the same hash code.</p>\n+     *\n+     * @return a hash code value for this object\n+     */\n+    @Override\n+    public int hashCode() {\n+        if (isNaN()) {\n+            return 542;\n+        }\n+        return 122 * (76 * MathUtils.hash(x) +  MathUtils.hash(y));\n+    }\n+\n+    /** Get a string representation of this vector.\n+     * @return a string representation of this vector\n+     */\n+    @Override\n+    public String toString() {\n+        return Vector2DFormat.getInstance().format(this);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public String toString(final NumberFormat format) {\n+        return new Vector2DFormat(format).format(this);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/twod/Vector2DFormat.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.geometry.euclidean.twod;\n+\n+import java.text.FieldPosition;\n+import java.text.NumberFormat;\n+import java.text.ParsePosition;\n+import java.util.Locale;\n+\n+import org.apache.commons.math.exception.MathParseException;\n+import org.apache.commons.math.geometry.Vector;\n+import org.apache.commons.math.geometry.VectorFormat;\n+import org.apache.commons.math.util.CompositeFormat;\n+\n+/**\n+ * Formats a 2D vector in components list format \"{x; y}\".\n+ * <p>The prefix and suffix \"{\" and \"}\" and the separator \"; \" can be replaced by\n+ * any user-defined strings. The number format for components can be configured.</p>\n+ * <p>White space is ignored at parse time, even if it is in the prefix, suffix\n+ * or separator specifications. So even if the default separator does include a space\n+ * character that is used at format time, both input string \"{1;1}\" and\n+ * \" { 1 ; 1 } \" will be parsed without error and the same vector will be\n+ * returned. In the second case, however, the parse position after parsing will be\n+ * just after the closing curly brace, i.e. just before the trailing space.</p>\n+ *\n+ * @version $Id:$\n+ * @since 3.0\n+ */\n+public class Vector2DFormat extends VectorFormat<Euclidean2D> {\n+\n+    /**\n+     * Create an instance with default settings.\n+     * <p>The instance uses the default prefix, suffix and separator:\n+     * \"{\", \"}\", and \"; \" and the default number format for components.</p>\n+     */\n+    public Vector2DFormat() {\n+        super(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR,\n+              CompositeFormat.getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with a custom number format for components.\n+     * @param format the custom format for components.\n+     */\n+    public Vector2DFormat(final NumberFormat format) {\n+        super(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix and separator.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param separator separator to use instead of the default \"; \"\n+     */\n+    public Vector2DFormat(final String prefix, final String suffix,\n+                         final String separator) {\n+        super(prefix, suffix, separator, CompositeFormat.getDefaultNumberFormat());\n+    }\n+\n+    /**\n+     * Create an instance with custom prefix, suffix, separator and format\n+     * for components.\n+     * @param prefix prefix to use instead of the default \"{\"\n+     * @param suffix suffix to use instead of the default \"}\"\n+     * @param separator separator to use instead of the default \"; \"\n+     * @param format the custom format for components.\n+     */\n+    public Vector2DFormat(final String prefix, final String suffix,\n+                         final String separator, final NumberFormat format) {\n+        super(prefix, suffix, separator, format);\n+    }\n+\n+    /**\n+     * Returns the default 2D vector format for the current locale.\n+     * @return the default 2D vector format.\n+     */\n+    public static Vector2DFormat getInstance() {\n+        return getInstance(Locale.getDefault());\n+    }\n+\n+    /**\n+     * Returns the default 2D vector format for the given locale.\n+     * @param locale the specific locale used by the format.\n+     * @return the 2D vector format specific to the given locale.\n+     */\n+    public static Vector2DFormat getInstance(final Locale locale) {\n+        return new Vector2DFormat(CompositeFormat.getDefaultNumberFormat(locale));\n+    }\n+\n+    /** {@inheritDoc} */\n+    public StringBuffer format(final Vector<Euclidean2D> vector, final StringBuffer toAppendTo,\n+                               final FieldPosition pos) {\n+        final Vector2D p2 = (Vector2D) vector;\n+        return format(toAppendTo, pos, p2.getX(), p2.getY());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector2D parse(final String source) {\n+        ParsePosition parsePosition = new ParsePosition(0);\n+        Vector2D result = parse(source, parsePosition);\n+        if (parsePosition.getIndex() == 0) {\n+            throw new MathParseException(source,\n+                                         parsePosition.getErrorIndex(),\n+                                         Vector2D.class);\n+        }\n+        return result;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public Vector2D parse(final String source, final ParsePosition pos) {\n+        final double[] coordinates = parseCoordinates(2, source, pos);\n+        if (coordinates == null) {\n+            return null;\n+        }\n+        return new Vector2D(coordinates[0], coordinates[1]);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/geometry/partitioning/Embedding.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.geometry.partitioning;\n+\n+import org.apache.commons.math.geometry.Vector;\n+import org.apache.commons.math.geometry.Space;\n+\n+/** This interface defines mappers between a space and one of its sub-spaces.\n+\n+ * <p>Sub-spaces are the lower dimensions subsets of a n-dimensions\n+ * space. The (n-1)-dimension sub-spaces are specific sub-spaces known\n+ * as {@link Hyperplane hyperplanes}. This interface can be used regardless\n+ * of the dimensions differences. As an example, {@link\n+ * org.apache.commons.math.geometry.euclidean.threed.Line Line} in 3D\n+ * implements Embedding<{@link\n+ * org.apache.commons.math.geometry.euclidean.threed.Vector3D Vector3D}, {link\n+ * org.apache.commons.math.geometry.euclidean.oned.Vector1D Vector1D>, i.e. it\n+ * maps directly dimensions 3 and 1.</p>\n+\n+ * <p>In the 3D euclidean space, hyperplanes are 2D planes, and the 1D\n+ * sub-spaces are lines.</p>\n+\n+ * @param <S> Type of the embedding space.\n+ * @param <T> Type of the embedded sub-space.\n+\n+ * @see Hyperplane\n+ * @version $Id:$\n+ * @since 3.0\n+ */\n+public interface Embedding<S extends Space, T extends Space> {\n+\n+    /** Transform a space point into a sub-space point.\n+     * @param point n-dimension point of the space\n+     * @return (n-1)-dimension point of the sub-space corresponding to\n+     * the specified space point\n+     * @see #toSpace\n+     */\n+    Vector<T> toSubSpace(Vector<S> point);\n+\n+    /** Transform a sub-space point into a space point.\n+     * @param point (n-1)-dimension point of the sub-space\n+     * @return n-dimension point of the space corresponding to the\n+     * specified sub-space point\n+     * @see #toSubSpace\n+     */\n+    Vector<S> toSpace(Vector<T> point);\n+\n+}", "timestamp": 1307124168, "metainfo": ""}