{"sha": "3dc361920534bd229d7e561607c298119bde4843", "log": "MATH-487 Removed checked exceptions.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/ContinuedFraction.java\n+++ b/src/main/java/org/apache/commons/math/util/ContinuedFraction.java\n  */\n package org.apache.commons.math.util;\n \n-import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.MathException;\n+import org.apache.commons.math.exception.ConvergenceException;\n import org.apache.commons.math.exception.MaxCountExceededException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n  * @version $Revision$ $Date$\n  */\n public abstract class ContinuedFraction {\n-\n     /** Maximum allowed numerical error. */\n     private static final double DEFAULT_EPSILON = 10e-9;\n \n      * Evaluates the continued fraction at the value x.\n      * @param x the evaluation point.\n      * @return the value of the continued fraction evaluated at x.\n-     * @throws MathException if the algorithm fails to converge.\n-     */\n-    public double evaluate(double x) throws MathException {\n+     * @throws ConvergenceException if the algorithm fails to converge.\n+     */\n+    public double evaluate(double x) {\n         return evaluate(x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n     }\n \n      * @param x the evaluation point.\n      * @param epsilon maximum error allowed.\n      * @return the value of the continued fraction evaluated at x.\n-     * @throws MathException if the algorithm fails to converge.\n-     */\n-    public double evaluate(double x, double epsilon) throws MathException {\n+     * @throws ConvergenceException if the algorithm fails to converge.\n+     */\n+    public double evaluate(double x, double epsilon) {\n         return evaluate(x, epsilon, Integer.MAX_VALUE);\n     }\n \n      * @param x the evaluation point.\n      * @param maxIterations maximum number of convergents\n      * @return the value of the continued fraction evaluated at x.\n-     * @throws MathException if the algorithm fails to converge.\n-     */\n-    public double evaluate(double x, int maxIterations) throws MathException {\n+     * @throws ConvergenceException if the algorithm fails to converge.\n+     */\n+    public double evaluate(double x, int maxIterations) {\n         return evaluate(x, DEFAULT_EPSILON, maxIterations);\n     }\n \n      * @param epsilon maximum error allowed.\n      * @param maxIterations maximum number of convergents\n      * @return the value of the continued fraction evaluated at x.\n-     * @throws MathException if the algorithm fails to converge.\n-     */\n-    public double evaluate(double x, double epsilon, int maxIterations)\n-        throws MathException\n-    {\n+     * @throws ConvergenceException if the algorithm fails to converge.\n+     */\n+    public double evaluate(double x, double epsilon, int maxIterations) {\n         double p0 = 1.0;\n         double p1 = getA(0, x);\n         double q0 = 0.0;\n                 final int maxPower = 5;\n                 final double scale = FastMath.max(a,b);\n                 if (scale <= 0) {  // Can't scale\n-                    throw new ConvergenceException(\n-                            LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n-                             x);\n+                    throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n+                                                   x);\n                 }\n                 infinite = true;\n                 for (int i = 0; i < maxPower; i++) {\n \n             if (infinite) {\n                // Scaling failed\n-               throw new ConvergenceException(\n-                 LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n-                  x);\n+               throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\n+                                              x);\n             }\n \n             double r = p2 / q2;\n \n             if (Double.isNaN(r)) {\n-                throw new ConvergenceException(\n-                  LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n-                  x);\n+                throw new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\n+                                               x);\n             }\n             relativeError = FastMath.abs(r / c - 1.0);\n \n \n         if (n >= maxIterations) {\n             throw new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\n-                    maxIterations, x);\n+                                                maxIterations, x);\n         }\n \n         return c;", "timestamp": 1300536271, "metainfo": ""}