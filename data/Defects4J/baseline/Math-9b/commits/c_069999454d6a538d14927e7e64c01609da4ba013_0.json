{"sha": "069999454d6a538d14927e7e64c01609da4ba013", "log": "improved consistency in class naming with respect to functions in the analysis package  ", "commit": "\n--- a/src/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n+++ b/src/java/org/apache/commons/math/optimization/LeastSquaresConverter.java\n \n package org.apache.commons.math.optimization;\n \n+import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.MultivariateVectorialFunction;\n import org.apache.commons.math.linear.RealMatrix;\n \n-/** This class converts {@link VectorialObjectiveFunction vectorial\n- * objective functions} to {@link ScalarObjectiveFunction scalar objective functions}\n+/** This class converts {@link MultivariateVectorialFunction vectorial\n+ * objective functions} to {@link MultivariateRealFunction scalar objective functions}\n  * when the goal is to minimize them.\n  * <p>\n  * This class is mostly used when the vectorial objective function represents\n- * a theoretical result computed from a variables set applied to a model and\n- * the models variables must be adjusted to fit the theoretical result to some\n+ * a theoretical result computed from a point set applied to a model and\n+ * the models point must be adjusted to fit the theoretical result to some\n  * reference observations. The observations may be obtained for example from\n  * physical measurements whether the model is built from theoretical\n  * considerations.\n  * This class computes a possibly weighted squared sum of the residuals, which is\n  * a scalar value. The residuals are the difference between the theoretical model\n  * (i.e. the output of the vectorial objective function) and the observations. The\n- * class implements the {@link ScalarObjectiveFunction} interface and can therefore be\n+ * class implements the {@link MultivariateRealFunction} interface and can therefore be\n  * minimized by any optimizer supporting scalar objectives functions.This is one way\n  * to perform a least square estimation. There are other ways to do this without using\n  * this converter, as some optimization algorithms directly support vectorial objective\n  * This class support combination of residuals with or without weights and correlations.\n  * </p>\n   *\n- * @see ScalarObjectiveFunction\n- * @see VectorialObjectiveFunction\n+ * @see MultivariateRealFunction\n+ * @see MultivariateVectorialFunction\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n \n-public class LeastSquaresConverter implements ScalarObjectiveFunction {\n+public class LeastSquaresConverter implements MultivariateRealFunction {\n \n     /** Serializable version identifier. */\n     private static final long serialVersionUID = -4369653306135732243L;\n \n     /** Underlying vectorial function. */\n-    private final VectorialObjectiveFunction function;\n+    private final MultivariateVectorialFunction function;\n \n     /** Observations to be compared to objective function to compute residuals. */\n     private final double[] observations;\n      * @param function vectorial residuals function to wrap\n      * @param observations observations to be compared to objective function to compute residuals\n      */\n-    public LeastSquaresConverter(final VectorialObjectiveFunction function,\n+    public LeastSquaresConverter(final MultivariateVectorialFunction function,\n                                  final double[] observations) {\n         this.function     = function;\n         this.observations = observations.clone();\n      * </p>\n      * <p>\n      * The array computed by the objective function, the observations array and the\n-     * weights array must have consistent sizes or a {@link ObjectiveException} will be\n+     * weights array must have consistent sizes or a {@link FunctionEvaluationException} will be\n      * triggered while computing the scalar objective.\n      * </p>\n      * @param function vectorial residuals function to wrap\n      * vector dimensions don't match (objective function dimension is checked only when\n      * the {@link #objective} method is called)\n      */\n-    public LeastSquaresConverter(final VectorialObjectiveFunction function,\n+    public LeastSquaresConverter(final MultivariateVectorialFunction function,\n                                  final double[] observations, final double[] weights)\n         throws IllegalArgumentException {\n         if (observations.length != weights.length) {\n      * </p>\n      * <p>\n      * The array computed by the objective function, the observations array and the\n-     * the scaling matrix must have consistent sizes or a {@link ObjectiveException}\n+     * the scaling matrix must have consistent sizes or a {@link FunctionEvaluationException}\n      * will be triggered while computing the scalar objective.\n      * </p>\n      * @param function vectorial residuals function to wrap\n      * matrix dimensions don't match (objective function dimension is checked only when\n      * the {@link #objective} method is called)\n      */\n-    public LeastSquaresConverter(final VectorialObjectiveFunction function,\n+    public LeastSquaresConverter(final MultivariateVectorialFunction function,\n                                  final double[] observations, final RealMatrix scale)\n         throws IllegalArgumentException {\n         if (observations.length != scale.getColumnDimension()) {\n     }\n \n     /** {@inheritDoc} */\n-    public double objective(final double[] variables) throws ObjectiveException {\n+    public double value(final double[] point) throws FunctionEvaluationException {\n \n         // compute residuals\n-        final double[] residuals = function.objective(variables);\n+        final double[] residuals = function.value(point);\n         if (residuals.length != observations.length) {\n-            throw new ObjectiveException(\"dimension mismatch {0} != {1}\",\n-                                         residuals.length, observations.length);\n+            throw new FunctionEvaluationException(point, \"dimension mismatch {0} != {1}\",\n+                                                  residuals.length, observations.length);\n         }\n         for (int i = 0; i < residuals.length; ++i) {\n             residuals[i] -= observations[i];", "timestamp": 1237932676, "metainfo": ""}