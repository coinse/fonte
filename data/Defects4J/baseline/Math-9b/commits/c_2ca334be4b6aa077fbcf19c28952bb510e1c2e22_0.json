{"sha": "2ca334be4b6aa077fbcf19c28952bb510e1c2e22", "log": "clean up code, mainly replacing static dotProduct methods calls by non-static ones  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Line.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Line.java\n  */\n package org.apache.commons.math.geometry.euclidean.threed;\n \n+import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.geometry.Vector;\n import org.apache.commons.math.geometry.euclidean.oned.Euclidean1D;\n import org.apache.commons.math.geometry.euclidean.oned.Vector1D;\n import org.apache.commons.math.geometry.partitioning.Embedding;\n import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n \n /** The class represent lines in a three dimensional space.\n \n     /** Build a line from a point and a direction.\n      * @param p point belonging to the line (this can be any point)\n      * @param direction direction of the line\n-     * @exception IllegalArgumentException if the direction norm is too small\n+     * @exception MathArithmeticException if the direction norm is too small\n      */\n     public Line(final Vector3D p, final Vector3D direction) {\n         reset(p, direction);\n+    }\n+\n+    /** Copy constructor.\n+     * <p>The created instance is completely independent from the\n+     * original instance, it is a deep copy.</p>\n+     * @param line line to copy\n+     */\n+    public Line(final Line line) {\n+        this.direction = line.direction;\n+        this.zero      = line.zero;\n     }\n \n     /** Reset the instance as if built from a point and a normal.\n      * @param p point belonging to the line (this can be any point)\n      * @param dir direction of the line\n-     * @exception IllegalArgumentException if the direction norm is too small\n+     * @exception MathArithmeticException if the direction norm is too small\n      */\n     public void reset(final Vector3D p, final Vector3D dir) {\n         final double norm = dir.getNorm();\n         if (norm == 0.0) {\n-            throw new IllegalArgumentException(\"null norm\");\n+            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n         }\n         this.direction = new Vector3D(1.0 / norm, dir);\n-        zero = new Vector3D(1.0, p, -Vector3D.dotProduct(p, this.direction), this.direction);\n+        zero = new Vector3D(1.0, p, -p.dotProduct(this.direction), this.direction);\n     }\n \n     /** Get a line with reversed direction.\n      * <p>The abscissa is 0 if the projection of the point and the\n      * projection of the frame origin on the line are the same\n      * point.</p>\n-     * @param point point to check (must be a {@link Vector3D Vector3D}\n-     * instance)\n-     * @return abscissa of the point (really a\n-     * {org.apache.commons.math.geometry.euclidean.oned.Vector1D Vector1D} instance)\n+     * @param point point to check\n+     * @return abscissa of the point\n+     */\n+    public double getAbscissa(final Vector3D point) {\n+        return point.subtract(zero).dotProduct(direction);\n+    }\n+\n+    /** Get one point from the line.\n+     * @param point desired abscissa for the point\n+     * @return one point belonging to the line, at specified abscissa\n+     */\n+    public Vector3D pointAt(final double abscissa) {\n+        return new Vector3D(1.0, zero, abscissa, direction);\n+    }\n+\n+    /** {@inheritDoc}\n+     * @see #getAbscissa(Vector3D)\n      */\n     public Vector1D toSubSpace(final Vector<Euclidean3D> point) {\n-        Vector3D p3 = (Vector3D) point;\n-        return new Vector1D(Vector3D.dotProduct(p3.subtract(zero), direction));\n-    }\n-\n-    /** Get one point from the line.\n-     * @param point desired abscissa for the point (must be a\n-     * {org.apache.commons.math.geometry.euclidean.oned.Vector1D Vector1D} instance)\n-     * @return one point belonging to the line, at specified abscissa\n-     * (really a {@link Vector3D Vector3D} instance)\n+        return new Vector1D(getAbscissa((Vector3D) point));\n+    }\n+\n+    /** {@inheritDoc}\n+     * @see #pointAt(double)\n      */\n     public Vector3D toSpace(final Vector<Euclidean1D> point) {\n-        Vector1D p1 = (Vector1D) point;\n-        return new Vector3D(1.0, zero, p1.getX(), direction);\n+        return pointAt(((Vector1D) point).getX());\n     }\n \n     /** Check if the instance is similar to another line.\n      */\n     public double distance(final Vector3D p) {\n         final Vector3D d = p.subtract(zero);\n-        final Vector3D n = new Vector3D(1.0, d, -Vector3D.dotProduct(d, direction), direction);\n+        final Vector3D n = new Vector3D(1.0, d, -d.dotProduct(direction), direction);\n         return n.getNorm();\n     }\n \n     /** Compute the shortest distance between the instance and another line.\n-     * @param line line to check agains the instance\n+     * @param line line to check against the instance\n      * @return shortest distance between the instance and the line\n      */\n     public double distance(final Line line) {\n \n         final Vector3D normal = Vector3D.crossProduct(direction, line.direction);\n-        if (normal.getNorm() < 1.0e-10) {\n+        final double n = normal.getNorm();\n+        if (n < MathUtils.SAFE_MIN) {\n             // lines are parallel\n             return distance(line.zero);\n         }\n \n-        // separating middle plane\n-        final Plane middle = new Plane(new Vector3D(0.5, zero, 0.5, line.zero), normal);\n-\n-        // the lines are at the same distance on either side of the plane\n-        return 2 * FastMath.abs(middle.getOffset(zero));\n-\n+        // signed separation of the two parallel planes that contains the lines\n+        final double offset = line.zero.subtract(zero).dotProduct(normal) / n;\n+\n+        return FastMath.abs(offset);\n+\n+    }\n+\n+    /** Compute the point of the instance closest to another line.\n+     * @param line line to check against the instance\n+     * @return point of the instance closest to another line\n+     */\n+    public Vector3D closestPoint(final Line line) {\n+\n+        final double cos = direction.dotProduct(line.direction);\n+        final double n = 1 - cos * cos;\n+        if (n < MathUtils.EPSILON) {\n+            // the lines are parallel\n+            return zero;\n+        }\n+\n+        final Vector3D delta0 = line.zero.subtract(zero);\n+        final double a        = delta0.dotProduct(direction);\n+        final double b        = delta0.dotProduct(line.direction);\n+\n+        return new Vector3D(1, zero, (a - b * cos) / n, direction);\n+\n+    }\n+\n+    /** Get the intersection point of the instance and another line.\n+     * @param line other line\n+     * @return intersection point of the instance and the other line\n+     * or null if there are no intersection points\n+     */\n+    public Vector3D intersection(final Line line) {\n+        final Vector3D closest = closestPoint(line);\n+        return line.contains(closest) ? closest : null;\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/OutlineExtractor.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/OutlineExtractor.java\n                 (AbstractSubHyperplane<Euclidean3D, Euclidean2D>) facet;\n             final Plane plane    = (Plane) facet.getHyperplane();\n \n-            final double scal = Vector3D.dotProduct(plane.getNormal(), w);\n+            final double scal = plane.getNormal().dotProduct(w);\n             if (FastMath.abs(scal) > 1.0e-3) {\n                 Vector2D[][] vertices =\n                     ((PolygonsSet) absFacet.getRemainingRegion()).getVertices();\n                     int previous         = closed ? (loop.length - 1) : 1;\n                     Vector3D previous3D  = (Vector3D) plane.toSpace(loop[previous]);\n                     int current          = (previous + 1) % loop.length;\n-                    Vector2D pPoint       = new Vector2D(Vector3D.dotProduct(previous3D, u),\n-                                                       Vector3D.dotProduct(previous3D, v));\n+                    Vector2D pPoint       = new Vector2D(previous3D.dotProduct(u),\n+                                                         previous3D.dotProduct(v));\n                     while (current < loop.length) {\n \n                         final Vector3D current3D = (Vector3D) plane.toSpace(loop[current]);\n-                        final Vector2D  cPoint    = new Vector2D(Vector3D.dotProduct(current3D, u),\n-                                                               Vector3D.dotProduct(current3D, v));\n+                        final Vector2D  cPoint    = new Vector2D(current3D.dotProduct(u),\n+                                                                 current3D.dotProduct(v));\n                         final org.apache.commons.math.geometry.euclidean.twod.Line line =\n                             new org.apache.commons.math.geometry.euclidean.twod.Line(pPoint, cPoint);\n                         SubHyperplane<Euclidean2D> edge = line.wholeHyperplane();\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Plane.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/Plane.java\n  */\n package org.apache.commons.math.geometry.euclidean.threed;\n \n+import org.apache.commons.math.exception.MathArithmeticException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.geometry.Vector;\n import org.apache.commons.math.geometry.euclidean.oned.Vector1D;\n import org.apache.commons.math.geometry.euclidean.twod.Euclidean2D;\n \n     /** Build a plane normal to a given direction and containing the origin.\n      * @param normal normal direction to the plane\n-     * @exception IllegalArgumentException if the normal norm is too small\n+     * @exception MathArithmeticException if the normal norm is too small\n      */\n     public Plane(final Vector3D normal) {\n         setNormal(normal);\n     /** Build a plane from a point and a normal.\n      * @param p point belonging to the plane\n      * @param normal normal direction to the plane\n-     * @exception IllegalArgumentException if the normal norm is too small\n+     * @exception MathArithmeticException if the normal norm is too small\n      */\n     public Plane(final Vector3D p, final Vector3D normal) {\n         setNormal(normal);\n-        originOffset = -Vector3D.dotProduct(p, w);\n+        originOffset = -p.dotProduct(w);\n         setFrame();\n     }\n \n      * @param p1 first point belonging to the plane\n      * @param p2 second point belonging to the plane\n      * @param p3 third point belonging to the plane\n-     * @exception IllegalArgumentException if the points do not constitute a plane\n+     * @exception MathArithmeticException if the points do not constitute a plane\n      */\n     public Plane(final Vector3D p1, final Vector3D p2, final Vector3D p3) {\n-        this(p1, Vector3D.crossProduct(p2.subtract(p1), p3.subtract(p1)));\n+        this(p1, p2.subtract(p1).crossProduct(p3.subtract(p1)));\n     }\n \n     /** Copy constructor.\n      */\n     public void reset(final Vector3D p, final Vector3D normal) {\n         setNormal(normal);\n-        originOffset = -Vector3D.dotProduct(p, w);\n+        originOffset = -p.dotProduct(w);\n         setFrame();\n     }\n \n \n     /** Set the normal vactor.\n      * @param normal normal direction to the plane (will be copied)\n-     * @exception IllegalArgumentException if the normal norm is too small\n+     * @exception MathArithmeticException if the normal norm is too small\n      */\n     private void setNormal(final Vector3D normal) {\n         final double norm = normal.getNorm();\n         if (norm < 1.0e-10) {\n-            throw new IllegalArgumentException(\"null norm\");\n+            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n         }\n         w = new Vector3D(1.0 / norm, normal);\n     }\n      * @see #toSpace\n      */\n     public Vector2D toSubSpace(final Vector<Euclidean3D> point) {\n-        final Vector3D p3D = (Vector3D) point;\n-        return new Vector2D(Vector3D.dotProduct(p3D, u),\n-                           Vector3D.dotProduct(p3D, v));\n+        return new Vector2D(point.dotProduct(u), point.dotProduct(v));\n     }\n \n     /** Transform an in-plane point into a 3D space point.\n      */\n     public Vector3D intersection(final Line line) {\n         final Vector3D direction = line.getDirection();\n-        final double   dot       = Vector3D.dotProduct(w, direction);\n+        final double   dot       = w.dotProduct(direction);\n         if (FastMath.abs(dot) < 1.0e-10) {\n             return null;\n         }\n         final Vector3D point = (Vector3D) line.toSpace(Vector1D.ZERO);\n-        final double   k     = -(originOffset + Vector3D.dotProduct(w, point)) / dot;\n+        final double   k     = -(originOffset + w.dotProduct(point)) / dot;\n         return new Vector3D(1.0, point, k, direction);\n     }\n \n      * @return offset of the point\n      */\n     public double getOffset(final Vector<Euclidean3D> point) {\n-        return Vector3D.dotProduct((Vector3D) point, w) + originOffset;\n+        return point.dotProduct(w) + originOffset;\n     }\n \n     /** Check if the instance has the same orientation as another hyperplane.\n      * the same orientation\n      */\n     public boolean sameOrientationAs(final Hyperplane<Euclidean3D> other) {\n-        return Vector3D.dotProduct(((Plane) other).w, w) > 0.0;\n+        return (((Plane) other).w).dotProduct(w) > 0.0;\n     }\n \n }\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/PolyhedronsSet.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/PolyhedronsSet.java\n \n                 final Plane    plane  = (Plane) facet.getHyperplane();\n                 final Vector3D facetB = plane.toSpace(polygon.getBarycenter());\n-                double   scaled = area * Vector3D.dotProduct(facetB, plane.getNormal());\n+                double   scaled = area * facetB.dotProduct(plane.getNormal());\n                 if (reversed) {\n                     scaled = -scaled;\n                 }\n--- a/src/main/java/org/apache/commons/math/geometry/euclidean/threed/SubPlane.java\n+++ b/src/main/java/org/apache/commons/math/geometry/euclidean/threed/SubPlane.java\n         Vector2D p = thisPlane.toSubSpace(inter.toSpace(Vector1D.ZERO));\n         Vector2D q = thisPlane.toSubSpace(inter.toSpace(Vector1D.ONE));\n         Vector3D crossP = Vector3D.crossProduct(inter.getDirection(), thisPlane.getNormal());\n-        if (Vector3D.dotProduct(crossP, otherPlane.getNormal()) < 0) {\n+        if (crossP.dotProduct(otherPlane.getNormal()) < 0) {\n             final Vector2D tmp = p;\n             p           = q;\n             q           = tmp;\n         Vector2D p = thisPlane.toSubSpace(inter.toSpace(Vector1D.ZERO));\n         Vector2D q = thisPlane.toSubSpace(inter.toSpace(Vector1D.ONE));\n         Vector3D crossP = Vector3D.crossProduct(inter.getDirection(), thisPlane.getNormal());\n-        if (Vector3D.dotProduct(crossP, otherPlane.getNormal()) < 0) {\n+        if (crossP.dotProduct(otherPlane.getNormal()) < 0) {\n             final Vector2D tmp = p;\n             p           = q;\n             q           = tmp;", "timestamp": 1313432408, "metainfo": ""}