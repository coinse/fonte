{"sha": "94417fe1ff3d59d80dd0edc0de712d37785013a3", "log": "moved the various solve function out of decomposition algorithms and into a dedicated DecompositionSolver class  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n     // org.apache.commons.math.linear.SingularMatrixException\n     { \"matrix is singular\",\n       \"matrice singuli\\u00e8re\" },\n-\n-    // org.apache.commons.math.linear.RankDeficientMatrixException\n-    { \"matrix is rank-deficient\",\n-      \"le rang de la matrice est inf\\u00e9rieur \\u00e0 sa dimension\" },\n \n     // org.apache.commons.math.linear.RealVectorImpl\n     { \"index {0} out of allowed range [{1}, {2}]\",\n--- a/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/AbstractEstimator.java\n \n import java.util.Arrays;\n \n+import org.apache.commons.math.linear.DecompositionSolver;\n import org.apache.commons.math.linear.InvalidMatrixException;\n+import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealMatrixImpl;\n \n /**\n \n         try {\n             // compute the covariances matrix\n-            return ((RealMatrixImpl) new RealMatrixImpl(jTj, false).inverse()).getDataRef();\n+            DecompositionSolver solver = new DecompositionSolver(new RealMatrixImpl(jTj, false));\n+            RealMatrix inverse = solver.getInverse(solver.luDecompose());\n+            return ((RealMatrixImpl) inverse).getDataRef();\n         } catch (InvalidMatrixException ime) {\n             throw new EstimationException(\"unable to compute covariances: singular problem\",\n                                           null);\n--- a/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n+++ b/src/java/org/apache/commons/math/estimation/GaussNewtonEstimator.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math.linear.DecompositionSolver;\n import org.apache.commons.math.linear.InvalidMatrixException;\n-import org.apache.commons.math.linear.LUDecompositionImpl;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealMatrixImpl;\n import org.apache.commons.math.linear.RealVector;\n             try {\n \n                 // solve the linearized least squares problem\n-                RealVector dX = new LUDecompositionImpl(a).solve(b);\n+                DecompositionSolver solver = new DecompositionSolver(a);\n+                RealVector dX = solver.solve(b, solver.luDecompose());\n \n                 // update the estimated parameters\n                 for (int i = 0; i < parameters.length; ++i) {\n--- a/src/java/org/apache/commons/math/linear/DecompositionSolver.java\n+++ b/src/java/org/apache/commons/math/linear/DecompositionSolver.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math.util.MathUtils;\n+\n /**\n- * A base interface to decomposition algorithms that can solve A &times; X = B.\n- * <p>This interface is the common base of decomposition algorithms like\n+ * Class handling decomposition algorithms that can solve A &times; X = B.\n+ * <p>This class is the entry point for decomposition algorithms like\n  * {@link QRDecomposition}, {@link LUDecomposition}, {@link\n  * SingularValueDecomposition} or {@link EigenDecomposition}. All these\n  * algorithms decompose an A matrix has a product of several specific matrices\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public interface DecompositionSolver extends Serializable {\n-\n-    /**\n-     * Decompose a matrix.\n+public class DecompositionSolver implements Serializable {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 182675257956465253L;\n+\n+    /** Matrix to decompose. */\n+    private final RealMatrix matrix;\n+\n+    /**\n+     * Build a decomposition solver for a matrix.\n      * @param matrix matrix to decompose\n+     */\n+    public DecompositionSolver(final RealMatrix matrix) {\n+        this.matrix = matrix;\n+    }\n+\n+    /**\n+     * Decompose a matrix using eigendecomposition.\n+     * <p>The split tolerance is set by default to {@link MathUtils#SAFE_MIN}.</p>\n      * @exception InvalidMatrixException if matrix does not fulfill\n      * the decomposition requirements (for example non-square matrix\n      * for {@link LUDecomposition})\n      */\n-    void decompose(RealMatrix matrix)\n-        throws InvalidMatrixException;\n-\n-    /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It <strong>must</strong> have\n-     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n-     * @param b right-hand side of the equation A &times; X = B\n+    public EigenDecomposition eigenDecompose()\n+        throws InvalidMatrixException {\n+        return new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+    }\n+\n+    /**\n+     * Decompose a matrix using eigendecomposition.\n+     * @param splitTolerance tolerance on the off-diagonal elements relative to the\n+     * geometric mean to split the tridiagonal matrix (a suggested value is\n+     * {@link MathUtils#SAFE_MIN})\n+     * @exception InvalidMatrixException if matrix does not fulfill\n+     * the decomposition requirements (for example non-square matrix\n+     * for {@link LUDecomposition})\n+     */\n+    public EigenDecomposition eigenDecompose(final double splitTolerance)\n+        throws InvalidMatrixException {\n+        return new EigenDecompositionImpl(matrix, splitTolerance);\n+    }\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @param decomposition decomposition of the matrix A\n      * @return a vector X that minimizes the two norm of A &times; X - B\n-     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n-     * has not been called\n-     * @exception IllegalArgumentException if matrices dimensions don't match\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n-     */\n-    double[] solve(double[] b)\n-        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException;\n-\n-    /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It <strong>must</strong> have\n-     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n-     * @param b right-hand side of the equation A &times; X = B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public double[] solve(final double[] b, final EigenDecomposition decomposition)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        if (!isNonSingular(decomposition)) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        final double[] eigenvalues = decomposition.getEigenvalues();\n+        final int m = eigenvalues.length;\n+        if (b.length != m) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+\n+        final double[] bp = new double[m];\n+        for (int i = 0; i < m; ++i) {\n+            final RealVector v = decomposition.getEigenvector(i);\n+            final double s = v.dotProduct(b) / eigenvalues[i];\n+            for (int j = 0; j < m; ++j) {\n+                bp[j] += s * v.getEntry(j);\n+            }\n+        }\n+\n+        return bp;\n+\n+    }\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @param decomposition decomposition of the matrix A\n      * @return a vector X that minimizes the two norm of A &times; X - B\n-     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n-     * has not been called\n-     * @exception IllegalArgumentException if matrices dimensions don't match\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n-     */\n-    RealVector solve(RealVector b)\n-        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException;\n-\n-    /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It <strong>must</strong> have\n-     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n-     * @param b right-hand side of the equation A &times; X = B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealVector solve(final RealVector b, final EigenDecomposition decomposition)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        if (!isNonSingular(decomposition)) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        final double[] eigenvalues = decomposition.getEigenvalues();\n+        final int m = eigenvalues.length;\n+        if (b.getDimension() != m) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+\n+        final double[] bp = new double[m];\n+        for (int i = 0; i < m; ++i) {\n+            final RealVector v = decomposition.getEigenvector(i);\n+            final double s = v.dotProduct(b) / eigenvalues[i];\n+            for (int j = 0; j < m; ++j) {\n+                bp[j] += s * v.getEntry(j);\n+            }\n+        }\n+\n+        return new RealVectorImpl(bp, false);\n+\n+    }\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @param decomposition decomposition of the matrix A\n      * @return a matrix X that minimizes the two norm of A &times; X - B\n-     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n-     * has not been called\n-     * @exception IllegalArgumentException if matrices dimensions don't match\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n-     */\n-    RealMatrix solve(RealMatrix b)\n-        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException;\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealMatrix solve(final RealMatrix b, final EigenDecomposition decomposition)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        if (!isNonSingular(decomposition)) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        final double[] eigenvalues = decomposition.getEigenvalues();\n+        final int m = eigenvalues.length;\n+        if (b.getRowDimension() != m) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+\n+        final int nColB = b.getColumnDimension();\n+        final double[][] bp = new double[m][nColB];\n+        for (int k = 0; k < nColB; ++k) {\n+            for (int i = 0; i < m; ++i) {\n+                final RealVector v = decomposition.getEigenvector(i);\n+                double s = 0;\n+                for (int j = 0; j < m; ++j) {\n+                    s += v.getEntry(j) * b.getEntry(j, k);\n+                }\n+                s /= eigenvalues[i];\n+                for (int j = 0; j < m; ++j) {\n+                    bp[j][k] += s * v.getEntry(j);\n+                }\n+            }\n+        }\n+\n+        return new RealMatrixImpl(bp, false);\n+\n+    }\n+\n+    /**\n+     * Return the determinant of the matrix\n+     * @param decomposition decomposition of the matrix A\n+     * @return determinant of the matrix\n+     * @see #isNonSingular()\n+     */\n+    public double getDeterminant(final EigenDecomposition decomposition) {\n+        double determinant = 1;\n+        for (double lambda : decomposition.getEigenvalues()) {\n+            determinant *= lambda;\n+        }\n+        return determinant;\n+    }\n \n     /**\n      * Check if the decomposed matrix is non-singular.\n+     * @param decomposition decomposition of the matrix A\n      * @return true if the decomposed matrix is non-singular\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n-     */\n-    boolean isNonSingular() throws IllegalStateException;\n+     */\n+    public boolean isNonSingular(final EigenDecomposition decomposition) {\n+        for (double lambda : decomposition.getEigenvalues()) {\n+            if (lambda == 0) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n \n     /** Get the inverse of the decomposed matrix.\n+     * @param decomposition decomposition of the matrix A\n      * @return inverse matrix\n-     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n-     * has not been called\n      * @throws InvalidMatrixException if decomposed matrix is singular\n      */\n-    RealMatrix getInverse()\n-        throws IllegalStateException, InvalidMatrixException;\n+    public RealMatrix getInverse(final EigenDecomposition decomposition)\n+        throws InvalidMatrixException {\n+\n+        if (!isNonSingular(decomposition)) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        final double[] eigenvalues = decomposition.getEigenvalues();\n+        final int m = eigenvalues.length;\n+        final double[][] invData = new double[m][m];\n+\n+        for (int i = 0; i < m; ++i) {\n+            final double[] invI = invData[i];\n+            for (int j = 0; j < m; ++j) {\n+                double invIJ = 0;\n+                for (int k = 0; k < m; ++k) {\n+                    final RealVector vK = decomposition.getEigenvector(k);\n+                    invIJ += vK.getEntry(i) * vK.getEntry(j) / eigenvalues[k];\n+                }\n+                invI[j] = invIJ;\n+            }\n+        }\n+        return new RealMatrixImpl(invData, false);\n+\n+    }\n+\n+    /**\n+     * Decompose a matrix using singular value composition.\n+     * @exception InvalidMatrixException if matrix does not fulfill\n+     * the decomposition requirements (for example non-square matrix\n+     * for {@link LUDecomposition})\n+     */\n+    public SingularValueDecomposition singularDecompose()\n+        throws InvalidMatrixException {\n+        return new SingularValueDecompositionImpl(matrix);\n+    }\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @param decomposition decomposition of the matrix A\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public double[] solve(final double[] b, final SingularValueDecomposition decomposition)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        final double[] singularValues = decomposition.getSingularValues();\n+        if (b.length != singularValues.length) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+\n+        final double[] w = decomposition.getUT().operate(b);\n+        for (int i = 0; i < singularValues.length; ++i) {\n+            final double si = singularValues[i];\n+            if (si == 0) {\n+                throw new SingularMatrixException();\n+            }\n+            w[i] /= si;\n+        }\n+        return decomposition.getV().operate(w);\n+\n+    }\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @param decomposition decomposition of the matrix A\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealVector solve(final RealVector b, final SingularValueDecomposition decomposition)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        final double[] singularValues = decomposition.getSingularValues();\n+        if (b.getDimension() != singularValues.length) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+\n+        final RealVector w = decomposition.getUT().operate(b);\n+        for (int i = 0; i < singularValues.length; ++i) {\n+            final double si = singularValues[i];\n+            if (si == 0) {\n+                throw new SingularMatrixException();\n+            }\n+            w.set(i, w.getEntry(i) / si);\n+        }\n+        return decomposition.getV().operate(w);\n+\n+    }\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @param decomposition decomposition of the matrix A\n+     * @return a matrix X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealMatrix solve(final RealMatrix b, final SingularValueDecomposition decomposition)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        final double[] singularValues = decomposition.getSingularValues();\n+        if (b.getRowDimension() != singularValues.length) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+\n+        final RealMatrixImpl w = (RealMatrixImpl) decomposition.getUT().multiply(b);\n+        final double[][] wData = w.getDataRef();\n+        for (int i = 0; i < singularValues.length; ++i) {\n+            final double si  = singularValues[i];\n+            if (si == 0) {\n+                throw new SingularMatrixException();\n+            }\n+            final double inv = 1.0 / si;\n+            final double[] wi = wData[i];\n+            for (int j = 0; j < b.getColumnDimension(); ++j) {\n+                wi[j] *= inv;\n+            }\n+        }\n+        return decomposition.getV().multiply(w);\n+\n+    }\n+\n+    /**\n+     * Check if the decomposed matrix is non-singular.\n+     * @param decomposition decomposition of the matrix A\n+     * @return true if the decomposed matrix is non-singular\n+     */\n+    public boolean isNonSingular(final SingularValueDecomposition decomposition) {\n+        return decomposition.getRank() == decomposition.getSingularValues().length;\n+    }\n+\n+    /** Get the inverse of the decomposed matrix.\n+     * @param decomposition decomposition of the matrix A\n+     * @return inverse matrix\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealMatrix getInverse(final SingularValueDecomposition decomposition)\n+        throws InvalidMatrixException {\n+\n+        if (!isNonSingular(decomposition)) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        return solve(MatrixUtils.createRealIdentityMatrix(decomposition.getSingularValues().length),\n+                     decomposition);\n+\n+    }\n+\n+    /**\n+     * Decompose a matrix using QR decomposition.\n+     */\n+    public QRDecomposition qrDecompose() {\n+        return new QRDecompositionImpl(matrix);\n+    }\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @param decomposition decomposition of the matrix A\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public double[] solve(final double[] b, final QRDecomposition decomposition)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        if (decomposition.getR().getRowDimension() != b.length) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");            \n+        }\n+        if (!isNonSingular(decomposition)) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        // solve Q.y = b, using the fact Q is orthogonal\n+        final double[] y = decomposition.getQT().operate(b);\n+\n+        // solve triangular system R.x = y\n+        final RealMatrix r = decomposition.getR();\n+        final double[] x = new double[r.getColumnDimension()];\n+        System.arraycopy(y, 0, x, 0, r.getRowDimension());\n+        for (int i = r.getRowDimension() - 1; i >= 0; --i) {\n+            x[i] /= r.getEntry(i, i);\n+            final double lastX = x[i];\n+            for (int j = i - 1; j >= 0; --j) {\n+                x[j] -= lastX * r.getEntry(j, i);\n+            }\n+        }\n+\n+        return x;\n+\n+    }\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @param decomposition decomposition of the matrix A\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealVector solve(final RealVector b, final QRDecomposition decomposition)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+        return new RealVectorImpl(solve(b.getData(), decomposition), false);\n+    }\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @param decomposition decomposition of the matrix A\n+     * @return a matrix X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealMatrix solve(final RealMatrix b, final QRDecomposition decomposition)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        if (decomposition.getR().getRowDimension() != b.getRowDimension()) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");            \n+        }\n+        if (!isNonSingular(decomposition)) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        // solve Q.y = b, using the fact Q is orthogonal\n+        final RealMatrix y = decomposition.getQT().multiply(b);\n+\n+        // solve triangular system R.x = y\n+        final RealMatrix r = decomposition.getR();\n+        final double[][] xData =\n+            new double[r.getColumnDimension()][b.getColumnDimension()];\n+        for (int i = 0; i < r.getRowDimension(); ++i) {\n+            final double[] xi = xData[i];\n+            for (int k = 0; k < xi.length; ++k) {\n+                xi[k] = y.getEntry(i, k);\n+            }\n+        }\n+        for (int i = r.getRowDimension() - 1; i >= 0; --i) {\n+            final double rii = r.getEntry(i, i);\n+            final double[] xi = xData[i];\n+            for (int k = 0; k < xi.length; ++k) {\n+                xi[k] /= rii;\n+                final double lastX = xi[k];\n+                for (int j = i - 1; j >= 0; --j) {\n+                    xData[j][k] -= lastX * r.getEntry(j, i);\n+                }\n+            }\n+        }\n+\n+        return new RealMatrixImpl(xData, false);\n+\n+    }\n+\n+    /**\n+     * Check if the decomposed matrix is non-singular.\n+     * @param decomposition decomposition of the matrix A\n+     * @return true if the decomposed matrix is non-singular\n+     */\n+    public boolean isNonSingular(final QRDecomposition decomposition) {\n+        final RealMatrix r = decomposition.getR();\n+        final int p = Math.min(r.getRowDimension(), r.getColumnDimension());\n+        for (int i = 0; i < p; ++i) {\n+            if (r.getEntry(i, i) == 0) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /** Get the inverse of the decomposed matrix.\n+     * @param decomposition decomposition of the matrix A\n+     * @return inverse matrix\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealMatrix getInverse(final QRDecomposition decomposition)\n+        throws InvalidMatrixException {\n+        final RealMatrix r = decomposition.getR();\n+        final int p = Math.min(r.getRowDimension(), r.getColumnDimension());\n+        return solve(MatrixUtils.createRealIdentityMatrix(p), decomposition);\n+    }\n+\n+    /**\n+     * Decompose a matrix using LU decomposition.\n+     * @exception InvalidMatrixException if matrix is non-square)\n+     */\n+    public LUDecomposition luDecompose()\n+        throws InvalidMatrixException {\n+        return new LUDecompositionImpl(matrix);\n+    }\n+\n+    /**\n+     * Decompose a matrix using LU decomposition.\n+     * @param singularityThreshold threshold (based on partial row norm)\n+     * under which a matrix is considered singular\n+     * @exception InvalidMatrixException if matrix is non-square)\n+     */\n+    public LUDecomposition luDecompose(final double singularityThreshold)\n+        throws InvalidMatrixException {\n+        return new LUDecompositionImpl(matrix, singularityThreshold);\n+    }\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @param decomposition decomposition of the matrix A\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public double[] solve(final double[] b, final LUDecomposition decomposition)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        final int[] pivot = decomposition.getPivot();\n+        final int m = pivot.length;\n+        if (b.length != m) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+        if (decomposition.isSingular()) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        final double[] bp = new double[m];\n+\n+        // Apply permutations to b\n+        for (int row = 0; row < m; row++) {\n+            bp[row] = b[pivot[row]];\n+        }\n+\n+        // Solve LY = b\n+        final RealMatrix l = decomposition.getL();\n+        for (int col = 0; col < m; col++) {\n+            for (int i = col + 1; i < m; i++) {\n+                bp[i] -= bp[col] * l.getEntry(i, col);\n+            }\n+        }\n+\n+        // Solve UX = Y\n+        final RealMatrix u = decomposition.getU();\n+        for (int col = m - 1; col >= 0; col--) {\n+            bp[col] /= u.getEntry(col, col);\n+            for (int i = 0; i < col; i++) {\n+                bp[i] -= bp[col] * u.getEntry(i, col);\n+            }\n+        }\n+\n+        return bp;\n+\n+    }\n+\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @param decomposition decomposition of the matrix A\n+     * @return a vector X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealVector solve(final RealVector b, final LUDecomposition decomposition)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        final int[] pivot = decomposition.getPivot();\n+        final int m = pivot.length;\n+        if (b.getDimension() != m) {\n+            throw new IllegalArgumentException(\"constant vector has wrong length\");\n+        }\n+        if (decomposition.isSingular()) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        final double[] bp = new double[m];\n+\n+        // Apply permutations to b\n+        for (int row = 0; row < m; row++) {\n+            bp[row] = b.getEntry(pivot[row]);\n+        }\n+\n+        // Solve LY = b\n+        final RealMatrix l = decomposition.getL();\n+        for (int col = 0; col < m; col++) {\n+            for (int i = col + 1; i < m; i++) {\n+                bp[i] -= bp[col] * l.getEntry(i, col);\n+            }\n+        }\n+\n+        // Solve UX = Y\n+        final RealMatrix u = decomposition.getU();\n+        for (int col = m - 1; col >= 0; col--) {\n+            bp[col] /= u.getEntry(col, col);\n+            for (int i = 0; i < col; i++) {\n+                bp[i] -= bp[col] * u.getEntry(i, col);\n+            }\n+        }\n+\n+        return new RealVectorImpl(bp, false);\n+  \n+    }\n+\n+    /** Solve the linear equation A &times; X = B.\n+     * <p>The A matrix is implicit here. It <strong>must</strong> have\n+     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n+     * @param b right-hand side of the equation A &times; X = B\n+     * @param decomposition decomposition of the matrix A\n+     * @return a matrix X that minimizes the two norm of A &times; X - B\n+     * @exception IllegalArgumentException if matrices dimensions don't match\n+     * @exception InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealMatrix solve(final RealMatrix b, final LUDecomposition decomposition)\n+        throws IllegalArgumentException, InvalidMatrixException {\n+\n+        final int[] pivot = decomposition.getPivot();\n+        final int m = pivot.length;\n+        if (b.getRowDimension() != m) {\n+            throw new IllegalArgumentException(\"Incorrect row dimension\");\n+        }\n+        if (decomposition.isSingular()) {\n+            throw new SingularMatrixException();\n+        }\n+\n+        final int nColB = b.getColumnDimension();\n+\n+        // Apply permutations to b\n+        final double[][] bp = new double[m][nColB];\n+        for (int row = 0; row < m; row++) {\n+            final double[] bpRow = bp[row];\n+            final int pRow = pivot[row];\n+            for (int col = 0; col < nColB; col++) {\n+                bpRow[col] = b.getEntry(pRow, col);\n+            }\n+        }\n+\n+        // Solve LY = b\n+        final RealMatrix l = decomposition.getL();\n+        for (int col = 0; col < m; col++) {\n+            final double[] bpCol = bp[col];\n+            for (int i = col + 1; i < m; i++) {\n+                final double[] bpI = bp[i];\n+                final double luICol = l.getEntry(i, col);\n+                for (int j = 0; j < nColB; j++) {\n+                    bpI[j] -= bpCol[j] * luICol;\n+                }\n+            }\n+        }\n+\n+        // Solve UX = Y\n+        final RealMatrix u = decomposition.getU();\n+        for (int col = m - 1; col >= 0; col--) {\n+            final double[] bpCol = bp[col];\n+            final double luDiag = u.getEntry(col, col);\n+            for (int j = 0; j < nColB; j++) {\n+                bpCol[j] /= luDiag;\n+            }\n+            for (int i = 0; i < col; i++) {\n+                final double[] bpI = bp[i];\n+                final double luICol = u.getEntry(i, col);\n+                for (int j = 0; j < nColB; j++) {\n+                    bpI[j] -= bpCol[j] * luICol;\n+                }\n+            }\n+        }\n+\n+        return new RealMatrixImpl(bp, false);\n+\n+    }\n+\n+\n+    /**\n+     * Return the determinant of the matrix\n+     * @param decomposition decomposition of the matrix A\n+     * @return determinant of the matrix\n+     * @see #isNonSingular()\n+     */\n+    public double getDeterminant(final LUDecomposition decomposition) {\n+        if (decomposition.isSingular()) {\n+            return 0;\n+        } else {\n+            final int m = decomposition.getPivot().length;\n+            final RealMatrix u = decomposition.getU();\n+            double determinant = decomposition.evenPermutation() ? 1 : -1;\n+            for (int i = 0; i < m; i++) {\n+                determinant *= u.getEntry(i, i);\n+            }\n+            return determinant;\n+        }\n+    }\n+\n+    /**\n+     * Check if the decomposed matrix is non-singular.\n+     * @param decomposition decomposition of the matrix A\n+     * @return true if the decomposed matrix is non-singular\n+     */\n+    public boolean isNonSingular(final LUDecomposition decomposition) {\n+        return !decomposition.isSingular();\n+    }\n+\n+    /** Get the inverse of the decomposed matrix.\n+     * @param decomposition decomposition of the matrix A\n+     * @return inverse matrix\n+     * @throws InvalidMatrixException if decomposed matrix is singular\n+     */\n+    public RealMatrix getInverse(final LUDecomposition decomposition)\n+        throws InvalidMatrixException {\n+        final int m = decomposition.getPivot().length;\n+        return solve(MatrixUtils.createRealIdentityMatrix(m), decomposition);\n+    }\n \n }\n--- a/src/java/org/apache/commons/math/linear/EigenDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/EigenDecomposition.java\n  */\n \n package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n \n /**\n  * An interface to classes that implement an algorithm to calculate the \n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public interface EigenDecomposition extends DecompositionSolver {\n+public interface EigenDecomposition extends Serializable {\n \n     /**\n      * Returns the matrix V of the decomposition. \n      * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n      * <p>The columns of V are the eigenvectors of the original matrix.</p>\n      * @return the V matrix\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    RealMatrix getV() throws IllegalStateException;\n+    RealMatrix getV();\n \n     /**\n      * Returns the diagonal matrix D of the decomposition. \n      * <p>D is a diagonal matrix.</p>\n      * <p>The values on the diagonal are the eigenvalues of the original matrix.</p>\n      * @return the D matrix\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      * @see #getEigenValues()\n      */\n-    RealMatrix getD() throws IllegalStateException;\n+    RealMatrix getD();\n \n     /**\n      * Returns the transpose of the matrix V of the decomposition. \n      * <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p>\n      * <p>The columns of V are the eigenvectors of the original matrix.</p>\n      * @return the transpose of the V matrix\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      */\n-    RealMatrix getVT() throws IllegalStateException;\n+    RealMatrix getVT();\n \n     /**\n      * Returns a copy of the eigenvalues of the original matrix.\n      * @return a copy of the eigenvalues of the original matrix\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      * @see #getD()\n      */\n-    double[] getEigenvalues() throws IllegalStateException;\n+    double[] getEigenvalues();\n \n     /**\n      * Returns the i<sup>th</sup> eigenvalue of the original matrix.\n      * @param i index of the eigenvalue (counting from 0)\n      * @return i<sup>th</sup> eigenvalue of the original matrix\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n-     * @exception ArrayIndexOutOfBoundsException if i is not\n      * @see #getD()\n      */\n-    double getEigenvalue(int i) throws IllegalStateException;\n+    double getEigenvalue(int i);\n \n     /**\n      * Returns a copy of the i<sup>th</sup> eigenvector of the original matrix.\n      * @param i index of the eigenvector (counting from 0)\n      * @return copy of the i<sup>th</sup> eigenvector of the original matrix\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n      * @see #getD()\n      */\n-    RealVector getEigenvector(int i) throws IllegalStateException;\n-\n-    /**\n-     * Return the determinant of the matrix\n-     * @return determinant of the matrix\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n-     * @see #isNonSingular()\n-     */\n-    double getDeterminant() throws IllegalStateException;\n+    RealVector getEigenvector(int i);\n \n }\n--- a/src/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n import java.util.List;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.util.MathUtils;\n \n public class EigenDecompositionImpl implements EigenDecomposition {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -4976315828448620858L;\n+    private static final long serialVersionUID = 3125911889630623276L;\n \n     /** Tolerance. */\n     private static final double TOLERANCE = 100 * MathUtils.EPSILON;\n \n     /** Cached value of Vt. */\n     private RealMatrix cachedVt;\n-\n-    /**\n-     * Build a new instance.\n-     * <p>Note that {@link #decompose(RealMatrix)} <strong>must</strong> be called\n-     * before any of the {@link #getV()}, {@link #getD()}, {@link #getVT()},\n-     * {@link #getEignevalues()}, {@link #solve(double[])}, {@link #solve(RealMatrix)},\n-     * {@link #solve(RealVector)} or {@link #solve(RealVectorImpl)} methods can be\n-     * called.</p>\n-     * @see #decompose(RealMatrix)\n-     */\n-    public EigenDecompositionImpl() {\n-        setRelativeAccuracySplitTolerance(MathUtils.SAFE_MIN);\n-    }\n \n     /**\n      * Calculates the eigen decomposition of the given symmetric matrix. \n      * <p>The specified matrix is assumed to be symmetrical without any check.\n      * Only the upper triangular part of the matrix is used.</p>\n      * @param matrix The <strong>symmetric</strong> matrix to decompose.\n+     * @param splitTolerance tolerance on the off-diagonal elements relative to the\n+     * geometric mean to split the tridiagonal matrix (a suggested value is\n+     * {@link MathUtils#SAFE_MIN})\n      * @exception InvalidMatrixException (wrapping a {@link ConvergenceException}\n      * if algorithm fails to converge\n      */\n-    public EigenDecompositionImpl(final RealMatrix matrix)\n+    public EigenDecompositionImpl(final RealMatrix matrix,\n+                                  final double splitTolerance)\n         throws InvalidMatrixException {\n-        setRelativeAccuracySplitTolerance(MathUtils.SAFE_MIN);\n-        decompose(matrix);\n+        this.splitTolerance = splitTolerance;\n+        transformToTridiagonal(matrix);\n+        decompose();\n     }\n \n     /**\n      * constructor and then call {@link #decompose(double[], double[])}.</p>\n      * @param main the main diagonal of the matrix\n      * @param secondary the secondary diagonal of the matrix\n+     * @param splitTolerance tolerance on the off-diagonal elements relative to the\n+     * geometric mean to split the tridiagonal matrix (a suggested value is\n+     * {@link MathUtils#SAFE_MIN})\n      * @exception InvalidMatrixException (wrapping a {@link ConvergenceException}\n      * if algorithm fails to converge\n      */\n-    public EigenDecompositionImpl(final double[] main, double[] secondary)\n+    public EigenDecompositionImpl(final double[] main, double[] secondary,\n+            final double splitTolerance)\n         throws InvalidMatrixException {\n-        setRelativeAccuracySplitTolerance(MathUtils.SAFE_MIN);\n-        decompose(main, secondary);\n-    }\n-\n-    /**\n-     * Set split tolerance based on absolute off-diagonal elements.\n-     * @param tolerance tolerance to set\n-     */\n-    public void setAbsoluteSplitTolerance(final double tolerance) {\n-        splitTolerance = -Math.abs(tolerance);\n-    }\n-\n-    /**\n-     * Set split tolerance preserving relative accuracy.\n-     * @param tolerance tolerance to set\n-     */\n-    public void setRelativeAccuracySplitTolerance(final double tolerance) {\n-        splitTolerance = Math.abs(tolerance);\n-    }\n-\n-    /**\n-     * Decompose a <strong>symmetric</strong> matrix.\n-     * <p>The specified matrix is assumed to be symmetrical without any check.\n-     * Only the upper triangular part of the matrix is used.</p>\n-     * @param matrix symmetric matrix to decompose\n-     * @exception InvalidMatrixException if matrix cannot be diagonalized\n-     */\n-    public void decompose(final RealMatrix matrix)\n-        throws InvalidMatrixException {\n-        transformToTridiagonal(matrix);\n-        decompose();\n-    }\n-\n-    /**\n-     * Decompose a tridiagonal symmetric matrix. \n-     * @param main the main diagonal of the matrix\n-     * @param secondary the secondary diagonal of the matrix\n-     * @exception InvalidMatrixException (wrapping a {@link ConvergenceException}\n-     * if algorithm fails to converge\n-     */\n-    public void decompose(final double[] main, final double[] secondary) {\n \n         this.main      = main;\n         this.secondary = secondary;\n             squaredSecondary[i] = s * s;\n         }\n \n+        this.splitTolerance = splitTolerance;\n         decompose();\n \n     }\n \n         if (cachedD == null) {\n \n-            checkDecomposed();\n-\n             final int m = eigenvalues.length;\n             final double[][] sData = new double[m][m];\n             for (int i = 0; i < m; ++i) {\n \n         if (cachedVt == null) {\n \n-            checkDecomposed();\n             if (eigenvectors == null) {\n                 findEigenVectors();\n             }\n     /** {@inheritDoc} */\n     public double[] getEigenvalues()\n         throws InvalidMatrixException {\n-        checkDecomposed();\n         return eigenvalues.clone();\n     }\n \n     /** {@inheritDoc} */\n     public double getEigenvalue(final int i)\n         throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n-        checkDecomposed();\n         return eigenvalues[i];\n     }\n \n     /** {@inheritDoc} */\n     public RealVector getEigenvector(final int i)\n         throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n-        checkDecomposed();\n         if (eigenvectors == null) {\n             findEigenVectors();\n         }\n         return eigenvectors[i].copy();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public boolean isNonSingular()\n-        throws IllegalStateException {\n-        for (double lambda : eigenvalues) {\n-            if (lambda == 0) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double[] solve(final double[] b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-\n-        checkNonSingular();\n-\n-        final int m = eigenvalues.length;\n-        if (b.length != m) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");\n-        }\n-\n-        if (eigenvectors == null) {\n-            findEigenVectors();\n-        }\n-\n-        final double[] bp = new double[m];\n-        for (int i = 0; i < m; ++i) {\n-            final RealVectorImpl v = eigenvectors[i];\n-            final double s = v.dotProduct(b) / eigenvalues[i];\n-            final double[] vData = v.getDataRef();\n-            for (int j = 0; j < m; ++j) {\n-                bp[j] += s * vData[j];\n-            }\n-        }\n-\n-        return bp;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector solve(final RealVector b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-        try {\n-            return solve((RealVectorImpl) b);\n-        } catch (ClassCastException cce) {\n-\n-            checkNonSingular();\n-\n-            final int m = eigenvalues.length;\n-            if (b.getDimension() != m) {\n-                throw new IllegalArgumentException(\"constant vector has wrong length\");\n-            }\n-\n-            if (eigenvectors == null) {\n-                findEigenVectors();\n-            }\n-\n-            final double[] bp = new double[m];\n-            for (int i = 0; i < m; ++i) {\n-                final RealVectorImpl v = eigenvectors[i];\n-                final double s = v.dotProduct(b) / eigenvalues[i];\n-                final double[] vData = v.getDataRef();\n-                for (int j = 0; j < m; ++j) {\n-                    bp[j] += s * vData[j];\n-                }\n-            }\n-\n-            return new RealVectorImpl(bp, false);\n-\n-        }\n-    }\n-\n-    /**\n-     * Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It <strong>must</strong> have\n-     * already been provided by a previous call to {@link #decompose(RealMatrix)}.</p>\n-     * @param b right-hand side of the equation A &times; X = B\n-     * @return a vector X such that A &times; X = B\n-     * @throws IllegalArgumentException if matrices dimensions don't match\n-     * @throws InvalidMatrixException if decomposed matrix is singular\n-     */\n-    public RealVectorImpl solve(final RealVectorImpl b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-        return new RealVectorImpl(solve(b.getDataRef()), false);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealMatrix solve(final RealMatrix b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-\n-        checkNonSingular();\n-\n-        final int m = eigenvalues.length;\n-        if (b.getRowDimension() != m) {\n-            throw new IllegalArgumentException(\"Incorrect row dimension\");\n-        }\n-\n-        if (eigenvectors == null) {\n-            findEigenVectors();\n-        }\n-\n-        final int nColB = b.getColumnDimension();\n-        final double[][] bp = new double[m][nColB];\n-        for (int k = 0; k < nColB; ++k) {\n-            for (int i = 0; i < m; ++i) {\n-                final double[] vData = eigenvectors[i].getDataRef();\n-                double s = 0;\n-                for (int j = 0; j < m; ++j) {\n-                    s += vData[j] * b.getEntry(j, k);\n-                }\n-                s /= eigenvalues[i];\n-                for (int j = 0; j < m; ++j) {\n-                    bp[j][k] += s * vData[j];\n-                }\n-            }\n-        }\n-\n-        return new RealMatrixImpl(bp, false);\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealMatrix getInverse()\n-        throws IllegalStateException, InvalidMatrixException {\n-\n-        checkNonSingular();\n-        final int m = eigenvalues.length;\n-        final double[][] invData = new double[m][m];\n-\n-        if (eigenvectors == null) {\n-            findEigenVectors();\n-        }\n-\n-        for (int i = 0; i < m; ++i) {\n-            final double[] invI = invData[i];\n-            for (int j = 0; j < m; ++j) {\n-                double invIJ = 0;\n-                for (int k = 0; k < m; ++k) {\n-                    final double[] vK = eigenvectors[k].getDataRef();\n-                    invIJ += vK[i] * vK[j] / eigenvalues[k];\n-                }\n-                invI[j] = invIJ;\n-            }\n-        }\n-        return new RealMatrixImpl(invData, false);\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getDeterminant()\n-        throws IllegalStateException {\n-        double determinant = 1;\n-        for (double lambda : eigenvalues) {\n-            determinant *= lambda;\n-        }\n-        return determinant;\n     }\n \n     /**\n \n         final List<Integer> list = new ArrayList<Integer>();\n \n-        if (splitTolerance < 0) {\n-            // splitting based on absolute off-diagonal value\n-            final double max = Math.abs(splitTolerance) * (upperSpectra - lowerSpectra);\n-            for (int i = 0; i < secondary.length; ++i) {\n-                if (Math.abs(secondary[i]) <= max) {\n-                    list.add(i + 1);\n-                    secondary[i] = 0;\n-                    squaredSecondary[i] = 0;\n-                }\n-            }\n-        } else {\n-            // splitting preserving relative accuracy\n-            double absDCurrent = Math.abs(0);\n-            for (int i = 0; i < secondary.length; ++i) {\n-                final double absDPrevious = absDCurrent;\n-                absDCurrent = Math.abs(i + 1);\n-                final double max = splitTolerance * Math.sqrt(absDPrevious * absDCurrent);\n-                if (Math.abs(secondary[i]) <= max) {\n-                    list.add(i + 1);\n-                    secondary[i] = 0;\n-                    squaredSecondary[i] = 0;\n-                }\n-            }            \n+        // splitting preserving relative accuracy\n+        double absDCurrent = Math.abs(main[0]);\n+        for (int i = 0; i < secondary.length; ++i) {\n+            final double absDPrevious = absDCurrent;\n+            absDCurrent = Math.abs(main[i + 1]);\n+            final double max = splitTolerance * Math.sqrt(absDPrevious * absDCurrent);\n+            if (Math.abs(secondary[i]) <= max) {\n+                list.add(i + 1);\n+                secondary[i] = 0;\n+                squaredSecondary[i] = 0;\n+            }\n         }\n \n         list.add(secondary.length + 1);\n         work[4] = pi;\n     }\n \n-    /**\n-     * Check if decomposition has been performed.\n-     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n-     * has not been called\n-     */\n-    private void checkDecomposed()\n-        throws IllegalStateException {\n-        if (eigenvalues == null) {\n-            throw MathRuntimeException.createIllegalStateException(\"no matrix have been decomposed yet\", null);\n-        }\n-    }\n-\n-    /**\n-     * Check if decomposed matrix is non singular.\n-     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n-     * has not been called\n-     * @exception SingularMatrixException if decomposed matrix is singular\n-     */\n-    private void checkNonSingular()\n-        throws IllegalStateException, SingularMatrixException {\n-        checkDecomposed();\n-        if (!isNonSingular()) {\n-            throw new SingularMatrixException();\n-        }\n-    }\n-\n }\n--- a/src/java/org/apache/commons/math/linear/LUDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/LUDecomposition.java\n  */\n \n package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n \n /**\n  * An interface to classes that implement an algorithm to calculate the \n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public interface LUDecomposition extends DecompositionSolver {\n+public interface LUDecomposition extends Serializable {\n \n     /**\n      * Computes a new\n     int[] getPivot() throws IllegalStateException;\n \n     /**\n-     * Return the determinant of the matrix\n-     * @return determinant of the matrix\n-     * @exception IllegalStateException if {@link\n-     * DecompositionSolver#decompose(RealMatrix) decompose} has not been called\n-     * @see #isNonSingular()\n+     * Get permutation parity.\n+     * @return true if there was an even number of permutations\n      */\n-    double getDeterminant() throws IllegalStateException;\n+    boolean evenPermutation();\n+\n+    /**\n+     * Get the singularity indicator.\n+     * @return singularity indicator\n+     */\n+    public boolean isSingular();\n \n }\n--- a/src/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n \n package org.apache.commons.math.linear;\n \n-import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * Calculates the LUP-decomposition of a square matrix.\n     private int[] pivot;\n \n     /** Parity of the permutation associated with the LU decomposition */\n-    private int parity;\n+    private boolean even;\n \n     /** Singularity indicator. */\n     private boolean singular;\n \n     /** Default bound to determine effective singularity in LU decomposition */\n     private static final double DEFAULT_TOO_SMALL = 10E-12;\n-\n-    /**\n-     * Build a new instance.\n-     * <p>Note that either {@link #decompose(RealMatrix)} or\n-     * {@link #decompose(RealMatrix, double)} <strong>must</strong> be called\n-     * before any of the {@link #getP()}, {@link #getPivot()}, {@link #getL()},\n-     * {@link #getU()}, {@link #getDeterminant()}, {@link #isNonSingular()},\n-     * {@link #solve(double[])}, {@link #solve(RealMatrix)}, {@link #solve(RealVector)}\n-     * or {@link #solve(RealVectorImpl)} methods can be called.</p>\n-     * @see #decompose(RealMatrix)\n-     * @see #decompose(RealMatrix, double)\n-     */\n-    public LUDecompositionImpl() {\n-    }\n \n     /**\n      * Calculates the LU-decomposition of the given matrix. \n         for (int row = 0; row < m; row++) {\n             pivot[row] = row;\n         }\n-        parity = 1;\n+        even     = true;\n         singular = false;\n \n         // Loop over columns\n                 int temp = pivot[max];\n                 pivot[max] = pivot[col];\n                 pivot[col] = temp;\n-                parity = -parity;\n+                even = !even;\n             }\n \n             // Divide the lower elements by the \"winning\" diagonal elt.\n     /** {@inheritDoc} */\n     public RealMatrix getL()\n         throws IllegalStateException {\n-        checkDecomposed();\n         if ((cachedL == null) && !singular) {\n             final int m = pivot.length;\n             final double[][] lData = new double[m][m];\n     /** {@inheritDoc} */\n     public RealMatrix getU()\n         throws IllegalStateException {\n-        checkDecomposed();\n         if ((cachedU == null) && !singular) {\n             final int m = pivot.length;\n             final double[][] uData = new double[m][m];\n     /** {@inheritDoc} */\n     public RealMatrix getP()\n         throws IllegalStateException {\n-        checkDecomposed();\n         if ((cachedP == null) && !singular) {\n             final int m = pivot.length;\n             final double[][] pData = new double[m][m];\n     /** {@inheritDoc} */\n     public int[] getPivot()\n         throws IllegalStateException {\n-        checkDecomposed();\n-        return pivot.clone();\n-    }\n-\n-    /** {@inheritDoc} */\n-    public boolean isNonSingular()\n-        throws IllegalStateException {\n-        checkDecomposed();\n-        return !singular;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double getDeterminant()\n-        throws IllegalStateException {\n-        checkDecomposed();\n-        if (singular) {\n-            return 0;\n-        } else {\n-            final int m = pivot.length;\n-            double determinant = parity;\n-            for (int i = 0; i < m; i++) {\n-                determinant *= lu[i][i];\n-            }\n-            return determinant;\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double[] solve(double[] b)\n-        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n-\n-        checkDecomposed();\n-        final int m = pivot.length;\n-        if (b.length != m) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");\n-        }\n-        if (singular) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        final double[] bp = new double[m];\n-\n-        // Apply permutations to b\n-        for (int row = 0; row < m; row++) {\n-            bp[row] = b[pivot[row]];\n-        }\n-\n-        // Solve LY = b\n-        for (int col = 0; col < m; col++) {\n-            for (int i = col + 1; i < m; i++) {\n-                bp[i] -= bp[col] * lu[i][col];\n-            }\n-        }\n-\n-        // Solve UX = Y\n-        for (int col = m - 1; col >= 0; col--) {\n-            bp[col] /= lu[col][col];\n-            for (int i = 0; i < col; i++) {\n-                bp[i] -= bp[col] * lu[i][col];\n-            }\n-        }\n-\n-        return bp;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector solve(RealVector b)\n-        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n-        try {\n-            return solve((RealVectorImpl) b);\n-        } catch (ClassCastException cce) {\n-\n-            checkDecomposed();\n-            final int m = pivot.length;\n-            if (b.getDimension() != m) {\n-                throw new IllegalArgumentException(\"constant vector has wrong length\");\n-            }\n-            if (singular) {\n-                throw new SingularMatrixException();\n-            }\n-\n-            final double[] bp = new double[m];\n-\n-            // Apply permutations to b\n-            for (int row = 0; row < m; row++) {\n-                bp[row] = b.getEntry(pivot[row]);\n-            }\n-\n-            // Solve LY = b\n-            for (int col = 0; col < m; col++) {\n-                for (int i = col + 1; i < m; i++) {\n-                    bp[i] -= bp[col] * lu[i][col];\n-                }\n-            }\n-\n-            // Solve UX = Y\n-            for (int col = m - 1; col >= 0; col--) {\n-                bp[col] /= lu[col][col];\n-                for (int i = 0; i < col; i++) {\n-                    bp[i] -= bp[col] * lu[i][col];\n-                }\n-            }\n-\n-            return new RealVectorImpl(bp, false);\n-\n-        }\n-    }\n-\n-    /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It is </p>\n-     * @param b right-hand side of the equation A &times; X = B\n-     * @return a vector X such that A &times; X = B\n-     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n-     * has not been called\n-     * @exception IllegalArgumentException if matrices dimensions don't match\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n-     */\n-    public RealVectorImpl solve(RealVectorImpl b)\n-        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n-        return new RealVectorImpl(solve(b.getDataRef()), false);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealMatrix solve(RealMatrix b)\n-        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n-\n-        checkDecomposed();\n-        final int m = pivot.length;\n-        if (b.getRowDimension() != m) {\n-            throw new IllegalArgumentException(\"Incorrect row dimension\");\n-        }\n-        if (singular) {\n-            throw new SingularMatrixException();\n-        }\n-\n-        final int nColB = b.getColumnDimension();\n-\n-        // Apply permutations to b\n-        final double[][] bp = new double[m][nColB];\n-        for (int row = 0; row < m; row++) {\n-            final double[] bpRow = bp[row];\n-            final int pRow = pivot[row];\n-            for (int col = 0; col < nColB; col++) {\n-                bpRow[col] = b.getEntry(pRow, col);\n-            }\n-        }\n-\n-        // Solve LY = b\n-        for (int col = 0; col < m; col++) {\n-            final double[] bpCol = bp[col];\n-            for (int i = col + 1; i < m; i++) {\n-                final double[] bpI = bp[i];\n-                final double luICol = lu[i][col];\n-                for (int j = 0; j < nColB; j++) {\n-                    bpI[j] -= bpCol[j] * luICol;\n-                }\n-            }\n-        }\n-\n-        // Solve UX = Y\n-        for (int col = m - 1; col >= 0; col--) {\n-            final double[] bpCol = bp[col];\n-            final double luDiag = lu[col][col];\n-            for (int j = 0; j < nColB; j++) {\n-                bpCol[j] /= luDiag;\n-            }\n-            for (int i = 0; i < col; i++) {\n-                final double[] bpI = bp[i];\n-                final double luICol = lu[i][col];\n-                for (int j = 0; j < nColB; j++) {\n-                    bpI[j] -= bpCol[j] * luICol;\n-                }\n-            }\n-        }\n-\n-        return new RealMatrixImpl(bp, false);\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealMatrix getInverse()\n-        throws IllegalStateException, InvalidMatrixException {\n-        checkDecomposed();\n-        return solve(MatrixUtils.createRealIdentityMatrix(pivot.length));\n-    }\n-\n-    /**\n-     * Check if either {@link #decompose(RealMatrix)} or {@link\n-     * #decompose(RealMatrix, double) has been called.\n-     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n-     * has not been called\n-     */\n-    private void checkDecomposed()\n-        throws IllegalStateException {\n-        if (lu == null) {\n-            throw MathRuntimeException.createIllegalStateException(\"no matrix have been decomposed yet\", null);\n-        }\n+        return pivot;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean evenPermutation() {\n+        return even;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public boolean isSingular()\n+        throws IllegalStateException {\n+        return singular;\n     }\n \n }\n--- a/src/java/org/apache/commons/math/linear/QRDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecomposition.java\n  */\n \n package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n \n /**\n  * An interface to classes that implement an algorithm to calculate the \n  * @version $Revision$ $Date$\n  * @since 1.2\n  */\n-public interface QRDecomposition extends DecompositionSolver {\n+public interface QRDecomposition extends Serializable {\n \n     /**\n      * Returns the matrix R of the decomposition. \n--- a/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n \n package org.apache.commons.math.linear;\n \n-import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * Calculates the QR-decomposition of a matrix.\n public class QRDecompositionImpl implements QRDecomposition {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -5179446891802932307L;\n+    private static final long serialVersionUID = 3107050419319784520L;\n \n     /**\n      * A packed TRANSPOSED representation of the QR decomposition.\n     private RealMatrix cachedH;\n \n     /**\n-     * Build a new instance.\n-     * <p>Note that {@link #decompose(RealMatrix)} <strong>must</strong> be called\n-     * before any of the {@link #getQ()}, {@link #getR()}, {@link #getH()},\n-     * {@link #isFullRank()}, {@link #solve(double[])}, {@link #solve(RealMatrix)},\n-     * {@link #solve(RealVector)} or {@link #solve(RealVectorImpl)} methods can be\n-     * called.</p>\n-     * @see #decompose(RealMatrix)\n-     */\n-    public QRDecompositionImpl() {\n-    }\n-\n-    /**\n      * Calculates the QR-decomposition of the given matrix. \n      * <p>Calling this constructor is equivalent to first call the no-arguments\n      * constructor and then call {@link #decompose(RealMatrix)}.</p>\n      * @param matrix The matrix to decompose.\n      */\n     public QRDecompositionImpl(RealMatrix matrix) {\n-        decompose(matrix);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void decompose(RealMatrix matrix) {\n \n         final int m = matrix.getRowDimension();\n         final int n = matrix.getColumnDimension();\n \n         if (cachedR == null) {\n \n-            checkDecomposed();\n-\n             // R is supposed to be m x n\n             final int n = qrt.length;\n             final int m = qrt[0].length;\n         throws IllegalStateException {\n \n         if (cachedQT == null) {\n-\n-            checkDecomposed();\n \n             // QT is supposed to be m x m\n             final int n = qrt.length;\n \n         if (cachedH == null) {\n \n-            checkDecomposed();\n-\n             final int n = qrt.length;\n             final int m = qrt[0].length;\n             double[][] hData = new double[m][n];\n \n     }\n \n-    /** {@inheritDoc} */\n-    public boolean isNonSingular()\n-        throws IllegalStateException {\n-\n-        checkDecomposed();\n-\n-        for (double diag : rDiag) {\n-            if (diag == 0) {\n-                return false;\n-            }\n-        }\n-        return true;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double[] solve(double[] b)\n-        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n- \n-        checkDecomposed();\n-\n-        final int n = qrt.length;\n-        final int m = qrt[0].length;\n-        if (b.length != m) {\n-            throw new IllegalArgumentException(\"Incorrect row dimension\");\n-        }\n-        if (!isNonSingular()) {\n-            throw new RankDeficientMatrixException();\n-        }\n-\n-        final double[] x = new double[n];\n-        final double[] y = b.clone();\n-\n-        // apply Householder transforms to solve Q.y = b\n-        for (int minor = 0; minor < Math.min(m, n); minor++) {\n-\n-            final double[] qrtMinor = qrt[minor];\n-            double dotProduct = 0;\n-            for (int row = minor; row < m; row++) {\n-                dotProduct += y[row] * qrtMinor[row];\n-            }\n-            dotProduct /= rDiag[minor] * qrtMinor[minor];\n-\n-            for (int row = minor; row < m; row++) {\n-                y[row] += dotProduct * qrtMinor[row];\n-            }\n-\n-        }\n-\n-        // solve triangular system R.x = y\n-        for (int row = n - 1; row >= 0; --row) {\n-            y[row] /= rDiag[row];\n-            final double yRow   = y[row];\n-            final double[] qrtRow = qrt[row];\n-            x[row] = yRow;\n-            for (int i = 0; i < row; i++) {\n-                y[i] -= yRow * qrtRow[i];\n-            }\n-        }\n-\n-        return x;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector solve(RealVector b)\n-        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n-        try {\n-            return solve((RealVectorImpl) b);\n-        } catch (ClassCastException cce) {\n-            checkDecomposed();\n-            return new RealVectorImpl(solve(b.getData()), false);\n-        }\n-    }\n-\n-    /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It is </p>\n-     * @param b right-hand side of the equation A &times; X = B\n-     * @return a vector X that minimizes the two norm of A &times; X - B\n-     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n-     * has not been called\n-     * @throws IllegalArgumentException if matrices dimensions don't match\n-     * @throws InvalidMatrixException if decomposed matrix is singular\n-     */\n-    public RealVectorImpl solve(RealVectorImpl b)\n-        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n-        return new RealVectorImpl(solve(b.getDataRef()), false);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealMatrix solve(RealMatrix b)\n-        throws IllegalStateException, IllegalArgumentException, InvalidMatrixException {\n-\n-        checkDecomposed();\n-\n-        final int n = qrt.length;\n-        final int m = qrt[0].length;\n-        if (b.getRowDimension() != m) {\n-            throw new IllegalArgumentException(\"Incorrect row dimension\");\n-        }\n-        if (!isNonSingular()) {\n-            throw new RankDeficientMatrixException();\n-        }\n-\n-        final int cols = b.getColumnDimension();\n-        final double[][] xData = new double[n][cols];\n-        final double[] y = new double[b.getRowDimension()];\n-\n-        for (int k = 0; k < cols; ++k) {\n-\n-            // get the right hand side vector\n-            for (int j = 0; j < y.length; ++j) {\n-                y[j] = b.getEntry(j, k);\n-            }\n-\n-            // apply Householder transforms to solve Q.y = b\n-            for (int minor = 0; minor < Math.min(m, n); minor++) {\n-\n-                final double[] qrtMinor = qrt[minor];\n-                double dotProduct = 0;\n-                for (int row = minor; row < m; row++) {\n-                    dotProduct += y[row] * qrtMinor[row];\n-                }\n-                dotProduct /= rDiag[minor] * qrtMinor[minor];\n-\n-                for (int row = minor; row < m; row++) {\n-                    y[row] += dotProduct * qrtMinor[row];\n-                }\n-\n-            }\n-\n-            // solve triangular system R.x = y\n-            for (int row = n - 1; row >= 0; --row) {\n-                y[row] /= rDiag[row];\n-                final double yRow = y[row];\n-                final double[] qrtRow = qrt[row];\n-                xData[row][k] = yRow;\n-                for (int i = 0; i < row; i++) {\n-                   y[i] -= yRow * qrtRow[i];\n-                }\n-             }\n-\n-        }\n-\n-        return new RealMatrixImpl(xData, false);\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealMatrix getInverse()\n-        throws IllegalStateException, InvalidMatrixException {\n-        checkDecomposed();\n-        return solve(MatrixUtils.createRealIdentityMatrix(rDiag.length));\n-    }\n-\n-    /**\n-     * Check if {@link #decompose(RealMatrix)} has been called.\n-     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n-     * has not been called\n-     */\n-    private void checkDecomposed()\n-        throws IllegalStateException {\n-        if (qrt == null) {\n-            throw MathRuntimeException.createIllegalStateException(\"no matrix have been decomposed yet\", null);\n-        }\n-    }\n-\n }\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n     /** Entries of the matrix */\n     protected double data[][];\n \n+    /** Cached decomposition solver.\n+     * @deprecated as of release 2.0, since all methods using this are deprecated\n+     */\n+    private DecompositionSolver ds;\n+\n     /** Cached LU decomposition.\n      * @deprecated as of release 2.0, since all methods using this are deprecated\n      */\n                     \"row and column dimensions must be postive\");\n         }\n         data = new double[rowDimension][columnDimension];\n-        lu = null;\n+        ds = null;\n     }\n \n     /**\n      */\n     public RealMatrixImpl(double[][] d) {\n         copyIn(d);\n-        lu = null;\n+        ds = null;\n     }\n \n     /**\n             }       \n             data = d;\n         }\n-        lu = null;\n+        ds = null;\n     }\n \n     /**\n             System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);\n         } \n \n-        lu = null;\n+        ds = null;\n \n     }\n \n     /** {@inheritDoc} */\n     @Deprecated\n     public RealMatrix inverse() throws InvalidMatrixException {\n-        if (lu == null) {\n-            lu = new LUDecompositionImpl(this);\n-        }\n-        return lu.getInverse();\n+        if (ds == null) {\n+            ds = new DecompositionSolver(this);\n+            lu = ds.luDecompose(MathUtils.SAFE_MIN);\n+        }\n+        return ds.getInverse(lu);\n     }\n \n     /** {@inheritDoc} */\n     @Deprecated\n     public double getDeterminant() throws InvalidMatrixException {\n-        if (lu == null) {\n-            lu = new LUDecompositionImpl(this);\n-        }\n-        return lu.getDeterminant();\n+        if (ds == null) {\n+            ds = new DecompositionSolver(this);\n+            lu = ds.luDecompose(MathUtils.SAFE_MIN);\n+        }\n+        return ds.getDeterminant(lu);\n     }\n \n     /** {@inheritDoc} */\n     /** {@inheritDoc} */\n     @Deprecated\n     public boolean isSingular() {\n-        if (lu == null) {\n-            lu = new LUDecompositionImpl(this);\n-        }\n-        return !lu.isNonSingular();\n+        if (ds == null) {\n+            ds = new DecompositionSolver(this);\n+            lu = ds.luDecompose(MathUtils.SAFE_MIN);\n+        }\n+        return !ds.isNonSingular(lu);\n     }\n \n     /** {@inheritDoc} */\n     /** {@inheritDoc} */\n     @Deprecated\n     public double[] solve(double[] b) throws IllegalArgumentException, InvalidMatrixException {\n-        if (lu == null) {\n-            lu = new LUDecompositionImpl(this);\n-        }\n-        return lu.solve(b);\n+        if (ds == null) {\n+            ds = new DecompositionSolver(this);\n+            lu = ds.luDecompose(MathUtils.SAFE_MIN);\n+        }\n+        return ds.solve(b, lu);\n     }\n \n     /** {@inheritDoc} */\n     @Deprecated\n     public RealMatrix solve(RealMatrix b) throws IllegalArgumentException, InvalidMatrixException  {\n-        if (lu == null) {\n-            lu = new LUDecompositionImpl(this);\n-        }\n-        return lu.solve(b);\n+        if (ds == null) {\n+            ds = new DecompositionSolver(this);\n+            lu = ds.luDecompose(MathUtils.SAFE_MIN);\n+        }\n+        return ds.solve(b, lu);\n     }\n \n     /**\n      */\n     @Deprecated\n     public void luDecompose() throws InvalidMatrixException {\n-        if (lu == null) {\n-            lu = new LUDecompositionImpl(this);\n+        if (ds == null) {\n+            ds = new DecompositionSolver(this);\n+            lu = ds.luDecompose(MathUtils.SAFE_MIN);\n         }\n     }\n \n--- a/src/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n+++ b/src/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n  */\n \n package org.apache.commons.math.linear;\n+\n+import java.io.Serializable;\n \n \n /**\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n-public interface SingularValueDecomposition extends DecompositionSolver {\n+public interface SingularValueDecomposition extends Serializable {\n \n     /**\n      * Returns the matrix U of the decomposition. \n--- a/src/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n package org.apache.commons.math.linear;\n \n import org.apache.commons.math.ConvergenceException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n  * Calculates the Singular Value Decomposition of a matrix.\n public class SingularValueDecompositionImpl implements SingularValueDecomposition {\n \n     /** Serializable version identifier. */\n-    private static final long serialVersionUID = -2357152028714378552L;\n+    private static final long serialVersionUID = -238768772547767847L;\n \n     /** Number of rows of the initial matrix. */\n     private int m;\n \n     /** Cached value of V<sup>T</sup>. */\n     private RealMatrix cachedVt;\n-\n-    /**\n-     * Build a new instance.\n-     * <p>Note that {@link #decompose(RealMatrix)} <strong>must</strong> be called\n-     * before any of the {@link #getU()}, {@link #getS()}, {@link #getV()},\n-     * {@link #getSingularValues()}, {@link #getNorm()}, {@link #getConditionNumber()},\n-     * {@link #getRank()}, {@link #solve(double[])}, {@link #solve(RealMatrix)},\n-     * {@link #solve(RealVector)} or {@link #solve(RealVectorImpl)} methods can be\n-     * called.</p>\n-     * @see #decompose(RealMatrix)\n-     */\n-    public SingularValueDecompositionImpl() {\n-    }\n \n     /**\n      * Calculates the Singular Value Decomposition of the given matrix. \n      */\n     public SingularValueDecompositionImpl(RealMatrix matrix)\n         throws InvalidMatrixException {\n-        decompose(matrix);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void decompose(final RealMatrix matrix) {\n \n         m = matrix.getRowDimension();\n         n = matrix.getColumnDimension();\n         }\n \n         // compute singular values\n-        eigenDecomposition = new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal);\n+        eigenDecomposition =\n+            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal,\n+                                       MathUtils.SAFE_MIN);\n         singularValues = eigenDecomposition.getEigenvalues();\n         for (int i = 0; i < singularValues.length; ++i) {\n             singularValues[i] = Math.sqrt(singularValues[i]);\n         throws InvalidMatrixException {\n \n         if (cachedU == null) {\n-\n-            checkDecomposed();\n \n             if (m >= n) {\n                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n \n         if (cachedS == null) {\n \n-            checkDecomposed();\n-\n             final int p = singularValues.length;\n             final double[][] sData = new double[p][p];\n             for (int i = 0; i < p; ++i) {\n     /** {@inheritDoc} */\n     public double[] getSingularValues()\n         throws InvalidMatrixException {\n-        checkDecomposed();\n         return singularValues.clone();\n     }\n \n         throws InvalidMatrixException {\n \n         if (cachedV == null) {\n-\n-            checkDecomposed();\n \n             if (m >= n) {\n                 // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n     /** {@inheritDoc} */\n     public double getNorm()\n         throws InvalidMatrixException {\n-        checkDecomposed();\n         return singularValues[0];\n     }\n \n     /** {@inheritDoc} */\n     public double getConditionNumber()\n         throws InvalidMatrixException {\n-        checkDecomposed();\n         return singularValues[0] / singularValues[singularValues.length - 1];\n     }\n \n     /** {@inheritDoc} */\n     public int getRank()\n         throws IllegalStateException {\n-\n-        checkDecomposed();\n \n         final double threshold = Math.max(m, n) * Math.ulp(singularValues[0]);\n \n \n     }\n \n-    /** {@inheritDoc} */\n-    public boolean isNonSingular()\n-        throws IllegalStateException {\n-        return getRank() == singularValues.length;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public double[] solve(final double[] b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-\n-        checkDecomposed();\n-\n-        if (b.length != m) {\n-            throw new IllegalArgumentException(\"constant vector has wrong length\");\n-        }\n-\n-        final double[] w = getUT().operate(b);\n-        for (int i = 0; i < singularValues.length; ++i) {\n-            final double si = singularValues[i];\n-            if (si == 0) {\n-                throw new SingularMatrixException();\n-            }\n-            w[i] /= si;\n-        }\n-        return getV().operate(w);\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector solve(final RealVector b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-        try {\n-            return solve((RealVectorImpl) b);\n-        } catch (ClassCastException cce) {\n-\n-            checkDecomposed();\n-\n-            if (b.getDimension() != m) {\n-                throw new IllegalArgumentException(\"constant vector has wrong length\");\n-            }\n-\n-            final RealVector w = getUT().operate(b);\n-            for (int i = 0; i < singularValues.length; ++i) {\n-                final double si = singularValues[i];\n-                if (si == 0) {\n-                    throw new SingularMatrixException();\n-                }\n-                w.set(i, w.getEntry(i) / si);\n-            }\n-            return getV().operate(w);\n-\n-        }\n-    }\n-\n-    /** Solve the linear equation A &times; X = B.\n-     * <p>The A matrix is implicit here. It is </p>\n-     * @param b right-hand side of the equation A &times; X = B\n-     * @return a vector X such that A &times; X = B\n-     * @throws IllegalArgumentException if matrices dimensions don't match\n-     * @throws InvalidMatrixException if decomposed matrix is singular\n-     */\n-    public RealVectorImpl solve(final RealVectorImpl b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-        return new RealVectorImpl(solve(b.getDataRef()), false);\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealMatrix solve(final RealMatrix b)\n-        throws IllegalArgumentException, InvalidMatrixException {\n-\n-        checkDecomposed();\n-\n-        if (b.getRowDimension() != m) {\n-            throw new IllegalArgumentException(\"Incorrect row dimension\");\n-        }\n-\n-        final RealMatrixImpl w = (RealMatrixImpl) getUT().multiply(b);\n-        final double[][] wData = w.getDataRef();\n-        for (int i = 0; i < singularValues.length; ++i) {\n-            final double si  = singularValues[i];\n-            if (si == 0) {\n-                throw new SingularMatrixException();\n-            }\n-            final double inv = 1.0 / si;\n-            final double[] wi = wData[i];\n-            for (int j = 0; j < b.getColumnDimension(); ++j) {\n-                wi[j] *= inv;\n-            }\n-        }\n-        return getV().multiply(w);\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealMatrix getInverse()\n-        throws IllegalStateException, InvalidMatrixException {\n-        checkDecomposed();\n-        return solve(MatrixUtils.createRealIdentityMatrix(singularValues.length));\n-    }\n-\n-    /**\n-     * Check if {@link #decompose(RealMatrix)} has been called.\n-     * @exception IllegalStateException if {@link #decompose(RealMatrix) decompose}\n-     * has not been called\n-     */\n-    private void checkDecomposed()\n-        throws IllegalStateException {\n-        if (singularValues == null) {\n-            throw MathRuntimeException.createIllegalStateException(\"no matrix have been decomposed yet\", null);\n-        }\n-    }\n-\n }\n--- a/src/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/GLSMultipleLinearRegression.java\n  */\n package org.apache.commons.math.stat.regression;\n \n-import org.apache.commons.math.linear.LUDecompositionImpl;\n+import org.apache.commons.math.linear.DecompositionSolver;\n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealMatrixImpl;\n \n      */\n     protected RealMatrix getOmegaInverse() {\n         if (OmegaInverse == null) {\n-            OmegaInverse = new LUDecompositionImpl(Omega).getInverse();\n+            DecompositionSolver solver = new DecompositionSolver(Omega);\n+            OmegaInverse = solver.getInverse(solver.luDecompose());\n         }\n         return OmegaInverse;\n     }\n         RealMatrix OI = getOmegaInverse();\n         RealMatrix XT = X.transpose();\n         RealMatrix XTOIX = XT.multiply(OI).multiply(X);\n-        return new LUDecompositionImpl(XTOIX).getInverse().multiply(XT).multiply(OI).multiply(Y);\n+        DecompositionSolver solver = new DecompositionSolver(XTOIX);\n+        return solver.getInverse(solver.luDecompose()).multiply(XT).multiply(OI).multiply(Y);\n     }\n \n     /**\n     protected RealMatrix calculateBetaVariance() {\n         RealMatrix OI = getOmegaInverse();\n         RealMatrix XTOIX = X.transpose().multiply(OI).multiply(X);\n-        return new LUDecompositionImpl(XTOIX).getInverse();\n+        DecompositionSolver solver = new DecompositionSolver(XTOIX);\n+        return solver.getInverse(solver.luDecompose());\n     }\n \n     /**\n--- a/src/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/OLSMultipleLinearRegression.java\n  */\n package org.apache.commons.math.stat.regression;\n \n+import org.apache.commons.math.linear.DecompositionSolver;\n import org.apache.commons.math.linear.LUDecompositionImpl;\n import org.apache.commons.math.linear.QRDecomposition;\n import org.apache.commons.math.linear.QRDecompositionImpl;\n      */\n     protected RealMatrix calculateBetaVariance() {\n         RealMatrix XTX = X.transpose().multiply(X);\n-        return new LUDecompositionImpl(XTX).getInverse();\n+        DecompositionSolver solver = new DecompositionSolver(XTX);\n+        return solver.getInverse(solver.luDecompose());\n     }\n     \n \n--- a/src/test/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/EigenDecompositionImplTest.java\n import java.util.Arrays;\n import java.util.Random;\n \n+import org.apache.commons.math.util.MathUtils;\n+\n import junit.framework.Test;\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n             new RealMatrixImpl(new double[][] {\n                                    { 1.5 }\n                                }, false);\n-        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        EigenDecomposition ed = new DecompositionSolver(matrix).eigenDecompose();\n         assertEquals(1.5, ed.getEigenvalue(0), 1.0e-15);\n     }\n \n                                    {       59.0, 12.0 },\n                                    { Double.NaN, 66.0 }\n                                }, false);\n-        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        EigenDecomposition ed = new DecompositionSolver(matrix).eigenDecompose();\n         assertEquals(75.0, ed.getEigenvalue(0), 1.0e-15);\n         assertEquals(50.0, ed.getEigenvalue(1), 1.0e-15);\n     }\n                                    { Double.NaN,     8693.0,   7920.0 },\n                                    { Double.NaN, Double.NaN,  17300.0 }\n                                }, false);\n-        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        EigenDecomposition ed = new DecompositionSolver(matrix).eigenDecompose();\n         assertEquals(50000.0, ed.getEigenvalue(0), 3.0e-11);\n         assertEquals(12500.0, ed.getEigenvalue(1), 3.0e-11);\n         assertEquals( 3125.0, ed.getEigenvalue(2), 3.0e-11);\n                                    { Double.NaN, Double.NaN,       0.164, -0.048 },\n                                    { Double.NaN, Double.NaN,  Double.NaN,  0.136 }\n                                }, false);\n-        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n-        assertEquals(1.0, ed.getEigenvalue(0), 1.0e-15);\n-        assertEquals(0.4, ed.getEigenvalue(1), 1.0e-15);\n-        assertEquals(0.2, ed.getEigenvalue(2), 1.0e-15);\n-        assertEquals(0.1, ed.getEigenvalue(3), 1.0e-15);\n-    }\n-\n-    public void testAbsoluteSplit() {\n-        RealMatrix matrix =\n-            new RealMatrixImpl(new double[][] {\n-                                   {      0.784,     -0.288,       0.000,  0.000 },\n-                                   { Double.NaN,      0.616,       0.000,  0.000 },\n-                                   { Double.NaN, Double.NaN,       0.164, -0.048 },\n-                                   { Double.NaN, Double.NaN,  Double.NaN,  0.136 }\n-                               }, false);\n-        EigenDecompositionImpl ed = new EigenDecompositionImpl();\n-        ed.setAbsoluteSplitTolerance(1.0e-13);\n-        ed.decompose(matrix);\n+        EigenDecomposition ed = new DecompositionSolver(matrix).eigenDecompose();\n         assertEquals(1.0, ed.getEigenvalue(0), 1.0e-15);\n         assertEquals(0.4, ed.getEigenvalue(1), 1.0e-15);\n         assertEquals(0.2, ed.getEigenvalue(2), 1.0e-15);\n                                    {  0.1152, -0.2304,  0.3088, -0.1344 },\n                                    { -0.2976,  0.1152, -0.1344,  0.3872 }\n                                }, false);\n-        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        EigenDecomposition ed = new DecompositionSolver(matrix).eigenDecompose();\n         assertEquals(1.0, ed.getEigenvalue(0), 1.0e-15);\n         assertEquals(0.4, ed.getEigenvalue(1), 1.0e-15);\n         assertEquals(0.2, ed.getEigenvalue(2), 1.0e-15);\n             new TriDiagonalTransformer(createTestMatrix(r, ref));\n         EigenDecomposition ed =\n             new EigenDecompositionImpl(t.getMainDiagonalRef(),\n-                                       t.getSecondaryDiagonalRef());\n+                                       t.getSecondaryDiagonalRef(),\n+                                       MathUtils.SAFE_MIN);\n         double[] eigenValues = ed.getEigenvalues();\n         assertEquals(ref.length, eigenValues.length);\n         for (int i = 0; i < ref.length; ++i) {\n     /** test dimensions */\n     public void testDimensions() {\n         final int m = matrix.getRowDimension();\n-        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        EigenDecomposition ed = new DecompositionSolver(matrix).eigenDecompose();\n         assertEquals(m, ed.getV().getRowDimension());\n         assertEquals(m, ed.getV().getColumnDimension());\n         assertEquals(m, ed.getD().getColumnDimension());\n \n     /** test eigenvalues */\n     public void testEigenvalues() {\n-        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        EigenDecomposition ed = new DecompositionSolver(matrix).eigenDecompose();\n         double[] eigenValues = ed.getEigenvalues();\n         assertEquals(refValues.length, eigenValues.length);\n         for (int i = 0; i < refValues.length; ++i) {\n             bigValues[i] = 2 * r.nextDouble() - 1;\n         }\n         Arrays.sort(bigValues);\n-        EigenDecomposition ed = new EigenDecompositionImpl(createTestMatrix(r, bigValues));\n+        EigenDecomposition ed =\n+            new DecompositionSolver(createTestMatrix(r, bigValues)).eigenDecompose();\n         double[] eigenValues = ed.getEigenvalues();\n         assertEquals(bigValues.length, eigenValues.length);\n         for (int i = 0; i < bigValues.length; ++i) {\n \n     /** test eigenvectors */\n     public void testEigenvectors() {\n-        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        EigenDecomposition ed = new DecompositionSolver(matrix).eigenDecompose();\n         for (int i = 0; i < matrix.getRowDimension(); ++i) {\n             double lambda = ed.getEigenvalue(i);\n             RealVector v  = ed.getEigenvector(i);\n \n     /** test A = VDVt */\n     public void testAEqualVDVt() {\n-        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        EigenDecomposition ed = new DecompositionSolver(matrix).eigenDecompose();\n         RealMatrix v  = ed.getV();\n         RealMatrix d  = ed.getD();\n         RealMatrix vT = ed.getVT();\n \n     /** test that V is orthogonal */\n     public void testVOrthogonal() {\n-        RealMatrix v = new EigenDecompositionImpl(matrix).getV();\n+        RealMatrix v = new DecompositionSolver(matrix).eigenDecompose().getV();\n         RealMatrix vTv = v.transpose().multiply(v);\n         RealMatrix id  = MatrixUtils.createRealIdentityMatrix(vTv.getRowDimension());\n         assertEquals(0, vTv.subtract(id).getNorm(), 2.0e-13);\n     /** test non invertible matrix */\n     public void testNonInvertible() {\n         Random r = new Random(9994100315209l);\n-        EigenDecomposition ed =\n-            new EigenDecompositionImpl(createTestMatrix(r, new double[] { 1.0, 0.0, -1.0, -2.0, -3.0 }));\n-        assertFalse(ed.isNonSingular());\n+        DecompositionSolver ds =\n+            new DecompositionSolver(createTestMatrix(r, new double[] { 1.0, 0.0, -1.0, -2.0, -3.0 }));\n+        EigenDecomposition ed = ds.eigenDecompose();\n+        assertFalse(ds.isNonSingular(ed));\n         try {\n-            ed.getInverse();\n+            ds.getInverse(ed);\n             fail(\"an exception should have been thrown\");\n         } catch (InvalidMatrixException ime) {\n             // expected behavior\n         Random r = new Random(9994100315209l);\n         RealMatrix m =\n             createTestMatrix(r, new double[] { 1.0, 0.5, -1.0, -2.0, -3.0 });\n-        EigenDecomposition ed = new EigenDecompositionImpl(m);\n-        assertTrue(ed.isNonSingular());\n-        RealMatrix inverse = ed.getInverse();\n+        DecompositionSolver ds = new DecompositionSolver(m);\n+        EigenDecomposition ed = ds.eigenDecompose();\n+        assertTrue(ds.isNonSingular(ed));\n+        RealMatrix inverse = ds.getInverse(ed);\n         RealMatrix error =\n             m.multiply(inverse).subtract(MatrixUtils.createRealIdentityMatrix(m.getRowDimension()));\n         assertEquals(0, error.getNorm(), 4.0e-15);\n     /** test diagonal matrix */\n     public void testDiagonal() {\n         double[] diagonal = new double[] { -3.0, -2.0, 2.0, 5.0 };\n-        EigenDecomposition ed =\n-            new EigenDecompositionImpl(createDiagonalMatrix(diagonal, diagonal.length, diagonal.length));\n+        RealMatrix m = createDiagonalMatrix(diagonal, diagonal.length, diagonal.length);\n+        EigenDecomposition ed = new DecompositionSolver(m).eigenDecompose();\n         assertEquals(diagonal[0], ed.getEigenvalue(3), 2.0e-15);\n         assertEquals(diagonal[1], ed.getEigenvalue(2), 2.0e-15);\n         assertEquals(diagonal[2], ed.getEigenvalue(1), 2.0e-15);\n \n     /** test solve dimension errors */\n     public void testSolveDimensionErrors() {\n-        EigenDecomposition ed = new EigenDecompositionImpl(matrix);\n+        DecompositionSolver ds = new DecompositionSolver(matrix);\n+        EigenDecomposition  ed = ds.eigenDecompose();\n         RealMatrix b = new RealMatrixImpl(new double[2][2]);\n         try {\n-            ed.solve(b);\n+            ds.solve(b, ed);\n             fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected behavior\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            ed.solve(b.getColumn(0));\n+            ds.solve(b.getColumn(0), ed);\n             fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected behavior\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            ed.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            ds.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)), ed);\n             fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected behavior\n                 { 40,  2, 21,  9, 51, 19 },\n                 { 14, -1,  8,  0, 19, 14 }\n         });\n-        EigenDecomposition ed = new EigenDecompositionImpl(m);\n-        assertEquals(184041, ed.getDeterminant(), 2.0e-8);\n+        DecompositionSolver ds = new DecompositionSolver(m);\n+        EigenDecomposition  ed = ds.eigenDecompose();\n+        assertEquals(184041, ds.getDeterminant(ed), 2.0e-8);\n         RealMatrix b = new RealMatrixImpl(new double[][] {\n                 { 1561, 269, 188 },\n                 {   69, -21,  70 },\n         });\n \n         // using RealMatrix\n-        assertEquals(0, ed.solve(b).subtract(xRef).getNorm(), 2.0e-12);\n+        assertEquals(0, ds.solve(b, ed).subtract(xRef).getNorm(), 2.0e-12);\n \n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             assertEquals(0,\n-                         new RealVectorImpl(ed.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         new RealVectorImpl(ds.solve(b.getColumn(i), ed)).subtract(xRef.getColumnVector(i)).getNorm(),\n                          2.0e-11);\n         }\n \n         // using RealMatrixImpl\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             assertEquals(0,\n-                         ed.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         ds.solve(b.getColumnVector(i), ed).subtract(xRef.getColumnVector(i)).getNorm(),\n                          2.0e-11);\n         }\n \n             RealVectorImplTest.RealVectorTestImpl v =\n                 new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n             assertEquals(0,\n-                         ed.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         ds.solve(v, ed).subtract(xRef.getColumnVector(i)).getNorm(),\n                          2.0e-11);\n         }\n \n                 {2,  0,  2},\n                 {4,  2,  3}\n         }); \n-        EigenDecomposition ed = new EigenDecompositionImpl(repeated);\n+        EigenDecomposition ed = new DecompositionSolver(repeated).eigenDecompose();\n         checkEigenValues((new double[] {8, -1, -1}), ed, 1E-12);\n         checkEigenVector((new double[] {2, 1, 2}), ed, 1E-12);\n     }\n                 {1, 3, -4}, \n                 {-4, -4, 8}\n         });\n-        EigenDecomposition ed = new EigenDecompositionImpl(distinct);\n+        EigenDecomposition ed = new DecompositionSolver(distinct).eigenDecompose();\n         checkEigenValues((new double[] {2, 0, 12}), ed, 1E-12);\n         checkEigenVector((new double[] {1, -1, 0}), ed, 1E-12);\n         checkEigenVector((new double[] {1, 1, 1}), ed, 1E-12);\n--- a/src/test/org/apache/commons/math/linear/LUDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/LUDecompositionImplTest.java\n         }\n     }\n \n-    /** test no call to decompose */\n-    public void testNoDecompose() {\n-        try {\n-            new LUDecompositionImpl().getPivot();\n-            fail(\"an exception should have been caught\");\n-        } catch (IllegalStateException ise) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-    }\n-\n     /** test threshold impact */\n     public void testThreshold() {\n         final RealMatrix matrix = new RealMatrixImpl(new double[][] {\n                                                        { 2.0, 5.0, 3.0},\n                                                        { 4.000001, 9.0, 9.0}\n                                                      }, false);\n-        assertFalse(new LUDecompositionImpl(matrix, 1.0e-5).isNonSingular());\n-        assertTrue(new LUDecompositionImpl(matrix, 1.0e-10).isNonSingular());\n+        DecompositionSolver solver = new DecompositionSolver(matrix);\n+        assertFalse(solver.isNonSingular(solver.luDecompose(1.0e-5)));\n+        assertTrue(solver.isNonSingular(solver.luDecompose(1.0e-10)));\n     }\n \n     /** test PA = LU */\n \n         matrix = new RealMatrixImpl(singular, false);\n         lu = new LUDecompositionImpl(matrix);\n-        assertFalse(lu.isNonSingular());\n+        assertTrue(lu.isSingular());\n         assertNull(lu.getL());\n         assertNull(lu.getU());\n         assertNull(lu.getP());\n \n         matrix = new RealMatrixImpl(bigSingular, false);\n         lu = new LUDecompositionImpl(matrix);\n-        assertFalse(lu.isNonSingular());\n+        assertTrue(lu.isSingular());\n         assertNull(lu.getL());\n         assertNull(lu.getU());\n         assertNull(lu.getP());\n     public void testSingular() {\n         LUDecomposition lu =\n             new LUDecompositionImpl(new RealMatrixImpl(testData, false));\n-        assertTrue(lu.isNonSingular());\n+        assertFalse(lu.isSingular());\n         lu = new LUDecompositionImpl(new RealMatrixImpl(singular, false));\n-        assertFalse(lu.isNonSingular());\n+        assertTrue(lu.isSingular());\n         lu = new LUDecompositionImpl(new RealMatrixImpl(bigSingular, false));\n-        assertFalse(lu.isNonSingular());\n+        assertTrue(lu.isSingular());\n     }\n \n     /** test solve dimension errors */\n     public void testSolveDimensionErrors() {\n-        LUDecomposition lu =\n-            new LUDecompositionImpl(new RealMatrixImpl(testData, false));\n+        DecompositionSolver solver =\n+            new DecompositionSolver(new RealMatrixImpl(testData, false));\n         RealMatrix b = new RealMatrixImpl(new double[2][2]);\n         try {\n-            lu.solve(b);\n+            solver.solve(b, solver.luDecompose());\n             fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected behavior\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            lu.solve(b.getColumn(0));\n+            solver.solve(b.getColumn(0), solver.luDecompose());\n             fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected behavior\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            lu.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            solver.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)),\n+                         solver.luDecompose());\n             fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected behavior\n \n     /** test solve singularity errors */\n     public void testSolveSingularityErrors() {\n-        LUDecomposition lu =\n-            new LUDecompositionImpl(new RealMatrixImpl(singular, false));\n+        DecompositionSolver solver =\n+            new DecompositionSolver(new RealMatrixImpl(singular, false));\n         RealMatrix b = new RealMatrixImpl(new double[2][2]);\n         try {\n-            lu.solve(b);\n+            solver.solve(b, solver.luDecompose());\n             fail(\"an exception should have been thrown\");\n         } catch (InvalidMatrixException ime) {\n             // expected behavior\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            lu.solve(b.getColumn(0));\n+            solver.solve(b.getColumn(0), solver.luDecompose());\n             fail(\"an exception should have been thrown\");\n         } catch (InvalidMatrixException ime) {\n             // expected behavior\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            lu.solve(b.getColumnVector(0));\n+            solver.solve(b.getColumnVector(0), solver.luDecompose());\n             fail(\"an exception should have been thrown\");\n         } catch (InvalidMatrixException ime) {\n             // expected behavior\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            lu.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            solver.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)),\n+                         solver.luDecompose());\n             fail(\"an exception should have been thrown\");\n         } catch (InvalidMatrixException ime) {\n             // expected behavior\n \n     /** test solve */\n     public void testSolve() {\n-        LUDecomposition lu =\n-            new LUDecompositionImpl(new RealMatrixImpl(testData, false));\n+        DecompositionSolver solver =\n+            new DecompositionSolver(new RealMatrixImpl(testData, false));\n+        LUDecomposition lu = solver.luDecompose();\n         RealMatrix b = new RealMatrixImpl(new double[][] {\n                 { 1, 0 }, { 2, -5 }, { 3, 1 }\n         });\n         });\n \n         // using RealMatrix\n-        assertEquals(0, lu.solve(b).subtract(xRef).getNorm(), 1.0e-13);\n+        assertEquals(0, solver.solve(b, lu).subtract(xRef).getNorm(), 1.0e-13);\n \n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             assertEquals(0,\n-                         new RealVectorImpl(lu.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         new RealVectorImpl(solver.solve(b.getColumn(i), lu)).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n \n         // using RealVectorImpl\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             assertEquals(0,\n-                         lu.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         solver.solve(b.getColumnVector(i), lu).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n \n             RealVectorImplTest.RealVectorTestImpl v =\n                 new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n             assertEquals(0,\n-                         lu.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         solver.solve(v, lu).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n \n \n     /** test determinant */\n     public void testDeterminant() {\n-        assertEquals(-1,\n-                     new LUDecompositionImpl(new RealMatrixImpl(testData, false)).getDeterminant(),\n-                     1.0e-15);\n-        assertEquals(-10,\n-                     new LUDecompositionImpl(new RealMatrixImpl(luData, false)).getDeterminant(),\n-                     1.0e-14);\n-        assertEquals(0,\n-                     new LUDecompositionImpl(new RealMatrixImpl(singular, false)).getDeterminant(),\n-                     1.0e-17);\n-        assertEquals(0,\n-                     new LUDecompositionImpl(new RealMatrixImpl(bigSingular, false)).getDeterminant(),\n-                     1.0e-17);\n+        assertEquals( -1, getDeterminant(new RealMatrixImpl(testData, false)), 1.0e-15);\n+        assertEquals(-10, getDeterminant(new RealMatrixImpl(luData, false)), 1.0e-14);\n+        assertEquals(  0, getDeterminant(new RealMatrixImpl(singular, false)), 1.0e-17);\n+        assertEquals(  0, getDeterminant(new RealMatrixImpl(bigSingular, false)), 1.0e-10);\n+    }\n+\n+    private double getDeterminant(RealMatrix m) {\n+        DecompositionSolver ds = new DecompositionSolver(m);\n+        return ds.getDeterminant(ds.luDecompose());\n     }\n \n }\n--- a/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/QRDecompositionImplTest.java\n \n     /** test rank */\n     public void testRank() {\n-        QRDecomposition qr =\n-            new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));\n-        assertTrue(qr.isNonSingular());\n-\n-        qr = new QRDecompositionImpl(new RealMatrixImpl(testData3x3Singular, false));\n-        assertFalse(qr.isNonSingular());\n-\n-        qr = new QRDecompositionImpl(new RealMatrixImpl(testData3x4, false));\n-        assertFalse(qr.isNonSingular());\n-\n-        qr = new QRDecompositionImpl(new RealMatrixImpl(testData4x3, false));\n-        assertTrue(qr.isNonSingular());\n+        DecompositionSolver ds =\n+            new DecompositionSolver(new RealMatrixImpl(testData3x3NonSingular, false));\n+        assertTrue(ds.isNonSingular(ds.qrDecompose()));\n+\n+        ds = new DecompositionSolver(new RealMatrixImpl(testData3x3Singular, false));\n+        assertFalse(ds.isNonSingular(ds.qrDecompose()));\n+\n+        ds = new DecompositionSolver(new RealMatrixImpl(testData3x4, false));\n+        assertTrue(ds.isNonSingular(ds.qrDecompose()));\n+\n+        ds = new DecompositionSolver(new RealMatrixImpl(testData4x3, false));\n+        assertTrue(ds.isNonSingular(ds.qrDecompose()));\n \n     }\n \n     /** test solve dimension errors */\n     public void testSolveDimensionErrors() {\n-        QRDecomposition qr =\n-            new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));\n+        DecompositionSolver solver =\n+            new DecompositionSolver(new RealMatrixImpl(testData3x3NonSingular, false));\n         RealMatrix b = new RealMatrixImpl(new double[2][2]);\n         try {\n-            qr.solve(b);\n+            solver.solve(b, solver.qrDecompose());\n             fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected behavior\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            qr.solve(b.getColumn(0));\n+            solver.solve(b.getColumn(0), solver.qrDecompose());\n             fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected behavior\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            qr.solve(b.getColumnVector(0));\n+            solver.solve(b.getColumnVector(0), solver.qrDecompose());\n             fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected behavior\n \n     /** test solve rank errors */\n     public void testSolveRankErrors() {\n-        QRDecomposition qr =\n-            new QRDecompositionImpl(new RealMatrixImpl(testData3x3Singular, false));\n+        DecompositionSolver solver =\n+            new DecompositionSolver(new RealMatrixImpl(testData3x3Singular, false));\n         RealMatrix b = new RealMatrixImpl(new double[3][2]);\n         try {\n-            qr.solve(b);\n+            solver.solve(b, solver.qrDecompose());\n             fail(\"an exception should have been thrown\");\n         } catch (InvalidMatrixException iae) {\n             // expected behavior\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            qr.solve(b.getColumn(0));\n+            solver.solve(b.getColumn(0), solver.qrDecompose());\n             fail(\"an exception should have been thrown\");\n         } catch (InvalidMatrixException iae) {\n             // expected behavior\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            qr.solve(b.getColumnVector(0));\n+            solver.solve(b.getColumnVector(0), solver.qrDecompose());\n             fail(\"an exception should have been thrown\");\n         } catch (InvalidMatrixException iae) {\n             // expected behavior\n \n     /** test solve */\n     public void testSolve() {\n-        QRDecomposition qr =\n-            new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));\n+        DecompositionSolver ds =\n+            new DecompositionSolver(new RealMatrixImpl(testData3x3NonSingular, false));\n+        QRDecomposition qr = ds.qrDecompose();\n         RealMatrix b = new RealMatrixImpl(new double[][] {\n                 { -102, 12250 }, { 544, 24500 }, { 167, -36750 }\n         });\n         });\n \n         // using RealMatrix\n-        assertEquals(0, qr.solve(b).subtract(xRef).getNorm(), 1.0e-13);\n+        assertEquals(0, ds.solve(b, qr).subtract(xRef).getNorm(), 1.0e-13);\n \n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             assertEquals(0,\n-                         new RealVectorImpl(qr.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         new RealVectorImpl(ds.solve(b.getColumn(i), qr)).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n \n         // using RealVectorImpl\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             assertEquals(0,\n-                         qr.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         ds.solve(b.getColumnVector(i), qr).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n \n             RealVectorImplTest.RealVectorTestImpl v =\n                 new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n             assertEquals(0,\n-                         qr.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         ds.solve(v, qr).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n \n \n     /** test matrices values */\n     public void testMatricesValues() {\n-        QRDecomposition qr =\n-            new QRDecompositionImpl(new RealMatrixImpl(testData3x3NonSingular, false));\n+        DecompositionSolver ds =\n+            new DecompositionSolver(new RealMatrixImpl(testData3x3NonSingular, false));\n+        QRDecomposition qr = ds.qrDecompose();\n         RealMatrix qRef = new RealMatrixImpl(new double[][] {\n                 { -12.0 / 14.0,   69.0 / 175.0,  -58.0 / 175.0 },\n                 {  -6.0 / 14.0, -158.0 / 175.0,    6.0 / 175.0 },\n         \n     }\n \n-    /** test no call to decompose */\n-    public void testNoDecompose() {\n-        try {\n-            new QRDecompositionImpl().isNonSingular();\n-            fail(\"an exception should have been caught\");\n-        } catch (IllegalStateException ise) {\n-            // expected behavior\n-        } catch (Exception e) {\n-            fail(\"wrong exception caught\");\n-        }\n-    }\n-\n }\n--- a/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealMatrixImplTest.java\n     /** test transpose */\n     public void testTranspose() {\n         RealMatrix m = new RealMatrixImpl(testData); \n-        RealMatrix mIT = new LUDecompositionImpl(m).getInverse().transpose();\n-        RealMatrix mTI = new LUDecompositionImpl(m.transpose()).getInverse();\n+        DecompositionSolver ds1 = new DecompositionSolver(m);\n+        RealMatrix mIT = ds1.getInverse(ds1.luDecompose()).transpose();\n+        DecompositionSolver ds2 = new DecompositionSolver(m.transpose());\n+        RealMatrix mTI = ds2.getInverse(ds2.luDecompose());\n         assertClose(\"inverse-transpose\", mIT, mTI, normTolerance);\n         m = new RealMatrixImpl(testData2);\n         RealMatrix mt = new RealMatrixImpl(testData2T);\n         assertEquals(2, p.getRowDimension());\n         assertEquals(2, p.getColumnDimension());\n         // Invert p\n-        RealMatrix pInverse = new LUDecompositionImpl(p).getInverse(); \n+        DecompositionSolver ds1 = new DecompositionSolver(p);\n+        RealMatrix pInverse = ds1.getInverse(ds1.luDecompose()); \n         assertEquals(2, pInverse.getRowDimension());\n         assertEquals(2, pInverse.getColumnDimension());\n         \n         double[][] coefficientsData = {{2, 3, -2}, {-1, 7, 6}, {4, -3, -5}};\n         RealMatrix coefficients = new RealMatrixImpl(coefficientsData);\n         double[] constants = {1, -2, 1};\n-        double[] solution = new LUDecompositionImpl(coefficients).solve(constants);\n+        DecompositionSolver ds2 = new DecompositionSolver(coefficients);\n+        double[] solution = ds2.solve(constants, ds2.luDecompose());\n         assertEquals(2 * solution[0] + 3 * solution[1] -2 * solution[2], constants[0], 1E-12);\n         assertEquals(-1 * solution[0] + 7 * solution[1] + 6 * solution[2], constants[1], 1E-12);\n         assertEquals(4 * solution[0] - 3 * solution[1] -5 * solution[2], constants[2], 1E-12);   \n--- a/src/test/org/apache/commons/math/linear/SingularValueDecompositionImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/SingularValueDecompositionImplTest.java\n \n     /** test solve dimension errors */\n     public void testSolveDimensionErrors() {\n-        SingularValueDecomposition svd =\n-            new SingularValueDecompositionImpl(new RealMatrixImpl(testSquare, false));\n+        DecompositionSolver ds =\n+            new DecompositionSolver(new RealMatrixImpl(testSquare, false));\n+        SingularValueDecomposition svd = ds.singularDecompose();\n         RealMatrix b = new RealMatrixImpl(new double[3][2]);\n         try {\n-            svd.solve(b);\n+            ds.solve(b, svd);\n             fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected behavior\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            svd.solve(b.getColumn(0));\n+            ds.solve(b.getColumn(0), svd);\n             fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected behavior\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            svd.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            ds.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)), svd);\n             fail(\"an exception should have been thrown\");\n         } catch (IllegalArgumentException iae) {\n             // expected behavior\n \n     /** test solve singularity errors */\n     public void testSolveSingularityErrors() {\n-        SingularValueDecomposition svd =\n-            new SingularValueDecompositionImpl(new RealMatrixImpl(new double[][] {\n-                                                                      { 1.0, 0.0 },\n-                                                                      { 0.0, 0.0 }\n-                                                                  }, false));\n+        DecompositionSolver ds =\n+            new DecompositionSolver(new RealMatrixImpl(new double[][] {\n+                                                           { 1.0, 0.0 },\n+                                                           { 0.0, 0.0 }\n+                                                       }, false));\n+        SingularValueDecomposition svd = ds.singularDecompose();\n         RealMatrix b = new RealMatrixImpl(new double[2][2]);\n         try {\n-            svd.solve(b);\n+            ds.solve(b, svd);\n             fail(\"an exception should have been thrown\");\n         } catch (InvalidMatrixException ime) {\n             // expected behavior\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            svd.solve(b.getColumn(0));\n+            ds.solve(b.getColumn(0), svd);\n             fail(\"an exception should have been thrown\");\n         } catch (InvalidMatrixException ime) {\n             // expected behavior\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            svd.solve(b.getColumnVector(0));\n+            ds.solve(b.getColumnVector(0), svd);\n             fail(\"an exception should have been thrown\");\n         } catch (InvalidMatrixException ime) {\n             // expected behavior\n             fail(\"wrong exception caught\");\n         }\n         try {\n-            svd.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)));\n+            ds.solve(new RealVectorImplTest.RealVectorTestImpl(b.getColumn(0)), svd);\n             fail(\"an exception should have been thrown\");\n         } catch (InvalidMatrixException ime) {\n             // expected behavior\n \n     /** test solve */\n     public void testSolve() {\n-        SingularValueDecomposition svd =\n-            new SingularValueDecompositionImpl(new RealMatrixImpl(testSquare, false));\n+        DecompositionSolver ds =\n+            new DecompositionSolver(new RealMatrixImpl(testSquare, false));\n+        SingularValueDecomposition svd = ds.singularDecompose();\n         RealMatrix b = new RealMatrixImpl(new double[][] {\n                 { 1, 2, 3 }, { 0, -5, 1 }\n         });\n         });\n \n         // using RealMatrix\n-        assertEquals(0, svd.solve(b).subtract(xRef).getNorm(), normTolerance);\n+        assertEquals(0, ds.solve(b, svd).subtract(xRef).getNorm(), normTolerance);\n \n         // using double[]\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             assertEquals(0,\n-                         new RealVectorImpl(svd.solve(b.getColumn(i))).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         new RealVectorImpl(ds.solve(b.getColumn(i), svd)).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n \n         // using RealMatrixImpl\n         for (int i = 0; i < b.getColumnDimension(); ++i) {\n             assertEquals(0,\n-                         svd.solve(b.getColumnVector(i)).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         ds.solve(b.getColumnVector(i), svd).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n \n             RealVectorImplTest.RealVectorTestImpl v =\n                 new RealVectorImplTest.RealVectorTestImpl(b.getColumn(i));\n             assertEquals(0,\n-                         svd.solve(v).subtract(xRef.getColumnVector(i)).getNorm(),\n+                         ds.solve(v, svd).subtract(xRef.getColumnVector(i)).getNorm(),\n                          1.0e-13);\n         }\n \n         });\n \n         // check values against known references\n-        SingularValueDecomposition svd = new SingularValueDecompositionImpl();\n-        svd.decompose(new RealMatrixImpl(testNonSquare, false));\n+        SingularValueDecomposition svd =\n+            new DecompositionSolver(new RealMatrixImpl(testNonSquare, false)).singularDecompose();\n         RealMatrix u = svd.getU();\n         assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);\n         RealMatrix s = svd.getS();", "timestamp": 1228434498, "metainfo": ""}