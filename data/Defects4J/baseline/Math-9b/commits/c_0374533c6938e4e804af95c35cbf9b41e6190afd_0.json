{"sha": "0374533c6938e4e804af95c35cbf9b41e6190afd", "log": "improved consistency between RealVector and RealMatrix API JIRA: MATH-245  ", "commit": "\n--- a/src/java/org/apache/commons/math/linear/RealVector.java\n+++ b/src/java/org/apache/commons/math/linear/RealVector.java\n      * @param index  index location of entry to be fetched\n      * @return vector entry at index\n      * @throws MatrixIndexException if the index is not valid\n+     * @see #setEntry(int, double)\n      */\n     double getEntry(int index)\n+        throws MatrixIndexException;\n+\n+    /**\n+     * Set a single element.\n+     * @param index element index.\n+     * @param value new value for the element.\n+     * @exception MatrixIndexException if the index is\n+     * inconsistent with vector size\n+     * @see #getEntry(int)\n+     */\n+    void setEntry(int index, double value)\n         throws MatrixIndexException;\n \n     /**\n      * @exception MatrixIndexException if the index is\n      * inconsistent with vector size\n      */\n-    RealVector get(int index, int n)\n-        throws MatrixIndexException;\n-\n-    /**\n-     * Set a single element.\n-     * @param index element index.\n-     * @param value new value for the element.\n-     * @exception MatrixIndexException if the index is\n-     * inconsistent with vector size\n-     */\n-    void set(int index, double value)\n+    RealVector getSubVector(int index, int n)\n         throws MatrixIndexException;\n \n     /**\n      * @param v vector containing the values to set.\n      * @exception MatrixIndexException if the index is\n      * inconsistent with vector size\n-     */\n-    void set(int index, RealVector v)\n+     * @see #setSubVector(int, double[])\n+     */\n+    void setSubVector(int index, RealVector v)\n         throws MatrixIndexException;\n \n     /**\n      * @param v vector containing the values to set.\n      * @exception MatrixIndexException if the index is\n      * inconsistent with vector size\n-     */\n-    void set(int index, double[] v)\n+     * @see #setSubVector(int, RealVector)\n+     */\n+    void setSubVector(int index, double[] v)\n         throws MatrixIndexException;\n \n     /**\n--- a/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealVectorImpl.java\n     }\n \n     /** {@inheritDoc} */\n-    public RealVector get(int index, int n) {\n+    public RealVector getSubVector(int index, int n) {\n         RealVectorImpl out = new RealVectorImpl(n);\n         try {\n             System.arraycopy(data, index, out.data, 0, n);\n     }\n \n     /** {@inheritDoc} */\n-    public void set(int index, double value) {\n+    public void setEntry(int index, double value) {\n         try {\n             data[index] = value;\n         } catch (IndexOutOfBoundsException e) {\n     }\n \n     /** {@inheritDoc} */\n-    public void set(int index, RealVector v) {\n+    public void setSubVector(int index, RealVector v) {\n         try {\n             try {\n                 set(index, (RealVectorImpl) v);\n     }\n \n     /** {@inheritDoc} */\n-    public void set(int index, double[] v) {\n+    public void setSubVector(int index, double[] v) {\n         try {\n             System.arraycopy(v, 0, data, index, v.length);\n         } catch (IndexOutOfBoundsException e) {\n      */\n     public void set(int index, RealVectorImpl v)\n         throws MatrixIndexException {\n-        set(index, v.data);\n+        setSubVector(index, v.data);\n     }\n \n     /** {@inheritDoc} */\n--- a/src/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n                 if (si == 0) {\n                     throw new SingularMatrixException();\n                 }\n-                w.set(i, w.getEntry(i) / si);\n+                w.setEntry(i, w.getEntry(i) / si);\n             }\n             return v.operate(w);\n \n--- a/src/java/org/apache/commons/math/linear/SparseRealVector.java\n+++ b/src/java/org/apache/commons/math/linear/SparseRealVector.java\n             iter.advance();\n             int key = iter.key();\n             if (v.getEntries().containsKey(key)) {\n-                res.set(key, iter.value() + v.getEntry(key));\n+                res.setEntry(key, iter.value() + v.getEntry(key));\n             }\n         }\n         iter = v.getEntries().iterator();\n             iter.advance();\n             int key = iter.key();\n             if (!entries.containsKey(key)) {\n-                res.set(key, iter.value());\n+                res.setEntry(key, iter.value());\n             }\n         }\n         return res;\n         checkVectorDimensions(v.length);\n         SparseRealVector res = new SparseRealVector(getDimension());\n         for (int i = 0; i < v.length; i++) {\n-            res.set(i, v[i] + getEntry(i));\n+            res.setEntry(i, v[i] + getEntry(i));\n         }\n         return res;\n     }\n         Iterator iter = v.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n-            res.set(iter.key() + virtualSize, iter.value());\n+            res.setEntry(iter.key() + virtualSize, iter.value());\n         }\n         return res;\n     }\n     /** {@inheritDoc} */\n     public RealVector append(double d) {\n         RealVector res = new SparseRealVector(this, 1);\n-        res.set(virtualSize, d);\n+        res.setEntry(virtualSize, d);\n         return res;\n     }\n \n     public RealVector append(double[] a) {\n         RealVector res = new SparseRealVector(this, a.length);\n         for (int i = 0; i < a.length; i++) {\n-            res.set(i + virtualSize, a[i]);\n+            res.setEntry(i + virtualSize, a[i]);\n         }\n         return res;\n     }\n         Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n-            res.set(iter.key(), iter.value() / v.getEntry(iter.key()));\n+            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n         }\n         return res;\n     }\n         Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n-            res.set(iter.key(), iter.value() / v[iter.key()]);\n+            res.setEntry(iter.key(), iter.value() / v[iter.key()]);\n         }\n         return null;\n     }\n         Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n-            res.set(iter.key(), iter.value() * v.getEntry(iter.key()));\n+            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n         }\n         return res;\n     }\n         Iterator iter = res.entries.iterator();\n         while (iter.hasNext()) {\n             iter.advance();\n-            res.set(iter.key(), iter.value() * v[iter.key()]);\n-        }\n-        return res;\n-    }\n-\n-    /** {@inheritDoc} */\n-    public RealVector get(int index, int n) throws MatrixIndexException {\n+            res.setEntry(iter.key(), iter.value() * v[iter.key()]);\n+        }\n+        return res;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public RealVector getSubVector(int index, int n) throws MatrixIndexException {\n         checkIndex(index);\n         checkIndex(index+n-1);\n         SparseRealVector res = new SparseRealVector(n);\n             iter.advance();\n             int key = iter.key();\n             if (key >= index && key < end) {\n-                res.set(key - index, iter.value());\n+                res.setEntry(key - index, iter.value());\n             }\n         }\n         return res;\n     /** {@inheritDoc} */\n     public RealVector mapAcosToSelf() {\n         for(int i=0; i < virtualSize; i++){\n-            set(i, Math.acos(getEntry(i)));\n+            setEntry(i, Math.acos(getEntry(i)));\n         }\n         return this;\n     }\n     /** {@inheritDoc} */\n     public RealVector mapAddToSelf(double d) {\n         for (int i = 0; i < virtualSize; i++) {\n-            set(i, getEntry(i) + d);\n+            setEntry(i, getEntry(i) + d);\n         }\n         return this;\n     }\n     /** {@inheritDoc} */\n     public RealVector mapInvToSelf() {\n         for(int i=0; i < virtualSize; i++){\n-            set(i, 1.0/getEntry(i));\n+            setEntry(i, 1.0/getEntry(i));\n         }\n         return this;\n     }\n     /** {@inheritDoc} */\n     public RealVector mapLog10ToSelf() {\n         for(int i=0; i < virtualSize; i++){\n-            set(i, Math.log10(getEntry(i)));\n+            setEntry(i, Math.log10(getEntry(i)));\n         }\n         return this;\n     }\n     /** {@inheritDoc} */\n     public RealVector mapLogToSelf() {\n         for(int i=0; i < virtualSize; i++){\n-            set(i, Math.log(getEntry(i)));\n+            setEntry(i, Math.log(getEntry(i)));\n         }\n        return this;\n     }\n     }\n \n     /** {@inheritDoc} */\n-    public void set(int index, double value) throws MatrixIndexException {\n+    public void setEntry(int index, double value) throws MatrixIndexException {\n         checkIndex(index);\n         if (!isZero(value)) {\n             entries.put(index, value);\n     }\n \n     /** {@inheritDoc} */\n-    public void set(int index, RealVector v) throws MatrixIndexException {\n+    public void setSubVector(int index, RealVector v) throws MatrixIndexException {\n         checkIndex(index);\n         checkIndex(index + v.getDimension() - 1);\n-        set(index, v.getData());\n-    }\n-\n-    /** {@inheritDoc} */\n-    public void set(int index, double[] v) throws MatrixIndexException {\n+        setSubVector(index, v.getData());\n+    }\n+\n+    /** {@inheritDoc} */\n+    public void setSubVector(int index, double[] v) throws MatrixIndexException {\n         checkIndex(index);\n         checkIndex(index + v.length - 1);\n         for (int i = 0; i < v.length; i++) {\n-            set(i + index, v[i]);\n+            setEntry(i + index, v[i]);\n         }\n     }\n \n     /** {@inheritDoc} */\n     public void set(double value) {\n         for(int i=0; i < virtualSize; i++){\n-            set(i, value);\n+            setEntry(i, value);\n         }\n     }\n \n         SparseRealVector res = new SparseRealVector(this);\n         for (int i = 0; i < v.length; i++) {\n             if (entries.containsKey(i)) {\n-                res.set(i, entries.get(i) - v[i]);\n+                res.setEntry(i, entries.get(i) - v[i]);\n             } else {\n-                res.set(i, -v[i]);\n+                res.setEntry(i, -v[i]);\n             }\n         }\n         return res;\n--- a/src/test/org/apache/commons/math/linear/RealVectorImplTest.java\n+++ b/src/test/org/apache/commons/math/linear/RealVectorImplTest.java\n             throw unsupported();\n         }\n \n-        public RealVector get(int index, int n) throws MatrixIndexException {\n-            throw unsupported();\n-        }\n-\n-        public void set(int index, double value) throws MatrixIndexException {\n-            throw unsupported();\n-        }\n-\n-        public void set(int index, RealVector v) throws MatrixIndexException {\n-            throw unsupported();\n-        }\n-\n-        public void set(int index, double[] v) throws MatrixIndexException {\n+        public RealVector getSubVector(int index, int n) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setEntry(int index, double value) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setSubVector(int index, RealVector v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setSubVector(int index, double[] v) throws MatrixIndexException {\n             throw unsupported();\n         }\n \n //      assertEquals(\"testData not same object \", v1.data, vout4.data);\n \n \n-        RealVector vout5 = v4.get(3, 3);\n+        RealVector vout5 = v4.getSubVector(3, 3);\n         assertEquals(\"testData len\", 3, vout5.getDimension());\n         assertEquals(\"testData is 4.0 \", 5.0, vout5.getEntry(1));\n         try {\n-            v4.get(3, 7);\n+            v4.getSubVector(3, 7);\n             fail(\"MatrixIndexException expected\");\n         } catch (MatrixIndexException ex) {\n             // expected behavior\n         }\n \n         RealVectorImpl v_set1 = (RealVectorImpl) v1.copy();\n-        v_set1.set(1, 11.0);\n+        v_set1.setEntry(1, 11.0);\n         assertEquals(\"testData is 11.0 \", 11.0, v_set1.getEntry(1));\n         try {\n-            v_set1.set(3, 11.0);\n+            v_set1.setEntry(3, 11.0);\n             fail(\"MatrixIndexException expected\");\n         } catch (MatrixIndexException ex) {\n             // expected behavior\n         }\n \n         RealVectorImpl v_set4 = (RealVectorImpl) v4.copy();\n-        v_set4.set(3, v2_t);\n+        v_set4.setSubVector(3, v2_t);\n         assertEquals(\"testData is 1.0 \", 4.0, v_set4.getEntry(3));\n         assertEquals(\"testData is 7.0 \", 7.0, v_set4.getEntry(6));\n         try {\n-            v_set4.set(7, v2_t);\n+            v_set4.setSubVector(7, v2_t);\n             fail(\"MatrixIndexException expected\");\n         } catch (MatrixIndexException ex) {\n             // expected behavior\n         RealVectorImpl vout10 = (RealVectorImpl) v1.copy();       \n         RealVectorImpl vout10_2 = (RealVectorImpl) v1.copy();\n         assertEquals(vout10, vout10_2);\n-        vout10_2.set(0, 1.1);\n+        vout10_2.setEntry(0, 1.1);\n         assertNotSame(vout10, vout10_2);\n \n     }\n         RealVectorImpl v = new RealVectorImpl(new double[] { 0, 1, 2 });\n \n         assertFalse(v.isNaN());\n-        v.set(1, Double.NaN);\n+        v.setEntry(1, Double.NaN);\n         assertTrue(v.isNaN());\n \n         assertFalse(v.isInfinite());\n-        v.set(0, Double.POSITIVE_INFINITY);\n+        v.setEntry(0, Double.POSITIVE_INFINITY);\n         assertFalse(v.isInfinite());\n-        v.set(1, 1);\n+        v.setEntry(1, 1);\n         assertTrue(v.isInfinite());\n \n-        v.set(0, 0);\n+        v.setEntry(0, 0);\n         assertEquals(v, new RealVectorImpl(new double[] { 0, 1, 2 }));\n         assertNotSame(v, new RealVectorImpl(new double[] { 0, 1, 2 + Math.ulp(2)}));\n         assertNotSame(v, new RealVectorImpl(new double[] { 0, 1, 2, 3 }));\n--- a/src/test/org/apache/commons/math/linear/SparseRealVectorTest.java\n+++ b/src/test/org/apache/commons/math/linear/SparseRealVectorTest.java\n             throw unsupported();\n         }\n \n-        public RealVector get(int index, int n) throws MatrixIndexException {\n-            throw unsupported();\n-        }\n-\n-        public void set(int index, double value) throws MatrixIndexException {\n-            throw unsupported();\n-        }\n-\n-        public void set(int index, RealVector v) throws MatrixIndexException {\n-            throw unsupported();\n-        }\n-\n-        public void set(int index, double[] v) throws MatrixIndexException {\n+        public RealVector getSubVector(int index, int n) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setEntry(int index, double value) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setSubVector(int index, RealVector v) throws MatrixIndexException {\n+            throw unsupported();\n+        }\n+\n+        public void setSubVector(int index, double[] v) throws MatrixIndexException {\n             throw unsupported();\n         }\n \n //      assertEquals(\"testData not same object \", v1.data, vout4.data);\n \n \n-        RealVector vout5 = v4.get(3, 3);\n+        RealVector vout5 = v4.getSubVector(3, 3);\n         assertEquals(\"testData len\", 3, vout5.getDimension());\n         assertEquals(\"testData is 4.0 \", 5.0, vout5.getEntry(1));\n         try {\n-            v4.get(3, 7);\n+            v4.getSubVector(3, 7);\n             fail(\"MatrixIndexException expected\");\n         } catch (MatrixIndexException ex) {\n             // expected behavior\n         }\n \n         SparseRealVector v_set1 = (SparseRealVector) v1.copy();\n-        v_set1.set(1, 11.0);\n+        v_set1.setEntry(1, 11.0);\n         assertEquals(\"testData is 11.0 \", 11.0, v_set1.getEntry(1));\n         try {\n-            v_set1.set(3, 11.0);\n+            v_set1.setEntry(3, 11.0);\n             fail(\"MatrixIndexException expected\");\n         } catch (MatrixIndexException ex) {\n             // expected behavior\n         }\n \n         SparseRealVector v_set2 = (SparseRealVector) v4.copy();\n-        v_set2.set(3, v1);\n+        v_set2.setSubVector(3, v1);\n         assertEquals(\"testData is 1.0 \", 1.0, v_set2.getEntry(3));\n         assertEquals(\"testData is 7.0 \", 7.0, v_set2.getEntry(6));\n         try {\n-            v_set2.set(7, v1);\n+            v_set2.setSubVector(7, v1);\n             fail(\"MatrixIndexException expected\");\n         } catch (MatrixIndexException ex) {\n             // expected behavior\n         }\n \n         SparseRealVector v_set4 = (SparseRealVector) v4.copy();\n-        v_set4.set(3, v2_t);\n+        v_set4.setSubVector(3, v2_t);\n         assertEquals(\"testData is 1.0 \", 4.0, v_set4.getEntry(3));\n         assertEquals(\"testData is 7.0 \", 7.0, v_set4.getEntry(6));\n         try {\n-            v_set4.set(7, v2_t);\n+            v_set4.setSubVector(7, v2_t);\n             fail(\"MatrixIndexException expected\");\n         } catch (MatrixIndexException ex) {\n             // expected behavior\n         SparseRealVector v = new SparseRealVector(new double[] { 0, 1, 2 });\n \n         assertFalse(v.isNaN());\n-        v.set(1, Double.NaN);\n+        v.setEntry(1, Double.NaN);\n         assertTrue(v.isNaN());\n \n         assertFalse(v.isInfinite());\n-        v.set(0, Double.POSITIVE_INFINITY);\n+        v.setEntry(0, Double.POSITIVE_INFINITY);\n         // TODO: fixme\n         //assertFalse(v.isInfinite());\n-        v.set(1, 1);\n+        v.setEntry(1, 1);\n         assertTrue(v.isInfinite());\n \n-        v.set(0, 0);\n+        v.setEntry(0, 0);\n         // TODO: backing store doesn't yet implement equals\n         //assertEquals(v, new SparseRealVector(new double[] { 0, 1, 2 }));\n         //assertNotSame(v, new SparseRealVector(new double[] { 0, 1, 2 + Math.ulp(2)}));", "timestamp": 1233755990, "metainfo": ""}