{"sha": "64763c33b77376a74fb012071a665d6cbd4db6b7", "log": "Added lower and upper boundaries to finite differences.  When a function is defined only on an interval, finite differences should not attempt to compute sample points outside this interval. This case is now detected properly and the sample is shifted if needed. This may result in some loss of accuracy as the formula is not centered anymore, but at least we should not get catastrophic errors or exceptions.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/FiniteDifferencesDifferentiator.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/FiniteDifferencesDifferentiator.java\n import org.apache.commons.math3.exception.NotPositiveException;\n import org.apache.commons.math3.exception.NumberIsTooLargeException;\n import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+import org.apache.commons.math3.util.FastMath;\n \n /** Univariate functions differentiator using finite differences.\n  * <p>\n  * <ul>\n  *   <li>step size = 0.25, second order derivative error about 9.97e-10</li>\n  *   <li>step size = 0.25, fourth order derivative error about 5.43e-8</li>\n- *   <li>step size = 1.0e-6, second order derivative error about 56.25</li>\n- *   <li>step size = 1.0e-6, fourth order derivative error about 2.47e+14</li>\n+ *   <li>step size = 1.0e-6, second order derivative error about 148</li>\n+ *   <li>step size = 1.0e-6, fourth order derivative error about 6.35e+14</li>\n  * </ul>\n  * This example shows that the small step size is really bad, even simply\n  * for second order derivative!\n     private final int nbPoints;\n \n     /** Step size. */\n-    private double stepSize;\n-\n-    /**\n-     * Build a differentiator with number of points and step size.\n+    private final double stepSize;\n+\n+    /** Half sample span. */\n+    private final double halfSampleSpan;\n+\n+    /** Lower bound for independent variable. */\n+    private final double tMin;\n+\n+    /** Upper bound for independent variable. */\n+    private final double tMax;\n+\n+    /**\n+     * Build a differentiator with number of points and step size when independent variable is unbounded.\n      * <p>\n      * Beware that wrong settings for the finite differences differentiator\n      * can lead to highly unstable and inaccurate results, especially for\n      */\n     public FiniteDifferencesDifferentiator(final int nbPoints, final double stepSize)\n         throws NotPositiveException, NumberIsTooSmallException {\n+        this(nbPoints, stepSize, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n+    }\n+\n+    /**\n+     * Build a differentiator with number of points and step size when independent variable is bounded.\n+     * <p>\n+     * When the independent variable is bounded (tLower &lt; t &lt; tUpper), the sampling\n+     * points used for differentiation will be adapted to ensure the constraint holds\n+     * even near the boundaries. This means the sample will not be centered anymore in\n+     * these cases. At an extreme case, computing derivatives exactly at the lower bound\n+     * will lead the sample to be entirely on the right side of the derivation point.\n+     * </p>\n+     * <p>\n+     * Note that the boundaries are considered to be excluded for function evaluation.\n+     * </p>\n+     * <p>\n+     * Beware that wrong settings for the finite differences differentiator\n+     * can lead to highly unstable and inaccurate results, especially for\n+     * high derivation orders. Using very small step sizes is often a\n+     * <em>bad</em> idea.\n+     * </p>\n+     * @param nbPoints number of points to use\n+     * @param stepSize step size (gap between each point)\n+     * @param tLower lower bound for independent variable (may be {@code Double.NEGATIVE_INFINITY}\n+     * if there are no lower bounds)\n+     * @param tUpper upper bound for independent variable (may be {@code Double.POSITIVE_INFINITY}\n+     * if there are no upper bounds)\n+     * @exception NotPositiveException if {@code stepsize <= 0} (note that\n+     * {@link NotPositiveException} extends {@link NumberIsTooSmallException})\n+     * @exception NumberIsTooSmallException {@code nbPoint <= 1}\n+     * @exception NumberIsTooLargeException {@code stepSize * (nbPoints - 1) >= tUpper - tLower}\n+     */\n+    public FiniteDifferencesDifferentiator(final int nbPoints, final double stepSize,\n+                                           final double tLower, final double tUpper)\n+            throws NotPositiveException, NumberIsTooSmallException, NumberIsTooLargeException {\n \n         if (nbPoints <= 1) {\n             throw new NumberIsTooSmallException(stepSize, 1, false);\n         }\n         this.stepSize = stepSize;\n \n+        halfSampleSpan = 0.5 * stepSize * (nbPoints - 1);\n+        if (2 * halfSampleSpan >= tUpper - tLower) {\n+            throw new NumberIsTooLargeException(2 * halfSampleSpan, tUpper - tLower, false);\n+        }\n+        final double safety = FastMath.ulp(halfSampleSpan);\n+        this.tMin = tLower + halfSampleSpan + safety;\n+        this.tMax = tUpper - halfSampleSpan - safety;\n+\n     }\n \n     /**\n     }\n \n     /**\n-     * Evaluate derivatives from a centered sample.\n-     * @param t central value and derivatives\n-     * @param y function values at {@code t + stepSize * (i - 0.5 * (nbPoints - 1))}\n+     * Evaluate derivatives from a sample.\n+     * <p>\n+     * Evaluation is done using divided differences.\n+     * </p>\n+     * @param te evaluation abscissa value and derivatives\n+     * @param t0 first sample point abscissa\n+     * @param y function values sample {@code y[i] = f(t[i]) = f(t0 + i * stepSize)}\n      * @return value and derivatives at {@code t}\n      * @exception NumberIsTooLargeException if the requested derivation order\n      * is larger or equal to the number of points\n      */\n-    private DerivativeStructure evaluate(final DerivativeStructure t, final double[] y)\n+    private DerivativeStructure evaluate(final DerivativeStructure t, final double t0,\n+                                         final double[] y)\n         throws NumberIsTooLargeException {\n \n         // create divided differences diagonal arrays\n         }\n \n         // evaluate interpolation polynomial (represented by top diagonal) at t\n-        final int order      = t.getOrder();\n-        final int parameters = t.getFreeParameters();\n+        final int order            = t.getOrder();\n+        final int parameters       = t.getFreeParameters();\n         final double[] derivatives = t.getAllDerivatives();\n+        final double dt0           = t.getValue() - t0;\n         DerivativeStructure interpolation = new DerivativeStructure(parameters, order, 0.0);\n-        DerivativeStructure monomial      = new DerivativeStructure(parameters, order, 1.0);\n+        DerivativeStructure monomial = null;\n         for (int i = 0; i < nbPoints; ++i) {\n+            if (i == 0) {\n+                // start with monomial(t) = 1\n+                monomial = new DerivativeStructure(parameters, order, 1.0);\n+            } else {\n+                // monomial(t) = (t - t0) * (t - t1) * ... * (t - t(i-1))\n+                derivatives[0] = dt0 - (i - 1) * stepSize;\n+                final DerivativeStructure deltaX = new DerivativeStructure(parameters, order, derivatives);\n+                monomial = monomial.multiply(deltaX);\n+            }\n             interpolation = interpolation.add(monomial.multiply(top[i]));\n-            derivatives[0] = stepSize * (0.5 * (nbPoints - 1) - i);\n-            final DerivativeStructure deltaX = new DerivativeStructure(parameters, order, derivatives);\n-            monomial = monomial.multiply(deltaX);\n         }\n \n         return interpolation;\n                     throw new NumberIsTooLargeException(t.getOrder(), nbPoints, false);\n                 }\n \n-                // get sample points centered around t value\n-                final double t0 = t.getValue();\n+                // compute sample position, trying to be centered if possible\n+                final double t0 = FastMath.max(FastMath.min(t.getValue(), tMax), tMin) - halfSampleSpan;\n+\n+                // compute sample points\n                 final double[] y = new double[nbPoints];\n                 for (int i = 0; i < nbPoints; ++i) {\n-                    final double xi = t0 + stepSize * (i - 0.5 * (nbPoints - 1));\n-                    y[i] = function.value(xi);\n+                    y[i] = function.value(t0 + i * stepSize);\n                 }\n \n                 // evaluate derivatives\n-                return evaluate(t, y);\n+                return evaluate(t, t0, y);\n \n             }\n \n                     throw new NumberIsTooLargeException(t.getOrder(), nbPoints, false);\n                 }\n \n-                // get sample points centered around t value\n-                final double t0 = t.getValue();\n+                // compute sample position, trying to be centered if possible\n+                final double t0 = FastMath.max(FastMath.min(t.getValue(), tMax), tMin) - halfSampleSpan;\n+\n+                // compute sample points\n                 double[][] y = null;\n                 for (int i = 0; i < nbPoints; ++i) {\n-                    final double xi = t0 + stepSize * (i - 0.5 * (nbPoints - 1));\n-                    final double[] v = function.value(xi);\n+                    final double[] v = function.value(t0 + i * stepSize);\n                     if (i == 0) {\n                         y = new double[v.length][nbPoints];\n                     }\n                 // evaluate derivatives\n                 final DerivativeStructure[] value = new DerivativeStructure[y.length];\n                 for (int j = 0; j < value.length; ++j) {\n-                    value[j] = evaluate(t, y[j]);\n+                    value[j] = evaluate(t, t0, y[j]);\n                 }\n \n                 return value;\n                     throw new NumberIsTooLargeException(t.getOrder(), nbPoints, false);\n                 }\n \n-                // get sample points centered around t value\n-                final double t0 = t.getValue();\n+                // compute sample position, trying to be centered if possible\n+                final double t0 = FastMath.max(FastMath.min(t.getValue(), tMax), tMin) - halfSampleSpan;\n+\n+                // compute sample points\n                 double[][][] y = null;\n                 for (int i = 0; i < nbPoints; ++i) {\n-                    final double xi = t0 + stepSize * (i - 0.5 * (nbPoints - 1));\n-                    final double[][] v = function.value(xi);\n+                    final double[][] v = function.value(t0 + i * stepSize);\n                     if (i == 0) {\n                         y = new double[v.length][v[0].length][nbPoints];\n                     }\n                 final DerivativeStructure[][] value = new DerivativeStructure[y.length][y[0].length];\n                 for (int j = 0; j < value.length; ++j) {\n                     for (int k = 0; k < y[j].length; ++k) {\n-                        value[j][k] = evaluate(t, y[j][k]);\n+                        value[j][k] = evaluate(t, t0, y[j][k]);\n                     }\n                 }\n \n--- a/src/test/java/org/apache/commons/math3/analysis/differentiation/FiniteDifferencesDifferentiatorTest.java\n+++ b/src/test/java/org/apache/commons/math3/analysis/differentiation/FiniteDifferencesDifferentiatorTest.java\n                 });\n         for (double x = -10; x < 10; x += 0.1) {\n             DerivativeStructure y = f.value(new DerivativeStructure(1, 2, 0, x));\n-            Assert.assertEquals(2 - 3 * x, y.getValue(), 1.0e-20);\n+            Assert.assertEquals(\"\" + (2 - 3 * x - y.getValue()), 2 - 3 * x, y.getValue(), 2.0e-15);\n             Assert.assertEquals(-3.0, y.getPartialDerivative(1), 4.0e-13);\n-            Assert.assertEquals( 0.0, y.getPartialDerivative(2), 5.0e-11);\n+            Assert.assertEquals( 0.0, y.getPartialDerivative(2), 9.0e-11);\n         }\n     }\n \n         UnivariateDifferentiableFunction f =\n                 differentiator.differentiate(gaussian);\n         double[] expectedError = new double[] {\n-            2.776e-17, 1.742e-15, 2.385e-13, 1.329e-11, 2.668e-9, 8.873e-8\n+            6.939e-18, 1.284e-15, 2.477e-13, 1.168e-11, 2.840e-9, 7.971e-8\n         };\n        double[] maxError = new double[expectedError.length];\n         for (double x = -10; x < 10; x += 0.1) {\n         // the 1.0e-6 step size is far too small for finite differences in the quintic on this abscissa range for 7 points\n         // the errors are huge!\n         final double[] expectedBad = new double[] {\n-            1.792e-22, 6.926e-5, 56.25, 1.783e8, 2.468e14, 3.056e20, 5.857e26            \n+            2.910e-11, 2.087e-5, 147.7, 3.820e7, 6.354e14, 6.548e19, 1.543e27            \n         };\n \n         for (int i = 0; i < maxErrorGood.length; ++i) {\n         f.value(new DerivativeStructure(1, 3, 0, 1.0));\n     }\n \n+    @Test(expected=NumberIsTooLargeException.class)\n+    public void testTooLargeStep() {\n+        new FiniteDifferencesDifferentiator(3, 2.5, 0.0, 1.0);\n+    }\n+\n+    @Test\n+    public void testBounds() {\n+\n+        final double slope = 2.5;\n+        UnivariateFunction f = new UnivariateFunction() {\n+            public double value(double x) {\n+                if (x < 0) {\n+                    throw new NumberIsTooSmallException(x, 0, true);\n+                } else if (x > 1) {\n+                    throw new NumberIsTooLargeException(x, 1, true);\n+                } else {\n+                    return slope * x;\n+                }\n+            }\n+        };\n+\n+        UnivariateDifferentiableFunction missingBounds =\n+                new FiniteDifferencesDifferentiator(3, 0.1).differentiate(f);\n+        UnivariateDifferentiableFunction properlyBounded =\n+                new FiniteDifferencesDifferentiator(3, 0.1, 0.0, 1.0).differentiate(f);\n+        DerivativeStructure tLow  = new DerivativeStructure(1, 1, 0, 0.05);\n+        DerivativeStructure tHigh = new DerivativeStructure(1, 1, 0, 0.95);\n+\n+        try {\n+            // here, we did not set the bounds, so the differences are evaluated out of domain\n+            // using f(-0.05), f(0.05), f(0.15)\n+            missingBounds.value(tLow);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (NumberIsTooSmallException nse) {\n+            Assert.assertEquals(-0.05, nse.getArgument().doubleValue(), 1.0e-10);\n+        } catch (Exception e) {\n+            Assert.fail(\"wrong exception caught: \" + e.getClass().getName());\n+        }\n+\n+        try {\n+            // here, we did not set the bounds, so the differences are evaluated out of domain\n+            // using f(0.85), f(0.95), f(1.05)\n+            missingBounds.value(tHigh);\n+            Assert.fail(\"an exception should have been thrown\");\n+        } catch (NumberIsTooLargeException nle) {\n+            Assert.assertEquals(1.05, nle.getArgument().doubleValue(), 1.0e-10);\n+        } catch (Exception e) {\n+            Assert.fail(\"wrong exception caught: \" + e.getClass().getName());\n+        }\n+\n+        // here, we did set the bounds, so evaluations are done within domain\n+        // using f(0.0), f(0.1), f(0.2)\n+        Assert.assertEquals(slope, properlyBounded.value(tLow).getPartialDerivative(1), 1.0e-10);\n+        \n+        // here, we did set the bounds, so evaluations are done within domain\n+        // using f(0.8), f(0.9), f(1.0)\n+        Assert.assertEquals(slope, properlyBounded.value(tHigh).getPartialDerivative(1), 1.0e-10);\n+        \n+    }\n+\n+    @Test\n+    public void testBoundedSqrt() {\n+\n+        UnivariateFunctionDifferentiator differentiator =\n+                new FiniteDifferencesDifferentiator(9, 1.0 / 32, 0.0, Double.POSITIVE_INFINITY);\n+        UnivariateDifferentiableFunction sqrt = differentiator.differentiate(new UnivariateFunction() {\n+            public double value(double x) {\n+                return FastMath.sqrt(x);\n+            }\n+        });\n+\n+        // we are able to compute derivative near 0, but the accuracy is much poorer there\n+        DerivativeStructure t001 = new DerivativeStructure(1, 1, 0, 0.01);\n+        Assert.assertEquals(0.5 / FastMath.sqrt(t001.getValue()), sqrt.value(t001).getPartialDerivative(1), 1.6);\n+        DerivativeStructure t01 = new DerivativeStructure(1, 1, 0, 0.1);\n+        Assert.assertEquals(0.5 / FastMath.sqrt(t01.getValue()), sqrt.value(t01).getPartialDerivative(1), 7.0e-3);\n+        DerivativeStructure t03 = new DerivativeStructure(1, 1, 0, 0.3);\n+        Assert.assertEquals(0.5 / FastMath.sqrt(t03.getValue()), sqrt.value(t03).getPartialDerivative(1), 2.1e-7);\n+\n+    }\n+\n     @Test\n     public void testVectorFunction() {\n \n             DerivativeStructure[] y = f.value(new DerivativeStructure(1, 2, 0, x));\n             double cos = FastMath.cos(x);\n             double sin = FastMath.sin(x);\n-            Assert.assertEquals(cos, y[0].getValue(), 2.0e-16);\n-            Assert.assertEquals(sin, y[1].getValue(), 2.0e-16);\n-            Assert.assertEquals(-sin, y[0].getPartialDerivative(1), 5.0e-14);\n-            Assert.assertEquals( cos, y[1].getPartialDerivative(1), 5.0e-14);\n-            Assert.assertEquals(-cos, y[0].getPartialDerivative(2), 6.0e-12);\n-            Assert.assertEquals(-sin, y[1].getPartialDerivative(2), 6.0e-12);\n+            Assert.assertEquals( cos, y[0].getValue(), 7.0e-16);\n+            Assert.assertEquals( sin, y[1].getValue(), 7.0e-16);\n+            Assert.assertEquals(-sin, y[0].getPartialDerivative(1), 6.0e-14);\n+            Assert.assertEquals( cos, y[1].getPartialDerivative(1), 6.0e-14);\n+            Assert.assertEquals(-cos, y[0].getPartialDerivative(2), 2.0e-11);\n+            Assert.assertEquals(-sin, y[1].getPartialDerivative(2), 2.0e-11);\n         }\n \n     }\n             double cosh = FastMath.cosh(x);\n             double sinh = FastMath.sinh(x);\n             Assert.assertEquals(cos,   y[0][0].getValue(), 7.0e-18);\n-            Assert.assertEquals(sin,   y[0][1].getValue(), 7.0e-18);\n+            Assert.assertEquals(sin,   y[0][1].getValue(), 6.0e-17);\n             Assert.assertEquals(cosh,  y[1][0].getValue(), 3.0e-16);\n             Assert.assertEquals(sinh,  y[1][1].getValue(), 3.0e-16);\n             Assert.assertEquals(-sin,  y[0][0].getPartialDerivative(1), 2.0e-14);\n         UnivariateDifferentiableFunction f =\n                 differentiator.differentiate(sine);\n         double[] expectedError = new double[] {\n-            1.110e-16, 2.66e-12, 4.803e-9, 5.486e-5\n+            6.696e-16, 1.371e-12, 2.007e-8, 1.754e-5\n         };\n         double[] maxError = new double[expectedError.length];\n        for (double x = -2; x < 2; x += 0.1) {", "timestamp": 1354479829, "metainfo": ""}