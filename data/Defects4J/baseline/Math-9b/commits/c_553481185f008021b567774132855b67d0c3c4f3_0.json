{"sha": "553481185f008021b567774132855b67d0c3c4f3", "log": "Code cleanup: Removed \"wantu\" and \"wantv\" that were unconditionally set to \"true\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n         final double[][] V = new double[n][n];\n         final double[] e = new double[n];\n         final double[] work = new double[m];\n-        boolean wantu = true;\n-        boolean wantv = true;\n         // Reduce A to bidiagonal form, storing the diagonal elements\n         // in s and the super-diagonal elements in e.\n         final int nct = FastMath.min(m - 1, n);\n                 // subsequent calculation of the row transformation.\n                 e[j] = A[k][j];\n             }\n-            if (wantu &&\n-                k < nct) {\n+            if (k < nct) {\n                 // Place the transformation in U for subsequent back\n                 // multiplication.\n                 for (int i = k; i < m; i++) {\n                         }\n                     }\n                 }\n-                if (wantv) {\n-                    // Place the transformation in V for subsequent\n-                    // back multiplication.\n-                    for (int i = k + 1; i < n; i++) {\n-                        V[i][k] = e[i];\n-                    }\n+\n+                // Place the transformation in V for subsequent\n+                // back multiplication.\n+                for (int i = k + 1; i < n; i++) {\n+                    V[i][k] = e[i];\n                 }\n             }\n         }\n             e[nrt] = A[nrt][p - 1];\n         }\n         e[p - 1] = 0.0;\n-        // If required, generate U.\n-        if (wantu) {\n-            for (int j = nct; j < nu; j++) {\n+\n+        // Generate U.\n+        for (int j = nct; j < nu; j++) {\n+            for (int i = 0; i < m; i++) {\n+                U[i][j] = 0.0;\n+            }\n+            U[j][j] = 1.0;\n+        }\n+        for (int k = nct - 1; k >= 0; k--) {\n+            if (singularValues[k] != 0.0) {\n+                for (int j = k + 1; j < nu; j++) {\n+                    double t = 0;\n+                    for (int i = k; i < m; i++) {\n+                        t += U[i][k] * U[i][j];\n+                    }\n+                    t = -t / U[k][k];\n+                    for (int i = k; i < m; i++) {\n+                        U[i][j] += t * U[i][k];\n+                    }\n+                }\n+                for (int i = k; i < m; i++) {\n+                    U[i][k] = -U[i][k];\n+                }\n+                U[k][k] = 1.0 + U[k][k];\n+                for (int i = 0; i < k - 1; i++) {\n+                    U[i][k] = 0.0;\n+                }\n+            } else {\n                 for (int i = 0; i < m; i++) {\n-                    U[i][j] = 0.0;\n-                }\n-                U[j][j] = 1.0;\n-            }\n-            for (int k = nct - 1; k >= 0; k--) {\n-                if (singularValues[k] != 0.0) {\n-                    for (int j = k + 1; j < nu; j++) {\n-                        double t = 0;\n-                        for (int i = k; i < m; i++) {\n-                            t += U[i][k] * U[i][j];\n-                        }\n-                        t = -t / U[k][k];\n-                        for (int i = k; i < m; i++) {\n-                            U[i][j] += t * U[i][k];\n-                        }\n-                    }\n-                    for (int i = k; i < m; i++) {\n-                        U[i][k] = -U[i][k];\n-                    }\n-                    U[k][k] = 1.0 + U[k][k];\n-                    for (int i = 0; i < k - 1; i++) {\n-                        U[i][k] = 0.0;\n-                    }\n-                } else {\n-                    for (int i = 0; i < m; i++) {\n-                        U[i][k] = 0.0;\n-                    }\n-                    U[k][k] = 1.0;\n-                }\n-            }\n-        }\n-        // If required, generate V.\n-        if (wantv) {\n-            for (int k = n - 1; k >= 0; k--) {\n-                if (k < nrt &&\n-                    e[k] != 0) {\n-                    for (int j = k + 1; j < nu; j++) {\n-                        double t = 0;\n-                        for (int i = k + 1; i < n; i++) {\n-                            t += V[i][k] * V[i][j];\n-                        }\n-                        t = -t / V[k + 1][k];\n-                        for (int i = k + 1; i < n; i++) {\n-                            V[i][j] += t * V[i][k];\n-                        }\n-                    }\n-                }\n-                for (int i = 0; i < n; i++) {\n-                    V[i][k] = 0.0;\n-                }\n-                V[k][k] = 1.0;\n-            }\n-        }\n+                    U[i][k] = 0.0;\n+                }\n+                U[k][k] = 1.0;\n+            }\n+        }\n+\n+        // Generate V.\n+        for (int k = n - 1; k >= 0; k--) {\n+            if (k < nrt &&\n+                e[k] != 0) {\n+                for (int j = k + 1; j < nu; j++) {\n+                    double t = 0;\n+                    for (int i = k + 1; i < n; i++) {\n+                        t += V[i][k] * V[i][j];\n+                    }\n+                    t = -t / V[k + 1][k];\n+                    for (int i = k + 1; i < n; i++) {\n+                        V[i][j] += t * V[i][k];\n+                    }\n+                }\n+            }\n+            for (int i = 0; i < n; i++) {\n+                V[i][k] = 0.0;\n+            }\n+            V[k][k] = 1.0;\n+        }\n+\n         // Main iteration loop for the singular values.\n         final int pp = p - 1;\n         int iter = 0;\n                             f = -sn * e[j - 1];\n                             e[j - 1] = cs * e[j - 1];\n                         }\n-                        if (wantv) {\n-                            for (int i = 0; i < n; i++) {\n-                                t = cs * V[i][j] + sn * V[i][p - 1];\n-                                V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n-                                V[i][j] = t;\n-                            }\n+\n+                        for (int i = 0; i < n; i++) {\n+                            t = cs * V[i][j] + sn * V[i][p - 1];\n+                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n+                            V[i][j] = t;\n                         }\n                     }\n                 }\n                         singularValues[j] = t;\n                         f = -sn * e[j];\n                         e[j] = cs * e[j];\n-                        if (wantu) {\n-                            for (int i = 0; i < m; i++) {\n-                                t = cs * U[i][j] + sn * U[i][k - 1];\n-                                U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n-                                U[i][j] = t;\n-                            }\n+\n+                        for (int i = 0; i < m; i++) {\n+                            t = cs * U[i][j] + sn * U[i][k - 1];\n+                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n+                            U[i][j] = t;\n                         }\n                     }\n                 }\n                         e[j] = cs * e[j] - sn * singularValues[j];\n                         g = sn * singularValues[j + 1];\n                         singularValues[j + 1] = cs * singularValues[j + 1];\n-                        if (wantv) {\n-                            for (int i = 0; i < n; i++) {\n-                                t = cs * V[i][j] + sn * V[i][j + 1];\n-                                V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n-                                V[i][j] = t;\n-                            }\n+\n+                        for (int i = 0; i < n; i++) {\n+                            t = cs * V[i][j] + sn * V[i][j + 1];\n+                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n+                            V[i][j] = t;\n                         }\n                         t = FastMath.hypot(f, g);\n                         cs = f / t;\n                         singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n                         g = sn * e[j + 1];\n                         e[j + 1] = cs * e[j + 1];\n-                        if (wantu &&\n-                            j < m - 1) {\n+                        if (j < m - 1) {\n                             for (int i = 0; i < m; i++) {\n                                 t = cs * U[i][j] + sn * U[i][j + 1];\n                                 U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n                     // Make the singular values positive.\n                     if (singularValues[k] <= 0.0) {\n                         singularValues[k] = singularValues[k] < 0.0 ? -singularValues[k] : 0.0;\n-                        if (wantv) {\n-                            for (int i = 0; i <= pp; i++) {\n-                                V[i][k] = -V[i][k];\n-                            }\n+\n+                        for (int i = 0; i <= pp; i++) {\n+                            V[i][k] = -V[i][k];\n                         }\n                     }\n                     // Order the singular values.\n                         double t = singularValues[k];\n                         singularValues[k] = singularValues[k + 1];\n                         singularValues[k + 1] = t;\n-                        if (wantv &&\n-                            k < n - 1) {\n+                        if (k < n - 1) {\n                             for (int i = 0; i < n; i++) {\n                                 t = V[i][k + 1];\n                                 V[i][k + 1] = V[i][k];\n                                 V[i][k] = t;\n                             }\n                         }\n-                        if (wantu &&\n-                            k < m - 1) {\n+                        if (k < m - 1) {\n                             for (int i = 0; i < m; i++) {\n                                 t = U[i][k + 1];\n                                 U[i][k + 1] = U[i][k];", "timestamp": 1313188933, "metainfo": ""}