{"sha": "5a3c5f2f87367f3bf9a2a1e0b8a1926c11f174e0", "log": "MATH-599 Renamed \"AllowedSolutions\" to \"AllowedSolution\".   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/AllowedSolution.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.analysis.solvers;\n+\n+\n+/** The kinds of solutions that a {@link BracketedUnivariateRealSolver\n+ * (bracketed univariate real) root-finding algorithm} may accept as solutions.\n+ * This basically controls whether or not under-approximations and\n+ * over-approximations are allowed.\n+ *\n+ * <p>If all solutions are accepted ({@link #ANY_SIDE}), then the solution\n+ * that the root-finding algorithm returns for a given root may be equal to the\n+ * actual root, but it may also be an approximation that is slightly smaller\n+ * or slightly larger than the actual root. Root-finding algorithms generally\n+ * only guarantee that the returned solution is within the requested\n+ * tolerances. In certain cases however, in particular for\n+ * {@link org.apache.commons.math.ode.events.EventHandler state events} of\n+ * {@link org.apache.commons.math.ode.ODEIntegrator ODE solvers}, it\n+ * may be necessary to guarantee that a solution is returned that lies on a\n+ * specific side the solution.</p>\n+ *\n+ * @see BracketedUnivariateRealSolver\n+ * @since 3.0\n+ * @version $Id$\n+ */\n+public enum AllowedSolution {\n+    /** There are no additional side restriction on the solutions for\n+     * root-finding. That is, both under-approximations and over-approximations\n+     * are allowed. So, if a function f(x) has a root at x = x0, then the\n+     * root-finding result s may be smaller than x0, equal to x0, or greater\n+     * than x0.\n+     */\n+    ANY_SIDE,\n+\n+    /** Only solutions that are less than or equal to the actual root are\n+     * acceptable as solutions for root-finding. In other words,\n+     * over-approximations are not allowed. So, if a function f(x) has a root\n+     * at x = x0, then the root-finding result s must satisfy s &lt;= x0.\n+     */\n+    LEFT_SIDE,\n+\n+    /** Only solutions that are greater than or equal to the actual root are\n+     * acceptable as solutions for root-finding. In other words,\n+     * under-approximations are not allowed. So, if a function f(x) has a root\n+     * at x = x0, then the root-finding result s must satisfy s &gt;= x0.\n+     */\n+    RIGHT_SIDE,\n+\n+    /** Only solutions for which values are less than or equal to zero are\n+     * acceptable as solutions for root-finding. So, if a function f(x) has\n+     * a root at x = x0, then the root-finding result s must satisfy f(s) &lt;= 0.\n+     */\n+    BELOW_SIDE,\n+\n+    /** Only solutions for which values are greater than or equal to zero are\n+     * acceptable as solutions for root-finding. So, if a function f(x) has\n+     * a root at x = x0, then the root-finding result s must satisfy f(s) &gt;= 0.\n+     */\n+    ABOVE_SIDE;\n+\n+}\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n     protected static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n \n     /** The kinds of solutions that the algorithm may accept. */\n-    private AllowedSolutions allowed;\n+    private AllowedSolution allowed;\n \n     /** The <em>Secant</em>-based root-finding method to use. */\n     private final Method method;\n      */\n     protected BaseSecantSolver(final double absoluteAccuracy, final Method method) {\n         super(absoluteAccuracy);\n-        this.allowed = AllowedSolutions.ANY_SIDE;\n+        this.allowed = AllowedSolution.ANY_SIDE;\n         this.method = method;\n     }\n \n                                final double absoluteAccuracy,\n                                final Method method) {\n         super(relativeAccuracy, absoluteAccuracy);\n-        this.allowed = AllowedSolutions.ANY_SIDE;\n+        this.allowed = AllowedSolution.ANY_SIDE;\n         this.method = method;\n     }\n \n                                final double functionValueAccuracy,\n                                final Method method) {\n         super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n-        this.allowed = AllowedSolutions.ANY_SIDE;\n+        this.allowed = AllowedSolution.ANY_SIDE;\n         this.method = method;\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final int maxEval, final UnivariateRealFunction f,\n                         final double min, final double max,\n-                        final AllowedSolutions allowedSolutions) {\n-        return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolutions);\n+                        final AllowedSolution allowedSolution) {\n+        return solve(maxEval, f, min, max, min + 0.5 * (max - min), allowedSolution);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(final int maxEval, final UnivariateRealFunction f,\n                         final double min, final double max, final double startValue,\n-                        final AllowedSolutions allowedSolutions) {\n-        this.allowed = allowedSolutions;\n+                        final AllowedSolution allowedSolution) {\n+        this.allowed = allowedSolution;\n         return super.solve(maxEval, f, min, max, startValue);\n     }\n \n     @Override\n     public double solve(final int maxEval, final UnivariateRealFunction f,\n                         final double min, final double max, final double startValue) {\n-        return solve(maxEval, f, min, max, startValue, AllowedSolutions.ANY_SIDE);\n+        return solve(maxEval, f, min, max, startValue, AllowedSolution.ANY_SIDE);\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketedUnivariateRealSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketedUnivariateRealSolver.java\n  *      return roots that are greater than or equal to the actual root, or\n  *      are less than or equal to the actual root. That is, we can control\n  *      whether under-approximations and over-approximations are\n- *      {@link AllowedSolutions allowed solutions}. Other root-finding\n+ *      {@link AllowedSolution allowed solutions}. Other root-finding\n  *      algorithms can usually only guarantee that the solution (the root that\n  *      was found) is around the actual root.</li>\n  * </ul>\n  *\n  * <p>For backwards compatibility, all root-finding algorithms must have\n- * {@link AllowedSolutions#ANY_SIDE ANY_SIDE} as default for the allowed\n+ * {@link AllowedSolution#ANY_SIDE ANY_SIDE} as default for the allowed\n  * solutions.</p>\n  * @param <FUNC> Type of function to solve.\n  *\n- * @see AllowedSolutions\n+ * @see AllowedSolution\n  * @since 3.0\n  * @version $Id$\n  */\n      * @param f Function to solve.\n      * @param min Lower bound for the interval.\n      * @param max Upper bound for the interval.\n-     * @param allowedSolutions The kind of solutions that the root-finding algorithm may\n+     * @param allowedSolution The kind of solutions that the root-finding algorithm may\n      * accept as solutions.\n      * @return A value where the function is zero.\n      * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n      * the allowed number of evaluations is exceeded.\n      */\n     double solve(int maxEval, FUNC f, double min, double max,\n-                 AllowedSolutions allowedSolutions);\n+                 AllowedSolution allowedSolution);\n \n     /**\n      * Solve for a zero in the given interval, start at {@code startValue}.\n      * @param min Lower bound for the interval.\n      * @param max Upper bound for the interval.\n      * @param startValue Start value to use.\n-     * @param allowedSolutions The kind of solutions that the root-finding algorithm may\n+     * @param allowedSolution The kind of solutions that the root-finding algorithm may\n      * accept as solutions.\n      * @return A value where the function is zero.\n      * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n      * the allowed number of evaluations is exceeded.\n      */\n     double solve(int maxEval, FUNC f, double min, double max, double startValue,\n-                 AllowedSolutions allowedSolutions);\n+                 AllowedSolution allowedSolution);\n \n }\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n  * The changes with respect to the original Brent algorithm are:\n  * <ul>\n  *   <li>the returned value is chosen in the current interval according\n- *   to user specified {@link AllowedSolutions},</li>\n+ *   to user specified {@link AllowedSolution},</li>\n  *   <li>the maximal order for the invert polynomial root search is\n  *   user-specified instead of being invert quadratic only</li>\n  * </ul>\n     private final int maximalOrder;\n \n     /** The kinds of solutions that the algorithm may accept. */\n-    private AllowedSolutions allowed;\n+    private AllowedSolution allowed;\n \n     /**\n      * Construct a solver with default accuracy and maximal order (1e-6 and 5 respectively)\n             throw new NumberIsTooSmallException(maximalOrder, 2, true);\n         }\n         this.maximalOrder = maximalOrder;\n-        this.allowed = AllowedSolutions.ANY_SIDE;\n+        this.allowed = AllowedSolution.ANY_SIDE;\n     }\n \n     /**\n             throw new NumberIsTooSmallException(maximalOrder, 2, true);\n         }\n         this.maximalOrder = maximalOrder;\n-        this.allowed = AllowedSolutions.ANY_SIDE;\n+        this.allowed = AllowedSolution.ANY_SIDE;\n     }\n \n     /**\n             throw new NumberIsTooSmallException(maximalOrder, 2, true);\n         }\n         this.maximalOrder = maximalOrder;\n-        this.allowed = AllowedSolutions.ANY_SIDE;\n+        this.allowed = AllowedSolution.ANY_SIDE;\n     }\n \n     /** Get the maximal order.\n \n     /** {@inheritDoc} */\n     public double solve(int maxEval, UnivariateRealFunction f, double min,\n-                        double max, AllowedSolutions allowedSolutions) {\n-        this.allowed = allowedSolutions;\n+                        double max, AllowedSolution allowedSolution) {\n+        this.allowed = allowedSolution;\n         return super.solve(maxEval, f, min, max);\n     }\n \n     /** {@inheritDoc} */\n     public double solve(int maxEval, UnivariateRealFunction f, double min,\n                         double max, double startValue,\n-                        AllowedSolutions allowedSolutions) {\n-        this.allowed = allowedSolutions;\n+                        AllowedSolution allowedSolution) {\n+        this.allowed = allowedSolution;\n         return super.solve(maxEval, f, min, max, startValue);\n     }\n \n--- a/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n      * @param baseRoot original root found by a previous non-bracketing solver\n      * @param min minimal bound of the search interval\n      * @param max maximal bound of the search interval\n-     * @param allowedSolutions the kind of solutions that the root-finding algorithm may\n+     * @param allowedSolution the kind of solutions that the root-finding algorithm may\n      * accept as solutions.\n      * @return a root approximation, on the specified side of the exact root\n      */\n     public static double forceSide(final int maxEval, final UnivariateRealFunction f,\n                                    final BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing,\n                                    final double baseRoot, final double min, final double max,\n-                                   final AllowedSolutions allowedSolutions) {\n-\n-        if (allowedSolutions == AllowedSolutions.ANY_SIDE) {\n+                                   final AllowedSolution allowedSolution) {\n+\n+        if (allowedSolution == AllowedSolution.ANY_SIDE) {\n             // no further bracketing required\n             return baseRoot;\n         }\n \n             if ((fLo >= 0 && fHi <= 0) || (fLo <= 0 && fHi >= 0)) {\n                 // compute the root on the selected side\n-                return bracketing.solve(remainingEval, f, xLo, xHi, baseRoot, allowedSolutions);\n+                return bracketing.solve(remainingEval, f, xLo, xHi, baseRoot, allowedSolution);\n             }\n \n             // try increasing the interval\n--- a/src/main/java/org/apache/commons/math/dfp/BracketingNthOrderBrentSolverDFP.java\n+++ b/src/main/java/org/apache/commons/math/dfp/BracketingNthOrderBrentSolverDFP.java\n package org.apache.commons.math.dfp;\n \n \n-import org.apache.commons.math.analysis.solvers.AllowedSolutions;\n+import org.apache.commons.math.analysis.solvers.AllowedSolution;\n import org.apache.commons.math.exception.MathInternalError;\n import org.apache.commons.math.exception.NoBracketingException;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n  * The changes with respect to the original Brent algorithm are:\n  * <ul>\n  *   <li>the returned value is chosen in the current interval according\n- *   to user specified {@link AllowedSolutions},</li>\n+ *   to user specified {@link AllowedSolution},</li>\n  *   <li>the maximal order for the invert polynomial root search is\n  *   user-specified instead of being invert quadratic only</li>\n  * </ul>\n      * @param f Function to solve.\n      * @param min Lower bound for the interval.\n      * @param max Upper bound for the interval.\n-     * @param allowedSolutions The kind of solutions that the root-finding algorithm may\n+     * @param allowedSolution The kind of solutions that the root-finding algorithm may\n      * accept as solutions.\n      * @return a value where the function is zero.\n      * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n      * the allowed number of evaluations is exceeded.\n      */\n     public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n-                     final Dfp min, final Dfp max, final AllowedSolutions allowedSolutions) {\n-        return solve(maxEval, f, min, max, min.add(max).divide(2), allowedSolutions);\n+                     final Dfp min, final Dfp max, final AllowedSolution allowedSolution) {\n+        return solve(maxEval, f, min, max, min.add(max).divide(2), allowedSolution);\n     }\n \n     /**\n      * @param min Lower bound for the interval.\n      * @param max Upper bound for the interval.\n      * @param startValue Start value to use.\n-     * @param allowedSolutions The kind of solutions that the root-finding algorithm may\n+     * @param allowedSolution The kind of solutions that the root-finding algorithm may\n      * accept as solutions.\n      * @return a value where the function is zero.\n      * @throws org.apache.commons.math.exception.MathIllegalArgumentException\n      */\n     public Dfp solve(final int maxEval, final UnivariateDfpFunction f,\n                      final Dfp min, final Dfp max, final Dfp startValue,\n-                     final AllowedSolutions allowedSolutions) {\n+                     final AllowedSolution allowedSolution) {\n \n         // Checks.\n         MathUtils.checkNotNull(f);\n             final Dfp xTol = absoluteAccuracy.add(relativeAccuracy.multiply(maxX));\n             if (xB.subtract(xA).subtract(xTol).negativeOrNull() ||\n                 maxY.lessThan(functionValueAccuracy)) {\n-                switch (allowedSolutions) {\n+                switch (allowedSolution) {\n                 case ANY_SIDE :\n                     return absYA.lessThan(absYB) ? xA : xB;\n                 case LEFT_SIDE :\n--- a/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n \n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n-import org.apache.commons.math.analysis.solvers.AllowedSolutions;\n+import org.apache.commons.math.analysis.solvers.AllowedSolution;\n import org.apache.commons.math.analysis.solvers.BracketedUnivariateRealSolver;\n import org.apache.commons.math.analysis.solvers.PegasusSolver;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolver;\n                         BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\n                                 (BracketedUnivariateRealSolver<UnivariateRealFunction>) solver;\n                         root = forward ?\n-                               bracketing.solve(maxIterationCount, f, ta, tb, AllowedSolutions.RIGHT_SIDE) :\n-                               bracketing.solve(maxIterationCount, f, tb, ta, AllowedSolutions.LEFT_SIDE);\n+                               bracketing.solve(maxIterationCount, f, ta, tb, AllowedSolution.RIGHT_SIDE) :\n+                               bracketing.solve(maxIterationCount, f, tb, ta, AllowedSolution.LEFT_SIDE);\n                     } else {\n                         final double baseRoot = forward ?\n                                                 solver.solve(maxIterationCount, f, ta, tb) :\n                                 new PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy());\n                         root = forward ?\n                                UnivariateRealSolverUtils.forceSide(remainingEval, f, bracketing,\n-                                                                   baseRoot, ta, tb, AllowedSolutions.RIGHT_SIDE) :\n+                                                                   baseRoot, ta, tb, AllowedSolution.RIGHT_SIDE) :\n                                UnivariateRealSolverUtils.forceSide(remainingEval, f, bracketing,\n-                                                                   baseRoot, tb, ta, AllowedSolutions.LEFT_SIDE);\n+                                                                   baseRoot, tb, ta, AllowedSolution.LEFT_SIDE);\n                     }\n \n                     if ((!Double.isNaN(previousEventTime)) &&\n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BaseSecantSolverAbstractTest.java\n         double right = 0.05;\n         for(int i = 0; i < 10; i++) {\n             // Test whether the allowed solutions are taken into account.\n-            double solution = getSolution(solver, 100, f, left, right, AllowedSolutions.LEFT_SIDE);\n+            double solution = getSolution(solver, 100, f, left, right, AllowedSolution.LEFT_SIDE);\n             if (!Double.isNaN(solution)) {\n                 Assert.assertTrue(solution <= 0.0);\n             }\n         double right = 0.05;\n         for(int i = 0; i < 10; i++) {\n             // Test whether the allowed solutions are taken into account.\n-            double solution = getSolution(solver, 100, f, left, right, AllowedSolutions.RIGHT_SIDE);\n+            double solution = getSolution(solver, 100, f, left, right, AllowedSolution.RIGHT_SIDE);\n             if (!Double.isNaN(solution)) {\n                 Assert.assertTrue(solution >= 0.0);\n             }\n         double right = 0.05;\n         for(int i = 0; i < 10; i++) {\n             // Test whether the allowed solutions are taken into account.\n-            double solution = getSolution(solver, 100, f, left, right, AllowedSolutions.BELOW_SIDE);\n+            double solution = getSolution(solver, 100, f, left, right, AllowedSolution.BELOW_SIDE);\n             if (!Double.isNaN(solution)) {\n                 Assert.assertTrue(f.value(solution) <= 0.0);\n             }\n         double right = 0.05;\n         for(int i = 0; i < 10; i++) {\n             // Test whether the allowed solutions are taken into account.\n-            double solution = getSolution(solver, 100, f, left, right, AllowedSolutions.ABOVE_SIDE);\n+            double solution = getSolution(solver, 100, f, left, right, AllowedSolution.ABOVE_SIDE);\n             if (!Double.isNaN(solution)) {\n                 Assert.assertTrue(f.value(solution) >= 0.0);\n             }\n     }\n \n     private double getSolution(UnivariateRealSolver solver, int maxEval, UnivariateRealFunction f,\n-                               double left, double right, AllowedSolutions allowedSolutions) {\n+                               double left, double right, AllowedSolution allowedSolution) {\n         try {\n             @SuppressWarnings(\"unchecked\")\n             BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\n             (BracketedUnivariateRealSolver<UnivariateRealFunction>) solver;\n-            return bracketing.solve(100, f, left, right, allowedSolutions);\n+            return bracketing.solve(100, f, left, right, allowedSolution);\n         } catch (ClassCastException cce) {\n             double baseRoot = solver.solve(maxEval, f, left, right);\n             if ((baseRoot <= left) || (baseRoot >= right)) {\n                                       solver.getFunctionValueAccuracy());\n             return UnivariateRealSolverUtils.forceSide(maxEval - solver.getEvaluations(),\n                                                        f, bracketing, baseRoot, left, right,\n-                                                       allowedSolutions);\n+                                                       allowedSolution);\n         }\n     }\n \n--- a/src/test/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolverTest.java\n         BracketingNthOrderBrentSolver solver =\n                 new BracketingNthOrderBrentSolver(1.0e-12, 1.0e-10, 0.001, 3);\n         QuinticFunction f = new QuinticFunction();\n-        double result = solver.solve(20, f, 0.2, 0.9, 0.4, AllowedSolutions.BELOW_SIDE);\n+        double result = solver.solve(20, f, 0.2, 0.9, 0.4, AllowedSolution.BELOW_SIDE);\n         Assert.assertEquals(0, f.value(result), solver.getFunctionValueAccuracy());\n         Assert.assertTrue(f.value(result) <= 0);\n         Assert.assertTrue(result - 0.5 > solver.getAbsoluteAccuracy());\n-        result = solver.solve(20, f, -0.9, -0.2,  -0.4, AllowedSolutions.ABOVE_SIDE);\n+        result = solver.solve(20, f, -0.9, -0.2,  -0.4, AllowedSolution.ABOVE_SIDE);\n         Assert.assertEquals(0, f.value(result), solver.getFunctionValueAccuracy());\n         Assert.assertTrue(f.value(result) >= 0);\n         Assert.assertTrue(result + 0.5 < -solver.getAbsoluteAccuracy());\n--- a/src/test/java/org/apache/commons/math/dfp/BracketingNthOrderBrentSolverDFPTest.java\n+++ b/src/test/java/org/apache/commons/math/dfp/BracketingNthOrderBrentSolverDFPTest.java\n \n package org.apache.commons.math.dfp;\n \n-import org.apache.commons.math.analysis.solvers.AllowedSolutions;\n+import org.apache.commons.math.analysis.solvers.AllowedSolution;\n import org.apache.commons.math.exception.MathInternalError;\n import org.apache.commons.math.exception.NumberIsTooSmallException;\n import org.junit.Assert;\n         };\n \n         Dfp result = solver.solve(20, f, field.newDfp(0.2), field.newDfp(0.9),\n-                                  field.newDfp(0.4), AllowedSolutions.BELOW_SIDE);\n+                                  field.newDfp(0.4), AllowedSolution.BELOW_SIDE);\n         Assert.assertTrue(f.value(result).abs().lessThan(solver.getFunctionValueAccuracy()));\n         Assert.assertTrue(f.value(result).negativeOrNull());\n         Assert.assertTrue(result.subtract(field.newDfp(0.5)).subtract(solver.getAbsoluteAccuracy()).positiveOrNull());\n         result = solver.solve(20, f, field.newDfp(-0.9), field.newDfp(-0.2),\n-                              field.newDfp(-0.4), AllowedSolutions.ABOVE_SIDE);\n+                              field.newDfp(-0.4), AllowedSolution.ABOVE_SIDE);\n         Assert.assertTrue(f.value(result).abs().lessThan(solver.getFunctionValueAccuracy()));\n         Assert.assertTrue(f.value(result).positiveOrNull());\n         Assert.assertTrue(result.add(field.newDfp(0.5)).subtract(solver.getAbsoluteAccuracy()).negativeOrNull());\n         // \"Several New Methods for solving Equations\"\n         // intern J. Computer Math Vol 23 pp 265-282\n         // available here: http://www.math.nps.navy.mil/~bneta/SeveralNewMethods.PDF\n-        for (AllowedSolutions allowed : AllowedSolutions.values()) {\n+        for (AllowedSolution allowed : AllowedSolution.values()) {\n             check(new UnivariateDfpFunction() {\n                 public Dfp value(Dfp x) {\n                     return DfpMath.sin(x).subtract(x.divide(2));\n     }\n \n     private void check(UnivariateDfpFunction f, int maxEval, double min, double max,\n-                       AllowedSolutions allowedSolutions) {\n+                       AllowedSolution allowedSolution) {\n         BracketingNthOrderBrentSolverDFP solver =\n                 new BracketingNthOrderBrentSolverDFP(relativeAccuracy, absoluteAccuracy,\n                                                      functionValueAccuracy, 20);\n         Dfp xResult = solver.solve(maxEval, f, field.newDfp(min), field.newDfp(max),\n-                                   allowedSolutions);\n+                                   allowedSolution);\n         Dfp yResult = f.value(xResult);\n-        switch (allowedSolutions) {\n+        switch (allowedSolution) {\n         case ANY_SIDE :\n             Assert.assertTrue(yResult.abs().lessThan(functionValueAccuracy.multiply(2)));\n             break;", "timestamp": 1312147659, "metainfo": ""}