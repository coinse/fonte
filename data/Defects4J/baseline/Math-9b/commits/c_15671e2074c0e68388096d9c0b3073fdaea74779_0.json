{"sha": "15671e2074c0e68388096d9c0b3073fdaea74779", "log": "Checkstyle errors.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/PowellOptimizer.java\n \n     /**\n      * Java 1.5 does not support Arrays.copyOf()\n-     * \n-     * @param source the array to be copied\n-     * @param newLen the length of the copy to be returned\n+     *\n+     * @param source Array to be copied.\n+     * @param newLen Length of the copy to be returned.\n      * @return the copied array, truncated or padded as necessary.\n      */\n      private double[] copyOf(double[] source, int newLen) {\n          System.arraycopy(source, 0, output, 0, Math.min(source.length, newLen));\n          return output;\n      }\n-\n }\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n         (0xc90fdaa2L << 32) | 0x2168c234L,\n         (0xc4c6628bL << 32) | 0x80dc1cd1L };\n \n-    /** Eighthes.\n+    /** Eighths.\n      * This is used by sinQ, because its faster to do a table lookup than\n      * a multiply in this time-critical routine\n      */\n     private static final double EIGHTHES[] = {0, 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.0, 1.125, 1.25, 1.375, 1.5, 1.625};\n \n-    /* Table of 2^((n+2)/3) */\n+    /** Table of 2^((n+2)/3) */\n     private static final double CBRTTWO[] = { 0.6299605249474366,\n-                                            0.7937005259840998, \n-                                            1.0, \n-                                            1.2599210498948732, \n+                                            0.7937005259840998,\n+                                            1.0,\n+                                            1.2599210498948732,\n                                             1.5874010519681994 };\n \n     // Initialize tables\n           double yb = -(ya - hiPrec[0] - hiPrec[1]);\n \n           /* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\n-          double denom = 1.0+ya;\n-          double denomr = 1.0/denom;\n+          double denom = 1.0 + ya;\n+          double denomr = 1.0 / denom;\n           double denomb = -(denom - 1.0 - ya) + yb;\n-          double ratio = ya*denomr;\n-          double ra, rb;\n+          double ratio = ya * denomr;\n           double temp = ratio * 1073741824.0;\n-          ra = ratio + temp - temp;\n-          rb = ratio - ra;\n+          double ra = ratio + temp - temp;\n+          double rb = ratio - ra;\n \n           temp = denom * 1073741824.0;\n           double za = denom + temp - temp;\n \n           result = ratioa + ratiob;\n       }\n-      \n+\n       if (negate) {\n           result = -result;\n       }\n \n     /** Internal helper method for expm1\n      * @param x number to compute shifted exponential\n-     * @param hiPrecOut[] receive high precision result for -1.0 < x < 1.0\n+     * @param hiPrecOut receive high precision result for -1.0 < x < 1.0\n      * @return exp(x) - 1\n      */\n     private static double expm1(double x, double hiPrecOut[]) {\n             yb = -rb;\n         }\n \n-\tif (hiPrecOut != null) {\n-\t  hiPrecOut[0] = ya;\n-\t  hiPrecOut[1] = yb;\n-\t}\n+        if (hiPrecOut != null) {\n+            hiPrecOut[0] = ya;\n+            hiPrecOut[1] = yb;\n+        }\n \n         return ya + yb;\n     }\n       int exp3 = exponent / 3;\n \n       /* p2 will be the nearest power of 2 to x with its exponent divided by 3 */\n-      double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) | \n+      double p2 = Double.longBitsToDouble((inbits & 0x8000000000000000L) |\n                                           (long)(((exp3 + 1023) & 0x7ff)) << 52);\n \n       /* This will be a number between 1 and 2 */\n       final double mant = Double.longBitsToDouble((inbits & 0x000fffffffffffffL) | 0x3ff0000000000000L);\n-      \n+\n       /* Estimate the cube root of mant by polynomial */\n       double est = -0.010714690733195933;\n       est = est * mant + 0.0875862700108075;\n \n       est *= CBRTTWO[exponent % 3 + 2];\n \n-      // est should now be good to about 15 bits of precision.   Do 2 rounds of \n+      // est should now be good to about 15 bits of precision.   Do 2 rounds of\n       // Newton's method to get closer,  this should get us full double precision\n       // Scale down x for the purpose of doing newtons method.  This avoids over/under flows.\n-      final double xs = x / (p2*p2*p2); \n+      final double xs = x / (p2*p2*p2);\n       est += (xs - est*est*est) / (3*est*est);\n       est += (xs - est*est*est) / (3*est*est);\n \n       double zb = ya * yb * 2.0 + yb * yb;\n       temp = za * 1073741824.0;\n       double temp2 = za + temp - temp;\n-      zb += (za - temp2);\n+      zb += za - temp2;\n       za = temp2;\n \n       zb = za * yb + ya * zb + zb * yb;\n--- a/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n+++ b/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n \n     /**\n      * Java 1.5 does not support Arrays.copyOf()\n-     * \n-     * @param source the array to be copied\n-     * @param newLen the length of the copy to be returned\n+     *\n+     * @param source Array to be copied.\n+     * @param newLen Length of the copy to be returned.\n      * @return the copied array, truncated or padded as necessary.\n      */\n      private int[] copyOf(int[] source, int newLen) {\n          System.arraycopy(source, 0, output, 0, Math.min(source.length, newLen));\n          return output;\n      }\n-\n }", "timestamp": 1286371312, "metainfo": ""}