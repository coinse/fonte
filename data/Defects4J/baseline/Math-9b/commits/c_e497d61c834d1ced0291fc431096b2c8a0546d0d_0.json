{"sha": "e497d61c834d1ced0291fc431096b2c8a0546d0d", "log": "improved error messages  ", "commit": "\n--- a/src/java/org/apache/commons/math/MathRuntimeException.java\n+++ b/src/java/org/apache/commons/math/MathRuntimeException.java\n     }\n \n     /**\n+     * Constructs a new <code>IllegalArgumentException</code> with specified nested\n+     * <code>Throwable</code> root cause.\n+     * @param rootCause the exception or error that caused this exception\n+     * to be thrown.\n+     * @return built exception\n+     */\n+    public static IllegalArgumentException createIllegalArgumentException(final Throwable rootCause) {\n+        IllegalArgumentException iae = new IllegalArgumentException(rootCause.getLocalizedMessage());\n+        iae.initCause(rootCause);\n+        return iae;\n+    }\n+\n+    /**\n      * Constructs a new <code>IllegalStateException</code> with specified formatted detail message.\n      * Message formatting is delegated to {@link java.text.MessageFormat}.\n      * @param pattern format specifier\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n   private static final Object[][] contents = {\n \n     // org.apache.commons.math.util.MathUtils\n+    { \"must have n >= k for binomial coefficient (n,k), got n = {0}, k = {1}\",\n+      \"n doit \\u00eatre sup\\u00e9rieur ou \\u00e9gal \\u00e0 k \" +\n+      \"pour le coefficient du bin\\u00f4me (n,k), or n = {0}, k = {1}\" },\n+    { \"must have n >= 0 for binomial coefficient (n,k), got n = {0}\",\n+      \"n doit \\u00eatre positif pour le coefficient du bin\\u00f4me (n,k), or n = {0}\" },\n+    { \"must have n >= 0 for n!, got n = {0}\",\n+      \"n doit \\u00eatre positif pour le calcul de n!, or n = {0}\" },\n     { \"overflow: gcd({0}, {1}) is 2^31\",\n       \"d\\u00e9passement de capacit\\u00e9 : le PGCD de {0} et {1} vaut 2^31\" },\n     { \"cannot raise an integral value to a negative power ({0}^{1})\",\n-      \"impossible d''\\u00e9lever une valeur enti\\u00e8re \\u00e0 une puissance n\\u00e9gative ({0}^{1})\" },\n-        \n+      \"impossible d''\\u00e9lever une valeur enti\\u00e8re \" +\n+      \"\\u00e0 une puissance n\\u00e9gative ({0}^{1})\" },\n+    { \"invalid rounding method {0}, valid methods: {1} ({2}), {3} ({4}),\" +\n+       \" {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})\",\n+      \"m\\u00e9thode d''arondi {0} invalide, m\\u00e9thodes valides : {1} ({2}), {3} ({4}),\" +\n+       \" {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})\" },\n+\n     // org.apache.commons.math.FunctionEvaluationException\n     { \"evaluation failed for argument = {0}\",\n       \"erreur d''\\u00e9valuation pour l''argument {0}\" },\n     // org.apache.commons.math.optimization.LeastSquaresConverter\n     // org.apache.commons.math.optimization.direct.DirectSearchOptimizer\n     // org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer\n+    // org.apache.commons.math.ode.ContinuousOutputModel\n+    // org.apache.commons.math.random.UncorrelatedRandomVectorGenerator\n     { \"dimension mismatch {0} != {1}\",\n       \"dimensions incompatibles {0} != {1}\" },\n \n     // org.apache.commons.math.optimization.direct.DirectSearchOptimizer\n     { \"unexpected exception caught\",\n       \"exception inattendue lev\\u00e9e\" },\n+    { \"propagation direction mismatch\",\n+      \"directions de propagation incoh\\u00e9rentes\" },\n+    { \"{0} wide hole between models time ranges\",\n+      \"trou de longueur {0} entre les domaines temporels des mod\\u00e8les\" },\n \n     // org.apache.commons.math.optimization.direct.DirectSearchOptimizer\n     { \"none of the {0} start points lead to convergence\",\n       \"aucun des {0} points de d\\u00e9part n''aboutit \\u00e0 une convergence\"  },\n \n+    // org.apache.commons.math.random.ValueServer\n+    { \"unknown mode {0}, known modes: {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}) and {11} ({12})\",\n+      \"mode {0} inconnu, modes connus : {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}) et {11} ({12})\" },\n+    { \"digest not initialized\",\n+      \"mod\\u00e8le empirique non initialis\\u00e9\" },\n+\n     // org.apache.commons.math.random.EmpiricalDistributionImpl\n+    { \"distribution not loaded\",\n+      \"aucune distribution n''a \\u00e9t\\u00e9 charg\\u00e9e\" },\n     { \"no bin selected\",\n       \"aucun compartiment s\\u00e9lectionn\\u00e9\" },\n+    { \"input data comes from unsupported datasource: {0}, supported sources: {1}, {2}\",\n+      \"les donn\\u00e9es d''entr\\u00e9e proviennent \" +\n+      \"d''une source non support\\u00e9e : {0}, sources support\\u00e9es : {1}, {2}\" },\n+\n+    // org.apache.commons.math.random.EmpiricalDistributionImpl\n+    // org.apache.commons.math.random.ValueServer\n+    { \"URL {0} contains no data\",\n+      \"l''adresse {0} ne contient aucune donn\\u00e9e\" },\n+\n+    // org.apache.commons.math.random.AbstractRandomGenerator\n+    { \"upper bound must be positive ({0})\",\n+      \"la borne sup\\u00e9rieure doit \\u00eatre positive ({0})\" },\n+\n+    // org.apache.commons.math.random.RandomDataImpl\n+    { \"length must be positive ({0})\",\n+      \"la longueur doit \\u00eatre positive ({0})\" },\n+    { \"upper bound ({0}) must be greater than lower bound ({1})\",\n+      \"la borne sup\\u00e9rieure ({0}) doit \\u00eatre sup\\u00e9rieure\" +\n+      \" \\u00e0 la borne inf\\u00e9rieure ({1})\" },\n+    { \"permutation k ({0}) exceeds n ({1})\",\n+      \"la permutation k ({0}) d\\u00e9passe n ({1})\" },\n+    { \"permutation k ({0}) must be positive\",\n+      \"la permutation k ({0}) doit \\u00eatre positive\" },\n+    { \"sample size ({0}) exceeds collection size ({1})\",\n+      \"la taille de l''\\u00e9chantillon ({0}) d\\u00e9passe la taille de la collection ({1})\" },\n \n     // org.apache.commons.math.linear.decomposition.EigenDecompositionImpl\n     { \"cannot solve degree {0} equation\",\n       \"impossible de r\\u00e9soudre une \\u00e9quation de degr\\u00e9 {0}\" },\n     { \"eigen decomposition of assymetric matrices not supported yet\",\n-      \"la d\\u00e9composition en valeurs/vecteurs propres de matrices non sym\\u00e9triques n''est pas encore disponible\" },\n+      \"la d\\u00e9composition en valeurs/vecteurs propres de matrices \" +\n+      \"non sym\\u00e9triques n''est pas encore disponible\" },\n \n     // org.apache.commons.math.linear.decomposition.NonSquareMatrixException\n     { \"a {0}x{1} matrix was provided instead of a square matrix\",\n       \"une matrice doit comporter au moins une colonne\" },\n     { \"some rows have length {0} while others have length {1}\",\n       \"certaines lignes ont une longueur de {0} alors que d''autres ont une longueur de {1}\" },\n-    { \"{0}x{1} and {2}x{3} matrices are not addition compatible\",\n-      \"les dimensions {0}x{1} et {2}x{3} sont incompatibles pour l'addition matricielle\" },\n-    { \"{0}x{1} and {2}x{3} matrices are not subtraction compatible\",\n-      \"les dimensions {0}x{1} et {2}x{3} sont incompatibles pour la soustraction matricielle\" },\n-    { \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n-      \"les dimensions {0}x{1} et {2}x{3} sont incompatibles pour la multiplication matricielle\" },\n-\n-    // org.apache.commons.math.linear.DenseRealMatrix\n-    { \"wrong array shape (block length = {0}, expected {1})\",\n-      \"forme de tableau erron\\u00e9e (bloc de longueur {0} au lieu des {1} attendus)\" },\n-\n-    // org.apache.commons.math.linear.BigMatrixImpl\n-    // org.apache.commons.math.linear.RealMatrixImpl\n+\n+    // org.apache.commons.math.linear.MatrixUtils\n     { \"row index {0} out of allowed range [{1}, {2}]\",\n       \"index de ligne {0} hors de la plage autoris\\u00e9e [{1}, {2}]\" },\n     { \"column index {0} out of allowed range [{1}, {2}]\",\n       \"index de colonne {0} hors de la plage autoris\\u00e9e [{1}, {2}]\" },\n-    { \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n-      \"pas d''entr\\u00e9e aux indices ({0}, {1}) dans une matrice {2}x{3}\" },\n     { \"initial row {0} after final row {1}\",\n       \"ligne initiale {0} apr\\u00e8s la ligne finale {1}\" },\n     { \"initial column {0} after final column {1}\",\n       \"tableau des indices de lignes s\\u00e9lectionn\\u00e9es vide\" },\n     { \"empty selected column index array\",\n       \"tableau des indices de colonnes s\\u00e9lectionn\\u00e9es vide\" },\n-\n-   // org.apache.commons.math.random.EmpiricalDistributionImpl\n-   // org.apache.commons.math.random.ValueServer\n-   { \"URL {0} contains no data\",\n-     \"l''adresse {0} ne contient aucune donn\\u00e9e\" },\n-\n-   // org.apache.commons.math.complex.Complex\n-   { \"cannot compute nth root for null or negative n: {0}\",\n+    { \"{0}x{1} and {2}x{3} matrices are not addition compatible\",\n+      \"les dimensions {0}x{1} et {2}x{3} sont incompatibles pour l'addition matricielle\" },\n+    { \"{0}x{1} and {2}x{3} matrices are not subtraction compatible\",\n+      \"les dimensions {0}x{1} et {2}x{3} sont incompatibles pour la soustraction matricielle\" },\n+    { \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n+      \"les dimensions {0}x{1} et {2}x{3} sont incompatibles pour la multiplication matricielle\" },\n+\n+    // org.apache.commons.math.linear.DenseRealMatrix\n+    { \"wrong array shape (block length = {0}, expected {1})\",\n+      \"forme de tableau erron\\u00e9e (bloc de longueur {0} au lieu des {1} attendus)\" },\n+\n+    // org.apache.commons.math.complex.Complex\n+    { \"cannot compute nth root for null or negative n: {0}\",\n      \"impossible de calculer la racine ni\\u00e8me pour n n\\u00e9gatif ou nul : {0}\" },\n \n    // org.apache.commons.math.complex.ComplexFormat\n    { \"unparseable complex number: \\\"{0}\\\"\",\n      \"\\u00e9chec d''analyse du nombre complexe \\\"{0}\\\"\" },\n+   { \"cannot format a {0} instance as a complex number\",\n+     \"impossible de formater une instance de {0} comme un nombre complexe\" },\n+   { \"empty string for imaginary character\",\n+     \"cha\\u00eene vide pour le caract\\u00e8 imaginaire\" },\n+   { \"null imaginary format\",\n+     \"format imaginaire nul\" },\n+   { \"null real format\",\n+     \"format r\\u00e9el nul\" },\n+\n+   // org.apache.commons.math.complex.ComplexUtils\n+   { \"negative complex module {0}\",\n+     \"module n\\u00e9gatif ({0}) pour un nombre complexe\" },\n \n    // org.apache.commons.math.geometry.Vector3DFormat\n    { \"unparseable 3D vector: \\\"{0}\\\"\",\n      \"\\u00e9chec d''analyse du vecteur de dimension 3 \\\"{0}\\\"\" },\n+   { \"cannot format a {0} instance as a 3D vector\",\n+     \"impossible de formater une instance de {0} comme un vecteur de dimension 3\" },\n \n    // org.apache.commons.math.linear.RealVectorFormat\n    { \"unparseable real vector: \\\"{0}\\\"\",\n      \"\\u00e9chec d''analyse du vecteur r\\u00e9el \\\"{0}\\\"\" },\n+   { \"cannot format a {0} instance as a real vector\",\n+     \"impossible de formater une instance de {0} comme un vecteur r\\u00e9el\" },\n \n    // org.apache.commons.math.util.ResizableDoubleArray\n    { \"the index specified: {0} is larger than the current maximal index {1}\",\n      \"d\\u00e9passement de capacit\\u00e9 pour le num\\u00e9rateur apr\\u00e8s multiplication : {0}\" },\n    { \"the fraction to divide by must not be zero: {0}/{1}\",\n      \"division par un nombre rationnel nul : {0}/{1}\" },\n+   { \"null fraction\",\n+     \"fraction nulle\" },\n \n    // org.apache.commons.math.geometry.Rotation\n    { \"zero norm for rotation axis\",\n      \"norme nulle pour un axe de rotation\" },\n+   { \"zero norm for rotation defining vector\",\n+     \"norme nulle pour un axe de d\\u00e9finition de rotation\" },\n \n    // org.apache.commons.math.geometry.Vector3D\n    // org.apache.commons.math.linear.RealVectorImpl\n    { \"first {0} columns are not initialized yet\",\n      \"les {0} premi\\u00e8res colonnes ne sont pas encore initialis\\u00e9es\" },\n \n-   // org.apache.commons.math.random.EmpiricalDistributionImpl\n-   { \"distribution not loaded\",\n-     \"aucune distribution n''a \\u00e9t\\u00e9 charg\\u00e9e\" },\n-\n-   // org.apache.commons.math.random.ValueServer\n-   { \"unknown mode {0}, known modes: {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}) and {11} ({12})\",\n-     \"mode {0} inconnu, modes connus : {1} ({2}), {3} ({4}), {5} ({6}), {7} ({8}), {9} ({10}) et {11} ({12})\" },\n-   { \"digest not initialized\",\n-     \"mod\\u00e8le empirique non initialis\\u00e9\" },\n+   // org.apache.commons.math.stat.Frequency\n+   { \"class ({0}) does not implement Comparable\",\n+     \"la classe ({0}) n''implante pas l''interface Comparable\" },\n+   { \"instance of class {0} not comparable to existing values\",\n+     \"l''instance de la classe {0} n''est pas comparable aux valeurs existantes\" },\n+\n+   // org.apache.commons.math.stat.StatUtils\n+   { \"input arrays must have the same positive length ({0} and {1})\",\n+     \"les tableaux d''entr\\u00e9e doivent avoir la m\\u00eame taille positive ({0} et {1})\" },\n+   { \"input arrays must have the same length and at least two elements ({0} and {1})\",\n+     \"les tableaux d''entr\\u00e9e doivent avoir la m\\u00eame taille\" +\n+     \" et au moins deux \\u00e9l\\u00e9ments ({0} et {1})\" },\n \n    // org.apache.commons.math.stat.correlation.Covariance\n    { \"arrays must have the same length and both must have at \" +\n      \"least two elements. xArray has size {0}, yArray has {1} elements\",\n-     \"les tableaux doivent avoir la m\\u00eame taille et comporter au moins deux \\u00e9l\\u00e9ments. \" +\n+     \"les tableaux doivent avoir la m\\u00eame taille \" +\n+     \"et comporter au moins deux \\u00e9l\\u00e9ments. \" +\n      \"xArray a une taille de {0}, yArray a {1} \\u00e9l\\u00e9ments\"},\n    { \"insufficient data: only {0} rows and {1} columns.\",\n      \"donn\\u00e9es insuffisantes : seulement {0} lignes et {1} colonnes.\" },\n    { \"covariance matrix is null\",\n      \"la matrice de covariance est nulle\" },\n    { \"invalid array dimensions. xArray has size {0}; yArray has {1} elements\",\n-     \"dimensions de tableaux invalides. xArray a une taille de {0}, yArray a {1} \\u00e9l\\u00e9ments\" },\n+     \"dimensions de tableaux invalides. xArray a une taille de {0}, \" +\n+     \"yArray a {1} \\u00e9l\\u00e9ments\" },\n+\n+   // org.apache.commons.math.stat.descriptive.DescriptiveStatistics\n+   { \"window size must be positive ({0})\",\n+     \"la taille de la fen\\u00eatre doit \\u00eatre positive ({0})\" },\n+   { \"percentile implementation {0} does not support setQuantile\",\n+     \"l''implantation de pourcentage {0} ne dispose pas de la m\\u00e9thode setQuantile\" },\n+   { \"cannot access setQuantile method in percentile implementation {0}\",\n+     \"acc\\u00e8s impossible \\u00e0 la m\\u00e9thode setQuantile\" +\n+     \" dans l''implantation de pourcentage {0}\" },\n+   { \"out of bounds quantile value: {0}, must be in (0, 100]\",\n+     \"valeur de quantile {0} hors bornes, doit \\u00eatre dans l''intervalle ]0, 100]\" },\n+\n+   // org.apache.commons.math.stat.descriptive.moment.Variance\n+   // org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic\n+   // org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic\n+   { \"input values array is null\",\n+     \"le tableau des valeurs d''entr\\u00e9es est nul\" },\n+\n+   // org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic\n+   { \"start position cannot be negative ({0})\",\n+     \"la position de d\\u00e9part ne peut pas \\u00eatre n\\u00e9gative\" },\n+   { \"length cannot be negative ({0})\",\n+     \"la longueur ne peut pas \\u00eatre n\\u00e9gative\" },\n+   { \"subarray ends after array end\",\n+     \"le sous-tableau se termine apr\\u00e8s la fin du tableau\" },\n \n    // org.apache.commons.math.stat.descriptive.moment.GeometricMean\n    // org.apache.commons.math.stat.descriptive.MultivariateSummaryStatistics\n    // org.apache.commons.math.stat.descriptive.SummaryStatistics\n    { \"{0} values have been added before statistic is configured\",\n-     \"{0} valeurs ont \\u00e9t\\u00e9 ajout\\u00e9es avant que la statistique ne soit configur\\u00e9e\" },\n+     \"{0} valeurs ont \\u00e9t\\u00e9 ajout\\u00e9es \" +\n+     \"avant que la statistique ne soit configur\\u00e9e\" },\n \n    // org.apache.commons.math.stat.descriptive.moment.Kurtosis\n    { \"statistics constructed from external moments cannot be incremented\",\n-     \"les statistiques bas\\u00e9es sur des moments externes ne peuvent pas \\u00eatre incr\\u00e9ment\\u00e9es\" },\n+     \"les statistiques bas\\u00e9es sur des moments externes \" +\n+     \"ne peuvent pas \\u00eatre incr\\u00e9ment\\u00e9es\" },\n    { \"statistics constructed from external moments cannot be cleared\",\n-     \"les statistiques bas\\u00e9es sur des moments externes ne peuvent pas \\u00eatre remises \\u00e0 z\\u00e9ro\" },\n+     \"les statistiques bas\\u00e9es sur des moments externes \" +\n+     \"ne peuvent pas \\u00eatre remises \\u00e0 z\\u00e9ro\" },\n+\n+   // org.apache.commons.math.stat.Regression\n+   { \"out of bounds significance level {0}, must be in (0, 1)\",\n+     \"niveau de signification {0} hors domaine, doit \\u00eatre dans l''intervalle ]0, 1[\" },\n+\n+   // org.apache.commons.math.distribution.AbstractContinuousDistribution\n+   // org.apache.commons.math.distribution.AbstractIntegerDistribution\n+   // org.apache.commons.math.distribution.ExponentialDistributionImpl\n+   // org.apache.commons.math.distribution.BinomialDistributionImpl\n+   // org.apache.commons.math.distribution.CauchyDistributionImpl\n+   // org.apache.commons.math.distribution.PascalDistributionImpl\n+   // org.apache.commons.math.distribution.WeibullDistributionImpl\n+   { \"{0} out of [{1}, {2}] range\",\n+     \"{0} hors du domaine [{1}, {2}]\" },\n+\n+   // org.apache.commons.math.distribution.AbstractDistribution\n+   // org.apache.commons.math.distribution.AbstractIntegerDistribution\n+   { \"lower endpoint ({0}) must be less than or equal to upper endpoint ({1})\",\n+     \"la borne inf\\u00e9rieure ({0}) devrait \\u00eatre inf\\u00e9rieure \" +\n+     \"ou \\u00e9gale \\u00e0 la borne sup\\u00e9rieure ({1})\" },\n+\n+   // org.apache.commons.math.distribution.BinomialDistributionImpl\n+   { \"number of trials must be non-negative ({0})\",\n+     \"le nombre d''essais ne doit pas \\u00eatre n\\u00e9gatif ({0})\" },\n+\n+   // org.apache.commons.math.distribution.ExponentialDistributionImpl\n+   // org.apache.commons.math.random.RandomDataImpl\n+   { \"mean must be positive ({0})\",\n+     \"la moyenne doit \\u00eatre positive ({0})\" },\n+\n+   // org.apache.commons.math.distribution.FDistributionImpl\n+   // org.apache.commons.math.distribution.TDistributionImpl\n+   { \"degrees of freedom must be positive ({0})\",\n+     \"les degr\\u00e9s de libert\\u00e9 doivent \\u00eatre positifs ({0})\" },\n+\n+   // org.apache.commons.math.distribution.GammaDistributionImpl\n+   { \"alpha must be positive ({0})\",\n+     \"alpha doit \\u00eatre positif ({0})\" },\n+   { \"beta must be positive ({0})\",\n+     \"beta doit \\u00eatre positif ({0})\" },\n+\n+   // org.apache.commons.math.distribution.HypergeometricDistributionImpl\n+   { \"number of successes ({0}) must be less than or equal to population size ({1})\",\n+     \"le nombre de succ\\u00e8s doit \\u00eatre inf\\u00e9rieur \" +\n+     \"ou \\u00e9gal \\u00e0 la taille de la population ({1})\" },\n+   { \"sample size ({0}) must be less than or equal to population size ({1})\",\n+     \"la taille de l''\\u00e9chantillon doit \\u00eatre inf\\u00e9rieure \" +\n+     \"ou \\u00e9gale \\u00e0 la taille de la population ({1})\" },\n+   { \"population size must be positive ({0})\",\n+     \"la taille de la population doit \\u00eatre positive ({0})\" },\n+\n+   // org.apache.commons.math.distribution.HypergeometricDistributionImpl\n+   // org.apache.commons.math.random.RandomDataImpl\n+   { \"sample size must be positive ({0})\",\n+     \"la taille de l''\\u00e9chantillon doit \\u00eatre positive ({0})\" },\n+\n+   // org.apache.commons.math.distribution.HypergeometricDistributionImpl\n+   // org.apache.commons.math.distribution.PascalDistributionImpl\n+   { \"number of successes must be non-negative ({0})\",\n+     \"le nombre de succ\\u00e8s ne doit pas \\u00eatre n\\u00e9gatif ({0})\" },\n+\n+   // org.apache.commons.math.distribution.NormalDistributionImpl\n+   // org.apache.commons.math.random.RandomDataImpl\n+   { \"standard deviation must be positive ({0})\",\n+     \"l''\\u00e9cart type doit \\u00eatre positif ({0})\" },\n+\n+   // org.apache.commons.math.distribution.PoissonDistributionImpl\n+   // org.apache.commons.math.random.RandomDataImpl\n+   { \"the Poisson mean must be positive ({0})\",\n+     \"la moyenne de Poisson doit \\u00eatre positive ({0})\" },\n+\n+   // org.apache.commons.math.distribution.WeibullDistributionImpl\n+   { \"shape must be positive ({0})\",\n+     \"le facteur de forme doit \\u00eatre positif ({0})\" },\n+\n+   // org.apache.commons.math.distribution.WeibullDistributionImpl\n+   // org.apache.commons.math.distribution.CauchyDistributionImpl\n+   { \"scale must be positive ({0})\",\n+     \"l''\\u00e9chelle doit \\u00eatre positive ({0})\" },\n \n    // org.apache.commons.math.distribution.ZipfDistributionImpl\n    { \"invalid number of elements {0} (must be positive)\",\n \n    // org.apache.commons.math.transform.FastFourierTransformer\n    { \"cannot compute 0-th root of unity, indefinite result\",\n-     \"impossible de calculer la racine z\\u00e9roi\\u00e8me de l''unit\\u00e9, r\\u00e9sultat ind\\u00e9fini\" },\n+     \"impossible de calculer la racine z\\u00e9roi\\u00e8me de l''unit\\u00e9, \" +\n+     \"r\\u00e9sultat ind\\u00e9fini\" },\n    { \"roots of unity have not been computed yet\",\n      \"les racines de l''unit\\u00e9 n''ont pas encore \\u00e9t\\u00e9 calcul\\u00e9es\" },\n    { \"out of range root of unity index {0} (must be in [{1};{2}])\",\n--- a/src/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java\n             ret = format( new Complex(((Number)obj).doubleValue(), 0.0),\n                 toAppendTo, pos);\n         } else { \n-            throw new IllegalArgumentException(\"Cannot format given Object as a Complex\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"cannot format a {0} instance as a complex number\",\n+                  obj.getClass().getName());\n         }\n         \n         return ret;\n      */\n     public void setImaginaryCharacter(String imaginaryCharacter) {\n         if (imaginaryCharacter == null || imaginaryCharacter.length() == 0) {\n-            throw new IllegalArgumentException(\n-                \"imaginaryCharacter must be a non-empty string.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"empty string for imaginary character\");\n         }\n         this.imaginaryCharacter = imaginaryCharacter;\n     }\n      */\n     public void setImaginaryFormat(NumberFormat imaginaryFormat) {\n         if (imaginaryFormat == null) {\n-            throw new IllegalArgumentException(\n-                \"imaginaryFormat can not be null.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"null imaginary format\");\n         }\n         this.imaginaryFormat = imaginaryFormat;\n     }\n      */\n     public void setRealFormat(NumberFormat realFormat) {\n         if (realFormat == null) {\n-            throw new IllegalArgumentException(\n-                \"realFormat can not be null.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"null real format\");\n         }\n         this.realFormat = realFormat;\n     }\n--- a/src/java/org/apache/commons/math/complex/ComplexUtils.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexUtils.java\n  */\n \n package org.apache.commons.math.complex;\n+\n+import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * Static implementations of common \n      */\n     public static Complex polar2Complex(double r, double theta) {\n         if (r < 0) {\n-            throw new IllegalArgumentException\n-                (\"Complex modulus must not be negative\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"negative complex module {0}\", r);\n         }\n         return new Complex(r * Math.cos(theta), r * Math.sin(theta));\n     }\n--- a/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractContinuousDistribution.java\n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.FunctionEvaluationException;\n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n \n     public double inverseCumulativeProbability(final double p)\n         throws MathException {\n         if (p < 0.0 || p > 1.0) {\n-            throw new IllegalArgumentException(\"p must be between 0.0 and 1.0, inclusive.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n         }\n \n         // by default, do simple root finding using bracketing and default solver.\n--- a/src/java/org/apache/commons/math/distribution/AbstractDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractDistribution.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * Base class for probability distributions.   \n     public double cumulativeProbability(double x0, double x1)\n         throws MathException {\n         if (x0 > x1) {\n-            throw new IllegalArgumentException\n-            (\"lower endpoint must be less than or equal to upper endpoint\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"lower endpoint ({0}) must be less than or equal to upper endpoint ({1})\",\n+                  x0, x1);\n         }\n         return cumulativeProbability(x1) - cumulativeProbability(x0);\n     }\n--- a/src/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n+++ b/src/java/org/apache/commons/math/distribution/AbstractIntegerDistribution.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n \n \n /**\n     public double cumulativeProbability(double x0, double x1)\n         throws MathException {\n         if (x0 > x1) {\n-            throw new IllegalArgumentException\n-            (\"lower endpoint must be less than or equal to upper endpoint\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"lower endpoint ({0}) must be less than or equal to upper endpoint ({1})\",\n+                  x0, x1);\n         }\n         if (Math.floor(x0) < x0) {\n             return cumulativeProbability(((int) Math.floor(x0)) + 1,\n      */\n     public double cumulativeProbability(int x0, int x1) throws MathException {\n         if (x0 > x1) {\n-            throw new IllegalArgumentException\n-                (\"lower endpoint must be less than or equal to upper endpoint\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"lower endpoint ({0}) must be less than or equal to upper endpoint ({1})\",\n+                  x0, x1);\n         }\n         return cumulativeProbability(x1) - cumulativeProbability(x0 - 1);\n     }\n      */\n     public int inverseCumulativeProbability(final double p) throws MathException{\n         if (p < 0.0 || p > 1.0) {\n-            throw new IllegalArgumentException(\n-                \"p must be between 0 and 1.0 (inclusive)\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n         }\n         \n         // by default, do simple bisection.\n--- a/src/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/BinomialDistributionImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.special.Beta;\n import org.apache.commons.math.util.MathUtils;\n \n      */\n     public void setNumberOfTrials(int trials) {\n         if (trials < 0) {\n-            throw new IllegalArgumentException(\"number of trials must be non-negative.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"number of trials must be non-negative ({0})\", trials);\n         }\n         numberOfTrials = trials;\n     }\n      */\n     public void setProbabilityOfSuccess(double p) {\n         if (p < 0.0 || p > 1.0) {\n-            throw new IllegalArgumentException(\"probability of success must be between 0.0 and 1.0, inclusive.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n         }\n         probabilityOfSuccess = p;\n     }\n--- a/src/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/CauchyDistributionImpl.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math.MathRuntimeException;\n+\n /**\n  * Default implementation of\n  * {@link org.apache.commons.math.distribution.CauchyDistribution}.\n     public double inverseCumulativeProbability(double p) {\n         double ret;\n         if (p < 0.0 || p > 1.0) {\n-            throw new IllegalArgumentException\n-                (\"probability argument must be between 0 and 1 (inclusive)\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n         } else if (p == 0) {\n             ret = Double.NEGATIVE_INFINITY;\n         } else  if (p == 1) {\n      */\n     public void setScale(double s) {\n         if (s <= 0.0) {\n-            throw new IllegalArgumentException(\n-                \"Scale must be positive.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"scale must be positive ({0})\", s);\n         }       \n         scale = s;\n     }\n--- a/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * The default implementation of {@link ExponentialDistribution}.\n      */\n     public void setMean(double mean) {\n         if (mean <= 0.0) {\n-            throw new IllegalArgumentException(\"mean must be positive.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"mean must be positive ({0})\", mean);\n         }\n         this.mean = mean;\n     }\n         double ret;\n         \n         if (p < 0.0 || p > 1.0) {\n-            throw new IllegalArgumentException\n-                (\"probability argument must be between 0 and 1 (inclusive)\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n         } else if (p == 1.0) {\n             ret = Double.POSITIVE_INFINITY;\n         } else {\n--- a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.special.Beta;\n \n /**\n      */\n     public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {\n         if (degreesOfFreedom <= 0.0) {\n-            throw new IllegalArgumentException(\n-                \"degrees of freedom must be positive.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"degrees of freedom must be positive ({0})\",\n+                  degreesOfFreedom);\n         }\n         this.numeratorDegreesOfFreedom = degreesOfFreedom;\n     }\n      */\n     public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {\n         if (degreesOfFreedom <= 0.0) {\n-            throw new IllegalArgumentException(\n-                \"degrees of freedom must be positive.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"degrees of freedom must be positive ({0})\",\n+                  degreesOfFreedom);\n         }\n         this.denominatorDegreesOfFreedom = degreesOfFreedom;\n     }\n--- a/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.special.Gamma;\n \n /**\n      */\n     public void setAlpha(double alpha) {\n         if (alpha <= 0.0) {\n-            throw new IllegalArgumentException(\"alpha must be positive\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"alpha must be positive ({0})\",\n+                  alpha);\n         }\n         this.alpha = alpha;\n     }\n      */\n     public void setBeta(double beta) {\n         if (beta <= 0.0) {\n-            throw new IllegalArgumentException(\"beta must be positive\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"beta must be positive ({0})\",\n+                  beta);\n         }\n         this.beta = beta;\n     }\n--- a/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/HypergeometricDistributionImpl.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n         int numberOfSuccesses, int sampleSize) {\n         super();\n         if (numberOfSuccesses > populationSize) {\n-            throw new IllegalArgumentException(\n-                \"number of successes must be less than or equal to \" +\n-                \"population size\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"number of successes ({0}) must be less than or equal to population size ({1})\",\n+                numberOfSuccesses, populationSize);\n         }\n         if (sampleSize > populationSize) {\n-            throw new IllegalArgumentException(\n-            \"sample size must be less than or equal to population size\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"sample size ({0}) must be less than or equal to population size ({1})\",\n+                  sampleSize, populationSize);\n         }\n         setPopulationSize(populationSize);\n         setSampleSize(sampleSize);\n      */\n     public void setNumberOfSuccesses(int num) {\n         if(num < 0){\n-            throw new IllegalArgumentException(\n-                \"number of successes must be non-negative.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"number of successes must be non-negative ({0})\",\n+                  num);\n         }\n         numberOfSuccesses = num;\n     }\n      */\n     public void setPopulationSize(int size) {\n         if(size <= 0){\n-            throw new IllegalArgumentException(\n-                \"population size must be positive.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"population size must be positive ({0})\",\n+                  size);\n         }\n         populationSize = size;\n     }\n      */\n     public void setSampleSize(int size) {\n         if (size < 0) {\n-            throw new IllegalArgumentException(\n-                \"sample size must be non-negative.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"sample size must be positive ({0})\",\n+                  size);\n         }    \n         sampleSize = size;\n     }\n--- a/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.MaxIterationsExceededException;\n import org.apache.commons.math.special.Erf;\n \n      */\n     public void setStandardDeviation(double sd) {\n         if (sd <= 0.0) {\n-            throw new IllegalArgumentException(\n-                \"Standard deviation must be positive.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"standard deviation must be positive ({0})\",\n+                  sd);\n         }       \n         standardDeviation = sd;\n     }\n--- a/src/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/PascalDistributionImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.special.Beta;\n import org.apache.commons.math.util.MathUtils;\n \n      */\n     public void setNumberOfSuccesses(int successes) {\n         if (successes < 0) {\n-            throw new IllegalArgumentException(\n-                \"number of successes must be non-negative.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"number of successes must be non-negative ({0})\",\n+                  successes);\n         }\n         numberOfSuccesses = successes;\n     }\n      */\n     public void setProbabilityOfSuccess(double p) {\n         if (p < 0.0 || p > 1.0) {\n-            throw new IllegalArgumentException(\n-                \"probability of success must be between 0.0 and 1.0, inclusive.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n         }\n         probabilityOfSuccess = p;\n     }\n--- a/src/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/PoissonDistributionImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.special.Gamma;\n import org.apache.commons.math.util.MathUtils;\n \n      */\n     public void setMean(double p) {\n         if (p <= 0) {\n-            throw new IllegalArgumentException(\n-                    \"The Poisson mean must be positive\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"the Poisson mean must be positive ({0})\",\n+                  p);\n         }\n         this.mean = p;\n         normal.setMean(p);\n--- a/src/java/org/apache/commons/math/distribution/TDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/TDistributionImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.special.Beta;\n \n /**\n      */\n     public void setDegreesOfFreedom(double degreesOfFreedom) {\n         if (degreesOfFreedom <= 0.0) {\n-            throw new IllegalArgumentException(\"degrees of freedom must be positive.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"degrees of freedom must be positive ({0})\",\n+                  degreesOfFreedom);\n         }\n         this.degreesOfFreedom = degreesOfFreedom;\n     }\n--- a/src/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/WeibullDistributionImpl.java\n package org.apache.commons.math.distribution;\n \n import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * Default implementation of\n     public double inverseCumulativeProbability(double p) {\n         double ret;\n         if (p < 0.0 || p > 1.0) {\n-            throw new IllegalArgumentException\n-                (\"probability argument must be between 0 and 1 (inclusive)\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"{0} out of [{1}, {2}] range\", p, 0.0, 1.0);\n         } else if (p == 0) {\n             ret = 0.0;\n         } else  if (p == 1) {\n      */\n     public void setShape(double alpha) {\n         if (alpha <= 0.0) {\n-            throw new IllegalArgumentException(\n-                \"Shape must be positive.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"shape must be positive ({0})\",\n+                  alpha);\n         }       \n         this.alpha = alpha;\n     }\n      */\n     public void setScale(double beta) {\n         if (beta <= 0.0) {\n-            throw new IllegalArgumentException(\n-                \"Scale must be positive.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"scale must be positive ({0})\",\n+                  beta);\n         }       \n         this.beta = beta;\n     }\n--- a/src/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/java/org/apache/commons/math/fraction/Fraction.java\n      */\n     private Fraction addSub(Fraction fraction, boolean isAdd) {\n         if (fraction == null) {\n-            throw new IllegalArgumentException(\"The fraction must not be null\");\n+            throw MathRuntimeException.createIllegalArgumentException(\"null fraction\");\n         }\n         // zero is identity for addition.\n         if (numerator == 0) {\n      */\n     public Fraction multiply(Fraction fraction) {\n         if (fraction == null) {\n-            throw new IllegalArgumentException(\"The fraction must not be null\");\n+            throw MathRuntimeException.createIllegalArgumentException(\"null fraction\");\n         }\n         if (numerator == 0 || fraction.numerator == 0) {\n             return ZERO;\n      */\n     public Fraction divide(Fraction fraction) {\n         if (fraction == null) {\n-            throw new IllegalArgumentException(\"The fraction must not be null\");\n+            throw MathRuntimeException.createIllegalArgumentException(\"null fraction\");\n         }\n         if (fraction.numerator == 0) {\n             throw MathRuntimeException.createArithmeticException(\n--- a/src/java/org/apache/commons/math/geometry/Rotation.java\n+++ b/src/java/org/apache/commons/math/geometry/Rotation.java\n   double v1v1 = Vector3D.dotProduct(v1, v1);\n   double v2v2 = Vector3D.dotProduct(v2, v2);\n   if ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\n-    throw new IllegalArgumentException(\"zero norm for rotation defining vector\");\n+    throw MathRuntimeException.createIllegalArgumentException(\"zero norm for rotation defining vector\");\n   }\n \n   double u1x = u1.getX();\n \n     double normProduct = u.getNorm() * v.getNorm();\n     if (normProduct == 0) {\n-      throw new IllegalArgumentException(\"zero norm for rotation defining vector\");\n+        throw MathRuntimeException.createIllegalArgumentException(\"zero norm for rotation defining vector\");\n     }\n \n     double dot = Vector3D.dotProduct(u, v);\n--- a/src/java/org/apache/commons/math/geometry/Vector3DFormat.java\n+++ b/src/java/org/apache/commons/math/geometry/Vector3DFormat.java\n             return format( (Vector3D)obj, toAppendTo, pos);\n         }\n \n-        throw new IllegalArgumentException(\"Cannot format given Object as a Vector3D\");\n+        throw MathRuntimeException.createIllegalArgumentException(\"cannot format a {0} instance as a 3D vector\",\n+                                                                  obj.getClass().getName());\n \n     }\n \n--- a/src/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/AbstractRealMatrix.java\n     public RealMatrix add(RealMatrix m) throws IllegalArgumentException {\n \n         // safety check\n-        checkAdditionCompatible(m);\n+        MatrixUtils.checkAdditionCompatible(this, m);\n \n         final int rowCount    = getRowDimension();\n         final int columnCount = getColumnDimension();\n     public RealMatrix subtract(final RealMatrix m) throws IllegalArgumentException {\n \n         // safety check\n-        checkSubtractionCompatible(m);\n+        MatrixUtils.checkSubtractionCompatible(this, m);\n \n         final int rowCount    = getRowDimension();\n         final int columnCount = getColumnDimension();\n         throws IllegalArgumentException {\n \n         // safety check\n-        checkMultiplicationCompatible(m);\n+        MatrixUtils.checkMultiplicationCompatible(this, m);\n \n         final int nRows = getRowDimension();\n         final int nCols = m.getColumnDimension();\n                                    final int startColumn, final int endColumn)\n         throws MatrixIndexException {\n \n-        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n \n         final RealMatrix subMatrix =\n             createMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n         throws MatrixIndexException {\n \n         // safety checks\n-        checkSubMatrixIndex(selectedRows, selectedColumns);\n+        MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);\n \n         // copy entries\n         final RealMatrix subMatrix =\n         throws MatrixIndexException, IllegalArgumentException {\n \n         // safety checks\n-        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         final int rowsCount    = endRow + 1 - startRow;\n         final int columnsCount = endColumn + 1 - startColumn;\n         if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) {\n         throws MatrixIndexException, IllegalArgumentException {\n \n         // safety checks\n-        checkSubMatrixIndex(selectedRows, selectedColumns);\n+        MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);\n         if ((destination.length < selectedRows.length) ||\n             (destination[0].length < selectedColumns.length)) {\n             throw MathRuntimeException.createIllegalArgumentException(\n             }\n         }\n \n-        checkRowIndex(row);\n-        checkColumnIndex(column);\n-        checkRowIndex(nRows + row - 1);\n-        checkColumnIndex(nCols + column - 1);\n+        MatrixUtils.checkRowIndex(this, row);\n+        MatrixUtils.checkColumnIndex(this, column);\n+        MatrixUtils.checkRowIndex(this, nRows + row - 1);\n+        MatrixUtils.checkColumnIndex(this, nCols + column - 1);\n \n         for (int i = 0; i < nRows; ++i) {\n             for (int j = 0; j < nCols; ++j) {\n     public RealMatrix getRowMatrix(final int row)\n         throws MatrixIndexException {\n \n-        checkRowIndex(row);\n+        MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         final RealMatrix out = createMatrix(1, nCols);\n         for (int i = 0; i < nCols; ++i) {\n     public void setRowMatrix(final int row, final RealMatrix matrix)\n         throws MatrixIndexException, InvalidMatrixException {\n \n-        checkRowIndex(row);\n+        MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         if ((matrix.getRowDimension() != 1) ||\n             (matrix.getColumnDimension() != nCols)) {\n     public RealMatrix getColumnMatrix(final int column)\n         throws MatrixIndexException {\n \n-        checkColumnIndex(column);\n+        MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         final RealMatrix out = createMatrix(nRows, 1);\n         for (int i = 0; i < nRows; ++i) {\n     public void setColumnMatrix(final int column, final RealMatrix matrix)\n         throws MatrixIndexException, InvalidMatrixException {\n \n-        checkColumnIndex(column);\n+        MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         if ((matrix.getRowDimension() != nRows) ||\n             (matrix.getColumnDimension() != 1)) {\n     public void setRowVector(final int row, final RealVector vector)\n         throws MatrixIndexException, InvalidMatrixException {\n \n-        checkRowIndex(row);\n+        MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         if (vector.getDimension() != nCols) {\n             throw new InvalidMatrixException(\n     public void setColumnVector(final int column, final RealVector vector)\n         throws MatrixIndexException, InvalidMatrixException {\n \n-        checkColumnIndex(column);\n+        MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         if (vector.getDimension() != nRows) {\n             throw new InvalidMatrixException(\n     public double[] getRow(final int row)\n         throws MatrixIndexException {\n \n-        checkRowIndex(row);\n+        MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         final double[] out = new double[nCols];\n         for (int i = 0; i < nCols; ++i) {\n     public void setRow(final int row, final double[] array)\n         throws MatrixIndexException, InvalidMatrixException {\n \n-        checkRowIndex(row);\n+        MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         if (array.length != nCols) {\n             throw new InvalidMatrixException(\n     public double[] getColumn(final int column)\n         throws MatrixIndexException {\n \n-        checkColumnIndex(column);\n+        MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         final double[] out = new double[nRows];\n         for (int i = 0; i < nRows; ++i) {\n     public void setColumn(final int column, final double[] array)\n         throws MatrixIndexException, InvalidMatrixException {\n \n-        checkColumnIndex(column);\n+        MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         if (array.length != nRows) {\n             throw new InvalidMatrixException(\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n         throws MatrixIndexException, MatrixVisitorException {\n-        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n         for (int row = startRow; row <= endRow; ++row) {\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n         throws MatrixIndexException, MatrixVisitorException {\n-        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n         for (int row = startRow; row <= endRow; ++row) {\n                                     final int startRow, final int endRow,\n                                     final int startColumn, final int endColumn)\n     throws MatrixIndexException, MatrixVisitorException {\n-        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n         for (int column = startColumn; column <= endColumn; ++column) {\n                                     final int startRow, final int endRow,\n                                     final int startColumn, final int endColumn)\n     throws MatrixIndexException, MatrixVisitorException {\n-        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n         for (int column = startColumn; column <= endColumn; ++column) {\n         return ret;\n     }\n \n-    /**\n-     * Check if a row index is valid.\n-     * @param row row index to check\n-     * @exception MatrixIndexException if index is not valid\n-     */\n-    protected void checkRowIndex(final int row) {\n-        if (row < 0 || row >= getRowDimension()) {\n-            throw new MatrixIndexException(\"row index {0} out of allowed range [{1}, {2}]\",\n-                                           row, 0, getRowDimension() - 1);\n-        }\n-    }\n-\n-    /**\n-     * Check if a column index is valid.\n-     * @param column column index to check\n-     * @exception MatrixIndexException if index is not valid\n-     */\n-    protected void checkColumnIndex(final int column)\n-        throws MatrixIndexException {\n-        if (column < 0 || column >= getColumnDimension()) {\n-            throw new MatrixIndexException(\"column index {0} out of allowed range [{1}, {2}]\",\n-                                           column, 0, getColumnDimension() - 1);\n-        }\n-    }\n-\n-    /**\n-     * Check if submatrix ranges indices are valid.\n-     * Rows and columns are indicated counting from 0 to n-1.\n-     *\n-     * @param startRow Initial row index\n-     * @param endRow Final row index\n-     * @param startColumn Initial column index\n-     * @param endColumn Final column index\n-     * @exception MatrixIndexException  if the indices are not valid\n-     */\n-    protected void checkSubMatrixIndex(final int startRow, final int endRow,\n-                                       final int startColumn, final int endColumn) {\n-        checkRowIndex(startRow);\n-        checkRowIndex(endRow);\n-        if (startRow > endRow) {\n-            throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n-                                           startRow, endRow);\n-        }\n-\n-        checkColumnIndex(startColumn);\n-        checkColumnIndex(endColumn);\n-        if (startColumn > endColumn) {\n-            throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n-                                           startColumn, endColumn);\n-        }\n-\n-    \n-    }\n-\n-    /**\n-     * Check if submatrix ranges indices are valid.\n-     * Rows and columns are indicated counting from 0 to n-1.\n-     *\n-     * @param selectedRows Array of row indices.\n-     * @param selectedColumns Array of column indices.\n-     * @exception MatrixIndexException if row or column selections are not valid\n-     */\n-    protected void checkSubMatrixIndex(final int[] selectedRows, final int[] selectedColumns) {\n-        if (selectedRows.length * selectedColumns.length == 0) {\n-            if (selectedRows.length == 0) {\n-                throw new MatrixIndexException(\"empty selected row index array\");\n-            }\n-            throw new MatrixIndexException(\"empty selected column index array\");\n-        }\n-\n-        for (final int row : selectedRows) {\n-            checkRowIndex(row);\n-        }\n-        for (final int column : selectedColumns) {\n-            checkColumnIndex(column);\n-        }\n-    }\n-\n-    /**\n-     * Check if a matrix is addition compatible with the instance\n-     * @param m matrix to check\n-     * @exception IllegalArgumentException if matrix is not addition compatible with instance\n-     */\n-    protected void checkAdditionCompatible(final RealMatrix m) {\n-        if ((getRowDimension()    != m.getRowDimension()) ||\n-            (getColumnDimension() != m.getColumnDimension())) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    \"{0}x{1} and {2}x{3} matrices are not addition compatible\",\n-                    getRowDimension(), getColumnDimension(),\n-                    m.getRowDimension(), m.getColumnDimension());\n-        }\n-    }\n-\n-    /**\n-     * Check if a matrix is subtraction compatible with the instance\n-     * @param m matrix to check\n-     * @exception IllegalArgumentException if matrix is not subtraction compatible with instance\n-     */\n-    protected void checkSubtractionCompatible(final RealMatrix m) {\n-        if ((getRowDimension()    != m.getRowDimension()) ||\n-            (getColumnDimension() != m.getColumnDimension())) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    \"{0}x{1} and {2}x{3} matrices are not subtraction compatible\",\n-                    getRowDimension(), getColumnDimension(),\n-                    m.getRowDimension(), m.getColumnDimension());\n-        }\n-    }\n-\n-    /**\n-     * Check if a matrix is multiplication compatible with the instance\n-     * @param m matrix to check\n-     * @exception IllegalArgumentException if matrix is not multiplication compatible with instance\n-     */\n-    protected void checkMultiplicationCompatible(final RealMatrix m) {\n-        if (getColumnDimension() != m.getRowDimension()) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n-                    getRowDimension(), getColumnDimension(),\n-                    m.getRowDimension(), m.getColumnDimension());\n-        }\n-    }\n-\n }\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/linear/AnyMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+\n+/**\n+ * Interface defining very basic matrix operations.\n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public interface AnyMatrix {\n+\n+    /**\n+     * Is this a square matrix?\n+     * @return true if the matrix is square (rowDimension = columnDimension)\n+     */\n+    boolean isSquare();\n+\n+    /**\n+     * Returns the number of rows in the matrix.\n+     *\n+     * @return rowDimension\n+     */\n+    int getRowDimension();\n+\n+    /**\n+     * Returns the number of columns in the matrix.\n+     *\n+     * @return columnDimension\n+     */\n+    int getColumnDimension();\n+\n+}\n--- a/src/java/org/apache/commons/math/linear/BigMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/BigMatrix.java\n  * org.apache.commons.math.util.BigReal} parameter\n  */\n @Deprecated\n-public interface BigMatrix {\n+public interface BigMatrix extends AnyMatrix {\n \n     /**\n      * Returns a (deep) copy of this.\n     BigDecimal getDeterminant() throws InvalidMatrixException;\n     \n     /**\n-     * Is this a square matrix?\n-     * @return true if the matrix is square (rowDimension = columnDimension)\n-     */\n-    boolean isSquare();\n-    \n-    /**\n-     * Is this a singular matrix?\n-     * @return true if the matrix is singular\n-     */\n-    boolean isSingular();\n-    \n-    /**\n-     * Returns the number of rows in the matrix.\n-     *\n-     * @return rowDimension\n-     */\n-    int getRowDimension();\n-    \n-    /**\n-     * Returns the number of columns in the matrix.\n-     *\n-     * @return columnDimension\n-     */\n-    int getColumnDimension();\n-    \n-    /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/MatrixTrace.html\">\n      * trace</a> of the matrix (the sum of the elements on the main diagonal).\n      *\n--- a/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/BigMatrixImpl.java\n      *  positive\n      */\n     public BigMatrixImpl(int rowDimension, int columnDimension) {\n-        if (rowDimension <=0 || columnDimension <=0) {\n-            throw new IllegalArgumentException\n-            (\"row and column dimensions must be positive\");\n+        if (rowDimension <= 0 ) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid row dimension {0} (must be positive)\",\n+                    rowDimension);\n+        }\n+        if (columnDimension <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"invalid column dimension {0} (must be positive)\",\n+                    columnDimension);\n         }\n         data = new BigDecimal[rowDimension][columnDimension];\n         lu = null;\n             }   \n             final int nRows = d.length;\n             if (nRows == 0) {\n-                throw new IllegalArgumentException(\"Matrix must have at least one row.\"); \n-            }\n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+            }\n+\n             final int nCols = d[0].length;\n             if (nCols == 0) {\n-                throw new IllegalArgumentException(\"Matrix must have at least one column.\"); \n+                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n             }\n             for (int r = 1; r < nRows; r++) {\n                 if (d[r].length != nCols) {\n-                    throw new IllegalArgumentException(\"All input rows must have the same length.\");\n+                    throw MathRuntimeException.createIllegalArgumentException(\n+                          \"some rows have length {0} while others have length {1}\",\n+                          nCols, d[r].length); \n                 }\n             }       \n             data = d;\n     public BigMatrixImpl(double[][] d) {\n         final int nRows = d.length;\n         if (nRows == 0) {\n-            throw new IllegalArgumentException(\n-            \"Matrix must have at least one row.\"); \n-        }\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+        }\n+\n         final int nCols = d[0].length;\n         if (nCols == 0) {\n-            throw new IllegalArgumentException(\n-            \"Matrix must have at least one column.\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n         }\n         for (int row = 1; row < nRows; row++) {\n             if (d[row].length != nCols) {\n-                throw new IllegalArgumentException(\n-                \"All input rows must have the same length.\");\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"some rows have length {0} while others have length {1}\",\n+                      nCols, d[row].length); \n             }\n         }\n         this.copyIn(d);\n     public BigMatrixImpl(String[][] d) {\n         final int nRows = d.length;\n         if (nRows == 0) {\n-            throw new IllegalArgumentException(\n-            \"Matrix must have at least one row.\"); \n-        }\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+        }\n+\n         final int nCols = d[0].length;\n         if (nCols == 0) {\n-            throw new IllegalArgumentException(\n-            \"Matrix must have at least one column.\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n         }\n         for (int row = 1; row < nRows; row++) {\n             if (d[row].length != nCols) {\n-                throw new IllegalArgumentException(\n-                \"All input rows must have the same length.\");\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"some rows have length {0} while others have length {1}\",\n+                      nCols, d[row].length); \n             }\n         }\n         this.copyIn(d);\n         try {\n             return add((BigMatrixImpl) m);\n         } catch (ClassCastException cce) {\n+\n+            // safety check\n+            MatrixUtils.checkAdditionCompatible(this, m);\n+\n             final int rowCount    = getRowDimension();\n             final int columnCount = getColumnDimension();\n-            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n-                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n-            }\n             final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n             for (int row = 0; row < rowCount; row++) {\n                 final BigDecimal[] dataRow    = data[row];\n      * @throws  IllegalArgumentException if m is not the same size as this\n      */\n     public BigMatrixImpl add(BigMatrixImpl m) throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkAdditionCompatible(this, m);\n+\n         final int rowCount    = getRowDimension();\n         final int columnCount = getColumnDimension();\n-        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n-            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n-        }\n         final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n             final BigDecimal[] dataRow    = data[row];\n         try {\n             return subtract((BigMatrixImpl) m);\n         } catch (ClassCastException cce) {\n+\n+            // safety check\n+            MatrixUtils.checkSubtractionCompatible(this, m);\n+\n             final int rowCount    = getRowDimension();\n             final int columnCount = getColumnDimension();\n-            if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n-                throw new IllegalArgumentException(\"matrix dimension mismatch\");\n-            }\n             final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n             for (int row = 0; row < rowCount; row++) {\n                 final BigDecimal[] dataRow    = data[row];\n      * @throws  IllegalArgumentException if m is not the same size as this\n      */\n     public BigMatrixImpl subtract(BigMatrixImpl m) throws IllegalArgumentException {\n+\n+        // safety check\n+        MatrixUtils.checkSubtractionCompatible(this, m);\n+\n         final int rowCount    = getRowDimension();\n         final int columnCount = getColumnDimension();\n-        if (columnCount != m.getColumnDimension() || rowCount != m.getRowDimension()) {\n-            throw new IllegalArgumentException(\"matrix dimension mismatch\");\n-        }\n         final BigDecimal[][] outData = new BigDecimal[rowCount][columnCount];\n         for (int row = 0; row < rowCount; row++) {\n             final BigDecimal[] dataRow    = data[row];\n         try {\n             return multiply((BigMatrixImpl) m);\n         } catch (ClassCastException cce) {\n-            if (this.getColumnDimension() != m.getRowDimension()) {\n-                throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n-            }\n+\n+            // safety check\n+            MatrixUtils.checkMultiplicationCompatible(this, m);\n+\n             final int nRows = this.getRowDimension();\n             final int nCols = m.getColumnDimension();\n             final int nSum = this.getColumnDimension();\n      *             if columnDimension(this) != rowDimension(m)\n      */\n     public BigMatrixImpl multiply(BigMatrixImpl m) throws IllegalArgumentException {\n-        if (this.getColumnDimension() != m.getRowDimension()) {\n-            throw new IllegalArgumentException(\"Matrices are not multiplication compatible.\");\n-        }\n+\n+        // safety check\n+        MatrixUtils.checkMultiplicationCompatible(this, m);\n+\n         final int nRows = this.getRowDimension();\n         final int nCols = m.getColumnDimension();\n         final int nSum = this.getColumnDimension();\n                                   int startColumn, int endColumn)\n         throws MatrixIndexException {\n \n-        checkRowIndex(startRow);\n-        checkRowIndex(endRow);\n+        MatrixUtils.checkRowIndex(this, startRow);\n+        MatrixUtils.checkRowIndex(this, endRow);\n         if (startRow > endRow) {\n             throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n                                            startRow, endRow);\n         }\n \n-        checkColumnIndex(startColumn);\n-        checkColumnIndex(endColumn);\n+        MatrixUtils.checkColumnIndex(this, startColumn);\n+        MatrixUtils.checkColumnIndex(this, endColumn);\n         if (startColumn > endColumn) {\n             throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n                                            startColumn, endColumn);\n             // we redo the loop with checks enabled\n             // in order to generate an appropriate message\n             for (final int row : selectedRows) {\n-                checkRowIndex(row);\n+                MatrixUtils.checkRowIndex(this, row);\n             }\n             for (final int column : selectedColumns) {\n-                checkColumnIndex(column);\n+                MatrixUtils.checkColumnIndex(this, column);\n             }\n         }\n         return new BigMatrixImpl(subMatrixData, false);\n     throws MatrixIndexException {\n \n         final int nRows = subMatrix.length;\n+        if (nRows == 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\"); \n+        }\n+\n         final int nCols = subMatrix[0].length;\n-\n-        if (nRows == 0) {\n-            throw new IllegalArgumentException(\"Matrix must have at least one row.\"); \n-        }\n         if (nCols == 0) {\n-            throw new IllegalArgumentException(\"Matrix must have at least one column.\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\"); \n         }\n \n         for (int r = 1; r < nRows; r++) {\n             if (subMatrix[r].length != nCols) {\n-                throw new IllegalArgumentException(\"All input rows must have the same length.\");\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"some rows have length {0} while others have length {1}\",\n+                      nCols, subMatrix[r].length); \n             }\n         }\n \n             data = new BigDecimal[nRows][nCols];\n             System.arraycopy(subMatrix, 0, data, 0, subMatrix.length);          \n         } else {\n-            checkRowIndex(row);\n-            checkColumnIndex(column);\n-            checkRowIndex(nRows + row - 1);\n-            checkColumnIndex(nCols + column - 1);\n+            MatrixUtils.checkRowIndex(this, row);\n+            MatrixUtils.checkColumnIndex(this, column);\n+            MatrixUtils.checkRowIndex(this, nRows + row - 1);\n+            MatrixUtils.checkColumnIndex(this, nCols + column - 1);\n         }\n         for (int i = 0; i < nRows; i++) {\n             System.arraycopy(subMatrix[i], 0, data[row + i], column, nCols);\n      * @throws MatrixIndexException if the specified row index is invalid\n      */\n     public BigMatrix getRowMatrix(int row) throws MatrixIndexException {\n-        checkRowIndex(row);\n+        MatrixUtils.checkRowIndex(this, row);\n         final int ncols = this.getColumnDimension();\n         final BigDecimal[][] out = new BigDecimal[1][ncols]; \n         System.arraycopy(data[row], 0, out[0], 0, ncols);\n      * @throws MatrixIndexException if the specified column index is invalid\n      */\n     public BigMatrix getColumnMatrix(int column) throws MatrixIndexException {\n-        checkColumnIndex(column);\n+        MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = this.getRowDimension();\n         final BigDecimal[][] out = new BigDecimal[nRows][1]; \n         for (int row = 0; row < nRows; row++) {\n      * @throws MatrixIndexException if the specified row index is not valid\n      */\n     public BigDecimal[] getRow(int row) throws MatrixIndexException {\n-        checkRowIndex(row);\n+        MatrixUtils.checkRowIndex(this, row);\n         final int ncols = this.getColumnDimension();\n         final BigDecimal[] out = new BigDecimal[ncols];\n         System.arraycopy(data[row], 0, out, 0, ncols);\n      * @throws MatrixIndexException if the specified row index is not valid\n      */\n     public double[] getRowAsDoubleArray(int row) throws MatrixIndexException {\n-        checkRowIndex(row);\n+        MatrixUtils.checkRowIndex(this, row);\n         final int ncols = this.getColumnDimension();\n         final double[] out = new double[ncols];\n         for (int i=0;i<ncols;i++) {\n      * @throws MatrixIndexException if the specified column index is not valid\n      */\n     public BigDecimal[] getColumn(int col) throws MatrixIndexException {\n-        checkColumnIndex(col);\n+        MatrixUtils.checkColumnIndex(this, col);\n         final int nRows = this.getRowDimension();\n         final BigDecimal[] out = new BigDecimal[nRows];\n         for (int i = 0; i < nRows; i++) {\n      * @throws MatrixIndexException if the specified column index is not valid\n      */\n     public double[] getColumnAsDoubleArray(int col) throws MatrixIndexException {\n-        checkColumnIndex(col);\n+        MatrixUtils.checkColumnIndex(this, col);\n         final int nrows = this.getRowDimension();\n         final double[] out = new double[nrows];\n         for (int i=0;i<nrows;i++) {\n         lu = null;\n     }\n \n-    /**\n-     * Check if a row index is valid.\n-     * @param row row index to check\n-     * @exception MatrixIndexException if index is not valid\n-     */\n-    private void checkRowIndex(final int row) {\n-        if (row < 0 || row >= getRowDimension()) {\n-            throw new MatrixIndexException(\n-                    \"row index {0} out of allowed range [{1}, {2}]\",\n-                    row, 0, getRowDimension() - 1);\n-        }\n-    }\n-\n-    /**\n-     * Check if a column index is valid.\n-     * @param column column index to check\n-     * @exception MatrixIndexException if index is not valid\n-     */\n-    private void checkColumnIndex(final int column)\n-        throws MatrixIndexException {\n-        if (column < 0 || column >= getColumnDimension()) {\n-            throw new MatrixIndexException(\n-                    \"column index {0} out of allowed range [{1}, {2}]\",\n-                    column, 0, getColumnDimension() - 1);\n-        }\n-    }\n-\n }\n--- a/src/java/org/apache/commons/math/linear/DenseRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/DenseRealMatrix.java\n         } catch (ClassCastException cce) {\n \n             // safety check\n-            checkAdditionCompatible(m);\n+            MatrixUtils.checkAdditionCompatible(this, m);\n \n             final DenseRealMatrix out = new DenseRealMatrix(rows, columns);\n \n         throws IllegalArgumentException {\n \n         // safety check\n-        checkAdditionCompatible(m);\n+        MatrixUtils.checkAdditionCompatible(this, m);\n \n         final DenseRealMatrix out = new DenseRealMatrix(rows, columns);\n \n         } catch (ClassCastException cce) {\n \n             // safety check\n-            checkSubtractionCompatible(m);\n+            MatrixUtils.checkSubtractionCompatible(this, m);\n \n             final DenseRealMatrix out = new DenseRealMatrix(rows, columns);\n \n         throws IllegalArgumentException {\n \n         // safety check\n-        checkSubtractionCompatible(m);\n+        MatrixUtils.checkSubtractionCompatible(this, m);\n \n         final DenseRealMatrix out = new DenseRealMatrix(rows, columns);\n \n         } catch (ClassCastException cce) {\n \n             // safety check\n-            checkMultiplicationCompatible(m);\n+            MatrixUtils.checkMultiplicationCompatible(this, m);\n \n             final DenseRealMatrix out = new DenseRealMatrix(rows, m.getColumnDimension());\n \n     public DenseRealMatrix multiply(DenseRealMatrix m) throws IllegalArgumentException {\n \n         // safety check\n-        checkMultiplicationCompatible(m);\n+        MatrixUtils.checkMultiplicationCompatible(this, m);\n \n         final DenseRealMatrix out = new DenseRealMatrix(rows, m.columns);\n \n         throws MatrixIndexException {\n \n         // safety checks\n-        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n \n         // create the output matrix\n         final DenseRealMatrix out =\n         }\n         final int endRow    = row + subMatrix.length - 1;\n         final int endColumn = column + refLength - 1;\n-        checkSubMatrixIndex(row, endRow, column, endColumn);\n+        MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);\n         for (final double[] subRow : subMatrix) {\n             if (subRow.length != refLength) {\n                 throw MathRuntimeException.createIllegalArgumentException(\n     public RealMatrix getRowMatrix(final int row)\n         throws MatrixIndexException {\n \n-        checkRowIndex(row);\n+        MatrixUtils.checkRowIndex(this, row);\n         final DenseRealMatrix out = new DenseRealMatrix(1, columns);\n \n         // perform copy block-wise, to ensure good cache behavior\n     public void setRowMatrix(final int row, final DenseRealMatrix matrix)\n         throws MatrixIndexException, InvalidMatrixException {\n \n-        checkRowIndex(row);\n+        MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         if ((matrix.getRowDimension() != 1) ||\n             (matrix.getColumnDimension() != nCols)) {\n     public RealMatrix getColumnMatrix(final int column)\n         throws MatrixIndexException {\n \n-        checkColumnIndex(column);\n+        MatrixUtils.checkColumnIndex(this, column);\n         final DenseRealMatrix out = new DenseRealMatrix(rows, 1);\n \n         // perform copy block-wise, to ensure good cache behavior\n     void setColumnMatrix(final int column, final DenseRealMatrix matrix)\n         throws MatrixIndexException, InvalidMatrixException {\n \n-        checkColumnIndex(column);\n+        MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         if ((matrix.getRowDimension() != nRows) ||\n             (matrix.getColumnDimension() != 1)) {\n     public RealVector getRowVector(final int row)\n         throws MatrixIndexException {\n \n-        checkRowIndex(row);\n+        MatrixUtils.checkRowIndex(this, row);\n         final double[] outData = new double[columns];\n \n         // perform copy block-wise, to ensure good cache behavior\n     public RealVector getColumnVector(final int column)\n         throws MatrixIndexException {\n \n-        checkColumnIndex(column);\n+        MatrixUtils.checkColumnIndex(this, column);\n         final double[] outData = new double[rows];\n \n         // perform copy block-wise, to ensure good cache behavior\n     public double[] getRow(final int row)\n         throws MatrixIndexException {\n \n-        checkRowIndex(row);\n+        MatrixUtils.checkRowIndex(this, row);\n         final double[] out = new double[columns];\n \n         // perform copy block-wise, to ensure good cache behavior\n     public void setRow(final int row, final double[] array)\n         throws MatrixIndexException, InvalidMatrixException {\n \n-        checkRowIndex(row);\n+        MatrixUtils.checkRowIndex(this, row);\n         final int nCols = getColumnDimension();\n         if (array.length != nCols) {\n             throw new InvalidMatrixException(\n     public double[] getColumn(final int column)\n         throws MatrixIndexException {\n \n-        checkColumnIndex(column);\n+        MatrixUtils.checkColumnIndex(this, column);\n         final double[] out = new double[rows];\n \n         // perform copy block-wise, to ensure good cache behavior\n     public void setColumn(final int column, final double[] array)\n         throws MatrixIndexException, InvalidMatrixException {\n \n-        checkColumnIndex(column);\n+        MatrixUtils.checkColumnIndex(this, column);\n         final int nRows = getRowDimension();\n         if (array.length != nRows) {\n             throw new InvalidMatrixException(\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n         throws MatrixIndexException, MatrixVisitorException {\n-        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n             final int p0     = iBlock * BLOCK_SIZE;\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n         throws MatrixIndexException, MatrixVisitorException {\n-        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n             final int p0     = iBlock * BLOCK_SIZE;\n                                        final int startRow, final int endRow,\n                                        final int startColumn, final int endColumn)\n         throws MatrixIndexException, MatrixVisitorException {\n-        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n             final int p0     = iBlock * BLOCK_SIZE;\n                                        final int startRow, final int endRow,\n                                        final int startColumn, final int endColumn)\n         throws MatrixIndexException, MatrixVisitorException {\n-        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n             final int p0     = iBlock * BLOCK_SIZE;\n--- a/src/java/org/apache/commons/math/linear/FieldMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/FieldMatrix.java\n  * @param <T> the type of the field elements\n  * @version $Revision$ $Date$\n  */\n-public interface FieldMatrix<T extends FieldElement<T>> extends Serializable {\n+public interface FieldMatrix<T extends FieldElement<T>> extends AnyMatrix, Serializable {\n \n     /**\n      * Get the type of field elements of the matrix.\n     FieldMatrix<T> transpose();\n \n     /**\n-     * Is this a square matrix?\n-     * @return true if the matrix is square (rowDimension = columnDimension)\n-     */\n-    boolean isSquare();\n-\n-    /**\n-     * Returns the number of rows in the matrix.\n-     *\n-     * @return rowDimension\n-     */\n-    int getRowDimension();\n-\n-    /**\n-     * Returns the number of columns in the matrix.\n-     *\n-     * @return columnDimension\n-     */\n-    int getColumnDimension();\n-\n-    /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/MatrixTrace.html\">\n      * trace</a> of the matrix (the sum of the elements on the main diagonal).\n      *\n--- a/src/java/org/apache/commons/math/linear/MatrixUtils.java\n+++ b/src/java/org/apache/commons/math/linear/MatrixUtils.java\n         }\n         return new BigMatrixImpl(data, false);\n     }\n-    \n+\n+    /**\n+     * Check if a row index is valid.\n+     * @param m matrix containing the submatrix\n+     * @param row row index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    public static void checkRowIndex(final AnyMatrix m, final int row) {\n+        if (row < 0 || row >= m.getRowDimension()) {\n+            throw new MatrixIndexException(\"row index {0} out of allowed range [{1}, {2}]\",\n+                                           row, 0, m.getRowDimension() - 1);\n+        }\n+    }\n+\n+    /**\n+     * Check if a column index is valid.\n+     * @param m matrix containing the submatrix\n+     * @param column column index to check\n+     * @exception MatrixIndexException if index is not valid\n+     */\n+    public static void checkColumnIndex(final AnyMatrix m, final int column)\n+        throws MatrixIndexException {\n+        if (column < 0 || column >= m.getColumnDimension()) {\n+            throw new MatrixIndexException(\"column index {0} out of allowed range [{1}, {2}]\",\n+                                           column, 0, m.getColumnDimension() - 1);\n+        }\n+    }\n+\n+    /**\n+     * Check if submatrix ranges indices are valid.\n+     * Rows and columns are indicated counting from 0 to n-1.\n+     *\n+     * @param m matrix containing the submatrix\n+     * @param startRow Initial row index\n+     * @param endRow Final row index\n+     * @param startColumn Initial column index\n+     * @param endColumn Final column index\n+     * @exception MatrixIndexException  if the indices are not valid\n+     */\n+    public static void checkSubMatrixIndex(final AnyMatrix m,\n+                                           final int startRow, final int endRow,\n+                                           final int startColumn, final int endColumn) {\n+        checkRowIndex(m, startRow);\n+        checkRowIndex(m, endRow);\n+        if (startRow > endRow) {\n+            throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n+                                           startRow, endRow);\n+        }\n+\n+        checkColumnIndex(m, startColumn);\n+        checkColumnIndex(m, endColumn);\n+        if (startColumn > endColumn) {\n+            throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n+                                           startColumn, endColumn);\n+        }\n+\n+    \n+    }\n+\n+    /**\n+     * Check if submatrix ranges indices are valid.\n+     * Rows and columns are indicated counting from 0 to n-1.\n+     *\n+     * @param m matrix containing the submatrix\n+     * @param selectedRows Array of row indices.\n+     * @param selectedColumns Array of column indices.\n+     * @exception MatrixIndexException if row or column selections are not valid\n+     */\n+    public static void checkSubMatrixIndex(final AnyMatrix m,\n+                                           final int[] selectedRows, final int[] selectedColumns)\n+        throws MatrixIndexException {\n+        if (selectedRows.length * selectedColumns.length == 0) {\n+            if (selectedRows.length == 0) {\n+                throw new MatrixIndexException(\"empty selected row index array\");\n+            }\n+            throw new MatrixIndexException(\"empty selected column index array\");\n+        }\n+\n+        for (final int row : selectedRows) {\n+            checkRowIndex(m, row);\n+        }\n+        for (final int column : selectedColumns) {\n+            checkColumnIndex(m, column);\n+        }\n+    }\n+\n+    /**\n+     * Check if matrices are addition compatible\n+     * @param left left hand side matrix\n+     * @param right right hand side matrix\n+     * @exception IllegalArgumentException if matrices are not addition compatible\n+     */\n+    public static void checkAdditionCompatible(final AnyMatrix left, final AnyMatrix right)\n+        throws IllegalArgumentException {\n+        if ((left.getRowDimension()    != right.getRowDimension()) ||\n+            (left.getColumnDimension() != right.getColumnDimension())) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0}x{1} and {2}x{3} matrices are not addition compatible\",\n+                    left.getRowDimension(), left.getColumnDimension(),\n+                    right.getRowDimension(), right.getColumnDimension());\n+        }\n+    }\n+\n+    /**\n+     * Check if matrices are subtraction compatible\n+     * @param left left hand side matrix\n+     * @param right right hand side matrix\n+     * @exception IllegalArgumentException if matrices are not subtraction compatible\n+     */\n+    public static void checkSubtractionCompatible(final AnyMatrix left, final AnyMatrix right)\n+        throws IllegalArgumentException {\n+        if ((left.getRowDimension()    != right.getRowDimension()) ||\n+            (left.getColumnDimension() != right.getColumnDimension())) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0}x{1} and {2}x{3} matrices are not subtraction compatible\",\n+                    left.getRowDimension(), left.getColumnDimension(),\n+                    right.getRowDimension(), right.getColumnDimension());\n+        }\n+    }\n+\n+    /**\n+     * Check if matrices are multiplication compatible\n+     * @param left left hand side matrix\n+     * @param right right hand side matrix\n+     * @exception IllegalArgumentException if matrices are not multiplication compatible\n+     */\n+    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\n+        throws IllegalArgumentException {\n+        if (left.getColumnDimension() != right.getRowDimension()) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n+                    left.getRowDimension(), left.getColumnDimension(),\n+                    right.getRowDimension(), right.getColumnDimension());\n+        }\n+    }\n+\n }\n-\n--- a/src/java/org/apache/commons/math/linear/RealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrix.java\n  * \n  * @version $Revision$ $Date$\n  */\n-public interface RealMatrix extends Serializable {\n+public interface RealMatrix extends AnyMatrix, Serializable {\n \n     /**\n      * Create a new RealMatrix of the same type as the instance with the supplied\n     double getDeterminant();\n \n     /**\n-     * Is this a square matrix?\n-     * @return true if the matrix is square (rowDimension = columnDimension)\n-     */\n-    boolean isSquare();\n-\n-    /**\n      * Is this a singular matrix?\n      * @return true if the matrix is singular\n      * @deprecated as of release 2.0, replaced by the boolean negation of\n      */\n     @Deprecated\n     boolean isSingular();\n-\n-    /**\n-     * Returns the number of rows in the matrix.\n-     *\n-     * @return rowDimension\n-     */\n-    int getRowDimension();\n-\n-    /**\n-     * Returns the number of columns in the matrix.\n-     *\n-     * @return columnDimension\n-     */\n-    int getColumnDimension();\n \n     /**\n      * Returns the <a href=\"http://mathworld.wolfram.com/MatrixTrace.html\">\n--- a/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n+++ b/src/java/org/apache/commons/math/linear/RealMatrixImpl.java\n         throws IllegalArgumentException {\n \n         // safety check\n-        checkAdditionCompatible(m);\n+        MatrixUtils.checkAdditionCompatible(this, m);\n \n         final int rowCount    = getRowDimension();\n         final int columnCount = getColumnDimension();\n         throws IllegalArgumentException {\n \n         // safety check\n-        checkSubtractionCompatible(m);\n+        MatrixUtils.checkSubtractionCompatible(this, m);\n \n         final int rowCount    = getRowDimension();\n         final int columnCount = getColumnDimension();\n         throws IllegalArgumentException {\n \n         // safety check\n-        checkMultiplicationCompatible(m);\n+        MatrixUtils.checkMultiplicationCompatible(this, m);\n \n         final int nRows = this.getRowDimension();\n         final int nCols = m.getColumnDimension();\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n         throws MatrixIndexException, MatrixVisitorException {\n-        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n         for (int i = startRow; i <= endRow; ++i) {\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n         throws MatrixIndexException, MatrixVisitorException {\n-        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n         for (int i = startRow; i <= endRow; ++i) {\n                                     final int startRow, final int endRow,\n                                     final int startColumn, final int endColumn)\n         throws MatrixIndexException, MatrixVisitorException {\n-        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n         for (int j = startColumn; j <= endColumn; ++j) {\n                                     final int startRow, final int endRow,\n                                     final int startColumn, final int endColumn)\n         throws MatrixIndexException, MatrixVisitorException {\n-        checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n+        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n         for (int j = startColumn; j <= endColumn; ++j) {\n--- a/src/java/org/apache/commons/math/linear/RealVectorFormat.java\n+++ b/src/java/org/apache/commons/math/linear/RealVectorFormat.java\n             return format( (RealVector)obj, toAppendTo, pos);\n         }\n \n-        throw new IllegalArgumentException(\"Cannot format given Object as a RealVector\");\n+        throw MathRuntimeException.createIllegalArgumentException(\n+              \"cannot format a {0} instance as a real vector\",\n+              obj.getClass().getName());\n \n     }\n \n--- a/src/java/org/apache/commons/math/linear/SparseRealMatrix.java\n+++ b/src/java/org/apache/commons/math/linear/SparseRealMatrix.java\n     public RealMatrix add(SparseRealMatrix m) throws IllegalArgumentException {\n \n         // safety check\n-        checkAdditionCompatible(m);\n+        MatrixUtils.checkAdditionCompatible(this, m);\n \n         final RealMatrix out = new SparseRealMatrix(this);\n         for (OpenIntToDoubleHashMap.Iterator iterator = m.entries.iterator(); iterator.hasNext();) {\n     public RealMatrix subtract(SparseRealMatrix m) throws IllegalArgumentException {\n \n         // safety check\n-        checkAdditionCompatible(m);\n+        MatrixUtils.checkAdditionCompatible(this, m);\n \n         final RealMatrix out = new SparseRealMatrix(this);\n         for (OpenIntToDoubleHashMap.Iterator iterator = m.entries.iterator(); iterator.hasNext();) {\n         } catch (ClassCastException cce) {\n \n             // safety check\n-            checkMultiplicationCompatible(m);\n+            MatrixUtils.checkMultiplicationCompatible(this, m);\n \n             final int outCols = m.getColumnDimension();\n             final DenseRealMatrix out = new DenseRealMatrix(rowDimension, outCols);\n     public SparseRealMatrix multiply(SparseRealMatrix m) throws IllegalArgumentException {\n \n         // safety check\n-        checkMultiplicationCompatible(m);\n+        MatrixUtils.checkMultiplicationCompatible(this, m);\n \n         final int outCols = m.getColumnDimension();\n         SparseRealMatrix out = new SparseRealMatrix(rowDimension, outCols);\n     /** {@inheritDoc} */\n     @Override\n     public double getEntry(int row, int column) throws MatrixIndexException {\n-        checkRowIndex(row);\n-        checkColumnIndex(column);\n+        MatrixUtils.checkRowIndex(this, row);\n+        MatrixUtils.checkColumnIndex(this, column);\n         return entries.get(computeKey(row, column));\n     }\n \n     @Override\n     public void setEntry(int row, int column, double value)\n             throws MatrixIndexException {\n-        checkRowIndex(row);\n-        checkColumnIndex(column);\n+        MatrixUtils.checkRowIndex(this, row);\n+        MatrixUtils.checkColumnIndex(this, column);\n         if (value == 0.0) {\n             entries.remove(computeKey(row, column));\n         } else {\n     @Override\n     public void addToEntry(int row, int column, double increment)\n             throws MatrixIndexException {\n-        checkRowIndex(row);\n-        checkColumnIndex(column);\n+        MatrixUtils.checkRowIndex(this, row);\n+        MatrixUtils.checkColumnIndex(this, column);\n         final int key = computeKey(row, column);\n         final double value = entries.get(key) + increment;\n         if (value == 0.0) {\n     @Override\n     public void multiplyEntry(int row, int column, double factor)\n             throws MatrixIndexException {\n-        checkRowIndex(row);\n-        checkColumnIndex(column);\n+        MatrixUtils.checkRowIndex(this, row);\n+        MatrixUtils.checkColumnIndex(this, column);\n         final int key = computeKey(row, column);\n         final double value = entries.get(key) * factor;\n         if (value == 0.0) {\n--- a/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n+++ b/src/java/org/apache/commons/math/ode/ContinuousOutputModel.java\n     } else {\n \n       if (getInterpolatedState().length != model.getInterpolatedState().length) {\n-        throw new IllegalArgumentException(\"state vector dimension mismatch\");\n+          throw MathRuntimeException.createIllegalArgumentException(\n+                \"dimension mismatch {0} != {1}\",\n+                getInterpolatedState().length, model.getInterpolatedState().length);\n       }\n \n       if (forward ^ model.forward) {\n-        throw new IllegalArgumentException(\"propagation direction mismatch\");\n+          throw MathRuntimeException.createIllegalArgumentException(\n+                \"propagation direction mismatch\");\n       }\n \n       final StepInterpolator lastInterpolator = steps.get(index);\n       final double step = current - previous;\n       final double gap = model.getInitialTime() - current;\n       if (Math.abs(gap) > 1.0e-3 * Math.abs(step)) {\n-        throw new IllegalArgumentException(\"hole between time ranges\");\n+        throw MathRuntimeException.createIllegalArgumentException(\n+              \"{0} wide hole between models time ranges\", Math.abs(gap));\n       }\n \n     }\n--- a/src/java/org/apache/commons/math/ode/NordsieckTransformer.java\n+++ b/src/java/org/apache/commons/math/ode/NordsieckTransformer.java\n  * org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator Adams-Bashforth}\n  * integrator uses p=1, q=2, r=1, s=n. The {@link\n  * org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator Adams-Moulton}\n- * integrator uses p=1, q=2, r=0, s=n-1.\n+ * integrator uses p=1, q=2, r=0, s=n-1. The {@link\n+ * org.apache.commons.math.ode.stiff.BDFIntegrator BDF} integrator uses p=1, q=n,\n+ * r=0, s=1.\n  * </p>\n  * <p>\n  * The Nordsieck form for a dimension n state history at step k is composed of the\n  * @see org.apache.commons.math.ode.MultistepIntegrator\n  * @see org.apache.commons.math.ode.nonstiff.AdamsBashforthIntegrator\n  * @see org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator\n+ * @see org.apache.commons.math.ode.stiff.BDFIntegrator\n  * @version $Revision$ $Date$\n  * @since 2.0\n  */\n--- a/src/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n+++ b/src/java/org/apache/commons/math/random/AbstractRandomGenerator.java\n  */\n package org.apache.commons.math.random;\n \n+import org.apache.commons.math.MathRuntimeException;\n+\n /**\n  * Abstract class implementing the {@link  RandomGenerator} interface.\n  * Default implementations for all methods other than {@link #nextDouble()} and\n      */\n     public int nextInt(int n) {\n         if (n <= 0 ) {\n-            throw new IllegalArgumentException(\"upper bound must be positive\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"upper bound must be positive ({0})\", n);\n         }\n         int result = (int) (nextDouble() * n);\n         return result < n ? result : n - 1;\n--- a/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n                 double[] inputArray = (double[]) in;\n                 return new ArrayDataAdapter(inputArray);\n             } else {\n-                throw new IllegalArgumentException(\n-                    \"Input data comes from the\" + \" unsupported source\");\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"input data comes from unsupported datasource: {0}, \" +\n+                      \"supported sources: {1}, {2}\",\n+                      in.getClass().getName(),\n+                      BufferedReader.class.getName(), double[].class.getName());\n             }\n         }\n     }\n--- a/src/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/java/org/apache/commons/math/random/RandomDataImpl.java\n import java.security.NoSuchProviderException;\n import java.util.Collection;\n \n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.MathUtils;\n \n /**\n      */\n     public String nextHexString(int len) {\n         if (len <= 0) {\n-            throw new IllegalArgumentException(\"length must be positive\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"length must be positive ({0})\", len);\n         }\n \n         // Get a random number generator\n      */\n     public int nextInt(int lower, int upper) {\n         if (lower >= upper) {\n-            throw new IllegalArgumentException(\n-                    \"upper bound must be > lower bound\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    \"upper bound ({0}) must be greater than lower bound ({1})\",\n+                    upper, lower);\n         }\n         RandomGenerator rand = getRan();\n         double r = rand.nextDouble();\n      */\n     public long nextLong(long lower, long upper) {\n         if (lower >= upper) {\n-            throw new IllegalArgumentException(\n-                    \"upper bound must be > lower bound\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"upper bound ({0}) must be greater than lower bound ({1})\",\n+                  upper, lower);\n         }\n         RandomGenerator rand = getRan();\n         double r = rand.nextDouble();\n      */\n     public String nextSecureHexString(int len) {\n         if (len <= 0) {\n-            throw new IllegalArgumentException(\"length must be positive\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"length must be positive ({0})\", len);\n         }\n \n         // Get SecureRandom and setup Digest provider\n      */\n     public int nextSecureInt(int lower, int upper) {\n         if (lower >= upper) {\n-            throw new IllegalArgumentException(\n-                    \"lower bound must be < upper bound\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"upper bound ({0}) must be greater than lower bound ({1})\",\n+                  upper, lower);\n         }\n         SecureRandom sec = getSecRan();\n         return lower + (int) (sec.nextDouble() * (upper - lower + 1));\n      */\n     public long nextSecureLong(long lower, long upper) {\n         if (lower >= upper) {\n-            throw new IllegalArgumentException(\n-                    \"lower bound must be < upper bound\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"upper bound ({0}) must be greater than lower bound ({1})\",\n+                  upper, lower);\n         }\n         SecureRandom sec = getSecRan();\n         return lower + (long) (sec.nextDouble() * (upper - lower + 1));\n      */\n     public long nextPoisson(double mean) {\n         if (mean <= 0) {\n-            throw new IllegalArgumentException(\"Poisson mean must be > 0\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"the Poisson mean must be positive ({0})\", mean);\n         }\n \n         RandomGenerator rand = getRan();\n      */\n     public double nextGaussian(double mu, double sigma) {\n         if (sigma <= 0) {\n-            throw new IllegalArgumentException(\"Gaussian std dev must be > 0\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"standard deviation must be positive ({0})\", sigma);\n         }\n         RandomGenerator rand = getRan();\n         return sigma * rand.nextGaussian() + mu;\n      */\n     public double nextExponential(double mean) {\n         if (mean < 0.0) {\n-            throw new IllegalArgumentException(\"Exponential mean must be >= 0\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"mean must be positive ({0})\", mean);\n         }\n         RandomGenerator rand = getRan();\n         double unif = rand.nextDouble();\n      */\n     public double nextUniform(double lower, double upper) {\n         if (lower >= upper) {\n-            throw new IllegalArgumentException(\n-                    \"lower bound must be < upper bound\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"upper bound ({0}) must be greater than lower bound ({1})\",\n+                  upper, lower);\n         }\n         RandomGenerator rand = getRan();\n \n      */\n     public int[] nextPermutation(int n, int k) {\n         if (k > n) {\n-            throw new IllegalArgumentException(\"permutation k exceeds n\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"permutation k ({0}) exceeds n ({1})\", k, n);\n         }\n         if (k == 0) {\n-            throw new IllegalArgumentException(\"permutation k must be > 0\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"permutation k ({0}) must be positive\", k);\n         }\n \n         int[] index = getNatural(n);\n     public Object[] nextSample(Collection<?> c, int k) {\n         int len = c.size();\n         if (k > len) {\n-            throw new IllegalArgumentException(\n-                    \"sample size exceeds collection size\");\n-        }\n-        if (k == 0) {\n-            throw new IllegalArgumentException(\"sample size must be > 0\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"sample size ({0}) exceeds collection size ({1})\");\n+        }\n+        if (k <= 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"sample size must be positive ({0})\", k);\n         }\n \n         Object[] objects = c.toArray();\n         }\n         return natural;\n     }\n+\n }\n--- a/src/java/org/apache/commons/math/random/UncorrelatedRandomVectorGenerator.java\n+++ b/src/java/org/apache/commons/math/random/UncorrelatedRandomVectorGenerator.java\n package org.apache.commons.math.random;\n \n import java.util.Arrays;\n+\n+import org.apache.commons.math.MathRuntimeException;\n \n /** \n  * A {@link RandomVectorGenerator} that generates vectors with uncorrelated\n                                            double[] standardDeviation,\n                                            NormalizedRandomGenerator generator) {\n     if (mean.length != standardDeviation.length) {\n-      throw new IllegalArgumentException(\"dimension mismatch\");\n+      throw MathRuntimeException.createIllegalArgumentException(\n+            \"dimension mismatch {0} != {1}\",\n+            mean.length, standardDeviation.length);\n     }\n     this.mean              = mean.clone();\n     this.standardDeviation = standardDeviation.clone();\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n import java.util.Iterator;\n import java.util.Comparator;\n import java.util.TreeMap;\n+\n+import org.apache.commons.math.MathRuntimeException;\n \n /** \n  * Maintains a frequency distribution.\n         if (v instanceof Comparable<?>){\n             addValue((Comparable<?>) v);            \n         } else {\n-            throw new IllegalArgumentException(\"Object must implement Comparable\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"class ({0}) does not implement Comparable\",\n+                  v.getClass().getName());\n         }\n     }\n     \n             }\n         } catch (ClassCastException ex) {   \n             //TreeMap will throw ClassCastException if v is not comparable\n-            throw new IllegalArgumentException(\"Value not comparable to existing values.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"instance of class {0} not comparable to existing values\",\n+                  v.getClass().getName());\n         }\n     }\n \n--- a/src/java/org/apache/commons/math/stat/StatUtils.java\n+++ b/src/java/org/apache/commons/math/stat/StatUtils.java\n  */\n package org.apache.commons.math.stat;\n \n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n import org.apache.commons.math.stat.descriptive.moment.GeometricMean;\n import org.apache.commons.math.stat.descriptive.moment.Mean;\n     public static double sumDifference(final double[] sample1, final double[] sample2)\n         throws IllegalArgumentException {\n         int n = sample1.length;\n-        if (n  != sample2.length || n < 1) {\n-            throw new IllegalArgumentException \n-                (\"Input arrays must have the same (positive) length.\");\n+        if ((n  != sample2.length) || (n < 1)) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"input arrays must have the same positive length ({0} and {1})\",\n+                  n, sample2.length);\n         }\n         double result = 0;\n         for (int i = 0; i < n; i++) {\n         double diff = 0d;\n         int n = sample1.length;\n         if (n < 2 || n != sample2.length) {\n-            throw new IllegalArgumentException(\"Input array lengths must be equal and at least 2.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"input arrays must have the same length and at least two elements ({0} and {1})\",\n+                  n, sample2.length);\n         }\n         for (int i = 0; i < n; i++) {\n             diff = sample1[i] - sample2[i];\n--- a/src/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n  */\n package org.apache.commons.math.stat.descriptive;\n \n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.util.MathUtils;\n import java.io.Serializable;\n \n     @Override\n     public double evaluate(final double[] values) {\n         if (values == null) {\n-            throw new IllegalArgumentException(\"input value array is null\");\n+            throw MathRuntimeException.createIllegalArgumentException(\"input values array is null\");\n         }\n         return evaluate(values, 0, values.length);\n     }\n      */\n     public void incrementAll(double[] values) {\n         if (values == null) {\n-            throw new IllegalArgumentException(\"input values array is null\");\n+            throw MathRuntimeException.createIllegalArgumentException(\"input values array is null\");\n         }\n         incrementAll(values, 0, values.length);\n     } \n--- a/src/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n package org.apache.commons.math.stat.descriptive;\n \n import java.io.Serializable;\n+\n+import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * Abstract base class for all implementations of the \n         final int length) {\n \n         if (values == null) {\n-            throw new IllegalArgumentException(\"input value array is null\");\n+            throw MathRuntimeException.createIllegalArgumentException(\"input values array is null\");\n         }\n         \n         if (begin < 0) {\n-            throw new IllegalArgumentException(\"start position cannot be negative\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"start position cannot be negative ({0})\", begin);\n         }\n         \n         if (length < 0) {\n-            throw new IllegalArgumentException(\"length cannot be negative\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"length cannot be negative ({0})\", length);\n         }\n         \n         if (begin + length > values.length) {\n-            throw new IllegalArgumentException(\n-                \"begin + length > values.length\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"subarray ends after array end\");\n         }\n \n         if (length == 0) {\n--- a/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n import java.lang.reflect.InvocationTargetException;\n import java.util.Arrays;\n \n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.stat.descriptive.moment.GeometricMean;\n import org.apache.commons.math.stat.descriptive.moment.Kurtosis;\n import org.apache.commons.math.stat.descriptive.moment.Mean;\n     public void setWindowSize(int windowSize) {\n         if (windowSize < 1) {\n             if (windowSize != INFINITE_WINDOW) {\n-                throw new IllegalArgumentException(\"window size must be positive.\");\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"window size must be positive ({0})\", windowSize);\n             }\n         }\n         \n                         new Class[] {Double.TYPE}).invoke(percentileImpl,\n                                 new Object[] {Double.valueOf(p)});\n             } catch (NoSuchMethodException e1) { // Setter guard should prevent\n-                throw new IllegalArgumentException(\n-                   \"Percentile implementation does not support setQuantile\");\n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"percentile implementation {0} does not support setQuantile\",\n+                      percentileImpl.getClass().getName());\n             } catch (IllegalAccessException e2) {\n-                throw new IllegalArgumentException(\n-                    \"IllegalAccessException setting quantile\"); \n+                throw MathRuntimeException.createIllegalArgumentException(\n+                      \"cannot access setQuantile method in percentile implementation {0}\",\n+                      percentileImpl.getClass().getName());\n             } catch (InvocationTargetException e3) {\n-                throw new IllegalArgumentException(\n-                    \"Error setting quantile\" + e3.toString()); \n+                throw MathRuntimeException.createIllegalArgumentException(e3.getCause()); \n             }\n         }\n         return apply(percentileImpl);\n                     new Class[] {Double.TYPE}).invoke(percentileImpl,\n                             new Object[] {Double.valueOf(50.0d)});\n         } catch (NoSuchMethodException e1) { \n-            throw new IllegalArgumentException(\n-                    \"Percentile implementation does not support setQuantile\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"percentile implementation {0} does not support setQuantile\",\n+                  percentileImpl.getClass().getName());\n         } catch (IllegalAccessException e2) {\n-            throw new IllegalArgumentException(\n-                \"IllegalAccessException setting quantile\"); \n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"cannot access setQuantile method in percentile implementation {0}\",\n+                  percentileImpl.getClass().getName());\n         } catch (InvocationTargetException e3) {\n-            throw new IllegalArgumentException(\n-                \"Error setting quantile\" + e3.toString()); \n+            throw MathRuntimeException.createIllegalArgumentException(e3.getCause()); \n         }\n         this.percentileImpl = percentileImpl;\n     }\n--- a/src/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n \n import java.io.Serializable;\n \n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n \n /**\n     @Override\n     public double evaluate(final double[] values) {\n         if (values == null) {\n-            throw new IllegalArgumentException(\"input values array is null\");\n+            throw MathRuntimeException.createIllegalArgumentException(\"input values array is null\");\n         }\n         return evaluate(values, 0, values.length);\n     }\n--- a/src/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n \n import java.io.Serializable;\n import java.util.Arrays;\n+\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic;\n \n /**\n         test(values, begin, length);\n \n         if ((p > 100) || (p <= 0)) {\n-            throw new IllegalArgumentException(\"invalid quantile value: \" + p);\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"out of bounds quantile value: {0}, must be in (0, 100]\", p);\n         }\n         if (length == 0) {\n             return Double.NaN;\n      */\n     public void setQuantile(final double p) {\n         if (p <= 0 || p > 100) {\n-            throw new IllegalArgumentException(\"Illegal quantile value: \" + p);\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"out of bounds quantile value: {0}, must be in (0, 100]\", p);\n         }\n         quantile = p;\n     }\n--- a/src/java/org/apache/commons/math/stat/regression/AbstractMultipleLinearRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/AbstractMultipleLinearRegression.java\n \n import org.apache.commons.math.linear.RealMatrix;\n import org.apache.commons.math.linear.RealMatrixImpl;\n+import org.apache.commons.math.linear.RealVector;\n+import org.apache.commons.math.linear.RealVectorImpl;\n \n /**\n  * Abstract base class for implementations of MultipleLinearRegression.\n     protected RealMatrix X;\n \n     /** Y sample data. */\n-    protected RealMatrix Y;\n+    protected RealVector Y;\n \n     /**\n      * Loads model x and y sample data from a flat array of data, overriding any previous sample.\n      * \n      * @param data input data array\n      * @param nobs number of observations (rows)\n-     * @param nvars number of independent variables (columnns, not counting y)\n+     * @param nvars number of independent variables (columns, not counting y)\n      */\n     public void newSampleData(double[] data, int nobs, int nvars) {\n         double[] y = new double[nobs];\n             }\n         }\n         this.X = new RealMatrixImpl(x);\n-        this.Y = new RealMatrixImpl(y);\n+        this.Y = new RealVectorImpl(y);\n     }\n     \n     /**\n      * @param y the [n,1] array representing the y sample\n      */\n     protected void newYSampleData(double[] y) {\n-        this.Y = new RealMatrixImpl(y);\n+        this.Y = new RealVectorImpl(y);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     public double[] estimateRegressionParameters() {\n-        RealMatrix b = calculateBeta();\n-        return b.getColumn(0);\n+        RealVector b = calculateBeta();\n+        return b.getData();\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     public double[] estimateResiduals() {\n-        RealMatrix b = calculateBeta();\n-        RealMatrix e = Y.subtract(X.multiply(b));\n-        return e.getColumn(0);\n+        RealVector b = calculateBeta();\n+        RealVector e = Y.subtract(X.operate(b));\n+        return e.getData();\n     }\n \n     /**\n      * \n      * @return beta\n      */\n-    protected abstract RealMatrix calculateBeta();\n+    protected abstract RealVector calculateBeta();\n \n     /**\n      * Calculates the beta variance of multiple linear regression in matrix\n      * \n      * @return The residuals [n,1] matrix\n      */\n-    protected RealMatrix calculateResiduals() {\n-        RealMatrix b = calculateBeta();\n-        return Y.subtract(X.multiply(b));\n+    protected RealVector calculateResiduals() {\n+        RealVector b = calculateBeta();\n+        return Y.subtract(X.operate(b));\n     }\n \n }\n--- a/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.distribution.TDistribution;\n import org.apache.commons.math.distribution.TDistributionImpl;\n \n     public double getSlopeConfidenceInterval(double alpha)\n         throws MathException {\n         if (alpha >= 1 || alpha <= 0) {\n-            throw new IllegalArgumentException();\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"out of bounds significance level {0}, must be in (0, 1)\",\n+                  alpha);\n         }\n         return getSlopeStdErr() *\n             distribution.inverseCumulativeProbability(1d - alpha / 2d);\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n      *         by a long integer.\n      */\n     public static long binomialCoefficient(final int n, final int k) {\n-        if (n < k) {\n-            throw new IllegalArgumentException(\n-                \"must have n >= k for binomial coefficient (n,k)\");\n-        }\n-        if (n < 0) {\n-            throw new IllegalArgumentException(\n-                \"must have n >= 0 for binomial coefficient (n,k)\");\n-        }\n+        checkBinomial(n, k);\n         if ((n == k) || (k == 0)) {\n             return 1;\n         }\n      * @throws IllegalArgumentException if preconditions are not met.\n      */\n     public static double binomialCoefficientDouble(final int n, final int k) {\n-        if (n < k) {\n-            throw new IllegalArgumentException(\n-                \"must have n >= k for binomial coefficient (n,k)\");\n-        }\n-        if (n < 0) {\n-            throw new IllegalArgumentException(\n-                \"must have n >= 0 for binomial coefficient (n,k)\");\n-        }\n+        checkBinomial(n, k);\n         if ((n == k) || (k == 0)) {\n             return 1d;\n         }\n      * @throws IllegalArgumentException if preconditions are not met.\n      */\n     public static double binomialCoefficientLog(final int n, final int k) {\n-        if (n < k) {\n-            throw new IllegalArgumentException(\n-                \"must have n >= k for binomial coefficient (n,k)\");\n-        }\n-        if (n < 0) {\n-            throw new IllegalArgumentException(\n-                \"must have n >= 0 for binomial coefficient (n,k)\");\n-        }\n+        checkBinomial(n, k);\n         if ((n == k) || (k == 0)) {\n             return 0;\n         }\n         }\n \n         return logSum;      \n+    }\n+\n+    /**\n+     * Check binomial preconditions.\n+     * @param n the size of the set\n+     * @param k the size of the subsets to be counted\n+     * @exception IllegalArgumentException if preconditions are not met.\n+     */\n+    private static void checkBinomial(final int n, final int k)\n+        throws IllegalArgumentException {\n+        if (n < k) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                \"must have n >= k for binomial coefficient (n,k), got n = {0}, k = {1}\",\n+                n, k);\n+        }\n+        if (n < 0) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"must have n >= 0 for binomial coefficient (n,k), got n = {0}\",\n+                  n);\n+        }\n     }\n     \n     /**\n      */\n     public static long factorial(final int n) {\n         if (n < 0) {\n-            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"must have n >= 0 for n!, got n = {0}\",\n+                  n);\n         }\n         if (n > 20) {\n             throw new ArithmeticException(\n      */\n     public static double factorialDouble(final int n) {\n         if (n < 0) {\n-            throw new IllegalArgumentException(\"must have n >= 0 for n!\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"must have n >= 0 for n!, got n = {0}\",\n+                  n);\n         }\n         if (n < 21) {\n             return factorial(n);\n      */\n     public static double factorialLog(final int n) {\n         if (n < 0) {\n-            throw new IllegalArgumentException(\"must have n > 0 for n!\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"must have n >= 0 for n!, got n = {0}\",\n+                  n);\n         }\n         if (n < 21) {\n             return Math.log(factorial(n));\n             unscaled = Math.ceil(nextAfter(unscaled,  Double.POSITIVE_INFINITY));\n             break;\n         default :\n-            throw new IllegalArgumentException(\"Invalid rounding method.\");\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                  \"invalid rounding method {0}, valid methods: {1} ({2}), {3} ({4}),\" +\n+                  \" {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})\",\n+                  roundingMethod,\n+                  \"ROUND_CEILING\",     BigDecimal.ROUND_CEILING,\n+                  \"ROUND_DOWN\",        BigDecimal.ROUND_DOWN,\n+                  \"ROUND_FLOOR\",       BigDecimal.ROUND_FLOOR,\n+                  \"ROUND_HALF_DOWN\",   BigDecimal.ROUND_HALF_DOWN,\n+                  \"ROUND_HALF_EVEN\",   BigDecimal.ROUND_HALF_EVEN,\n+                  \"ROUND_HALF_UP\",     BigDecimal.ROUND_HALF_UP,\n+                  \"ROUND_UNNECESSARY\", BigDecimal.ROUND_UNNECESSARY,\n+                  \"ROUND_UP\",          BigDecimal.ROUND_UP);\n         }\n         return unscaled;\n     }", "timestamp": 1241603008, "metainfo": ""}