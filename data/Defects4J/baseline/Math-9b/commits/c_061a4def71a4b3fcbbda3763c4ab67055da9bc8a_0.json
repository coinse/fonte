{"sha": "061a4def71a4b3fcbbda3763c4ab67055da9bc8a", "log": "Added adapters for simple bounds constraints optimization.  The adapters are useful only for optimizers that do not support simple bounds constraints by themselves (i.e. Nelder-Mead and Torczon's multidirectional). Two adapters are available, one performs a mapping between the whole real range and the bounded range (bounds being set component wise), and one uses a penalty function.   JIRA: MATH-196  ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultivariateRealFunctionMappingAdapter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.function.Logit;\n+import org.apache.commons.math.analysis.function.Sigmoid;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * <p>Adapter for mapping bounded {@link MultivariateRealFunction} to unbounded ones.</p>\n+ *\n+ * <p>\n+ * This adapter can be used to wrap functions subject to simple bounds on\n+ * parameters so they can be used by optimizers that do <em>not</em> directly\n+ * support simple bounds.\n+ * </p>\n+ * <p>\n+ * The principle is that the user function that will be wrapped will see its\n+ * parameters bounded as required, i.e when its {@code value} method is called\n+ * with argument array {@code point}, the elements array will fulfill requirement\n+ * {@code lower[i] <= point[i] <= upper[i]} for all i. Some of the components\n+ * may be unbounded or bounded only on one side if the corresponding bound is\n+ * set to an infinite value. The optimizer will not manage the user function by\n+ * itself, but it will handle this adapter and it is this adapter that will take\n+ * care the bounds are fulfilled. The adapter {@link #value(double[])} method will\n+ * be called by the optimizer with unbound parameters, and the adapter will map\n+ * the unbounded value to the bounded range using appropriate functions like\n+ * {@link Sigmoid} for double bounded elements for example.\n+ * </p>\n+ * <p>\n+ * As the optimizer sees only unbounded parameters, it should be noted that the\n+ * start point or simplex expected by the optimizer should be unbounded, so the\n+ * user is responsible for converting his bounded point to unbounded by calling\n+ * {@link #boundedToUnbounded(double[])} before providing them to the optimizer.\n+ * For the same reason, the point returned by the {@link\n+ * org.apache.commons.math.optimization.BaseMultivariateRealOptimizer#optimize(int,\n+ * MultivariateRealFunction, org.apache.commons.math.optimization.GoalType, double[])}\n+ * method is unbounded. So to convert this point to bounded, users must call\n+ * {@link #unboundedToBounded(double[])} by themselves!</p>\n+ * <p>\n+ * This adapter is only a poor man solution to simple bounds optimization constraints\n+ * that can be used with simple optimizers like {@link SimplexOptimizer} with {@link\n+ * NelderMeadSimplex} or {@link MultiDirectionalSimplex}. A better solution is to use\n+ * an optimizer that directly supports simple bounds like {@link CMAESOptimizer} or\n+ * {@link BOBYQAOptimizer}. One caveat of this poor man solution is that behavior near\n+ * the bounds may be numerically unstable as bounds are mapped from infinite values.\n+ * Another caveat is that convergence values are evaluated by the optimizer with respect\n+ * to unbounded variables, so there will be scales differences when converted to bounded\n+ * variables.\n+ * </p>\n+ *\n+ * @see MultivariateRealFunctionPenaltyAdapter\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+\n+public class MultivariateRealFunctionMappingAdapter implements MultivariateRealFunction {\n+\n+    /** Underlying bounded function. */\n+    private final MultivariateRealFunction bounded;\n+\n+    /** Mapping functions. */\n+    private final Mapper[] mappers;\n+\n+    /** Simple constructor.\n+     * @param bounded bounded function\n+     * @param lower lower bounds for each element of the input parameters array\n+     * (some elements may be set to {@code Double.NEGATIVE_INFINITY} for\n+     * unbounded values)\n+     * @param upper upper bounds for each element of the input parameters array\n+     * (some elements may be set to {@code Double.POSITIVE_INFINITY} for\n+     * unbounded values)\n+     * @exception MathIllegalArgumentException if lower and upper bounds are not\n+     * consistent, either according to dimension or to values\n+     */\n+    public MultivariateRealFunctionMappingAdapter(final MultivariateRealFunction bounded,\n+                                                  final double[] lower, final double[] upper) {\n+\n+        // safety checks\n+        MathUtils.checkNotNull(lower);\n+        MathUtils.checkNotNull(upper);\n+        if (lower.length != upper.length) {\n+            throw new DimensionMismatchException(lower.length, upper.length);\n+        }\n+        for (int i = 0; i < lower.length; ++i) {\n+            // note the following test is written in such a way it also fails for NaN\n+            if (!(upper[i] >= lower[i])) {\n+                throw new NumberIsTooSmallException(upper[i], lower[i], true);\n+            }\n+        }\n+\n+        this.bounded = bounded;\n+        this.mappers = new Mapper[lower.length];\n+        for (int i = 0; i < mappers.length; ++i) {\n+            if (Double.isInfinite(lower[i])) {\n+                if (Double.isInfinite(upper[i])) {\n+                    // element is unbounded, no transformation is needed\n+                    mappers[i] = new NoBoundsMapper();\n+                } else {\n+                    // element is simple-bounded on the upper side\n+                    mappers[i] = new UpperBoundMapper(upper[i]);\n+                }\n+            } else {\n+                if (Double.isInfinite(upper[i])) {\n+                    // element is simple-bounded on the lower side\n+                    mappers[i] = new LowerBoundMapper(lower[i]);\n+                } else {\n+                    // element is double-bounded\n+                    mappers[i] = new LowerUpperBoundMapper(lower[i], upper[i]);\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    /** Map an array from unbounded to bounded.\n+     * @param x unbounded value\n+     * @return bounded value\n+     */\n+    public double[] unboundedToBounded(double[] point) {\n+\n+        // map unbounded input point to bounded point\n+        final double[] mapped = new double[mappers.length];\n+        for (int i = 0; i < mappers.length; ++i) {\n+            mapped[i] = mappers[i].unboundedToBounded(point[i]);\n+        }\n+\n+        return mapped;\n+\n+    }\n+\n+    /** Map an array from bounded to unbounded.\n+     * @param y bounded value\n+     * @return unbounded value\n+     */\n+    public double[] boundedToUnbounded(double[] point) {\n+\n+        // map bounded input point to unbounded point\n+        final double[] mapped = new double[mappers.length];\n+        for (int i = 0; i < mappers.length; ++i) {\n+            mapped[i] = mappers[i].boundedToUnbounded(point[i]);\n+        }\n+\n+        // call underlying function\n+        return mapped;\n+\n+    }\n+\n+    /** Compute the underlying function value from an unbounded point.\n+     * <p>\n+     * This method simply bounds the unbounded point using the mappings\n+     * set up at construction and calls the underlying function using\n+     * the bounded point.\n+     * </p>\n+     * @see #unboundedToBounded(double[])\n+     */\n+    public double value(double[] point) {\n+        return bounded.value(unboundedToBounded(point));\n+    }\n+\n+    /** Mapping interface. */\n+    private static interface Mapper {\n+\n+        /** Map a value from unbounded to bounded.\n+         * @param y unbounded value\n+         * @return bounded value\n+         */\n+        public double unboundedToBounded(double y);\n+\n+        /** Map a value from bounded to unbounded.\n+         * @param x bounded value\n+         * @return unbounded value\n+         */\n+        public double boundedToUnbounded(double x);\n+\n+    }\n+\n+    /** Local class for no bounds mapping. */\n+    private static class NoBoundsMapper implements Mapper {\n+\n+        /** Simple constructor.\n+         */\n+        public NoBoundsMapper() {\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double unboundedToBounded(final double y) {\n+            return y;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double boundedToUnbounded(final double x) {\n+            return x;\n+        }\n+\n+    }\n+\n+    /** Local class for lower bounds mapping. */\n+    private static class LowerBoundMapper implements Mapper {\n+\n+        /** Low bound. */\n+        private final double lower;\n+\n+        /** Simple constructor.\n+         * @param lower lower bound\n+         */\n+        public LowerBoundMapper(final double lower) {\n+            this.lower = lower;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double unboundedToBounded(final double y) {\n+            return lower + FastMath.exp(y);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double boundedToUnbounded(final double x) {\n+            return FastMath.log(x - lower);\n+        }\n+\n+    }\n+\n+    /** Local class for upper bounds mapping. */\n+    private static class UpperBoundMapper implements Mapper {\n+\n+        /** Upper bound. */\n+        private final double upper;\n+\n+        /** Simple constructor.\n+         * @param upper upper bound\n+         */\n+        public UpperBoundMapper(final double upper) {\n+            this.upper = upper;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double unboundedToBounded(final double y) {\n+            return upper - FastMath.exp(-y);\n+        }\n+        \n+        /** {@inheritDoc} */\n+        public double boundedToUnbounded(final double x) {\n+            return -FastMath.log(upper - x);\n+        }\n+        \n+    }\n+\n+    /** Local class for lower and bounds mapping. */\n+    private static class LowerUpperBoundMapper implements Mapper {\n+\n+        /** Function from unbounded to bounded. */\n+        private final UnivariateRealFunction boundingFunction;\n+\n+        /** Function from bounded to unbounded. */\n+        private final UnivariateRealFunction unboundingFunction;\n+\n+        /** Simple constructor.\n+         * @param lower lower bound\n+         * @param upper upper bound\n+         */\n+        public LowerUpperBoundMapper(final double lower, final double upper) {\n+            boundingFunction   = new Sigmoid(lower, upper);\n+            unboundingFunction = new Logit(lower, upper);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double unboundedToBounded(final double y) {\n+            return boundingFunction.value(y);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double boundedToUnbounded(final double x) {\n+            return unboundingFunction.value(x);\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultivariateRealFunctionPenaltyAdapter.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * <p>Adapter extending bounded {@link MultivariateRealFunction} to an unbouded\n+ * domain using a penalty function.</p>\n+ *\n+ * <p>\n+ * This adapter can be used to wrap functions subject to simple bounds on\n+ * parameters so they can be used by optimizers that do <em>not</em> directly\n+ * support simple bounds.\n+ * </p>\n+ * <p>\n+ * The principle is that the user function that will be wrapped will see its\n+ * parameters bounded as required, i.e when its {@code value} method is called\n+ * with argument array {@code point}, the elements array will fulfill requirement\n+ * {@code lower[i] <= point[i] <= upper[i]} for all i. Some of the components\n+ * may be unbounded or bounded only on one side if the corresponding bound is\n+ * set to an infinite value. The optimizer will not manage the user function by\n+ * itself, but it will handle this adapter and it is this adapter that will take\n+ * care the bounds are fulfilled. The adapter {@link #value(double[])} method will\n+ * be called by the optimizer with unbound parameters, and the adapter will check\n+ * if the parameters is within range or not. If it is in range, then the underlying\n+ * user function will be called, and if it is not the value of a penalty function\n+ * will be returned instead.\n+ * </p>\n+ * <p>\n+ * This adapter is only a poor man solution to simple bounds optimization constraints\n+ * that can be used with simple optimizers like {@link SimplexOptimizer} with {@link\n+ * NelderMeadSimplex} or {@link MultiDirectionalSimplex}. A better solution is to use\n+ * an optimizer that directly supports simple bounds like {@link CMAESOptimizer} or\n+ * {@link BOBYQAOptimizer}. One caveat of this poor man solution is that if start point\n+ * or start simplex is completely outside of the allowed range, only the penalty function\n+ * is used, and the optimizer may converge without ever entering the range.\n+ * </p>\n+ *\n+ * @see MultivariateRealFunctionMappingAdapter\n+ *\n+ * @version $Id$\n+ * @since 3.0\n+ */\n+\n+public class MultivariateRealFunctionPenaltyAdapter implements MultivariateRealFunction {\n+\n+    /** Underlying bounded function. */\n+    private final MultivariateRealFunction bounded;\n+\n+    /** Lower bounds. */\n+    private final double[] lower;\n+\n+    /** Upper bounds. */\n+    private final double[] upper;\n+\n+    /** Penalty offset. */\n+    private final double offset;\n+\n+    /** Penalty scales. */\n+    private final double[] scale;\n+\n+    /** Simple constructor.\n+     * <p>\n+     * When the optimizer provided points are out of range, the value of the\n+     * penalty function will be used instead of the value of the underlying\n+     * function. In order for this penalty to be effective in rejecting this\n+     * point during the optimization process, the penalty function value should\n+     * be defined with care. This value is computed as:\n+     * <pre>\n+     *   penalty(point) = offset + &sum;<sub>i</sub>[scale[i] * &radic;|point[i]-boundary[i]|]\n+     * </pre>\n+     * where indices i correspond to all the components that violates their boundaries.\n+     * </p>\n+     * <p>\n+     * So when attempting a function minimization, offset should be larger than\n+     * the maximum expected value of the underlying function and scale components\n+     * should all be positive. When attempting a function maximization, offset\n+     * should be lesser than the minimum expected value of the underlying function\n+     * and scale components should all be negative.\n+     * minimization, and lesser than the minimum expected value of the underlying\n+     * function when attempting maximization.\n+     * </p>\n+     * <p>\n+     * These choices for the penalty function have two properties. First, all out\n+     * of range points will return a function value that is worse than the value\n+     * returned by any in range point. Second, the penalty is worse for large\n+     * boundaries violation than for small violations, so the optimizer has an hint\n+     * about the direction in which it should search for acceptable points.\n+     * </p>\n+     * @param bounded bounded function\n+     * @param lower lower bounds for each element of the input parameters array\n+     * (some elements may be set to {@code Double.NEGATIVE_INFINITY} for\n+     * unbounded values)\n+     * @param upper upper bounds for each element of the input parameters array\n+     * (some elements may be set to {@code Double.POSITIVE_INFINITY} for\n+     * unbounded values)\n+     * @param offset base offset of the penalty function\n+     * @param scale scale of the penalty function\n+     * @exception MathIllegalArgumentException if lower bounds, upper bounds and\n+     * scales are not consistent, either according to dimension or to bounadary\n+     * values\n+     */\n+    public MultivariateRealFunctionPenaltyAdapter(final MultivariateRealFunction bounded,\n+                                                  final double[] lower, final double[] upper,\n+                                                  final double offset, final double[] scale) {\n+\n+        // safety checks\n+        MathUtils.checkNotNull(lower);\n+        MathUtils.checkNotNull(upper);\n+        MathUtils.checkNotNull(scale);\n+        if (lower.length != upper.length) {\n+            throw new DimensionMismatchException(lower.length, upper.length);\n+        }\n+        if (lower.length != scale.length) {\n+            throw new DimensionMismatchException(lower.length, scale.length);\n+        }\n+        for (int i = 0; i < lower.length; ++i) {\n+            // note the following test is written in such a way it also fails for NaN\n+            if (!(upper[i] >= lower[i])) {\n+                throw new NumberIsTooSmallException(upper[i], lower[i], true);\n+            }\n+        }\n+\n+        this.bounded = bounded;\n+        this.lower   = lower.clone();\n+        this.upper   = upper.clone();\n+        this.offset  = offset;\n+        this.scale   = scale.clone();\n+\n+    }\n+\n+    /** Compute the underlying function value from an unbounded point.\n+     * <p>\n+     * This method simply bounds the unbounded point using the mappings\n+     * set up at construction and calls the underlying function using\n+     * the bounded point.\n+     * </p>\n+     * @see #unboundedToBounded(double[])\n+     */\n+    public double value(double[] point) {\n+\n+        for (int i = 0; i < scale.length; ++i) {\n+            if ((point[i] < lower[i]) || (point[i] > upper[i])) {\n+                // bound violation starting at this component\n+                double sum = 0;\n+                for (int j = i; j < scale.length; ++j) {\n+                    final double overshoot;\n+                    if (point[j] < lower[j]) {\n+                        overshoot = lower[j] - point[j];\n+                    } else if (point[j] > upper[j]) {\n+                        overshoot = point[j] - upper[j];\n+                    } else {\n+                        overshoot = 0;\n+                    }\n+                    sum += FastMath.sqrt(overshoot);\n+                }\n+                return offset + sum;\n+            }\n+        }\n+\n+        // all boundaries are fulfilled, we are in the expected\n+        // domain of the underlying function\n+        return bounded.value(point);\n+\n+    }\n+\n+}\n--- a/src/main/java/org/apache/commons/math/optimization/direct/SimplexOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/SimplexOptimizer.java\n  *  previous and current simplex to the convergence checker, not the best\n  *  ones.\n  * </p>\n+ * <p>\n+ * This simplex optimizer implementation does not directly support constrained\n+ * optimization with simple bounds, so for such optimizations, either a more\n+ * dedicated method must be used like {@link CMAESOptimizer} or {@link\n+ * BOBYQAOptimizer}, or the optimized method must be wrapped in an adapter like\n+ * {@link MultivariateRealFunctionMappingAdapter} or {@link\n+ * MultivariateRealFunctionPenaltyAdapter}.\n+ * </p>\n  *\n  * @see AbstractSimplex\n+ * @see MultivariateRealFunctionMappingAdapter\n+ * @see MultivariateRealFunctionPenaltyAdapter\n+ * @see CMAESOptimizer\n+ * @see BOBYQAOptimizer\n  * @version $Id$\n  * @since 3.0\n  */\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/MultivariateRealFunctionMappingAdapterTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class MultivariateRealFunctionMappingAdapterTest {\n+\n+    @Test\n+    public void testStartSimplexInsideRange() {\n+\n+        final BiQuadratic biQuadratic = new BiQuadratic(2.0, 2.5, 1.0, 3.0, 2.0, 3.0);\n+        final MultivariateRealFunctionMappingAdapter wrapped =\n+                new MultivariateRealFunctionMappingAdapter(biQuadratic,\n+                                                           biQuadratic.getLower(),\n+                                                           biQuadratic.getUpper());\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[][] {\n+            wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }),\n+            wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }),\n+            wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 })\n+        }));\n+\n+        final RealPointValuePair optimum\n+            = optimizer.optimize(300, wrapped, GoalType.MINIMIZE,\n+                                 wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 }));\n+        final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint());\n+\n+        Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 2e-7);\n+        Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 2e-7);\n+\n+    }\n+\n+    @Test\n+    public void testOptimumOutsideRange() {\n+\n+        final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0, 1.0, 3.0, 2.0, 3.0);\n+        final MultivariateRealFunctionMappingAdapter wrapped =\n+                new MultivariateRealFunctionMappingAdapter(biQuadratic,\n+                                                           biQuadratic.getLower(),\n+                                                           biQuadratic.getUpper());\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[][] {\n+            wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }),\n+            wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }),\n+            wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 })\n+        }));\n+\n+        final RealPointValuePair optimum\n+            = optimizer.optimize(100, wrapped, GoalType.MINIMIZE,\n+                                 wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 }));\n+        final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint());\n+\n+        Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 2e-7);\n+        Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 2e-7);\n+\n+    }\n+\n+    @Test\n+    public void testUnbounded() {\n+\n+        final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0,\n+                                                        Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY,\n+                                                        Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n+        final MultivariateRealFunctionMappingAdapter wrapped =\n+                new MultivariateRealFunctionMappingAdapter(biQuadratic,\n+                                                           biQuadratic.getLower(),\n+                                                           biQuadratic.getUpper());\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[][] {\n+            wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }),\n+            wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }),\n+            wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 })\n+        }));\n+\n+        final RealPointValuePair optimum\n+            = optimizer.optimize(300, wrapped, GoalType.MINIMIZE,\n+                                 wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 }));\n+        final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint());\n+\n+        Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 2e-7);\n+        Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 2e-7);\n+\n+    }\n+\n+    @Test\n+    public void testHalfBounded() {\n+\n+        final BiQuadratic biQuadratic = new BiQuadratic(4.0, 4.0,\n+                                                        1.0, Double.POSITIVE_INFINITY,\n+                                                        Double.NEGATIVE_INFINITY, 3.0);\n+        final MultivariateRealFunctionMappingAdapter wrapped =\n+                new MultivariateRealFunctionMappingAdapter(biQuadratic,\n+                                                           biQuadratic.getLower(),\n+                                                           biQuadratic.getUpper());\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(1e-13, 1e-30);\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[][] {\n+            wrapped.boundedToUnbounded(new double[] { 1.5, 2.75 }),\n+            wrapped.boundedToUnbounded(new double[] { 1.5, 2.95 }),\n+            wrapped.boundedToUnbounded(new double[] { 1.7, 2.90 })\n+        }));\n+\n+        final RealPointValuePair optimum\n+            = optimizer.optimize(200, wrapped, GoalType.MINIMIZE,\n+                                 wrapped.boundedToUnbounded(new double[] { 1.5, 2.25 }));\n+        final double[] bounded = wrapped.unboundedToBounded(optimum.getPoint());\n+\n+        Assert.assertEquals(biQuadratic.getBoundedXOptimum(), bounded[0], 1e-7);\n+        Assert.assertEquals(biQuadratic.getBoundedYOptimum(), bounded[1], 1e-7);\n+\n+    }\n+\n+    private static class BiQuadratic implements MultivariateRealFunction {\n+\n+        private final double xOptimum;\n+        private final double yOptimum;\n+\n+        private final double xMin;\n+        private final double xMax;\n+        private final double yMin;\n+        private final double yMax;\n+\n+        public BiQuadratic(final double xOptimum, final double yOptimum,\n+                           final double xMin, final double xMax,\n+                           final double yMin, final double yMax) {\n+            this.xOptimum = xOptimum;\n+            this.yOptimum = yOptimum;\n+            this.xMin     = xMin;\n+            this.xMax     = xMax;\n+            this.yMin     = yMin;\n+            this.yMax     = yMax;\n+        }\n+\n+        public double value(double[] point) {\n+\n+            // the function should never be called with out of range points\n+            Assert.assertTrue(point[0] >= xMin);\n+            Assert.assertTrue(point[0] <= xMax);\n+            Assert.assertTrue(point[1] >= yMin);\n+            Assert.assertTrue(point[1] <= yMax);\n+\n+            final double dx = point[0] - xOptimum;\n+            final double dy = point[1] - yOptimum;\n+            return dx * dx + dy * dy;\n+\n+        }\n+\n+        public double[] getLower() {\n+            return new double[] { xMin, yMin };\n+        }\n+\n+        public double[] getUpper() {\n+            return new double[] { xMax, yMax };\n+        }\n+\n+        public double getBoundedXOptimum() {\n+            return (xOptimum < xMin) ? xMin : ((xOptimum > xMax) ? xMax : xOptimum);\n+        }\n+\n+        public double getBoundedYOptimum() {\n+            return (yOptimum < yMin) ? yMin : ((yOptimum > yMax) ? yMax : yOptimum);\n+        }\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/optimization/direct/MultivariateRealFunctionPenaltyAdapterTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.direct;\n+\n+\n+import org.apache.commons.math.analysis.MultivariateRealFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.RealPointValuePair;\n+import org.apache.commons.math.optimization.SimpleRealPointChecker;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class MultivariateRealFunctionPenaltyAdapterTest {\n+\n+    @Test\n+    public void testStartSimplexInsideRange() {\n+\n+        final BiQuadratic biQuadratic = new BiQuadratic(2.0, 2.5, 1.0, 3.0, 2.0, 3.0);\n+        final MultivariateRealFunctionPenaltyAdapter wrapped =\n+                new MultivariateRealFunctionPenaltyAdapter(biQuadratic,\n+                                                           biQuadratic.getLower(),\n+                                                           biQuadratic.getUpper(),\n+                                                           1000.0, new double[] { 100.0, 100.0 });\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 }));\n+\n+        final RealPointValuePair optimum\n+            = optimizer.optimize(300, wrapped, GoalType.MINIMIZE, new double[] { 1.5, 2.25 });\n+\n+        Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);\n+        Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7);\n+\n+    }\n+\n+    @Test\n+    public void testStartSimplexOutsideRange() {\n+\n+        final BiQuadratic biQuadratic = new BiQuadratic(2.0, 2.5, 1.0, 3.0, 2.0, 3.0);\n+        final MultivariateRealFunctionPenaltyAdapter wrapped =\n+                new MultivariateRealFunctionPenaltyAdapter(biQuadratic,\n+                                                           biQuadratic.getLower(),\n+                                                           biQuadratic.getUpper(),\n+                                                           1000.0, new double[] { 100.0, 100.0 });\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 }));\n+\n+        final RealPointValuePair optimum\n+            = optimizer.optimize(300, wrapped, GoalType.MINIMIZE, new double[] { -1.5, 4.0 });\n+\n+        Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);\n+        Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7);\n+\n+    }\n+\n+    @Test\n+    public void testOptimumOutsideRange() {\n+\n+        final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0, 1.0, 3.0, 2.0, 3.0);\n+        final MultivariateRealFunctionPenaltyAdapter wrapped =\n+                new MultivariateRealFunctionPenaltyAdapter(biQuadratic,\n+                                                           biQuadratic.getLower(),\n+                                                           biQuadratic.getUpper(),\n+                                                           1000.0, new double[] { 100.0, 100.0 });\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleRealPointChecker(1.0e-11, 1.0e-20));\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 }));\n+\n+        final RealPointValuePair optimum\n+            = optimizer.optimize(600, wrapped, GoalType.MINIMIZE, new double[] { -1.5, 4.0 });\n+\n+        Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);\n+        Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7);\n+\n+    }\n+\n+    @Test\n+    public void testUnbounded() {\n+\n+        final BiQuadratic biQuadratic = new BiQuadratic(4.0, 0.0,\n+                                                        Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY,\n+                                                        Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n+        final MultivariateRealFunctionPenaltyAdapter wrapped =\n+                new MultivariateRealFunctionPenaltyAdapter(biQuadratic,\n+                                                           biQuadratic.getLower(),\n+                                                           biQuadratic.getUpper(),\n+                                                           1000.0, new double[] { 100.0, 100.0 });\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(1e-10, 1e-30);\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 }));\n+\n+        final RealPointValuePair optimum\n+            = optimizer.optimize(300, wrapped, GoalType.MINIMIZE, new double[] { -1.5, 4.0 });\n+\n+        Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);\n+        Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7);\n+\n+    }\n+\n+    @Test\n+    public void testHalfBounded() {\n+\n+        final BiQuadratic biQuadratic = new BiQuadratic(4.0, 4.0,\n+                                                        1.0, Double.POSITIVE_INFINITY,\n+                                                        Double.NEGATIVE_INFINITY, 3.0);\n+        final MultivariateRealFunctionPenaltyAdapter wrapped =\n+                new MultivariateRealFunctionPenaltyAdapter(biQuadratic,\n+                                                           biQuadratic.getLower(),\n+                                                           biQuadratic.getUpper(),\n+                                                           1000.0, new double[] { 100.0, 100.0 });\n+\n+        SimplexOptimizer optimizer = new SimplexOptimizer(new SimpleRealPointChecker(1.0e-10, 1.0e-20));\n+        optimizer.setSimplex(new NelderMeadSimplex(new double[] { 1.0, 0.5 }));\n+\n+        final RealPointValuePair optimum\n+            = optimizer.optimize(400, wrapped, GoalType.MINIMIZE, new double[] { -1.5, 4.0 });\n+\n+        Assert.assertEquals(biQuadratic.getBoundedXOptimum(), optimum.getPoint()[0], 2e-7);\n+        Assert.assertEquals(biQuadratic.getBoundedYOptimum(), optimum.getPoint()[1], 2e-7);\n+\n+    }\n+\n+    private static class BiQuadratic implements MultivariateRealFunction {\n+\n+        private final double xOptimum;\n+        private final double yOptimum;\n+\n+        private final double xMin;\n+        private final double xMax;\n+        private final double yMin;\n+        private final double yMax;\n+\n+        public BiQuadratic(final double xOptimum, final double yOptimum,\n+                           final double xMin, final double xMax,\n+                           final double yMin, final double yMax) {\n+            this.xOptimum = xOptimum;\n+            this.yOptimum = yOptimum;\n+            this.xMin     = xMin;\n+            this.xMax     = xMax;\n+            this.yMin     = yMin;\n+            this.yMax     = yMax;\n+        }\n+\n+        public double value(double[] point) {\n+\n+            // the function should never be called with out of range points\n+            Assert.assertTrue(point[0] >= xMin);\n+            Assert.assertTrue(point[0] <= xMax);\n+            Assert.assertTrue(point[1] >= yMin);\n+            Assert.assertTrue(point[1] <= yMax);\n+\n+            final double dx = point[0] - xOptimum;\n+            final double dy = point[1] - yOptimum;\n+            return dx * dx + dy * dy;\n+\n+        }\n+\n+        public double[] getLower() {\n+            return new double[] { xMin, yMin };\n+        }\n+\n+        public double[] getUpper() {\n+            return new double[] { xMax, yMax };\n+        }\n+\n+        public double getBoundedXOptimum() {\n+            return (xOptimum < xMin) ? xMin : ((xOptimum > xMax) ? xMax : xOptimum);\n+        }\n+\n+        public double getBoundedYOptimum() {\n+            return (yOptimum < yMin) ? yMin : ((yOptimum > yMax) ? yMax : yOptimum);\n+        }\n+\n+    }\n+\n+}", "timestamp": 1320955735, "metainfo": ""}