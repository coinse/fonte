{"sha": "dd73c918d31f35c9d86ac7cb3d6c7c1ebebc6809", "log": "Removed deprecated code.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/BetaDistributionImpl.java\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getAlpha() {\n         return alpha;\n     }\n \n     /** {@inheritDoc} */\n+    @Override\n     public double getBeta() {\n         return beta;\n     }\n     }\n \n     /**\n-     * Return the probability density for a particular point.\n-     *\n-     * @param x Point at which the density should be computed.\n-     * @return the pdf at point x.\n-     * @since 2.1\n+     * {@inheritDoc}\n      */\n+    @Override\n     public double density(double x) {\n         recomputeZ();\n         if (x < 0 || x > 1) {\n--- a/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ChiSquaredDistributionImpl.java\n  */\n public class ChiSquaredDistributionImpl\n     extends AbstractContinuousDistribution\n-    implements ChiSquaredDistribution, Serializable  {\n+    implements ChiSquaredDistribution, Serializable {\n     /**\n      * Default inverse cumulative probability accuracy\n      * @since 2.1\n     }\n \n     /**\n-     * Modify the degrees of freedom.\n-     * @param degreesOfFreedom the new degrees of freedom.\n-     */\n-    private void setDegreesOfFreedomInternal(double degreesOfFreedom) {\n-        gamma.setAlpha(degreesOfFreedom / 2.0);\n-    }\n-\n-    /**\n-     * Access the degrees of freedom.\n-     * @return the degrees of freedom.\n+     * {@inheritDoc}\n      */\n     public double getDegreesOfFreedom() {\n         return gamma.getAlpha() * 2.0;\n     @Override\n     protected double getInitialDomain(double p) {\n         // NOTE: chi squared is skewed to the left\n-        // NOTE: therefore, P(X < &mu;) > .5\n+        // NOTE: therefore, P(X < &mu;) > 0.5\n \n         double ret;\n \n-        if (p < .5) {\n+        if (p < 0.5) {\n             // use 1/2 mean\n-            ret = getDegreesOfFreedom() * .5;\n+            ret = getDegreesOfFreedom() * 0.5;\n         } else {\n             // use mean\n             ret = getDegreesOfFreedom();\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n      *\n-     * @return the solver absolute accuracy\n+     * @return the solver absolute accuracy.\n      * @since 2.1\n      */\n     @Override\n--- a/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/ExponentialDistributionImpl.java\n     }\n \n     /**\n-     * Access the mean.\n-     *\n-     * @return the mean.\n-     */\n+     * {@inheritDoc}\n+     */\n+    @Override\n     public double getMean() {\n         return mean;\n     }\n \n     /**\n-     * Return the probability density for a particular point.\n-     *\n-     * @param x Point at which the density should be computed.\n-     * @return the pdf at point {@code x}.\n-     * @since 2.1\n+     * {@inheritDoc}\n      */\n     @Override\n     public double density(double x) {\n--- a/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistribution.java\n  *\n  * @version $Revision$ $Date$\n  */\n-public interface GammaDistribution extends ContinuousDistribution, HasDensity<Double> {\n+public interface GammaDistribution extends ContinuousDistribution {\n     /**\n-     * Modify the shape parameter, alpha.\n-     * @param alpha the new shape parameter.\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setAlpha(double alpha);\n-\n-    /**\n-     * Access the shape parameter, alpha\n+     * Access the alpha shape parameter.\n+     *\n      * @return alpha.\n      */\n     double getAlpha();\n \n     /**\n-     * Modify the scale parameter, beta.\n-     * @param beta the new scale parameter.\n-     * @deprecated as of v2.1\n-     */\n-    @Deprecated\n-    void setBeta(double beta);\n-\n-    /**\n-     * Access the scale parameter, beta\n+     * Access the beta scale parameter.\n+     *\n      * @return beta.\n      */\n     double getBeta();\n \n     /**\n      * Return the probability density for a particular point.\n-     * @param x  The point at which the density should be computed.\n-     * @return  The pdf at point x.\n+     *\n+     * @param x Point at which the density should be computed..\n+     * @return the pdf at point {@code x}.\n      */\n-    double density(Double x);\n+    double density(double x);\n }\n--- a/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/GammaDistributionImpl.java\n import java.io.Serializable;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n import org.apache.commons.math.special.Gamma;\n import org.apache.commons.math.util.FastMath;\n      * Create a new gamma distribution with the given alpha and beta values.\n      * @param alpha the shape parameter.\n      * @param beta the scale parameter.\n-     * @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates\n-     * (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY})\n+     * @param inverseCumAccuracy the maximum absolute error in inverse\n+     * cumulative probability estimates (defaults to\n+     * {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}).\n+     * @throws NotStrictlyPositiveException if {@code alpha <= 0} or\n+     * {@code beta <= 0}.\n      * @since 2.1\n      */\n     public GammaDistributionImpl(double alpha, double beta, double inverseCumAccuracy) {\n-        super();\n-        setAlphaInternal(alpha);\n-        setBetaInternal(beta);\n+        if (alpha <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.ALPHA, alpha);\n+        }\n+        if (beta <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.BETA, beta);\n+        }\n+\n+        this.alpha = alpha;\n+        this.beta = beta;\n         solverAbsoluteAccuracy = inverseCumAccuracy;\n     }\n \n     public double cumulativeProbability(double x) throws MathException{\n         double ret;\n \n-        if (x <= 0.0) {\n-            ret = 0.0;\n+        if (x <= 0) {\n+            ret = 0;\n         } else {\n             ret = Gamma.regularizedGammaP(alpha, x / beta);\n         }\n \n     /**\n      * For this distribution, X, this method returns the critical point x, such\n-     * that P(X &lt; x) = <code>p</code>.\n-     * <p>\n-     * Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>\n-     *\n-     * @param p the desired probability\n-     * @return x, such that P(X &lt; x) = <code>p</code>\n+     * that {@code P(X < x) = p}.\n+     * Returns 0 when p = 0 and {@code Double.POSITIVE_INFINITY} when p = 1.\n+     *\n+     * @param p Desired probability.\n+     * @return {@code x}, such that {@code P(X < x) = p}.\n      * @throws MathException if the inverse cumulative probability can not be\n-     *         computed due to convergence or other numerical errors.\n-     * @throws IllegalArgumentException if <code>p</code> is not a valid\n-     *         probability.\n+     * computed due to convergence or other numerical errors.\n+     * @throws IllegalArgumentException if {@code p} is not a valid\n+     * probability.\n      */\n     @Override\n     public double inverseCumulativeProbability(final double p)\n-    throws MathException {\n+        throws MathException {\n         if (p == 0) {\n-            return 0d;\n+            return 0;\n         }\n         if (p == 1) {\n             return Double.POSITIVE_INFINITY;\n     }\n \n     /**\n-     * Modify the shape parameter, alpha.\n-     * @param alpha the new shape parameter.\n-     * @throws IllegalArgumentException if <code>alpha</code> is not positive.\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setAlpha(double alpha) {\n-        setAlphaInternal(alpha);\n-    }\n-\n-    /**\n-     * Modify the shape parameter, alpha.\n-     * @param newAlpha the new shape parameter.\n-     * @throws IllegalArgumentException if <code>newAlpha</code> is not positive.\n-     */\n-    private void setAlphaInternal(double newAlpha) {\n-        if (newAlpha <= 0.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_POSITIVE_ALPHA,\n-                  newAlpha);\n-        }\n-        this.alpha = newAlpha;\n-    }\n-\n-    /**\n-     * Access the shape parameter, alpha\n-     * @return alpha.\n-     */\n+     * {@inheritDoc}\n+     */\n+    @Override\n     public double getAlpha() {\n         return alpha;\n     }\n \n     /**\n-     * Modify the scale parameter, beta.\n-     * @param newBeta the new scale parameter.\n-     * @throws IllegalArgumentException if <code>newBeta</code> is not positive.\n-     * @deprecated as of 2.1 (class will become immutable in 3.0)\n-     */\n-    @Deprecated\n-    public void setBeta(double newBeta) {\n-        setBetaInternal(newBeta);\n-    }\n-\n-    /**\n-     * Modify the scale parameter, beta.\n-     * @param newBeta the new scale parameter.\n-     * @throws IllegalArgumentException if <code>newBeta</code> is not positive.\n-     */\n-    private void setBetaInternal(double newBeta) {\n-        if (newBeta <= 0.0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  LocalizedFormats.NOT_POSITIVE_BETA,\n-                  newBeta);\n-        }\n-        this.beta = newBeta;\n-    }\n-\n-    /**\n-     * Access the scale parameter, beta\n-     * @return beta.\n-     */\n+     * {@inheritDoc}\n+     */\n+    @Override\n     public double getBeta() {\n         return beta;\n     }\n \n     /**\n-     * Returns the probability density for a particular point.\n-     *\n-     * @param x The point at which the density should be computed.\n-     * @return The pdf at point x.\n+     * {@inheritDoc}\n      */\n     @Override\n     public double density(double x) {\n         if (x < 0) return 0;\n-        return FastMath.pow(x / beta, alpha - 1) / beta * FastMath.exp(-x / beta) / FastMath.exp(Gamma.logGamma(alpha));\n-    }\n-\n-    /**\n-     * Return the probability density for a particular point.\n-     *\n-     * @param x The point at which the density should be computed.\n-     * @return The pdf at point x.\n-     * @deprecated\n-     */\n-    public double density(Double x) {\n-        return density(x.doubleValue());\n+        return FastMath.pow(x / beta, alpha - 1) / beta *\n+            FastMath.exp(-x / beta) / FastMath.exp(Gamma.logGamma(alpha));\n     }\n \n     /**\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return domain value lower bound, i.e.\n-     *         P(X &lt; <i>lower bound</i>) &lt; <code>p</code>\n+     * @param p Desired probability for the critical value.\n+     * @return the domain value lower bound, i.e. {@code P(X < 'lower bound') < p}.\n      */\n     @Override\n     protected double getDomainLowerBound(double p) {\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n      * @param p the desired probability for the critical value\n-     * @return domain value upper bound, i.e.\n-     *         P(X &lt; <i>upper bound</i>) &gt; <code>p</code>\n+     * @return domain value upper bound, i.e. {@code P(X < 'upper bound') > p}.\n      */\n     @Override\n     protected double getDomainUpperBound(double p) {\n \n         double ret;\n \n-        if (p < .5) {\n+        if (p < 0.5) {\n             // use mean\n             ret = alpha * beta;\n         } else {\n     }\n \n     /**\n-     * Access the initial domain value, based on <code>p</code>, used to\n+     * Access the initial domain value, based on {@code p}, used to\n      * bracket a CDF root.  This method is used by\n      * {@link #inverseCumulativeProbability(double)} to find critical values.\n      *\n-     * @param p the desired probability for the critical value\n-     * @return initial domain value\n+     * @param p Desired probability for the critical value.\n+     * @return the initial domain value.\n      */\n     @Override\n     protected double getInitialDomain(double p) {\n \n         double ret;\n \n-        if (p < .5) {\n+        if (p < 0.5) {\n             // use 1/2 mean\n-            ret = alpha * beta * .5;\n+            ret = alpha * beta * 0.5;\n         } else {\n             // use mean\n             ret = alpha * beta;\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities.\n      *\n-     * @return the solver absolute accuracy\n+     * @return the solver absolute accuracy.\n      * @since 2.1\n      */\n     @Override\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     NOT_INCREASING_NUMBER_OF_POINTS(\"points {0} and {1} are not increasing ({2} > {3})\"),\n     NOT_INCREASING_SEQUENCE(\"points {3} and {2} are not increasing ({1} > {0})\"), /* keep */\n     NOT_MULTIPLICATION_COMPATIBLE_MATRICES(\"{0}x{1} and {2}x{3} matrices are not multiplication compatible\"),\n-    NOT_POSITIVE_ALPHA(\"alpha must be positive ({0})\"),\n-    NOT_POSITIVE_BETA(\"beta must be positive ({0})\"),\n+    ALPHA(\"alpha\"), /* keep */\n+    BETA(\"beta\"), /* keep */\n     NOT_POSITIVE_COLUMNDIMENSION(\"invalid column dimension: {0} (must be positive)\"),\n     NOT_POSITIVE_DEFINITE_MATRIX(\"not positive definite matrix\"),\n     NOT_POSITIVE_DEGREES_OF_FREEDOM(\"degrees of freedom must be positive ({0})\"),\n--- a/src/test/java/org/apache/commons/math/distribution/GammaDistributionTest.java\n+++ b/src/test/java/org/apache/commons/math/distribution/GammaDistributionTest.java\n  */\n \n package org.apache.commons.math.distribution;\n+\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n \n /**\n  * Test cases for GammaDistribution.\n     public void testParameterAccessors() {\n         GammaDistribution distribution = (GammaDistribution) getDistribution();\n         assertEquals(4d, distribution.getAlpha(), 0);\n-        distribution.setAlpha(3d);\n-        assertEquals(3d, distribution.getAlpha(), 0);\n         assertEquals(2d, distribution.getBeta(), 0);\n-        distribution.setBeta(4d);\n-        assertEquals(4d, distribution.getBeta(), 0);\n+    }\n+\n+    public void testPreconditions() {\n         try {\n-            distribution.setAlpha(0d);\n-            fail(\"Expecting IllegalArgumentException for alpha = 0\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n+            GammaDistribution distribution = new GammaDistributionImpl(0, 1);\n+            fail(\"Expecting NotStrictlyPositiveException for alpha = 0\");\n+        } catch (NotStrictlyPositiveException ex) {\n+            // Expected.\n         }\n         try {\n-            distribution.setBeta(0d);\n-            fail(\"Expecting IllegalArgumentException for beta = 0\");\n-        } catch (IllegalArgumentException ex) {\n-            // expected\n+            GammaDistribution distribution = new GammaDistributionImpl(1, 0);\n+            fail(\"Expecting NotStrictlyPositiveException for alpha = 0\");\n+        } catch (NotStrictlyPositiveException ex) {\n+            // Expected.\n         }\n     }\n ", "timestamp": 1285595039, "metainfo": ""}