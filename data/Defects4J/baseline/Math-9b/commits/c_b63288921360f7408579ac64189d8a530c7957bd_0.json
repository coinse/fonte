{"sha": "b63288921360f7408579ac64189d8a530c7957bd", "log": "use root bracketing to find events on the appropriate side according to integration direction  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n \n import org.apache.commons.math.ConvergenceException;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.analysis.solvers.AllowedSolutions;\n+import org.apache.commons.math.analysis.solvers.BracketedUnivariateRealSolver;\n+import org.apache.commons.math.analysis.solvers.PegasusSolver;\n import org.apache.commons.math.analysis.solvers.UnivariateRealSolver;\n-import org.apache.commons.math.exception.MathInternalError;\n+import org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils;\n import org.apache.commons.math.exception.MathUserException;\n import org.apache.commons.math.ode.sampling.StepInterpolator;\n import org.apache.commons.math.util.FastMath;\n     public void reinitializeBegin(final StepInterpolator interpolator)\n         throws EventException {\n         try {\n-            // excerpt from MATH-421 issue:\n-            // If an ODE solver is setup with an EventHandler that return STOP\n-            // when the even is triggered, the integrator stops (which is exactly\n-            // the expected behavior). If however the user want to restart the\n-            // solver from the final state reached at the event with the same\n-            // configuration (expecting the event to be triggered again at a\n-            // later time), then the integrator may fail to start. It can get stuck\n-            // at the previous event.\n-\n-            // The use case for the bug MATH-421 is fairly general, so events occurring\n-            // less than epsilon after the solver start in the first step should be ignored,\n-            // where epsilon is the convergence threshold of the event. The sign of the g\n-            // function should be evaluated after this initial ignore zone, not exactly at\n-            // beginning (if there are no event at the very beginning g(t0) and g(t0+epsilon)\n-            // have the same sign, so this does not hurt ; if there is an event at the very\n-            // beginning, g(t0) and g(t0+epsilon) have opposite signs and we want to start\n-            // with the second one. Of course, the sign of epsilon depend on the integration\n-            // direction (forward or backward). This explains what is done below.\n-\n-            final double ignoreZone = interpolator.isForward() ? getConvergence() : -getConvergence();\n-            t0 = interpolator.getPreviousTime() + ignoreZone;\n+\n+            t0 = interpolator.getPreviousTime();\n             interpolator.setInterpolatedTime(t0);\n             g0 = handler.g(t0, interpolator.getInterpolatedState());\n             if (g0 == 0) {\n-                // extremely rare case: there is a zero EXACTLY at end of ignore zone\n-                // we will use the opposite of sign at step beginning to force ignoring this zero\n-                final double tStart = interpolator.getPreviousTime();\n+                // excerpt from MATH-421 issue:\n+                // If an ODE solver is setup with an EventHandler that return STOP\n+                // when the even is triggered, the integrator stops (which is exactly\n+                // the expected behavior). If however the user wants to restart the\n+                // solver from the final state reached at the event with the same\n+                // configuration (expecting the event to be triggered again at a\n+                // later time), then the integrator may fail to start. It can get stuck\n+                // at the previous event. The use case for the bug MATH-421 is fairly\n+                // general, so events occurring exactly at start in the first step should\n+                // be ignored.\n+\n+                // extremely rare case: there is a zero EXACTLY at interval start\n+                // we will use the sign slightly after step beginning to force ignoring this zero\n+                final double epsilon = FastMath.max(solver.getAbsoluteAccuracy(),\n+                                                    FastMath.abs(solver.getRelativeAccuracy() * t0));\n+                final double tStart = t0 + 0.5 * epsilon;\n                 interpolator.setInterpolatedTime(tStart);\n-                g0Positive = handler.g(tStart, interpolator.getInterpolatedState()) <= 0;\n-            } else {\n-                g0Positive = g0 >= 0;\n+                g0 = handler.g(tStart, interpolator.getInterpolatedState());\n             }\n+            g0Positive = g0 >= 0;\n \n         } catch (MathUserException mue) {\n             throw new EventException(mue);\n \n             forward = interpolator.isForward();\n             final double t1 = interpolator.getCurrentTime();\n-            if (FastMath.abs(t1 - t0) < convergence) {\n+            final double dt = t1 - t0;\n+            if (FastMath.abs(dt) < convergence) {\n                 // we cannot do anything on such a small step, don't trigger any events\n                 return false;\n             }\n-            final double start = forward ? (t0 + convergence) : t0 - convergence;\n-            final double dt    = t1 - start;\n-            final int    n     = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\n-            final double h     = dt / n;\n+            final int    n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\n+            final double h = dt / n;\n+\n+            final UnivariateRealFunction f = new UnivariateRealFunction() {\n+                public double value(final double t) {\n+                    try {\n+                        interpolator.setInterpolatedTime(t);\n+                        return handler.g(t, interpolator.getInterpolatedState());\n+                    } catch (EventException e) {\n+                        throw new ConveyedException(e);\n+                    }\n+                }\n+            };\n \n             double ta = t0;\n             double ga = g0;\n             for (int i = 0; i < n; ++i) {\n \n                 // evaluate handler value at the end of the substep\n-                final double tb = start + (i + 1) * h;\n+                final double tb = t0 + (i + 1) * h;\n                 interpolator.setInterpolatedTime(tb);\n                 final double gb = handler.g(tb, interpolator.getInterpolatedState());\n \n                     // variation direction, with respect to the integration direction\n                     increasing = gb >= ga;\n \n-                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n-                        public double value(final double t) throws MathUserException {\n-                            try {\n-                                interpolator.setInterpolatedTime(t);\n-                                return handler.g(t, interpolator.getInterpolatedState());\n-                            } catch (EventException e) {\n-                                throw new MathUserException(e);\n-                            }\n-                        }\n-                    };\n-\n-                    if (ga * gb >= 0) {\n-                        // this is a corner case:\n-                        // - there was an event near ta,\n-                        // - there is another event between ta and tb\n-                        // - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n-                        // this implies that the real sign of ga is the same as gb, so we need to slightly\n-                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain\n-                        // about bracketing\n-                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;\n-                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n-                            ta += epsilon;\n-                            ga = f.value(ta);\n-                        }\n-                        if (ga * gb > 0) {\n-                            // this should never happen\n-                            throw new MathInternalError();\n-                        }\n+                    // find the event time making sure we select a solution just at or past the exact root\n+                    final double root;\n+                    if (solver instanceof BracketedUnivariateRealSolver<?>) {\n+                        @SuppressWarnings(\"unchecked\")\n+                        BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\n+                                (BracketedUnivariateRealSolver<UnivariateRealFunction>) solver;\n+                        root = forward ?\n+                               bracketing.solve(maxIterationCount, f, ta, tb, AllowedSolutions.RIGHT_SIDE) :\n+                               bracketing.solve(maxIterationCount, f, tb, ta, AllowedSolutions.LEFT_SIDE);\n+                    } else {\n+                        final double baseRoot = forward ?\n+                                                solver.solve(maxIterationCount, f, ta, tb) :\n+                                                solver.solve(maxIterationCount, f, tb, ta);\n+                        final int remainingEval = maxIterationCount - solver.getEvaluations();\n+                        BracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\n+                                new PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy());\n+                        root = forward ?\n+                               UnivariateRealSolverUtils.forceSide(remainingEval, f, bracketing,\n+                                                                   baseRoot, ta, tb, AllowedSolutions.RIGHT_SIDE) :\n+                               UnivariateRealSolverUtils.forceSide(remainingEval, f, bracketing,\n+                                                                   baseRoot, tb, ta, AllowedSolutions.LEFT_SIDE);\n                     }\n-\n-                    final double root = (ta <= tb) ?\n-                                        solver.solve(maxIterationCount, f, ta, tb) :\n-                                        solver.solve(maxIterationCount, f, tb, ta);\n \n                     if ((!Double.isNaN(previousEventTime)) &&\n                         (FastMath.abs(root - ta) <= convergence) &&\n                         (FastMath.abs(root - previousEventTime) <= convergence)) {\n-                        // we have either found nothing or found (again ?) a past event, we simply ignore it\n-                        ta = tb;\n-                        ga = gb;\n+                        // we have either found nothing or found (again ?) a past event,\n+                        // retry the substep excluding this value\n+                        ta = forward ? ta + convergence : ta - convergence;\n+                        ga = f.value(ta);\n+                        --i;\n                     } else if (Double.isNaN(previousEventTime) ||\n                                (FastMath.abs(previousEventTime - root) > convergence)) {\n                         pendingEventTime = root;\n             pendingEventTime = Double.NaN;\n             return false;\n \n-        } catch (MathUserException mue) {\n-            final Throwable cause = mue.getCause();\n-            if ((cause != null) && (cause instanceof EventException)) {\n-                throw (EventException) cause;\n-            }\n-            throw mue;\n+        } catch (ConveyedException ce) {\n+            throw ce.getConveyedException();\n         }\n \n     }\n \n     /** Get the occurrence time of the event triggered in the current step.\n      * @return occurrence time of the event triggered in the current\n-     * step or positive infinity if no events are triggered\n+     * step or infinity if no events are triggered\n      */\n     public double getEventTime() {\n-        return pendingEvent ? pendingEventTime : Double.POSITIVE_INFINITY;\n+        return pendingEvent ?\n+               pendingEventTime :\n+               (forward ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY);\n     }\n \n     /** Acknowledge the fact the step has been accepted by the integrator.\n \n     }\n \n+    /** Local exception to convey EventException instances through root finding algorithms. */\n+    private static class ConveyedException extends RuntimeException {\n+\n+        /** Serializable uid. */\n+        private static final long serialVersionUID = 2668348550531980574L;\n+\n+        /** Conveyed exception. */\n+        private final EventException conveyedException;\n+\n+        /** Simple constructor.\n+         * @param conveyedException conveyed exception\n+         */\n+        public ConveyedException(final EventException conveyedException) {\n+            this.conveyedException = conveyedException;\n+        }\n+\n+        /** Get the conveyed exception.\n+         * @return conveyed exception\n+         */\n+        public EventException getConveyedException() {\n+            return conveyedException;\n+        }\n+\n+    }\n+\n }", "timestamp": 1310313939, "metainfo": ""}