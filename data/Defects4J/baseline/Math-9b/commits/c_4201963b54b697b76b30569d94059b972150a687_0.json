{"sha": "4201963b54b697b76b30569d94059b972150a687", "log": "added tests based on dfp library (now a package in commons-math)  ", "commit": "\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/util/FastMathTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.util;\n+\n+import org.apache.commons.math.dfp.Dfp;\n+import org.apache.commons.math.dfp.DfpField;\n+import org.apache.commons.math.dfp.DfpMath;\n+import org.apache.commons.math.random.MersenneTwister;\n+import org.apache.commons.math.random.RandomGenerator;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+public class FastMathTest {\n+\n+    private final double MAX_ERROR_ULP = 0.51;\n+    private final int NUMBER_OF_TRIALS = 1000;\n+    private DfpField field;\n+    private RandomGenerator generator;\n+\n+    @Before\n+    public void setUp() {\n+        field = new DfpField(40);\n+        generator = new MersenneTwister(6176597458463500194l);\n+    }\n+\n+    @Test\n+    public void testMinMaxDouble() {\n+        double[][] pairs = {\n+            { -50.0, 50.0 },\n+            {  Double.POSITIVE_INFINITY, 1.0 },\n+            {  Double.NEGATIVE_INFINITY, 1.0 },\n+            {  Double.NaN, 1.0 },\n+            {  Double.POSITIVE_INFINITY, 0.0 },\n+            {  Double.NEGATIVE_INFINITY, 0.0 },\n+            {  Double.NaN, 0.0 },\n+            {  Double.NaN, Double.NEGATIVE_INFINITY },\n+            {  Double.NaN, Double.POSITIVE_INFINITY },\n+            { MathUtils.SAFE_MIN, MathUtils.EPSILON }\n+        };\n+        for (double[] pair : pairs) {\n+            Assert.assertEquals(\"min(\" + pair[0] + \", \" + pair[1] + \")\",\n+                                Math.min(pair[0], pair[1]),\n+                                FastMath.min(pair[0], pair[1]),\n+                                MathUtils.EPSILON);\n+            Assert.assertEquals(\"min(\" + pair[1] + \", \" + pair[0] + \")\",\n+                                Math.min(pair[1], pair[0]),\n+                                FastMath.min(pair[1], pair[0]),\n+                                MathUtils.EPSILON);\n+            Assert.assertEquals(\"max(\" + pair[0] + \", \" + pair[1] + \")\",\n+                                Math.max(pair[0], pair[1]),\n+                                FastMath.max(pair[0], pair[1]),\n+                                MathUtils.EPSILON);\n+            Assert.assertEquals(\"max(\" + pair[1] + \", \" + pair[0] + \")\",\n+                                Math.max(pair[1], pair[0]),\n+                                FastMath.max(pair[1], pair[0]),\n+                                MathUtils.EPSILON);\n+        }\n+    }\n+\n+    @Test\n+    public void testMinMaxFloat() {\n+        double[][] pairs = {\n+            { -50.0, 50.0 },\n+            {  Float.POSITIVE_INFINITY, 1.0 },\n+            {  Float.NEGATIVE_INFINITY, 1.0 },\n+            {  Float.NaN, 1.0 },\n+            {  Float.POSITIVE_INFINITY, 0.0 },\n+            {  Float.NEGATIVE_INFINITY, 0.0 },\n+            {  Float.NaN, 0.0 },\n+            {  Float.NaN, Float.NEGATIVE_INFINITY },\n+            {  Float.NaN, Float.POSITIVE_INFINITY }\n+        };\n+        for (double[] pair : pairs) {\n+            Assert.assertEquals(\"min(\" + pair[0] + \", \" + pair[1] + \")\",\n+                                Math.min(pair[0], pair[1]),\n+                                FastMath.min(pair[0], pair[1]),\n+                                MathUtils.EPSILON);\n+            Assert.assertEquals(\"min(\" + pair[1] + \", \" + pair[0] + \")\",\n+                                Math.min(pair[1], pair[0]),\n+                                FastMath.min(pair[1], pair[0]),\n+                                MathUtils.EPSILON);\n+            Assert.assertEquals(\"max(\" + pair[0] + \", \" + pair[1] + \")\",\n+                                Math.max(pair[0], pair[1]),\n+                                FastMath.max(pair[0], pair[1]),\n+                                MathUtils.EPSILON);\n+            Assert.assertEquals(\"max(\" + pair[1] + \", \" + pair[0] + \")\",\n+                                Math.max(pair[1], pair[0]),\n+                                FastMath.max(pair[1], pair[0]),\n+                                MathUtils.EPSILON);\n+        }\n+    }\n+\n+    @Test\n+    public void testConstants() {\n+        Assert.assertEquals(Math.PI, FastMath.PI, 1.0e-20);\n+        Assert.assertEquals(Math.E, FastMath.E, 1.0e-20);\n+    }\n+\n+    @Test\n+    public void testAtan2() {\n+        double y1 = 1.2713504628280707e10;\n+        double x1 = -5.674940885228782e-10;\n+        Assert.assertEquals(Math.atan2(y1, x1), FastMath.atan2(y1, x1), 2 * MathUtils.EPSILON);\n+        double y2 = 0.0;\n+        double x2 = Double.POSITIVE_INFINITY;\n+        Assert.assertEquals(Math.atan2(y2, x2), FastMath.atan2(y2, x2), MathUtils.SAFE_MIN);\n+    }\n+\n+    @Test\n+    public void testHyperbolic() {\n+        double maxErr = 0;\n+        for (double x = -30; x < 30; x += 0.001) {\n+            double tst = FastMath.sinh(x);\n+            double ref = Math.sinh(x);\n+            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));\n+        }\n+        Assert.assertEquals(0, maxErr, 2);\n+\n+        maxErr = 0;\n+        for (double x = -30; x < 30; x += 0.001) {\n+            double tst = FastMath.cosh(x);\n+            double ref = Math.cosh(x);\n+            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));\n+        }\n+        Assert.assertEquals(0, maxErr, 2);\n+\n+        maxErr = 0;\n+        for (double x = -0.5; x < 0.5; x += 0.001) {\n+            double tst = FastMath.tanh(x);\n+            double ref = Math.tanh(x);\n+            maxErr = FastMath.max(maxErr, FastMath.abs(ref - tst) / FastMath.ulp(ref));\n+        }\n+        Assert.assertEquals(0, maxErr, 4);\n+\n+    }\n+\n+    @Test\n+    public void testHyperbolicInverses() {\n+        double maxErr = 0;\n+        for (double x = -30; x < 30; x += 0.01) {\n+            maxErr = FastMath.max(maxErr, FastMath.abs(x - FastMath.sinh(FastMath.asinh(x))) / (2 * FastMath.ulp(x)));\n+        }\n+        Assert.assertEquals(0, maxErr, 3);\n+\n+        maxErr = 0;\n+        for (double x = 1; x < 30; x += 0.01) {\n+            maxErr = FastMath.max(maxErr, FastMath.abs(x - FastMath.cosh(FastMath.acosh(x))) / (2 * FastMath.ulp(x)));\n+        }\n+        Assert.assertEquals(0, maxErr, 2);\n+\n+        maxErr = 0;\n+        for (double x = -1 + MathUtils.EPSILON; x < 1 - MathUtils.EPSILON; x += 0.0001) {\n+            maxErr = FastMath.max(maxErr, FastMath.abs(x - FastMath.tanh(FastMath.atanh(x))) / (2 * FastMath.ulp(x)));\n+        }\n+        Assert.assertEquals(0, maxErr, 2);\n+\n+    }\n+\n+    @Test\n+    public void testLogAccuracy() {\n+        double maxerrulp = 0.0;\n+\n+        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {\n+            double x = Math.exp(generator.nextDouble() * 1416.0 - 708.0) * generator.nextDouble();\n+            // double x = generator.nextDouble()*2.0;\n+            double tst = FastMath.log(x);\n+            double ref = DfpMath.log(field.newDfp(x)).toDouble();\n+            double err = (tst - ref) / ref;\n+\n+            if (err != 0.0) {\n+                double ulp = Math.abs(ref -\n+                                      Double.longBitsToDouble((Double\n+                                          .doubleToLongBits(ref) ^ 1)));\n+                double errulp = field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();\n+//                System.out.println(x + \"\\t\" + tst + \"\\t\" + ref + \"\\t\" + err + \"\\t\" + errulp);\n+\n+                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n+            }\n+        }\n+\n+        Assert.assertTrue(\"log() had errors in excess of \" + MAX_ERROR_ULP + \" ULP\", maxerrulp < MAX_ERROR_ULP);\n+    }\n+\n+    @Test\n+    public void testLog10Accuracy() {\n+        double maxerrulp = 0.0;\n+\n+        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {\n+            double x = Math.exp(generator.nextDouble() * 1416.0 - 708.0) * generator.nextDouble();\n+            // double x = generator.nextDouble()*2.0;\n+            double tst = FastMath.log10(x);\n+            double ref = DfpMath.log(field.newDfp(x)).divide(DfpMath.log(field.newDfp(\"10\"))).toDouble();\n+            double err = (tst - ref) / ref;\n+\n+            if (err != 0.0) {\n+                double ulp = Math.abs(ref -\n+                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));\n+                double errulp = field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x)).divide(DfpMath.log(field.newDfp(\"10\")))).divide(field.newDfp(ulp)).toDouble();\n+//                System.out.println(x + \"\\t\" + tst + \"\\t\" + ref + \"\\t\" + err + \"\\t\" + errulp);\n+\n+                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n+            }\n+        }\n+\n+        Assert.assertTrue(\"log10() had errors in excess of \" + MAX_ERROR_ULP + \" ULP\", maxerrulp < MAX_ERROR_ULP);\n+    }\n+\n+    @Test\n+    public void testLog1pAccuracy() {\n+        double maxerrulp = 0.0;\n+\n+        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {\n+            double x = Math.exp(generator.nextDouble() * 10.0 - 5.0) * generator.nextDouble();\n+            // double x = generator.nextDouble()*2.0;\n+            double tst = FastMath.log1p(x);\n+            double ref = DfpMath.log(field.newDfp(x).add(field.getOne())).toDouble();\n+            double err = (tst - ref) / ref;\n+\n+            if (err != 0.0) {\n+                double ulp = Math.abs(ref -\n+                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));\n+                double errulp = field.newDfp(tst).subtract(DfpMath.log(field.newDfp(x).add(field.getOne()))).divide(field.newDfp(ulp)).toDouble();\n+//                System.out.println(x + \"\\t\" + tst + \"\\t\" + ref + \"\\t\" + err + \"\\t\" + errulp);\n+\n+                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n+            }\n+        }\n+\n+        Assert.assertTrue(\"log1p() had errors in excess of \" + MAX_ERROR_ULP + \" ULP\", maxerrulp < MAX_ERROR_ULP);\n+    }\n+\n+    @Test\n+    public void testLogSpecialCases() {\n+        double x;\n+\n+        x = FastMath.log(0.0);\n+        if (x != Double.NEGATIVE_INFINITY)\n+            throw new RuntimeException(\"Log of zero should be -Inf\");\n+\n+        x = FastMath.log(-0.0);\n+        if (x != Double.NEGATIVE_INFINITY)\n+            throw new RuntimeException(\"Log of zero should be -Inf\");\n+\n+        x = FastMath.log(Double.NaN);\n+        if (x == x)\n+            throw new RuntimeException(\"Log of NaN should be NaN\");\n+\n+        x = FastMath.log(-1.0);\n+        if (x == x)\n+            throw new RuntimeException(\"Log of negative number should be NaN\");\n+\n+        x = FastMath.log(Double.MIN_VALUE);\n+        if (x != -744.4400719213812)\n+            throw new RuntimeException(\n+                                       \"Log of Double.MIN_VALUE should be -744.4400719213812\");\n+\n+        x = FastMath.log(-1.0);\n+        if (x == x)\n+            throw new RuntimeException(\"Log of negative number should be NaN\");\n+\n+        x = FastMath.log(Double.POSITIVE_INFINITY);\n+        if (x != Double.POSITIVE_INFINITY)\n+            throw new RuntimeException(\"Log of infinity should be infinity\");\n+    }\n+\n+    @Test\n+    public void testExpSpecialCases() {\n+        double x;\n+\n+        /* Smallest value that will round up to Double.MIN_VALUE */\n+        x = FastMath.exp(-745.1332191019411);\n+        if (x != Double.MIN_VALUE)\n+            throw new RuntimeException(\n+                                       \"exp(-745.1332191019411) should be Double.MIN_VALUE\");\n+\n+        x = FastMath.exp(-745.1332191019412);\n+        if (x != 0.0)\n+            throw new RuntimeException(\"exp(-745.1332191019412) should be 0.0\");\n+\n+        x = FastMath.exp(Double.NaN);\n+        if (x == x)\n+            throw new RuntimeException(\"exp of NaN should be NaN\");\n+\n+        x = FastMath.exp(Double.POSITIVE_INFINITY);\n+        if (x != Double.POSITIVE_INFINITY)\n+            throw new RuntimeException(\"exp of infinity should be infinity\");\n+\n+        x = FastMath.exp(Double.NEGATIVE_INFINITY);\n+        if (x != 0.0)\n+            throw new RuntimeException(\"exp of -infinity should be 0.0\");\n+\n+        x = FastMath.exp(1.0);\n+        if (x != Math.E)\n+            throw new RuntimeException(\"exp(1) should be Math.E\");\n+    }\n+\n+    @Test\n+    public void testPowSpecialCases() {\n+        double x;\n+\n+        x = FastMath.pow(-1.0, 0.0);\n+        if (x != 1.0)\n+            throw new RuntimeException(\"pow(x, 0) should be 1.0\");\n+\n+        x = FastMath.pow(-1.0, -0.0);\n+        if (x != 1.0)\n+            throw new RuntimeException(\"pow(x, -0) should be 1.0\");\n+\n+        x = FastMath.pow(Math.PI, 1.0);\n+        if (x != Math.PI)\n+            throw new RuntimeException(\"pow(PI, 1.0) should be PI\");\n+\n+        x = FastMath.pow(-Math.PI, 1.0);\n+        if (x != -Math.PI)\n+            throw new RuntimeException(\"pow(-PI, 1.0) should be PI\");\n+\n+        x = FastMath.pow(Math.PI, Double.NaN);\n+        if (x == x)\n+            throw new RuntimeException(\"pow(PI, NaN) should be NaN\");\n+\n+        x = FastMath.pow(Double.NaN, Math.PI);\n+        if (x == x)\n+            throw new RuntimeException(\"pow(NaN, PI) should be NaN\");\n+\n+        x = FastMath.pow(2.0, Double.POSITIVE_INFINITY);\n+        if (x != Double.POSITIVE_INFINITY)\n+            throw new RuntimeException(\"pow(2.0, Infinity) should be Infinity\");\n+\n+        x = FastMath.pow(0.5, Double.NEGATIVE_INFINITY);\n+        if (x != Double.POSITIVE_INFINITY)\n+            throw new RuntimeException(\"pow(0.5, -Infinity) should be Infinity\");\n+\n+        x = FastMath.pow(0.5, Double.POSITIVE_INFINITY);\n+        if (x != 0.0)\n+            throw new RuntimeException(\"pow(0.5, Infinity) should be 0.0\");\n+\n+        x = FastMath.pow(2.0, Double.NEGATIVE_INFINITY);\n+        if (x != 0.0)\n+            throw new RuntimeException(\"pow(2.0, -Infinity) should be 0.0\");\n+\n+        x = FastMath.pow(0.0, 0.5);\n+        if (x != 0.0)\n+            throw new RuntimeException(\"pow(0.0, 0.5) should be 0.0\");\n+\n+        x = FastMath.pow(Double.POSITIVE_INFINITY, -0.5);\n+        if (x != 0.0)\n+            throw new RuntimeException(\"pow(Inf, -0.5) should be 0.0\");\n+\n+        x = FastMath.pow(0.0, -0.5);\n+        if (x != Double.POSITIVE_INFINITY)\n+            throw new RuntimeException(\"pow(0.0, -0.5) should be Inf\");\n+\n+        x = FastMath.pow(Double.POSITIVE_INFINITY, 0.5);\n+        if (x != Double.POSITIVE_INFINITY)\n+            throw new RuntimeException(\"pow(Inf, 0.5) should be Inf\");\n+\n+        x = FastMath.pow(-0.0, -3.0);\n+        if (x != Double.NEGATIVE_INFINITY)\n+            throw new RuntimeException(\"pow(-0.0, -3.0) should be -Inf\");\n+\n+        x = FastMath.pow(Double.NEGATIVE_INFINITY, 3.0);\n+        if (x != Double.NEGATIVE_INFINITY)\n+            throw new RuntimeException(\"pow(-Inf, -3.0) should be -Inf\");\n+\n+        x = FastMath.pow(-0.0, -3.5);\n+        if (x != Double.POSITIVE_INFINITY)\n+            throw new RuntimeException(\"pow(-0.0, -3.5) should be Inf\");\n+\n+        x = FastMath.pow(Double.POSITIVE_INFINITY, 3.5);\n+        if (x != Double.POSITIVE_INFINITY)\n+            throw new RuntimeException(\"pow(Inf, 3.5) should be Inf\");\n+\n+        x = FastMath.pow(-2.0, 3.0);\n+        if (x != -8.0)\n+            throw new RuntimeException(\"pow(-2.0, 3.0) should be -8.0\");\n+\n+        x = FastMath.pow(-2.0, 3.5);\n+        if (x == x)\n+            throw new RuntimeException(\"pow(-2.0, 3.5) should be NaN\");\n+    }\n+\n+    @Test\n+    public void testAtan2SpecialCases() {\n+        double x;\n+\n+        x = FastMath.atan2(Double.NaN, 0.0);\n+        if (x == x)\n+            throw new RuntimeException(\"atan2(NaN, 0.0) should be NaN\");\n+\n+        x = FastMath.atan2(0.0, Double.NaN);\n+        if (x == x)\n+            throw new RuntimeException(\"atan2(0.0, NaN) should be NaN\");\n+\n+        x = FastMath.atan2(0.0, 0.0);\n+        if (x != 0.0 || 1 / x != Double.POSITIVE_INFINITY)\n+            throw new RuntimeException(\"atan2(0.0, 0.0) should be 0.0\");\n+\n+        x = FastMath.atan2(0.0, 0.001);\n+        if (x != 0.0 || 1 / x != Double.POSITIVE_INFINITY)\n+            throw new RuntimeException(\"atan2(0.0, 0.001) should be 0.0\");\n+\n+        x = FastMath.atan2(0.1, Double.POSITIVE_INFINITY);\n+        if (x != 0.0 || 1 / x != Double.POSITIVE_INFINITY)\n+            throw new RuntimeException(\"atan2(0.1, +Inf) should be 0.0\");\n+\n+        x = FastMath.atan2(-0.0, 0.0);\n+        if (x != 0.0 || 1 / x != Double.NEGATIVE_INFINITY)\n+            throw new RuntimeException(\"atan2(-0.0, 0.0) should be -0.0\");\n+\n+        x = FastMath.atan2(-0.0, 0.001);\n+        if (x != 0.0 || 1 / x != Double.NEGATIVE_INFINITY)\n+            throw new RuntimeException(\"atan2(-0.0, 0.001) should be -0.0\");\n+\n+        x = FastMath.atan2(-0.1, Double.POSITIVE_INFINITY);\n+        if (x != 0.0 || 1 / x != Double.NEGATIVE_INFINITY)\n+            throw new RuntimeException(\"atan2(-0.0, +Inf) should be -0.0\");\n+\n+        x = FastMath.atan2(0.0, -0.0);\n+        if (x != Math.PI)\n+            throw new RuntimeException(\"atan2(0.0, -0.0) should be PI\");\n+\n+        x = FastMath.atan2(0.1, Double.NEGATIVE_INFINITY);\n+        if (x != Math.PI)\n+            throw new RuntimeException(\"atan2(0.1, -Inf) should be PI\");\n+\n+        x = FastMath.atan2(-0.0, -0.0);\n+        if (x != -Math.PI)\n+            throw new RuntimeException(\"atan2(-0.0, -0.0) should be -PI\");\n+\n+        x = FastMath.atan2(-0.1, Double.NEGATIVE_INFINITY);\n+        if (x != -Math.PI)\n+            throw new RuntimeException(\"atan2(0.1, -Inf) should be -PI\");\n+\n+        x = FastMath.atan2(0.1, 0.0);\n+        if (x != Math.PI / 2)\n+            throw new RuntimeException(\"atan2(0.1, 0.0) should be PI/2\");\n+\n+        x = FastMath.atan2(0.1, -0.0);\n+        if (x != Math.PI / 2)\n+            throw new RuntimeException(\"atan2(0.1, -0.0) should be PI/2\");\n+\n+        x = FastMath.atan2(Double.POSITIVE_INFINITY, 0.1);\n+        if (x != Math.PI / 2)\n+            throw new RuntimeException(\"atan2(Inf, 0.1) should be PI/2\");\n+\n+        x = FastMath.atan2(Double.POSITIVE_INFINITY, -0.1);\n+        if (x != Math.PI / 2)\n+            throw new RuntimeException(\"atan2(Inf, -0.1) should be PI/2\");\n+\n+        x = FastMath.atan2(-0.1, 0.0);\n+        if (x != -Math.PI / 2)\n+            throw new RuntimeException(\"atan2(-0.1, 0.0) should be -PI/2\");\n+\n+        x = FastMath.atan2(-0.1, -0.0);\n+        if (x != -Math.PI / 2)\n+            throw new RuntimeException(\"atan2(-0.1, -0.0) should be -PI/2\");\n+\n+        x = FastMath.atan2(Double.NEGATIVE_INFINITY, 0.1);\n+        if (x != -Math.PI / 2)\n+            throw new RuntimeException(\"atan2(-Inf, 0.1) should be -PI/2\");\n+\n+        x = FastMath.atan2(Double.NEGATIVE_INFINITY, -0.1);\n+        if (x != -Math.PI / 2)\n+            throw new RuntimeException(\"atan2(-Inf, -0.1) should be -PI/2\");\n+\n+        x = FastMath.atan2(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n+        if (x != Math.PI / 4)\n+            throw new RuntimeException(\"atan2(Inf, Inf) should be PI/4\");\n+\n+        x = FastMath.atan2(Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY);\n+        if (x != Math.PI * 3.0 / 4.0)\n+            throw new RuntimeException(\"atan2(Inf, -Inf) should be PI * 3/4\");\n+\n+        x = FastMath.atan2(Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n+        if (x != -Math.PI / 4)\n+            throw new RuntimeException(\"atan2(-Inf, Inf) should be -PI/4\");\n+\n+        x = FastMath.atan2(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY);\n+        if (x != -Math.PI * 3.0 / 4.0)\n+            throw new RuntimeException(\"atan2(-Inf, -Inf) should be -PI * 3/4\");\n+    }\n+\n+    @Test\n+    public void testPowAccuracy() {\n+        double maxerrulp = 0.0;\n+\n+        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {\n+            double x = (generator.nextDouble() * 2.0 + 0.25);\n+            double y = (generator.nextDouble() * 1200.0 - 600.0) * generator.nextDouble();\n+            /*\n+             * double x = FastMath.floor(generator.nextDouble()*1024.0 - 512.0); double\n+             * y; if (x != 0) y = FastMath.floor(512.0 / FastMath.abs(x)); else\n+             * y = generator.nextDouble()*1200.0; y = y - y/2; x = FastMath.pow(2.0, x) *\n+             * generator.nextDouble(); y = y * generator.nextDouble();\n+             */\n+\n+            // double x = generator.nextDouble()*2.0;\n+            double tst = FastMath.pow(x, y);\n+            double ref = DfpMath.pow(field.newDfp(x), field.newDfp(y)).toDouble();\n+            double err = (tst - ref) / ref;\n+\n+            if (err != 0) {\n+                double ulp = Math.abs(ref -\n+                                      Double.longBitsToDouble((Double\n+                                          .doubleToLongBits(ref) ^ 1)));\n+                double errulp = field.newDfp(tst).subtract(DfpMath.pow(field.newDfp(x), field.newDfp(y))).divide(field.newDfp(ulp)).toDouble();\n+//                System.out.println(x + \"\\t\" + y + \"\\t\" + tst + \"\\t\" + ref + \"\\t\" + err + \"\\t\" + errulp);\n+\n+                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n+            }\n+        }\n+\n+        Assert.assertTrue(\"pow() had errors in excess of \" + MAX_ERROR_ULP + \" ULP\", maxerrulp < MAX_ERROR_ULP);\n+    }\n+\n+    @Test\n+    public void testExpAccuracy() {\n+        double maxerrulp = 0.0;\n+\n+        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {\n+            /* double x = 1.0 + i/1024.0/2.0; */\n+            double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();\n+            // double x = (generator.nextDouble() * 20.0) - 10.0;\n+            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();\n+            /* double x = 3.0 / 512.0 * i - 3.0; */\n+            double tst = FastMath.exp(x);\n+            double ref = DfpMath.exp(field.newDfp(x)).toDouble();\n+            double err = (tst - ref) / ref;\n+\n+            if (err != 0) {\n+                double ulp = Math.abs(ref -\n+                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));\n+                double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();\n+//                System.out.println(x + \"\\t\" + tst + \"\\t\" + ref + \"\\t\" + err + \"\\t\" + errulp);\n+\n+                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n+            }\n+        }\n+\n+        Assert.assertTrue(\"exp() had errors in excess of \" + MAX_ERROR_ULP + \" ULP\", maxerrulp < MAX_ERROR_ULP);\n+    }\n+\n+    @Test\n+    public void testSinAccuracy() {\n+        double maxerrulp = 0.0;\n+\n+        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {\n+            /* double x = 1.0 + i/1024.0/2.0; */\n+            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();\n+            double x = ((generator.nextDouble() * Math.PI) - Math.PI / 2.0) *\n+                       Math.pow(2, 21) * generator.nextDouble();\n+            // double x = (generator.nextDouble() * 20.0) - 10.0;\n+            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();\n+            /* double x = 3.0 / 512.0 * i - 3.0; */\n+            double tst = FastMath.sin(x);\n+            double ref = DfpMath.sin(field.newDfp(x)).toDouble();\n+            double err = (tst - ref) / ref;\n+\n+            if (err != 0) {\n+                double ulp = Math.abs(ref -\n+                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));\n+                double errulp = field.newDfp(tst).subtract(DfpMath.sin(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();\n+//                System.out.println(x + \"\\t\" + tst + \"\\t\" + ref + \"\\t\" + err + \"\\t\" + errulp);\n+\n+                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n+            }\n+        }\n+\n+        Assert.assertTrue(\"sin() had errors in excess of \" + MAX_ERROR_ULP + \" ULP\", maxerrulp < MAX_ERROR_ULP);\n+    }\n+\n+    @Test\n+    public void testCosAccuracy() {\n+        double maxerrulp = 0.0;\n+\n+        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {\n+            /* double x = 1.0 + i/1024.0/2.0; */\n+            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();\n+            double x = ((generator.nextDouble() * Math.PI) - Math.PI / 2.0) *\n+                       Math.pow(2, 21) * generator.nextDouble();\n+            // double x = (generator.nextDouble() * 20.0) - 10.0;\n+            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();\n+            /* double x = 3.0 / 512.0 * i - 3.0; */\n+            double tst = FastMath.cos(x);\n+            double ref = DfpMath.cos(field.newDfp(x)).toDouble();\n+            double err = (tst - ref) / ref;\n+\n+            if (err != 0) {\n+                double ulp = Math.abs(ref -\n+                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));\n+                double errulp = field.newDfp(tst).subtract(DfpMath.cos(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();\n+//                System.out.println(x + \"\\t\" + tst + \"\\t\" + ref + \"\\t\" + err + \"\\t\" + errulp);\n+\n+                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n+            }\n+        }\n+\n+        Assert.assertTrue(\"cos() had errors in excess of \" + MAX_ERROR_ULP + \" ULP\", maxerrulp < MAX_ERROR_ULP);\n+    }\n+\n+    @Test\n+    public void testTanAccuracy() {\n+        double maxerrulp = 0.0;\n+\n+        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {\n+            /* double x = 1.0 + i/1024.0/2.0; */\n+            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();\n+            double x = ((generator.nextDouble() * Math.PI) - Math.PI / 2.0) *\n+                       Math.pow(2, 12) * generator.nextDouble();\n+            // double x = (generator.nextDouble() * 20.0) - 10.0;\n+            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();\n+            /* double x = 3.0 / 512.0 * i - 3.0; */\n+            double tst = FastMath.tan(x);\n+            double ref = DfpMath.tan(field.newDfp(x)).toDouble();\n+            double err = (tst - ref) / ref;\n+\n+            if (err != 0) {\n+                double ulp = Math.abs(ref -\n+                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));\n+                double errulp = field.newDfp(tst).subtract(DfpMath.tan(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();\n+//                System.out.println(x + \"\\t\" + tst + \"\\t\" + ref + \"\\t\" + err + \"\\t\" + errulp);\n+\n+                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n+            }\n+        }\n+\n+        Assert.assertTrue(\"tan() had errors in excess of \" + MAX_ERROR_ULP + \" ULP\", maxerrulp < MAX_ERROR_ULP);\n+    }\n+\n+    @Test\n+    public void testAtanAccuracy() {\n+        double maxerrulp = 0.0;\n+\n+        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {\n+            /* double x = 1.0 + i/1024.0/2.0; */\n+            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();\n+            // double x = ((generator.nextDouble() * Math.PI) - Math.PI/2.0) *\n+            // generator.nextDouble();\n+            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble();\n+\n+            // double x = (generator.nextDouble() * 20.0) - 10.0;\n+            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();\n+            /* double x = 3.0 / 512.0 * i - 3.0; */\n+            double tst = FastMath.atan(x);\n+            double ref = DfpMath.atan(field.newDfp(x)).toDouble();\n+            double err = (tst - ref) / ref;\n+\n+            if (err != 0) {\n+                double ulp = Math.abs(ref -\n+                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));\n+                double errulp = field.newDfp(tst).subtract(DfpMath.atan(field.newDfp(x))).divide(field.newDfp(ulp)).toDouble();\n+//                System.out.println(x + \"\\t\" + tst + \"\\t\" + ref + \"\\t\" + err + \"\\t\" + errulp);\n+\n+                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n+            }\n+        }\n+\n+        Assert.assertTrue(\"atan() had errors in excess of \" + MAX_ERROR_ULP + \" ULP\", maxerrulp < MAX_ERROR_ULP);\n+    }\n+\n+    @Test\n+    public void testAtan2Accuracy() {\n+        double maxerrulp = 0.0;\n+\n+        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {\n+            /* double x = 1.0 + i/1024.0/2.0; */\n+            // double x = ((generator.nextDouble() * 1416.0) - 708.0) * generator.nextDouble();\n+            double x = generator.nextDouble() - 0.5;\n+            double y = generator.nextDouble() - 0.5;\n+            // double x = (generator.nextDouble() * 20.0) - 10.0;\n+            // double x = ((generator.nextDouble() * 2.0) - 1.0) * generator.nextDouble();\n+            /* double x = 3.0 / 512.0 * i - 3.0; */\n+            double tst = FastMath.atan2(y, x);\n+            Dfp refdfp = DfpMath.atan(field.newDfp(y)\n+                .divide(field.newDfp(x)));\n+            /* Make adjustments for sign */\n+            if (x < 0.0) {\n+                if (y > 0.0)\n+                    refdfp = field.getPi().add(refdfp);\n+                else\n+                    refdfp = refdfp.subtract(field.getPi());\n+            }\n+\n+            double ref = refdfp.toDouble();\n+            double err = (tst - ref) / ref;\n+\n+            if (err != 0) {\n+                double ulp = Math.abs(ref -\n+                                      Double.longBitsToDouble((Double\n+                                          .doubleToLongBits(ref) ^ 1)));\n+                double errulp = field.newDfp(tst).subtract(refdfp).divide(field.newDfp(ulp)).toDouble();\n+//                System.out.println(x + \"\\t\" + y + \"\\t\" + tst + \"\\t\" + ref + \"\\t\" + errulp);\n+\n+                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n+            }\n+        }\n+\n+        Assert.assertTrue(\"atan2() had errors in excess of \" + MAX_ERROR_ULP + \" ULP\", maxerrulp < MAX_ERROR_ULP);\n+    }\n+\n+    @Test\n+    public void testExpm1Accuracy() {\n+        double maxerrulp = 0.0;\n+\n+        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {\n+            /* double x = 1.0 + i/1024.0/2.0; */\n+            // double x = (generator.nextDouble() * 20.0) - 10.0;\n+            double x = ((generator.nextDouble() * 16.0) - 8.0) * generator.nextDouble();\n+            /* double x = 3.0 / 512.0 * i - 3.0; */\n+            double tst = FastMath.expm1(x);\n+            double ref = DfpMath.exp(field.newDfp(x)).subtract(field.getOne()).toDouble();\n+            double err = (tst - ref) / ref;\n+\n+            if (err != 0) {\n+                double ulp = Math.abs(ref -\n+                                      Double.longBitsToDouble((Double\n+                                          .doubleToLongBits(ref) ^ 1)));\n+                double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble();\n+//                System.out.println(x + \"\\t\" + tst + \"\\t\" + ref + \"\\t\" + err + \"\\t\" + errulp);\n+\n+                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n+            }\n+        }\n+\n+        Assert.assertTrue(\"expm1() had errors in excess of \" + MAX_ERROR_ULP + \" ULP\", maxerrulp < MAX_ERROR_ULP);\n+    }\n+\n+    @Test\n+    public void testToDegrees() {\n+        double maxerrulp = 0.0;\n+        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {\n+            double x = generator.nextDouble();\n+            double tst = field.newDfp(x).multiply(180).divide(field.getPi()).toDouble();\n+            double ref = FastMath.toDegrees(x);\n+            double err = (tst - ref) / ref;\n+\n+            if (err != 0) {\n+                double ulp = Math.abs(ref -\n+                                      Double.longBitsToDouble((Double.doubleToLongBits(ref) ^ 1)));\n+                double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble();\n+//                System.out.println(x + \"\\t\" + tst + \"\\t\" + ref + \"\\t\" + err + \"\\t\" + errulp);\n+\n+                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n+            }\n+        }\n+        Assert.assertTrue(\"toDegrees() had errors in excess of \" + MAX_ERROR_ULP + \" ULP\", maxerrulp < MAX_ERROR_ULP);\n+\n+    }\n+\n+    @Test\n+    public void testToRadians() {\n+        double maxerrulp = 0.0;\n+        for (int i = 0; i < NUMBER_OF_TRIALS; i++) {\n+            double x = generator.nextDouble();\n+            double tst = field.newDfp(x).multiply(field.getPi()).divide(180).toDouble();\n+            double ref = FastMath.toRadians(x);\n+            double err = (tst - ref) / ref;\n+\n+            if (err != 0) {\n+                double ulp = Math.abs(ref -\n+                                      Double.longBitsToDouble((Double\n+                                          .doubleToLongBits(ref) ^ 1)));\n+                double errulp = field.newDfp(tst).subtract(DfpMath.exp(field.newDfp(x)).subtract(field.getOne())).divide(field.newDfp(ulp)).toDouble();\n+//                System.out.println(x + \"\\t\" + tst + \"\\t\" + ref + \"\\t\" + err + \"\\t\" + errulp);\n+\n+                maxerrulp = Math.max(maxerrulp, Math.abs(errulp));\n+            }\n+        }\n+        Assert.assertTrue(\"toRadians() had errors in excess of \" + MAX_ERROR_ULP + \" ULP\", maxerrulp < MAX_ERROR_ULP);\n+\n+    }\n+\n+    @Ignore\n+    @Test\n+    public void testPerformance() {\n+        final int numberOfRuns = 10000000;\n+        for (int j = 0; j < 10; j++) {\n+            double x = 0;\n+            long time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += StrictMath.log(Math.PI + i/* 1.0 + i/1e9 */);\n+            time = System.currentTimeMillis() - time;\n+            System.out.print(\"StrictMath.log \" + time + \"\\t\" + x + \"\\t\");\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += FastMath.log(Math.PI + i/* 1.0 + i/1e9 */);\n+            time = System.currentTimeMillis() - time;\n+            System.out.println(\"FastMath.log \" + time + \"\\t\" + x);\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += StrictMath.pow(Math.PI + i / 1e6, i / 1e6);\n+            time = System.currentTimeMillis() - time;\n+            System.out.print(\"StrictMath.pow \" + time + \"\\t\" + x + \"\\t\");\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += FastMath.pow(Math.PI + i / 1e6, i / 1e6);\n+            time = System.currentTimeMillis() - time;\n+            System.out.println(\"FastMath.pow \" + time + \"\\t\" + x);\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += StrictMath.exp(i / 1000000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.print(\"StrictMath.exp \" + time + \"\\t\" + x + \"\\t\");\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += FastMath.exp(i / 1000000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.println(\"FastMath.exp \" + time + \"\\t\" + x);\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += StrictMath.sin(i / 1000000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.print(\"StrictMath.sin \" + time + \"\\t\" + x + \"\\t\");\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += FastMath.sin(i / 1000000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.println(\"FastMath.sin \" + time + \"\\t\" + x);\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += StrictMath.cos(i / 1000000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.print(\"StrictMath.cos \" + time + \"\\t\" + x + \"\\t\");\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += FastMath.cos(i / 1000000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.println(\"FastMath.cos \" + time + \"\\t\" + x);\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += StrictMath.tan(i / 1000000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.print(\"StrictMath.tan \" + time + \"\\t\" + x + \"\\t\");\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += FastMath.tan(i / 1000000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.println(\"FastMath.tan \" + time + \"\\t\" + x);\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += StrictMath.atan(i / 1000000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.print(\"StrictMath.atan \" + time + \"\\t\" + x + \"\\t\");\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += FastMath.atan(i / 1000000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.println(\"FastMath.atan \" + time + \"\\t\" + x);\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += StrictMath.expm1(-i / 100000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.print(\"StrictMath.expm1 \" + time + \"\\t\" + x + \"\\t\");\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += FastMath.expm1(-i / 100000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.println(\"FastMath.expm1 \" + time + \"\\t\" + x);\n+\n+            x = 0;\n+            time = System.currentTimeMillis();\n+            for (int i = 0; i < numberOfRuns; i++)\n+                x += FastMath.expm1(-i / 100000.0);\n+            time = System.currentTimeMillis() - time;\n+            System.out.println(\"FastMath.expm1 \" + time + \"\\t\" + x);\n+        }\n+    }\n+\n+}", "timestamp": 1283714892, "metainfo": ""}