{"sha": "e3aebabc8a6138919010b280457ee0d7a1053b35", "log": "MATH-425 Replaced \"MatrixIndexException\" with \"OutOfRangeException\" or \"DimensionMismatchException\". Removed try/catch blocks misused as preconditions check.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/exception/MultiDimensionMismatchException.java\n+++ b/src/main/java/org/apache/commons/math/exception/MultiDimensionMismatchException.java\n     /**\n      * Construct an exception from the mismatched dimensions.\n      *\n-     * @param wrong Wrong dimensionq.\n-     * @param expected Expected dimensionq.\n+     * @param wrong Wrong dimensions.\n+     * @param expected Expected dimensions.\n      */\n     public MultiDimensionMismatchException(Integer[] wrong,\n                                            Integer[] expected) {\n         return wrong[index];\n     }\n     /**\n-     * @return an the expected dimension stored at {@code index}..\n+     * @param index Dimension index.\n+     * @return the expected dimension stored at {@code index}.\n      */\n     public int getExpectedDimension(int index) {\n         return expected[index];\n--- a/src/main/java/org/apache/commons/math/exception/OutOfRangeException.java\n+++ b/src/main/java/org/apache/commons/math/exception/OutOfRangeException.java\n  * @version $Revision$ $Date$\n  */\n public class OutOfRangeException extends MathIllegalNumberException {\n-\n     /** Serializable version Id. */\n     private static final long serialVersionUID = 111601815794403609L;\n-\n     /** Lower bound. */\n     private final Number lo;\n     /** Higher bound. */\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     CLASS_DOESNT_IMPLEMENT_COMPARABLE(\"class ({0}) does not implement Comparable\"),\n     CLOSEST_ORTHOGONAL_MATRIX_HAS_NEGATIVE_DETERMINANT(\"the closest orthogonal matrix has a negative determinant {0}\"),\n     COLUMN_INDEX_OUT_OF_RANGE(\"column index {0} out of allowed range [{1}, {2}]\"),\n+    COLUMN_INDEX(\"column index ({0})\"), /* keep */\n     CONTINUED_FRACTION_INFINITY_DIVERGENCE(\"Continued fraction convergents diverged to +/- infinity for value {0}\"),\n     CONTINUED_FRACTION_NAN_DIVERGENCE(\"Continued fraction diverged to NaN for value {0}\"),\n     CONTRACTION_CRITERIA_SMALLER_THAN_EXPANSION_FACTOR(\"contraction criteria ({0}) smaller than the expansion factor ({1}).  This would lead to a never ending loop of expansion and contraction as a newly expanded internal storage array would immediately satisfy the criteria for contraction.\"),\n     SIGNIFICANCE_LEVEL(\"significance level ({0})\"), /* keep */\n     OUT_OF_ORDER_ABSCISSA_ARRAY(\"the abscissae array must be sorted in a strictly increasing order, but the {0}-th element is {1} whereas {2}-th is {3}\"),\n     OUT_OF_RANGE_ROOT_OF_UNITY_INDEX(\"out of range root of unity index {0} (must be in [{1};{2}])\"),\n+    OUT_OF_RANGE(\"out of range\"), /* keep */\n     OUT_OF_RANGE_SIMPLE(\"{0} out of [{1}, {2}] range\"), /* keep */\n     OVERFLOW_IN_FRACTION(\"overflow in fraction {0}/{1}, cannot negate\"),\n     OVERFLOW_IN_ADDITION(\"overflow in addition: {0} + {1}\"),\n     ROOTS_OF_UNITY_NOT_COMPUTED_YET(\"roots of unity have not been computed yet\"),\n     ROTATION_MATRIX_DIMENSIONS(\"a {0}x{1} matrix cannot be a rotation matrix\"),\n     ROW_INDEX_OUT_OF_RANGE(\"row index {0} out of allowed range [{1}, {2}]\"),\n+    ROW_INDEX(\"row index ({0})\"), /* keep */\n     SAME_SIGN_AT_ENDPOINTS(\"function values at endpoints do not have different signs, endpoints: [{0}, {1}], values: [{2}, {3}]\"),\n     SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE(\"sample size ({0}) exceeds collection size ({1})\"), /* keep */\n     SAMPLE_SIZE_LARGER_THAN_POPULATION_SIZE(\"sample size ({0}) must be less than or equal to population size ({1})\"),\n--- a/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/AbstractFieldMatrix.java\n \n import org.apache.commons.math.Field;\n import org.apache.commons.math.FieldElement;\n-import org.apache.commons.math.MathRuntimeException;\n import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n+import org.apache.commons.math.exception.DimensionMismatchException;\n+import org.apache.commons.math.exception.NoDataException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NullArgumentException;\n import org.apache.commons.math.exception.util.LocalizedFormats;\n \n /**\n  * @since 2.0\n  */\n public abstract class AbstractFieldMatrix<T extends FieldElement<T>> implements FieldMatrix<T> {\n-\n     /** Field to which the elements belong. */\n     private final Field<T> field;\n \n     /**\n      * Create a new FieldMatrix<T> with the supplied row and column dimensions.\n      *\n-     * @param field field to which the elements belong\n-     * @param rowDimension  the number of rows in the new matrix\n-     * @param columnDimension  the number of columns in the new matrix\n-     * @throws IllegalArgumentException if row or column dimension is not positive\n+     * @param field Field to which the elements belong.\n+     * @param rowDimension Number of rows in the new matrix.\n+     * @param columnDimension Number of columns in the new matrix.\n+     * @throws NotStrictlyPositiveException if row or column dimension is not\n+     * positive.\n      */\n     protected AbstractFieldMatrix(final Field<T> field,\n-                                  final int rowDimension, final int columnDimension)\n-        throws IllegalArgumentException {\n-        if (rowDimension < 1 ) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.INSUFFICIENT_DIMENSION, rowDimension, 1);\n-        }\n-        if (columnDimension < 1) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.INSUFFICIENT_DIMENSION, columnDimension, 1);\n+                                  final int rowDimension,\n+                                  final int columnDimension) {\n+        if (rowDimension <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.DIMENSION,\n+                                                   rowDimension);\n+        }\n+        if (columnDimension <= 0) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.DIMENSION,\n+                                                   columnDimension);\n         }\n         this.field = field;\n     }\n \n     /**\n      * Get the elements type from an array.\n-     * @param <T> the type of the field elements\n-     * @param d data array\n-     * @return field to which array elements belong\n-     * @exception IllegalArgumentException if array is empty\n-     */\n-    protected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d)\n-        throws IllegalArgumentException {\n+     *\n+     * @param <T> Type of the field elements.\n+     * @param d Data array.\n+     * @return the field to which the array elements belong.\n+     * @throws NullArgumentException if the array is {@code null}.\n+     * @throws NoDataException if the array is empty.\n+     */\n+    protected static <T extends FieldElement<T>> Field<T> extractField(final T[][] d) {\n+        if (d == null) {\n+            throw new NullArgumentException();\n+        }\n         if (d.length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);\n+            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n         }\n         if (d[0].length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n+            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n         }\n         return d[0][0].getField();\n     }\n \n     /**\n      * Get the elements type from an array.\n-     * @param <T> the type of the field elements\n-     * @param d data array\n-     * @return field to which array elements belong\n-     * @exception IllegalArgumentException if array is empty\n-     */\n-    protected static <T extends FieldElement<T>> Field<T> extractField(final T[] d)\n-        throws IllegalArgumentException {\n+     *\n+     * @param <T> Type of the field elements.\n+     * @param d Data array.\n+     * @return the field to which the array elements belong.\n+     * @throws NoDataException if array is empty.\n+     */\n+    protected static <T extends FieldElement<T>> Field<T> extractField(final T[] d) {\n         if (d.length == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);\n+            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n         }\n         return d[0].getField();\n     }\n      * <p>\n      * Complete arrays are filled with field.getZero()\n      * </p>\n-     * @param <T> the type of the field elements\n+     * @param <T> Type of the field elements\n      * @param field field to which array elements belong\n      * @param rows number of rows\n      * @param columns number of columns (may be negative to build partial\n \n     /** {@inheritDoc} */\n     public FieldMatrix<T> getSubMatrix(final int startRow, final int endRow,\n-                                   final int startColumn, final int endColumn)\n-        throws MatrixIndexException {\n+                                       final int startColumn, final int endColumn) {\n \n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n \n     }\n \n     /** {@inheritDoc} */\n-    public FieldMatrix<T> getSubMatrix(final int[] selectedRows, final int[] selectedColumns)\n-        throws MatrixIndexException {\n+    public FieldMatrix<T> getSubMatrix(final int[] selectedRows,\n+                                       final int[] selectedColumns) {\n \n         // safety checks\n         checkSubMatrixIndex(selectedRows, selectedColumns);\n     /** {@inheritDoc} */\n     public void copySubMatrix(final int startRow, final int endRow,\n                               final int startColumn, final int endColumn,\n-                              final T[][] destination)\n-        throws MatrixIndexException, IllegalArgumentException {\n-\n+                              final T[][] destination) {\n         // safety checks\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         final int rowsCount    = endRow + 1 - startRow;\n         final int columnsCount = endColumn + 1 - startColumn;\n         if ((destination.length < rowsCount) || (destination[0].length < columnsCount)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    destination.length, destination[0].length,\n-                    rowsCount, columnsCount);\n+            throw new MatrixDimensionMismatchException(destination.length,\n+                                                       destination[0].length,\n+                                                       rowsCount,\n+                                                       columnsCount);\n         }\n \n         // copy entries\n     }\n \n     /** {@inheritDoc} */\n-    public void copySubMatrix(int[] selectedRows, int[] selectedColumns, T[][] destination)\n-        throws MatrixIndexException, IllegalArgumentException {\n-\n+    public void copySubMatrix(int[] selectedRows, int[] selectedColumns, T[][] destination) {\n         // safety checks\n         checkSubMatrixIndex(selectedRows, selectedColumns);\n         if ((destination.length < selectedRows.length) ||\n             (destination[0].length < selectedColumns.length)) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.DIMENSIONS_MISMATCH_2x2,\n-                    destination.length, destination[0].length,\n-                    selectedRows.length, selectedColumns.length);\n+            throw new MatrixDimensionMismatchException(destination.length,\n+                                                       destination[0].length,\n+                                                       selectedRows.length,\n+                                                       selectedColumns.length);\n         }\n \n         // copy entries\n     }\n \n     /** {@inheritDoc} */\n-    public void setSubMatrix(final T[][] subMatrix, final int row, final int column)\n-        throws MatrixIndexException {\n-\n+    public void setSubMatrix(final T[][] subMatrix, final int row, final int column) {\n+        if (subMatrix == null) {\n+            throw new NullArgumentException();\n+        }\n         final int nRows = subMatrix.length;\n         if (nRows == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_ROW);\n+            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n         }\n \n         final int nCols = subMatrix[0].length;\n         if (nCols == 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n+            throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n         }\n \n         for (int r = 1; r < nRows; ++r) {\n             if (subMatrix[r].length != nCols) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.DIFFERENT_ROWS_LENGTHS,\n-                        nCols, subMatrix[r].length);\n+                throw new DimensionMismatchException(nCols, subMatrix[r].length);\n             }\n         }\n \n                 setEntry(row + i, column + j, subMatrix[i][j]);\n             }\n         }\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    public FieldMatrix<T> getRowMatrix(final int row)\n-        throws MatrixIndexException {\n-\n+    }\n+\n+    /** {@inheritDoc} */\n+    public FieldMatrix<T> getRowMatrix(final int row) {\n         checkRowIndex(row);\n         final int nCols = getColumnDimension();\n         final FieldMatrix<T> out = createMatrix(1, nCols);\n     }\n \n     /** {@inheritDoc} */\n-    public FieldMatrix<T> getColumnMatrix(final int column)\n-        throws MatrixIndexException {\n+    public FieldMatrix<T> getColumnMatrix(final int column) {\n \n         checkColumnIndex(column);\n         final int nRows = getRowDimension();\n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> getRowVector(final int row)\n-        throws MatrixIndexException {\n+    public FieldVector<T> getRowVector(final int row) {\n         return new ArrayFieldVector<T>(getRow(row), false);\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    public FieldVector<T> getColumnVector(final int column)\n-        throws MatrixIndexException {\n+    public FieldVector<T> getColumnVector(final int column) {\n         return new ArrayFieldVector<T>(getColumn(column), false);\n     }\n \n     }\n \n     /** {@inheritDoc} */\n-    public T[] getRow(final int row)\n-        throws MatrixIndexException {\n-\n+    public T[] getRow(final int row) {\n         checkRowIndex(row);\n         final int nCols = getColumnDimension();\n         final T[] out = buildArray(field, nCols);\n     }\n \n     /** {@inheritDoc} */\n-    public T[] getColumn(final int column)\n-        throws MatrixIndexException {\n-\n+    public T[] getColumn(final int column) {\n         checkColumnIndex(column);\n         final int nRows = getRowDimension();\n         final T[] out = buildArray(field, nRows);\n     }\n \n     /** {@inheritDoc} */\n-    public abstract T getEntry(int row, int column)\n-        throws MatrixIndexException;\n-\n-    /** {@inheritDoc} */\n-    public abstract void setEntry(int row, int column, T value)\n-        throws MatrixIndexException;\n-\n-    /** {@inheritDoc} */\n-    public abstract void addToEntry(int row, int column, T increment)\n-        throws MatrixIndexException;\n-\n-    /** {@inheritDoc} */\n-    public abstract void multiplyEntry(int row, int column, T factor)\n-        throws MatrixIndexException;\n+    public abstract T getEntry(int row, int column);\n+\n+    /** {@inheritDoc} */\n+    public abstract void setEntry(int row, int column, T value);\n+\n+    /** {@inheritDoc} */\n+    public abstract void addToEntry(int row, int column, T increment);\n+\n+    /** {@inheritDoc} */\n+    public abstract void multiplyEntry(int row, int column, T factor);\n \n     /** {@inheritDoc} */\n     public FieldMatrix<T> transpose() {\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         if (v.length != nCols) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                    v.length, nCols);\n+            throw new DimensionMismatchException(v.length, nCols);\n         }\n \n         final T[] out = buildArray(field, nRows);\n             final int nRows = getRowDimension();\n             final int nCols = getColumnDimension();\n             if (v.getDimension() != nCols) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                        v.getDimension(), nCols);\n+                throw new DimensionMismatchException(v.getDimension(), nCols);\n             }\n \n             final T[] out = buildArray(field, nRows);\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         if (v.length != nRows) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                    v.length, nRows);\n+            throw new DimensionMismatchException(v.length, nRows);\n         }\n \n         final T[] out = buildArray(field, nCols);\n             final int nRows = getRowDimension();\n             final int nCols = getColumnDimension();\n             if (v.getDimension() != nRows) {\n-                throw MathRuntimeException.createIllegalArgumentException(\n-                        LocalizedFormats.VECTOR_LENGTH_MISMATCH,\n-                        v.getDimension(), nRows);\n+                throw new DimensionMismatchException(v.getDimension(), nRows);\n             }\n \n             final T[] out = buildArray(field, nCols);\n     public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor,\n                             final int startRow, final int endRow,\n                             final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     public T walkInColumnOrder(final FieldMatrixChangingVisitor<T> visitor,\n                                final int startRow, final int endRow,\n                                final int startColumn, final int endColumn)\n-    throws MatrixIndexException, MatrixVisitorException {\n+    throws MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     public T walkInColumnOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                final int startRow, final int endRow,\n                                final int startColumn, final int endColumn)\n-    throws MatrixIndexException, MatrixVisitorException {\n+    throws MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor,\n                                        final int startRow, final int endRow,\n                                        final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n     }\n \n     public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                        final int startRow, final int endRow,\n                                        final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);\n     }\n \n \n     /**\n      * Check if a row index is valid.\n-     * @param row row index to check\n-     * @exception MatrixIndexException if index is not valid\n+     *\n+     * @param row Row index to check.\n+     * @throws OutOfRangeException if {@code index} is not valid.\n      */\n     protected void checkRowIndex(final int row) {\n         if (row < 0 || row >= getRowDimension()) {\n-            throw new MatrixIndexException(LocalizedFormats.ROW_INDEX_OUT_OF_RANGE,\n-                                           row, 0, getRowDimension() - 1);\n+            throw new OutOfRangeException(LocalizedFormats.ROW_INDEX,\n+                                          row, 0, getRowDimension() - 1);\n         }\n     }\n \n     /**\n      * Check if a column index is valid.\n-     * @param column column index to check\n-     * @exception MatrixIndexException if index is not valid\n-     */\n-    protected void checkColumnIndex(final int column)\n-        throws MatrixIndexException {\n+     *\n+     * @param column Column index to check.\n+     * @throws OutOfRangeException if {@code index} is not valid.\n+     */\n+    protected void checkColumnIndex(final int column) {\n         if (column < 0 || column >= getColumnDimension()) {\n-            throw new MatrixIndexException(LocalizedFormats.COLUMN_INDEX_OUT_OF_RANGE,\n-                                           column, 0, getColumnDimension() - 1);\n+            throw new OutOfRangeException(LocalizedFormats.COLUMN_INDEX,\n+                                          column, 0, getColumnDimension() - 1);\n         }\n     }\n \n      * Check if submatrix ranges indices are valid.\n      * Rows and columns are indicated counting from 0 to n-1.\n      *\n-     * @param startRow Initial row index\n-     * @param endRow Final row index\n-     * @param startColumn Initial column index\n-     * @param endColumn Final column index\n-     * @exception MatrixIndexException  if the indices are not valid\n+     * @param startRow Initial row index.\n+     * @param endRow Final row index.\n+     * @param startColumn Initial column index.\n+     * @param endColumn Final column index.\n+     * @throws OutOfRangeException if the indices are not valid.\n+     * @throws NumberIsTooSmallException if {@code endRow < startRow} or\n+     * {@code endColumn < startColumn}.\n      */\n     protected void checkSubMatrixIndex(final int startRow, final int endRow,\n                                        final int startColumn, final int endColumn) {\n         checkRowIndex(startRow);\n         checkRowIndex(endRow);\n-        if (startRow > endRow) {\n-            throw new MatrixIndexException(LocalizedFormats.INITIAL_ROW_AFTER_FINAL_ROW,\n-                                           startRow, endRow);\n+        if (endRow < startRow) {\n+            throw new NumberIsTooSmallException(LocalizedFormats.INITIAL_ROW_AFTER_FINAL_ROW,\n+                                                endRow, startRow, true);\n         }\n \n         checkColumnIndex(startColumn);\n         checkColumnIndex(endColumn);\n-        if (startColumn > endColumn) {\n-            throw new MatrixIndexException(LocalizedFormats.INITIAL_COLUMN_AFTER_FINAL_COLUMN,\n-                                           startColumn, endColumn);\n+        if (endColumn < startColumn) {\n+            throw new NumberIsTooSmallException(LocalizedFormats.INITIAL_COLUMN_AFTER_FINAL_COLUMN,\n+                                                endColumn, startColumn, true);\n         }\n     }\n \n      *\n      * @param selectedRows Array of row indices.\n      * @param selectedColumns Array of column indices.\n-     * @exception MatrixIndexException if row or column selections are not valid\n+     * @throws NullArgumentException if the arrays are {@code null}.\n+     * @throws NoDataException if the arrays have zero length.\n+     * @throws OutOfRangeException if row or column selections are not valid.\n      */\n     protected void checkSubMatrixIndex(final int[] selectedRows, final int[] selectedColumns) {\n-        if (selectedRows.length * selectedColumns.length == 0) {\n-            if (selectedRows.length == 0) {\n-                throw new MatrixIndexException(LocalizedFormats.EMPTY_SELECTED_ROW_INDEX_ARRAY);\n-            }\n-            throw new MatrixIndexException(LocalizedFormats.EMPTY_SELECTED_COLUMN_INDEX_ARRAY);\n+        if (selectedRows == null ||\n+            selectedColumns == null) {\n+            throw new NullArgumentException();\n+        }\n+        if (selectedRows.length == 0 ||\n+            selectedColumns.length == 0) {\n+            throw new NoDataException();\n         }\n \n         for (final int row : selectedRows) {\n     }\n \n     /**\n-     * Check if a matrix is addition compatible with the instance\n-     * @param m matrix to check\n-     * @exception IllegalArgumentException if matrix is not addition compatible with instance\n+     * Check if a matrix is addition compatible with the instance.\n+     *\n+     * @param m Matrix to check.\n+     * @throws MatrixDimensionMismatchException if the matrix is not\n+     * addition-compatible with instance.\n      */\n     protected void checkAdditionCompatible(final FieldMatrix<T> m) {\n-        if ((getRowDimension()    != m.getRowDimension()) ||\n+        if ((getRowDimension() != m.getRowDimension()) ||\n             (getColumnDimension() != m.getColumnDimension())) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.NOT_ADDITION_COMPATIBLE_MATRICES,\n-                    getRowDimension(), getColumnDimension(),\n-                    m.getRowDimension(), m.getColumnDimension());\n-        }\n-    }\n-\n-    /**\n-     * Check if a matrix is subtraction compatible with the instance\n-     * @param m matrix to check\n-     * @exception IllegalArgumentException if matrix is not subtraction compatible with instance\n+            throw new MatrixDimensionMismatchException(m.getRowDimension(), m.getColumnDimension(),\n+                                                       getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /**\n+     * Check if a matrix is subtraction compatible with the instance.\n+     *\n+     * @param m Matrix to check.\n+     * @throws MatrixDimensionMismatchException if the matrix is not\n+     * subtraction-compatible with instance.\n      */\n     protected void checkSubtractionCompatible(final FieldMatrix<T> m) {\n-        if ((getRowDimension()    != m.getRowDimension()) ||\n+        if ((getRowDimension() != m.getRowDimension()) ||\n             (getColumnDimension() != m.getColumnDimension())) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.NOT_SUBTRACTION_COMPATIBLE_MATRICES,\n-                    getRowDimension(), getColumnDimension(),\n-                    m.getRowDimension(), m.getColumnDimension());\n-        }\n-    }\n-\n-    /**\n-     * Check if a matrix is multiplication compatible with the instance\n-     * @param m matrix to check\n-     * @exception IllegalArgumentException if matrix is not multiplication compatible with instance\n+            throw new MatrixDimensionMismatchException(m.getRowDimension(), m.getColumnDimension(),\n+                                                       getRowDimension(), getColumnDimension());\n+        }\n+    }\n+\n+    /**\n+     * Check if a matrix is multiplication compatible with the instance.\n+     *\n+     * @param m Matrix to check.\n+     * @throws DimensionMismatchException if the matrix is not\n+     * multiplication-compatible with instance.\n      */\n     protected void checkMultiplicationCompatible(final FieldMatrix<T> m) {\n         if (getColumnDimension() != m.getRowDimension()) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                    LocalizedFormats.NOT_MULTIPLICATION_COMPATIBLE_MATRICES,\n-                    getRowDimension(), getColumnDimension(),\n-                    m.getRowDimension(), m.getColumnDimension());\n+            throw new DimensionMismatchException(m.getRowDimension(), getColumnDimension());\n         }\n     }\n }\n--- a/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/Array2DRowFieldMatrix.java\n \n     /** {@inheritDoc} */\n     @Override\n-    public void setSubMatrix(final T[][] subMatrix, final int row, final int column)\n-    throws MatrixIndexException {\n+    public void setSubMatrix(final T[][] subMatrix, final int row, final int column) {\n         if (data == null) {\n             if (row > 0) {\n                 throw MathRuntimeException.createIllegalStateException(\n \n     /** {@inheritDoc} */\n     @Override\n-    public T getEntry(final int row, final int column)\n-        throws MatrixIndexException {\n-        try {\n-            return data[row][column];\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\n-                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void setEntry(final int row, final int column, final T value)\n-        throws MatrixIndexException {\n-        try {\n-            data[row][column] = value;\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\n-                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void addToEntry(final int row, final int column, final T increment)\n-        throws MatrixIndexException {\n-        try {\n-            data[row][column] = data[row][column].add(increment);\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\n-                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void multiplyEntry(final int row, final int column, final T factor)\n-        throws MatrixIndexException {\n-        try {\n-            data[row][column] = data[row][column].multiply(factor);\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\n-                      LocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n-        }\n+    public T getEntry(final int row, final int column) {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+\n+        return data[row][column];\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(final int row, final int column, final T value) {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+\n+        data[row][column] = value;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(final int row, final int column, final T increment) {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+\n+        data[row][column] = data[row][column].add(increment);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(final int row, final int column, final T factor) {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+\n+        data[row][column] = data[row][column].multiply(factor);\n     }\n \n     /** {@inheritDoc} */\n     public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor,\n                             final int startRow, final int endRow,\n                             final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                             final int startRow, final int endRow,\n                             final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     public T walkInColumnOrder(final FieldMatrixChangingVisitor<T> visitor,\n                                final int startRow, final int endRow,\n                                final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n     public T walkInColumnOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                final int startRow, final int endRow,\n                                final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(getRowDimension(), getColumnDimension(),\n                       startRow, endRow, startColumn, endColumn);\n--- a/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n+++ b/src/main/java/org/apache/commons/math/linear/BlockFieldMatrix.java\n  * @since 2.0\n  */\n public class BlockFieldMatrix<T extends FieldElement<T>> extends AbstractFieldMatrix<T> implements Serializable {\n-\n     /** Block size. */\n     public static final int BLOCK_SIZE = 36;\n-\n-    /** Serializable version identifier */\n+    /** Serializable version identifier. */\n     private static final long serialVersionUID = -4602336630143123183L;\n-\n     /** Blocks of matrix entries. */\n     private final T blocks[][];\n-\n     /** Number of rows of the matrix. */\n     private final int rows;\n-\n     /** Number of columns of the matrix. */\n     private final int columns;\n-\n     /** Number of block rows of the matrix. */\n     private final int blockRows;\n-\n     /** Number of block columns of the matrix. */\n     private final int blockColumns;\n \n     /**\n      * Create a new matrix with the supplied row and column dimensions.\n      *\n-     * @param field field to which the elements belong\n-     * @param rows  the number of rows in the new matrix\n-     * @param columns  the number of columns in the new matrix\n-     * @throws IllegalArgumentException if row or column dimension is not\n-     *  positive\n+     * @param field Field to which the elements belong.\n+     * @param rows Number of rows in the new matrix.\n+     * @param columns Number of columns in the new matrix.\n+     * @throws org.apache.commons.math.exception.NotStrictlyPositiveException\n+     * if row or column dimension is not positive.\n      */\n-    public BlockFieldMatrix(final Field<T> field, final int rows, final int columns)\n-        throws IllegalArgumentException {\n-\n+    public BlockFieldMatrix(final Field<T> field, final int rows, final int columns) {\n         super(field, rows, columns);\n         this.rows    = rows;\n         this.columns = columns;\n \n         // allocate storage blocks, taking care of smaller ones at right and bottom\n         blocks = createBlocksLayout(field, rows, columns);\n-\n     }\n \n     /**\n      * <pre>matrix = new BlockFieldMatrix<T>(getField(), rawData.length, rawData[0].length,\n      *                                   toBlocksLayout(rawData), false);</pre>\n      * </p>\n-     * @param rawData data for new matrix, in raw layout\n+     * @param rawData Data for the new matrix, in raw layout.\n      *\n-     * @exception IllegalArgumentException if <code>blockData</code> shape is\n-     * inconsistent with block layout\n+     * @exception DimensionMismatchException if the {@code blockData} shape is\n+     * inconsistent with block layout.\n      * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)\n      */\n-    public BlockFieldMatrix(final T[][] rawData)\n-        throws IllegalArgumentException {\n+    public BlockFieldMatrix(final T[][] rawData) {\n         this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n     }\n \n      * @param copyArray if true, the input array will be copied, otherwise\n      * it will be referenced\n      *\n-     * @exception IllegalArgumentException if <code>blockData</code> shape is\n-     * inconsistent with block layout\n+     * @exception DimensionMismatchException if the {@code blockData} shape is\n+     * inconsistent with block layout.\n      * @see #createBlocksLayout(Field, int, int)\n      * @see #toBlocksLayout(FieldElement[][])\n      * @see #BlockFieldMatrix(FieldElement[][])\n      */\n     public BlockFieldMatrix(final int rows, final int columns,\n-                            final T[][] blockData, final boolean copyArray)\n-        throws IllegalArgumentException {\n-\n+                            final T[][] blockData, final boolean copyArray) {\n         super(extractField(blockData), rows, columns);\n         this.rows    = rows;\n         this.columns = columns;\n                 }\n             }\n         }\n-\n     }\n \n     /**\n      * #BlockFieldMatrix(int, int, FieldElement[][], boolean)}\n      * constructor.\n      * </p>\n-     * @param <T> the type of the field elements\n-     * @param rawData data array in raw layout\n+     * @param <T> Type of the field elements.\n+     * @param rawData Data array in raw layout.\n      * @return a new data array containing the same entries but in blocks layout\n-     * @exception IllegalArgumentException if <code>rawData</code> is not rectangular\n-     *  (not all rows have the same length)\n+     * @throws DimensionMismatchException if {@code rawData} is not rectangular\n+     *  (not all rows have the same length).\n      * @see #createBlocksLayout(Field, int, int)\n      * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)\n      */\n-    public static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData)\n-        throws IllegalArgumentException {\n+    public static <T extends FieldElement<T>> T[][] toBlocksLayout(final T[][] rawData) {\n \n         final int rows         = rawData.length;\n         final int columns      = rawData[0].length;\n                 }\n \n                 ++blockIndex;\n-\n             }\n         }\n \n         return blocks;\n-\n     }\n \n     /**\n      * #BlockFieldMatrix(int, int, FieldElement[][], boolean)}\n      * constructor.\n      * </p>\n-     * @param <T> the type of the field elements\n-     * @param field field to which the elements belong\n-     * @param rows  the number of rows in the new matrix\n-     * @param columns  the number of columns in the new matrix\n-     * @return a new data array in blocks layout\n+     * @param <T> Type of the field elements.\n+     * @param field Field to which the elements belong.\n+     * @param rows Number of rows in the new matrix.\n+     * @param columns Number of columns in the new matrix.\n+     * @return a new data array in blocks layout.\n      * @see #toBlocksLayout(FieldElement[][])\n      * @see #BlockFieldMatrix(int, int, FieldElement[][], boolean)\n      */\n     public static <T extends FieldElement<T>> T[][] createBlocksLayout(final Field<T> field,\n                                                                        final int rows, final int columns) {\n-\n         final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n         final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n \n         }\n \n         return blocks;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension)\n-        throws IllegalArgumentException {\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> createMatrix(final int rowDimension, final int columnDimension) {\n         return new BlockFieldMatrix<T>(getField(), rowDimension, columnDimension);\n     }\n \n         }\n \n         return copied;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public FieldMatrix<T> add(final FieldMatrix<T> m)\n-        throws IllegalArgumentException {\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> add(final FieldMatrix<T> m) {\n         try {\n             return add((BlockFieldMatrix<T>) m);\n         } catch (ClassCastException cce) {\n             }\n \n             return out;\n-\n         }\n     }\n \n      * @return     this + m\n      * @throws  IllegalArgumentException if m is not the same size as this\n      */\n-    public BlockFieldMatrix<T> add(final BlockFieldMatrix<T> m)\n-        throws IllegalArgumentException {\n+    public BlockFieldMatrix<T> add(final BlockFieldMatrix<T> m) {\n \n         // safety check\n         checkAdditionCompatible(m);\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n             }\n \n             return out;\n-\n         }\n     }\n \n      * @return     this - m\n      * @throws  IllegalArgumentException if m is not the same size as this\n      */\n-    public BlockFieldMatrix<T> subtract(final BlockFieldMatrix<T> m)\n-        throws IllegalArgumentException {\n-\n+    public BlockFieldMatrix<T> subtract(final BlockFieldMatrix<T> m) {\n         // safety check\n         checkSubtractionCompatible(m);\n \n         }\n \n         return out;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public FieldMatrix<T> scalarAdd(final T d)\n-        throws IllegalArgumentException {\n-\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> scalarAdd(final T d) {\n         final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns);\n \n         // perform subtraction block-wise, to ensure good cache behavior\n         }\n \n         return out;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public FieldMatrix<T> scalarMultiply(final T d)\n-        throws IllegalArgumentException {\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> scalarMultiply(final T d) {\n \n         final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, columns);\n \n         }\n \n         return out;\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public FieldMatrix<T> multiply(final FieldMatrix<T> m)\n-        throws IllegalArgumentException {\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> multiply(final FieldMatrix<T> m) {\n         try {\n             return multiply((BlockFieldMatrix<T>) m);\n         } catch (ClassCastException cce) {\n             }\n \n             return out;\n-\n         }\n     }\n \n      * @throws     IllegalArgumentException\n      *             if columnDimension(this) != rowDimension(m)\n      */\n-    public BlockFieldMatrix<T> multiply(BlockFieldMatrix<T> m) throws IllegalArgumentException {\n+    public BlockFieldMatrix<T> multiply(BlockFieldMatrix<T> m) {\n \n         // safety check\n         checkMultiplicationCompatible(m);\n \n                 // go to next block\n                 ++blockIndex;\n-\n             }\n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n         }\n \n         return data;\n-\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public FieldMatrix<T> getSubMatrix(final int startRow, final int endRow,\n-                                   final int startColumn, final int endColumn)\n-        throws MatrixIndexException {\n-\n+                                       final int startColumn, final int endColumn) {\n         // safety checks\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n \n                                       outBlock, jWidth, 0, 0);\n                     }\n                }\n-\n                 ++qBlock;\n             }\n-\n             ++pBlock;\n-\n         }\n \n         return out;\n-\n     }\n \n     /**\n \n     /** {@inheritDoc} */\n     @Override\n-    public void setSubMatrix(final T[][] subMatrix, final int row, final int column)\n-        throws MatrixIndexException {\n-\n+    public void setSubMatrix(final T[][] subMatrix, final int row, final int column) {\n         // safety checks\n         final int refLength = subMatrix[0].length;\n         if (refLength == 0) {\n \n     /** {@inheritDoc} */\n     @Override\n-    public FieldMatrix<T> getRowMatrix(final int row)\n-        throws MatrixIndexException {\n-\n+    public FieldMatrix<T> getRowMatrix(final int row) {\n         checkRowIndex(row);\n         final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), 1, columns);\n \n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n      * @param row the row to be set\n      * @param matrix row matrix (must have one row and the same number of columns\n      * as the instance)\n-     * @throws MatrixIndexException if the specified row index is invalid\n-     * @throws MatrixDimensionMismatchException if the matrix dimensions do not match one\n-     * instance row\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if the\n+     * specified row index is invalid.\n+     * @throws MatrixDimensionMismatchException if the matrix dimensions do\n+     * not match one instance row.\n      */\n     public void setRowMatrix(final int row, final BlockFieldMatrix<T> matrix) {\n         checkRowIndex(row);\n                 mIndex += jWidth;\n            }\n         }\n-\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public FieldMatrix<T> getColumnMatrix(final int column)\n-        throws MatrixIndexException {\n-\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public FieldMatrix<T> getColumnMatrix(final int column) {\n         checkColumnIndex(column);\n         final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), rows, 1);\n \n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n     }\n \n     /**\n-     * Sets the entries in column number <code>column</code>\n+     * Sets the entries in column number {@code column}\n      * as a column matrix.  Column indices start at 0.\n      *\n-     * @param column the column to be set\n-     * @param matrix column matrix (must have one column and the same number of rows\n-     * as the instance)\n-     * @throws MatrixIndexException if the specified column index is invalid\n-     * @throws MatrixDimensionMismatchException if the matrix dimensions do not match one\n-     * instance column\n+     * @param column Column to be set.\n+     * @param matrix Column matrix (must have one column and the same number of rows\n+     * as the instance).\n+     * @throws org.apache.commons.math.exception.OutOfRangeException if\n+     * the specified column index is invalid.\n+     * @throws MatrixDimensionMismatchException if the matrix dimensions do\n+     * not match one instance column.\n      */\n     void setColumnMatrix(final int column, final BlockFieldMatrix<T> matrix) {\n         checkColumnIndex(column);\n \n     /** {@inheritDoc} */\n     @Override\n-    public FieldVector<T> getRowVector(final int row)\n-        throws MatrixIndexException {\n-\n+    public FieldVector<T> getRowVector(final int row) {\n         checkRowIndex(row);\n         final T[] outData = buildArray(getField(), columns);\n \n         }\n \n         return new ArrayFieldVector<T>(outData, false);\n-\n     }\n \n     /** {@inheritDoc} */\n \n     /** {@inheritDoc} */\n     @Override\n-    public FieldVector<T> getColumnVector(final int column)\n-        throws MatrixIndexException {\n-\n+    public FieldVector<T> getColumnVector(final int column) {\n         checkColumnIndex(column);\n         final T[] outData = buildArray(getField(), rows);\n \n         }\n \n         return new ArrayFieldVector<T>(outData, false);\n-\n     }\n \n     /** {@inheritDoc} */\n \n     /** {@inheritDoc} */\n     @Override\n-    public T[] getRow(final int row)\n-        throws MatrixIndexException {\n-\n+    public T[] getRow(final int row) {\n         checkRowIndex(row);\n         final T[] out = buildArray(getField(), columns);\n \n         }\n \n         return out;\n-\n     }\n \n     /** {@inheritDoc} */\n \n     /** {@inheritDoc} */\n     @Override\n-    public T[] getColumn(final int column)\n-        throws MatrixIndexException {\n-\n+    public T[] getColumn(final int column) {\n         checkColumnIndex(column);\n         final T[] out = buildArray(getField(), rows);\n \n \n     /** {@inheritDoc} */\n     @Override\n-    public T getEntry(final int row, final int column)\n-        throws MatrixIndexException {\n-        try {\n-            final int iBlock = row    / BLOCK_SIZE;\n-            final int jBlock = column / BLOCK_SIZE;\n-            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n-                               (column - jBlock * BLOCK_SIZE);\n-            return blocks[iBlock * blockColumns + jBlock][k];\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\n-                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n-                    row, column, getRowDimension(), getColumnDimension());\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void setEntry(final int row, final int column, final T value)\n-        throws MatrixIndexException {\n-        try {\n-            final int iBlock = row    / BLOCK_SIZE;\n-            final int jBlock = column / BLOCK_SIZE;\n-            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n-                               (column - jBlock * BLOCK_SIZE);\n-            blocks[iBlock * blockColumns + jBlock][k] = value;\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\n-                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n-                    row, column, getRowDimension(), getColumnDimension());\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void addToEntry(final int row, final int column, final T increment)\n-        throws MatrixIndexException {\n-        try {\n-            final int iBlock = row    / BLOCK_SIZE;\n-            final int jBlock = column / BLOCK_SIZE;\n-            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n-                               (column - jBlock * BLOCK_SIZE);\n-            final T[] blockIJ = blocks[iBlock * blockColumns + jBlock];\n-            blockIJ[k] = blockIJ[k].add(increment);\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\n-                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n-                    row, column, getRowDimension(), getColumnDimension());\n-        }\n-    }\n-\n-    /** {@inheritDoc} */\n-    @Override\n-    public void multiplyEntry(final int row, final int column, final T factor)\n-        throws MatrixIndexException {\n-        try {\n-            final int iBlock = row    / BLOCK_SIZE;\n-            final int jBlock = column / BLOCK_SIZE;\n-            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n-                               (column - jBlock * BLOCK_SIZE);\n-            final T[] blockIJ = blocks[iBlock * blockColumns + jBlock];\n-            blockIJ[k] = blockIJ[k].multiply(factor);\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            throw new MatrixIndexException(\n-                    LocalizedFormats.NO_SUCH_MATRIX_ENTRY,\n-                    row, column, getRowDimension(), getColumnDimension());\n-        }\n+    public T getEntry(final int row, final int column) {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+\n+        final int iBlock = row    / BLOCK_SIZE;\n+        final int jBlock = column / BLOCK_SIZE;\n+        final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+            (column - jBlock * BLOCK_SIZE);\n+\n+        return blocks[iBlock * blockColumns + jBlock][k];\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setEntry(final int row, final int column, final T value) {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+\n+        final int iBlock = row    / BLOCK_SIZE;\n+        final int jBlock = column / BLOCK_SIZE;\n+        final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+            (column - jBlock * BLOCK_SIZE);\n+\n+        blocks[iBlock * blockColumns + jBlock][k] = value;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void addToEntry(final int row, final int column, final T increment) {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+\n+        final int iBlock = row    / BLOCK_SIZE;\n+        final int jBlock = column / BLOCK_SIZE;\n+        final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+            (column - jBlock * BLOCK_SIZE);\n+        final T[] blockIJ = blocks[iBlock * blockColumns + jBlock];\n+\n+        blockIJ[k] = blockIJ[k].add(increment);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void multiplyEntry(final int row, final int column, final T factor) {\n+        checkRowIndex(row);\n+        checkColumnIndex(column);\n+\n+        final int iBlock = row    / BLOCK_SIZE;\n+        final int jBlock = column / BLOCK_SIZE;\n+        final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n+            (column - jBlock * BLOCK_SIZE);\n+        final T[] blockIJ = blocks[iBlock * blockColumns + jBlock];\n+\n+        blockIJ[k] = blockIJ[k].multiply(factor);\n     }\n \n     /** {@inheritDoc} */\n     @Override\n     public FieldMatrix<T> transpose() {\n-\n         final int nRows = getRowDimension();\n         final int nCols = getColumnDimension();\n         final BlockFieldMatrix<T> out = new BlockFieldMatrix<T>(getField(), nCols, nRows);\n     public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n     public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                  final int startRow, final int endRow,\n                                  final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n     public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor,\n                                        final int startRow, final int endRow,\n                                        final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n     public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor,\n                                        final int startRow, final int endRow,\n                                        final int startColumn, final int endColumn)\n-        throws MatrixIndexException, MatrixVisitorException {\n+        throws MatrixVisitorException {\n         checkSubMatrixIndex(startRow, endRow, startColumn, endColumn);\n         visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);\n         for (int iBlock = startRow / BLOCK_SIZE; iBlock < 1 + endRow / BLOCK_SIZE; ++iBlock) {\n--- a/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/BlockFieldMatrixTest.java\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.fraction.FractionField;\n import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n+import org.apache.commons.math.exception.NoDataException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NullArgumentException;\n \n /**\n  * Test cases for the {@link BlockFieldMatrix} class.\n         TestUtils.assertEquals(m.getColumn(2), testDataCol3);\n         try {\n             m.getRow(10);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // ignored\n         }\n         try {\n             m.getColumn(-1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // ignored\n         }\n     }\n         assertEquals(m.getEntry(0,1),new Fraction(2));\n         try {\n             m.getEntry(10, 4);\n-            fail (\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail (\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n             if (reference != null) {\n                 assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);\n             } else {\n-                fail(\"Expecting MatrixIndexException\");\n-            }\n-        } catch (MatrixIndexException e) {\n+                fail(\"Expecting OutOfRangeException or NotStrictlyPositiveException\"\n+                     + \" or NumberIsTooSmallException or NoDataException\");\n+            }\n+        } catch (OutOfRangeException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NotStrictlyPositiveException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NumberIsTooSmallException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NoDataException e) {\n             if (reference != null) {\n                 throw e;\n             }\n             if (reference != null) {\n                 assertEquals(new BlockFieldMatrix<Fraction>(reference), sub);\n             } else {\n-                fail(\"Expecting MatrixIndexException\");\n-            }\n-        } catch (MatrixIndexException e) {\n+                fail(\"Expecting OutOfRangeException\");\n+            }\n+        } catch (OutOfRangeException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NotStrictlyPositiveException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NumberIsTooSmallException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NoDataException e) {\n             if (reference != null) {\n                 throw e;\n             }\n         checkCopy(m, null, -1, 1, 2, 2);\n         checkCopy(m, null,  1, 0, 2, 2);\n         checkCopy(m, null,  1, 0, 2, 4);\n-        checkCopy(m, null, new int[] {},    new int[] { 0 });\n+        checkCopy(m, null, new int[] {}, new int[] { 0 });\n         checkCopy(m, null, new int[] { 0 }, new int[] { 4 });\n     }\n \n             if (reference != null) {\n                 assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n             } else {\n-                fail(\"Expecting MatrixIndexException\");\n-            }\n-        } catch (MatrixIndexException e) {\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n+            }\n+        } catch (OutOfRangeException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NumberIsTooSmallException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NoDataException e) {\n             if (reference != null) {\n                 throw e;\n             }\n             if (reference != null) {\n                 assertEquals(new BlockFieldMatrix<Fraction>(reference), new BlockFieldMatrix<Fraction>(sub));\n             } else {\n-                fail(\"Expecting MatrixIndexException\");\n-            }\n-        } catch (MatrixIndexException e) {\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n+            }\n+        } catch (OutOfRangeException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NumberIsTooSmallException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NoDataException e) {\n             if (reference != null) {\n                 throw e;\n             }\n         assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n         try {\n             m.getRowMatrix(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowMatrix(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(mRow3, m.getRowMatrix(0));\n         try {\n             m.setRowMatrix(-1, mRow3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         assertEquals(mColumn3, m.getColumnMatrix(3));\n         try {\n             m.getColumnMatrix(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnMatrix(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(mColumn3, m.getColumnMatrix(1));\n         try {\n             m.setColumnMatrix(-1, mColumn3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         assertEquals(mRow3, m.getRowVector(3));\n         try {\n             m.getRowVector(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowVector(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(mRow3, m.getRowVector(0));\n         try {\n             m.setRowVector(-1, mRow3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         assertEquals(mColumn3, m.getColumnVector(3));\n         try {\n             m.getColumnVector(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnVector(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(mColumn3, m.getColumnVector(1));\n         try {\n             m.setColumnVector(-1, mColumn3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         checkArrays(subRow3[0], m.getRow(3));\n         try {\n             m.getRow(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRow(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         checkArrays(subRow3[0], m.getRow(0));\n         try {\n             m.setRow(-1, subRow3[0]);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         checkArrays(mColumn3, m.getColumn(3));\n         try {\n             m.getColumn(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumn(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         checkArrays(mColumn3, m.getColumn(1));\n         try {\n             m.setColumn(-1, mColumn3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         // dimension overflow\n         try {\n             m.setSubMatrix(testData,1,1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException e) {\n             // expected\n         }\n         // dimension underflow\n         try {\n             m.setSubMatrix(testData,-1,1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException e) {\n             // expected\n         }\n         try {\n             m.setSubMatrix(testData,1,-1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException e) {\n             // expected\n         }\n \n--- a/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/FieldMatrixImplTest.java\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.fraction.FractionField;\n import org.apache.commons.math.exception.MatrixDimensionMismatchException;\n+import org.apache.commons.math.exception.NoDataException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math.exception.NullArgumentException;\n \n /**\n  * Test cases for the {@link Array2DRowFieldMatrix} class.\n         TestUtils.assertEquals(m.getColumn(2), testDataCol3);\n         try {\n             m.getRow(10);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // ignored\n         }\n         try {\n             m.getColumn(-1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // ignored\n         }\n     }\n \n     public void testGetEntry() {\n         FieldMatrix<Fraction> m = new Array2DRowFieldMatrix<Fraction>(testData);\n-        assertEquals(\"get entry\",m.getEntry(0,1),new Fraction(2));\n+        assertEquals(\"get entry\", m.getEntry(0,1), new Fraction(2));\n         try {\n             m.getEntry(10, 4);\n-            fail (\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail (\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n             if (reference != null) {\n                 assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);\n             } else {\n-                fail(\"Expecting MatrixIndexException\");\n-            }\n-        } catch (MatrixIndexException e) {\n+                fail(\"Expecting OutOfRangeException or NotStrictlyPositiveException\"\n+                     + \" or NumberIsTooSmallException or NoDataException\");\n+            }\n+        } catch (OutOfRangeException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NotStrictlyPositiveException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NumberIsTooSmallException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NoDataException e) {\n             if (reference != null) {\n                 throw e;\n             }\n             if (reference != null) {\n                 assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), sub);\n             } else {\n-                fail(\"Expecting MatrixIndexException\");\n-            }\n-        } catch (MatrixIndexException e) {\n+                fail(\"Expecting OutOfRangeException or NotStrictlyPositiveException\"\n+                     + \" or NumberIsTooSmallException or NoDataException\");\n+            }\n+        } catch (OutOfRangeException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NotStrictlyPositiveException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NumberIsTooSmallException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NoDataException e) {\n             if (reference != null) {\n                 throw e;\n             }\n             if (reference != null) {\n                 assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));\n             } else {\n-                fail(\"Expecting MatrixIndexException\");\n-            }\n-        } catch (MatrixIndexException e) {\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n+            }\n+        } catch (OutOfRangeException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NumberIsTooSmallException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NoDataException e) {\n             if (reference != null) {\n                 throw e;\n             }\n             if (reference != null) {\n                 assertEquals(new Array2DRowFieldMatrix<Fraction>(reference), new Array2DRowFieldMatrix<Fraction>(sub));\n             } else {\n-                fail(\"Expecting MatrixIndexException\");\n-            }\n-        } catch (MatrixIndexException e) {\n+                fail(\"Expecting OutOfRangeException or NumberIsTooSmallException or NoDataException\");\n+            }\n+        } catch (OutOfRangeException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NumberIsTooSmallException e) {\n+            if (reference != null) {\n+                throw e;\n+            }\n+        } catch (NoDataException e) {\n             if (reference != null) {\n                 throw e;\n             }\n                 m.getRowMatrix(3));\n         try {\n             m.getRowMatrix(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowMatrix(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(mRow3, m.getRowMatrix(0));\n         try {\n             m.setRowMatrix(-1, mRow3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n                 m.getColumnMatrix(3));\n         try {\n             m.getColumnMatrix(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnMatrix(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(mColumn3, m.getColumnMatrix(1));\n         try {\n             m.setColumnMatrix(-1, mColumn3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n         try {\n             m.getRowVector(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowVector(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(mRow3, m.getRowVector(0));\n         try {\n             m.setRowVector(-1, mRow3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n         try {\n             m.getColumnVector(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnVector(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(mColumn3, m.getColumnVector(1));\n         try {\n             m.setColumnVector(-1, mColumn3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         checkArrays(subRow3[0], m.getRow(3));\n         try {\n             m.getRow(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRow(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         checkArrays(subRow3[0], m.getRow(0));\n         try {\n             m.setRow(-1, subRow3[0]);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         checkArrays(mColumn3, m.getColumn(3));\n         try {\n             m.getColumn(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumn(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         checkArrays(mColumn3, m.getColumn(1));\n         try {\n             m.setColumn(-1, mColumn3);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n         // dimension overflow\n         try {\n             m.setSubMatrix(testData,1,1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException e) {\n             // expected\n         }\n         // dimension underflow\n         try {\n             m.setSubMatrix(testData,-1,1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException e) {\n             // expected\n         }\n         try {\n             m.setSubMatrix(testData,1,-1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException e) {\n             // expected\n         }\n \n         // null\n         try {\n-            m.setSubMatrix(null,1,1);\n-            fail(\"expecting NullPointerException\");\n-        } catch (NullPointerException e) {\n+            m.setSubMatrix(null, 1, 1);\n+            fail(\"expecting NullArgumentException\");\n+        } catch (NullArgumentException e) {\n             // expected\n         }\n         Array2DRowFieldMatrix<Fraction> m2 = new Array2DRowFieldMatrix<Fraction>(FractionField.getInstance());\n--- a/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SparseFieldMatrixTest.java\n import org.apache.commons.math.fraction.Fraction;\n import org.apache.commons.math.fraction.FractionConversionException;\n import org.apache.commons.math.fraction.FractionField;\n+import org.apache.commons.math.exception.NoDataException;\n+import org.apache.commons.math.exception.OutOfRangeException;\n+import org.apache.commons.math.exception.NumberIsTooSmallException;\n+import org.apache.commons.math.exception.NullArgumentException;\n \n /**\n  * Test cases for the {@link SparseFieldMatrix} class.\n         assertClose(\"get col\", m.getColumn(2), testDataCol3, entryTolerance);\n         try {\n             m.getRow(10);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // ignored\n         }\n         try {\n             m.getColumn(-1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // ignored\n         }\n     }\n         assertEquals(\"get entry\", m.getEntry(0, 1).doubleValue(), 2d, entryTolerance);\n         try {\n             m.getEntry(10, 4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n \n         try {\n             m.getSubMatrix(1, 0, 2, 4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting NumberIsTooSmallException\");\n+        } catch (NumberIsTooSmallException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(-1, 1, 2, 2);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(1, 0, 2, 2);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting NumberIsTooSmallException\");\n+        } catch (NumberIsTooSmallException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(1, 0, 2, 4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting NumberIsTooSmallException\");\n+        } catch (NumberIsTooSmallException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(new int[] {}, new int[] { 0 });\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting NoDataException\");\n+        } catch (NoDataException ex) {\n             // expected\n         }\n         try {\n             m.getSubMatrix(new int[] { 0 }, new int[] { 4 });\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(\"Row3\", mRow3, m.getRowMatrix(3));\n         try {\n             m.getRowMatrix(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowMatrix(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(\"Column3\", mColumn3, m.getColumnMatrix(3));\n         try {\n             m.getColumnMatrix(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnMatrix(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(\"Row3\", mRow3, m.getRowVector(3));\n         try {\n             m.getRowVector(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getRowVector(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         assertEquals(\"Column3\", mColumn3, m.getColumnVector(3));\n         try {\n             m.getColumnVector(-1);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n         try {\n             m.getColumnVector(4);\n-            fail(\"Expecting MatrixIndexException\");\n-        } catch (MatrixIndexException ex) {\n+            fail(\"Expecting OutOfRangeException\");\n+        } catch (OutOfRangeException ex) {\n             // expected\n         }\n     }\n         // dimension overflow\n         try {\n             m.setSubMatrix(testData, 1, 1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException e) {\n             // expected\n         }\n         // dimension underflow\n         try {\n             m.setSubMatrix(testData, -1, 1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException e) {\n             // expected\n         }\n         try {\n             m.setSubMatrix(testData, 1, -1);\n-            fail(\"expecting MatrixIndexException\");\n-        } catch (MatrixIndexException e) {\n+            fail(\"expecting OutOfRangeException\");\n+        } catch (OutOfRangeException e) {\n             // expected\n         }\n \n         // null\n         try {\n             m.setSubMatrix(null, 1, 1);\n-            fail(\"expecting NullPointerException\");\n-        } catch (NullPointerException e) {\n+            fail(\"expecting NullArgumentException\");\n+        } catch (NullArgumentException e) {\n             // expected\n         }\n         try {", "timestamp": 1286371803, "metainfo": ""}