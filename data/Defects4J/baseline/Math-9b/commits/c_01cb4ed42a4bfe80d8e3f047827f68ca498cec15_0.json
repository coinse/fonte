{"sha": "01cb4ed42a4bfe80d8e3f047827f68ca498cec15", "log": "Added SemiVariance. JIRA: MATH-323. Reported and patched by Larry Diamond.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n      \"valeur de quantile {0} hors bornes, doit \\u00eatre dans l''intervalle ]0, 100]\" },\n \n    // org.apache.commons.math.stat.descriptive.moment.Variance\n+   // org.apache.commons.math.stat.descriptive.moment.SemiVariance\n    // org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic\n    // org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic\n    { \"input values array is null\",\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/SemiVariance.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic;\n+\n+/**\n+ * <p>Computes the semivariance of a set of values with respect to a given cutoff value.\n+ * We define the <i>downside semivariance</i> of a set of values <code>x</code>\n+ * against the <i>cutoff value</i> <code>cutoff</code> to be <br/>\n+ * <code>&Sigma; (x[i] - target)<sup>2</sup> / df</code> <br/>\n+ * where the sum is taken over all <code>i</code> such that <code>x[i] < cutoff</code>\n+ * and <code>df</code> is the length of <code>x</code> (non-bias-corrected) or\n+ * one less than this number (bias corrected).  The <i>upside semivariance</i>\n+ * is defined similarly, with the sum taken over values of <code>x</code> that\n+ * exceed the cutoff value.</p>\n+ *\n+ * <p>The cutoff value defaults to the mean, bias correction defaults to <code>true</code>\n+ * and the \"variance direction\" (upside or downside) defaults to downside.  The variance direction\n+ * and bias correction may be set using property setters or their values can provided as\n+ * parameters to {@link #evaluate(double[], double, Direction, boolean, int, int)}.</p>\n+ *\n+ * <p>If the input array is null, <code>evaluate</code> methods throw\n+ * <code>IllegalArgumentException.</code>  If the array has length 1, <code>0</code>\n+ * is returned, regardless of the value of the <code>cutoff.</code>\n+ *\n+ * <p><strong>Note that this class is not intended to be threadsafe.</strong> If\n+ * multiple threads access an instance of this class concurrently, and one or\n+ * more of these threads invoke property setters, external synchronization must\n+ * be provided to ensure correct results.</p>\n+ *\n+ * @version $Revision$ $Date$\n+ * @since 2.1\n+ */\n+\n+public class SemiVariance extends AbstractUnivariateStatistic implements Serializable {\n+\n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = -2653430366886024994L;\n+\n+    /**\n+     * Determines whether or not bias correction is applied when computing the\n+     * value of the statisic.  True means that bias is corrected.\n+     */\n+    private boolean biasCorrected = true;\n+\n+    /**\n+     * Determines whether to calculate downside or upside SemiVariance.\n+     */\n+    private Direction varianceDirection = Direction.DOWNSIDE;\n+\n+    /**\n+     * The UPSIDE Direction is used to specify that the observations above the\n+     * cutoff point will be used to calculate SemiVariance.\n+     */\n+    public static final Direction UPSIDE_VARIANCE = Direction.UPSIDE;\n+\n+    /**\n+     * The DOWNSIDE Direction is used to specify that the observations below\n+     * the cutoff point will be used to calculate SemiVariance\n+     */\n+    public static final Direction DOWNSIDE_VARIANCE = Direction.DOWNSIDE;\n+\n+    /**\n+     * Constructs a SemiVariance with default (true) <code>biasCorrected</code>\n+     * property and default (Downside) <code>varianceDirection</code> property.\n+     */\n+    public SemiVariance() {\n+    }\n+\n+    /**\n+     * Constructs a SemiVariance with the specified <code>biasCorrected</code>\n+     * property and default (Downside) <code>varianceDirection</code> property.\n+     *\n+     * @param biasCorrected  setting for bias correction - true means\n+     * bias will be corrected and is equivalent to using the argumentless\n+     * constructor\n+     */\n+    public SemiVariance(final boolean biasCorrected) {\n+        this.biasCorrected = biasCorrected;\n+    }\n+\n+\n+    /**\n+     * Constructs a SemiVariance with the specified <code>Direction</code> property\n+     * and default (true) <code>biasCorrected</code> property\n+     *\n+     * @param direction  setting for the direction of the SemiVariance\n+     * to calculate\n+     */\n+    public SemiVariance(final Direction direction) {\n+        this.varianceDirection = direction;\n+    }\n+\n+\n+    /**\n+     * Constructs a SemiVariance with the specified <code>isBiasCorrected</code>\n+     * property and the specified <code>Direction</code> property.\n+     *\n+     * @param corrected  setting for bias correction - true means\n+     * bias will be corrected and is equivalent to using the argumentless\n+     * constructor\n+     *\n+     * @param direction  setting for the direction of the SemiVariance\n+     * to calculate\n+     */\n+    public SemiVariance(final boolean corrected, final Direction direction) {\n+        this.biasCorrected = corrected;\n+        this.varianceDirection = direction;\n+    }\n+\n+\n+    /**\n+     * Copy constructor, creates a new {@code SemiVariance} identical\n+     * to the {@code original}\n+     *\n+     * @param original the {@code SemiVariance} instance to copy\n+     */\n+    public SemiVariance(final SemiVariance original) {\n+        copy(original, this);\n+    }\n+\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public SemiVariance copy() {\n+        SemiVariance result = new SemiVariance();\n+        copy(this, result);\n+        return result;\n+    }\n+\n+\n+    /**\n+     * Copies source to dest.\n+     * <p>Neither source nor dest can be null.</p>\n+     *\n+     * @param source SemiVariance to copy\n+     * @param dest SemiVariance to copy to\n+     * @throws NullPointerException if either source or dest is null\n+     */\n+    public static void copy(final SemiVariance source, SemiVariance dest) {\n+        dest.biasCorrected = source.biasCorrected;\n+        dest.varianceDirection = source.varianceDirection;\n+    }\n+\n+\n+    /**\n+     * This method calculates {@link SemiVariance} for the entire array against the mean, using\n+     * instance properties varianceDirection and biasCorrection.\n+     *\n+     * @param values the input array\n+     * @return the SemiVariance\n+     * @throws IllegalArgumentException if values is null\n+     *\n+     */\n+    @Override\n+    public double evaluate(final double[] values) {\n+        if (values == null) {\n+            throw MathRuntimeException.createIllegalArgumentException(\"input values array is null\");\n+         }\n+        return evaluate(values, 0, values.length);\n+    }\n+\n+\n+    /**\n+      * <p>Returns the {@link SemiVariance} of the designated values against the mean, using\n+      * instance properties varianceDirection and biasCorrection.</p>\n+      *\n+      * <p>Returns <code>NaN</code> if the array is empty and throws\n+      * <code>IllegalArgumentException</code> if the array is null.</p>\n+      *\n+      * @param values the input array\n+      * @param start index of the first array element to include\n+      * @param length the number of elements to include\n+      * @return the SemiVariance\n+      * @throws IllegalArgumentException if the parameters are not valid\n+      *\n+      */\n+      @Override\n+      public double evaluate(final double[] values, final int start, final int length) {\n+        double m = (new Mean()).evaluate(values, start, length);\n+        return evaluate(values, m, varianceDirection, biasCorrected, 0, values.length);\n+      }\n+\n+\n+      /**\n+       * This method calculates {@link SemiVariance} for the entire array against the mean, using\n+       * the current value of the biasCorrection instance property.\n+       *\n+       * @param values the input array\n+       * @param direction the {@link Direction} of the semivariance\n+       * @return the SemiVariance\n+       * @throws IllegalArgumentException if values is null\n+       *\n+       */\n+      public double evaluate(final double[] values, Direction direction) {\n+          double m = (new Mean()).evaluate(values);\n+          return evaluate (values, m, direction, biasCorrected, 0, values.length);\n+      }\n+\n+      /**\n+       * <p>Returns the {@link SemiVariance} of the designated values against the cutoff, using\n+       * instance properties variancDirection and biasCorrection.</p>\n+       *\n+       * <p>Returns <code>NaN</code> if the array is empty and throws\n+       * <code>IllegalArgumentException</code> if the array is null.</p>\n+       *\n+       * @param values the input array\n+       * @param cutoff the reference point\n+       * @return the SemiVariance\n+       * @throws IllegalArgumentException if values is null\n+       */\n+      public double evaluate(final double[] values, final double cutoff) {\n+          return evaluate(values, cutoff, varianceDirection, biasCorrected, 0, values.length);\n+      }\n+\n+      /**\n+       * <p>Returns the {@link SemiVariance} of the designated values against the cutoff in the\n+       * given direction, using the current value of the biasCorrection instance property.</p>\n+       *\n+       * <p>Returns <code>NaN</code> if the array is empty and throws\n+       * <code>IllegalArgumentException</code> if the array is null.</p>\n+       *\n+       * @param values the input array\n+       * @param cutoff the reference point\n+       * @param direction the {@link Direction} of the semivariance\n+       * @return the SemiVariance\n+       * @throws IllegalArgumentException if values is null\n+       */\n+      public double evaluate(final double[] values, final double cutoff, final Direction direction) {\n+          return evaluate(values, cutoff, direction, biasCorrected, 0, values.length);\n+      }\n+\n+\n+     /**\n+      * <p>Returns the {@link SemiVariance} of the designated values against the cutoff\n+      * in the given direction with the provided bias correction.</p>\n+      *\n+      * <p>Returns <code>NaN</code> if the array is empty and throws\n+      * <code>IllegalArgumentException</code> if the array is null.</p>\n+      *\n+      * @param values the input array\n+      * @param cutoff the reference point\n+      * @param direction the {@link Direction} of the semivariance\n+      * @param corrected the BiasCorrection flag\n+      * @param start index of the first array element to include\n+      * @param length the number of elements to include\n+      * @return the SemiVariance\n+      * @throws IllegalArgumentException if the parameters are not valid\n+      *\n+      */\n+    public double evaluate (final double[] values, final double cutoff, final Direction direction,\n+            final boolean corrected, final int start, final int length) {\n+\n+        test(values, start, length);\n+        if (values.length == 0) {\n+            return Double.NaN;\n+        } else {\n+            if (values.length == 1) {\n+                return 0.0;\n+            } else {\n+                final boolean booleanDirection = direction.getDirection();\n+\n+                double dev = 0.0;\n+                double sumsq = 0.0;\n+                for (int i = start; i < length; i++) {\n+                    if ((values[i] > cutoff) == booleanDirection) {\n+                       dev = values[i] - cutoff;\n+                       sumsq += dev * dev;\n+                    }\n+                }\n+\n+                if (corrected) {\n+                    return sumsq / (length - 1.0);\n+                } else {\n+                    return sumsq / length;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Returns true iff biasCorrected property is set to true.\n+     *\n+     * @return the value of biasCorrected.\n+     */\n+    public boolean isBiasCorrected() {\n+        return biasCorrected;\n+    }\n+\n+    /**\n+     * Sets the biasCorrected property.\n+     *\n+     * @param biasCorrected new biasCorrected property value\n+     */\n+    public void setBiasCorrected(boolean biasCorrected) {\n+        this.biasCorrected = biasCorrected;\n+    }\n+\n+    /**\n+     * Returns the varianceDirection property.\n+     *\n+     * @return the varianceDirection\n+     */\n+    public Direction getVarianceDirection () {\n+        return varianceDirection;\n+    }\n+\n+    /**\n+     * Sets the variance direction\n+     *\n+     * @param varianceDirection the direction of the semivariance\n+     */\n+    public void setVarianceDirection(Direction varianceDirection) {\n+        this.varianceDirection = varianceDirection;\n+    }\n+\n+    /**\n+     * The direction of the semivariance - either upside or downside. The direction\n+     * is represented by boolean, with true corresponding to UPSIDE semivariance.\n+     */\n+    public enum Direction {\n+        /**\n+         * The UPSIDE Direction is used to specify that the observations above the\n+         * cutoff point will be used to calculate SemiVariance\n+         */\n+        UPSIDE (true),\n+\n+        /**\n+         * The DOWNSIDE Direction is used to specify that the observations below\n+         * the cutoff point will be used to calculate SemiVariance\n+         */\n+        DOWNSIDE (false);\n+\n+        /**\n+         *   boolean value  UPSIDE <-> true\n+         */\n+        private boolean direction;\n+\n+        /**\n+         * Create a Direction with the given value.\n+         *\n+         * @param b boolean value representing the Direction. True corresponds to UPSIDE.\n+         */\n+        Direction (boolean b) {\n+            direction = b;\n+        }\n+\n+        /**\n+         * Returns the value of this Direction. True corresponds to UPSIDE.\n+         *\n+         * @return true if direction is UPSIDE; false otherwise\n+         */\n+        boolean getDirection () {\n+            return direction;\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/stat/descriptive/moment/SemiVarianceTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.stat.StatUtils;\n+\n+import junit.framework.TestCase;\n+\n+public class SemiVarianceTest extends TestCase {\n+\n+    public void testInsufficientData() {\n+        double[] nothing = null;\n+        SemiVariance sv = new SemiVariance();\n+        try {\n+            sv.evaluate(nothing);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException iae) {\n+        }\n+\n+        try {\n+            sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);\n+            sv.evaluate(nothing);\n+            fail(\"null is not a valid data array.\");\n+        } catch (IllegalArgumentException iae) {\n+        }\n+        nothing = new double[] {};\n+        assertTrue(Double.isNaN(sv.evaluate(nothing)));\n+    }\n+\n+    public void testSingleDown() {\n+        SemiVariance sv = new SemiVariance();\n+        double[] values = { 50.0d };\n+        double singletest = sv.evaluate(values);\n+        assertEquals(0.0d, singletest, 0);\n+    }\n+\n+    public void testSingleUp() {\n+        SemiVariance sv = new SemiVariance(SemiVariance.UPSIDE_VARIANCE);\n+        double[] values = { 50.0d };\n+        double singletest = sv.evaluate(values);\n+        assertEquals(0.0d, singletest, 0);\n+    }\n+\n+    public void testSample() {\n+        final double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };\n+        final int length = values.length;\n+        final double mean = StatUtils.mean(values); // 6.333...\n+        final SemiVariance sv = new SemiVariance();  // Default bias correction is true\n+        final double downsideSemiVariance = sv.evaluate(values); // Downside is the default\n+        assertEquals(TestUtils.sumSquareDev(new double[] {-2d, 2d, 4d, -2d, 3d, 5d}, mean) / (length - 1),\n+                downsideSemiVariance, 1E-14);\n+\n+        sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);\n+        final double upsideSemiVariance = sv.evaluate(values);\n+        assertEquals(TestUtils.sumSquareDev(new double[] {22d, 11d, 14d}, mean) / (length - 1),\n+                upsideSemiVariance, 1E-14);\n+        \n+        // Verify that upper + lower semivariance against the mean sum to variance\n+        assertEquals(StatUtils.variance(values), downsideSemiVariance + upsideSemiVariance, 10e-12);\n+    }\n+\n+    public void testPopulation() {\n+        double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };\n+        SemiVariance sv = new SemiVariance(false);\n+\n+        double singletest = sv.evaluate(values);\n+        assertEquals(19.556d, singletest, 0.01d);\n+\n+        sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);\n+        singletest = sv.evaluate(values);\n+        assertEquals(36.222d, singletest, 0.01d);\n+    }\n+\n+    public void testNonMeanCutoffs() {\n+        double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };\n+        SemiVariance sv = new SemiVariance(false); // Turn off bias correction - use df = length\n+\n+        double singletest = sv.evaluate(values, 1.0d, SemiVariance.DOWNSIDE_VARIANCE, false, 0, values.length);\n+        assertEquals(TestUtils.sumSquareDev(new double[] { -2d, -2d }, 1.0d) / values.length,\n+                singletest, 0.01d);\n+\n+        singletest = sv.evaluate(values, 3.0d, SemiVariance.UPSIDE_VARIANCE, false, 0, values.length);\n+        assertEquals(TestUtils.sumSquareDev(new double[] { 4d, 22d, 11d, 14d, 5d }, 3.0d) / values.length, singletest,\n+                0.01d);\n+    }\n+\n+    /**\n+     * Check that the lower + upper semivariance against the mean sum to the\n+     * variance.\n+     */\n+    public void testVarianceDecompMeanCutoff() {\n+        double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };\n+        double variance = StatUtils.variance(values);\n+        SemiVariance sv = new SemiVariance(true); // Bias corrected\n+        sv.setVarianceDirection(SemiVariance.DOWNSIDE_VARIANCE);\n+        final double lower = sv.evaluate(values);\n+        sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);\n+        final double upper = sv.evaluate(values);\n+        assertEquals(variance, lower + upper, 10e-12);\n+    }\n+\n+    /**\n+     * Check that upper and lower semivariances against a cutoff sum to the sum\n+     * of squared deviations of the full set of values against the cutoff\n+     * divided by df = length - 1 (assuming bias-corrected).\n+     */\n+    public void testVarianceDecompNonMeanCutoff() {\n+        double[] values = { -2.0d, 2.0d, 4.0d, -2.0d, 22.0d, 11.0d, 3.0d, 14.0d, 5.0d };\n+        double target = 0;\n+        double totalSumOfSquares = TestUtils.sumSquareDev(values, target);\n+        SemiVariance sv = new SemiVariance(true); // Bias corrected\n+        sv.setVarianceDirection(SemiVariance.DOWNSIDE_VARIANCE);\n+        double lower = sv.evaluate(values, target);\n+        sv.setVarianceDirection(SemiVariance.UPSIDE_VARIANCE);\n+        double upper = sv.evaluate(values, target);\n+        assertEquals(totalSumOfSquares / (values.length - 1), lower + upper, 10e-12);\n+    }\n+    \n+    public void testNoVariance() {\n+        final double[] values = {100d, 100d, 100d, 100d};\n+        SemiVariance sv = new SemiVariance();\n+        assertEquals(0, sv.evaluate(values), 10E-12);\n+        assertEquals(0, sv.evaluate(values, 100d), 10E-12);\n+        assertEquals(0, sv.evaluate(values, 100d, SemiVariance.UPSIDE_VARIANCE, false, 0, values.length), 10E-12); \n+    }\n+}", "timestamp": 1266253854, "metainfo": ""}