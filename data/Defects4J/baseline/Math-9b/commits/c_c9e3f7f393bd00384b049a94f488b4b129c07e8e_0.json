{"sha": "c9e3f7f393bd00384b049a94f488b4b129c07e8e", "log": "More thorough testing of FastFourierTransformer (MATH-677).  ", "commit": "\n--- a/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n+++ b/src/test/java/org/apache/commons/math/transform/FastFourierTransformerTest.java\n  */\n package org.apache.commons.math.transform;\n \n-import org.apache.commons.math.analysis.*;\n-import org.apache.commons.math.complex.*;\n+import java.util.Random;\n+\n+import org.apache.commons.math.analysis.SinFunction;\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.analysis.function.Sinc;\n+import org.apache.commons.math.complex.Complex;\n import org.apache.commons.math.util.FastMath;\n import org.junit.Assert;\n import org.junit.Test;\n  * @version $Id$\n  */\n public final class FastFourierTransformerTest {\n+    /**\n+     * The common (for repeatability) seed of all random number generators used\n+     * in this test.\n+     */\n+    private final static long SEED = 20110111L;\n \n     /**\n      * Test of transformer for the ad hoc data taken from Mathematica.\n             // expected\n         }\n     }\n+\n+    /** Naive implementation of DFT, for reference. */\n+    private static Complex[] dft(final Complex[] x, final int sgn) {\n+        final int n = x.length;\n+        final double[] cos = new double[n];\n+        final double[] sin = new double[n];\n+        final Complex[] y = new Complex[n];\n+        for (int i = 0; i < n; i++) {\n+            final double arg = 2.0 * FastMath.PI * i / n;\n+            cos[i] = FastMath.cos(arg);\n+            sin[i] = FastMath.sin(arg);\n+        }\n+        for (int i = 0; i < n; i++) {\n+            double yr = 0.0;\n+            double yi = 0.0;\n+            for (int j = 0; j < n; j++) {\n+                final int index = (i * j) % n;\n+                final double c = cos[index];\n+                final double s = sin[index];\n+                final double xr = x[j].getReal();\n+                final double xi = x[j].getImaginary();\n+                yr += c * xr - sgn * s * xi;\n+                yi += sgn * s * xr + c * xi;\n+            }\n+            y[i] = new Complex(yr, yi);\n+        }\n+        return y;\n+    }\n+    \n+    @Test\n+    public void testStandardTransformComplex() {\n+        final boolean forward = true;\n+        final boolean standard = true;\n+        doTestTransformComplex(2, 1.0E-15, forward, standard);\n+        doTestTransformComplex(4, 1.0E-14, forward, standard);\n+        doTestTransformComplex(8, 1.0E-14, forward, standard);\n+        doTestTransformComplex(16, 1.0E-13, forward, standard);\n+        doTestTransformComplex(32, 1.0E-13, forward, standard);\n+        doTestTransformComplex(64, 1.0E-13, forward, standard);\n+        doTestTransformComplex(128, 1.0E-12, forward, standard);\n+    }\n+\n+    @Test\n+    public void testUnitaryTransformComplex() {\n+        final boolean forward = true;\n+        final boolean standard = false;\n+        doTestTransformComplex(2, 1.0E-15, forward, standard);\n+        doTestTransformComplex(4, 1.0E-14, forward, standard);\n+        doTestTransformComplex(8, 1.0E-14, forward, standard);\n+        doTestTransformComplex(16, 1.0E-13, forward, standard);\n+        doTestTransformComplex(32, 1.0E-13, forward, standard);\n+        doTestTransformComplex(64, 1.0E-13, forward, standard);\n+        doTestTransformComplex(128, 1.0E-12, forward, standard);\n+    }\n+\n+    @Test\n+    public void testStandardInverseTransformComplex() {\n+        final boolean forward = false;\n+        final boolean standard = true;\n+        doTestTransformComplex(2, 1.0E-15, forward, standard);\n+        doTestTransformComplex(4, 1.0E-14, forward, standard);\n+        doTestTransformComplex(8, 1.0E-14, forward, standard);\n+        doTestTransformComplex(16, 1.0E-13, forward, standard);\n+        doTestTransformComplex(32, 1.0E-13, forward, standard);\n+        doTestTransformComplex(64, 1.0E-12, forward, standard);\n+        doTestTransformComplex(128, 1.0E-12, forward, standard);\n+    }\n+\n+    @Test\n+    public void testUnitaryInverseTransformComplex() {\n+        final boolean forward = false;\n+        final boolean standard = false;\n+        doTestTransformComplex(2, 1.0E-15, forward, standard);\n+        doTestTransformComplex(4, 1.0E-14, forward, standard);\n+        doTestTransformComplex(8, 1.0E-14, forward, standard);\n+        doTestTransformComplex(16, 1.0E-13, forward, standard);\n+        doTestTransformComplex(32, 1.0E-13, forward, standard);\n+        doTestTransformComplex(64, 1.0E-12, forward, standard);\n+        doTestTransformComplex(128, 1.0E-12, forward, standard);\n+    }\n+\n+    @Test\n+    public void testStandardTransformReal() {\n+        final boolean forward = true;\n+        final boolean standard = true;\n+        doTestTransformReal(2, 1.0E-15, forward, standard);\n+        doTestTransformReal(4, 1.0E-14, forward, standard);\n+        doTestTransformReal(8, 1.0E-14, forward, standard);\n+        doTestTransformReal(16, 1.0E-13, forward, standard);\n+        doTestTransformReal(32, 1.0E-13, forward, standard);\n+        doTestTransformReal(64, 1.0E-13, forward, standard);\n+        doTestTransformReal(128, 1.0E-11, forward, standard);\n+    }\n+\n+    @Test\n+    public void testUnitaryTransformReal() {\n+        final boolean forward = true;\n+        final boolean standard = false;\n+        doTestTransformReal(2, 1.0E-15, forward, standard);\n+        doTestTransformReal(4, 1.0E-14, forward, standard);\n+        doTestTransformReal(8, 1.0E-14, forward, standard);\n+        doTestTransformReal(16, 1.0E-13, forward, standard);\n+        doTestTransformReal(32, 1.0E-13, forward, standard);\n+        doTestTransformReal(64, 1.0E-13, forward, standard);\n+        doTestTransformReal(128, 1.0E-11, forward, standard);\n+    }\n+\n+    @Test\n+    public void testStandardInverseTransformReal() {\n+        final boolean forward = false;\n+        final boolean standard = true;\n+        doTestTransformReal(2, 1.0E-15, forward, standard);\n+        doTestTransformReal(4, 1.0E-14, forward, standard);\n+        doTestTransformReal(8, 1.0E-14, forward, standard);\n+        doTestTransformReal(16, 1.0E-13, forward, standard);\n+        doTestTransformReal(32, 1.0E-13, forward, standard);\n+        doTestTransformReal(64, 1.0E-12, forward, standard);\n+        doTestTransformReal(128, 1.0E-11, forward, standard);\n+    }\n+\n+    @Test\n+    public void testUnitaryInverseTransformReal() {\n+        final boolean forward = false;\n+        final boolean standard = false;\n+        doTestTransformReal(2, 1.0E-15, forward, standard);\n+        doTestTransformReal(4, 1.0E-14, forward, standard);\n+        doTestTransformReal(8, 1.0E-14, forward, standard);\n+        doTestTransformReal(16, 1.0E-13, forward, standard);\n+        doTestTransformReal(32, 1.0E-13, forward, standard);\n+        doTestTransformReal(64, 1.0E-12, forward, standard);\n+        doTestTransformReal(128, 1.0E-11, forward, standard);\n+    }\n+\n+    @Test\n+    public void testStandardTransformFunction() {\n+        final UnivariateFunction f = new Sinc();\n+        final double min = -FastMath.PI;\n+        final double max = FastMath.PI;\n+        final boolean forward = true;\n+        final boolean standard = true;\n+        doTestTransformFunction(f, min, max, 2, 1.0E-15, forward, standard);\n+        doTestTransformFunction(f, min, max, 4, 1.0E-14, forward, standard);\n+        doTestTransformFunction(f, min, max, 8, 1.0E-14, forward, standard);\n+        doTestTransformFunction(f, min, max, 16, 1.0E-13, forward, standard);\n+        doTestTransformFunction(f, min, max, 32, 1.0E-13, forward, standard);\n+        doTestTransformFunction(f, min, max, 64, 1.0E-12, forward, standard);\n+        doTestTransformFunction(f, min, max, 128, 1.0E-11, forward, standard);\n+    }\n+\n+    @Test\n+    public void testUnitaryTransformFunction() {\n+        final UnivariateFunction f = new Sinc();\n+        final double min = -FastMath.PI;\n+        final double max = FastMath.PI;\n+        final boolean forward = true;\n+        final boolean standard = false;\n+        doTestTransformFunction(f, min, max, 2, 1.0E-15, forward, standard);\n+        doTestTransformFunction(f, min, max, 4, 1.0E-14, forward, standard);\n+        doTestTransformFunction(f, min, max, 8, 1.0E-14, forward, standard);\n+        doTestTransformFunction(f, min, max, 16, 1.0E-13, forward, standard);\n+        doTestTransformFunction(f, min, max, 32, 1.0E-13, forward, standard);\n+        doTestTransformFunction(f, min, max, 64, 1.0E-12, forward, standard);\n+        doTestTransformFunction(f, min, max, 128, 1.0E-11, forward, standard);\n+    }\n+\n+    @Test\n+    public void testStandardInverseTransformFunction() {\n+        final UnivariateFunction f = new Sinc();\n+        final double min = -FastMath.PI;\n+        final double max = FastMath.PI;\n+        final boolean forward = false;\n+        final boolean standard = true;\n+        doTestTransformFunction(f, min, max, 2, 1.0E-15, forward, standard);\n+        doTestTransformFunction(f, min, max, 4, 1.0E-14, forward, standard);\n+        doTestTransformFunction(f, min, max, 8, 1.0E-14, forward, standard);\n+        doTestTransformFunction(f, min, max, 16, 1.0E-13, forward, standard);\n+        doTestTransformFunction(f, min, max, 32, 1.0E-13, forward, standard);\n+        doTestTransformFunction(f, min, max, 64, 1.0E-12, forward, standard);\n+        doTestTransformFunction(f, min, max, 128, 1.0E-11, forward, standard);\n+    }\n+\n+    @Test\n+    public void testUnitaryInverseTransformFunction() {\n+        final UnivariateFunction f = new Sinc();\n+        final double min = -FastMath.PI;\n+        final double max = FastMath.PI;\n+        final boolean forward = false;\n+        final boolean standard = false;\n+        doTestTransformFunction(f, min, max, 2, 1.0E-15, forward, standard);\n+        doTestTransformFunction(f, min, max, 4, 1.0E-14, forward, standard);\n+        doTestTransformFunction(f, min, max, 8, 1.0E-14, forward, standard);\n+        doTestTransformFunction(f, min, max, 16, 1.0E-13, forward, standard);\n+        doTestTransformFunction(f, min, max, 32, 1.0E-13, forward, standard);\n+        doTestTransformFunction(f, min, max, 64, 1.0E-12, forward, standard);\n+        doTestTransformFunction(f, min, max, 128, 1.0E-11, forward, standard);\n+    }\n+\n+    private static Complex[] createComplexData(final int n) {\n+        final Random random = new Random(SEED);\n+        final Complex[] data = new Complex[n];\n+        for (int i = 0; i < n; i++) {\n+            final double re = 2.0 * random.nextDouble() - 1.0;\n+            final double im = 2.0 * random.nextDouble() - 1.0;\n+            data[i] = new Complex(re, im);\n+        }\n+        return data;\n+    }\n+\n+    private static double[] createRealData(final int n) {\n+        final Random random = new Random(SEED);\n+        final double[] data = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            data[i] = 2.0 * random.nextDouble() - 1.0;\n+        }\n+        return data;\n+    }\n+\n+    private static void doTestTransformComplex(final int n, final double tol,\n+        final boolean forward, final boolean standard) {\n+        final FastFourierTransformer fft;\n+        if (standard) {\n+            fft = FastFourierTransformer.create();\n+        } else {\n+            fft = FastFourierTransformer.createUnitary();\n+        }\n+        final Complex[] x = createComplexData(n);\n+        final Complex[] expected;\n+        final Complex[] actual;\n+        final double s;\n+        if (forward) {\n+            expected = dft(x, -1);\n+            s = standard ? 1.0 : 1.0 / FastMath.sqrt(n);\n+            actual = fft.transform(x);\n+        } else {\n+            expected = dft(x, 1);\n+            s = standard ? 1.0 / n : 1.0 / FastMath.sqrt(n);\n+            actual = fft.inverseTransform(x);\n+        }\n+        for (int i = 0; i < n; i++) {\n+            final String msg = String.format(\"%d, %d\", n, i);\n+            final double re = s * expected[i].getReal();\n+            Assert.assertEquals(msg, re, actual[i].getReal(),\n+                tol * FastMath.abs(re));\n+            final double im = s * expected[i].getImaginary();\n+            Assert.assertEquals(msg, im, actual[i].getImaginary(), tol *\n+                FastMath.abs(re));\n+        }\n+    }\n+\n+    private static void doTestTransformReal(final int n, final double tol,\n+        final boolean forward, final boolean standard) {\n+        final FastFourierTransformer fft;\n+        if (standard) {\n+            fft = FastFourierTransformer.create();\n+        } else {\n+            fft = FastFourierTransformer.createUnitary();\n+        }\n+        final double[] x = createRealData(n);\n+        final Complex[] xc = new Complex[n];\n+        for (int i = 0; i < n; i++) {\n+            xc[i] = new Complex(x[i], 0.0);\n+        }\n+        final Complex[] expected;\n+        final Complex[] actual;\n+        final double s;\n+        if (forward) {\n+            expected = dft(xc, -1);\n+            s = standard ? 1.0 : 1.0 / FastMath.sqrt(n);\n+            actual = fft.transform(x);\n+        } else {\n+            expected = dft(xc, 1);\n+            s = standard ? 1.0 / n : 1.0 / FastMath.sqrt(n);\n+            actual = fft.inverseTransform(x);\n+        }\n+        for (int i = 0; i < n; i++) {\n+            final String msg = String.format(\"%d, %d\", n, i);\n+            final double re = s * expected[i].getReal();\n+            Assert.assertEquals(msg, re, actual[i].getReal(),\n+                tol * FastMath.abs(re));\n+            final double im = s * expected[i].getImaginary();\n+            Assert.assertEquals(msg, im, actual[i].getImaginary(), tol *\n+                FastMath.abs(re));\n+        }\n+    }\n+\n+    private static void doTestTransformFunction(final UnivariateFunction f,\n+        final double min, final double max, int n, final double tol,\n+        final boolean forward, final boolean standard) {\n+        final FastFourierTransformer fft;\n+        if (standard) {\n+            fft = FastFourierTransformer.create();\n+        } else {\n+            fft = FastFourierTransformer.createUnitary();\n+        }\n+        final Complex[] x = new Complex[n];\n+        for (int i = 0; i < n; i++) {\n+            final double t = min + i * (max - min) / n;\n+            x[i] = new Complex(f.value(t));\n+        }\n+        final Complex[] expected;\n+        final Complex[] actual;\n+        final double s;\n+        if (forward) {\n+            expected = dft(x, -1);\n+            s = standard ? 1.0 : 1.0 / FastMath.sqrt(n);\n+            actual = fft.transform(f, min, max, n);\n+        } else {\n+            expected = dft(x, 1);\n+            s = standard ? 1.0 / n : 1.0 / FastMath.sqrt(n);\n+            actual = fft.inverseTransform(f, min, max, n);\n+        }\n+        for (int i = 0; i < n; i++) {\n+            final String msg = String.format(\"%d, %d\", n, i);\n+            final double re = s * expected[i].getReal();\n+            Assert.assertEquals(msg, re, actual[i].getReal(),\n+                tol * FastMath.abs(re));\n+            final double im = s * expected[i].getImaginary();\n+            Assert.assertEquals(msg, im, actual[i].getImaginary(), tol *\n+                FastMath.abs(re));\n+        }\n+    }\n }", "timestamp": 1326264573, "metainfo": ""}