{"sha": "59ed630e834e030da4ff2685d0ac74ca8250960a", "log": "JIRA: MATH-675 Added isMonotone methods to MathUtils and cleaned up checkOrder.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n         /** Constant for decreasing direction. */\n         DECREASING\n     }\n+     /**\n+     * Check that an array is monotone increasing or decreasing\n+     *\n+     * @param val Values.\n+     * @param dir Ordering direction.\n+     * @param strict Whether the order should be strict.\n+     * @return {@code true} if sorted, {@code false} otherwise\n+     */\n+    public static boolean isMonotone(Comparable[] val, OrderDirection dir,\n+            boolean strict){\n+        Comparable previous = val[0];\n+        int max = val.length;\n+        int comp;\n+        for (int i = 1; i < max; i++) {\n+            switch (dir) {\n+            case INCREASING:\n+                comp = -val[i].compareTo(previous);\n+                if (strict) {\n+                    if (0 <= comp) {\n+                        return false;\n+                    }\n+                } else {\n+                    if ( comp > 0) {\n+                        return false;\n+                    }\n+                }\n+                break;\n+            case DECREASING:\n+                comp = val[i].compareTo(previous);\n+                if (strict) {\n+                    if (comp >= 0) {\n+                        return false;\n+                    }\n+                } else {\n+                    if (comp > 0) {\n+                       return false;\n+                    }\n+                }\n+                break;\n+            default:\n+                // Should never happen.\n+                throw new IllegalArgumentException();\n+            }\n+\n+            previous = val[i];\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Check that an array is monotone increasing or decreasing\n+     *\n+     * @param val Values.\n+     * @param dir Ordering direction.\n+     * @param strict Whether the order should be strict.\n+     * @return {@code true} if sorted, {@code false} otherwise\n+     */\n+    public static boolean isMonotone( double[] val, OrderDirection dir,\n+                                      boolean strict){\n+        double previous = val[0];\n+        int max = val.length;\n+        for (int i = 1; i < max; i++) {\n+            switch (dir) {\n+            case INCREASING:\n+                if (strict) {\n+                    if (val[i] <= previous) {\n+                        return false;\n+                    }\n+                } else {\n+                    if (val[i] < previous) {\n+                        return false;\n+                    }\n+                }\n+                break;\n+            case DECREASING:\n+                if (strict) {\n+                    if (val[i] >= previous) {\n+                        return false;\n+                    }\n+                } else {\n+                    if (val[i] > previous) {\n+                        return false;\n+                    }\n+                }\n+                break;\n+            default:\n+                // Should never happen.\n+                throw new IllegalArgumentException();\n+            }\n+            previous = val[i];\n+        }\n+\n+        return true;\n+    }\n \n     /**\n      * Check that the given array is sorted.\n     public static boolean checkOrder(double[] val, OrderDirection dir,\n                                      boolean strict, boolean abort) {\n         double previous = val[0];\n-        boolean ok = true;\n-\n         int max = val.length;\n         for (int i = 1; i < max; i++) {\n             switch (dir) {\n             case INCREASING:\n                 if (strict) {\n                     if (val[i] <= previous) {\n-                        ok = false;\n+                        if (abort) {\n+                            throw new NonMonotonousSequenceException((Number)val[i], (Number)previous, i, dir, strict);\n+                        }\n+                        return false;\n                     }\n                 } else {\n                     if (val[i] < previous) {\n-                        ok = false;\n+                        if (abort) {\n+                            throw new NonMonotonousSequenceException((Number)val[i], (Number)previous, i, dir, strict);\n+                        }\n+                        return false;\n                     }\n                 }\n                 break;\n             case DECREASING:\n                 if (strict) {\n                     if (val[i] >= previous) {\n-                        ok = false;\n+                        if (abort) {\n+                            throw new NonMonotonousSequenceException((Number)val[i], (Number)previous, i, dir, strict);\n+                        }\n+                        return false;\n                     }\n                 } else {\n                     if (val[i] > previous) {\n-                        ok = false;\n+                        if (abort) {\n+                            throw new NonMonotonousSequenceException((Number)val[i], (Number)previous, i, dir, strict);\n+                        }\n+                        return false;\n                     }\n                 }\n                 break;\n                 // Should never happen.\n                 throw new IllegalArgumentException();\n             }\n-\n-            if (!ok &&\n-                abort) {\n-                throw new NonMonotonousSequenceException(val[i], previous, i, dir, strict);\n-            }\n             previous = val[i];\n         }\n-\n-        return ok;\n+        return true;\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n         Assert.assertEquals(expected,\n                             MathUtils.reduce(orig, -period, offset),\n                             1e-6);\n-        \n+\n         Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig, Double.NaN, offset)));\n         Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.NaN, period, offset)));\n         Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig, period, Double.NaN)));\n         Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY,\n                 period, offset)));\n         Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig,\n-                Double.POSITIVE_INFINITY, offset)));   \n+                Double.POSITIVE_INFINITY, offset)));\n         Assert.assertTrue(Double.isNaN(MathUtils.reduce(orig,\n                 Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY)));\n         Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY,\n                 period, Double.POSITIVE_INFINITY)));\n         Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY,\n-                Double.POSITIVE_INFINITY, offset))); \n+                Double.POSITIVE_INFINITY, offset)));\n         Assert.assertTrue(Double.isNaN(MathUtils.reduce(Double.POSITIVE_INFINITY,\n                 Double.POSITIVE_INFINITY,  Double.POSITIVE_INFINITY)));\n     }\n         try {\n             MathUtils.round(1.234, 2, BigDecimal.ROUND_UNNECESSARY);\n             Assert.fail();\n-        } catch (ArithmeticException ex) { \n+        } catch (ArithmeticException ex) {\n             // expected\n         }\n \n     }\n \n     @Test\n+    public void testIsMonotone() {\n+        if(MathUtils.isMonotone(new double[] {-15, -5.5, -1, -1, 2,15},\n+                             MathUtils.OrderDirection.INCREASING, true) ){\n+            Assert.fail(\"an exception should have been thrown\");\n+        }\n+\n+        if(MathUtils.isMonotone(new double[] {-15, -5.5,-1,-2,2},\n+                             MathUtils.OrderDirection.INCREASING, false)){\n+            Assert.fail(\"an exception should have been thrown\");\n+        }\n+\n+        if(MathUtils.isMonotone(new double[] {3,3,-5.5,-11,-27.5},\n+                             MathUtils.OrderDirection.DECREASING, true)){\n+            Assert.fail(\"an exception should have been thrown\");\n+        }\n+        if( MathUtils.isMonotone(new double[] {3,-1,0,-5.5,-11,-27.5},\n+                             MathUtils.OrderDirection.DECREASING, false) ){\n+        Assert.fail(\"an exception should have been thrown\");\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testIsMonotoneComparable() {\n+        if(MathUtils.isMonotone(new Double[] {new Double(-15), new Double(-5.5), new Double(-1), new Double(-1), new Double(2), new Double(15)},\n+                             MathUtils.OrderDirection.INCREASING, true) ){\n+            Assert.fail(\"an exception should have been thrown\");\n+        }\n+\n+        if(MathUtils.isMonotone(new Double[] {new Double(-15), new Double(-5.5), new Double(-1), new Double(-2), new Double(2)},\n+                             MathUtils.OrderDirection.INCREASING, false)){\n+            Assert.fail(\"an exception should have been thrown\");\n+        }\n+\n+        if(MathUtils.isMonotone(new Double[] {new Double(3), new Double(3), new Double(-5.5), new Double(-11), new Double(-27.5)},\n+                             MathUtils.OrderDirection.DECREASING, true)){\n+            Assert.fail(\"an exception should have been thrown\");\n+        }\n+        if( MathUtils.isMonotone(new Double[] {new Double(3), new Double(-1), new Double(0), new Double(-5.5), new Double(-11), new Double(-27.5)},\n+                             MathUtils.OrderDirection.DECREASING, false) ){\n+        Assert.fail(\"an exception should have been thrown\");\n+        }\n+\n+    }\n+\n+    @Test\n     public void testCheckFinite() {\n         try {\n             MathUtils.checkFinite(Double.POSITIVE_INFINITY);\n         final double[] x1 = {2,   5,  -3, 1,  4};\n         final double[] x2 = {4,  25,   9, 1, 16};\n         final double[] x3 = {8, 125, -27, 1, 64};\n-        \n+\n         MathUtils.sortInPlace(x1, x2, x3);\n \n         Assert.assertEquals(-3,  x1[0], Math.ulp(1d));", "timestamp": 1316676845, "metainfo": ""}