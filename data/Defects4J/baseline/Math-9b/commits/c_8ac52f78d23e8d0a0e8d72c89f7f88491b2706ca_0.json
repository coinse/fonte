{"sha": "8ac52f78d23e8d0a0e8d72c89f7f88491b2706ca", "log": "added missing files from previous patches (JIRA:MATH-161 and JIRA:MATH-162)  ", "commit": "\n--- /dev/null\n+++ b/src/mantissa/src/org/spaceroots/mantissa/algebra/CoefficientsGenerator.java\n+package org.spaceroots.mantissa.algebra;\n+\n+import java.util.ArrayList;\n+\n+public abstract class CoefficientsGenerator {\n+\n+  /** Build a generator with coefficients for two polynomials.\n+   * <p>The first polynomial must be a degree 0 polynomial\n+   * P<sub>0</sub>(X)=a<sub>0,0</sub> and the second polynomial\n+   * must be a degree 1 polynomial P<sub>1</sub>(X)=a<sub>0,1</sub>\n+   * +a<sub>1,1</sub>X</p>\n+   * @param a00 constant term for the degree 0 polynomial\n+   * @param a01 constant term for the degree 1 polynomial\n+   * @param a11 X term for the degree 1 polynomial\n+   */\n+  protected CoefficientsGenerator(RationalNumber a00,\n+                                  RationalNumber a01, RationalNumber a11) {\n+    l = new ArrayList();\n+    l.add(a00);\n+    l.add(a01);\n+    l.add(a11);\n+    maxDegree = 1;\n+  }\n+\n+  /** Set the recurrence coefficients.\n+   * @param b2k b<sub>2,k</sub> coefficient (b<sub>2,k</sub> = a<sub>2,k</sub> / a<sub>1,k</sub>)\n+   * @param b3k b<sub>3,k</sub> coefficient (b<sub>3,k</sub> = a<sub>3,k</sub> / a<sub>1,k</sub>)\n+   * @param b4k b<sub>4,k</sub> coefficient (b<sub>4,k</sub> = a<sub>4,k</sub> / a<sub>1,k</sub>)\n+   */\n+  protected void setRecurrenceCoefficients(RationalNumber b2k,\n+                                           RationalNumber b3k,\n+                                           RationalNumber b4k) {\n+    this.b2k = b2k;\n+    this.b3k = b3k;\n+    this.b4k = b4k;\n+  }\n+\n+  /** Set the recurrence coefficients.\n+   * The recurrence relation is\n+   *  <pre>a<sub>1,k</sub> O<sub>k+1</sub>(X) =(a<sub>2,k</sub> + a<sub>3,k</sub> X) O<sub>k</sub>(X) - a<sub>4,k</sub> O<sub>k-1</sub>(X)</pre>\n+   * the method must call {@link #setRecurrenceCoefficients(RationalNumber,\n+   * RationalNumber, RationalNumber)} to provide the coefficients\n+   * @param k index of the current step\n+   */\n+  protected abstract void setRecurrenceCoefficients(int k);\n+\n+  /** Compute all the polynomial coefficients up to a given degree.\n+   * @param degree maximal degree\n+   */\n+  private void computeUpToDegree(int degree) {\n+\n+    int startK = (maxDegree - 1) * maxDegree / 2;\n+    for (int k = maxDegree; k < degree; ++k) {\n+\n+      // start indices of two previous polynomials Ok(X) and Ok-1(X)\n+      int startKm1 = startK;\n+      startK += k;\n+\n+      // a1k Ok+1(X) = (a2k + a3k X) Ok(X) - a4k Ok-1(X)\n+      // we use bik = aik/a1k\n+      setRecurrenceCoefficients(k);\n+\n+      RationalNumber ckPrev = null;\n+      RationalNumber ck     = (RationalNumber) l.get(startK);\n+      RationalNumber ckm1   = (RationalNumber) l.get(startKm1);\n+\n+      // degree 0 coefficient\n+      l.add(ck.multiply(b2k).subtract(ckm1.multiply(b4k)));\n+\n+      // degree 1 to degree k-1 coefficients\n+      for (int i = 1; i < k; ++i) {\n+        ckPrev = ck;\n+        ck     = (RationalNumber) l.get(startK + i);\n+        ckm1   = (RationalNumber) l.get(startKm1 + i);\n+        l.add(ck.multiply(b2k).add(ckPrev.multiply(b3k)).subtract(ckm1.multiply(b4k)));\n+      }\n+\n+      // degree k coefficient\n+      ckPrev = ck;\n+      ck     = (RationalNumber) l.get(startK + k);\n+      l.add(ck.multiply(b2k).add(ckPrev.multiply(b3k)));\n+\n+      // degree k+1 coefficient\n+      l.add(ck.multiply(b3k));\n+\n+    }\n+\n+    maxDegree = degree;\n+\n+  }\n+\n+  /** Get the coefficients array for a given degree.\n+   * @param degree degree of the polynomial\n+   * @return coefficients array\n+   */\n+  public RationalNumber[] getCoefficients(int degree) {\n+\n+    synchronized (this) {\n+      if (degree > maxDegree) {\n+        computeUpToDegree(degree);\n+      }\n+    }\n+\n+    // coefficient  for polynomial 0 is  l [0]\n+    // coefficients for polynomial 1 are l [1] ... l [2] (degrees 0 ... 1)\n+    // coefficients for polynomial 2 are l [3] ... l [5] (degrees 0 ... 2)\n+    // coefficients for polynomial 3 are l [6] ... l [9] (degrees 0 ... 3)\n+    // coefficients for polynomial 4 are l[10] ... l[14] (degrees 0 ... 4)\n+    // coefficients for polynomial 5 are l[15] ... l[20] (degrees 0 ... 5)\n+    // coefficients for polynomial 6 are l[21] ... l[27] (degrees 0 ... 6)\n+    // ...\n+    int start = degree * (degree + 1) / 2;\n+\n+    RationalNumber[] a = new RationalNumber[degree + 1];\n+    for (int i = 0; i <= degree; ++i) {\n+      a[i] = (RationalNumber) l.get(start + i);\n+    }\n+\n+    return a;\n+\n+  }\n+  \n+  /** List holding the coefficients of the polynomials computed so far. */\n+  private ArrayList l;\n+\n+  /** Maximal degree of the polynomials computed so far. */\n+  private int maxDegree;\n+\n+  /** b<sub>2,k</sub> coefficient to initialize\n+   * (b<sub>2,k</sub> = a<sub>2,k</sub> / a<sub>1,k</sub>). */\n+  private RationalNumber b2k;\n+\n+  /** b<sub>3,k</sub> coefficient to initialize\n+   * (b<sub>3,k</sub> = a<sub>3,k</sub> / a<sub>1,k</sub>). */\n+  private RationalNumber b3k;\n+\n+  /** b<sub>4,k</sub> coefficient to initialize\n+   * (b<sub>4,k</sub> = a<sub>4,k</sub> / a<sub>1,k</sub>). */\n+  private RationalNumber b4k;\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/estimation/MinpackTest.java\n+package org.spaceroots.mantissa.estimation;\n+\n+import java.util.Arrays;\n+\n+import junit.framework.*;\n+\n+/**\n+ * <p>Some of the unit tests are re-implementations of the MINPACK <a\n+ * href=\"http://www.netlib.org/minpack/ex/file17\">file17</a> and <a\n+ * href=\"http://www.netlib.org/minpack/ex/file22\">file22</a> test files. \n+ * The redistribution policy for MINPACK is available <a\n+ * href=\"http://www.netlib.org/minpack/disclaimer\">here</a>, for\n+ * convenience, it is reproduced below.</p>\n+\n+ * <table border=\"0\" width=\"80%\" cellpadding=\"10\" align=\"center\" bgcolor=\"#E0E0E0\">\n+ * <tr><td>\n+ *    Minpack Copyright Notice (1999) University of Chicago.\n+ *    All rights reserved\n+ * </td></tr>\n+ * <tr><td>\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ * <ol>\n+ *  <li>Redistributions of source code must retain the above copyright\n+ *      notice, this list of conditions and the following disclaimer.</li>\n+ * <li>Redistributions in binary form must reproduce the above\n+ *     copyright notice, this list of conditions and the following\n+ *     disclaimer in the documentation and/or other materials provided\n+ *     with the distribution.</li>\n+ * <li>The end-user documentation included with the redistribution, if any,\n+ *     must include the following acknowledgment:\n+ *     <code>This product includes software developed by the University of\n+ *           Chicago, as Operator of Argonne National Laboratory.</code>\n+ *     Alternately, this acknowledgment may appear in the software itself,\n+ *     if and wherever such third-party acknowledgments normally appear.</li>\n+ * <li><strong>WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\"\n+ *     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE\n+ *     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND\n+ *     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR\n+ *     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES\n+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE\n+ *     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY\n+ *     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR\n+ *     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF\n+ *     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4)\n+ *     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION\n+ *     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL\n+ *     BE CORRECTED.</strong></li>\n+ * <li><strong>LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT\n+ *     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF\n+ *     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT,\n+ *     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF\n+ *     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF\n+ *     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER\n+ *     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT\n+ *     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE,\n+ *     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE\n+ *     POSSIBILITY OF SUCH LOSS OR DAMAGES.</strong></li>\n+ * <ol></td></tr>\n+ * </table>\n+\n+ * @author Argonne National Laboratory. MINPACK project. March 1980 (original fortran minpack tests)\n+ * @author Burton S. Garbow (original fortran minpack tests)\n+ * @author Kenneth E. Hillstrom (original fortran minpack tests)\n+ * @author Jorge J. More (original fortran minpack tests)\n+ * @author Luc Maisonobe (non-minpack tests and minpack tests Java translation)\n+ */\n+public class MinpackTest\n+  extends TestCase {\n+\n+  public MinpackTest(String name) {\n+    super(name);\n+  }\n+\n+  public void testMinpackLinearFullRank()\n+    throws EstimationException {\n+    minpackTest(new LinearFullRankFunction(10, 5, 1.0,\n+                                           5.0, 2.23606797749979), false);\n+    minpackTest(new LinearFullRankFunction(50, 5, 1.0,\n+                                           8.06225774829855, 6.70820393249937), false);\n+  }\n+\n+  public void testMinpackLinearRank1()\n+    throws EstimationException {\n+    minpackTest(new LinearRank1Function(10, 5, 1.0,\n+                                        291.521868819476, 1.4638501094228), false);\n+    minpackTest(new LinearRank1Function(50, 5, 1.0,\n+                                        3101.60039334535, 3.48263016573496), false);\n+  }\n+\n+  public void testMinpackLinearRank1ZeroColsAndRows()\n+    throws EstimationException {\n+    minpackTest(new LinearRank1ZeroColsAndRowsFunction(10, 5, 1.0), false);\n+    minpackTest(new LinearRank1ZeroColsAndRowsFunction(50, 5, 1.0), false);\n+  }\n+\n+  public void testMinpackRosenbrok()\n+    throws EstimationException {\n+    minpackTest(new RosenbrockFunction(new double[] { -1.2, 1.0 },\n+                                       Math.sqrt(24.2)), false);\n+    minpackTest(new RosenbrockFunction(new double[] { -12.0, 10.0 },\n+                                       Math.sqrt(1795769.0)), false);\n+    minpackTest(new RosenbrockFunction(new double[] { -120.0, 100.0 },\n+                                       11.0 * Math.sqrt(169000121.0)), false);\n+  }\n+\n+  public void testMinpackHelicalValley()\n+    throws EstimationException {\n+    minpackTest(new HelicalValleyFunction(new double[] { -1.0, 0.0, 0.0 },\n+                                          50.0), false);\n+    minpackTest(new HelicalValleyFunction(new double[] { -10.0, 0.0, 0.0 },\n+                                          102.95630140987), false);\n+    minpackTest(new HelicalValleyFunction(new double[] { -100.0, 0.0, 0.0},\n+                                          991.261822123701), false);\n+  }\n+    \n+  public void testMinpackPowellSingular()\n+    throws EstimationException {\n+    minpackTest(new PowellSingularFunction(new double[] { 3.0, -1.0, 0.0, 1.0 },\n+                                           14.6628782986152), false);\n+    minpackTest(new PowellSingularFunction(new double[] { 30.0, -10.0, 0.0, 10.0 },\n+                                           1270.9838708654), false);\n+    minpackTest(new PowellSingularFunction(new double[] { 300.0, -100.0, 0.0, 100.0 },\n+                                           126887.903284750), false);\n+  }\n+    \n+  public void testMinpackFreudensteinRoth()\n+    throws EstimationException {\n+    minpackTest(new FreudensteinRothFunction(new double[] { 0.5, -2.0 },\n+                                             20.0124960961895, 6.99887517584575,\n+                                             new double[] {\n+                                               11.4124844654993,\n+                                               -0.896827913731509\n+                                             }), false);\n+    minpackTest(new FreudensteinRothFunction(new double[] { 5.0, -20.0 },\n+                                             12432.833948863, 6.9988751744895,\n+                                             new double[] {\n+                                               11.4130046614746,\n+                                               -0.896796038685958\n+                                             }), false);\n+    minpackTest(new FreudensteinRothFunction(new double[] { 50.0, -200.0 },\n+                                             11426454.595762, 6.99887517242903,\n+                                             new double[] {\n+                                               11.4127817857886,\n+                                               -0.89680510749204\n+                                             }), false);\n+  }\n+    \n+  public void testMinpackBard()\n+    throws EstimationException {\n+    minpackTest(new BardFunction(1.0, 6.45613629515967, 0.0906359603390466,\n+                                 new double[] {\n+                                   0.0824105765758334,\n+                                   1.1330366534715,\n+                                   2.34369463894115\n+                                 }), false);\n+    minpackTest(new BardFunction(10.0, 36.1418531596785, 4.17476870138539,\n+                                 new double[] {\n+                                   0.840666673818329,\n+                                   -158848033.259565,\n+                                   -164378671.653535\n+                                 }), false);\n+    minpackTest(new BardFunction(100.0, 384.114678637399, 4.17476870135969,\n+                                 new double[] {\n+                                   0.840666673867645,\n+                                   -158946167.205518,\n+                                   -164464906.857771\n+                                 }), false);\n+  }\n+    \n+  public void testMinpackKowalikOsborne()\n+    throws EstimationException {\n+    minpackTest(new KowalikOsborneFunction(new double[] { 0.25, 0.39, 0.415, 0.39 },\n+                                           0.0728915102882945,\n+                                           0.017535837721129,\n+                                           new double[] {\n+                                             0.192807810476249,\n+                                             0.191262653354071,\n+                                             0.123052801046931,\n+                                             0.136053221150517\n+                                           }), false);\n+    minpackTest(new KowalikOsborneFunction(new double[] { 2.5, 3.9, 4.15, 3.9 },\n+                                           2.97937007555202,\n+                                           0.032052192917937,\n+                                           new double[] {\n+                                             728675.473768287,\n+                                             -14.0758803129393,\n+                                             -32977797.7841797,\n+                                             -20571594.1977912\n+                                           }), false);\n+    minpackTest(new KowalikOsborneFunction(new double[] { 25.0, 39.0, 41.5, 39.0 },\n+                                           29.9590617016037,\n+                                           0.0175364017658228,\n+                                           new double[] {\n+                                             0.192948328597594,\n+                                             0.188053165007911,\n+                                             0.122430604321144,\n+                                             0.134575665392506\n+                                           }), true);\n+  }\n+    \n+  public void testMinpackMeyer()\n+    throws EstimationException {\n+    minpackTest(new MeyerFunction(new double[] { 0.02, 4000.0, 250.0 },\n+                                  41153.4665543031, 9.37794514651874,\n+                                  new double[] {\n+                                    0.00560963647102661,\n+                                    6181.34634628659,\n+                                    345.223634624144\n+                                  }), false);\n+    minpackTest(new MeyerFunction(new double[] { 0.2, 40000.0, 2500.0 },\n+                                  4168216.89130846, 792.917871779501,\n+                                  new double[] {\n+                                    1.42367074157994e-11,\n+                                    33695.7133432541,\n+                                    901.268527953801\n+                                  }), true);\n+  }\n+    \n+  public void testMinpackWatson()\n+    throws EstimationException {\n+  \n+    minpackTest(new WatsonFunction(6, 0.0,\n+                                   5.47722557505166, 0.0478295939097601,\n+                                   new double[] {\n+                                     -0.0157249615083782, 1.01243488232965,\n+                                     -0.232991722387673,  1.26043101102818,\n+                                     -1.51373031394421,   0.99299727291842\n+                                   }), false);\n+    minpackTest(new WatsonFunction(6, 10.0,\n+                                   6433.12578950026, 0.0478295939096951,\n+                                   new double[] {\n+                                     -0.0157251901386677, 1.01243485860105,\n+                                     -0.232991545843829,  1.26042932089163,\n+                                     -1.51372776706575,   0.99299573426328\n+                                   }), false);\n+    minpackTest(new WatsonFunction(6, 100.0,\n+                                   674256.040605213, 0.047829593911544,\n+                                   new double[] {\n+                                    -0.0157247019712586, 1.01243490925658,\n+                                    -0.232991922761641,  1.26043292929555,\n+                                    -1.51373320452707,   0.99299901922322\n+                                   }), false);\n+\n+    minpackTest(new WatsonFunction(9, 0.0,\n+                                   5.47722557505166, 0.00118311459212420,\n+                                   new double[] {\n+                                    -0.153070644166722e-4, 0.999789703934597,\n+                                     0.0147639634910978,   0.146342330145992,\n+                                     1.00082109454817,    -2.61773112070507,\n+                                     4.10440313943354,    -3.14361226236241,\n+                                     1.05262640378759\n+                                   }), false);\n+    minpackTest(new WatsonFunction(9, 10.0,\n+                                   12088.127069307, 0.00118311459212513,\n+                                   new double[] {\n+                                   -0.153071334849279e-4, 0.999789703941234,\n+                                    0.0147639629786217,   0.146342334818836,\n+                                    1.00082107321386,    -2.61773107084722,\n+                                    4.10440307655564,    -3.14361222178686,\n+                                    1.05262639322589\n+                                   }), false);\n+    minpackTest(new WatsonFunction(9, 100.0,\n+                                   1269109.29043834, 0.00118311459212384,\n+                                   new double[] {\n+                                    -0.153069523352176e-4, 0.999789703958371,\n+                                     0.0147639625185392,   0.146342341096326,\n+                                     1.00082104729164,    -2.61773101573645,\n+                                     4.10440301427286,    -3.14361218602503,\n+                                     1.05262638516774\n+                                   }), false);\n+\n+    minpackTest(new WatsonFunction(12, 0.0,\n+                                   5.47722557505166, 0.217310402535861e-4,\n+                                   new double[] {\n+                                    -0.660266001396382e-8, 1.00000164411833,\n+                                    -0.000563932146980154, 0.347820540050756,\n+                                    -0.156731500244233,    1.05281515825593,\n+                                    -3.24727109519451,     7.2884347837505,\n+                                   -10.271848098614,       9.07411353715783,\n+                                    -4.54137541918194,     1.01201187975044\n+                                   }), false);\n+    minpackTest(new WatsonFunction(12, 10.0,\n+                                   19220.7589790951, 0.217310402518509e-4,\n+                                   new double[] {\n+                                    -0.663710223017410e-8, 1.00000164411787,\n+                                    -0.000563932208347327, 0.347820540486998,\n+                                    -0.156731503955652,    1.05281517654573,\n+                                    -3.2472711515214,      7.28843489430665,\n+                                   -10.2718482369638,      9.07411364383733,\n+                                    -4.54137546533666,     1.01201188830857\n+                                   }), false);\n+    minpackTest(new WatsonFunction(12, 100.0,\n+                                   2018918.04462367, 0.217310402539845e-4,\n+                                   new double[] {\n+                                    -0.663806046485249e-8, 1.00000164411786,\n+                                    -0.000563932210324959, 0.347820540503588,\n+                                    -0.156731504091375,    1.05281517718031,\n+                                    -3.24727115337025,     7.28843489775302,\n+                                   -10.2718482410813,      9.07411364688464,\n+                                    -4.54137546660822,     1.0120118885369\n+                                   }), false);\n+\n+  }\n+    \n+  public void testMinpackBox3Dimensional()\n+  throws EstimationException {\n+    minpackTest(new Box3DimensionalFunction(10, new double[] { 0.0, 10.0, 20.0 },\n+                                            32.1115837449572), false);\n+  }\n+    \n+  public void testMinpackJennrichSampson()\n+    throws EstimationException {\n+    minpackTest(new JennrichSampsonFunction(10, new double[] { 0.3, 0.4 },\n+                                            64.5856498144943, 11.1517793413499,\n+                                            new double[] {\n+                                             0.257819926636811, 0.257829976764542\n+                                            }), false);\n+  }\n+\n+  public void testMinpackBrownDennis()\n+    throws EstimationException {\n+    minpackTest(new BrownDennisFunction(20,\n+                                        new double[] { 25.0, 5.0, -5.0, -1.0 },\n+                                        2815.43839161816, 292.954288244866,\n+                                        new double[] {\n+                                         -11.59125141003, 13.2024883984741,\n+                                         -0.403574643314272, 0.236736269844604\n+                                        }), false);\n+    minpackTest(new BrownDennisFunction(20,\n+                                        new double[] { 250.0, 50.0, -50.0, -10.0 },\n+                                        555073.354173069, 292.954270581415,\n+                                        new double[] {\n+                                         -11.5959274272203, 13.2041866926242,\n+                                         -0.403417362841545, 0.236771143410386\n+                                       }), false);\n+    minpackTest(new BrownDennisFunction(20,\n+                                        new double[] { 2500.0, 500.0, -500.0, -100.0 },\n+                                        61211252.2338581, 292.954306151134,\n+                                        new double[] {\n+                                         -11.5902596937374, 13.2020628854665,\n+                                         -0.403688070279258, 0.236665033746463\n+                                        }), false);\n+  }\n+    \n+  public void testMinpackChebyquad()\n+    throws EstimationException {\n+    minpackTest(new ChebyquadFunction(1, 8, 1.0,\n+                                      1.88623796907732, 1.88623796907732,\n+                                      new double[] { 0.5 }), false);\n+    minpackTest(new ChebyquadFunction(1, 8, 10.0,\n+                                      5383344372.34005, 1.88424820499951,\n+                                      new double[] { 0.9817314924684 }), false);\n+    minpackTest(new ChebyquadFunction(1, 8, 100.0,\n+                                      0.118088726698392e19, 1.88424820499347,\n+                                      new double[] { 0.9817314852934 }), false);\n+    minpackTest(new ChebyquadFunction(8, 8, 1.0,\n+                                      0.196513862833975, 0.0593032355046727,\n+                                      new double[] {\n+                                        0.0431536648587336, 0.193091637843267,\n+                                        0.266328593812698,  0.499999334628884,\n+                                        0.500000665371116,  0.733671406187302,\n+                                        0.806908362156733,  0.956846335141266\n+                                      }), false);\n+    minpackTest(new ChebyquadFunction(9, 9, 1.0,\n+                                      0.16994993465202, 0.0,\n+                                      new double[] {\n+                                        0.0442053461357828, 0.199490672309881,\n+                                        0.23561910847106,   0.416046907892598,\n+                                        0.5,                0.583953092107402,\n+                                        0.764380891528940,  0.800509327690119,\n+                                        0.955794653864217\n+                                      }), false);\n+    minpackTest(new ChebyquadFunction(10, 10, 1.0,\n+                                      0.183747831178711, 0.0806471004038253,\n+                                      new double[] {\n+                                        0.0596202671753563, 0.166708783805937,\n+                                        0.239171018813509,  0.398885290346268,\n+                                        0.398883667870681,  0.601116332129320,\n+                                        0.60111470965373,   0.760828981186491,\n+                                        0.833291216194063,  0.940379732824644\n+                                      }), false);\n+  }\n+    \n+  public void testMinpackBrownAlmostLinear()\n+    throws EstimationException {\n+    minpackTest(new BrownAlmostLinearFunction(10, 0.5,\n+                                              16.5302162063499, 0.0,\n+                                              new double[] {\n+                                                0.979430303349862, 0.979430303349862,\n+                                                0.979430303349862, 0.979430303349862,\n+                                                0.979430303349862, 0.979430303349862,\n+                                                0.979430303349862, 0.979430303349862,\n+                                                0.979430303349862, 1.20569696650138\n+                                              }), false);\n+    minpackTest(new BrownAlmostLinearFunction(10, 5.0,\n+                                              9765624.00089211, 0.0,\n+                                              new double[] {\n+                                               0.979430303349865, 0.979430303349865,\n+                                               0.979430303349865, 0.979430303349865,\n+                                               0.979430303349865, 0.979430303349865,\n+                                               0.979430303349865, 0.979430303349865,\n+                                               0.979430303349865, 1.20569696650135\n+                                              }), false);  \n+    minpackTest(new BrownAlmostLinearFunction(10, 50.0,\n+                                              0.9765625e17, 0.0,\n+                                              new double[] {\n+                                                1.0, 1.0, 1.0, 1.0, 1.0,\n+                                                1.0, 1.0, 1.0, 1.0, 1.0\n+                                              }), false);\n+    minpackTest(new BrownAlmostLinearFunction(30, 0.5,\n+                                              83.476044467848, 0.0,\n+                                              new double[] {\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 0.997754216442807,\n+                                                0.997754216442807, 1.06737350671578\n+                                              }), false);\n+    minpackTest(new BrownAlmostLinearFunction(40, 0.5,\n+                                              128.026364472323, 0.0,\n+                                              new double[] {\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                1.00000000000002, 1.00000000000002,\n+                                                0.999999999999121\n+                                              }), false);\n+    }\n+    \n+  public void testMinpackOsborne1()\n+    throws EstimationException {\n+      minpackTest(new Osborne1Function(new double[] { 0.5, 1.5, -1.0, 0.01, 0.02, },\n+                                       0.937564021037838, 0.00739249260904843,\n+                                       new double[] {\n+                                         0.375410049244025, 1.93584654543108,\n+                                        -1.46468676748716, 0.0128675339110439,\n+                                         0.0221227011813076\n+                                       }), false);\n+    }\n+    \n+  public void testMinpackOsborne2()\n+    throws EstimationException {\n+      \n+    minpackTest(new Osborne2Function(new double[] {\n+                                       1.3, 0.65, 0.65, 0.7, 0.6,\n+                                       3.0, 5.0, 7.0, 2.0, 4.5, 5.5\n+                                     },\n+                                     1.44686540984712, 0.20034404483314,\n+                                     new double[] {\n+                                       1.30997663810096,  0.43155248076,\n+                                       0.633661261602859, 0.599428560991695,\n+                                       0.754179768272449, 0.904300082378518,\n+                                       1.36579949521007, 4.82373199748107,\n+                                       2.39868475104871, 4.56887554791452,\n+                                       5.67534206273052\n+                                     }), false);\n+  }\n+\n+  private void minpackTest(MinpackFunction function, boolean exceptionExpected) {\n+    LevenbergMarquardtEstimator estimator = new LevenbergMarquardtEstimator();\n+    estimator.setMaxCostEval(100 * (function.getN() + 1));\n+    estimator.setCostRelativeTolerance(Math.sqrt(2.22044604926e-16));\n+    estimator.setParRelativeTolerance(Math.sqrt(2.22044604926e-16));\n+    estimator.setOrthoTolerance(2.22044604926e-16);\n+    assertTrue(function.checkTheoreticalStartCost(estimator.getRMS(function)));\n+    try {\n+      estimator.estimate(function);\n+      assertFalse(exceptionExpected);\n+    } catch (EstimationException lsse) {\n+      assertTrue(exceptionExpected);\n+    }\n+    assertTrue(function.checkTheoreticalMinCost(estimator.getRMS(function)));\n+    assertTrue(function.checkTheoreticalMinParams());\n+  }\n+\n+  private static abstract class MinpackFunction implements EstimationProblem {\n+ \n+    protected MinpackFunction(int m,\n+                              double[] startParams,\n+                              double   theoreticalStartCost,\n+                              double   theoreticalMinCost,\n+                              double[] theoreticalMinParams) {\n+      this.m = m;\n+      this.n = startParams.length;\n+      parameters = new EstimatedParameter[n];\n+      for (int i = 0; i < n; ++i) {\n+        parameters[i] = new EstimatedParameter(\"p\" + i, startParams[i]);\n+      }\n+      this.theoreticalStartCost = theoreticalStartCost;\n+      this.theoreticalMinCost   = theoreticalMinCost;\n+      this.theoreticalMinParams = theoreticalMinParams;\n+      this.costAccuracy         = 1.0e-8;\n+      this.paramsAccuracy       = 1.0e-5;\n+    }\n+\n+    protected static double[] buildArray(int n, double x) {\n+      double[] array = new double[n];\n+      Arrays.fill(array, x);\n+      return array;\n+    }\n+\n+    protected void setCostAccuracy(double costAccuracy) {\n+      this.costAccuracy = costAccuracy;\n+    }\n+\n+    protected void setParamsAccuracy(double paramsAccuracy) {\n+      this.paramsAccuracy = paramsAccuracy;\n+    }\n+\n+    public int getN() {\n+      return parameters.length;\n+    }\n+\n+    public boolean checkTheoreticalStartCost(double rms) {\n+      double threshold = costAccuracy * (1.0 + theoreticalStartCost);\n+      return Math.abs(Math.sqrt(m) * rms - theoreticalStartCost) <= threshold;\n+    }\n+\n+    public boolean checkTheoreticalMinCost(double rms) {\n+      double threshold = costAccuracy * (1.0 + theoreticalMinCost);\n+     return Math.abs(Math.sqrt(m) * rms - theoreticalMinCost) <= threshold;\n+    }\n+\n+    public boolean checkTheoreticalMinParams() {\n+      if (theoreticalMinParams != null) {\n+        for (int i = 0; i < theoreticalMinParams.length; ++i) {\n+          double mi = theoreticalMinParams[i];\n+          double vi = parameters[i].getEstimate();\n+          if (Math.abs(mi - vi) > (paramsAccuracy * (1.0 + Math.abs(mi)))) {\n+            return false;\n+          }\n+        }\n+      }\n+      return true;\n+    }\n+ \n+    public WeightedMeasurement[] getMeasurements() {\n+      WeightedMeasurement[] measurements = new WeightedMeasurement[m];\n+      for (int i = 0; i < m; ++i) {\n+        measurements[i] = new MinpackMeasurement(i);\n+      }\n+      return measurements;\n+    }\n+\n+    public EstimatedParameter[] getUnboundParameters() {\n+      return parameters;\n+    }\n+\n+    public EstimatedParameter[] getAllParameters() {\n+      return parameters;\n+    }\n+\n+    protected abstract double[][] getJacobian();\n+\n+    protected abstract double[] getResiduals();\n+\n+    private class MinpackMeasurement extends WeightedMeasurement {\n+\n+      public MinpackMeasurement(int index) {\n+        super(1.0, 0.0);\n+        this.index = index;\n+      }\n+\n+      public double getTheoreticalValue() {\n+        // this is obviously NOT efficient as we recompute the whole vector\n+        // each time we need only one element, but it is only for test\n+        // purposes and is simpler to check.\n+        // This implementation should NOT be taken as an example, it is ugly!\n+        return getResiduals()[index];\n+      }\n+\n+      public double getPartial(EstimatedParameter parameter) {\n+        // this is obviously NOT efficient as we recompute the whole jacobian\n+        // each time we need only one element, but it is only for test\n+        // purposes and is simpler to check.\n+        // This implementation should NOT be taken as an example, it is ugly!\n+        for (int j = 0; j < n; ++j) {\n+          if (parameter == parameters[j]) {\n+            return getJacobian()[index][j];\n+          }\n+        }\n+        return 0;\n+      }\n+\n+      private int index;\n+      private static final long serialVersionUID = 1L;\n+\n+    }\n+\n+    protected int                  n;\n+    protected int                  m;\n+    protected EstimatedParameter[] parameters;\n+    protected double               theoreticalStartCost;\n+    protected double               theoreticalMinCost;\n+    protected double[]             theoreticalMinParams;\n+    protected double               costAccuracy;\n+    protected double               paramsAccuracy;\n+\n+  }\n+\n+  private static class LinearFullRankFunction extends MinpackFunction {\n+\n+    public LinearFullRankFunction(int m, int n, double x0,\n+                                  double theoreticalStartCost,\n+                                  double theoreticalMinCost) {\n+      super(m, buildArray(n, x0), theoreticalStartCost,\n+            theoreticalMinCost, buildArray(n, -1.0));\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double t = 2.0 / m;\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+        for (int j = 0; j < n; ++j) {\n+          jacobian[i][j] = (i == j) ? (1 - t) : -t;\n+        }\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double sum = 0;\n+      for (int i = 0; i < n; ++i) {\n+        sum += parameters[i].getEstimate();\n+      }\n+      double t  = 1 + 2 * sum / m;\n+      double[] f = new double[m];\n+      for (int i = 0; i < n; ++i) {\n+        f[i] = parameters[i].getEstimate() - t;\n+      }\n+      Arrays.fill(f, n, m, -t);\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class LinearRank1Function extends MinpackFunction {\n+\n+    public LinearRank1Function(int m, int n, double x0,\n+                                  double theoreticalStartCost,\n+                                  double theoreticalMinCost) {\n+      super(m, buildArray(n, x0), theoreticalStartCost, theoreticalMinCost, null);\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+        for (int j = 0; j < n; ++j) {\n+          jacobian[i][j] = (i + 1) * (j + 1);\n+        }\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double[] f = new double[m];\n+      double sum = 0;\n+      for (int i = 0; i < n; ++i) {\n+        sum += (i + 1) * parameters[i].getEstimate();\n+      }\n+      for (int i = 0; i < m; ++i) {\n+        f[i] = (i + 1) * sum - 1;\n+      }\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class LinearRank1ZeroColsAndRowsFunction extends MinpackFunction {\n+\n+    public LinearRank1ZeroColsAndRowsFunction(int m, int n, double x0) {\n+      super(m, buildArray(n, x0),\n+            Math.sqrt(m + (n+1)*(n-2)*(m-2)*(m-1) * ((n+1)*(n-2)*(2*m-3) - 12) / 24.0),\n+            Math.sqrt((m * (m + 3) - 6) / (2.0 * (2 * m - 3))),\n+            null);\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+        jacobian[i][0] = 0;\n+        for (int j = 1; j < (n - 1); ++j) {\n+          if (i == 0) {\n+            jacobian[i][j] = 0;\n+          } else if (i != (m - 1)) {\n+            jacobian[i][j] = i * (j + 1);\n+          } else {\n+            jacobian[i][j] = 0;\n+          }\n+        }\n+        jacobian[i][n - 1] = 0;\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double[] f = new double[m];\n+      double sum = 0;\n+      for (int i = 1; i < (n - 1); ++i) {\n+        sum += (i + 1) * parameters[i].getEstimate();\n+      }\n+      for (int i = 0; i < (m - 1); ++i) {\n+        f[i] = i * sum - 1;\n+      }\n+      f[m - 1] = -1;\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class RosenbrockFunction extends MinpackFunction {\n+\n+    public RosenbrockFunction(double[] startParams, double theoreticalStartCost) {\n+      super(2, startParams, theoreticalStartCost, 0.0, buildArray(2, 1.0));\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double x1 = parameters[0].getEstimate();\n+      return new double[][] { { -20 * x1, 10 }, { -1, 0 } };\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      return new double[] { 10 * (x2 - x1 * x1), 1 - x1 };\n+    }\n+\n+  }\n+\n+  private static class HelicalValleyFunction extends MinpackFunction {\n+\n+    public HelicalValleyFunction(double[] startParams,\n+                                 double theoreticalStartCost) {\n+      super(3, startParams, theoreticalStartCost, 0.0,\n+            new double[] { 1.0, 0.0, 0.0 });\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double tmpSquare = x1 * x1 + x2 * x2;\n+      double tmp1 = twoPi * tmpSquare;\n+      double tmp2 = Math.sqrt(tmpSquare);\n+      return new double[][] {\n+        {  100 * x2 / tmp1, -100 * x1 / tmp1, 10 },\n+        { 10 * x1 / tmp2, 10 * x2 / tmp2, 0 },\n+        { 0, 0, 1 }\n+      };\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double tmp1;\n+      if (x1 == 0) {\n+        tmp1 = (x2 >= 0) ? 0.25 : -0.25;\n+      } else {\n+        tmp1 = Math.atan(x2 / x1) / twoPi;\n+        if (x1 < 0) {\n+          tmp1 += 0.5;\n+        }\n+      }\n+      double tmp2 = Math.sqrt(x1 * x1 + x2 * x2);\n+      return new double[] {\n+        10.0 * (x3 - 10 * tmp1),\n+        10.0 * (tmp2 - 1),\n+        x3\n+      };\n+    }\n+\n+    private static final double twoPi = 2.0 * Math.PI;\n+\n+  }\n+\n+  private static class PowellSingularFunction extends MinpackFunction {\n+\n+    public PowellSingularFunction(double[] startParams,\n+                                  double theoreticalStartCost) {\n+      super(4, startParams, theoreticalStartCost, 0.0, buildArray(4, 0.0));\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double x4 = parameters[3].getEstimate();\n+      return new double[][] {\n+        { 1, 10, 0, 0 },\n+        { 0, 0, sqrt5, -sqrt5 },\n+        { 0, 2 * (x2 - 2 * x3), -4 * (x2 - 2 * x3), 0 },\n+        { 2 * sqrt10 * (x1 - x4), 0, 0, -2 * sqrt10 * (x1 - x4) }\n+      };\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double x4 = parameters[3].getEstimate();\n+      return new double[] {\n+        x1 + 10 * x2,\n+        sqrt5 * (x3 - x4),\n+        (x2 - 2 * x3) * (x2 - 2 * x3),\n+        sqrt10 * (x1 - x4) * (x1 - x4)\n+      };\n+    }\n+\n+    private static final double sqrt5  = Math.sqrt( 5.0);\n+    private static final double sqrt10 = Math.sqrt(10.0);\n+\n+  }\n+\n+  private static class FreudensteinRothFunction extends MinpackFunction {\n+\n+    public FreudensteinRothFunction(double[] startParams,\n+                                    double theoreticalStartCost,\n+                                    double theoreticalMinCost,\n+                                    double[] theoreticalMinParams) {\n+      super(2, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double x2 = parameters[1].getEstimate();\n+      return new double[][] {\n+        { 1, x2 * (10 - 3 * x2) -  2 },\n+        { 1, x2 * ( 2 + 3 * x2) - 14, }\n+      };\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      return new double[] {\n+       -13.0 + x1 + ((5.0 - x2) * x2 -  2.0) * x2,\n+       -29.0 + x1 + ((1.0 + x2) * x2 - 14.0) * x2\n+      };\n+    }\n+\n+  }\n+\n+  private static class BardFunction extends MinpackFunction {\n+\n+    public BardFunction(double x0,\n+                        double theoreticalStartCost,\n+                        double theoreticalMinCost,\n+                        double[] theoreticalMinParams) {\n+      super(15, buildArray(3, x0), theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double   x2 = parameters[1].getEstimate();\n+      double   x3 = parameters[2].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp1 = i  + 1;\n+        double tmp2 = 15 - i;\n+        double tmp3 = (i <= 7) ? tmp1 : tmp2;\n+        double tmp4 = x2 * tmp2 + x3 * tmp3;\n+        tmp4 *= tmp4;\n+        jacobian[i] = new double[] { -1, tmp1 * tmp2 / tmp4, tmp1 * tmp3 / tmp4 };\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double   x1 = parameters[0].getEstimate();\n+      double   x2 = parameters[1].getEstimate();\n+      double   x3 = parameters[2].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp1 = i + 1;\n+        double tmp2 = 15 - i;\n+        double tmp3 = (i <= 7) ? tmp1 : tmp2;\n+        f[i] = y[i] - (x1 + tmp1 / (x2 * tmp2 + x3 * tmp3));\n+      }\n+      return f;\n+    }\n+\n+    private static final double[] y = {\n+      0.14, 0.18, 0.22, 0.25, 0.29,\n+      0.32, 0.35, 0.39, 0.37, 0.58,\n+      0.73, 0.96, 1.34, 2.10, 4.39\n+    };\n+\n+  }\n+\n+  private static class KowalikOsborneFunction extends MinpackFunction {\n+\n+    public KowalikOsborneFunction(double[] startParams,\n+                                  double theoreticalStartCost,\n+                                  double theoreticalMinCost,\n+                                  double[] theoreticalMinParams) {\n+      super(11, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+      if (theoreticalStartCost > 20.0) {\n+        setCostAccuracy(2.0e-4);\n+        setParamsAccuracy(5.0e-3);\n+      }\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double   x1 = parameters[0].getEstimate();\n+      double   x2 = parameters[1].getEstimate();\n+      double   x3 = parameters[2].getEstimate();\n+      double   x4 = parameters[3].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp = v[i] * (v[i] + x3) + x4;\n+        double j1  = -v[i] * (v[i] + x2) / tmp;\n+        double j2  = -v[i] * x1 / tmp;\n+        double j3  = j1 * j2;\n+        double j4  = j3 / v[i];\n+        jacobian[i] = new double[] { j1, j2, j3, j4 };\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double x4 = parameters[3].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        f[i] = y[i] - x1 * (v[i] * (v[i] + x2)) / (v[i] * (v[i] + x3) + x4);\n+      }\n+      return f;\n+    }\n+\n+    private static final double[] v = {\n+      4.0, 2.0, 1.0, 0.5, 0.25, 0.167, 0.125, 0.1, 0.0833, 0.0714, 0.0625\n+    };\n+\n+    private static final double[] y = {\n+      0.1957, 0.1947, 0.1735, 0.1600, 0.0844, 0.0627,\n+      0.0456, 0.0342, 0.0323, 0.0235, 0.0246\n+    };\n+\n+  }\n+\n+  private static class MeyerFunction extends MinpackFunction {\n+\n+    public MeyerFunction(double[] startParams,\n+                         double theoreticalStartCost,\n+                         double theoreticalMinCost,\n+                         double[] theoreticalMinParams) {\n+      super(16, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+      if (theoreticalStartCost > 1.0e6) {\n+        setCostAccuracy(7.0e-3);\n+        setParamsAccuracy(2.0e-2);\n+      }\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double   x1 = parameters[0].getEstimate();\n+      double   x2 = parameters[1].getEstimate();\n+      double   x3 = parameters[2].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = 5.0 * (i + 1) + 45.0 + x3;\n+        double tmp1 = x2 / temp;\n+        double tmp2 = Math.exp(tmp1);\n+        double tmp3 = x1 * tmp2 / temp;\n+        jacobian[i] = new double[] { tmp2, tmp3, -tmp1 * tmp3 };\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        f[i] = x1 * Math.exp(x2 / (5.0 * (i + 1) + 45.0 + x3)) - y[i];\n+      }\n+     return f;\n+    }\n+\n+    private static final double[] y = {\n+      34780.0, 28610.0, 23650.0, 19630.0,\n+      16370.0, 13720.0, 11540.0,  9744.0,\n+       8261.0,  7030.0,  6005.0,  5147.0,\n+       4427.0,  3820.0,  3307.0,  2872.0                  \n+    };\n+\n+  }\n+\n+  private static class WatsonFunction extends MinpackFunction {\n+\n+    public WatsonFunction(int n, double x0,\n+                          double theoreticalStartCost,\n+                          double theoreticalMinCost,\n+                          double[] theoreticalMinParams) {\n+      super(31, buildArray(n, x0), theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    protected double[][] getJacobian() {\n+\n+      double[][] jacobian = new double[m][];\n+\n+      for (int i = 0; i < (m - 2); ++i) {\n+        double div = (i + 1) / 29.0;\n+        double s2  = 0.0;\n+        double dx  = 1.0;\n+        for (int j = 0; j < n; ++j) {\n+          s2 += dx * parameters[j].getEstimate();\n+          dx *= div;\n+        }\n+        double temp= 2 * div * s2;\n+        dx = 1.0 / div;\n+        jacobian[i] = new double[n];\n+        for (int j = 0; j < n; ++j) {\n+          jacobian[i][j] = dx * (j - temp);\n+          dx *= div;\n+        }\n+      }\n+\n+      jacobian[m - 2]    = new double[n];\n+      jacobian[m - 2][0] = 1;\n+\n+      jacobian[m - 1]   = new double[n];\n+      jacobian[m - 1][0]= -2 * parameters[0].getEstimate();\n+      jacobian[m - 1][1]= 1;\n+\n+      return jacobian;\n+\n+    }\n+\n+    protected double[] getResiduals() {\n+     double[] f = new double[m];\n+     for (int i = 0; i < (m - 2); ++i) {\n+       double div = (i + 1) / 29.0;\n+       double s1 = 0;\n+       double dx = 1;\n+       for (int j = 1; j < n; ++j) {\n+         s1 += j * dx * parameters[j].getEstimate();\n+         dx *= div;\n+       }\n+       double s2 =0;\n+       dx =1;\n+       for (int j = 0; j < n; ++j) {\n+         s2 += dx * parameters[j].getEstimate();\n+         dx *= div;\n+       }\n+       f[i] = s1 - s2 * s2 - 1;\n+     }\n+\n+     double x1 = parameters[0].getEstimate();\n+     double x2 = parameters[1].getEstimate();\n+     f[m - 2] = x1;\n+     f[m - 1] = x2 - x1 * x1 - 1;\n+\n+     return f;\n+\n+    }\n+\n+  }\n+\n+  private static class Box3DimensionalFunction extends MinpackFunction {\n+\n+    public Box3DimensionalFunction(int m, double[] startParams,\n+                                   double theoreticalStartCost) {\n+      super(m, startParams, theoreticalStartCost,\n+            0.0, new double[] { 1.0, 10.0, 1.0 });\n+   }\n+\n+    protected double[][] getJacobian() {\n+      double   x1 = parameters[0].getEstimate();\n+      double   x2 = parameters[1].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp = (i + 1) / 10.0;\n+        jacobian[i] = new double[] {\n+          -tmp * Math.exp(-tmp * x1),\n+           tmp * Math.exp(-tmp * x2),\n+          Math.exp(-i - 1) - Math.exp(-tmp)\n+        };\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double tmp = (i + 1) / 10.0;\n+        f[i] = Math.exp(-tmp * x1) - Math.exp(-tmp * x2)\n+             + (Math.exp(-i - 1) - Math.exp(-tmp)) * x3;\n+      }\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class JennrichSampsonFunction extends MinpackFunction {\n+\n+    public JennrichSampsonFunction(int m, double[] startParams,\n+                                   double theoreticalStartCost,\n+                                   double theoreticalMinCost,\n+                                   double[] theoreticalMinParams) {\n+      super(m, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double   x1 = parameters[0].getEstimate();\n+      double   x2 = parameters[1].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double t = i + 1;\n+        jacobian[i] = new double[] { -t * Math.exp(t * x1), -t * Math.exp(t * x2) };\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = i + 1;\n+        f[i] = 2 + 2 * temp - Math.exp(temp * x1) - Math.exp(temp * x2);\n+      }\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class BrownDennisFunction extends MinpackFunction {\n+\n+    public BrownDennisFunction(int m, double[] startParams,\n+                               double theoreticalStartCost,\n+                               double theoreticalMinCost,\n+                               double[] theoreticalMinParams) {\n+      super(m, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double   x1 = parameters[0].getEstimate();\n+      double   x2 = parameters[1].getEstimate();\n+      double   x3 = parameters[2].getEstimate();\n+      double   x4 = parameters[3].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = (i + 1) / 5.0;\n+        double ti   = Math.sin(temp);\n+        double tmp1 = x1 + temp * x2 - Math.exp(temp);\n+        double tmp2 = x3 + ti   * x4 - Math.cos(temp);\n+        jacobian[i] = new double[] {\n+          2 * tmp1, 2 * temp * tmp1, 2 * tmp2, 2 * ti * tmp2\n+        };\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double x4 = parameters[3].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = (i + 1) / 5.0;\n+        double tmp1 = x1 + temp * x2 - Math.exp(temp);\n+        double tmp2 = x3 + Math.sin(temp) * x4 - Math.cos(temp);\n+        f[i] = tmp1 * tmp1 + tmp2 * tmp2;\n+      }\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class ChebyquadFunction extends MinpackFunction {\n+\n+    private static double[] buildChebyquadArray(int n, double factor) {\n+      double[] array = new double[n];\n+      double inv = factor / (n + 1);\n+      for (int i = 0; i < n; ++i) {\n+        array[i] = (i + 1) * inv;\n+      }\n+      return array;\n+    }\n+\n+    public ChebyquadFunction(int n, int m, double factor,\n+                             double theoreticalStartCost,\n+                             double theoreticalMinCost,\n+                             double[] theoreticalMinParams) {\n+      super(m, buildChebyquadArray(n, factor), theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    protected double[][] getJacobian() {\n+\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+      }\n+\n+      double dx = 1.0 / n;\n+      for (int j = 0; j < n; ++j) {\n+        double tmp1 = 1;\n+        double tmp2 = 2 * parameters[j].getEstimate() - 1;\n+        double temp = 2 * tmp2;\n+        double tmp3 = 0;\n+        double tmp4 = 2;\n+        for (int i = 0; i < m; ++i) {\n+          jacobian[i][j] = dx * tmp4;\n+          double ti = 4 * tmp2 + temp * tmp4 - tmp3;\n+          tmp3 = tmp4;\n+          tmp4 = ti;\n+          ti   = temp * tmp2 - tmp1;\n+          tmp1 = tmp2;\n+          tmp2 = ti;\n+        }\n+      }\n+\n+      return jacobian;\n+\n+    }\n+\n+    protected double[] getResiduals() {\n+\n+      double[] f = new double[m];\n+\n+      for (int j = 0; j < n; ++j) {\n+        double tmp1 = 1;\n+        double tmp2 = 2 * parameters[j].getEstimate() - 1;\n+        double temp = 2 * tmp2;\n+        for (int i = 0; i < m; ++i) {\n+          f[i] += tmp2;\n+          double ti = temp * tmp2 - tmp1;\n+          tmp1 = tmp2;\n+          tmp2 = ti;\n+        }\n+      }\n+\n+      double dx = 1.0 / n;\n+      boolean iev = false;\n+      for (int i = 0; i < m; ++i) {\n+        f[i] *= dx;\n+        if (iev) {\n+          f[i] += 1.0 / (i * (i + 2));\n+        }\n+        iev = ! iev;\n+      }\n+\n+      return f;\n+\n+    }\n+\n+  }\n+\n+  private static class BrownAlmostLinearFunction extends MinpackFunction {\n+\n+    public BrownAlmostLinearFunction(int m, double factor,\n+                                     double theoreticalStartCost,\n+                                     double theoreticalMinCost,\n+                                     double[] theoreticalMinParams) {\n+      super(m, buildArray(m, factor), theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        jacobian[i] = new double[n];\n+      }\n+\n+      double prod = 1;\n+      for (int j = 0; j < n; ++j) {\n+        prod *= parameters[j].getEstimate();\n+        for (int i = 0; i < n; ++i) {\n+          jacobian[i][j] = 1;\n+        }\n+        jacobian[j][j] = 2;\n+      }\n+\n+      for (int j = 0; j < n; ++j) {\n+        EstimatedParameter vj = parameters[j];\n+        double temp = vj.getEstimate();\n+        if (temp == 0) {\n+          temp = 1;\n+          prod = 1;\n+          for (int k = 0; k < n; ++k) {\n+            if (k != j) {\n+              prod *= parameters[k].getEstimate();\n+            }\n+          }\n+        }\n+        jacobian[n - 1][j] = prod / temp;\n+      }\n+\n+      return jacobian;\n+\n+    }\n+\n+    protected double[] getResiduals() {\n+      double[] f = new double[m];\n+      double sum  = -(n + 1);\n+      double prod = 1;\n+      for (int j = 0; j < n; ++j) {\n+        sum  += parameters[j].getEstimate();\n+        prod *= parameters[j].getEstimate();\n+      }\n+      for (int i = 0; i < n; ++i) {\n+        f[i] = parameters[i].getEstimate() + sum;\n+      }\n+      f[n - 1] = prod - 1;\n+      return f;\n+    }\n+\n+  }\n+\n+  private static class Osborne1Function extends MinpackFunction {\n+\n+    public Osborne1Function(double[] startParams,\n+                            double theoreticalStartCost,\n+                            double theoreticalMinCost,\n+                            double[] theoreticalMinParams) {\n+      super(33, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double   x2 = parameters[1].getEstimate();\n+      double   x3 = parameters[2].getEstimate();\n+      double   x4 = parameters[3].getEstimate();\n+      double   x5 = parameters[4].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = 10.0 * i;\n+        double tmp1 = Math.exp(-temp * x4);\n+        double tmp2 = Math.exp(-temp * x5);\n+        jacobian[i] = new double[] {\n+          -1, -tmp1, -tmp2, temp * x2 * tmp1, temp * x3 * tmp2\n+        };\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x1 = parameters[0].getEstimate();\n+      double x2 = parameters[1].getEstimate();\n+      double x3 = parameters[2].getEstimate();\n+      double x4 = parameters[3].getEstimate();\n+      double x5 = parameters[4].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = 10.0 * i;\n+        double tmp1 = Math.exp(-temp * x4);\n+        double tmp2 = Math.exp(-temp * x5);\n+        f[i] = y[i] - (x1 + x2 * tmp1 + x3 * tmp2);\n+      }\n+      return f;\n+    }\n+\n+    private static final double[] y = {\n+      0.844, 0.908, 0.932, 0.936, 0.925, 0.908, 0.881, 0.850, 0.818, 0.784, 0.751,\n+      0.718, 0.685, 0.658, 0.628, 0.603, 0.580, 0.558, 0.538, 0.522, 0.506, 0.490,\n+      0.478, 0.467, 0.457, 0.448, 0.438, 0.431, 0.424, 0.420, 0.414, 0.411, 0.406\n+    };\n+\n+  }\n+\n+  private static class Osborne2Function extends MinpackFunction {\n+\n+    public Osborne2Function(double[] startParams,\n+                            double theoreticalStartCost,\n+                            double theoreticalMinCost,\n+                            double[] theoreticalMinParams) {\n+      super(65, startParams, theoreticalStartCost,\n+            theoreticalMinCost, theoreticalMinParams);\n+    }\n+\n+    protected double[][] getJacobian() {\n+      double   x01 = parameters[0].getEstimate();\n+      double   x02 = parameters[1].getEstimate();\n+      double   x03 = parameters[2].getEstimate();\n+      double   x04 = parameters[3].getEstimate();\n+      double   x05 = parameters[4].getEstimate();\n+      double   x06 = parameters[5].getEstimate();\n+      double   x07 = parameters[6].getEstimate();\n+      double   x08 = parameters[7].getEstimate();\n+      double   x09 = parameters[8].getEstimate();\n+      double   x10 = parameters[9].getEstimate();\n+      double   x11 = parameters[10].getEstimate();\n+      double[][] jacobian = new double[m][];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = i / 10.0;\n+        double tmp1 = Math.exp(-x05 * temp);\n+        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));\n+        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));\n+        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));\n+        jacobian[i] = new double[] {\n+          -tmp1,\n+          -tmp2,\n+          -tmp3,\n+          -tmp4,\n+          temp * x01 * tmp1,\n+          x02 * (temp - x09) * (temp - x09) * tmp2,\n+          x03 * (temp - x10) * (temp - x10) * tmp3,\n+          x04 * (temp - x11) * (temp - x11) * tmp4,\n+          -2 * x02 * x06 * (temp - x09) * tmp2,\n+          -2 * x03 * x07 * (temp - x10) * tmp3,\n+          -2 * x04 * x08 * (temp - x11) * tmp4\n+        };\n+      }\n+      return jacobian;\n+    }\n+\n+    protected double[] getResiduals() {\n+      double x01 = parameters[0].getEstimate();\n+      double x02 = parameters[1].getEstimate();\n+      double x03 = parameters[2].getEstimate();\n+      double x04 = parameters[3].getEstimate();\n+      double x05 = parameters[4].getEstimate();\n+      double x06 = parameters[5].getEstimate();\n+      double x07 = parameters[6].getEstimate();\n+      double x08 = parameters[7].getEstimate();\n+      double x09 = parameters[8].getEstimate();\n+      double x10 = parameters[9].getEstimate();\n+      double x11 = parameters[10].getEstimate();\n+      double[] f = new double[m];\n+      for (int i = 0; i < m; ++i) {\n+        double temp = i / 10.0;\n+        double tmp1 = Math.exp(-x05 * temp);\n+        double tmp2 = Math.exp(-x06 * (temp - x09) * (temp - x09));\n+        double tmp3 = Math.exp(-x07 * (temp - x10) * (temp - x10));\n+        double tmp4 = Math.exp(-x08 * (temp - x11) * (temp - x11));\n+        f[i] = y[i] - (x01 * tmp1 + x02 * tmp2 + x03 * tmp3 + x04 * tmp4);\n+      }\n+      return f;\n+    }\n+\n+    private static final double[] y = {\n+      1.366, 1.191, 1.112, 1.013, 0.991,\n+      0.885, 0.831, 0.847, 0.786, 0.725,\n+      0.746, 0.679, 0.608, 0.655, 0.616,\n+      0.606, 0.602, 0.626, 0.651, 0.724,\n+      0.649, 0.649, 0.694, 0.644, 0.624,\n+      0.661, 0.612, 0.558, 0.533, 0.495,\n+      0.500, 0.423, 0.395, 0.375, 0.372,\n+      0.391, 0.396, 0.405, 0.428, 0.429,\n+      0.523, 0.562, 0.607, 0.653, 0.672,\n+      0.708, 0.633, 0.668, 0.645, 0.632,\n+      0.591, 0.559, 0.597, 0.625, 0.739,\n+      0.710, 0.729, 0.720, 0.636, 0.581,\n+      0.428, 0.292, 0.162, 0.098, 0.054\n+    };\n+\n+  }\n+\n+  public static Test suite() {\n+    return new TestSuite(MinpackTest.class);\n+  }\n+\n+}\n--- /dev/null\n+++ b/src/mantissa/tests-src/org/spaceroots/mantissa/ode/StepProblem.java\n+package org.spaceroots.mantissa.ode;\n+\n+\n+public class StepProblem\n+  implements FirstOrderDifferentialEquations, SwitchingFunction {\n+\n+  public StepProblem(double rateBefore, double rateAfter,\n+                     double switchTime) {\n+    this.rateAfter  = rateAfter;\n+    this.switchTime = switchTime;\n+    setRate(rateBefore);\n+  }\n+\n+  public void computeDerivatives(double t, double[] y, double[] yDot) {\n+    yDot[0] = rate;\n+  }\n+\n+  public int getDimension() {\n+    return 1;\n+  }\n+\n+  public void setRate(double rate) {\n+    this.rate = rate;\n+  }\n+\n+  public int eventOccurred(double t, double[] y) {\n+    setRate(rateAfter);\n+    return RESET_DERIVATIVES;\n+  }\n+\n+  public double g(double t, double[] y) {\n+    return t - switchTime;\n+  }\n+\n+  public void resetState(double t, double[] y) {\n+  }\n+\n+  private double rate;\n+  private double rateAfter;\n+  private double switchTime;\n+\n+  private static final long serialVersionUID = 7590601995477504318L;\n+\n+}", "timestamp": 1168894731, "metainfo": ""}