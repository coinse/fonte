{"sha": "e511f759c4b626c4b884500fe4280885dbdaf453", "log": "Improved usability of the geometry package. From a developer point of view, all the changes are related. From a user point of view, they are independent changes.   - added several convenience methods for Vector3D and Rotation  - replaced public no argument constructors with IDENTITY or ZERO    static instances for immutable classes Vector3D and Rotation  - fixed inconsistencies in the naming scheme for static fields in    Vector3D and Rotation with respect to the overall library   ", "commit": "\n--- a/src/java/org/apache/commons/math/geometry/Rotation.java\n+++ b/src/java/org/apache/commons/math/geometry/Rotation.java\n \n public class Rotation implements Serializable {\n \n-  /** Build the identity rotation.\n-   */\n-  public Rotation() {\n-    q0 = 1;\n-    q1 = 0;\n-    q2 = 0;\n-    q3 = 0;\n-  }\n+  /** Identity rotation. */\n+  public static final Rotation IDENTITY = new Rotation(1.0, 0.0, 0.0, 0.0, false);\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -2153622329907944313L;\n+\n+  /** Scalar coordinate of the quaternion. */\n+  private final double q0;\n+\n+  /** First coordinate of the vectorial part of the quaternion. */\n+  private final double q1;\n+\n+  /** Second coordinate of the vectorial part of the quaternion. */\n+  private final double q2;\n+\n+  /** Third coordinate of the vectorial part of the quaternion. */\n+  private final double q3;\n \n   /** Build a rotation from the quaternion coordinates.\n    * <p>A rotation can be built from a <em>normalized</em> quaternion,\n       // (-r) (Vector3D.plusI) coordinates are :\n       // cos (psi) cos (theta), -sin (psi) cos (theta), sin (theta)\n       // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n-      Vector3D v1 = applyTo(Vector3D.plusK);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusI);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n       if  ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(true);\n       }\n       // (-r) (Vector3D.plusI) coordinates are :\n       // cos (theta) cos (psi), -sin (psi), sin (theta) cos (psi)\n       // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n-      Vector3D v1 = applyTo(Vector3D.plusJ);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusI);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n       if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(true);\n       }\n       // (-r) (Vector3D.plusJ) coordinates are :\n       // sin (psi) cos (phi), cos (psi) cos (phi), -sin (phi)\n       // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n-      Vector3D v1 = applyTo(Vector3D.plusK);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusJ);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n       if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(true);\n       }\n       // (-r) (Vector3D.plusJ) coordinates are :\n       // sin (psi), cos (phi) cos (psi), -sin (phi) cos (psi)\n       // and we can choose to have psi in the interval [-PI/2 ; +PI/2]\n-      Vector3D v1 = applyTo(Vector3D.plusI);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusJ);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n       if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(true);\n       }\n       // (-r) (Vector3D.plusK) coordinates are :\n       // -sin (theta) cos (phi), sin (phi), cos (theta) cos (phi)\n       // and we can choose to have phi in the interval [-PI/2 ; +PI/2]\n-      Vector3D v1 = applyTo(Vector3D.plusJ);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusK);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n       if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(true);\n       }\n       // (-r) (Vector3D.plusK) coordinates are :\n       // -sin (theta), sin (phi) cos (theta), cos (phi) cos (theta)\n       // and we can choose to have theta in the interval [-PI/2 ; +PI/2]\n-      Vector3D v1 = applyTo(Vector3D.plusI);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusK);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n       if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(true);\n       }\n       // (-r) (Vector3D.plusI) coordinates are :\n       // cos (theta), sin (theta) sin (phi2), sin (theta) cos (phi2)\n       // and we can choose to have theta in the interval [0 ; PI]\n-      Vector3D v1 = applyTo(Vector3D.plusI);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusI);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n       if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(false);\n       }\n       // (-r) (Vector3D.plusI) coordinates are :\n       // cos (psi), -sin (psi) cos (phi2), sin (psi) sin (phi2)\n       // and we can choose to have psi in the interval [0 ; PI]\n-      Vector3D v1 = applyTo(Vector3D.plusI);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusI);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_I);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_I);\n       if ((v2.getX() < -0.9999999999) || (v2.getX() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(false);\n       }\n       // (-r) (Vector3D.plusJ) coordinates are :\n       // sin (phi) sin (theta2), cos (phi), -sin (phi) cos (theta2)\n       // and we can choose to have phi in the interval [0 ; PI]\n-      Vector3D v1 = applyTo(Vector3D.plusJ);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusJ);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n       if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(false);\n       }\n       // (-r) (Vector3D.plusJ) coordinates are :\n       // sin (psi) cos (theta2), cos (psi), sin (psi) sin (theta2)\n       // and we can choose to have psi in the interval [0 ; PI]\n-      Vector3D v1 = applyTo(Vector3D.plusJ);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusJ);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_J);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_J);\n       if ((v2.getY() < -0.9999999999) || (v2.getY() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(false);\n       }\n       // (-r) (Vector3D.plusK) coordinates are :\n       // sin (phi) sin (psi2), sin (phi) cos (psi2), cos (phi)\n       // and we can choose to have phi in the interval [0 ; PI]\n-      Vector3D v1 = applyTo(Vector3D.plusK);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusK);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n       if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(false);\n       }\n       // (-r) (Vector3D.plusK) coordinates are :\n       // -sin (theta) cos (psi2), sin (theta) sin (psi2), cos (theta)\n       // and we can choose to have theta in the interval [0 ; PI]\n-      Vector3D v1 = applyTo(Vector3D.plusK);\n-      Vector3D v2 = applyInverseTo(Vector3D.plusK);\n+      Vector3D v1 = applyTo(Vector3D.PLUS_K);\n+      Vector3D v2 = applyInverseTo(Vector3D.PLUS_K);\n       if ((v2.getZ() < -0.9999999999) || (v2.getZ() > 0.9999999999)) {\n         throw new CardanEulerSingularityException(false);\n       }\n                                           });\n   }\n \n-  /** Scalar coordinate of the quaternion. */\n-  private final double q0;\n-\n-  /** First coordinate of the vectorial part of the quaternion. */\n-  private final double q1;\n-\n-  /** Second coordinate of the vectorial part of the quaternion. */\n-  private final double q2;\n-\n-  /** Third coordinate of the vectorial part of the quaternion. */\n-  private final double q3;\n-\n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = 8225864499430109352L;\n+  /** Compute the <i>distance</i> between two rotations.\n+   * <p>The <i>distance</i> is intended here as a way to check if two\n+   * rotations are almost similar (i.e. they transform vectors the same way)\n+   * or very different. It is mathematically defined as the angle of\n+   * the rotation r that prepended to one of the rotations gives the other\n+   * one:</p>\n+   * <pre>\n+   *        r<sub>1</sub>(r) = r<sub>2</sub>\n+   * </pre>\n+   * <p>This distance is an angle between 0 and &pi;. Its value is the smallest\n+   * possible upper bound of the angle in radians between r<sub>1</sub>(v)\n+   * and r<sub>2</sub>(v) for all possible vectors v. This upper bound is\n+   * reached for some v. The distance is equal to 0 if and only if the two\n+   * rotations are identical.</p>\n+   * <p>Comparing two rotations should always be done using this value rather\n+   * than for example comparing the components of the quaternions. It is much\n+   * more stable, and has a geometric meaning. Also comparing quaternions\n+   * components is error prone since for example quaternions (0.36, 0.48, -0.48, -0.64)\n+   * and (-0.36, -0.48, 0.48, 0.64) represent exactly the same rotation despite\n+   * their components are different (they are exact opposites).</p>\n+   * @param r1 first rotation\n+   * @param r2 second rotation\n+   * @return <i>distance</i> between r1 and r2\n+   */\n+  public static double distance(Rotation r1, Rotation r2) {\n+      return r1.applyInverseTo(r2).getAngle();\n+  }\n \n }\n--- a/src/java/org/apache/commons/math/geometry/RotationOrder.java\n+++ b/src/java/org/apache/commons/math/geometry/RotationOrder.java\n    * around Z\n    */\n   public static final RotationOrder XYZ =\n-    new RotationOrder(\"XYZ\", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusK);\n+    new RotationOrder(\"XYZ\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_K);\n \n   /** Set of Cardan angles.\n    * this ordered set of rotations is around X, then around Z, then\n    * around Y\n    */\n   public static final RotationOrder XZY =\n-    new RotationOrder(\"XZY\", Vector3D.plusI, Vector3D.plusK, Vector3D.plusJ);\n+    new RotationOrder(\"XZY\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_J);\n \n   /** Set of Cardan angles.\n    * this ordered set of rotations is around Y, then around X, then\n    * around Z\n    */\n   public static final RotationOrder YXZ =\n-    new RotationOrder(\"YXZ\", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusK);\n+    new RotationOrder(\"YXZ\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_K);\n \n   /** Set of Cardan angles.\n    * this ordered set of rotations is around Y, then around Z, then\n    * around X\n    */\n   public static final RotationOrder YZX =\n-    new RotationOrder(\"YZX\", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusI);\n+    new RotationOrder(\"YZX\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_I);\n \n   /** Set of Cardan angles.\n    * this ordered set of rotations is around Z, then around X, then\n    * around Y\n    */\n   public static final RotationOrder ZXY =\n-    new RotationOrder(\"ZXY\", Vector3D.plusK, Vector3D.plusI, Vector3D.plusJ);\n+    new RotationOrder(\"ZXY\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_J);\n \n   /** Set of Cardan angles.\n    * this ordered set of rotations is around Z, then around Y, then\n    * around X\n    */\n   public static final RotationOrder ZYX =\n-    new RotationOrder(\"ZYX\", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusI);\n+    new RotationOrder(\"ZYX\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_I);\n \n   /** Set of Euler angles.\n    * this ordered set of rotations is around X, then around Y, then\n    * around X\n    */\n   public static final RotationOrder XYX =\n-    new RotationOrder(\"XYX\", Vector3D.plusI, Vector3D.plusJ, Vector3D.plusI);\n+    new RotationOrder(\"XYX\", Vector3D.PLUS_I, Vector3D.PLUS_J, Vector3D.PLUS_I);\n \n   /** Set of Euler angles.\n    * this ordered set of rotations is around X, then around Z, then\n    * around X\n    */\n   public static final RotationOrder XZX =\n-    new RotationOrder(\"XZX\", Vector3D.plusI, Vector3D.plusK, Vector3D.plusI);\n+    new RotationOrder(\"XZX\", Vector3D.PLUS_I, Vector3D.PLUS_K, Vector3D.PLUS_I);\n \n   /** Set of Euler angles.\n    * this ordered set of rotations is around Y, then around X, then\n    * around Y\n    */\n   public static final RotationOrder YXY =\n-    new RotationOrder(\"YXY\", Vector3D.plusJ, Vector3D.plusI, Vector3D.plusJ);\n+    new RotationOrder(\"YXY\", Vector3D.PLUS_J, Vector3D.PLUS_I, Vector3D.PLUS_J);\n \n   /** Set of Euler angles.\n    * this ordered set of rotations is around Y, then around Z, then\n    * around Y\n    */\n   public static final RotationOrder YZY =\n-    new RotationOrder(\"YZY\", Vector3D.plusJ, Vector3D.plusK, Vector3D.plusJ);\n+    new RotationOrder(\"YZY\", Vector3D.PLUS_J, Vector3D.PLUS_K, Vector3D.PLUS_J);\n \n   /** Set of Euler angles.\n    * this ordered set of rotations is around Z, then around X, then\n    * around Z\n    */\n   public static final RotationOrder ZXZ =\n-    new RotationOrder(\"ZXZ\", Vector3D.plusK, Vector3D.plusI, Vector3D.plusK);\n+    new RotationOrder(\"ZXZ\", Vector3D.PLUS_K, Vector3D.PLUS_I, Vector3D.PLUS_K);\n \n   /** Set of Euler angles.\n    * this ordered set of rotations is around Z, then around Y, then\n    * around Z\n    */\n   public static final RotationOrder ZYZ =\n-    new RotationOrder(\"ZYZ\", Vector3D.plusK, Vector3D.plusJ, Vector3D.plusK);\n+    new RotationOrder(\"ZYZ\", Vector3D.PLUS_K, Vector3D.PLUS_J, Vector3D.PLUS_K);\n \n   /** Name of the rotations order. */\n   private final String name;\n--- a/src/java/org/apache/commons/math/geometry/Vector3D.java\n+++ b/src/java/org/apache/commons/math/geometry/Vector3D.java\n public class Vector3D\n   implements Serializable {\n \n+  /** Null vector (coordinates: 0, 0, 0). */\n+  public static final Vector3D ZERO   = new Vector3D(0, 0, 0);\n+\n   /** First canonical vector (coordinates: 1, 0, 0). */\n-  public static final Vector3D plusI = new Vector3D(1, 0, 0);\n+  public static final Vector3D PLUS_I = new Vector3D(1, 0, 0);\n \n   /** Opposite of the first canonical vector (coordinates: -1, 0, 0). */\n-  public static final Vector3D minusI = new Vector3D(-1, 0, 0);\n+  public static final Vector3D MINUS_I = new Vector3D(-1, 0, 0);\n \n   /** Second canonical vector (coordinates: 0, 1, 0). */\n-  public static final Vector3D plusJ = new Vector3D(0, 1, 0);\n+  public static final Vector3D PLUS_J = new Vector3D(0, 1, 0);\n \n   /** Opposite of the second canonical vector (coordinates: 0, -1, 0). */\n-  public static final Vector3D minusJ = new Vector3D(0, -1, 0);\n+  public static final Vector3D MINUS_J = new Vector3D(0, -1, 0);\n \n   /** Third canonical vector (coordinates: 0, 0, 1). */\n-  public static final Vector3D plusK = new Vector3D(0, 0, 1);\n+  public static final Vector3D PLUS_K = new Vector3D(0, 0, 1);\n \n   /** Opposite of the third canonical vector (coordinates: 0, 0, -1).  */\n-  public static final Vector3D minusK = new Vector3D(0, 0, -1);\n-\n-  /** Null vector (coordinates: 0, 0, 0). */\n-  public static final Vector3D zero   = new Vector3D(0, 0, 0);\n-\n-  /** Simple constructor.\n-   * Build a null vector.\n-   */\n-  public Vector3D() {\n-    x = 0;\n-    y = 0;\n-    z = 0;\n-  }\n+  public static final Vector3D MINUS_K = new Vector3D(0, 0, -1);\n+\n+  /** Serializable version identifier */\n+  private static final long serialVersionUID = -6155041477622120793L;\n+\n+  /** Abscissa. */\n+  private final double x;\n+\n+  /** Ordinate. */\n+  private final double y;\n+\n+  /** Height. */\n+  private final double z;\n \n   /** Simple constructor.\n    * Build a vector from its coordinates\n    */\n   public double getNorm() {\n     return Math.sqrt (x * x + y * y + z * z);\n+  }\n+\n+  /** Get the square of the norm for the vector.\n+   * @return square of the euclidian norm for the vector\n+   */\n+  public double getNormSq() {\n+    return x * x + y * y + z * z;\n   }\n \n   /** Get the azimuth of the vector.\n                         v1.x * v2.y - v1.y * v2.x);\n   }\n \n-  /** Abscissa. */\n-  private final double x;\n-\n-  /** Ordinate. */\n-  private final double y;\n-\n-  /** Height. */\n-  private final double z;\n-\n-  /** Serializable version identifier */\n-  private static final long serialVersionUID = -5721105387745193385L;\n-\n+  /** Compute the distance between two vectors.\n+   * <p>Calling this method is equivalent to calling:\n+   * <code>v1.subtract(v2).getNorm()</code> except that no intermediate\n+   * vector is built</p>\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the distance between v1 and v2\n+   */\n+  public static double distance(Vector3D v1, Vector3D v2) {\n+    final double dx = v2.x - v1.x;\n+    final double dy = v2.y - v1.y;\n+    final double dz = v2.z - v1.z;\n+    return Math.sqrt(dx * dx + dy * dy + dz * dz);\n+  }\n+\n+  /** Compute the square of the distance between two vectors.\n+   * <p>Calling this method is equivalent to calling:\n+   * <code>v1.subtract(v2).getNormSq()</code> except that no intermediate\n+   * vector is built</p>\n+   * @param v1 first vector\n+   * @param v2 second vector\n+   * @return the square of the distance between v1 and v2\n+   */\n+  public static double distanceSq(Vector3D v1, Vector3D v2) {\n+    final double dx = v2.x - v1.x;\n+    final double dy = v2.y - v1.y;\n+    final double dz = v2.z - v1.z;\n+    return dx * dx + dy * dy + dz * dz;\n+  }\n \n }\n--- a/src/test/org/apache/commons/math/geometry/RotationTest.java\n+++ b/src/test/org/apache/commons/math/geometry/RotationTest.java\n import org.apache.commons.math.geometry.Rotation;\n import org.apache.commons.math.geometry.RotationOrder;\n import org.apache.commons.math.geometry.Vector3D;\n+import org.apache.commons.math.util.MathUtils;\n \n import junit.framework.*;\n \n \n   public void testIdentity() {\n \n-    Rotation r = new Rotation();\n-    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);\n-    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);\n-    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);\n+    Rotation r = Rotation.IDENTITY;\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);\n     checkAngle(r.getAngle(), 0);\n \n     r = new Rotation(-1, 0, 0, 0, false);\n-    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);\n-    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);\n-    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);\n     checkAngle(r.getAngle(), 0);\n \n     r = new Rotation(42, 0, 0, 0, true);\n-    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusI);\n-    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusJ);\n-    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusK);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_I);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_J);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_K);\n     checkAngle(r.getAngle(), 0);\n \n   }\n   public void testAxisAngle() {\n \n     Rotation r = new Rotation(new Vector3D(10, 10, 10), 2 * Math.PI / 3);\n-    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusJ);\n-    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusK);\n-    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusI);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_J);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_K);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_I);\n     double s = 1 / Math.sqrt(3);\n     checkVector(r.getAxis(), new Vector3D(s, s, s));\n     checkAngle(r.getAngle(), 2 * Math.PI / 3);\n       fail(\"unexpected exception\");\n     }\n \n-    r = new Rotation(Vector3D.plusK, 1.5 * Math.PI);\n+    r = new Rotation(Vector3D.PLUS_K, 1.5 * Math.PI);\n     checkVector(r.getAxis(), new Vector3D(0, 0, -1));\n     checkAngle(r.getAngle(), 0.5 * Math.PI);\n \n-    r = new Rotation(Vector3D.plusJ, Math.PI);\n-    checkVector(r.getAxis(), Vector3D.plusJ);\n+    r = new Rotation(Vector3D.PLUS_J, Math.PI);\n+    checkVector(r.getAxis(), Vector3D.PLUS_J);\n     checkAngle(r.getAngle(), Math.PI);\n \n-    checkVector(new Rotation().getAxis(), Vector3D.plusI);\n+    checkVector(Rotation.IDENTITY.getAxis(), Vector3D.PLUS_I);\n \n   }\n \n     checkAngle(new Rotation(u, u.negate()).getAngle(), Math.PI);\n \n     try {\n-        new Rotation(u, new Vector3D());\n+        new Rotation(u, Vector3D.ZERO);\n         fail(\"an exception should have been thrown\");\n       } catch (IllegalArgumentException e) {\n         // expected behavior\n     Vector3D v1 = new Vector3D(0, 0, 2);\n     Vector3D v2 = new Vector3D(-2, 0, 2);\n     Rotation r = new Rotation(u1, u2, v1, v2);\n-    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);\n-    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.minusI);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.MINUS_I);\n \n     r = new Rotation(u1, u2, u1.negate(), u2.negate());\n     Vector3D axis = r.getAxis();\n-    if (Vector3D.dotProduct(axis, Vector3D.plusK) > 0) {\n-      checkVector(axis, Vector3D.plusK);\n+    if (Vector3D.dotProduct(axis, Vector3D.PLUS_K) > 0) {\n+      checkVector(axis, Vector3D.PLUS_K);\n     } else {\n-      checkVector(axis, Vector3D.minusK);\n+      checkVector(axis, Vector3D.MINUS_K);\n     }\n     checkAngle(r.getAngle(), Math.PI);\n \n     double sqrt = Math.sqrt(2) / 2;\n-    r = new Rotation(Vector3D.plusI,  Vector3D.plusJ,\n+    r = new Rotation(Vector3D.PLUS_I,  Vector3D.PLUS_J,\n                      new Vector3D(0.5, 0.5,  sqrt),\n                      new Vector3D(0.5, 0.5, -sqrt));\n     checkRotation(r, sqrt, 0.5, 0.5, 0);\n     checkRotation(new Rotation(u1, u2, u1, u2), 1, 0, 0, 0);\n \n     try {\n-        new Rotation(u1, u2, new Vector3D(), v2);\n+        new Rotation(u1, u2, Vector3D.ZERO, v2);\n         fail(\"an exception should have been thrown\");\n     } catch (IllegalArgumentException e) {\n       // expected behavior\n                       { 0.0, 0.0, 1.0 },\n                       { 1.0, 0.0, 0.0 } };\n     Rotation r = new Rotation(m1, 1.0e-7);\n-    checkVector(r.applyTo(Vector3D.plusI), Vector3D.plusK);\n-    checkVector(r.applyTo(Vector3D.plusJ), Vector3D.plusI);\n-    checkVector(r.applyTo(Vector3D.plusK), Vector3D.plusJ);\n+    checkVector(r.applyTo(Vector3D.PLUS_I), Vector3D.PLUS_K);\n+    checkVector(r.applyTo(Vector3D.PLUS_J), Vector3D.PLUS_I);\n+    checkVector(r.applyTo(Vector3D.PLUS_K), Vector3D.PLUS_J);\n \n     double[][] m2 = { { 0.83203, -0.55012, -0.07139 },\n                       { 0.48293,  0.78164, -0.39474 },\n       }\n     }\n \n-    checkVector(r.applyTo(Vector3D.plusI),\n+    checkVector(r.applyTo(Vector3D.PLUS_I),\n                 new Vector3D(m3[0][0], m3[1][0], m3[2][0]));\n-    checkVector(r.applyTo(Vector3D.plusJ),\n+    checkVector(r.applyTo(Vector3D.PLUS_J),\n                 new Vector3D(m3[0][1], m3[1][1], m3[2][1]));\n-    checkVector(r.applyTo(Vector3D.plusK),\n+    checkVector(r.applyTo(Vector3D.PLUS_K),\n                 new Vector3D(m3[0][2], m3[1][2], m3[2][2]));\n \n     double[][] m4 = { { 1.0,  0.0,  0.0 },\n       }\n     }\n \n-    r = new Rotation();\n+    r = Rotation.IDENTITY;\n     for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n       for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n           Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),\n       }\n     }\n \n-    r = new Rotation(Vector3D.plusK, Math.PI);\n+    r = new Rotation(Vector3D.PLUS_K, Math.PI);\n     for (double lambda = 0; lambda < 6.2; lambda += 0.2) {\n       for (double phi = -1.55; phi < 1.55; phi += 0.2) {\n           Vector3D u = new Vector3D(Math.cos(lambda) * Math.cos(phi),\n   }\n \n   private void checkAngle(double a1, double a2) {\n-    a2 -= 2 * Math.PI * Math.floor((a2 + Math.PI - a1) / (2 * Math.PI));\n-    assertTrue(Math.abs(a1 - a2) < 1.0e-10);\n+    assertEquals(a1, MathUtils.normalizeAngle(a2, a1), 1.0e-10);\n   }\n \n   private void checkRotation(Rotation r, double q0, double q1, double q2, double q3) {\n-    Rotation reference = new Rotation(q0, q1, q2, q3, false);\n-    assertEquals(0, r.applyInverseTo(reference).getAngle(), 1.0e-12);\n+    assertEquals(0, Rotation.distance(r, new Rotation(q0, q1, q2, q3, false)), 1.0e-12);\n   }\n \n   public static Test suite() {\n--- a/src/test/org/apache/commons/math/geometry/Vector3DTest.java\n+++ b/src/test/org/apache/commons/math/geometry/Vector3DTest.java\n       double r = Math.sqrt(2) /2;\n       checkVector(new Vector3D(2, new Vector3D(Math.PI / 3, -Math.PI / 4)),\n                   r, r * Math.sqrt(3), -2 * r);\n-      checkVector(new Vector3D(2, Vector3D.plusI,\n-                              -3, Vector3D.minusK),\n+      checkVector(new Vector3D(2, Vector3D.PLUS_I,\n+                              -3, Vector3D.MINUS_K),\n                   2, 0, 3);\n-      checkVector(new Vector3D(2, Vector3D.plusI,\n-                               5, Vector3D.plusJ,\n-                              -3, Vector3D.minusK),\n+      checkVector(new Vector3D(2, Vector3D.PLUS_I,\n+                               5, Vector3D.PLUS_J,\n+                              -3, Vector3D.MINUS_K),\n                   2, 5, 3);\n-      checkVector(new Vector3D(2, Vector3D.plusI,\n-                               5, Vector3D.plusJ,\n-                               5, Vector3D.minusJ,\n-                               -3, Vector3D.minusK),\n+      checkVector(new Vector3D(2, Vector3D.PLUS_I,\n+                               5, Vector3D.PLUS_J,\n+                               5, Vector3D.MINUS_J,\n+                               -3, Vector3D.MINUS_K),\n                   2, 0, 3);\n   }\n \n   }\n   \n   public void testNorm() {\n-    assertTrue(Math.abs(new Vector3D().getNorm()) < 1.0e-12);\n+    assertTrue(Math.abs(Vector3D.ZERO.getNorm()) < 1.0e-12);\n     assertTrue(Math.abs(new Vector3D(1, 2, 3).getNorm() - Math.sqrt(14))\n                < 1.0e-12);\n   }\n \n   public void testAngular() {\n \n-    assertEquals(0,           Vector3D.plusI.getAlpha(), 1.0e-10);\n-    assertEquals(0,           Vector3D.plusI.getDelta(), 1.0e-10);\n-    assertEquals(Math.PI / 2, Vector3D.plusJ.getAlpha(), 1.0e-10);\n-    assertEquals(0,           Vector3D.plusJ.getDelta(), 1.0e-10);\n-    assertEquals(0,           Vector3D.plusK.getAlpha(), 1.0e-10);\n-    assertEquals(Math.PI / 2, Vector3D.plusK.getDelta(), 1.0e-10);\n+    assertEquals(0,           Vector3D.PLUS_I.getAlpha(), 1.0e-10);\n+    assertEquals(0,           Vector3D.PLUS_I.getDelta(), 1.0e-10);\n+    assertEquals(Math.PI / 2, Vector3D.PLUS_J.getAlpha(), 1.0e-10);\n+    assertEquals(0,           Vector3D.PLUS_J.getDelta(), 1.0e-10);\n+    assertEquals(0,           Vector3D.PLUS_K.getAlpha(), 1.0e-10);\n+    assertEquals(Math.PI / 2, Vector3D.PLUS_K.getDelta(), 1.0e-10);\n \n     Vector3D u = new Vector3D(-1, 1, -1);\n     assertEquals(3 * Math.PI /4, u.getAlpha(), 1.0e-10);\n   public void testNormalize() {\n     assertEquals(1.0, new Vector3D(5, -4, 2).normalize().getNorm(), 1.0e-12);\n     try {\n-        new Vector3D().normalize();\n+        Vector3D.ZERO.normalize();\n         fail(\"an exception should have been thrown\");\n     } catch (ArithmeticException ae) {\n         // expected behavior\n                   Vector3D.angle(new Vector3D(1, 2, 3), new Vector3D(-2, -4, -6.000001)),\n                   1.0e-12);\n      try {\n-         Vector3D.angle(new Vector3D(), Vector3D.plusI);\n+         Vector3D.angle(Vector3D.ZERO, Vector3D.PLUS_I);\n          fail(\"an exception should have been thrown\");\n      } catch (ArithmeticException ae) {\n          // expected behavior", "timestamp": 1213021041, "metainfo": ""}