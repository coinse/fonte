{"sha": "4029aa31c6be8edd61d962add05e2d3aedafe593", "log": "updated univariate algorithms with latest interfaces definitions  ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.optimization.univariate;\n+\n+import org.apache.commons.math.ConvergingAlgorithmImpl;\n+import org.apache.commons.math.MathRuntimeException;\n+import org.apache.commons.math.optimization.UnivariateRealOptimizer;\n+\n+/**\n+ * Provide a default implementation for several functions useful to generic\n+ * optimizers.\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public abstract class AbstractUnivariateRealOptimizer\n+    extends ConvergingAlgorithmImpl implements UnivariateRealOptimizer {\n+\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 4543031162377070699L;\n+\n+    /** Indicates where a root has been computed. */\n+    protected boolean resultComputed;\n+\n+    /** The last computed root. */\n+    protected double result;\n+\n+    /** Value of the function at the last computed result. */\n+    protected double functionValue;\n+\n+    /**\n+     * Construct a solver with given iteration count and accuracy.\n+     * \n+     * @param defaultAbsoluteAccuracy maximum absolute error\n+     * @param defaultMaximalIterationCount maximum number of iterations\n+     * @throws IllegalArgumentException if f is null or the \n+     * defaultAbsoluteAccuracy is not valid\n+     */\n+    protected AbstractUnivariateRealOptimizer(final int defaultMaximalIterationCount,\n+                                              final double defaultAbsoluteAccuracy) {\n+        super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\n+        resultComputed = false;\n+    }\n+\n+    /** Check if a result has been computed.\n+     * @exception IllegalStateException if no result has been computed\n+     */\n+    protected void checkResultComputed() throws IllegalStateException {\n+        if (!resultComputed) {\n+            throw MathRuntimeException.createIllegalStateException(\"no result available\");\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getResult() {\n+        checkResultComputed();\n+        return result;\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double getFunctionValue() {\n+        checkResultComputed();\n+        return functionValue;\n+    }\n+\n+    /**\n+     * Convenience function for implementations.\n+     * \n+     * @param result the result to set\n+     * @param iterationCount the iteration count to set\n+     */\n+    protected final void setResult(final double result, final int iterationCount) {\n+        this.result         = result;\n+        this.iterationCount = iterationCount;\n+        this.resultComputed = true;\n+    }\n+\n+    /**\n+     * Convenience function for implementations.\n+     * \n+     * @param x the result to set\n+     * @param fx the result to set\n+     * @param iterationCount the iteration count to set\n+     */\n+    protected final void setResult(final double x, final double fx,\n+                                   final int iterationCount) {\n+        this.result         = x;\n+        this.functionValue  = fx;\n+        this.iterationCount = iterationCount;\n+        this.resultComputed = true;\n+    }\n+\n+    /**\n+     * Convenience function for implementations.\n+     */\n+    protected final void clearResult() {\n+        this.resultComputed = false;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/optimization/univariate/BrentOptimizer.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.optimization.univariate;\n+\n+import org.apache.commons.math.FunctionEvaluationException;\n+import org.apache.commons.math.MaxIterationsExceededException;\n+import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+\n+/**\n+ * Implements Richard Brent's algorithm (from his book \"Algorithms for\n+ * Minimization without Derivatives\", p. 79) for finding minima of real\n+ * univariate functions.\n+ *  \n+ * @version $Revision$ $Date$\n+ * @since 2.0\n+ */\n+public class BrentOptimizer extends AbstractUnivariateRealOptimizer {\n+    \n+    /** Serializable version identifier */\n+    private static final long serialVersionUID = 7185472920191999565L;\n+\n+    /**\n+     * Golden section.\n+     */\n+    private static final double c = 0.5 * (3 - Math.sqrt(5));\n+\n+    /**\n+     * Construct a solver.\n+     */\n+    public BrentOptimizer() {\n+        super(100, 1E-10);\n+    }\n+\n+    /** {@inheritDoc} */\n+    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n+                           final double min, final double max, final double startValue)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        return optimize(f, goalType, min, max);\n+    }\n+    \n+    /** {@inheritDoc} */\n+    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n+                           final double min, final double max)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        clearResult();\n+        return localMin(f, goalType, min, max, relativeAccuracy, absoluteAccuracy);\n+    }\n+    \n+    /**\n+     * Find the minimum of the function {@code f} within the interval {@code (a, b)}.\n+     *\n+     * If the function {@code f} is defined on the interval {@code (a, b)}, then\n+     * this method finds an approximation {@code x} to the point at which {@code f}\n+     * attains its minimum.<br/>\n+     * {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t} and\n+     * {@code f} is never evaluated at two points closer together than {@code tol}.\n+     * {@code eps} should be no smaller than <em>2 macheps</em> and preferable not\n+     * much less than <em>sqrt(macheps)</em>, where <em>macheps</em> is the relative\n+     * machine precision. {@code t} should be positive.\n+     * @param f the function to solve\n+     * @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE}\n+     * or {@link GoalType#MINIMIZE}\n+     * @param a Lower bound of the interval\n+     * @param b Higher bound of the interval\n+     * @param eps Relative accuracy\n+     * @param t Absolute accuracy\n+     * @return the point at which the function is minimal.\n+     * @throws MaxIterationsExceededException if the maximum iteration count\n+     * is exceeded.\n+     * @throws FunctionEvaluationException if an error occurs evaluating\n+     * the function. \n+     */\n+    private double localMin(final UnivariateRealFunction f, final GoalType goalType,\n+                            double a, double b, final double eps, final double t)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        double x = a + c * (b - a);\n+        double v = x;\n+        double w = x;\n+        double e = 0;\n+        double fx = f.value(x);\n+        if (goalType == GoalType.MAXIMIZE) {\n+            fx = -fx;\n+        }\n+        double fv = fx;\n+        double fw = fx;\n+\n+        int count = 0;\n+        while (count < maximalIterationCount) {\n+            double m = 0.5 * (a + b);\n+            double tol = eps * Math.abs(x) + t;\n+            double t2 = 2 * tol;\n+\n+            // Check stopping criterion.\n+            if (Math.abs(x - m) > t2 - 0.5 * (b - a)) {\n+                double p = 0;\n+                double q = 0;\n+                double r = 0;\n+                double d = 0;\n+                double u = 0;\n+\n+                if (Math.abs(e) > tol) { // Fit parabola.\n+                    r = (x - w) * (fx - fv);\n+                    q = (x - v) * (fx - fw);\n+                    p = (x - v) * q - (x - w) * r;\n+                    q = 2 * (q - r);\n+\n+                    if (q > 0) {\n+                        p = -p;\n+                    } else {\n+                        q = -q;\n+                    }\n+\n+                    r = e;\n+                    e = d;\n+                }\n+\n+                if (Math.abs(p) < Math.abs(0.5 * q * r) &&\n+                    (p < q * (a - x)) && (p < q * (b - x))) { // Parabolic interpolation step.\n+                    d = p / q;\n+                    u = x + d;\n+\n+                    // f must not be evaluated too close to a or b.\n+                    if (((u - a) < t2) || ((b - u) < t2)) {\n+                        d = (x < m) ? tol : -tol;\n+                    }\n+                } else { // Golden section step.\n+                    e = ((x < m) ? b : a) - x;\n+                    d = c * e;\n+                }\n+\n+                // f must not be evaluated too close to a or b.\n+                u = x + ((Math.abs(d) > tol) ? d : ((d > 0) ? tol : -tol));\n+                double fu = f.value(u);\n+                if (goalType == GoalType.MAXIMIZE) {\n+                    fu = -fu;\n+                }\n+\n+                // Update a, b, v, w and x.\n+                if (fu <= fx) {\n+                    if (u < x) {\n+                        b = x;\n+                    } else {\n+                        a = x;\n+                    }\n+                    v = w;\n+                    fv = fw;\n+                    w = x;\n+                    fw = fx;\n+                    x = u;\n+                    fx = fu;\n+                } else {\n+                    if (u < x) {\n+                        a = u;\n+                    } else {\n+                        b = u;\n+                    }\n+                    if ((fu <= fw) || (w == x)) {\n+                        v = w;\n+                        fv = fw;\n+                        w = u;\n+                        fw = fu;\n+                    } else if ((fu <= fv) || (v == x) || (v == w)) {\n+                        v = u;\n+                        fv = fu;\n+                    }\n+                }\n+            } else { // termination\n+                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n+                return x;\n+            }\n+\n+            ++count;\n+        }\n+\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+\n+    }\n+\n+}\n--- a/src/test/org/apache/commons/math/optimization/univariate/BrentMinimizerTest.java\n+++ b/src/test/org/apache/commons/math/optimization/univariate/BrentMinimizerTest.java\n import org.apache.commons.math.analysis.QuinticFunction;\n import org.apache.commons.math.analysis.SinFunction;\n import org.apache.commons.math.analysis.UnivariateRealFunction;\n+import org.apache.commons.math.optimization.GoalType;\n+import org.apache.commons.math.optimization.UnivariateRealOptimizer;\n \n /**\n  * @version $Revision$ $Date$ \n \n     public static Test suite() {\n         TestSuite suite = new TestSuite(BrentMinimizerTest.class);\n-        suite.setName(\"BrentMinimizer Tests\");\n+        suite.setName(\"BrentOptimizer Tests\");\n         return suite;\n     }\n \n     public void testSinMin() throws MathException {\n         UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealMinimizer minimizer = new BrentMinimizer();\n-        assertEquals(3 * Math.PI / 2, minimizer.minimize(f, 4, 5), 70 * minimizer.getAbsoluteAccuracy());\n+        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n+        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 4, 5), 70 * minimizer.getAbsoluteAccuracy());\n         assertTrue(minimizer.getIterationCount() <= 50);\n-        assertEquals(3 * Math.PI / 2, minimizer.minimize(f, 1, 5), 70 * minimizer.getAbsoluteAccuracy());\n+        assertEquals(3 * Math.PI / 2, minimizer.optimize(f, GoalType.MINIMIZE, 1, 5), 70 * minimizer.getAbsoluteAccuracy());\n         assertTrue(minimizer.getIterationCount() <= 50);\n     }\n \n         // The quintic function has zeros at 0, +-0.5 and +-1.\n         // The function has extrema (first derivative is zero) at 0.27195613 and 0.82221643,\n         UnivariateRealFunction f = new QuinticFunction();\n-        UnivariateRealMinimizer minimizer = new BrentMinimizer();\n-        assertEquals(-0.27195613, minimizer.minimize(f, -0.3, -0.2), 1.0e-8);\n-        assertEquals( 0.82221643, minimizer.minimize(f,  0.3,  0.9), 1.0e-8);\n+        UnivariateRealOptimizer minimizer = new BrentOptimizer();\n+        assertEquals(-0.27195613, minimizer.optimize(f, GoalType.MINIMIZE, -0.3, -0.2), 1.0e-8);\n+        assertEquals( 0.82221643, minimizer.optimize(f, GoalType.MINIMIZE,  0.3,  0.9), 1.0e-8);\n         assertTrue(minimizer.getIterationCount() <= 50);\n \n         // search in a large interval\n-        assertEquals(-0.27195613, minimizer.minimize(f, -1.0, 0.2), 1.0e-8);\n+        assertEquals(-0.27195613, minimizer.optimize(f, GoalType.MINIMIZE, -1.0, 0.2), 1.0e-8);\n         assertTrue(minimizer.getIterationCount() <= 50);\n \n    }\n     \n     public void testMinEndpoints() throws Exception {\n         UnivariateRealFunction f = new SinFunction();\n-        UnivariateRealMinimizer solver = new BrentMinimizer();\n+        UnivariateRealOptimizer solver = new BrentOptimizer();\n         \n         // endpoint is minimum\n-        double result = solver.minimize(f, 3 * Math.PI / 2, 5);\n+        double result = solver.optimize(f, GoalType.MINIMIZE, 3 * Math.PI / 2, 5);\n         assertEquals(3 * Math.PI / 2, result, 70 * solver.getAbsoluteAccuracy());\n \n-        result = solver.minimize(f, 4, 3 * Math.PI / 2);\n+        result = solver.optimize(f, GoalType.MINIMIZE, 4, 3 * Math.PI / 2);\n         assertEquals(3 * Math.PI / 2, result, 70 * solver.getAbsoluteAccuracy());\n \n     }", "timestamp": 1237932843, "metainfo": ""}