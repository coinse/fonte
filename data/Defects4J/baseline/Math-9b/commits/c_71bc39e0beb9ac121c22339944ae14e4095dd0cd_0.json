{"sha": "71bc39e0beb9ac121c22339944ae14e4095dd0cd", "log": "Fixed rounding error in RandomDataImpl nextInt, nextLong methods causing lower endpoints to be excluded when negative. Also improved robustness of nextUniform for extreme values and changed its contract to throw IAE when provided bounds are infinite or NaN.  JIRA: MATH-724 Reported and patched by Dennis Hendricks    ", "commit": "\n--- a/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n+++ b/src/main/java/org/apache/commons/math/exception/util/LocalizedFormats.java\n     INDEX_OUT_OF_RANGE(\"index {0} out of allowed range [{1}, {2}]\"),\n     INDEX(\"index ({0})\"), /* keep */\n     NOT_FINITE_NUMBER(\"{0} is not a finite number\"), /* keep */\n+    INFINITE_BOUND(\"interval bounds must be finite\"),\n     ARRAY_ELEMENT(\"value {0} at index {1}\"), /* keep */\n     INFINITE_ARRAY_ELEMENT(\"Array contains an infinite element, {0} at index {1}\"),\n     INFINITE_VALUE_CONVERSION(\"cannot convert infinite value\"),\n     NO_REGRESSORS(\"Regression model must include at least one regressor\"),\n     NO_RESULT_AVAILABLE(\"no result available\"),\n     NO_SUCH_MATRIX_ENTRY(\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\"),\n+    NAN_NOT_ALLOWED(\"NaN is not allowed\"),\n     NULL_NOT_ALLOWED(\"null is not allowed\"), /* keep */\n     ARRAY_ZERO_LENGTH_OR_NULL_NOTALLOWED(\"A null or zero length array not allowed\"),\n     COVARIANCE_MATRIX(\"covariance matrix\"), /* keep */\n--- a/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n+++ b/src/main/java/org/apache/commons/math/random/RandomDataImpl.java\n import org.apache.commons.math.distribution.TDistribution;\n import org.apache.commons.math.distribution.WeibullDistribution;\n import org.apache.commons.math.distribution.ZipfDistribution;\n+import org.apache.commons.math.exception.MathIllegalArgumentException;\n import org.apache.commons.math.exception.MathInternalError;\n import org.apache.commons.math.exception.NotStrictlyPositiveException;\n import org.apache.commons.math.exception.NumberIsTooLargeException;\n                                                 lower, upper, false);\n         }\n         double r = getRan().nextDouble();\n-        return (int) ((r * upper) + ((1.0 - r) * lower) + r);\n+        double scaled = r * upper + (1.0 - r) * lower + r;\n+        return (int)FastMath.floor(scaled);\n     }\n \n     /**\n                                                 lower, upper, false);\n         }\n         double r = getRan().nextDouble();\n-        return (long) ((r * upper) + ((1.0 - r) * lower) + r);\n+        double scaled = r * upper + (1.0 - r) * lower + r;\n+        return (long)FastMath.floor(scaled);\n     }\n \n     /**\n                                                 lower, upper, false);\n         }\n         SecureRandom sec = getSecRan();\n-        return lower + (int) (sec.nextDouble() * (upper - lower + 1));\n+        double r = sec.nextDouble();\n+        double scaled = r * upper + (1.0 - r) * lower + r;\n+        return (int)FastMath.floor(scaled);\n     }\n \n     /**\n                                                 lower, upper, false);\n         }\n         SecureRandom sec = getSecRan();\n-        return lower + (long) (sec.nextDouble() * (upper - lower + 1));\n+        double r = sec.nextDouble();\n+        double scaled = r * upper + (1.0 - r) * lower + r;\n+        return (long)FastMath.floor(scaled);\n     }\n \n     /**\n      * provide a symmetric output interval (both endpoints excluded).\n      * </p>\n      *\n-     * @param lower\n-     *            the lower bound.\n-     * @param upper\n-     *            the upper bound.\n-     * @return a uniformly distributed random value from the interval (lower,\n-     *         upper)\n-     * @throws NumberIsTooLargeException if {@code lower >= upper}.\n+     * @param lower the lower bound.\n+     * @param upper the upper bound.\n+     * @return a uniformly distributed random value from the interval (lower, upper)\n+     * @throws MathIllegalArgumentException if {@code lower >= upper}\n+     * or either bound is infinite or NaN\n      */\n     public double nextUniform(double lower, double upper) {\n         if (lower >= upper) {\n-            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n-                                                lower, upper, false);\n-        }\n+            throw new MathIllegalArgumentException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n+                                                lower, upper);\n+        }\n+\n+        if (Double.isInfinite(lower) || Double.isInfinite(upper)) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_BOUND);\n+        }\n+\n+        if (Double.isNaN(lower) || Double.isNaN(upper)) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.NAN_NOT_ALLOWED);\n+        }\n+\n         final RandomGenerator generator = getRan();\n \n         // ensure nextDouble() isn't 0.0\n             u = generator.nextDouble();\n         }\n \n-        return lower + u * (upper - lower);\n+        return u * upper + (1.0 - u) * lower;\n     }\n \n     /**\n--- a/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomDataTest.java\n         long y = randomData.nextLong(Long.MIN_VALUE, Long.MAX_VALUE);\n         Assert.assertFalse(x == y);\n     }\n-\n-    /** test dispersion and failure modes for nextInt() */\n-    @Test\n-    public void testNextInt() {\n+    \n+    @Test\n+    public void testNextUniformExtremeValues() {\n+        double x = randomData.nextUniform(-Double.MAX_VALUE, Double.MAX_VALUE);\n+        double y = randomData.nextUniform(-Double.MAX_VALUE, Double.MAX_VALUE);\n+        Assert.assertFalse(x == y);\n+        Assert.assertFalse(Double.isNaN(x));\n+        Assert.assertFalse(Double.isNaN(y));\n+        Assert.assertFalse(Double.isInfinite(x));\n+        Assert.assertFalse(Double.isInfinite(y));\n+    }\n+    \n+    @Test\n+    public void testNextIntIAE() throws Exception {\n         try {\n             randomData.nextInt(4, 3);\n             Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n-        Frequency freq = new Frequency();\n-        int value = 0;\n+    }\n+    \n+    @Test\n+    public void testNextIntNegativeToPositiveRange() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextIntUniform(-3, 5);\n+            checkNextIntUniform(-3, 6);\n+        }\n+    }\n+    \n+    @Test \n+    public void testNextIntNegativeRange() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextIntUniform(-7, -4);\n+            checkNextIntUniform(-15, -2);\n+        }\n+    }\n+    \n+    @Test \n+    public void testNextIntPositiveRange() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextIntUniform(0, 3);\n+            checkNextIntUniform(2, 12);\n+            checkNextIntUniform(1,2);\n+        }\n+    }\n+    \n+    \n+    private void checkNextIntUniform(int min, int max) throws Exception {\n+        final Frequency freq = new Frequency();\n         for (int i = 0; i < smallSampleSize; i++) {\n-            value = randomData.nextInt(0, 3);\n-            Assert.assertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+            final int value = randomData.nextInt(min, max);\n+            Assert.assertTrue(\"nextInt range\", (value >= min) && (value <= max));\n             freq.addValue(value);\n         }\n-        long[] observed = new long[4];\n-        for (int i = 0; i < 4; i++) {\n-            observed[i] = freq.getCount(i);\n-        }\n-\n-        /*\n-         * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n-         * for alpha = .01\n-         */\n-        Assert.assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-                testStatistic.chiSquare(expected, observed) < 16.27);\n-    }\n-\n-    /** test dispersion and failure modes for nextLong() */\n-    @Test\n-    public void testNextLong() {\n+        final int len = max - min + 1;\n+        final long[] observed = new long[len];\n+        for (int i = 0; i < len; i++) {\n+            observed[i] = freq.getCount(min + i);\n+        }\n+        final double[] expected = new double[len];\n+        for (int i = 0; i < len; i++) {\n+            expected[i] = 1d / len;\n+        }\n+        \n+        TestUtils.assertChiSquareAccept(expected, observed, 0.01);\n+    }\n+\n+    @Test\n+    public void testNextLongIAE() {\n         try {\n             randomData.nextLong(4, 3);\n             Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n-        Frequency freq = new Frequency();\n-        long value = 0;\n+    }\n+    \n+    @Test\n+    public void testNextLongNegativeToPositiveRange() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextLongUniform(-3, 5);\n+            checkNextLongUniform(-3, 6);\n+        }\n+    }\n+    \n+    @Test \n+    public void testNextLongNegativeRange() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextLongUniform(-7, -4);\n+            checkNextLongUniform(-15, -2);\n+        }\n+    }\n+    \n+    @Test \n+    public void testNextLongPositiveRange() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextLongUniform(0, 3);\n+            checkNextLongUniform(2, 12);\n+        }\n+    }\n+    \n+    private void checkNextLongUniform(int min, int max) throws Exception {\n+        final Frequency freq = new Frequency();\n         for (int i = 0; i < smallSampleSize; i++) {\n-            value = randomData.nextLong(0, 3);\n-            Assert.assertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+            final long value = randomData.nextLong(min, max);\n+            Assert.assertTrue(\"nextLong range\", (value >= min) && (value <= max));\n             freq.addValue(value);\n         }\n-        long[] observed = new long[4];\n-        for (int i = 0; i < 4; i++) {\n-            observed[i] = freq.getCount(i);\n-        }\n-\n-        /*\n-         * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n-         * for alpha = .01\n-         */\n-        Assert.assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-                testStatistic.chiSquare(expected, observed) < 16.27);\n-    }\n-\n-    /** test dispersion and failure modes for nextSecureLong() */\n-    @Test\n-    public void testNextSecureLong() {\n+        final int len = max - min + 1;\n+        final long[] observed = new long[len];\n+        for (int i = 0; i < len; i++) {\n+            observed[i] = freq.getCount(min + i);\n+        }\n+        final double[] expected = new double[len];\n+        for (int i = 0; i < len; i++) {\n+            expected[i] = 1d / len;\n+        }\n+        \n+        TestUtils.assertChiSquareAccept(expected, observed, 0.01);\n+    }\n+\n+    @Test\n+    public void testNextSecureLongIAE() {\n         try {\n             randomData.nextSecureLong(4, 3);\n             Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n-        Frequency freq = new Frequency();\n-        long value = 0;\n+    }\n+    @Test\n+    public void testNextSecureLongNegativeToPositiveRange() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextSecureLongUniform(-3, 5);\n+            checkNextSecureLongUniform(-3, 6);\n+        }\n+    }\n+    \n+    @Test \n+    public void testNextSecureLongNegativeRange() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextSecureLongUniform(-7, -4);\n+            checkNextSecureLongUniform(-15, -2);\n+        }\n+    }\n+    \n+    @Test \n+    public void testNextSecureLongPositiveRange() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextSecureLongUniform(0, 3);\n+            checkNextSecureLongUniform(2, 12);\n+        }\n+    }\n+    \n+    private void checkNextSecureLongUniform(int min, int max) throws Exception {\n+        final Frequency freq = new Frequency();\n         for (int i = 0; i < smallSampleSize; i++) {\n-            value = randomData.nextSecureLong(0, 3);\n-            Assert.assertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+            final long value = randomData.nextSecureLong(min, max);\n+            Assert.assertTrue(\"nextLong range\", (value >= min) && (value <= max));\n             freq.addValue(value);\n         }\n-        long[] observed = new long[4];\n-        for (int i = 0; i < 4; i++) {\n-            observed[i] = freq.getCount(i);\n-        }\n-\n-        /*\n-         * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n-         * for alpha = .01\n-         */\n-        Assert.assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-                testStatistic.chiSquare(expected, observed) < 16.27);\n-    }\n-\n-    /** test dispersion and failure modes for nextSecureInt() */\n-    @Test\n-    public void testNextSecureInt() {\n+        final int len = max - min + 1;\n+        final long[] observed = new long[len];\n+        for (int i = 0; i < len; i++) {\n+            observed[i] = freq.getCount(min + i);\n+        }\n+        final double[] expected = new double[len];\n+        for (int i = 0; i < len; i++) {\n+            expected[i] = 1d / len;\n+        }\n+        \n+        TestUtils.assertChiSquareAccept(expected, observed, 0.0001);\n+    }\n+\n+    @Test\n+    public void testNextSecureIntIAE() {\n         try {\n             randomData.nextSecureInt(4, 3);\n             Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n-        Frequency freq = new Frequency();\n-        int value = 0;\n+    }\n+    \n+    @Test\n+    public void testNextSecureIntNegativeToPositiveRange() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextSecureIntUniform(-3, 5);\n+            checkNextSecureIntUniform(-3, 6);\n+        }\n+    }\n+    \n+    @Test \n+    public void testNextSecureIntNegativeRange() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextSecureIntUniform(-7, -4);\n+            checkNextSecureIntUniform(-15, -2);\n+        }\n+    }\n+    \n+    @Test \n+    public void testNextSecureIntPositiveRange() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextSecureIntUniform(0, 3);\n+            checkNextSecureIntUniform(2, 12);\n+        }\n+    }\n+     \n+    private void checkNextSecureIntUniform(int min, int max) throws Exception {\n+        final Frequency freq = new Frequency();\n         for (int i = 0; i < smallSampleSize; i++) {\n-            value = randomData.nextSecureInt(0, 3);\n-            Assert.assertTrue(\"nextInt range\", (value >= 0) && (value <= 3));\n+            final int value = randomData.nextSecureInt(min, max);\n+            Assert.assertTrue(\"nextInt range\", (value >= min) && (value <= max));\n             freq.addValue(value);\n         }\n-        long[] observed = new long[4];\n-        for (int i = 0; i < 4; i++) {\n-            observed[i] = freq.getCount(i);\n-        }\n-\n-        /*\n-         * Use ChiSquare dist with df = 4-1 = 3, alpha = .001 Change to 11.34\n-         * for alpha = .01\n-         */\n-        Assert.assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-                testStatistic.chiSquare(expected, observed) < 16.27);\n-    }\n+        final int len = max - min + 1;\n+        final long[] observed = new long[len];\n+        for (int i = 0; i < len; i++) {\n+            observed[i] = freq.getCount(min + i);\n+        }\n+        final double[] expected = new double[len];\n+        for (int i = 0; i < len; i++) {\n+            expected[i] = 1d / len;\n+        }\n+        \n+        TestUtils.assertChiSquareAccept(expected, observed, 0.0001);\n+    }\n+    \n+    \n \n     /**\n      * Make sure that empirical distribution of random Poisson(4)'s has P(X <=\n                 testStatistic.chiSquare(expected, observed) < 37.70);\n     }\n \n-    /** test failure modes and dispersion of nextUniform() */\n-    @Test\n-    public void testNextUniform() {\n+    @Test\n+    public void testNextUniformIAE() {\n         try {\n             randomData.nextUniform(4, 3);\n             Assert.fail(\"MathIllegalArgumentException expected\");\n             // ignored\n         }\n         try {\n-            randomData.nextUniform(3, 3);\n+            randomData.nextUniform(0, Double.POSITIVE_INFINITY);\n             Assert.fail(\"MathIllegalArgumentException expected\");\n         } catch (MathIllegalArgumentException ex) {\n             // ignored\n         }\n-        double[] expected = { 500, 500 };\n-        long[] observed = { 0, 0 };\n-        double lower = -1d;\n-        double upper = 20d;\n-        double midpoint = (lower + upper) / 2d;\n-        double result = 0;\n-        for (int i = 0; i < 1000; i++) {\n-            result = randomData.nextUniform(lower, upper);\n-            if ((result == lower) || (result == upper)) {\n-                Assert.fail(\"generated value equal to an endpoint: \" + result);\n-            }\n-            if (result < midpoint) {\n-                observed[0]++;\n-            } else {\n-                observed[1]++;\n-            }\n-        }\n-        /*\n-         * Use ChiSquare dist with df = 2-1 = 1, alpha = .001 Change to 6.64 for\n-         * alpha = .01\n-         */\n-        Assert.assertTrue(\"chi-square test -- will fail about 1 in 1000 times\",\n-                testStatistic.chiSquare(expected, observed) < 10.83);\n+        try {\n+            randomData.nextUniform(Double.NEGATIVE_INFINITY, 0);\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            randomData.nextUniform(0, Double.NaN);\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+        try {\n+            randomData.nextUniform(Double.NaN, 0);\n+            Assert.fail(\"MathIllegalArgumentException expected\");\n+        } catch (MathIllegalArgumentException ex) {\n+            // ignored\n+        }\n+    }\n+    \n+    @Test\n+    public void testNextUniformUniformPositiveBounds() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextUniformUniform(0, 10);\n+        }\n+    }\n+    \n+    @Test\n+    public void testNextUniformUniformNegativeToPositiveBounds() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextUniformUniform(-3, 5);\n+        }\n+    }\n+    \n+    @Test\n+    public void testNextUniformUniformNegaiveBounds() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextUniformUniform(-7, -3);\n+        }\n+    }\n+    \n+    @Test\n+    public void testNextUniformUniformMaximalInterval() throws Exception {\n+        for (int i = 0; i < 5; i++) {\n+            checkNextUniformUniform(-Double.MAX_VALUE, Double.MAX_VALUE);\n+        }\n+    }\n+    \n+    private void checkNextUniformUniform(double min, double max) throws Exception {\n+        // Set up bin bounds - min, binBound[0], ..., binBound[binCount-2], max\n+        final int binCount = 5;\n+        final double binSize = max / binCount - min/binCount; // Prevent overflow in extreme value case\n+        final double[] binBounds = new double[binCount - 1];\n+        binBounds[0] = min + binSize;\n+        for (int i = 1; i < binCount - 1; i++) {\n+            binBounds[i] = binBounds[i - 1] + binSize;  // + instead of * to avoid overflow in extreme case\n+        }\n+        \n+        final Frequency freq = new Frequency();\n+        for (int i = 0; i < smallSampleSize; i++) {\n+            final double value = randomData.nextUniform(min, max);\n+            Assert.assertTrue(\"nextUniform range\", (value > min) && (value < max));\n+            // Find bin\n+            int j = 0;\n+            while (j < binCount - 1 && value > binBounds[j]) {\n+                j++;\n+            }\n+            freq.addValue(j);\n+        }\n+       \n+        final long[] observed = new long[binCount];\n+        for (int i = 0; i < binCount; i++) {\n+            observed[i] = freq.getCount(i);\n+        }\n+        final double[] expected = new double[binCount];\n+        for (int i = 0; i < binCount; i++) {\n+            expected[i] = 1d / binCount;\n+        }\n+        \n+        TestUtils.assertChiSquareAccept(expected, observed, 0.01);\n     }\n \n     /** test exclusive endpoints of nextUniform **/\n--- a/src/test/java/org/apache/commons/math/random/RandomGeneratorAbstractTest.java\n+++ b/src/test/java/org/apache/commons/math/random/RandomGeneratorAbstractTest.java\n     \n     // Omit secureXxx tests, since they do not use the provided generator\n     @Override\n-    public void testNextSecureLong() {}\n-    \n-    @Override\n-    public void testNextSecureInt() {}\n-    \n+    public void testNextSecureLongIAE() {}\n+    @Override\n+    public void testNextSecureLongNegativeToPositiveRange() {}\n+    @Override\n+    public void testNextSecureLongNegativeRange() {}\n+    @Override\n+    public void testNextSecureLongPositiveRange() {}\n+    @Override\n+    public void testNextSecureIntIAE() {}\n+    @Override\n+    public void testNextSecureIntNegativeToPositiveRange() {}\n+    @Override\n+    public void testNextSecureIntNegativeRange() {}\n+    @Override\n+    public void testNextSecureIntPositiveRange() {}\n     @Override\n     public void testNextSecureHex() {}\n ", "timestamp": 1324415278, "metainfo": ""}