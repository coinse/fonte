{"sha": "58b5609fe8f99aabc990d885bf6c4d85631b7c79", "log": "Fixed an error in computing gcd and lcm for some extreme values at integer range boundaries. JIRA: MATH-243  ", "commit": "\n--- a/src/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/java/org/apache/commons/math/MessagesResources_fr.java\n   /** Non-translated/translated messages arrays. */\n   static final Object[][] contents = {\n \n+    // org.apache.commons.math.util.MathUtils\n+    { \"overflow: gcd({0}, {1}) is 2^31\",\n+      \"d\\u00e9passement de capacit\\u00e9 : le PGCD de {0} et {1} vaut 2^31\" },\n+      \n     // org.apache.commons.math.FunctionEvaluationException\n     { \"Evaluation failed for argument = {0}\",\n       \"Erreur d''\\u00e9valuation pour l''argument {0}\" },\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n \n import java.math.BigDecimal;\n import java.util.Arrays;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.MathRuntimeException;\n \n /**\n  * Some useful additions to the built-in functions in {@link Math}.\n      * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n      * Stein (1961).\n      * </p>\n-     * \n-     * @param u a non-zero number\n-     * @param v a non-zero number\n-     * @return the greatest common divisor, never zero\n+     * Special cases:\n+     * <ul>\n+     * <li>The invocations\n+     * <code>gcd(Integer.MIN_VALUE, Integer.MIN_VALUE)</code>,\n+     * <code>gcd(Integer.MIN_VALUE, 0)</code> and\n+     * <code>gcd(0, Integer.MIN_VALUE)</code> throw an\n+     * <code>ArithmeticException</code>, because the result would be 2^31, which\n+     * is too large for an int value.</li>\n+     * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0, x)</code> and\n+     * <code>gcd(x, 0)</code> is the absolute value of <code>x</code>, except\n+     * for the special cases above.\n+     * <li>The invocation <code>gcd(0, 0)</code> is the only one which returns\n+     * <code>0</code>.</li>\n+     * </ul>\n+     * \n+     * @param u any number\n+     * @param v any number\n+     * @return the greatest common divisor, never negative\n+     * @throws ArithmeticException\n+     *             if the result cannot be represented as a nonnegative int\n+     *             value\n      * @since 1.1\n      */\n-    public static int gcd(int u, int v) {\n+    public static int gcd(final int p, final int q) {\n+        int u = p;\n+        int v = q;\n         if ((u == 0) || (v == 0)) {\n+            if ((u == Integer.MIN_VALUE) || (v == Integer.MIN_VALUE)) {\n+                throw MathRuntimeException.createArithmeticException(\n+                        \"overflow: gcd({0}, {1}) is 2^31\",\n+                        new Object[] { p, q });\n+            }\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to\n             k++; // cast out twos.\n         }\n         if (k == 31) {\n-            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n+            throw MathRuntimeException.createArithmeticException(\n+                    \"overflow: gcd({0}, {1}) is 2^31\",\n+                    new Object[] { p, q });\n         }\n         // B2. Initialize: u and v have been divided by 2^k and at least\n         // one is odd.\n     }\n \n     /**\n-     * Returns the least common multiple between two integer values.\n-     * \n-     * @param a the first integer value.\n-     * @param b the second integer value.\n-     * @return the least common multiple between a and b.\n-     * @throws ArithmeticException if the lcm is too large to store as an int\n+     * <p>\n+     * Returns the least common multiple of the absolute value of two numbers,\n+     * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.\n+     * </p>\n+     * Special cases:\n+     * <ul>\n+     * <li>The invocations <code>lcm(Integer.MIN_VALUE, n)</code> and\n+     * <code>lcm(n, Integer.MIN_VALUE)</code>, where <code>abs(n)</code> is a\n+     * power of 2, throw an <code>ArithmeticException</code>, because the result\n+     * would be 2^31, which is too large for an int value.</li>\n+     * <li>The result of <code>lcm(0, x)</code> and <code>lcm(x, 0)</code> is\n+     * <code>0</code> for any <code>x</code>.\n+     * </ul>\n+     * \n+     * @param a any number\n+     * @param b any number\n+     * @return the least common multiple, never negative\n+     * @throws ArithmeticException\n+     *             if the result cannot be represented as a nonnegative int\n+     *             value\n      * @since 1.1\n      */\n     public static int lcm(int a, int b) {\n-        return Math.abs(mulAndCheck(a / gcd(a, b), b));\n+        if (a==0 || b==0){\n+            return 0;\n+        }\n+        int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n+        if (lcm == Integer.MIN_VALUE){\n+            throw new ArithmeticException(\"overflow: lcm is 2^31\");\n+        }\n+        return lcm;\n     }\n \n     /** \n--- a/src/test/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/org/apache/commons/math/util/MathUtilsTest.java\n         assertEquals(3 * (1<<15), MathUtils.gcd(3 * (1<<20), 9 * (1<<15)));\n \n         assertEquals(Integer.MAX_VALUE, MathUtils.gcd(Integer.MAX_VALUE, 0));\n-        // abs(Integer.MIN_VALUE) == Integer.MIN_VALUE\n-        assertEquals(Integer.MIN_VALUE, MathUtils.gcd(Integer.MIN_VALUE, 0));\n-        try {\n+        assertEquals(Integer.MAX_VALUE, MathUtils.gcd(-Integer.MAX_VALUE, 0));\n+        assertEquals(1<<30, MathUtils.gcd(1<<30, -Integer.MIN_VALUE));\n+        try {\n+            // gcd(Integer.MIN_VALUE, 0) > Integer.MAX_VALUE\n+            MathUtils.gcd(Integer.MIN_VALUE, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException expected) {\n+            // expected\n+        }\n+        try {\n+            // gcd(0, Integer.MIN_VALUE) > Integer.MAX_VALUE\n+            MathUtils.gcd(0, Integer.MIN_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException expected) {\n+            // expected\n+        }\n+        try {\n+            // gcd(Integer.MIN_VALUE, Integer.MIN_VALUE) > Integer.MAX_VALUE\n             MathUtils.gcd(Integer.MIN_VALUE, Integer.MIN_VALUE);\n+            fail(\"expecting ArithmeticException\");\n         } catch (ArithmeticException expected) {\n-            //\n+            // expected\n         }\n     }\n \n         assertEquals(150, MathUtils.lcm(a, b));\n         assertEquals(150, MathUtils.lcm(-a, b));\n         assertEquals(150, MathUtils.lcm(a, -b));\n+        assertEquals(150, MathUtils.lcm(-a, -b));\n         assertEquals(2310, MathUtils.lcm(a, c));\n+\n+        // Assert that no intermediate value overflows:\n+        // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)\n+        assertEquals((1<<20)*15, MathUtils.lcm((1<<20)*3, (1<<20)*5));\n+\n+        // Special case\n+        assertEquals(0, MathUtils.lcm(0, 0));\n+\n+        try {\n+            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n+            MathUtils.lcm(Integer.MIN_VALUE, 1);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n+        \n+        try {\n+            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n+            MathUtils.lcm(Integer.MIN_VALUE, 1<<20);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException ex) {\n+            // expected\n+        }\n \n         try {\n             MathUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1);", "timestamp": 1235224465, "metainfo": ""}