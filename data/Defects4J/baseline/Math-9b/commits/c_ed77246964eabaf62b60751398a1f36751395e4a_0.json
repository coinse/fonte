{"sha": "ed77246964eabaf62b60751398a1f36751395e4a", "log": "Replaced EigenDecomposition by EigenDecompositionImpl (preliminary cleaning for solving MATH-662).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/CMAESOptimizer.java\n import org.apache.commons.math.exception.OutOfRangeException;\n import org.apache.commons.math.exception.TooManyEvaluationsException;\n import org.apache.commons.math.linear.Array2DRowRealMatrix;\n-import org.apache.commons.math.linear.EigenDecomposition;\n import org.apache.commons.math.linear.EigenDecompositionImpl;\n import org.apache.commons.math.linear.MatrixUtils;\n import org.apache.commons.math.linear.RealMatrix;\n             // to achieve O(N^2)\n             C = triu(C, 0).add(triu(C, 1).transpose());\n             // enforce symmetry to prevent complex numbers\n-            EigenDecomposition eig = new EigenDecompositionImpl(C, 1.0);\n+            EigenDecompositionImpl eig = new EigenDecompositionImpl(C, 1.0);\n             B = eig.getV(); // eigen decomposition, B==normalized eigenvectors\n             D = eig.getD();\n             diagD = diag(D);\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/EigenDecompositionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+\n+\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class EigenDecompositionTest {\n+\n+    private double[] refValues;\n+    private RealMatrix matrix;\n+\n+    @Test\n+    public void testDimension1() {\n+        RealMatrix matrix =\n+            MatrixUtils.createRealMatrix(new double[][] { { 1.5 } });\n+        EigenDecompositionImpl ed;\n+        ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+        Assert.assertEquals(1.5, ed.getRealEigenvalue(0), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testDimension2() {\n+        RealMatrix matrix =\n+            MatrixUtils.createRealMatrix(new double[][] {\n+                    { 59.0, 12.0 },\n+                    { 12.0, 66.0 }\n+            });\n+        EigenDecompositionImpl ed;\n+        ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+        Assert.assertEquals(75.0, ed.getRealEigenvalue(0), 1.0e-15);\n+        Assert.assertEquals(50.0, ed.getRealEigenvalue(1), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testDimension3() {\n+        RealMatrix matrix =\n+            MatrixUtils.createRealMatrix(new double[][] {\n+                                   {  39632.0, -4824.0, -16560.0 },\n+                                   {  -4824.0,  8693.0,   7920.0 },\n+                                   { -16560.0,  7920.0,  17300.0 }\n+                               });\n+        EigenDecompositionImpl ed;\n+        ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+        Assert.assertEquals(50000.0, ed.getRealEigenvalue(0), 3.0e-11);\n+        Assert.assertEquals(12500.0, ed.getRealEigenvalue(1), 3.0e-11);\n+        Assert.assertEquals( 3125.0, ed.getRealEigenvalue(2), 3.0e-11);\n+    }\n+\n+    @Test\n+    public void testDimension3MultipleRoot() {\n+        RealMatrix matrix =\n+            MatrixUtils.createRealMatrix(new double[][] {\n+                    {  5,   10,   15 },\n+                    { 10,   20,   30 },\n+                    { 15,   30,   45 }\n+            });\n+        EigenDecompositionImpl ed;\n+        ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+        Assert.assertEquals(70.0, ed.getRealEigenvalue(0), 3.0e-11);\n+        Assert.assertEquals(0.0,  ed.getRealEigenvalue(1), 3.0e-11);\n+        Assert.assertEquals(0.0,  ed.getRealEigenvalue(2), 3.0e-11);\n+    }\n+\n+    @Test\n+    public void testDimension4WithSplit() {\n+        RealMatrix matrix =\n+            MatrixUtils.createRealMatrix(new double[][] {\n+                                   {  0.784, -0.288,  0.000,  0.000 },\n+                                   { -0.288,  0.616,  0.000,  0.000 },\n+                                   {  0.000,  0.000,  0.164, -0.048 },\n+                                   {  0.000,  0.000, -0.048,  0.136 }\n+                               });\n+        EigenDecompositionImpl ed;\n+        ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+        Assert.assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);\n+        Assert.assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);\n+        Assert.assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);\n+        Assert.assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);\n+    }\n+\n+    @Test\n+    public void testDimension4WithoutSplit() {\n+        RealMatrix matrix =\n+            MatrixUtils.createRealMatrix(new double[][] {\n+                                   {  0.5608, -0.2016,  0.1152, -0.2976 },\n+                                   { -0.2016,  0.4432, -0.2304,  0.1152 },\n+                                   {  0.1152, -0.2304,  0.3088, -0.1344 },\n+                                   { -0.2976,  0.1152, -0.1344,  0.3872 }\n+                               });\n+        EigenDecompositionImpl ed;\n+        ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+        Assert.assertEquals(1.0, ed.getRealEigenvalue(0), 1.0e-15);\n+        Assert.assertEquals(0.4, ed.getRealEigenvalue(1), 1.0e-15);\n+        Assert.assertEquals(0.2, ed.getRealEigenvalue(2), 1.0e-15);\n+        Assert.assertEquals(0.1, ed.getRealEigenvalue(3), 1.0e-15);\n+    }\n+\n+    // the following test triggered an ArrayIndexOutOfBoundsException in commons-math 2.0\n+    @Test\n+    public void testMath308() {\n+\n+        double[] mainTridiagonal = {\n+            22.330154644539597, 46.65485522478641, 17.393672330044705, 54.46687435351116, 80.17800767709437\n+        };\n+        double[] secondaryTridiagonal = {\n+            13.04450406501361, -5.977590941539671, 2.9040909856707517, 7.1570352792841225\n+        };\n+\n+        // the reference values have been computed using routine DSTEMR\n+        // from the fortran library LAPACK version 3.2.1\n+        double[] refEigenValues = {\n+            82.044413207204002, 53.456697699894512, 52.536278520113882, 18.847969733754262, 14.138204224043099\n+        };\n+        RealVector[] refEigenVectors = {\n+            new ArrayRealVector(new double[] { -0.000462690386766, -0.002118073109055,  0.011530080757413,  0.252322434584915,  0.967572088232592 }),\n+            new ArrayRealVector(new double[] {  0.314647769490148,  0.750806415553905, -0.167700312025760, -0.537092972407375,  0.143854968127780 }),\n+            new ArrayRealVector(new double[] {  0.222368839324646,  0.514921891363332, -0.021377019336614,  0.801196801016305, -0.207446991247740 }),\n+            new ArrayRealVector(new double[] { -0.713933751051495,  0.190582113553930, -0.671410443368332,  0.056056055955050, -0.006541576993581 }),\n+            new ArrayRealVector(new double[] { -0.584677060845929,  0.367177264979103,  0.721453187784497, -0.052971054621812,  0.005740715188257 })\n+        };\n+\n+        EigenDecompositionImpl decomposition;\n+        decomposition = new EigenDecompositionImpl(mainTridiagonal,\n+                                                   secondaryTridiagonal,\n+                                                   MathUtils.SAFE_MIN);\n+\n+        double[] eigenValues = decomposition.getRealEigenvalues();\n+        for (int i = 0; i < refEigenValues.length; ++i) {\n+            Assert.assertEquals(refEigenValues[i], eigenValues[i], 1.0e-5);\n+            Assert.assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 2.0e-7);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testMathpbx02() {\n+\n+        double[] mainTridiagonal = {\n+              7484.860960227216, 18405.28129035345, 13855.225609560746,\n+             10016.708722343366, 559.8117399576674, 6750.190788301587,\n+                71.21428769782159\n+        };\n+        double[] secondaryTridiagonal = {\n+             -4175.088570476366,1975.7955858241994,5193.178422374075,\n+              1995.286659169179,75.34535882933804,-234.0808002076056\n+        };\n+\n+        // the reference values have been computed using routine DSTEMR\n+        // from the fortran library LAPACK version 3.2.1\n+        double[] refEigenValues = {\n+                20654.744890306974412,16828.208208485466457,\n+                6893.155912634994820,6757.083016675340332,\n+                5887.799885688558788,64.309089923240379,\n+                57.992628792736340\n+        };\n+        RealVector[] refEigenVectors = {\n+                new ArrayRealVector(new double[] {-0.270356342026904, 0.852811091326997, 0.399639490702077, 0.198794657813990, 0.019739323307666, 0.000106983022327, -0.000001216636321}),\n+                new ArrayRealVector(new double[] {0.179995273578326,-0.402807848153042,0.701870993525734,0.555058211014888,0.068079148898236,0.000509139115227,-0.000007112235617}),\n+                new ArrayRealVector(new double[] {-0.399582721284727,-0.056629954519333,-0.514406488522827,0.711168164518580,0.225548081276367,0.125943999652923,-0.004321507456014}),\n+                new ArrayRealVector(new double[] {0.058515721572821,0.010200130057739,0.063516274916536,-0.090696087449378,-0.017148420432597,0.991318870265707,-0.034707338554096}),\n+                new ArrayRealVector(new double[] {0.855205995537564,0.327134656629775,-0.265382397060548,0.282690729026706,0.105736068025572,-0.009138126622039,0.000367751821196}),\n+                new ArrayRealVector(new double[] {-0.002913069901144,-0.005177515777101,0.041906334478672,-0.109315918416258,0.436192305456741,0.026307315639535,0.891797507436344}),\n+                new ArrayRealVector(new double[] {-0.005738311176435,-0.010207611670378,0.082662420517928,-0.215733886094368,0.861606487840411,-0.025478530652759,-0.451080697503958})\n+        };\n+\n+        // the following line triggers the exception\n+        EigenDecompositionImpl decomposition;\n+        decomposition = new EigenDecompositionImpl(mainTridiagonal,\n+                                                   secondaryTridiagonal,\n+                                                   MathUtils.SAFE_MIN);\n+\n+        double[] eigenValues = decomposition.getRealEigenvalues();\n+        for (int i = 0; i < refEigenValues.length; ++i) {\n+            Assert.assertEquals(refEigenValues[i], eigenValues[i], 1.0e-3);\n+            if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {\n+                Assert.assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n+            } else {\n+                Assert.assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n+            }\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testMathpbx03() {\n+\n+        double[] mainTridiagonal = {\n+            1809.0978259647177,3395.4763425956166,1832.1894584712693,3804.364873592377,\n+            806.0482458637571,2403.656427234185,28.48691431556015\n+        };\n+        double[] secondaryTridiagonal = {\n+            -656.8932064545833,-469.30804108920734,-1021.7714889369421,\n+            -1152.540497328983,-939.9765163817368,-12.885877015422391\n+        };\n+\n+        // the reference values have been computed using routine DSTEMR\n+        // from the fortran library LAPACK version 3.2.1\n+        double[] refEigenValues = {\n+            4603.121913685183245,3691.195818048970978,2743.442955402465032,1657.596442107321764,\n+            1336.797819095331306,30.129865209677519,17.035352085224986\n+        };\n+\n+        RealVector[] refEigenVectors = {\n+            new ArrayRealVector(new double[] {-0.036249830202337,0.154184732411519,-0.346016328392363,0.867540105133093,-0.294483395433451,0.125854235969548,-0.000354507444044}),\n+            new ArrayRealVector(new double[] {-0.318654191697157,0.912992309960507,-0.129270874079777,-0.184150038178035,0.096521712579439,-0.070468788536461,0.000247918177736}),\n+            new ArrayRealVector(new double[] {-0.051394668681147,0.073102235876933,0.173502042943743,-0.188311980310942,-0.327158794289386,0.905206581432676,-0.004296342252659}),\n+            new ArrayRealVector(new double[] {0.838150199198361,0.193305209055716,-0.457341242126146,-0.166933875895419,0.094512811358535,0.119062381338757,-0.000941755685226}),\n+            new ArrayRealVector(new double[] {0.438071395458547,0.314969169786246,0.768480630802146,0.227919171600705,-0.193317045298647,-0.170305467485594,0.001677380536009}),\n+            new ArrayRealVector(new double[] {-0.003726503878741,-0.010091946369146,-0.067152015137611,-0.113798146542187,-0.313123000097908,-0.118940107954918,0.932862311396062}),\n+            new ArrayRealVector(new double[] {0.009373003194332,0.025570377559400,0.170955836081348,0.291954519805750,0.807824267665706,0.320108347088646,0.360202112392266}),\n+        };\n+\n+        // the following line triggers the exception\n+        EigenDecompositionImpl decomposition;\n+        decomposition = new EigenDecompositionImpl(mainTridiagonal,\n+                                                   secondaryTridiagonal,\n+                                                   MathUtils.SAFE_MIN);\n+\n+        double[] eigenValues = decomposition.getRealEigenvalues();\n+        for (int i = 0; i < refEigenValues.length; ++i) {\n+            Assert.assertEquals(refEigenValues[i], eigenValues[i], 1.0e-4);\n+            if (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {\n+                Assert.assertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n+            } else {\n+                Assert.assertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n+            }\n+        }\n+\n+    }\n+\n+    /** test a matrix already in tridiagonal form. */\n+    @Test\n+    public void testTridiagonal() {\n+        Random r = new Random(4366663527842l);\n+        double[] ref = new double[30];\n+        for (int i = 0; i < ref.length; ++i) {\n+            if (i < 5) {\n+                ref[i] = 2 * r.nextDouble() - 1;\n+            } else {\n+                ref[i] = 0.0001 * r.nextDouble() + 6;\n+            }\n+        }\n+        Arrays.sort(ref);\n+        TriDiagonalTransformer t =\n+            new TriDiagonalTransformer(createTestMatrix(r, ref));\n+        EigenDecompositionImpl ed;\n+        ed = new EigenDecompositionImpl(t.getMainDiagonalRef(),\n+                                        t.getSecondaryDiagonalRef(),\n+                                        MathUtils.SAFE_MIN);\n+        double[] eigenValues = ed.getRealEigenvalues();\n+        Assert.assertEquals(ref.length, eigenValues.length);\n+        for (int i = 0; i < ref.length; ++i) {\n+            Assert.assertEquals(ref[ref.length - i - 1], eigenValues[i], 2.0e-14);\n+        }\n+\n+    }\n+\n+    /** test dimensions */\n+    @Test\n+    public void testDimensions() {\n+        final int m = matrix.getRowDimension();\n+        EigenDecompositionImpl ed;\n+        ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+        Assert.assertEquals(m, ed.getV().getRowDimension());\n+        Assert.assertEquals(m, ed.getV().getColumnDimension());\n+        Assert.assertEquals(m, ed.getD().getColumnDimension());\n+        Assert.assertEquals(m, ed.getD().getColumnDimension());\n+        Assert.assertEquals(m, ed.getVT().getRowDimension());\n+        Assert.assertEquals(m, ed.getVT().getColumnDimension());\n+    }\n+\n+    /** test eigenvalues */\n+    @Test\n+    public void testEigenvalues() {\n+        EigenDecompositionImpl ed;\n+        ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+        double[] eigenValues = ed.getRealEigenvalues();\n+        Assert.assertEquals(refValues.length, eigenValues.length);\n+        for (int i = 0; i < refValues.length; ++i) {\n+            Assert.assertEquals(refValues[i], eigenValues[i], 3.0e-15);\n+        }\n+    }\n+\n+    /** test eigenvalues for a big matrix. */\n+    @Test\n+    public void testBigMatrix() {\n+        Random r = new Random(17748333525117l);\n+        double[] bigValues = new double[200];\n+        for (int i = 0; i < bigValues.length; ++i) {\n+            bigValues[i] = 2 * r.nextDouble() - 1;\n+        }\n+        Arrays.sort(bigValues);\n+        EigenDecompositionImpl ed;\n+        ed = new EigenDecompositionImpl(createTestMatrix(r, bigValues),\n+                                        MathUtils.SAFE_MIN);\n+        double[] eigenValues = ed.getRealEigenvalues();\n+        Assert.assertEquals(bigValues.length, eigenValues.length);\n+        for (int i = 0; i < bigValues.length; ++i) {\n+            Assert.assertEquals(bigValues[bigValues.length - i - 1], eigenValues[i], 2.0e-14);\n+        }\n+    }\n+\n+    /** test eigenvectors */\n+    @Test\n+    public void testEigenvectors() {\n+        EigenDecompositionImpl ed;\n+        ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+        for (int i = 0; i < matrix.getRowDimension(); ++i) {\n+            double lambda = ed.getRealEigenvalue(i);\n+            RealVector v  = ed.getEigenvector(i);\n+            RealVector mV = matrix.operate(v);\n+            Assert.assertEquals(0, mV.subtract(v.mapMultiplyToSelf(lambda)).getNorm(), 1.0e-13);\n+        }\n+    }\n+\n+    /** test A = VDVt */\n+    @Test\n+    public void testAEqualVDVt() {\n+        EigenDecompositionImpl ed;\n+        ed = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN);\n+        RealMatrix v  = ed.getV();\n+        RealMatrix d  = ed.getD();\n+        RealMatrix vT = ed.getVT();\n+        double norm = v.multiply(d).multiply(vT).subtract(matrix).getNorm();\n+        Assert.assertEquals(0, norm, 6.0e-13);\n+    }\n+\n+    /** test that V is orthogonal */\n+    @Test\n+    public void testVOrthogonal() {\n+        RealMatrix v = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN).getV();\n+        RealMatrix vTv = v.transpose().multiply(v);\n+        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(vTv.getRowDimension());\n+        Assert.assertEquals(0, vTv.subtract(id).getNorm(), 2.0e-13);\n+    }\n+\n+    /** test diagonal matrix */\n+    @Test\n+    public void testDiagonal() {\n+        double[] diagonal = new double[] { -3.0, -2.0, 2.0, 5.0 };\n+        RealMatrix m = createDiagonalMatrix(diagonal, diagonal.length, diagonal.length);\n+        EigenDecompositionImpl ed;\n+        ed = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN);\n+        Assert.assertEquals(diagonal[0], ed.getRealEigenvalue(3), 2.0e-15);\n+        Assert.assertEquals(diagonal[1], ed.getRealEigenvalue(2), 2.0e-15);\n+        Assert.assertEquals(diagonal[2], ed.getRealEigenvalue(1), 2.0e-15);\n+        Assert.assertEquals(diagonal[3], ed.getRealEigenvalue(0), 2.0e-15);\n+    }\n+\n+    /**\n+     * Matrix with eigenvalues {8, -1, -1}\n+     */\n+    @Test\n+    public void testRepeatedEigenvalue() {\n+        RealMatrix repeated = MatrixUtils.createRealMatrix(new double[][] {\n+                {3,  2,  4},\n+                {2,  0,  2},\n+                {4,  2,  3}\n+        });\n+        EigenDecompositionImpl ed;\n+        ed = new EigenDecompositionImpl(repeated, MathUtils.SAFE_MIN);\n+        checkEigenValues((new double[] {8, -1, -1}), ed, 1E-12);\n+        checkEigenVector((new double[] {2, 1, 2}), ed, 1E-12);\n+    }\n+\n+    /**\n+     * Matrix with eigenvalues {2, 0, 12}\n+     */\n+    @Test\n+    public void testDistinctEigenvalues() {\n+        RealMatrix distinct = MatrixUtils.createRealMatrix(new double[][] {\n+                {3, 1, -4},\n+                {1, 3, -4},\n+                {-4, -4, 8}\n+        });\n+        EigenDecompositionImpl ed;\n+        ed = new EigenDecompositionImpl(distinct, MathUtils.SAFE_MIN);\n+        checkEigenValues((new double[] {2, 0, 12}), ed, 1E-12);\n+        checkEigenVector((new double[] {1, -1, 0}), ed, 1E-12);\n+        checkEigenVector((new double[] {1, 1, 1}), ed, 1E-12);\n+        checkEigenVector((new double[] {-1, -1, 2}), ed, 1E-12);\n+    }\n+\n+    /**\n+     * Verifies operation on indefinite matrix\n+     */\n+    @Test\n+    public void testZeroDivide() {\n+        RealMatrix indefinite = MatrixUtils.createRealMatrix(new double [][] {\n+                { 0.0, 1.0, -1.0 },\n+                { 1.0, 1.0, 0.0 },\n+                { -1.0,0.0, 1.0 }\n+        });\n+        EigenDecompositionImpl ed;\n+        ed = new EigenDecompositionImpl(indefinite, MathUtils.SAFE_MIN);\n+        checkEigenValues((new double[] {2, 1, -1}), ed, 1E-12);\n+        double isqrt3 = 1/FastMath.sqrt(3.0);\n+        checkEigenVector((new double[] {isqrt3,isqrt3,-isqrt3}), ed, 1E-12);\n+        double isqrt2 = 1/FastMath.sqrt(2.0);\n+        checkEigenVector((new double[] {0.0,-isqrt2,-isqrt2}), ed, 1E-12);\n+        double isqrt6 = 1/FastMath.sqrt(6.0);\n+        checkEigenVector((new double[] {2*isqrt6,-isqrt6,isqrt6}), ed, 1E-12);\n+    }\n+    /**\n+     * Verifies that the given EigenDecomposition has eigenvalues equivalent to\n+     * the targetValues, ignoring the order of the values and allowing\n+     * values to differ by tolerance.\n+     */\n+    protected void checkEigenValues(double[] targetValues,\n+            EigenDecompositionImpl ed, double tolerance) {\n+        double[] observed = ed.getRealEigenvalues();\n+        for (int i = 0; i < observed.length; i++) {\n+            Assert.assertTrue(isIncludedValue(observed[i], targetValues, tolerance));\n+            Assert.assertTrue(isIncludedValue(targetValues[i], observed, tolerance));\n+        }\n+    }\n+\n+\n+    /**\n+     * Returns true iff there is an entry within tolerance of value in\n+     * searchArray.\n+     */\n+    private boolean isIncludedValue(double value, double[] searchArray,\n+            double tolerance) {\n+       boolean found = false;\n+       int i = 0;\n+       while (!found && i < searchArray.length) {\n+           if (FastMath.abs(value - searchArray[i]) < tolerance) {\n+               found = true;\n+           }\n+           i++;\n+       }\n+       return found;\n+    }\n+\n+    /**\n+     * Returns true iff eigenVector is a scalar multiple of one of the columns\n+     * of ed.getV().  Does not try linear combinations - i.e., should only be\n+     * used to find vectors in one-dimensional eigenspaces.\n+     */\n+    protected void checkEigenVector(double[] eigenVector,\n+            EigenDecompositionImpl ed, double tolerance) {\n+        Assert.assertTrue(isIncludedColumn(eigenVector, ed.getV(), tolerance));\n+    }\n+\n+    /**\n+     * Returns true iff there is a column that is a scalar multiple of column\n+     * in searchMatrix (modulo tolerance)\n+     */\n+    private boolean isIncludedColumn(double[] column, RealMatrix searchMatrix,\n+            double tolerance) {\n+        boolean found = false;\n+        int i = 0;\n+        while (!found && i < searchMatrix.getColumnDimension()) {\n+            double multiplier = 1.0;\n+            boolean matching = true;\n+            int j = 0;\n+            while (matching && j < searchMatrix.getRowDimension()) {\n+                double colEntry = searchMatrix.getEntry(j, i);\n+                // Use the first entry where both are non-zero as scalar\n+                if (FastMath.abs(multiplier - 1.0) <= FastMath.ulp(1.0) && FastMath.abs(colEntry) > 1E-14\n+                        && FastMath.abs(column[j]) > 1e-14) {\n+                    multiplier = colEntry / column[j];\n+                }\n+                if (FastMath.abs(column[j] * multiplier - colEntry) > tolerance) {\n+                    matching = false;\n+                }\n+                j++;\n+            }\n+            found = matching;\n+            i++;\n+        }\n+        return found;\n+    }\n+\n+    @Before\n+    public void setUp() {\n+        refValues = new double[] {\n+                2.003, 2.002, 2.001, 1.001, 1.000, 0.001\n+        };\n+        matrix = createTestMatrix(new Random(35992629946426l), refValues);\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        refValues = null;\n+        matrix    = null;\n+    }\n+\n+    static RealMatrix createTestMatrix(final Random r, final double[] eigenValues) {\n+        final int n = eigenValues.length;\n+        final RealMatrix v = createOrthogonalMatrix(r, n);\n+        final RealMatrix d = createDiagonalMatrix(eigenValues, n, n);\n+        return v.multiply(d).multiply(v.transpose());\n+    }\n+\n+    public static RealMatrix createOrthogonalMatrix(final Random r, final int size) {\n+\n+        final double[][] data = new double[size][size];\n+\n+        for (int i = 0; i < size; ++i) {\n+            final double[] dataI = data[i];\n+            double norm2 = 0;\n+            do {\n+\n+                // generate randomly row I\n+                for (int j = 0; j < size; ++j) {\n+                    dataI[j] = 2 * r.nextDouble() - 1;\n+                }\n+\n+                // project the row in the subspace orthogonal to previous rows\n+                for (int k = 0; k < i; ++k) {\n+                    final double[] dataK = data[k];\n+                    double dotProduct = 0;\n+                    for (int j = 0; j < size; ++j) {\n+                        dotProduct += dataI[j] * dataK[j];\n+                    }\n+                    for (int j = 0; j < size; ++j) {\n+                        dataI[j] -= dotProduct * dataK[j];\n+                    }\n+                }\n+\n+                // normalize the row\n+                norm2 = 0;\n+                for (final double dataIJ : dataI) {\n+                    norm2 += dataIJ * dataIJ;\n+                }\n+                final double inv = 1.0 / FastMath.sqrt(norm2);\n+                for (int j = 0; j < size; ++j) {\n+                    dataI[j] *= inv;\n+                }\n+\n+            } while (norm2 * size < 0.01);\n+        }\n+\n+        return MatrixUtils.createRealMatrix(data);\n+\n+    }\n+\n+    public static RealMatrix createDiagonalMatrix(final double[] diagonal,\n+                                                  final int rows, final int columns) {\n+        final double[][] dData = new double[rows][columns];\n+        for (int i = 0; i < FastMath.min(rows, columns); ++i) {\n+            dData[i][i] = diagonal[i];\n+        }\n+        return MatrixUtils.createRealMatrix(dData);\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/math/linear/EigenSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/EigenSolverTest.java\n     public void testNonInvertible() {\n         Random r = new Random(9994100315209l);\n         RealMatrix m =\n-            EigenDecompositionImplTest.createTestMatrix(r, new double[] { 1.0, 0.0, -1.0, -2.0, -3.0 });\n+            EigenDecompositionTest.createTestMatrix(r, new double[] { 1.0, 0.0, -1.0, -2.0, -3.0 });\n         DecompositionSolver es = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN).getSolver();\n         Assert.assertFalse(es.isNonSingular());\n         try {\n     public void testInvertible() {\n         Random r = new Random(9994100315209l);\n         RealMatrix m =\n-            EigenDecompositionImplTest.createTestMatrix(r, new double[] { 1.0, 0.5, -1.0, -2.0, -3.0 });\n+            EigenDecompositionTest.createTestMatrix(r, new double[] { 1.0, 0.5, -1.0, -2.0, -3.0 });\n         DecompositionSolver es = new EigenDecompositionImpl(m, MathUtils.SAFE_MIN).getSolver();\n         Assert.assertTrue(es.isNonSingular());\n         RealMatrix inverse = es.getInverse();\n         final double[] refValues = new double[] {\n             2.003, 2.002, 2.001, 1.001, 1.000, 0.001\n         };\n-        final RealMatrix matrix = EigenDecompositionImplTest.createTestMatrix(new Random(35992629946426l), refValues);\n+        final RealMatrix matrix = EigenDecompositionTest.createTestMatrix(new Random(35992629946426l), refValues);\n \n         DecompositionSolver es = new EigenDecompositionImpl(matrix, MathUtils.SAFE_MIN).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[2][2]);\n--- a/src/test/java/org/apache/commons/math/linear/SingularValueDecompositionImplTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SingularValueDecompositionImplTest.java\n     private RealMatrix createTestMatrix(final Random r, final int rows, final int columns,\n                                         final double[] singularValues) {\n         final RealMatrix u =\n-            EigenDecompositionImplTest.createOrthogonalMatrix(r, rows);\n+            EigenDecompositionTest.createOrthogonalMatrix(r, rows);\n         final RealMatrix d =\n-            EigenDecompositionImplTest.createDiagonalMatrix(singularValues, rows, columns);\n+            EigenDecompositionTest.createDiagonalMatrix(singularValues, rows, columns);\n         final RealMatrix v =\n-            EigenDecompositionImplTest.createOrthogonalMatrix(r, columns);\n+            EigenDecompositionTest.createOrthogonalMatrix(r, columns);\n         return u.multiply(d).multiply(v);\n     }\n ", "timestamp": 1316673461, "metainfo": ""}