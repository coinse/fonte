{"sha": "0f37f87216b67d12b722d706f3e313b731ee31ab", "log": "MATH-925 Minimal implementation of a diagonal matrix. Unit tests are lacking.   ", "commit": "\n--- /dev/null\n+++ b/src/main/java/org/apache/commons/math3/linear/DiagonalMatrix.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math3.linear;\n+\n+import java.io.Serializable;\n+import org.apache.commons.math3.exception.DimensionMismatchException;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+import org.apache.commons.math3.exception.OutOfRangeException;\n+import org.apache.commons.math3.exception.MathUnsupportedOperationException;\n+\n+/**\n+ * Implementation of a diagonal matrix.\n+ * <br/>\n+ * Caveat: This implementation is minimal; it is currently solely aimed\n+ * at solving issue MATH-924. In particular many methods just throw\n+ * {@code MathUnsupportedOperationException}.\n+ *\n+ * @version $Id$\n+ */\n+public class DiagonalMatrix extends AbstractRealMatrix\n+    implements Serializable {\n+    /** Serializable version identifier. */\n+    private static final long serialVersionUID = 20121229L;\n+    /** Entries of the diagonal. */\n+    private double[] data;\n+\n+    /**\n+     * Creates a matrix with no data.\n+     */\n+    public DiagonalMatrix() {}\n+\n+    /**\n+     * Creates a matrix with the supplied dimension.\n+     *\n+     * @param dimension Number of rows and columns in the new matrix.\n+     * @param columnDimension Number of columns in the new matrix.\n+     * @throws NotStrictlyPositiveException if the dimension is\n+     * not positive.\n+     */\n+    public DiagonalMatrix(final int dimension)\n+        throws NotStrictlyPositiveException {\n+        super(dimension, dimension);\n+        data = new double[dimension];\n+    }\n+\n+    /**\n+     * Creates a matrix using the input array as the underlying data. \n+     * <br/>\n+     * The input array is copied, not referenced.\n+     *\n+     * @param d Data for the new matrix.\n+     */\n+    public DiagonalMatrix(final double[] d) {\n+        data = d.clone();\n+    }\n+\n+    /**\n+     * Creates a matrix using the input array as the underlying data.\n+     * <br/>\n+     * If an array is built specially in order to be embedded in a\n+     * RealMatrix and not used directly, the {@code copyArray} may be\n+     * set to {@code false}. This will prevent the copying and improve\n+     * performance as no new array will be built and no data will be copied.\n+     *\n+     * @param d Data for new matrix.\n+     * @param copyArray if {@code true}, the input array will be copied,\n+     * otherwise it will be referenced.\n+     */\n+    public DiagonalMatrix(final double[] d, final boolean copyArray) {\n+        data = copyArray ? d.clone() : d;\n+    }\n+\n+    /** \n+     * {@inheritDoc}\n+     *\n+     * @throws DimensionMismatchException if the requested dimensions are not equal.\n+     */\n+    @Override\n+    public RealMatrix createMatrix(final int rowDimension,\n+                                   final int columnDimension)\n+        throws NotStrictlyPositiveException,\n+               DimensionMismatchException {\n+        if (rowDimension != columnDimension) {\n+            throw new DimensionMismatchException(rowDimension, columnDimension);\n+        }\n+\n+        return new DiagonalMatrix(rowDimension);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public RealMatrix copy() {\n+        return new DiagonalMatrix(data);\n+    }\n+\n+    /**\n+     * Compute the sum of {@code this} and {@code m}.\n+     *\n+     * @param m Matrix to be added.\n+     * @return {@code this + m}.\n+     * @throws MatrixDimensionMismatchException if {@code m} is not the same\n+     * size as {@code this}.\n+     */\n+    public DiagonalMatrix add(final DiagonalMatrix m)\n+        throws MatrixDimensionMismatchException {\n+        // Safety check.\n+        MatrixUtils.checkAdditionCompatible(this, m);\n+\n+        final int dim = getRowDimension();\n+        final double[] outData = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            outData[i] = data[i] + m.data[i];\n+        }\n+\n+        return new DiagonalMatrix(outData, false);\n+    }\n+\n+    /**\n+     * Returns {@code this} minus {@code m}.\n+     *\n+     * @param m Matrix to be subtracted.\n+     * @return {@code this - m}\n+     * @throws MatrixDimensionMismatchException if {@code m} is not the same\n+     * size as {@code this}.\n+     */\n+    public DiagonalMatrix subtract(final DiagonalMatrix m)\n+        throws MatrixDimensionMismatchException {\n+        MatrixUtils.checkSubtractionCompatible(this, m);\n+\n+        final int dim = getRowDimension();\n+        final double[] outData = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            outData[i] = data[i] - m.data[i];\n+        }\n+\n+        return new DiagonalMatrix(outData, false);\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying {@code this} by {@code m}.\n+     *\n+     * @param m matrix to postmultiply by\n+     * @return {@code this * m}\n+     * @throws DimensionMismatchException if\n+     * {@code columnDimension(this) != rowDimension(m)}\n+     */\n+    public DiagonalMatrix multiply(final DiagonalMatrix m)\n+        throws DimensionMismatchException {\n+        MatrixUtils.checkMultiplicationCompatible(this, m);\n+\n+        final int dim = getRowDimension();\n+        final double[] outData = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            outData[i] = data[i] * m.data[i];\n+        }\n+\n+        return new DiagonalMatrix(outData, false);\n+    }\n+\n+    /**\n+     * Returns the result of postmultiplying {@code this} by {@code m}.\n+     *\n+     * @param m matrix to postmultiply by\n+     * @return {@code this * m}\n+     * @throws DimensionMismatchException if\n+     * {@code columnDimension(this) != rowDimension(m)}\n+     */\n+    public RealMatrix multiply(final RealMatrix m)\n+        throws DimensionMismatchException {\n+        if (m instanceof DiagonalMatrix) {\n+            return multiply((DiagonalMatrix) m);\n+        } else {\n+            MatrixUtils.checkMultiplicationCompatible(this, m);\n+            final int nRows = m.getRowDimension();\n+            final int nCols = m.getColumnDimension();\n+            final double[][] product = new double[nRows][nCols];\n+            for (int r = 0; r < nRows; r++) {\n+                for (int c = 0; c < nCols; c++) {\n+                    product[r][c] = data[r] * m.getEntry(r, c);\n+                }\n+            }\n+            return new Array2DRowRealMatrix(product, false);\n+        }\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[][] getData() {\n+        final int dim = getRowDimension();\n+        final double[][] out = new double[dim][dim];\n+\n+        for (int i = 0; i < dim; i++) {\n+            out[i][i] = data[i];\n+        }\n+\n+        return out;\n+    }\n+\n+    /**\n+     * Gets a reference to the underlying data array.\n+     *\n+     * @return 1-dimensional array of entries.\n+     */\n+    public double[] getDataRef() {\n+        return data;\n+    }\n+\n+    /**\n+     * @throws MathUnsupportedOperationException\n+     */\n+    @Override\n+    public void setSubMatrix(final double[][] subMatrix,\n+                             final int row,\n+                             final int column)\n+        throws MathUnsupportedOperationException {\n+        throw new MathUnsupportedOperationException();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double getEntry(final int row, final int column)\n+        throws OutOfRangeException {\n+        MatrixUtils.checkMatrixIndex(this, row, column);\n+        return row == column ? data[row] : 0;\n+    }\n+\n+    /** {@inheritDoc}\n+     * @throws MathUnsupportedOperationException if {@code row != column}.\n+     */\n+    @Override\n+    public void setEntry(final int row, final int column, final double value)\n+        throws OutOfRangeException,\n+               MathUnsupportedOperationException {\n+        if (row != column) {\n+            throw new MathUnsupportedOperationException();\n+        }\n+        MatrixUtils.checkMatrixIndex(this, row, column);\n+        data[row] = value;\n+    }\n+\n+    /** {@inheritDoc}\n+     * @throws MathUnsupportedOperationException if {@code row != column}.\n+     */\n+    @Override\n+    public void addToEntry(final int row,\n+                           final int column,\n+                           final double increment)\n+        throws OutOfRangeException,\n+               MathUnsupportedOperationException {\n+        if (row != column) {\n+            throw new MathUnsupportedOperationException();\n+        }\n+        MatrixUtils.checkMatrixIndex(this, row, column);\n+        data[row] += increment;\n+    }\n+\n+    /** {@inheritDoc}\n+     * @throws MathUnsupportedOperationException if {@code row != column}.\n+     */\n+    @Override\n+    public void multiplyEntry(final int row,\n+                              final int column,\n+                              final double factor)\n+        throws OutOfRangeException,\n+               MathUnsupportedOperationException {\n+        if (row != column) {\n+            throw new MathUnsupportedOperationException();\n+        }\n+        MatrixUtils.checkMatrixIndex(this, row, column);\n+        data[row] *= factor;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getRowDimension() {\n+        return data == null ? 0 : data.length;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getColumnDimension() {\n+        return getRowDimension();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[] operate(final double[] v)\n+        throws DimensionMismatchException {\n+        return multiply(new DiagonalMatrix(v, false)).getDataRef();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double[] preMultiply(final double[] v)\n+        throws DimensionMismatchException {\n+        return operate(v);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor)\n+        throws MathUnsupportedOperationException {\n+        throw new MathUnsupportedOperationException();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MathUnsupportedOperationException {\n+        throw new MathUnsupportedOperationException();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixChangingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MathUnsupportedOperationException {\n+        throw new MathUnsupportedOperationException();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor,\n+                                 final int startRow, final int endRow,\n+                                 final int startColumn, final int endColumn)\n+        throws MathUnsupportedOperationException {\n+        throw new MathUnsupportedOperationException();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor)\n+        throws MathUnsupportedOperationException {\n+        throw new MathUnsupportedOperationException();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor)\n+        throws MathUnsupportedOperationException {\n+        throw new MathUnsupportedOperationException();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInColumnOrder(final RealMatrixChangingVisitor visitor,\n+                                    final int startRow, final int endRow,\n+                                    final int startColumn, final int endColumn)\n+        throws MathUnsupportedOperationException {\n+        throw new MathUnsupportedOperationException();\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor,\n+                                    final int startRow, final int endRow,\n+                                    final int startColumn, final int endColumn)\n+        throws MathUnsupportedOperationException {\n+        throw new MathUnsupportedOperationException();\n+    }\n+}", "timestamp": 1356786711, "metainfo": ""}