{"sha": "0412df24e84e53397b3b5a6516aee1a4e12109c4", "log": "Renamed .univariate -> .descriptive, .multivariate -> .regression   ", "commit": "\n--- a/src/java/org/apache/commons/math/random/EmpiricalDistribution.java\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistribution.java\n import java.net.URL;\n import java.util.List;\n \n-import org.apache.commons.math.stat.univariate.StatisticalSummary;\n+import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n \n /**\n  * Represents an <a href=\"http://random.mat.sbg.ac.at/~ste/dipl/node11.html\">\n  * generate random values \"like\" those in the input file -- i.e., the values\n  * generated will follow the distribution of the values in the file.\n  * \n- * @version $Revision: 1.22 $ $Date: 2004/07/22 02:34:25 $\n+ * @version $Revision: 1.23 $ $Date: 2004/10/08 05:08:16 $\n  */\n public interface EmpiricalDistribution {\n \n \n     /**\n      * Returns a \n-     * {@link org.apache.commons.math.stat.univariate.StatisticalSummary} \n+     * {@link org.apache.commons.math.stat.descriptive.StatisticalSummary} \n      * describing this distribution.\n      * <strong>Preconditions:</strong><ul>\n      * <li>the distribution must be loaded before invoking this method</li>\n \n     /**\n      * Returns a list of \n-     * {@link org.apache.commons.math.stat.univariate.SummaryStatistics}\n+     * {@link org.apache.commons.math.stat.descriptive.SummaryStatistics}\n      * containing statistics describing the values in each of the bins.  The\n      * List is indexed on the bin number.\n      * \n--- a/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/random/EmpiricalDistributionImpl.java\n import java.util.ArrayList;\n import java.util.List;\n \n-import org.apache.commons.math.stat.univariate.SummaryStatistics;\n-import org.apache.commons.math.stat.univariate.StatisticalSummary;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n \n /**\n  * Implements <code>EmpiricalDistribution</code> interface.  This implementation\n  *    entry per line.</li>\n  * </ul></p>\n  *\n- * @version $Revision: 1.29 $ $Date: 2004/07/20 12:53:54 $\n+ * @version $Revision: 1.30 $ $Date: 2004/10/08 05:08:16 $\n  */\n public class EmpiricalDistributionImpl implements Serializable, EmpiricalDistribution {\n \n--- a/src/java/org/apache/commons/math/stat/StatUtils.java\n+++ b/src/java/org/apache/commons/math/stat/StatUtils.java\n  */\n package org.apache.commons.math.stat;\n \n-import org.apache.commons.math.stat.univariate.UnivariateStatistic;\n-import org.apache.commons.math.stat.univariate.moment.GeometricMean;\n-import org.apache.commons.math.stat.univariate.moment.Mean;\n-import org.apache.commons.math.stat.univariate.moment.Variance;\n-import org.apache.commons.math.stat.univariate.rank.Max;\n-import org.apache.commons.math.stat.univariate.rank.Min;\n-import org.apache.commons.math.stat.univariate.rank.Percentile;\n-import org.apache.commons.math.stat.univariate.summary.Product;\n-import org.apache.commons.math.stat.univariate.summary.Sum;\n-import org.apache.commons.math.stat.univariate.summary.SumOfLogs;\n-import org.apache.commons.math.stat.univariate.summary.SumOfSquares;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.moment.GeometricMean;\n+import org.apache.commons.math.stat.descriptive.moment.Mean;\n+import org.apache.commons.math.stat.descriptive.moment.Variance;\n+import org.apache.commons.math.stat.descriptive.rank.Max;\n+import org.apache.commons.math.stat.descriptive.rank.Min;\n+import org.apache.commons.math.stat.descriptive.rank.Percentile;\n+import org.apache.commons.math.stat.descriptive.summary.Product;\n+import org.apache.commons.math.stat.descriptive.summary.Sum;\n+import org.apache.commons.math.stat.descriptive.summary.SumOfLogs;\n+import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n \n /**\n  * StatUtils provides static methods for computing statistics based on data\n  * stored in double[] arrays. \n  * \n- * @version $Revision: 1.32 $ $Date: 2004/09/01 15:51:39 $\n+ * @version $Revision: 1.33 $ $Date: 2004/10/08 05:08:16 $\n  */\n public final class StatUtils {\n \n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.\n      * <p>\n-     * See {@link org.apache.commons.math.stat.univariate.summary.SumOfLogs}.\n+     * See {@link org.apache.commons.math.stat.descriptive.summary.SumOfLogs}.\n      * \n      * @param values the input array\n      * @return the sum of the natural logs of the values or Double.NaN if \n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.\n      * <p>\n-      * See {@link org.apache.commons.math.stat.univariate.summary.SumOfLogs}.\n+      * See {@link org.apache.commons.math.stat.descriptive.summary.SumOfLogs}.\n      * \n      * @param values the input array\n      * @param begin index of the first array element to include\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.\n      * <p>\n-     * See {@link org.apache.commons.math.stat.univariate.moment.Mean} for\n+     * See {@link org.apache.commons.math.stat.descriptive.moment.Mean} for\n      * details on the computing algorithm.\n      * \n      * @param values the input array\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.\n      * <p>\n-     * See {@link org.apache.commons.math.stat.univariate.moment.Mean} for\n+     * See {@link org.apache.commons.math.stat.descriptive.moment.Mean} for\n      * details on the computing algorithm.\n      * \n      * @param values the input array\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.\n      * <p>\n-     * See {@link org.apache.commons.math.stat.univariate.moment.GeometricMean}\n+     * See {@link org.apache.commons.math.stat.descriptive.moment.GeometricMean}\n      * for details on the computing algorithm.\n      * \n      * @param values the input array\n      * <p>\n      * Throws <code>IllegalArgumentException</code> if the array is null.\n      * <p>\n-     * See {@link org.apache.commons.math.stat.univariate.moment.GeometricMean}\n+     * See {@link org.apache.commons.math.stat.descriptive.moment.GeometricMean}\n      * for details on the computing algorithm.\n      * \n      * @param values the input array\n      * Returns the variance of the entries in the input array, or \n      * <code>Double.NaN</code> if the array is empty.\n      * <p>\n-     * See {@link org.apache.commons.math.stat.univariate.moment.Variance} for\n+     * See {@link org.apache.commons.math.stat.descriptive.moment.Variance} for\n      * details on the computing algorithm.\n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.\n      * the input array, or <code>Double.NaN</code> if the designated subarray\n      * is empty.\n      * <p>\n-     * See {@link org.apache.commons.math.stat.univariate.moment.Variance} for\n+     * See {@link org.apache.commons.math.stat.descriptive.moment.Variance} for\n      * details on the computing algorithm.\n      * <p>\n      * Returns 0 for a single-value (i.e. length = 1) sample.\n      * the input array, using the precomputed mean value.  Returns \n      * <code>Double.NaN</code> if the designated subarray is empty.\n      * <p>\n-     * See {@link org.apache.commons.math.stat.univariate.moment.Variance} for\n+     * See {@link org.apache.commons.math.stat.descriptive.moment.Variance} for\n      * details on the computing algorithm.\n      * <p>\n      * The formula used assumes that the supplied mean value is the arithmetic\n      * precomputed mean value.  Returns <code>Double.NaN</code> if the array\n      * is empty.  \n      * <p>\n-     * See {@link org.apache.commons.math.stat.univariate.moment.Variance} for\n+     * See {@link org.apache.commons.math.stat.descriptive.moment.Variance} for\n      * details on the computing algorithm.   \n      * <p>\n      * The formula used assumes that the supplied mean value is the arithmetic\n      * and less than or equal to 100)</li>\n      * </ul>\n      * <p>\n-     * See {@link org.apache.commons.math.stat.univariate.rank.Percentile} for\n+     * See {@link org.apache.commons.math.stat.descriptive.rank.Percentile} for\n      * a description of the percentile estimation algorithm used.\n      * \n      * @param values input array of values\n      * and less than or equal to 100)</li>\n      * </ul>\n      * <p>\n-      * See {@link org.apache.commons.math.stat.univariate.rank.Percentile} for\n+      * See {@link org.apache.commons.math.stat.descriptive.rank.Percentile} for\n       * a description of the percentile estimation algorithm used.\n      * \n      * @param values array of input values\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/AbstractStorelessUnivariateStatistic.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import org.apache.commons.math.util.MathUtils;\n+import java.io.Serializable;\n+\n+/**\n+ *\n+ * Abstract Implementation for the {@link StorelessUnivariateStatistic} interface.\n+ * <p>\n+ * Provides default <code>evaluate()</code> and <code>incrementAll(double[])<code>\n+ * implementations. \n+ * <p>\n+ * <strong>Note that these implementations are not synchronized.</strong>\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public abstract class AbstractStorelessUnivariateStatistic\n+    extends AbstractUnivariateStatistic\n+    implements StorelessUnivariateStatistic, Serializable {\n+\n+    /** Serialization UID */\n+    static final long serialVersionUID = -44915725420072521L;\n+    \n+    /**\n+     * This default implementation calls {@link #clear}, then invokes \n+     * {@link #increment} in a loop over the the input array, and then uses \n+     * {@link #getResult} to compute the return value.  \n+     * <p>\n+     * Note that this implementation changes the internal state of the\n+     * statistic.  Its side effects are the same as invoking {@link #clear} and\n+     * then {@link #incrementAll(double[])}.\n+     * <p>\n+     * Implementations may override this method with a more efficient \n+     * implementation that works directly with the input array.\n+     * <p>\n+     * If the array is null, an IllegalArgumentException is thrown.\n+     * \n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatistic#evaluate(double[])\n+     */\n+    public double evaluate(final double[] values) {\n+        if (values == null) {\n+            throw new IllegalArgumentException(\"input value array is null\");\n+        }\n+        return evaluate(values, 0, values.length);\n+    }\n+    \n+    /**\n+     * This default implementation calls {@link #clear}, then invokes \n+     * {@link #increment} in a loop over the specified portion of the input \n+     * array, and then uses {@link #getResult} to compute the return value.  \n+     * <p>\n+     * Note that this implementation changes the internal state of the\n+     * statistic.  Its side effects are the same as invoking {@link #clear} and\n+     * then {@link #incrementAll(double[], int, int)}.\n+     * <p>\n+     * Implementations may override this method with a more efficient \n+     * implementation that works directly with the input array.\n+     * <p>\n+     * If the array is null or the index parameters are not valid, an \n+     * IllegalArgumentException is thrown.\n+     * \n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatistic#evaluate(double[], int, int)\n+     */\n+    public double evaluate(final double[] values, final int begin, final int length) {\n+        if (test(values, begin, length)) {\n+            clear();\n+            incrementAll(values, begin, length);\n+        }\n+        return getResult();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     */\n+    public abstract void clear();\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     */\n+    public abstract double getResult();\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     */\n+    public abstract void increment(final double d);\n+    \n+    /**\n+     * This default implementation just calls {@link #increment} in a loop over\n+     * the input array.   \n+     * <p>\n+     * Throws IllegalArgumentException if the input values array is null.\n+     * \n+     * @param values values to add\n+     * @throws IllegalArgumentException if values is null\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#incrementAll(double[])\n+     */\n+    public void incrementAll(double[] values) {\n+        if (values == null) {\n+            throw new IllegalArgumentException(\"input values array is null\");\n+        }\n+        incrementAll(values, 0, values.length);\n+    } \n+   \n+    /**\n+     * This default implementation just calls {@link #increment} in a loop over\n+     * the specified portion of the input array.\n+     * <p>\n+     * Throws IllegalArgumentException if the input values array is null.\n+     * \n+     * @param values  array holding values to add\n+     * @param begin   index of the first array element to add\n+     * @param length  number of array elements to add\n+     * @throws IllegalArgumentException if values is null\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#incrementAll(double[], int, int)\n+     */\n+    public void incrementAll(double[] values, int begin, int length) {\n+        if (test(values, begin, length)) {\n+            int k = begin + length;\n+            for (int i = begin; i < k; i++) {\n+                increment(values[i]);\n+            }   \n+        }\n+    }\n+    \n+    /**\n+     * Returns true iff <code>object</code> is an \n+     * <code>AbstractStorelessUnivariateStatistic</code> returning the same\n+     * values as this for <code>getResult()</code> and <code>getN()</code>\n+     * @param object object to test equality against.\n+     * @return true if object returns the same value as this\n+     */\n+    public boolean equals(Object object) {\n+        if (object == this ) {\n+            return true;\n+        }\n+       if (object instanceof AbstractStorelessUnivariateStatistic == false) {\n+            return false;\n+        }\n+        AbstractStorelessUnivariateStatistic stat = (AbstractStorelessUnivariateStatistic) object;\n+        return (MathUtils.equals(stat.getResult(), this.getResult()) && \n+                MathUtils.equals(stat.getN(), this.getN()));\n+    }\n+    \n+    /**\n+     * Returns hash code based on getResult() and getN()\n+     * \n+     * @return hash code\n+     */\n+    public int hashCode() {\n+        return 31* (31 + MathUtils.hash(getResult())) + MathUtils.hash(getN());\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatistic.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Abstract base class for all implementations of the \n+ * {@link UnivariateStatistic} interface.\n+ * <p>\n+ * Provides a default implementation of <code>evaluate(double[]),</code> \n+ * delegating to <code>evaluate(double[], int, int)</code> in the natural way.\n+ * <p>\n+ * Also includes a <code>test</code> method that performs generic parameter\n+ * validation for the <code>evaluate</code> methods.\n+ * <p>\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public abstract class AbstractUnivariateStatistic\n+    implements UnivariateStatistic, Serializable {\n+    \n+    /** Serialization UID */\n+    static final long serialVersionUID = -8007759382851708045L;\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatistic#evaluate(double[])\n+     */\n+    public double evaluate(final double[] values) {\n+        test(values, 0, 0);\n+        return evaluate(values, 0, values.length);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatistic#evaluate(double[], int, int)\n+     */\n+    public abstract double evaluate(final double[] values, final int begin, final int length);\n+\n+    /**\n+     * This method is used by <code>evaluate(double[], int, int)</code> methods\n+     * to verify that the input parameters designate a subarray of positive length.\n+     * <p>\n+     * <ul>\n+     * <li>returns <code>true</code> iff the parameters designate a subarray of \n+     * positive length</li>\n+     * <li>throws <code>IllegalArgumentException</code> if the array is null or\n+     * or the indices are invalid</li>\n+     * <li>returns <code>false</li> if the array is non-null, but \n+     * <code>length</code> is 0.\n+     * </ul>\n+     *\n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return true if the parameters are valid and designate a subarray of positive length\n+     * @throws IllegalArgumentException if the indices are invalid or the array is null\n+     */\n+    protected boolean test(\n+        final double[] values,\n+        final int begin,\n+        final int length) {\n+\n+        if (values == null) {\n+            throw new IllegalArgumentException(\"input value array is null\");\n+        }\n+        \n+        if (begin < 0) {\n+            throw new IllegalArgumentException(\"start position cannot be negative\");\n+        }\n+        \n+        if (length < 0) {\n+            throw new IllegalArgumentException(\"length cannot be negative\");\n+        }\n+        \n+        if (begin + length > values.length) {\n+            throw new IllegalArgumentException(\n+                \"begin + length > values.length\");\n+        }\n+\n+        if (length == 0) {\n+            return false;\n+        }\n+\n+        return true;\n+\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatistics.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+\n+import org.apache.commons.discovery.tools.DiscoverClass;\n+import org.apache.commons.math.stat.descriptive.moment.GeometricMean;\n+import org.apache.commons.math.stat.descriptive.moment.Kurtosis;\n+import org.apache.commons.math.stat.descriptive.moment.Mean;\n+import org.apache.commons.math.stat.descriptive.moment.Skewness;\n+import org.apache.commons.math.stat.descriptive.moment.Variance;\n+import org.apache.commons.math.stat.descriptive.rank.Max;\n+import org.apache.commons.math.stat.descriptive.rank.Min;\n+import org.apache.commons.math.stat.descriptive.rank.Percentile;\n+import org.apache.commons.math.stat.descriptive.summary.Sum;\n+import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n+\n+\n+/**\n+ * Abstract factory class for univariate statistical summaries.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public abstract class DescriptiveStatistics implements StatisticalSummary, Serializable {\n+    \n+    /** Serialization UID */\n+    static final long serialVersionUID = 5188298269533339922L;\n+    \n+    /**\n+     * Create an instance of a <code>DescriptiveStatistics</code>\n+     * @param cls the type of <code>DescriptiveStatistics</code> object to\n+     *        create. \n+     * @return a new factory. \n+     * @throws InstantiationException is thrown if the object can not be\n+     *            created.\n+     * @throws IllegalAccessException is thrown if the type's default\n+     *            constructor is not accessible.\n+     */\n+    public static DescriptiveStatistics newInstance(Class cls) throws InstantiationException, IllegalAccessException {\n+        return (DescriptiveStatistics)cls.newInstance();\n+    }\n+    \n+    /**\n+     * Create an instance of a <code>DescriptiveStatistics</code>\n+     * @return a new factory. \n+     */\n+    public static DescriptiveStatistics newInstance() {\n+        DescriptiveStatistics factory = null;\n+        try {\n+            DiscoverClass dc = new DiscoverClass();\n+            factory = (DescriptiveStatistics) dc.newInstance(\n+                DescriptiveStatistics.class,\n+                \"org.apache.commons.math.stat.descriptive.DescriptiveStatisticsImpl\");\n+        } catch(Throwable t) {\n+            return new DescriptiveStatisticsImpl();\n+        }\n+        return factory;\n+    }\n+    \n+    /**\n+     * This constant signals that a Univariate implementation\n+     * takes into account the contributions of an infinite number of\n+     * elements.  In other words, if getWindow returns this\n+     * constant, there is, in effect, no \"window\".\n+     */\n+    public static final int INFINITE_WINDOW = -1;\n+\n+    /**\n+     * Adds the value to the set of numbers\n+     * @param v the value to be added \n+     */\n+    public abstract void addValue(double v);\n+\n+    /** \n+     * Returns the <a href=\"http://www.xycoon.com/arithmetic_mean.htm\">\n+     * arithmetic mean </a> of the available values \n+     * @return The mean or Double.NaN if no values have been added.\n+     */\n+    public double getMean() {\n+        return apply(new Mean());\n+    }\n+\n+    /** \n+     * Returns the <a href=\"http://www.xycoon.com/geometric_mean.htm\">\n+     * geometric mean </a> of the available values\n+     * @return The geometricMean, Double.NaN if no values have been added, \n+     * or if the productof the available values is less than or equal to 0.\n+     */\n+    public double getGeometricMean() {\n+        return apply(new GeometricMean());\n+    }\n+\n+    /** \n+     * Returns the variance of the available values.\n+     * @return The variance, Double.NaN if no values have been added \n+     * or 0.0 for a single value set.  \n+     */\n+    public double getVariance() {\n+        return apply(new Variance());\n+    }\n+\n+    /** \n+     * Returns the standard deviation of the available values.\n+     * @return The standard deviation, Double.NaN if no values have been added \n+     * or 0.0 for a single value set. \n+     */\n+    public double getStandardDeviation() {\n+        double stdDev = Double.NaN;\n+        if (getN() > 0) {\n+            if (getN() > 1) {\n+                stdDev = Math.sqrt(getVariance());\n+            } else {\n+                stdDev = 0.0;\n+            }\n+        }\n+        return (stdDev);\n+    }\n+\n+    /**\n+     * Returns the skewness of the available values. Skewness is a \n+     * measure of the assymetry of a given distribution.\n+     * @return The skewness, Double.NaN if no values have been added \n+     * or 0.0 for a value set &lt;=2. \n+     */\n+    public double getSkewness() {\n+        return apply(new Skewness());\n+    }\n+\n+    /**\n+     * Returns the Kurtosis of the available values. Kurtosis is a \n+     * measure of the \"peakedness\" of a distribution\n+     * @return The kurtosis, Double.NaN if no values have been added, or 0.0 \n+     * for a value set &lt;=3. \n+     */\n+    public double getKurtosis() {\n+        return apply(new Kurtosis());\n+    }\n+\n+    /** \n+     * Returns the maximum of the available values\n+     * @return The max or Double.NaN if no values have been added.\n+     */\n+    public double getMax() {\n+        return apply(new Max());\n+    }\n+\n+    /** \n+    * Returns the minimum of the available values\n+    * @return The min or Double.NaN if no values have been added.\n+    */\n+    public double getMin() {\n+        return apply(new Min());\n+    }\n+\n+    /** \n+     * Returns the number of available values\n+     * @return The number of available values\n+     */\n+    public abstract long getN();\n+\n+    /**\n+     * Returns the sum of the values that have been added to Univariate.\n+     * @return The sum or Double.NaN if no values have been added\n+     */\n+    public double getSum() {\n+        return apply(new Sum());\n+    }\n+\n+    /**\n+     * Returns the sum of the squares of the available values.\n+     * @return The sum of the squares or Double.NaN if no \n+     * values have been added.\n+     */\n+    public double getSumsq() {\n+        return apply(new SumOfSquares());\n+    }\n+\n+    /** \n+     * Resets all statistics and storage\n+     */\n+    public abstract void clear();\n+\n+    /**\n+     * Univariate has the ability to return only measures for the\n+     * last N elements added to the set of values.\n+     * @return The current window size or -1 if its Infinite.\n+     */\n+\n+    public abstract int getWindowSize();\n+\n+    /**\n+     * WindowSize controls the number of values which contribute \n+     * to the values returned by Univariate.  For example, if \n+     * windowSize is set to 3 and the values {1,2,3,4,5} \n+     * have been added <strong> in that order</strong> \n+     * then the <i>available values</i> are {3,4,5} and all\n+     * reported statistics will be based on these values\n+     * @param windowSize sets the size of the window.\n+     */\n+    public abstract void setWindowSize(int windowSize);\n+    \n+    /**\n+     * Returns the current set of values in an array of double primitives.  \n+     * The order of addition is preserved.  The returned array is a fresh\n+     * copy of the underlying data -- i.e., it is not a reference to the\n+     * stored data.\n+     * \n+     * @return returns the current set of numbers in the order in which they \n+     *         were added to this set\n+     */\n+    public abstract double[] getValues();\n+\n+    /**\n+     * Returns the current set of values in an array of double primitives,  \n+     * sorted in ascending order.  The returned array is a fresh\n+     * copy of the underlying data -- i.e., it is not a reference to the\n+     * stored data.\n+     * @return returns the current set of \n+     * numbers sorted in ascending order        \n+     */\n+    public double[] getSortedValues() {\n+        double[] sort = getValues();\n+        Arrays.sort(sort);\n+        return sort;\n+    }\n+\n+    /**\n+     * Returns the element at the specified index\n+     * @param index The Index of the element\n+     * @return return the element at the specified index\n+     */\n+    public abstract double getElement(int index);\n+\n+    /**\n+     * Returns an estimate for the pth percentile of the stored values. \n+     * <p>\n+     * The implementation provided here follows the first estimation procedure presented\n+     * <a href=\"http://www.itl.nist.gov/div898/handbook/prc/section2/prc252.htm\">here.</a>\n+     * <p>\n+     * <strong>Preconditions</strong>:<ul>\n+     * <li><code>0 &lt; p &lt; 100</code> (otherwise an \n+     * <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li>at least one value must be stored (returns <code>Double.NaN\n+     *     </code> otherwise)</li>\n+     * </ul>\n+     * \n+     * @param p the requested percentile (scaled from 0 - 100)\n+     * @return An estimate for the pth percentile of the stored data \n+     * values\n+     */\n+    public double getPercentile(double p) {\n+        return apply(new Percentile(p));\n+    }\n+    \n+    /**\n+     * Generates a text report displaying univariate statistics from values\n+     * that have been added.  Each statistic is displayed on a separate\n+     * line.\n+     * \n+     * @return String with line feeds displaying statistics\n+     */\n+    public String toString() {\n+        StringBuffer outBuffer = new StringBuffer();\n+        outBuffer.append(\"DescriptiveStatistics:\\n\");\n+        outBuffer.append(\"n: \" + getN() + \"\\n\");\n+        outBuffer.append(\"min: \" + getMin() + \"\\n\");\n+        outBuffer.append(\"max: \" + getMax() + \"\\n\");\n+        outBuffer.append(\"mean: \" + getMean() + \"\\n\");\n+        outBuffer.append(\"std dev: \" + getStandardDeviation() + \"\\n\");\n+        outBuffer.append(\"median: \" + getPercentile(50) + \"\\n\");\n+        outBuffer.append(\"skewness: \" + getSkewness() + \"\\n\");\n+        outBuffer.append(\"kurtosis: \" + getKurtosis() + \"\\n\");\n+        return outBuffer.toString();\n+    }\n+    \n+    /**\n+     * Apply the given statistic to the data associated with this set of statistics.\n+     * @param stat the statistic to apply\n+     * @return the computed value of the statistic.\n+     */\n+    public abstract double apply(UnivariateStatistic stat);\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsImpl.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.util.ResizableDoubleArray;\n+\n+/**\n+ * Default implementation of\n+ * {@link org.apache.commons.math.stat.descriptive.DescriptiveStatistics}.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public class DescriptiveStatisticsImpl extends DescriptiveStatistics implements Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -1868088725461221010L;\n+    \n+    /** hold the window size **/\n+    protected int windowSize;\n+    \n+    /** \n+     *  Stored data values\n+     */\n+    protected ResizableDoubleArray eDA;\n+\n+    /**\n+     * Construct a DescriptiveStatisticsImpl with infinite window\n+     */\n+    public DescriptiveStatisticsImpl() {\n+        this(INFINITE_WINDOW);\n+    }\n+    \n+    /**\n+     * Construct a DescriptiveStatisticsImpl with finite window\n+     * @param window the finite window size.\n+     */\n+    public DescriptiveStatisticsImpl(int window) {\n+        super();\n+        eDA = new ResizableDoubleArray();\n+        setWindowSize(window);\n+    }\n+\n+    /**\n+     * Access the window size.\n+     * @return the current window size.\n+     */\n+    public int getWindowSize() {\n+        return windowSize;\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getValues()\n+     */\n+    public double[] getValues() {\n+\n+        double[] copiedArray = new double[eDA.getNumElements()];\n+        System.arraycopy(\n+            eDA.getElements(),\n+            0,\n+            copiedArray,\n+            0,\n+            eDA.getNumElements());\n+        return copiedArray;\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getElement(int)\n+     */\n+    public double getElement(int index) {\n+        return eDA.getElement(index);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getN()\n+     */\n+    public long getN() {\n+        return eDA.getNumElements();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#addValue(double)\n+     */\n+    public void addValue(double v) {\n+        if (windowSize != INFINITE_WINDOW) {\n+            if (getN() == windowSize) {\n+                eDA.addElementRolling(v);\n+            } else if (getN() < windowSize) {\n+                eDA.addElement(v);\n+            }\n+        } else {\n+            eDA.addElement(v);\n+        }\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#clear()\n+     */\n+    public void clear() {\n+        eDA.clear();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#setWindowSize(int)\n+     */\n+    public void setWindowSize(int windowSize) {\n+        if (windowSize < 1) {\n+            if (windowSize != INFINITE_WINDOW) {\n+                throw new IllegalArgumentException(\"window size must be positive.\");\n+            }\n+        }\n+        \n+        this.windowSize = windowSize;\n+\n+        // We need to check to see if we need to discard elements\n+        // from the front of the array.  If the windowSize is less than \n+        // the current number of elements.\n+        if (windowSize != INFINITE_WINDOW && windowSize < eDA.getNumElements()) {\n+            eDA.discardFrontElements(eDA.getNumElements() - windowSize);\n+        }\n+    }\n+\n+    /**\n+     * Apply the given statistic to this univariate collection.\n+     * @param stat the statistic to apply\n+     * @return the computed value of the statistic.\n+     */\n+    public double apply(UnivariateStatistic stat) {\n+        return stat.evaluate(eDA.getValues(), eDA.start(), eDA.getNumElements());\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/StatisticalSummary.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+/**\n+ *  Reporting interface for basic univariate statistics.\n+ *\n+  * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public interface StatisticalSummary {\n+    /** \n+     * Returns the <a href=\"http://www.xycoon.com/arithmetic_mean.htm\">\n+     * arithmetic mean </a> of the available values \n+     * @return The mean or Double.NaN if no values have been added.\n+     */\n+    public abstract double getMean();\n+    /** \n+     * Returns the variance of the available values.\n+     * @return The variance, Double.NaN if no values have been added \n+     * or 0.0 for a single value set.  \n+     */\n+    public abstract double getVariance();\n+    /** \n+     * Returns the standard deviation of the available values.\n+     * @return The standard deviation, Double.NaN if no values have been added \n+     * or 0.0 for a single value set. \n+     */\n+    public abstract double getStandardDeviation();\n+    /** \n+     * Returns the maximum of the available values\n+     * @return The max or Double.NaN if no values have been added.\n+     */\n+    public abstract double getMax();\n+    /** \n+    * Returns the minimum of the available values\n+    * @return The min or Double.NaN if no values have been added.\n+    */\n+    public abstract double getMin();\n+    /** \n+     * Returns the number of available values\n+     * @return The number of available values\n+     */\n+    public abstract long getN();\n+    /**\n+     * Returns the sum of the values that have been added to Univariate.\n+     * @return The sum or Double.NaN if no values have been added\n+     */\n+    public abstract double getSum();\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/StatisticalSummaryValues.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.io.Serializable;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ *  Value object representing the results of a univariate statistical summary.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public class StatisticalSummaryValues implements Serializable, \n+    StatisticalSummary {\n+   \n+    /** Serialization id */\n+    static final long serialVersionUID = -5108854841843722536L;\n+\n+    /** The sample mean */\n+    private final double mean;\n+    \n+    /** The sample variance */\n+    private final double variance;\n+    \n+    /** The number of observations in the sample */\n+    private final long n;\n+    \n+    /** The maximum value */\n+    private final double max;\n+    \n+    /** The minimum value */\n+    private final double min;\n+    \n+    /** The sum of the sample values */\n+    private final double sum;\n+    \n+    /**\n+      * Constructor\n+      * \n+      * @param mean  the sample mean\n+      * @param variance  the sample variance\n+      * @param n  the number of observations in the sample \n+      * @param max  the maximum value\n+      * @param min  the minimum value\n+      * @param sum  the sum of the values\n+     */\n+    public StatisticalSummaryValues(double mean, double variance, long n,\n+        double max, double min, double sum) {\n+        super();\n+        this.mean = mean;\n+        this.variance = variance;\n+        this.n = n;\n+        this.max = max;\n+        this.min = min;\n+        this.sum = sum;\n+    }\n+\n+    /**\n+     * @return Returns the max.\n+     */\n+    public double getMax() {\n+        return max;\n+    }\n+\n+    /**\n+     * @return Returns the mean.\n+     */\n+    public double getMean() {\n+        return mean;\n+    }\n+\n+    /**\n+     * @return Returns the min.\n+     */\n+    public double getMin() {\n+        return min;\n+    }\n+\n+    /**\n+     * @return Returns the number of values.\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+\n+    /**\n+     * @return Returns the sum.\n+     */\n+    public double getSum() {\n+        return sum;\n+    }\n+    \n+    /**\n+     * @return Returns the standard deviation\n+     */\n+    public double getStandardDeviation() {\n+        return Math.sqrt(variance);\n+    }\n+\n+    /**\n+     * @return Returns the variance.\n+     */\n+    public double getVariance() {\n+        return variance;\n+    }\n+    \n+    /**\n+     * Returns true iff <code>object</code> is a \n+     * <code>StatisticalSummaryValues</code> instance and all statistics have\n+     *  the same values as this.\n+     * \n+     * @param object the object to test equality against.\n+     * @return true if object equals this\n+     */\n+    public boolean equals(Object object) {\n+        if (object == this ) {\n+            return true;\n+        }\n+        if (object instanceof StatisticalSummaryValues == false) {\n+            return false;\n+        }\n+        StatisticalSummaryValues stat = (StatisticalSummaryValues) object;\n+        return (MathUtils.equals(stat.getMax(), this.getMax()) && \n+                MathUtils.equals(stat.getMean(),this.getMean()) &&\n+                MathUtils.equals(stat.getMin(),this.getMin()) &&\n+                MathUtils.equals(stat.getN(), this.getN()) &&\n+                MathUtils.equals(stat.getSum(), this.getSum()) &&\n+                MathUtils.equals(stat.getVariance(),this.getVariance()));\n+    }\n+    \n+    /**\n+     * Returns hash code based on values of statistics\n+     * \n+     * @return hash code\n+     */\n+    public int hashCode() {\n+        int result = 31 + MathUtils.hash(getMax());\n+        result = result * 31 + MathUtils.hash(getMean());\n+        result = result * 31 + MathUtils.hash(getMin());\n+        result = result * 31 + MathUtils.hash(getN());\n+        result = result * 31 + MathUtils.hash(getSum());\n+        result = result * 31 + MathUtils.hash(getVariance());\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatistic.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+/**\n+ * Extends the definition of {@link UnivariateStatistic} with \n+ * {@link #increment} and {@link #incrementAll(double[])} methods for adding\n+ * values and updating internal state.  \n+ * <p>\n+ * This interface is designed to be used for calculating statistics that can be computed in \n+ * one pass through the data without storing the full array of sample values.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public interface StorelessUnivariateStatistic extends UnivariateStatistic {\n+\n+    /**\n+     * Updates the internal state of the statistic to reflect the addition of the new value.\n+     * @param d  the new value.\n+     */\n+    void increment(double d);\n+    \n+    /**\n+     * Updates the internal state of the statistic to reflect addition of\n+     * all values in the values array.  Does not clear the statistic first --\n+     * i.e., the values are added <strong>incrementally</stong> to the dataset.\n+     * \n+     * @param values  array holding the new values to add\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    void incrementAll(double[] values);\n+    \n+    /**\n+     * Updates the internal state of the statistic to reflect addition of\n+     * the values in the designated portion of the values array.  Does not\n+     * clear the statistic first -- i.e., the values are added \n+     * <strong>incrementally</stong> to the dataset.\n+     * \n+     * @param values  array holding the new values to add\n+     * @param start  the array index of the first value to add\n+     * @param length  the number of elements to add\n+     * @throws IllegalArgumentException if the array is null or the index\n+     */\n+    void incrementAll(double[] values, int start, int length);\n+\n+    /**\n+     * Returns the current value of the Statistic.\n+     * @return value of the statistic, <code>Double.NaN</code> if it\n+     * has been cleared or just instantiated.\n+     */\n+    double getResult();\n+\n+    /**\n+     * Returns the number of values that have been added.\n+     * @return the number of values.\n+     */\n+    long getN();\n+\n+    /**\n+     * Clears the internal state of the Statistic\n+     */\n+    void clear();\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/SummaryStatistics.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.discovery.tools.DiscoverClass;\n+import org.apache.commons.math.util.MathUtils;\n+\n+/**\n+ * Abstract factory class for univariate statistical summaries.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public abstract class SummaryStatistics implements StatisticalSummary, Serializable {\n+\n+    /** Serialization UID */\n+    static final long serialVersionUID = -6400596334135654825L;\n+     \n+    /**\n+     * Create an instance of a <code>SummaryStatistics</code>\n+     * \n+     * @param cls the type of <code>SummaryStatistics</code> object to\n+     *        create. \n+     * @return a new factory. \n+     * @throws InstantiationException is thrown if the object can not be\n+     *            created.\n+     * @throws IllegalAccessException is thrown if the type's default\n+     *            constructor is not accessible.\n+     */\n+    public static SummaryStatistics newInstance(Class cls) throws \n+        InstantiationException, IllegalAccessException {\n+        return (SummaryStatistics)cls.newInstance();\n+    }\n+    \n+    /**\n+     * Create an instance of a <code>SummaryStatistics</code>\n+     * \n+     * @return a new SummaryStatistics instance. \n+     */\n+    public static SummaryStatistics newInstance() {\n+        SummaryStatistics instance = null;\n+        try {\n+            DiscoverClass dc = new DiscoverClass();\n+            instance = (SummaryStatistics) dc.newInstance(\n+                SummaryStatistics.class,\n+                \"org.apache.commons.math.stat.descriptive.SummaryStatisticsImpl\");\n+        } catch(Throwable t) {\n+            return new SummaryStatisticsImpl();\n+        }\n+        return instance;\n+    }\n+    \n+\n+    /**\n+     * Return a {@link StatisticalSummaryValues} instance reporting current\n+     * statistics.\n+     * \n+     * @return Current values of statistics \n+     */\n+    public StatisticalSummary getSummary() {\n+        return new StatisticalSummaryValues(getMean(), getVariance(), getN(),\n+                getMax(), getMin(), getSum());\n+    }\n+    \n+    /**\n+     * Adds the value to the data to be summarized\n+     * @param v the value to be added \n+     */\n+    public abstract void addValue(double v);\n+\n+    /** \n+     * Returns the <a href=\"http://www.xycoon.com/arithmetic_mean.htm\">\n+     * arithmetic mean </a> of the available values \n+     * @return The mean or Double.NaN if no values have been added.\n+     */\n+    public abstract double getMean();\n+\n+    /** \n+     * Returns the <a href=\"http://www.xycoon.com/geometric_mean.htm\">\n+     * geometric mean </a> of the available values\n+     * @return The geometricMean, Double.NaN if no values have been added, \n+     * or if the productof the available values is less than or equal to 0.\n+     */\n+    public abstract double getGeometricMean();\n+\n+    /** \n+     * Returns the variance of the available values.\n+     * @return The variance, Double.NaN if no values have been added \n+     * or 0.0 for a single value set.  \n+     */\n+    public abstract double getVariance();\n+\n+    /** \n+     * Returns the standard deviation of the available values.\n+     * @return The standard deviation, Double.NaN if no values have been added \n+     * or 0.0 for a single value set. \n+     */\n+    public abstract double getStandardDeviation();\n+    \n+    /** \n+     * Returns the maximum of the available values\n+     * @return The max or Double.NaN if no values have been added.\n+     */\n+    public abstract double getMax();\n+\n+    /** \n+    * Returns the minimum of the available values\n+    * @return The min or Double.NaN if no values have been added.\n+    */\n+    public abstract double getMin();\n+\n+    /** \n+     * Returns the number of available values\n+     * @return The number of available values\n+     */\n+    public abstract long getN();\n+\n+    /**\n+     * Returns the sum of the values that have been added to Univariate.\n+     * @return The sum or Double.NaN if no values have been added\n+     */\n+    public abstract double getSum();\n+\n+    /**\n+     * Returns the sum of the squares of the available values.\n+     * @return The sum of the squares or Double.NaN if no \n+     * values have been added.\n+     */\n+    public abstract double getSumsq();\n+\n+    /** \n+     * Resets all statistics\n+     */\n+    public abstract void clear();\n+    \n+    /**\n+     * Returns true iff <code>object</code> is a <code>SummaryStatistics</code>\n+     * instance and all statistics have the same values as this.\n+     * @param object the object to test equality against.\n+     * @return true if object equals this\n+     */\n+    public boolean equals(Object object) {\n+        if (object == this ) {\n+            return true;\n+        }\n+        if (object instanceof SummaryStatistics == false) {\n+            return false;\n+        }\n+        SummaryStatistics stat = (SummaryStatistics) object;\n+        return (MathUtils.equals(stat.getGeometricMean(), \n+                this.getGeometricMean()) &&\n+                MathUtils.equals(stat.getMax(), this.getMax()) && \n+                MathUtils.equals(stat.getMean(),this.getMean()) &&\n+                MathUtils.equals(stat.getMin(),this.getMin()) &&\n+                MathUtils.equals(stat.getN(), this.getN()) &&\n+                MathUtils.equals(stat.getSum(), this.getSum()) &&\n+                MathUtils.equals(stat.getSumsq(),this.getSumsq()) &&\n+                MathUtils.equals(stat.getVariance(),this.getVariance()));\n+    }\n+    \n+    /**\n+     * Returns hash code based on values of statistics\n+     * \n+     * @return hash code\n+     */\n+    public int hashCode() {\n+        int result = 31 + MathUtils.hash(getGeometricMean());\n+        result = result * 31 + MathUtils.hash(getGeometricMean());\n+        result = result * 31 + MathUtils.hash(getMax());\n+        result = result * 31 + MathUtils.hash(getMean());\n+        result = result * 31 + MathUtils.hash(getMin());\n+        result = result * 31 + MathUtils.hash(getN());\n+        result = result * 31 + MathUtils.hash(getSum());\n+        result = result * 31 + MathUtils.hash(getSumsq());\n+        result = result * 31 + MathUtils.hash(getVariance());\n+        return result;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/SummaryStatisticsImpl.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.io.Serializable;\n+import org.apache.commons.math.stat.descriptive.moment.SecondMoment;\n+import org.apache.commons.math.stat.descriptive.moment.GeometricMean;\n+import org.apache.commons.math.stat.descriptive.moment.Mean;\n+import org.apache.commons.math.stat.descriptive.moment.Variance;\n+import org.apache.commons.math.stat.descriptive.rank.Max;\n+import org.apache.commons.math.stat.descriptive.rank.Min;\n+import org.apache.commons.math.stat.descriptive.summary.Sum;\n+import org.apache.commons.math.stat.descriptive.summary.SumOfLogs;\n+import org.apache.commons.math.stat.descriptive.summary.SumOfSquares;\n+\n+/**\n+ * Provides a default {@link SummaryStatistics} implementation.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $  \n+ */\n+public class SummaryStatisticsImpl extends SummaryStatistics implements Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = 8787174276883311692L;\n+\n+    /** count of values that have been added */\n+    protected long n = 0;\n+    \n+    /** SecondMoment is used to compute the mean and variance */\n+    protected SecondMoment secondMoment = null;\n+    \n+    /** sum of values that have been added */\n+    protected Sum sum = null;\n+\n+    /** sum of the square of each value that has been added */\n+    protected SumOfSquares sumsq = null;\n+\n+    /** min of values that have been added */\n+    protected Min min = null;\n+\n+    /** max of values that have been added */\n+    protected Max max = null;\n+\n+    /** sumLog of values that have been added */\n+    protected SumOfLogs sumLog = null;\n+\n+    /** geoMean of values that have been added */\n+    protected GeometricMean geoMean = null;\n+\n+    /** mean of values that have been added */\n+    protected Mean mean = null;\n+\n+    /** variance of values that have been added */\n+    protected Variance variance = null;\n+\n+    /**\n+     * Construct a SummaryStatistics\n+     */\n+    public SummaryStatisticsImpl() {\n+        sum = new Sum();\n+        sumsq = new SumOfSquares();\n+        min = new Min();\n+        max = new Max();\n+        sumLog = new SumOfLogs();\n+        geoMean = new GeometricMean();\n+        secondMoment = new SecondMoment();\n+    }\n+\n+    /**\n+     * Add a value to the data\n+     * \n+     * @param value  the value to add\n+     */\n+    public void addValue(double value) {\n+        sum.increment(value);\n+        sumsq.increment(value);\n+        min.increment(value);\n+        max.increment(value);\n+        sumLog.increment(value);\n+        geoMean.increment(value);\n+        secondMoment.increment(value);\n+        n++;\n+    }\n+\n+    /** \n+     * Returns the number of available values\n+     * @return The number of available values\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+\n+    /**\n+     * Returns the sum of the values that have been added to Univariate.\n+     * @return The sum or Double.NaN if no values have been added\n+     */\n+    public double getSum() {\n+        return sum.getResult();\n+    }\n+\n+    /**\n+     * Returns the sum of the squares of the values that have been added.\n+     * <p>\n+     *  Double.NaN is returned if no values have been added.</p>\n+     * \n+     * @return The sum of squares\n+     */\n+    public double getSumsq() {\n+        return sumsq.getResult();\n+    }\n+\n+    /**\n+     * Returns the mean of the values that have been added.\n+     * <p>\n+     *  Double.NaN is returned if no values have been added.</p>\n+     * \n+     * @return the mean\n+     */\n+    public double getMean() {\n+      return new Mean(secondMoment).getResult();\n+    }\n+\n+    /**\n+     * Returns the standard deviation of the values that have been added.\n+     * <p>\n+     *  Double.NaN is returned if no values have been added.</p>\n+     * \n+     * @return the standard deviation\n+     */\n+    public double getStandardDeviation() {\n+        double stdDev = Double.NaN;\n+        if (getN() > 0) {\n+            if (getN() > 1) {\n+                stdDev = Math.sqrt(getVariance());\n+            } else {\n+                stdDev = 0.0;\n+            }\n+        }\n+        return (stdDev);\n+    }\n+\n+    /**\n+     * Returns the variance of the values that have been added.\n+     * <p>\n+     *  Double.NaN is returned if no values have been added.</p>\n+     *\n+     * @return the variance \n+     */\n+    public double getVariance() {\n+        return new Variance(secondMoment).getResult();\n+    }\n+\n+    /**\n+     * Returns the maximum of the values that have been added.\n+     * <p>\n+     *  Double.NaN is returned if no values have been added.</p>\n+     *\n+     * @return the maximum  \n+     */\n+    public double getMax() {\n+        return max.getResult();\n+    }\n+\n+    /**\n+     * Returns the minimum of the values that have been added.\n+     * <p>\n+     *  Double.NaN is returned if no values have been added.</p>\n+     *\n+     * @return the minimum  \n+     */\n+    public double getMin() {\n+        return min.getResult();\n+    }\n+\n+    /**\n+     * Returns the geometric mean of the values that have been added.\n+     * <p>\n+     *  Double.NaN is returned if no values have been added.</p>\n+     *\n+     * @return the geometric mean  \n+     */\n+    public double getGeometricMean() {\n+        return geoMean.getResult();\n+    }\n+    \n+    /**\n+     * Generates a text report displaying\n+     * summary statistics from values that\n+     * have been added.\n+     * @return String with line feeds displaying statistics\n+     */\n+    public String toString() {\n+        StringBuffer outBuffer = new StringBuffer();\n+        outBuffer.append(\"SummaryStatistics:\\n\");\n+        outBuffer.append(\"n: \" + getN() + \"\\n\");\n+        outBuffer.append(\"min: \" + getMin() + \"\\n\");\n+        outBuffer.append(\"max: \" + getMax() + \"\\n\");\n+        outBuffer.append(\"mean: \" + getMean() + \"\\n\");\n+        outBuffer.append(\"geometric mean: \" + getGeometricMean() + \"\\n\");\n+        outBuffer.append(\"variance: \" + getVariance() + \"\\n\");\n+        outBuffer.append(\"sum of squares: \" + getSumsq() + \"\\n\");\n+        outBuffer.append(\"standard deviation: \" + getStandardDeviation() + \"\\n\");\n+        return outBuffer.toString();\n+    }\n+\n+    /** \n+     * Resets all statistics and storage\n+     */\n+    public void clear() {\n+        this.n = 0;\n+        min.clear();\n+        max.clear();\n+        sum.clear();\n+        sumLog.clear();\n+        sumsq.clear();\n+        geoMean.clear();\n+        secondMoment.clear();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/UnivariateStatistic.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+/**\n+ * Base evaluation interface implemented by all statistics.\n+ * <p>\n+ * Includes \"stateless\" <code>evaluate</code> methods that take\n+ * <code>double[]</code> arrays as input and return the value of the statistic\n+ * applied to the input values.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public interface UnivariateStatistic {\n+\n+    /**\n+     * Returns the result of evaluating the statistic over the input array.\n+     * \n+     * @param values input array\n+     * @return the value of the statistic applied to the input array\n+     */\n+    double evaluate(double[] values);\n+\n+    /**\n+     * Returns the result of evaluating the statistic over the specified entries\n+     * in the input array.\n+     * \n+     * @param values the input array\n+     * @param begin the index of the first element to include\n+     * @param length the number of elements to include\n+     * @return the value of the statistic applied to the included array entries\n+     */\n+    double evaluate(double[] values, int begin, int length);\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/FirstMoment.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * Computes the first moment (arithmetic mean).  Uses the definitional formula:\n+ * <p>\n+ * mean = sum(x_i) / n\n+ * <p>\n+ * where <code>n</code> is the number of observations.\n+ * <p>\n+ * To limit numeric errors, the value of the statistic is computed using the\n+ * following recursive updating algorithm:\n+ * <p>\n+ * <ol>\n+ * <li>Initialize <code>m = </code> the first value</li>\n+ * <li>For each additional value, update using <br>\n+ *   <code>m = m + (new value - m) / (number of observations)</code></li>\n+ * </ol>\n+ * <p>\n+ *  Returns <code>Double.NaN</code> if the dataset is empty.\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public class FirstMoment extends AbstractStorelessUnivariateStatistic \n+    implements Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -803343206421984070L; \n+    \n+    /** Count of values that have been added */\n+    protected long n;\n+\n+    /** First moment of values that have been added */\n+    protected double m1;\n+    \n+    /** \n+     * Deviation of most recently added value from previous first moment.\n+     * Retained to prevent repeated computation in higher order moments.\n+     */\n+    protected double dev;\n+    \n+    /**\n+     * Deviation of most recently added value from previous first moment,\n+     * normalized by previous sample size.  Retained to prevent repeated\n+     * computation in higher order moments\n+     */\n+    protected double nDev;\n+\n+    /**\n+     * Create a FirstMoment instance\n+     */\n+    public FirstMoment() {\n+        n = 0;\n+        m1 = Double.NaN;\n+        dev = Double.NaN;\n+        nDev = Double.NaN;\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     */\n+    public void increment(final double d) {\n+        if (n == 0) {\n+            m1 = 0.0;\n+        }\n+        n++;\n+        double n0 = (double) n;\n+        dev = d - m1;\n+        nDev = dev / n0;\n+        m1 += nDev;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        m1 = Double.NaN;\n+        n = 0;\n+        dev = Double.NaN;\n+        nDev = Double.NaN;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     */\n+    public double getResult() {\n+        return m1;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/FourthMoment.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Computes a statistic related to the Fourth Central Moment.  Specifically,\n+ * what is computed is the sum of \n+ * <p>\n+ * (x_i - xbar) ^ 4,\n+ * <p>\n+ * where the x_i are the \n+ * sample observations and xbar is the sample mean.\n+ * <p>\n+ * The following recursive updating formula is used:\n+ * <p>\n+ * Let <ul>\n+ * <li> dev = (current obs - previous mean) </li>\n+ * <li> m2 = previous value of {@link SecondMoment} </li>\n+ * <li> m2 = previous value of {@link ThirdMoment} </li>\n+ * <li> n = number of observations (including current obs) </li>\n+ * </ul>\n+ * Then\n+ * <p>\n+ * new value = old value - 4 * (dev/n) * m3 + 6 * (dev/n)^2 * m2 + <br>\n+ * [n^2 - 3 * (n-1)] * dev^4 * (n-1) / n^3\n+ * <p>\n+ * Returns <code>Double.NaN</code> if no data values have been added and\n+ * returns <code>0</code> if there is just one value in the data set.\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public class FourthMoment extends ThirdMoment implements Serializable{\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = 4763990447117157611L;\n+        \n+    /** fourth moment of values that have been added */\n+    protected double m4;\n+\n+    /**\n+     * Create a FourthMoment instance\n+     */\n+    public FourthMoment() {\n+        super();\n+        m4 = Double.NaN;\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     */\n+    public void increment(final double d) {\n+        if (n < 1) {\n+            m4 = 0.0;\n+            m3 = 0.0;\n+            m2 = 0.0;\n+            m1 = 0.0;\n+        }\n+\n+        double prevM3 = m3;\n+        double prevM2 = m2;\n+        \n+        super.increment(d);\n+        \n+        double n0 = (double) n;\n+\n+        m4 = m4 - 4.0 * nDev * prevM3 + 6.0 * nDevSq * prevM2 +\n+            ((n0 * n0) - 3 * (n0 -1)) * (nDevSq * nDevSq * (n0 - 1) * n0);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     */\n+    public double getResult() {\n+        return m4;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        super.clear();\n+        m4 = Double.NaN;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/GeometricMean.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.summary.SumOfLogs;\n+\n+/**\n+ * Returns the <a href=\"http://www.xycoon.com/geometric_mean.htm\">\n+ * geometric mean </a> of the available values.\n+ * <p>\n+ * Uses a {@link SumOfLogs} instance to compute sum of logs and returns\n+ * <code> exp( 1/n  (sum of logs) ).</code>  Therefore,\n+ * <ul>\n+ * <li>If any of values are < 0, the result is <code>NaN.</code></li>\n+ * <li>If all values are non-negative and less than \n+ * <code>Double.POSITIVE_INFINITY</code>,  but at least one value is 0, the \n+ * result is <code>0.</code></li>\n+ * <li>If both <code>Double.POSITIVE_INFINITY</code> and \n+ * <code>Double.NEGATIVE_INFINITY</code> are among the values, the result is\n+ * <code>NaN.</code></li>\n+ * </ul>\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.\n+ * \n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public class GeometricMean extends AbstractStorelessUnivariateStatistic {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -8178734905303459453L;  \n+    \n+    /** Wrapped SumOfLogs instance */\n+    private SumOfLogs sumOfLogs;\n+\n+    /**\n+     * Create a GeometricMean instance\n+     */\n+    public GeometricMean() {\n+        sumOfLogs = new SumOfLogs();\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     */\n+    public void increment(final double d) {\n+        sumOfLogs.increment(d);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     */\n+    public double getResult() {\n+        if (sumOfLogs.getN() > 0) {\n+            return Math.exp(sumOfLogs.getResult() / (double) sumOfLogs.getN());\n+        } else {\n+            return Double.NaN;\n+        }\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        sumOfLogs.clear();\n+    }\n+\n+    /**\n+     * Returns the geometric mean of the entries in the specified portion\n+     * of the input array.\n+     * <p>\n+     * See {@link GeometricMean} for details on the computing algorithm.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.\n+     * \n+     * @param values input array containing the values\n+     * @param begin first array element to include\n+     * @param length the number of elements to include\n+     * @return the geometric mean or Double.NaN if length = 0 or\n+     * any of the values are &lt;= 0.\n+     * @throws IllegalArgumentException if the input array is null or the array\n+     * index parameters are not valid\n+     */\n+    public double evaluate(\n+        final double[] values, final int begin, final int length) {\n+        return Math.exp(\n+            sumOfLogs.evaluate(values, begin, length) / (double) length);\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     */\n+    public long getN() {\n+        return sumOfLogs.getN();\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Kurtosis.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * Computes the Kurtosis of the available values.\n+ * <p>\n+ * We use the following (unbiased) formula to define kurtosis:\n+ *  <p>\n+ *  kurtosis = { [n(n+1) / (n -1)(n - 2)(n-3)] sum[(x_i - mean)^4] / std^4 } - [3(n-1)^2 / (n-2)(n-3)]\n+ *  <p>\n+ *  where n is the number of values, mean is the {@link Mean} and std is the\n+ * {@link StandardDeviation}\n+ * <p>\n+ *  Note that this statistic is undefined for n < 4.  <code>Double.Nan</code>\n+ *  is returned when there is not sufficient data to compute the statistic.\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public class Kurtosis extends AbstractStorelessUnivariateStatistic  {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = 2784465764798260919L;  \n+      \n+    /**Fourth Moment on which this statistic is based */\n+    protected FourthMoment moment;\n+\n+    /** \n+     * Determines whether or not this statistic can be incremented or cleared.\n+     * <p>\n+     * Statistics based on (constructed from) external moments cannot\n+     * be incremented or cleared.\n+    */\n+    protected boolean incMoment;\n+\n+    /**\n+     * Construct a Kurtosis\n+     */\n+    public Kurtosis() {\n+        incMoment = true;\n+        moment = new FourthMoment();\n+    }\n+\n+    /**\n+     * Construct a Kurtosis from an external moment\n+     * \n+     * @param m4 external Moment\n+     */\n+    public Kurtosis(final FourthMoment m4) {\n+        incMoment = false;\n+        this.moment = m4;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     */\n+    public void increment(final double d) {\n+        if (incMoment) {\n+            moment.increment(d);\n+        }  else  {\n+            throw new IllegalStateException\n+            (\"Statistics constructed from external moments cannot be incremented\");\n+        }\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     */\n+    public double getResult() {\n+        double kurtosis = Double.NaN;\n+        if (moment.getN() > 3) {\n+            double variance = moment.m2 / (double) (moment.n - 1);\n+                if (moment.n <= 3 || variance < 10E-20) {\n+                    kurtosis = 0.0;\n+                } else {\n+                    double n = (double) moment.n;\n+                    kurtosis =\n+                        (n * (n + 1) * moment.m4 -\n+                                3 * moment.m2 * moment.m2 * (n - 1)) /\n+                                ((n - 1) * (n -2) * (n -3) * variance * variance);\n+                }\n+        }\n+        return kurtosis;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        if (incMoment) {\n+            moment.clear();\n+        } else  {\n+            throw new IllegalStateException\n+                (\"Statistics constructed from external moments cannot be cleared\");\n+        }\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     */\n+    public long getN() {\n+        return moment.getN();\n+    }\n+    \n+    /* UnvariateStatistic Approach  */\n+\n+    /**\n+     * Returns the kurtosis of the entries in the specified portion of the\n+     * input array.  \n+     * <p>\n+     * See {@link Kurtosis} for details on the computing algorithm.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the kurtosis of the values or Double.NaN if length is less than\n+     * 4\n+     * @throws IllegalArgumentException if the input array is null or the array\n+     * index parameters are not valid\n+     */\n+    public double evaluate(final double[] values,final int begin, final int length) {\n+        // Initialize the kurtosis  \n+        double kurt = Double.NaN;   \n+        \n+        if (test(values, begin, length) && length > 3) {       \n+            \n+            // Compute the mean and standard deviation\n+            Variance variance = new Variance();\n+            variance.incrementAll(values, begin, length);\n+            double mean = variance.moment.m1;\n+            double stdDev = Math.sqrt(variance.getResult());\n+            \n+            // Sum the ^4 of the distance from the mean divided by the\n+            // standard deviation\n+            double accum3 = 0.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                accum3 += Math.pow((values[i] - mean), 4.0);\n+            }\n+            accum3 /= Math.pow(stdDev, 4.0d);\n+            \n+            // Get N\n+            double n0 = length;\n+            \n+            double coefficientOne =\n+                (n0 * (n0 + 1)) / ((n0 - 1) * (n0 - 2) * (n0 - 3));\n+            double termTwo =\n+                ((3 * Math.pow(n0 - 1, 2.0)) / ((n0 - 2) * (n0 - 3)));\n+            \n+            // Calculate kurtosis\n+            kurt = (coefficientOne * accum3) - termTwo;\n+        }       \n+        return kurt;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Mean.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.summary.Sum;\n+\n+/**\n+ * Returns the arithmetic mean of the available values. Uses the definitional \n+ * formula:\n+ * <p>\n+ * mean = sum(x_i) / n\n+ * <p>\n+ * where <code>n</code> is the number of observations.\n+ * <p>\n+ * The value of the statistic is computed using the following recursive\n+ * updating algorithm:\n+ * <p>\n+ * <ol>\n+ * <li>Initialize <code>m = </code> the first value</li>\n+ * <li>For each additional value, update using <br>\n+ *   <code>m = m + (new value - m) / (number of observations)</code></li>\n+ * </ol>\n+ * <p>\n+ *  Returns <code>Double.NaN</code> if the dataset is empty.\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public class Mean extends AbstractStorelessUnivariateStatistic \n+    implements Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -1296043746617791564L;    \n+    \n+    /** First moment on which this statistic is based. */\n+    protected FirstMoment moment;\n+\n+    /** \n+     * Determines whether or not this statistic can be incremented or cleared.\n+     * <p>\n+     * Statistics based on (constructed from) external moments cannot\n+     * be incremented or cleared.\n+     */\n+    protected boolean incMoment;\n+\n+    /** Constructs a Mean. */\n+    public Mean() {\n+        incMoment = true;\n+        moment = new FirstMoment();\n+    }\n+\n+    /**\n+     * Constructs a Mean with an External Moment.\n+     * \n+     * @param m1 the moment\n+     */\n+    public Mean(final FirstMoment m1) {\n+        this.moment = m1;\n+        incMoment = false;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     */\n+    public void increment(final double d) {\n+        if (incMoment) {\n+            moment.increment(d);\n+        }\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        if (incMoment) {\n+            moment.clear();\n+        }\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     */\n+    public double getResult() {\n+        return moment.m1;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     */\n+    public long getN() {\n+        return moment.getN();\n+    }\n+\n+    /**\n+     * Returns the arithmetic mean of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.\n+     * <p>\n+     * See {@link Mean} for details on the computing algorithm.\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the mean of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    public double evaluate(final double[] values,final int begin, final int length) {\n+        if (test(values, begin, length)) {\n+            Sum sum = new Sum();\n+            return sum.evaluate(values, begin, length) / ((double) length);\n+        }\n+        return Double.NaN;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/SecondMoment.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Computes a statistic related to the Second Central Moment.  Specifically,\n+ * what is computed is the sum of squared deviations from the sample mean.\n+ * <p>\n+ * The following recursive updating formula is used:\n+ * <p>\n+ * Let <ul>\n+ * <li> dev = (current obs - previous mean) </li>\n+ * <li> n = number of observations (including current obs) </li>\n+ * </ul>\n+ * Then\n+ * <p>\n+ * new value = old value + dev^2 * (n -1) / n.\n+ * <p>\n+ * Returns <code>Double.NaN</code> if no data values have been added and\n+ * returns <code>0</code> if there is just one value in the data set.\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public class SecondMoment extends FirstMoment implements Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = 3942403127395076445L;  \n+      \n+    /** second moment of values that have been added */\n+    protected double m2;\n+\n+    /**\n+     * Create a SecondMoment instance\n+     */\n+    public SecondMoment() {\n+        super();\n+        m2 = Double.NaN;\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     */\n+    public void increment(final double d) {\n+        if (n < 1) {\n+            m1 = m2 = 0.0;\n+        }\n+        super.increment(d);\n+        m2 += ((double) n - 1) * dev * nDev;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        super.clear();\n+        m2 = Double.NaN;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     */\n+    public double getResult() {\n+        return m2;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Skewness.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * Computes the skewness of the available values.\n+ * <p>\n+ * We use the following (unbiased) formula to define skewness:\n+ * <p>\n+ * skewness = [n / (n -1) (n - 2)] sum[(x_i - mean)^3] / std^3\n+ * <p>\n+ * where n is the number of values, mean is the {@link Mean} and std is the \n+ * {@link StandardDeviation}\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public class Skewness extends AbstractStorelessUnivariateStatistic implements Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = 7101857578996691352L;    \n+    \n+    /** Third moment on which this statistic is based */\n+    protected ThirdMoment moment = null;\n+\n+     /** \n+     * Determines whether or not this statistic can be incremented or cleared.\n+     * <p>\n+     * Statistics based on (constructed from) external moments cannot\n+     * be incremented or cleared.\n+    */\n+    protected boolean incMoment;\n+\n+    /**\n+     * Constructs a Skewness\n+     */\n+    public Skewness() {\n+        incMoment = true;\n+        moment = new ThirdMoment();\n+    }\n+\n+    /**\n+     * Constructs a Skewness with an external moment\n+     * @param m3 external moment\n+     */\n+    public Skewness(final ThirdMoment m3) {\n+        incMoment = false;\n+        this.moment = m3;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     */\n+    public void increment(final double d) {\n+        if (incMoment) {\n+            moment.increment(d);\n+        }\n+    }\n+\n+    /**\n+     * Returns the value of the statistic based on the values that have been added.\n+     * <p>\n+     * See {@link Skewness} for the definition used in the computation.\n+     * \n+     * @return the skewness of the available values.\n+     */\n+    public double getResult() {\n+        \n+        if (moment.n < 3) {\n+            return Double.NaN;\n+        }\n+        double variance = moment.m2 / (double) (moment.n - 1);\n+        double skewness = Double.NaN;\n+        if (variance < 10E-20) {\n+            skewness = 0.0;\n+        } else {\n+            double n0 = (double) moment.getN();\n+            skewness = (n0 * moment.m3) /\n+            ((n0 - 1) * (n0 -2) * Math.sqrt(variance) * variance);\n+        }\n+        return skewness;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     */\n+    public long getN() {\n+        return moment.getN();\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        if (incMoment) {\n+            moment.clear();\n+        }\n+    }\n+\n+    /**\n+     * Returns the Skewness of the entries in the specifed portion of the\n+     * input array.\n+     * <p>\n+     * See {@link Skewness} for the definition used in the computation.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.\n+     * \n+     * @param values the input array\n+     * @param begin the index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the skewness of the values or Double.NaN if length is less than\n+     * 3\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    public double evaluate(final double[] values,final int begin, \n+            final int length) {\n+\n+        // Initialize the skewness\n+        double skew = Double.NaN;\n+\n+        if (test(values, begin, length) && length > 2 ){\n+            Mean mean = new Mean();\n+            // Get the mean and the standard deviation\n+            double m = mean.evaluate(values, begin, length);\n+            \n+            // Calc the std, this is implemented here instead\n+            // of using the standardDeviation method eliminate\n+            // a duplicate pass to get the mean\n+            double accum = 0.0;\n+            double accum2 = 0.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                accum += Math.pow((values[i] - m), 2.0);\n+                accum2 += (values[i] - m);\n+            }\n+            double stdDev = Math.sqrt((accum - (Math.pow(accum2, 2) / ((double) length))) /\n+                    (double) (length - 1));\n+            \n+            double accum3 = 0.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                accum3 += Math.pow(values[i] - m, 3.0d);\n+            }\n+            accum3 /= Math.pow(stdDev, 3.0d);\n+            \n+            // Get N\n+            double n0 = length;\n+            \n+            // Calculate skewness\n+            skew = (n0 / ((n0 - 1) * (n0 - 2))) * accum3;\n+        }\n+        return skew;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/StandardDeviation.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * Computes the sample standard deviation.  The standard deviation\n+ * is the positive square root of the variance.  See {@link Variance} for\n+ * more information.  This implementation wraps a {@link Variance}\n+ * instance.\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public class StandardDeviation extends AbstractStorelessUnivariateStatistic\n+    implements Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = 5728716329662425188L;  \n+    \n+    /** Wrapped Variance instance */\n+    private Variance variance = null;\n+\n+    /**\n+     * Constructs a StandardDeviation\n+     */\n+    public StandardDeviation() {\n+        variance = new Variance();\n+    }\n+\n+    /**\n+     * Constructs a StandardDeviation from an external second moment.\n+     * \n+     * @param m2 the external moment\n+     */\n+    public StandardDeviation(final SecondMoment m2) {\n+        variance = new Variance(m2);\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     */\n+    public void increment(final double d) {\n+        variance.increment(d);\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     */\n+    public long getN() {\n+        return variance.getN();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     */\n+    public double getResult() {\n+        return Math.sqrt(variance.getResult());\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        variance.clear();\n+    }\n+\n+    /**\n+     * Returns the Standard Deviation of the entries in the input array, or \n+     * <code>Double.NaN</code> if the array is empty.\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.\n+     * <p>\n+     * Does not change the internal state of the statistic.\n+     * \n+     * @param values the input array\n+     * @return the standard deviation of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null\n+     */  \n+    public double evaluate(final double[] values)  {\n+        return Math.sqrt(variance.evaluate(values));\n+    }\n+    \n+    \n+    /**\n+     * Returns the Standard Deviation of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.\n+     * <p>\n+     * Does not change the internal state of the statistic.\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the standard deviation of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final int begin, final int length)  {\n+       return Math.sqrt(variance.evaluate(values, begin, length));\n+    }\n+    \n+    /**\n+     * Returns the Standard Deviation of the entries in the specified portion of\n+     * the input array, using the precomputed mean value.  Returns\n+     * <code>Double.NaN</code> if the designated subarray is empty.\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.\n+     * <p>\n+     * The formula used assumes that the supplied mean value is the arithmetic\n+     * mean of the sample data, not a known population parameter.  This method\n+     * is supplied only to save computation when the mean has already been\n+     * computed.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.\n+     * <p>\n+     * Does not change the internal state of the statistic.\n+     * \n+     * @param values the input array\n+     * @param mean the precomputed mean value\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the standard deviation of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final double mean,\n+            final int begin, final int length)  {\n+        return Math.sqrt(variance.evaluate(values, mean, begin, length));\n+    }\n+    \n+    /**\n+     * Returns the Standard Deviation of the entries in the input array, using\n+     * the precomputed mean value.  Returns\n+     * <code>Double.NaN</code> if the designated subarray is empty.\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.\n+     * <p>\n+     * The formula used assumes that the supplied mean value is the arithmetic\n+     * mean of the sample data, not a known population parameter.  This method\n+     * is supplied only to save computation when the mean has already been\n+     * computed.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.\n+     * <p>\n+     * Does not change the internal state of the statistic.\n+     * \n+     * @param values the input array\n+     * @param mean the precomputed mean value\n+     * @return the standard deviation of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public double evaluate(final double[] values, final double mean)  {\n+        return Math.sqrt(variance.evaluate(values, mean));\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/ThirdMoment.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Computes a statistic related to the Third Central Moment.  Specifically,\n+ * what is computed is the sum of cubed deviations from the sample mean.\n+ * <p>\n+ * The following recursive updating formula is used:\n+ * <p>\n+ * Let <ul>\n+ * <li> dev = (current obs - previous mean) </li>\n+ * <li> m2 = previous value of {@link SecondMoment} </li>\n+ * <li> n = number of observations (including current obs) </li>\n+ * </ul>\n+ * Then\n+ * <p>\n+ * new value = old value - 3 * (dev/n) * m2 + (n-1) * (n -2) * (dev^3/n^2)\n+ * <p>\n+ * Returns <code>Double.NaN</code> if no data values have been added and\n+ * returns <code>0</code> if there is just one value in the data set.\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public class ThirdMoment extends SecondMoment implements Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -7818711964045118679L;  \n+      \n+    /** third moment of values that have been added */\n+    protected double m3;\n+\n+     /**\n+     * Square of deviation of most recently added value from previous first \n+     * moment, normalized by previous sample size.  Retained to prevent \n+     * repeated computation in higher order moments.  nDevSq = nDev * nDev.\n+     */\n+    protected double nDevSq;\n+\n+    /**\n+     * Create a FourthMoment instance\n+     */\n+    public ThirdMoment() {\n+        super();\n+        m3 = Double.NaN;\n+        nDevSq = Double.NaN;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     */\n+    public void increment(final double d) {\n+        if (n < 1) {\n+            m3 = m2 = m1 = 0.0;\n+        }  \n+       \n+        double prevM2 = m2;\n+        super.increment(d);\n+        nDevSq = nDev * nDev;\n+        double n0 = (double) n;\n+        m3 = m3 - 3.0 * nDev * prevM2 + (n0 - 1) * (n0 - 2) * nDevSq * dev;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     */\n+    public double getResult() {\n+        return m3;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        super.clear();\n+        m3 = Double.NaN;\n+        nDevSq = Double.NaN;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * Computes the (unbiased) sample variance.  Uses the definitional formula: \n+ * <p>\n+ * variance = sum((x_i - mean)^2) / (n - 1)\n+ * <p>\n+ * where mean is the {@link Mean} and <code>n</code> is the number\n+ * of sample observations.  \n+ * <p>\n+ * The definitional formula does not have good numerical properties, so\n+ * this implementation uses updating formulas based on West's algorithm\n+ * as described in <a href=\"http://doi.acm.org/10.1145/359146.359152\">\n+ * Chan, T. F. andJ. G. Lewis 1979, <i>Communications of the ACM</i>,\n+ * vol. 22 no. 9, pp. 526-531.</a>.\n+* <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public class Variance extends AbstractStorelessUnivariateStatistic implements Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -9111962718267217978L;  \n+      \n+    /** SecondMoment is used in incremental calculation of Variance*/\n+    protected SecondMoment moment = null;\n+\n+    /**\n+     * Boolean test to determine if this Variance should also increment\n+     * the second moment, this evaluates to false when this Variance is\n+     * constructed with an external SecondMoment as a parameter.\n+     */\n+    protected boolean incMoment = true;\n+\n+    /**\n+     * Constructs a Variance.\n+     */\n+    public Variance() {\n+        moment = new SecondMoment();\n+    }\n+\n+    /**\n+     * Constructs a Variance based on an external second moment.\n+     * @param m2 the SecondMoment (Thrid or Fourth moments work\n+     * here as well.)\n+     */\n+    public Variance(final SecondMoment m2) {\n+        incMoment = false;\n+        this.moment = m2;\n+    }\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     */\n+    public void increment(final double d) {\n+        if (incMoment) {\n+            moment.increment(d);\n+        }\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     */\n+    public double getResult() {\n+            if (moment.n == 0) {\n+                return Double.NaN;\n+            } else if (moment.n == 1) {\n+                return 0d;\n+            } else {\n+                return moment.m2 / ((double) moment.n - 1d);\n+            }\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     */\n+    public long getN() {\n+        return moment.getN();\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        if (incMoment) {\n+            moment.clear();\n+        }\n+    }\n+    \n+    /**\n+     * Returns the variance of the entries in the input array, or \n+     * <code>Double.NaN</code> if the array is empty.\n+     * <p>\n+     * See {@link Variance} for details on the computing algorithm.\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.\n+     * <p>\n+     * Does not change the internal state of the statistic.\n+     * \n+     * @param values the input array\n+     * @return the variance of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public double evaluate(final double[] values) {\n+        if (values == null) {\n+            throw new IllegalArgumentException(\"input values array is null\");\n+        }\n+        return evaluate(values, 0, values.length);\n+    }\n+\n+    /**\n+     * Returns the variance of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * See {@link Variance} for details on the computing algorithm.\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.\n+     * <p>\n+     * Does not change the internal state of the statistic.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the variance of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final int begin, final int length) {\n+\n+        double var = Double.NaN;\n+\n+        if (test(values, begin, length)) {\n+            clear();\n+            if (length == 1) {\n+                var = 0.0;\n+            } else if (length > 1) {\n+                Mean mean = new Mean();\n+                double m = mean.evaluate(values, begin, length);\n+                var = evaluate(values, m, begin, length);\n+            }\n+        }\n+        return var;\n+    }\n+    \n+    /**\n+     * Returns the variance of the entries in the specified portion of\n+     * the input array, using the precomputed mean value.  Returns \n+     * <code>Double.NaN</code> if the designated subarray is empty.\n+     * <p>\n+     * See {@link Variance} for details on the computing algorithm.\n+     * <p>\n+     * The formula used assumes that the supplied mean value is the arithmetic\n+     * mean of the sample data, not a known population parameter.  This method\n+     * is supplied only to save computation when the mean has already been\n+     * computed.\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.\n+     * <p>\n+     * Does not change the internal state of the statistic.\n+     * \n+     * @param values the input array\n+     * @param mean the precomputed mean value\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the variance of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final double mean, \n+            final int begin, final int length) {\n+        \n+        double var = Double.NaN;\n+\n+        if (test(values, begin, length)) {\n+            if (length == 1) {\n+                var = 0.0;\n+            } else if (length > 1) {\n+                double accum = 0.0;\n+                double accum2 = 0.0;\n+                for (int i = begin; i < begin + length; i++) {\n+                    accum += Math.pow((values[i] - mean), 2.0);\n+                    accum2 += (values[i] - mean);\n+                }\n+                var = (accum - (Math.pow(accum2, 2) / ((double) length))) /\n+                (double) (length - 1);\n+            }\n+        }\n+        return var;\n+    }\n+    \n+    /**\n+     * Returns the variance of the entries in the input array, using the\n+     * precomputed mean value.  Returns <code>Double.NaN</code> if the array\n+     * is empty.\n+     * <p>\n+     * See {@link Variance} for details on the computing algorithm.\n+     * <p>\n+     * The formula used assumes that the supplied mean value is the arithmetic\n+     * mean of the sample data, not a known population parameter.  This method\n+     * is supplied only to save computation when the mean has already been\n+     * computed.\n+     * <p>\n+     * Returns 0 for a single-value (i.e. length = 1) sample.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.\n+     * <p>\n+     * Does not change the internal state of the statistic.\n+     * \n+     * @param values the input array\n+     * @param mean the precomputed mean value\n+     * @return the variance of the values or Double.NaN if the array is empty\n+     * @throws IllegalArgumentException if the array is null\n+     */\n+    public double evaluate(final double[] values, final double mean) {\n+        return evaluate(values, mean, 0, values.length);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Max.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.rank;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * Returns the maximum of the available values.\n+ * <p>\n+ * <ul>\n+ * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+ * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n+ * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>, \n+ * the result is <code>Double.POSITIVE_INFINITY.</code></li>\n+ * </ul>\n+* <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public class Max extends AbstractStorelessUnivariateStatistic {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -5593383832225844641L;    \n+    \n+    /** Number of values that have been added */\n+    private long n;\n+        \n+    /** Current value of the statistic */\n+    private double value;\n+\n+    /**\n+     * Create a Max instance\n+     */\n+    public Max() {\n+        n = 0;\n+        value = Double.NaN;\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     */\n+    public void increment(final double d) {\n+        if (d > value || Double.isNaN(value)) {\n+            value = d;\n+        }\n+        n++;\n+    }\n+\n+    /**\n+         * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+         */\n+    public void clear() {\n+        value = Double.NaN;\n+        n = 0;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     */\n+    public double getResult() {\n+        return value;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+    \n+    /**\n+     * Returns the maximum of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null or\n+     * the array index parameters are not valid.\n+     * <p>\n+     * <ul>\n+     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+     * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n+     * <li>If any of the values equals <code>Double.POSITIVE_INFINITY</code>, \n+     * the result is <code>Double.POSITIVE_INFINITY.</code></li>\n+     * </ul>\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the maximum of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final int begin, final int length) {\n+        double max = Double.NaN;\n+        if (test(values, begin, length)) {\n+            max = values[begin];\n+            for (int i = begin; i < begin + length; i++) {\n+                max = (max > values[i]) ? max : values[i];\n+            }\n+        }\n+        return max;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Median.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.rank;\n+\n+import java.io.Serializable;\n+\n+\n+/**\n+ * Returns the median of the available values.  This is the same as the 50th percentile.\n+ * See {@link Percentile} for a description of the algorithm used.\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public class Median extends Percentile implements Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -3961477041290915687L;    \n+\n+    /**\n+     * Default constructor.\n+     */\n+    public Median() {\n+        super(50.0);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Min.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.rank;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * Returns the minimum of the available values.\n+ * <p>\n+ * <ul>\n+ * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+ * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n+ * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>, \n+ * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n+ * </ul> \n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public class Min extends AbstractStorelessUnivariateStatistic implements Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -2941995784909003131L;  \n+      \n+    /**Number of values that have been added */\n+    private long n;\n+    \n+    /**Current value of the statistic */\n+    private double value;\n+\n+    /**\n+     * Create a Min instance\n+     */\n+    public Min() {\n+        n = 0;\n+        value = Double.NaN;\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     */\n+    public void increment(final double d) {\n+        if (d < value || Double.isNaN(value)) {\n+            value = d;\n+        }\n+        n++;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        value = Double.NaN;\n+        n = 0;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     */\n+    public double getResult() {\n+        return value;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+    \n+    /**\n+     * Returns the minimum of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null or\n+     * the array index parameters are not valid.\n+     * <p>\n+     * <ul>\n+     * <li>The result is <code>NaN</code> iff all values are <code>NaN</code> \n+     * (i.e. <code>NaN</code> values have no impact on the value of the statistic).</li>\n+     * <li>If any of the values equals <code>Double.NEGATIVE_INFINITY</code>, \n+     * the result is <code>Double.NEGATIVE_INFINITY.</code></li>\n+     * </ul> \n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the minimum of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    public double evaluate(final double[] values,final int begin, final int length) {\n+        double min = Double.NaN;\n+        if (test(values, begin, length)) {\n+            min = values[begin];\n+            for (int i = begin; i < begin + length; i++) {\n+                min = (min < values[i]) ? min : values[i];\n+            }\n+        }\n+        return min;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/rank/Percentile.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.rank;\n+\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic;\n+\n+/**\n+ * Provides percentile computation.\n+ * <p>\n+ * There are several commonly used methods for estimating percentiles (a.k.a. \n+ * quantiles) based on sample data.  For large samples, the different methods \n+ * agree closely, but when sample sizes are small, different methods will give\n+ * significantly different results.  The algorithm implemented here works as follows:\n+ * <ol>\n+ * <li>Let <code>n</code> be the length of the (sorted) array and \n+ * <code>0 < p <= 100</code> be the desired percentile.</li>\n+ * <li>If <code> n = 1 </code> return the unique array element (regardless of \n+ * the value of <code>p</code>); otherwise </li>\n+ * <li>Compute the estimated percentile position  \n+ * <code> pos = p * (n + 1) / 100</code> and the difference, <code>d</code>\n+ * between <code>pos</code> and <code>floor(pos)</code> (i.e. the fractional\n+ * part of <code>pos</code>).  If <code>pos >= n</code> return the largest\n+ * element in the array; otherwise</li>\n+ * <li>Let <code>lower</code> be the element in position \n+ * <code>floor(pos)</code> in the array and let <code>upper</code> be the\n+ * next element in the array.  Return <code>lower + d * (upper - lower)</code>\n+ * </li>\n+ * </ol>\n+ * <p>\n+ * To compute percentiles, the data must be (totally) ordered.  Input arrays\n+ * are copied and then sorted using  {@link java.util.Arrays#sort(double[])}.\n+ * The ordering used by <code>Arrays.sort(double[])</code> is the one determined\n+ * by {@link java.lang.Double#compareTo(Double)}.  This ordering makes \n+ * <code>Double.NaN</code> larger than any other value (including \n+ * <code>Double.POSITIVE_INFINITY</code>).  Therefore, for example, the median\n+ * (50th percentile) of  \n+ * <code>{0, 1, 2, 3, 4, Double.NaN}</code> evaluates to <code>2.5.</code>  \n+ * <p>\n+ * Since percentile estimation usually involves interpolation between array \n+ * elements, arrays containing  <code>NaN</code> or infinite values will often\n+ * result in <code>NaN<code> or infinite values returned.\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:17 $\n+ */\n+public class Percentile extends AbstractUnivariateStatistic implements Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -8091216485095130416L; \n+       \n+    /** Determines what percentile is computed when evaluate() is activated \n+     * with no quantile argument */\n+    private double quantile = 0.0;\n+\n+    /**\n+     * Constructs a Percentile with a default quantile\n+     * value of 50.0.\n+     */\n+    public Percentile() {\n+        this(50.0);\n+    }\n+\n+    /**\n+     * Constructs a Percentile with the specific quantile value.\n+     * @param p the quantile\n+     * @throws IllegalArgumentException  if p is not greater than 0 and less\n+     * than or equal to 100\n+     */\n+    public Percentile(final double p) {\n+        setQuantile(p);\n+    }\n+\n+    /**\n+     * Returns an estimate of the <code>p</code>th percentile of the values\n+     * in the <code>values</code> array.\n+     * <p>\n+     * Calls to this method do not modify the internal <code>quantile</code>\n+     * state of this statistic.\n+     * <p>\n+     * <ul>\n+     * <li>Returns <code>Double.NaN</code> if <code>values</code> has length \n+     * <code>0</code></li>\n+     * <li>Returns (for any value of <code>p</code>) <code>values[0]</code>\n+     *  if <code>values</code> has length <code>1</code></li>\n+     * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n+     * is null or p is not a valid quantile value (p must be greater than 0\n+     * and less than or equal to 100) </li>\n+     * </ul>\n+     * <p>\n+     * See {@link Percentile} for a description of the percentile estimation\n+     * algorithm used.\n+     * \n+     * @param values input array of values\n+     * @param p the percentile value to compute\n+     * @return the percentile value or Double.NaN if the array is empty\n+     * @throws IllegalArgumentException if <code>values</code> is null \n+     *     or p is invalid\n+     */\n+    public double evaluate(final double[] values, final double p) {\n+        test(values, 0, 0);\n+        return evaluate(values, 0, values.length, p);\n+    }\n+\n+    /**\n+     * Returns an estimate of the <code>quantile</code>th percentile of the\n+     * designated values in the <code>values</code> array.  The quantile\n+     * estimated is determined by the <code>quantile</code> property.\n+     * <p>\n+     * <ul>\n+     * <li>Returns <code>Double.NaN</code> if <code>length = 0</code></li>\n+     * <li>Returns (for any value of <code>quantile</code>) \n+     * <code>values[begin]</code> if <code>length = 1 </code></li>\n+     * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n+     * is null,  or <code>start</code> or <code>length</code> \n+     * is invalid</li>\n+     * </ul>\n+     * <p>\n+     * See {@link Percentile} for a description of the percentile estimation\n+     * algorithm used.\n+     * \n+     * @param values the input array\n+     * @param start index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the percentile value\n+     * @throws IllegalArgumentException if the parameters are not valid\n+     * \n+     */\n+    public double evaluate( final double[] values, final int start, final int length) {\n+        return evaluate(values, start, length, quantile);\n+    }\n+\n+     /**\n+     * Returns an estimate of the <code>p</code>th percentile of the values\n+     * in the <code>values</code> array, starting with the element in (0-based)\n+     * position <code>begin</code> in the array and including <code>length</code>\n+     * values.\n+     * <p>\n+     * Calls to this method do not modify the internal <code>quantile</code>\n+     * state of this statistic.\n+     * <p>\n+     * <ul>\n+     * <li>Returns <code>Double.NaN</code> if <code>length = 0</code></li>\n+     * <li>Returns (for any value of <code>p</code>) <code>values[begin]</code>\n+     *  if <code>length = 1 </code></li>\n+     * <li>Throws <code>IllegalArgumentException</code> if <code>values</code>\n+     *  is null , <code>begin</code> or <code>length</code> is invalid, or \n+     * <code>p</code> is not a valid quantile value (p must be greater than 0\n+     * and less than or equal to 100)</li>\n+     * </ul>\n+     * <p>\n+      * See {@link Percentile} for a description of the percentile estimation\n+      * algorithm used.\n+     * \n+     * @param values array of input values\n+     * @param p  the percentile to compute\n+     * @param begin  the first (0-based) element to include in the computation\n+     * @param length  the number of array elements to include\n+     * @return  the percentile value\n+     * @throws IllegalArgumentException if the parameters are not valid or the\n+     * input array is null\n+     */\n+    public double evaluate(final double[] values, final int begin, \n+            final int length, final double p) {\n+\n+        test(values, begin, length);\n+\n+        if ((p > 100) || (p <= 0)) {\n+            throw new IllegalArgumentException(\"invalid quantile value: \" + p);\n+        }\n+        double n = (double) length;\n+        if (n == 0) {\n+            return Double.NaN;\n+        }\n+        if (n == 1) {\n+            return values[begin]; // always return single value for n = 1\n+        }\n+        double pos = p * (n + 1) / 100;\n+        double fpos = Math.floor(pos);\n+        int intPos = (int) fpos;\n+        double dif = pos - fpos;\n+        double[] sorted = new double[length];\n+        System.arraycopy(values, begin, sorted, 0, length);\n+        Arrays.sort(sorted);\n+\n+        if (pos < 1) {\n+            return sorted[0];\n+        }\n+        if (pos >= n) {\n+            return sorted[length - 1];\n+        }\n+        double lower = sorted[intPos - 1];\n+        double upper = sorted[intPos];\n+        return lower + dif * (upper - lower);\n+    }\n+\n+    /**\n+     * Returns the value of the quantile field (determines what percentile is\n+     * computed when evaluate() is called with no quantile argument).\n+     * \n+     * @return quantile\n+     */\n+    public double getQuantile() {\n+        return quantile;\n+    }\n+\n+    /**\n+     * Sets the value of the quantile field (determines what percentile is \n+     * computed when evaluate() is called with no quantile argument).\n+     * \n+     * @param p a value between 0 < p <= 100 \n+     * @throws IllegalArgumentException  if p is not greater than 0 and less\n+     * than or equal to 100\n+     */\n+    public void setQuantile(final double p) {\n+        if (p <= 0 || p > 100) {\n+            throw new IllegalArgumentException(\"Illegal quantile value: \" + p);\n+        }\n+        quantile = p;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/Product.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.summary;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * Returns the product of the available values.\n+ * <p>\n+ * If there are no values in the dataset, or any of the values are \n+ * <code>NaN</code>, then <code>NaN</code> is returned.  \n+* <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:18 $\n+ */\n+public class Product extends AbstractStorelessUnivariateStatistic implements Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = 2824226005990582538L;   \n+     \n+    /**The number of values that have been added */\n+    private long n;\n+    \n+    /**\n+     * The current Running Product.\n+     */\n+    private double value;\n+\n+    /**\n+     * Create a Product instance\n+     */\n+    public Product() {\n+        n = 0;\n+        value = Double.NaN;\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     */\n+    public void increment(final double d) {\n+        if (n == 0) {\n+            value = d;\n+        } else {\n+            value *= d;\n+        }\n+        n++;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     */\n+    public double getResult() {\n+        return value;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        value = Double.NaN;\n+        n = 0;\n+    }\n+\n+    /**\n+     * Returns the product of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the product of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final int begin, final int length) {\n+        double product = Double.NaN;\n+        if (test(values, begin, length)) {\n+            product = 1.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                product *= values[i];\n+            }\n+        }\n+        return product;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/Sum.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.summary;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+  * Returns the sum of the available values.\n+ * <p>\n+ * If there are no values in the dataset, or any of the values are \n+ * <code>NaN</code>, then <code>NaN</code> is returned.  \n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:18 $\n+ */\n+public class Sum extends AbstractStorelessUnivariateStatistic implements Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -8231831954703408316L;  \n+      \n+    /** */\n+    private long n;\n+    \n+    /**\n+     * The currently running sum.\n+     */\n+    private double value;\n+\n+    /**\n+     * Create a Sum instance\n+     */\n+    public Sum() {\n+        n = 0;\n+        value = Double.NaN;\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     */\n+    public void increment(final double d) {\n+        if (n == 0) {\n+            value = d;\n+        } else {\n+            value += d;\n+        }\n+        n++;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     */\n+    public double getResult() {\n+        return value;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        value = Double.NaN;\n+        n = 0;\n+    }\n+\n+    /**\n+     * The sum of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the sum of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final int begin, final int length) {\n+        double sum = Double.NaN;\n+        if (test(values, begin, length)) {\n+            sum = 0.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                sum += values[i];\n+            }\n+        }\n+        return sum;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfLogs.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.summary;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * Returns the sum of the natural logs for this collection of values.  \n+ * <p>\n+ * Uses {@link java.lang.Math#log(double)} to compute the logs.  Therefore,\n+ * <ul>\n+ * <li>If any of values are < 0, the result is <code>NaN.</code></li>\n+ * <li>If all values are non-negative and less than \n+ * <code>Double.POSITIVE_INFINITY</code>,  but at least one value is 0, the\n+ * result is <code>Double.NEGATIVE_INFINITY.</code></li>\n+ * <li>If both <code>Double.POSITIVE_INFINITY</code> and \n+ * <code>Double.NEGATIVE_INFINITY</code> are among the values, the result is\n+ * <code>NaN.</code></li>\n+ * </ul>\n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:18 $\n+ */\n+public class SumOfLogs extends AbstractStorelessUnivariateStatistic implements Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -370076995648386763L;    \n+\n+    /**Number of values that have been added */\n+    private int n;\n+    \n+    /**\n+     * The currently running value\n+     */\n+    private double value;\n+    \n+    /**\n+     * Create a SumOfLogs instance\n+     */\n+    public SumOfLogs() {\n+       value = 0d;\n+       n = 0;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     */\n+    public void increment(final double d) {\n+        value += Math.log(d);\n+        n++;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     */\n+    public double getResult() {\n+        if (n > 0) {\n+            return value;\n+        } else {\n+            return Double.NaN;\n+        }\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        value = 0d;\n+        n = 0;\n+    }\n+\n+    /**\n+     * Returns the sum of the natural logs of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.\n+     * <p>\n+     * See {@link SumOfLogs}.\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the sum of the natural logs of the values or Double.NaN if \n+     * length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    public double evaluate(final double[] values, final int begin, final int length) {\n+        double sumLog = Double.NaN;\n+        if (test(values, begin, length)) {\n+            sumLog = 0.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                sumLog += Math.log(values[i]);\n+            }\n+        }\n+        return sumLog;\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/descriptive/summary/SumOfSquares.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.summary;\n+\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic;\n+\n+/**\n+ * Returns the sum of the squares of the available values.\n+ * <p>\n+ * If there are no values in the dataset, or any of the values are \n+ * <code>NaN</code>, then <code>NaN</code> is returned.  \n+ * <p>\n+ * <strong>Note that this implementation is not synchronized.</strong> If \n+ * multiple threads access an instance of this class concurrently, and at least\n+ * one of the threads invokes the <code>increment()</code> or \n+ * <code>clear()</code> method, it must be synchronized externally.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:18 $\n+ */\n+public class SumOfSquares extends AbstractStorelessUnivariateStatistic implements Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = 1460986908574398008L;  \n+      \n+    /** */\n+    private long n;\n+    \n+    /**\n+     * The currently running sumSq\n+     */\n+    private double value;\n+\n+    /**\n+     * Create a SumOfSquares instance\n+     */\n+    public SumOfSquares() {\n+        n = 0;\n+        value = Double.NaN;\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#increment(double)\n+     */\n+    public void increment(final double d) {\n+        if (n == 0) {\n+            value = d * d;\n+        } else {\n+            value += d * d;\n+        }\n+        n++;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getResult()\n+     */\n+    public double getResult() {\n+        return value;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#getN()\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.StorelessUnivariateStatistic#clear()\n+     */\n+    public void clear() {\n+        value = Double.NaN;\n+        n = 0;\n+    }\n+\n+    /**\n+     * Returns the sum of the squares of the entries in the specified portion of\n+     * the input array, or <code>Double.NaN</code> if the designated subarray\n+     * is empty.\n+     * <p>\n+     * Throws <code>IllegalArgumentException</code> if the array is null.\n+     * \n+     * @param values the input array\n+     * @param begin index of the first array element to include\n+     * @param length the number of elements to include\n+     * @return the sum of the squares of the values or Double.NaN if length = 0\n+     * @throws IllegalArgumentException if the array is null or the array index\n+     *  parameters are not valid\n+     */\n+    public double evaluate(final double[] values,final int begin, final int length) {\n+        double sumSq = Double.NaN;\n+        if (test(values, begin, length)) {\n+            sumSq = 0.0;\n+            for (int i = begin; i < begin + length; i++) {\n+                sumSq += values[i] * values[i];\n+            }\n+        }\n+        return sumSq;\n+    }\n+\n+}\n--- a/src/java/org/apache/commons/math/stat/inference/TTest.java\n+++ b/src/java/org/apache/commons/math/stat/inference/TTest.java\n package org.apache.commons.math.stat.inference;\n \n import org.apache.commons.math.MathException;\n-import org.apache.commons.math.stat.univariate.StatisticalSummary;\n+import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n \n /**\n  * An interface for Student's t-tests.\n  * {@link StatisticalSummary} instances.\n  * \n  *\n- * @version $Revision: 1.7 $ $Date: 2004/08/02 04:20:08 $ \n+ * @version $Revision: 1.8 $ $Date: 2004/10/08 05:08:18 $ \n  */\n public interface TTest {\n     /**\n--- a/src/java/org/apache/commons/math/stat/inference/TTestImpl.java\n+++ b/src/java/org/apache/commons/math/stat/inference/TTestImpl.java\n import org.apache.commons.math.distribution.DistributionFactory;\n import org.apache.commons.math.distribution.TDistribution;\n import org.apache.commons.math.stat.StatUtils;\n-import org.apache.commons.math.stat.univariate.StatisticalSummary;\n+import org.apache.commons.math.stat.descriptive.StatisticalSummary;\n \n /**\n  * Implements t-test statistics defined in the {@link TTest} interface.\n  * Uses commons-math {@link org.apache.commons.math.distribution.TDistribution}\n  * implementation to estimate exact p-values.\n  *\n- * @version $Revision: 1.9 $ $Date: 2004/08/02 04:20:08 $\n+ * @version $Revision: 1.10 $ $Date: 2004/10/08 05:08:18 $\n  */\n public class TTestImpl implements TTest  {\n \n--- /dev/null\n+++ b/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.stat.regression;\n+import java.io.Serializable;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.distribution.DistributionFactory;\n+import org.apache.commons.math.distribution.TDistribution;\n+\n+/**\n+ * Estimates an ordinary least squares regression model\n+ * with one independent variable.\n+ * <p>\n+ * <code> y = intercept + slope * x  </code>\n+ * <p>\n+ * Standard errors for <code>intercept</code> and <code>slope</code> are \n+ * available as well as ANOVA, r-square and Pearson's r statistics.\n+ * <p>\n+ * Observations (x,y pairs) can be added to the model one at a time or they \n+ * can be provided in a 2-dimensional array.  The observations are not stored\n+ * in memory, so there is no limit to the number of observations that can be\n+ * added to the model. \n+ * <p>\n+ * <strong>Usage Notes</strong>: <ul>\n+ * <li> When there are fewer than two observations in the model, or when\n+ * there is no variation in the x values (i.e. all x values are the same) \n+ * all statistics return <code>NaN</code>. At least two observations with\n+ * different x coordinates are requred to estimate a bivariate regression \n+ * model.\n+ * </li>\n+ * <li> getters for the statistics always compute values based on the current\n+ * set of observations -- i.e., you can get statistics, then add more data\n+ * and get updated statistics without using a new instance.  There is no \n+ * \"compute\" method that updates all statistics.  Each of the getters performs\n+ * the necessary computations to return the requested statistic.</li>\n+ * </ul>\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:18 $\n+ */\n+public class SimpleRegression implements Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -3004689053607543335L;\n+\n+    /** sum of x values */\n+    private double sumX = 0d;\n+\n+    /** total variation in x (sum of squared deviations from xbar) */\n+    private double sumXX = 0d;\n+\n+    /** sum of y values */\n+    private double sumY = 0d;\n+\n+    /** total variation in y (sum of squared deviations from ybar) */\n+    private double sumYY = 0d;\n+\n+    /** sum of products */\n+    private double sumXY = 0d;\n+\n+    /** number of observations */\n+    private long n = 0;\n+\n+    /** mean of accumulated x values, used in updating formulas */\n+    private double xbar = 0;\n+\n+    /** mean of accumulated y values, used in updating formulas */\n+    private double ybar = 0;\n+\n+    // ---------------------Public methods--------------------------------------\n+\n+    /**\n+     * Create an empty SimpleRegression instance\n+     */\n+    public SimpleRegression() {\n+        super();\n+    }\n+    \n+    /**\n+     * Adds the observation (x,y) to the regression data set.\n+     * <p>\n+     * Uses updating formulas for means and sums of squares defined in \n+     * \"Algorithms for Computing the Sample Variance: Analysis and\n+     * Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J. \n+     * 1983, American Statistician, vol. 37, pp. 242-247, referenced in\n+     * Weisberg, S. \"Applied Linear Regression\". 2nd Ed. 1985\n+     *\n+     *\n+     * @param x independent variable value\n+     * @param y dependent variable value\n+     */\n+    public void addData(double x, double y) {\n+        if (n == 0) {\n+            xbar = x;\n+            ybar = y;\n+        } else {\n+            double dx = x - xbar;\n+            double dy = y - ybar;\n+            sumXX += dx * dx * (double) n / (double) (n + 1.0);\n+            sumYY += dy * dy * (double) n / (double) (n + 1.0);\n+            sumXY += dx * dy * (double) n / (double) (n + 1.0);\n+            xbar += dx / (double) (n + 1.0);\n+            ybar += dy / (double) (n + 1.0);\n+        }\n+        sumX += x;\n+        sumY += y;\n+        n++;\n+    }\n+\n+    /**\n+     * Adds the observations represented by the elements in \n+     * <code>data</code>.\n+     * <p>\n+     * <code>(data[0][0],data[0][1])</code> will be the first observation, then\n+     * <code>(data[1][0],data[1][1])</code>, etc. \n+     * <p> \n+     * This method does not replace data that has already been added.  The\n+     * observations represented by <code>data</code> are added to the existing\n+     * dataset.\n+     * <p> \n+     * To replace all data, use <code>clear()</code> before adding the new \n+     * data.\n+     * \n+     * @param data array of observations to be added\n+     */\n+    public void addData(double[][] data) {\n+        for (int i = 0; i < data.length; i++) {\n+            addData(data[i][0], data[i][1]);\n+        }\n+    }\n+\n+    /**\n+     * Clears all data from the model.\n+     */\n+    public void clear() {\n+        sumX = 0d;\n+        sumXX = 0d;\n+        sumY = 0d;\n+        sumYY = 0d;\n+        sumXY = 0d;\n+        n = 0;\n+    }\n+\n+    /**\n+     * Returns the number of observations that have been added to the model.\n+     *\n+     * @return n number of observations that have been added.\n+     */\n+    public long getN() {\n+        return n;\n+    }\n+\n+    /**\n+     * Returns the \"predicted\" <code>y</code> value associated with the \n+     * supplied <code>x</code> value,  based on the data that has been\n+     * added to the model when this method is activated.\n+     * <p>\n+     * <code> predict(x) = intercept + slope * x </code>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>At least two observations (with at least two different x values)\n+     * must have been added before invoking this method. If this method is \n+     * invoked before a model can be estimated, <code>Double,NaN</code> is\n+     * returned.\n+     * </li></ul>\n+     *\n+     * @param x input <code>x</code> value\n+     * @return predicted <code>y</code> value\n+     */\n+    public double predict(double x) {\n+        double b1 = getSlope();\n+        return getIntercept(b1) + b1 * x;\n+    }\n+\n+    /**\n+     * Returns the intercept of the estimated regression line.\n+     * <p>\n+     * The least squares estimate of the intercept is computed using the \n+     * <a href=\"http://www.xycoon.com/estimation4.htm\">normal equations</a>.\n+     * The intercept is sometimes denoted b0. \n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>At least two observations (with at least two different x values)\n+     * must have been added before invoking this method. If this method is \n+     * invoked before a model can be estimated, <code>Double,NaN</code> is\n+     * returned.\n+     * </li></ul>\n+     *\n+     * @return the intercept of the regression line\n+     */\n+    public double getIntercept() {\n+        return getIntercept(getSlope());\n+    }\n+\n+    /**\n+    * Returns the slope of the estimated regression line.  \n+    * <p>\n+    * The least squares estimate of the slope is computed using the \n+    * <a href=\"http://www.xycoon.com/estimation4.htm\">normal equations</a>.\n+    * The slope is sometimes denoted b1. \n+    * <p>\n+    * <strong>Preconditions</strong>: <ul>\n+    * <li>At least two observations (with at least two different x values)\n+    * must have been added before invoking this method. If this method is \n+    * invoked before a model can be estimated, <code>Double.NaN</code> is\n+    * returned.\n+    * </li></ul>\n+    *\n+    * @return the slope of the regression line\n+    */\n+    public double getSlope() {\n+        if (n < 2) {\n+            return Double.NaN; //not enough data \n+        }\n+        if (Math.abs(sumXX) < 10 * Double.MIN_VALUE) {\n+            return Double.NaN; //not enough variation in x\n+        }\n+        return sumXY / sumXX;\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://www.xycoon.com/SumOfSquares.htm\">\n+     * sum of squared errors</a> (SSE) associated with the regression \n+     * model.\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>At least two observations (with at least two different x values)\n+     * must have been added before invoking this method. If this method is \n+     * invoked before a model can be estimated, <code>Double,NaN</code> is\n+     * returned.\n+     * </li></ul>\n+     *\n+     * @return sum of squared errors associated with the regression model\n+     */\n+    public double getSumSquaredErrors() {\n+        return getSumSquaredErrors(getSlope());\n+    }\n+\n+    /**\n+     * Returns the sum of squared deviations of the y values about their mean.\n+     * <p>\n+     * This is defined as SSTO \n+     * <a href=\"http://www.xycoon.com/SumOfSquares.htm\">here</a>.\n+     * <p>\n+     * If <code>n < 2</code>, this returns <code>Double.NaN</code>.\n+     *\n+     * @return sum of squared deviations of y values\n+     */\n+    public double getTotalSumSquares() {\n+        if (n < 2) {\n+            return Double.NaN;\n+        }\n+        return sumYY;\n+    }\n+\n+    /**\n+     * Returns the sum of squared deviations of the predicted y values about \n+     * their mean (which equals the mean of y).\n+     * <p>\n+     * This is usually abbreviated SSR or SSM.  It is defined as SSM \n+     * <a href=\"http://www.xycoon.com/SumOfSquares.htm\">here</a>\n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>At least two observations (with at least two different x values)\n+     * must have been added before invoking this method. If this method is \n+     * invoked before a model can be estimated, <code>Double.NaN</code> is\n+     * returned.\n+     * </li></ul>\n+     *\n+     * @return sum of squared deviations of predicted y values\n+     */\n+    public double getRegressionSumSquares() {\n+        return getRegressionSumSquares(getSlope());\n+    }\n+\n+    /**\n+     * Returns the sum of squared errors divided by the degrees of freedom,\n+     * usually abbreviated MSE. \n+     * <p>\n+     * If there are fewer than <strong>three</strong> data pairs in the model,\n+     * or if there is no variation in <code>x</code>, this returns \n+     * <code>Double.NaN</code>.\n+     *\n+     * @return sum of squared deviations of y values\n+     */\n+    public double getMeanSquareError() {\n+        if (n < 3) {\n+            return Double.NaN;\n+        }\n+        return getSumSquaredErrors() / (double) (n - 2);\n+    }\n+\n+    /**\n+     * Returns <a href=\"http://mathworld.wolfram.com/CorrelationCoefficient.html\">\n+     * Pearson's product moment correlation coefficient</a>,\n+     * usually denoted r. \n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>At least two observations (with at least two different x values)\n+     * must have been added before invoking this method. If this method is \n+     * invoked before a model can be estimated, <code>Double,NaN</code> is\n+     * returned.\n+     * </li></ul>\n+     *\n+     * @return Pearson's r\n+     */\n+    public double getR() {\n+        double b1 = getSlope();\n+        double result = Math.sqrt(getRSquare(b1));\n+        if (b1 < 0) {\n+            result = -result;\n+        }\n+        return result;\n+    }\n+\n+    /** \n+     * Returns the <a href=\"http://www.xycoon.com/coefficient1.htm\"> \n+     * coefficient of determination</a>,\n+     * usually denoted r-square. \n+     * <p>\n+     * <strong>Preconditions</strong>: <ul>\n+     * <li>At least two observations (with at least two different x values)\n+     * must have been added before invoking this method. If this method is \n+     * invoked before a model can be estimated, <code>Double,NaN</code> is\n+     * returned.\n+     * </li></ul>\n+     *\n+     * @return r-square\n+     */\n+    public double getRSquare() {\n+        return getRSquare(getSlope());\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://www.xycoon.com/standarderrorb0.htm\">\n+     * standard error of the intercept estimate</a>, \n+     * usually denoted s(b0). \n+     * <p>\n+     * If there are fewer that <strong>three</strong> observations in the \n+     * model, or if there is no variation in x, this returns \n+     * <code>Double.NaN</code>.\n+     *\n+     * @return standard error associated with intercept estimate\n+     */\n+    public double getInterceptStdErr() {\n+        return Math.sqrt(\n+            getMeanSquareError() * ((1d / (double) n) + (xbar * xbar) / sumXX));\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://www.xycoon.com/standerrorb(1).htm\">standard\n+     * error of the slope estimate</a>,\n+     * usually denoted s(b1). \n+     * <p>\n+     * If there are fewer that <strong>three</strong> data pairs in the model,\n+     * or if there is no variation in x, this returns <code>Double.NaN</code>.\n+     *\n+     * @return standard error associated with slope estimate\n+     */\n+    public double getSlopeStdErr() {\n+        return Math.sqrt(getMeanSquareError() / sumXX);\n+    }\n+\n+    /**\n+     * Returns the half-width of a 95% confidence interval for the slope\n+     * estimate.\n+     * <p>\n+     * The 95% confidence interval is \n+     * <p>\n+     * <code>(getSlope() - getSlopeConfidenceInterval(), \n+     * getSlope() + getSlopeConfidenceInterval())</code>\n+     * <p>\n+     * If there are fewer that <strong>three</strong> observations in the \n+     * model, or if there is no variation in x, this returns \n+     * <code>Double.NaN</code>.\n+     * <p>\n+     * <strong>Usage Note</strong>:<br>\n+     * The validity of this statistic depends on the assumption that the \n+     * observations included in the model are drawn from a\n+     * <a href=\"http://mathworld.wolfram.com/BivariateNormalDistribution.html\">\n+     * Bivariate Normal Distribution</a>.\n+     *\n+     * @return half-width of 95% confidence interval for the slope estimate\n+     * \n+     * @throws MathException if the confidence interval can not be computed.\n+     */\n+    public double getSlopeConfidenceInterval() throws MathException {\n+        return getSlopeConfidenceInterval(0.05d);\n+    }\n+\n+    /**\n+     * Returns the half-width of a (100-100*alpha)% confidence interval for \n+     * the slope estimate.\n+     * <p>\n+     * The (100-100*alpha)% confidence interval is \n+     * <p>\n+     * <code>(getSlope() - getSlopeConfidenceInterval(), \n+     * getSlope() + getSlopeConfidenceInterval())</code>\n+     * <p>\n+     * To request, for example, a 99% confidence interval, use \n+     * <code>alpha = .01</code>\n+     * <p>\n+     * <strong>Usage Note</strong>:<br>\n+     * The validity of this statistic depends on the assumption that the \n+     * observations included in the model are drawn from a\n+     * <a href=\"http://mathworld.wolfram.com/BivariateNormalDistribution.html\">\n+     * Bivariate Normal Distribution</a>.\n+     * <p>\n+     * <strong> Preconditions:</strong><ul>\n+     * <li>If there are fewer that <strong>three</strong> observations in the \n+     * model, or if there is no variation in x, this returns \n+     * <code>Double.NaN</code>. \n+     * </li>\n+     * <li><code>(0 < alpha < 1)</code>; otherwise an \n+     * <code>IllegalArgumentException</code> is thrown.\n+     * </li></ul>    \n+     *\n+     * @param alpha the desired significance level \n+     * @return half-width of 95% confidence interval for the slope estimate\n+     * @throws MathException if the confidence interval can not be computed.\n+     */\n+    public double getSlopeConfidenceInterval(double alpha)\n+        throws MathException {\n+        if (alpha >= 1 || alpha <= 0) {\n+            throw new IllegalArgumentException();\n+        }\n+        return getSlopeStdErr() *\n+            getTDistribution().inverseCumulativeProbability(1d - alpha / 2d);\n+    }\n+\n+    /**\n+     * Returns the significance level of the slope (equiv) correlation. \n+     * <p>\n+     * Specifically, the returned value is the smallest <code>alpha</code>\n+     * such that the slope confidence interval with significance level\n+     * equal to <code>alpha</code> does not include <code>0</code>.\n+     * On regression output, this is often denoted <code>Prob(|t| > 0)</code>\n+     * <p>\n+     * <strong>Usage Note</strong>:<br>\n+     * The validity of this statistic depends on the assumption that the \n+     * observations included in the model are drawn from a\n+     * <a href=\"http://mathworld.wolfram.com/BivariateNormalDistribution.html\">\n+     * Bivariate Normal Distribution</a>.\n+     * <p>\n+     * If there are fewer that <strong>three</strong> observations in the \n+     * model, or if there is no variation in x, this returns \n+     * <code>Double.NaN</code>.\n+     *\n+     * @return significance level for slope/correlation\n+     * @throws MathException if the significance level can not be computed.\n+     */\n+    public double getSignificance() throws MathException {\n+        return (\n+            1.0 - getTDistribution().cumulativeProbability(\n+                    Math.abs(getSlope()) / getSlopeStdErr()));\n+    }\n+\n+    // ---------------------Private methods-----------------------------------\n+\n+    /**\n+    * Returns the intercept of the estimated regression line, given the slope.\n+    * <p>\n+    * Will return <code>NaN</code> if slope is <code>NaN</code>.\n+    *\n+    * @param slope current slope\n+    * @return the intercept of the regression line\n+    */\n+    private double getIntercept(double slope) {\n+        return (sumY - slope * sumX) / ((double) n);\n+    }\n+\n+    /**\n+     * Returns the sum of squared errors associated with the regression \n+     * model, using the slope of the regression line. \n+     * <p> \n+     * Returns NaN if the slope is NaN.\n+     * \n+     * @param b1 current slope\n+     * @return sum of squared errors associated with the regression model\n+     */\n+    private double getSumSquaredErrors(double b1) {\n+        return sumYY - sumXY * sumXY / sumXX;\n+    }\n+\n+    /** \n+     * Computes r-square from the slope.\n+     * <p>\n+     * will return NaN if slope is Nan.\n+     *\n+     * @param b1 current slope\n+     * @return r-square\n+     */\n+    private double getRSquare(double b1) {\n+        double ssto = getTotalSumSquares();\n+        return (ssto - getSumSquaredErrors(b1)) / ssto;\n+    }\n+\n+    /**\n+     * Computes SSR from b1.\n+     * \n+     * @param slope regression slope estimate\n+     * @return sum of squared deviations of predicted y values\n+     */\n+    private double getRegressionSumSquares(double slope) {\n+        return slope * slope * sumXX;\n+    }\n+\n+    /**\n+     * Uses distribution framework to get a t distribution instance \n+     * with df = n - 2\n+     *\n+     * @return t distribution with df = n - 2\n+     */\n+    private TDistribution getTDistribution() {\n+        return DistributionFactory.newInstance().createTDistribution(n - 2);\n+    }\n+}\n--- a/src/test/org/apache/commons/math/random/EmpiricalDistributionTest.java\n+++ b/src/test/org/apache/commons/math/random/EmpiricalDistributionTest.java\n \n import org.apache.commons.math.RetryTestCase;\n import org.apache.commons.math.TestUtils;\n-import org.apache.commons.math.stat.univariate.SummaryStatistics;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n \n /**\n  * Test cases for the EmpiricalDistribution class\n  *\n- * @version $Revision: 1.18 $ $Date: 2004/06/17 23:51:33 $\n+ * @version $Revision: 1.19 $ $Date: 2004/10/08 05:08:19 $\n  */\n \n public final class EmpiricalDistributionTest extends RetryTestCase {\n--- a/src/test/org/apache/commons/math/random/RandomDataTest.java\n+++ b/src/test/org/apache/commons/math/random/RandomDataTest.java\n import org.apache.commons.math.RetryTestCase;\n import org.apache.commons.math.stat.Frequency;\n import org.apache.commons.math.stat.inference.ChiSquareTestImpl;\n-import org.apache.commons.math.stat.univariate.SummaryStatistics;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n \n /**\n  * Test cases for the RandomData class.\n  *\n- * @version $Revision: 1.16 $ $Date: 2004/05/03 03:08:08 $\n+ * @version $Revision: 1.17 $ $Date: 2004/10/08 05:08:19 $\n  */\n \n public final class RandomDataTest extends RetryTestCase {\n--- a/src/test/org/apache/commons/math/random/ValueServerTest.java\n+++ b/src/test/org/apache/commons/math/random/ValueServerTest.java\n import java.net.URL;\n \n import org.apache.commons.math.RetryTestCase;\n-import org.apache.commons.math.stat.univariate.SummaryStatistics;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n  \n /**\n  * Test cases for the ValueServer class.\n  *\n- * @version $Revision: 1.16 $ $Date: 2004/05/23 00:30:01 $\n+ * @version $Revision: 1.17 $ $Date: 2004/10/08 05:08:19 $\n  */\n \n public final class ValueServerTest extends RetryTestCase {\n--- a/src/test/org/apache/commons/math/stat/CertifiedDataTest.java\n+++ b/src/test/org/apache/commons/math/stat/CertifiedDataTest.java\n import java.io.BufferedReader;\n import java.io.InputStreamReader;\n \n-import org.apache.commons.math.stat.univariate.SummaryStatistics;\n-import org.apache.commons.math.stat.univariate.SummaryStatisticsImpl;\n-import org.apache.commons.math.stat.univariate.DescriptiveStatistics;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n+import org.apache.commons.math.stat.descriptive.SummaryStatisticsImpl;\n+import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n \n /**\n  * Certified data test cases.\n- * @version $Revision: 1.18 $ $Date: 2004/07/10 16:07:07 $\n+ * @version $Revision: 1.19 $ $Date: 2004/10/08 05:08:19 $\n  */\n public class CertifiedDataTest extends TestCase  {\n \n--- a/src/test/org/apache/commons/math/stat/data/CertifiedDataAbstractTest.java\n+++ b/src/test/org/apache/commons/math/stat/data/CertifiedDataAbstractTest.java\n import java.util.Map;\n \n import org.apache.commons.math.TestUtils;\n-import org.apache.commons.math.stat.univariate.DescriptiveStatistics;\n-import org.apache.commons.math.stat.univariate.SummaryStatistics;\n+import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n \n import junit.framework.TestCase;\n \n /**\n- * @version $Revision: 1.6 $ $Date: 2004/06/04 13:54:03 $\n+ * @version $Revision: 1.7 $ $Date: 2004/10/08 05:08:19 $\n  */\n public abstract class CertifiedDataAbstractTest extends TestCase {\n \t\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/AbstractUnivariateStatisticTest.java\n+/*\n+ * \n+ * Copyright (c) 2004 The Apache Software Foundation. All rights reserved.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy\n+ * of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ *  \n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.moment.Mean;\n+\n+/**\n+ * Tests for AbstractUnivariateStatistic \n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:19 $\n+ */\n+public class AbstractUnivariateStatisticTest extends TestCase {\n+    \n+    public AbstractUnivariateStatisticTest(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(AbstractUnivariateStatisticTest.class);\n+        suite.setName(\"AbstractUnivariateStatistic Tests\");\n+        return suite;\n+    }\n+    \n+    protected double[] testArray = {0, 1, 2, 3, 4, 5};\n+    protected double[] nullArray = null;\n+    protected double[] singletonArray = {0};\n+    protected Mean testStatistic = new Mean();\n+    \n+    public void testTestPositive() {\n+        for (int j = 0; j < 6; j++) {\n+            for (int i = 1; i < (7 - j); i++) {\n+                assertTrue(testStatistic.test(testArray, 0, i));\n+            }  \n+        }\n+        assertTrue(testStatistic.test(singletonArray, 0, 1));\n+    }\n+    \n+    public void testTestNegative() {\n+        assertFalse(testStatistic.test(singletonArray, 0, 0));\n+        assertFalse(testStatistic.test(testArray, 0, 0));\n+        try {\n+            testStatistic.test(singletonArray, 2, 1);  // start past end\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            testStatistic.test(testArray, 0, 7);  // end past end\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            testStatistic.test(testArray, -1, 1);  // start negative\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            testStatistic.test(testArray, 0, -1);  // length negative\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            testStatistic.test(nullArray, 0, 1);  // null array\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }      \n+    } \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsImplTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.random.RandomData;\n+import org.apache.commons.math.random.RandomDataImpl;\n+\n+/**\n+ * Test cases for the {@link Univariate} class.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:19 $\n+ */\n+\n+public final class DescriptiveStatisticsImplTest extends TestCase {\n+    private double one = 1;\n+    private float two = 2;\n+    private int three = 3;\n+    private double mean = 2;\n+    private double sumSq = 18;\n+    private double sum = 8;\n+    private double var = 0.666666666666666666667;\n+    private double std = Math.sqrt(var);\n+    private double n = 4;\n+    private double min = 1;\n+    private double max = 3;\n+    private double skewness = 0;\n+    private double kurtosis = 0.5;\n+    private double tolerance = 10E-15;\n+    \n+    public DescriptiveStatisticsImplTest(String name) {\n+        super(name);\n+    }\n+    \n+    public void setUp() {  \n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(DescriptiveStatisticsImplTest.class);\n+        suite.setName(\"DescriptiveStatistics Tests\");\n+        return suite;\n+    }\n+    \n+    /** test stats */\n+    public void testStats() {\n+        DescriptiveStatistics u = DescriptiveStatistics.newInstance(); \n+        assertEquals(\"total count\",0,u.getN(),tolerance);\n+        u.addValue(one);\n+        u.addValue(two);\n+        u.addValue(two);\n+        u.addValue(three);\n+        assertEquals(\"N\",n,u.getN(),tolerance);\n+        assertEquals(\"sum\",sum,u.getSum(),tolerance);\n+        assertEquals(\"sumsq\",sumSq,u.getSumsq(),tolerance);\n+        assertEquals(\"var\",var,u.getVariance(),tolerance);\n+        assertEquals(\"std\",std,u.getStandardDeviation(),tolerance);\n+        assertEquals(\"mean\",mean,u.getMean(),tolerance);\n+        assertEquals(\"min\",min,u.getMin(),tolerance);\n+        assertEquals(\"max\",max,u.getMax(),tolerance);\n+        u.clear();\n+        assertEquals(\"total count\",0,u.getN(),tolerance);    \n+    }     \n+    \n+    public void testN0andN1Conditions() throws Exception {\n+    \tDescriptiveStatistics u = DescriptiveStatistics.newInstance(); \n+    \t    \t\n+            assertTrue(\"Mean of n = 0 set should be NaN\", \n+                Double.isNaN( u.getMean() ) );\n+            assertTrue(\"Standard Deviation of n = 0 set should be NaN\", \n+                Double.isNaN( u.getStandardDeviation() ) );\n+            assertTrue(\"Variance of n = 0 set should be NaN\",\n+                Double.isNaN(u.getVariance() ) );\n+\n+            u.addValue(one);\n+\n+            assertTrue( \"Mean of n = 1 set should be value of single item n1\",\n+                u.getMean() == one);\n+            assertTrue( \"StdDev of n = 1 set should be zero, instead it is: \" \n+                + u.getStandardDeviation(), u.getStandardDeviation() == 0);\n+            assertTrue( \"Variance of n = 1 set should be zero\", \n+                u.getVariance() == 0);\t\n+    }\n+    \n+    public void testSkewAndKurtosis() {\n+    \tDescriptiveStatistics u = DescriptiveStatistics.newInstance(); \n+    \t\n+    \tdouble[] testArray = \n+        { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,\n+          9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };\n+  \t  \tfor( int i = 0; i < testArray.length; i++) {\n+  \t  \t\tu.addValue( testArray[i]);\n+  \t  \t}\n+  \t  \t\n+\t\tassertEquals(\"mean\", 12.40455, u.getMean(), 0.0001);\n+\t\tassertEquals(\"variance\", 10.00236, u.getVariance(), 0.0001);\n+\t\tassertEquals(\"skewness\", 1.437424, u.getSkewness(), 0.0001);\n+  \t  \tassertEquals(\"kurtosis\", 2.37719, u.getKurtosis(), 0.0001);\n+    }\n+\n+    public void testProductAndGeometricMean() throws Exception {\n+    \tDescriptiveStatistics u = DescriptiveStatistics.newInstance(); \n+        u.setWindowSize(10);\n+    \t    \t\n+        u.addValue( 1.0 );\n+        u.addValue( 2.0 );\n+        u.addValue( 3.0 );\n+        u.addValue( 4.0 );\n+\n+        //assertEquals( \"Product not expected\", \n+        //    24.0, u.getProduct(), Double.MIN_VALUE );\n+        assertEquals( \"Geometric mean not expected\", \n+            2.213364, u.getGeometricMean(), 0.00001 );\n+\n+        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution\n+        // of a discarded element\n+        for( int i = 0; i < 10; i++ ) {\n+            u.addValue( i + 2 );\n+        }\n+        // Values should be (2,3,4,5,6,7,8,9,10,11)\n+        \n+        //assertEquals( \"Product not expected\", 39916800.0, \n+        //    u.getProduct(), 0.00001 );\n+        assertEquals( \"Geometric mean not expected\", 5.755931, \n+            u.getGeometricMean(), 0.00001 );\n+    }\n+    \n+    public void testGetSortedValues() {\n+        double[] test1 = {5,4,3,2,1};\n+        double[] test2 = {5,2,1,3,4,0};\n+        double[] test3 = {1};\n+        int[] testi = null;\n+        double[] test4 = null;\n+        RandomData rd = new RandomDataImpl();\n+        tstGetSortedValues(test1);\n+        tstGetSortedValues(test2);\n+        tstGetSortedValues(test3);\n+        for (int i = 0; i < 10; i++) {\n+            testi = rd.nextPermutation(10,6);\n+            test4 = new double[6];\n+            for (int j = 0; j < testi.length; j++) {\n+                test4[j] = (double) testi[j];\n+            }\n+            tstGetSortedValues(test4);\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            testi = rd.nextPermutation(10,5);\n+            test4 = new double[5];\n+            for (int j = 0; j < testi.length; j++) {\n+                test4[j] = (double) testi[j];\n+            }\n+            tstGetSortedValues(test4);\n+        }        \n+    }\n+    \n+        \n+    private void tstGetSortedValues(double[] test) {\n+        DescriptiveStatistics u = DescriptiveStatistics.newInstance(); \n+        for (int i = 0; i < test.length; i++) {\n+            u.addValue(test[i]);\n+        }\n+        double[] sorted = u.getSortedValues();\n+        if (sorted.length != test.length) {\n+            fail(\"wrong length for sorted values array\");\n+        }\n+        for (int i = 0; i < sorted.length-1; i++) {\n+            if (sorted[i] > sorted[i+1]) {\n+                fail(\"sorted values out of sequence\");\n+            }\n+        }\n+    }\n+    \n+    public void testPercentiles() {\n+        double[] test = {5,4,3,2,1};\n+        DescriptiveStatistics u = DescriptiveStatistics.newInstance(); \n+        for (int i = 0; i < test.length; i++) {\n+            u.addValue(test[i]);\n+        }\n+        assertEquals(\"expecting min\",1,u.getPercentile(5),10E-12);\n+        assertEquals(\"expecting max\",5,u.getPercentile(99),10E-12);\n+        assertEquals(\"expecting middle\",3,u.getPercentile(50),10E-12);\n+        try {\n+            double x = u.getPercentile(0);\n+            fail(\"expecting IllegalArgumentException for getPercentile(0)\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            double x = u.getPercentile(120);\n+            fail(\"expecting IllegalArgumentException for getPercentile(120)\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        \n+        u.clear();\n+        double[] test2 = {1,2,3,4};\n+        for (int i = 0; i < test2.length; i++) {\n+            u.addValue(test2[i]);\n+        }\n+        assertEquals(\"Q1\",1.25,u.getPercentile(25),10E-12);\n+        assertEquals(\"Q3\",3.75,u.getPercentile(75),10E-12);\n+        assertEquals(\"Q2\",2.5,u.getPercentile(50),10E-12);\n+        \n+        u.clear();\n+        double[] test3 = {1};\n+        for (int i = 0; i < test3.length; i++) {\n+            u.addValue(test3[i]);\n+        }\n+        assertEquals(\"Q1\",1,u.getPercentile(25),10E-12);\n+        assertEquals(\"Q3\",1,u.getPercentile(75),10E-12);\n+        assertEquals(\"Q2\",1,u.getPercentile(50),10E-12);\n+        \n+        u.clear();\n+        RandomData rd = new RandomDataImpl();\n+        int[] testi = rd.nextPermutation(100,100); // will contain 0-99\n+        for (int j = 0; j < testi.length; j++) {\n+            u.addValue((double) testi[j]);  //OK, laugh at me for the cast\n+        }\n+        for (int i = 1; i < 100; i++) {\n+            assertEquals(\"percentile \" + i,\n+                (double) i-1 + (double) i*(.01), u.getPercentile(i),10E-12);\n+        }\n+        \n+        u.clear();\n+        double[] test4 = {1,2,3,4,100};\n+        for (int i = 0; i < test4.length; i++) {\n+            u.addValue(test4[i]);\n+        }\n+        assertEquals(\"80th\",80.8,u.getPercentile(80),10E-12);\n+        \n+        u.clear();\n+        assertTrue(\"empty value set should return NaN\",\n+            Double.isNaN(u.getPercentile(50)));\n+    }\n+                                     \n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/DescriptiveStatisticsTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.random.RandomData;\n+import org.apache.commons.math.random.RandomDataImpl;\n+\n+/**\n+ * Test cases for the {@link Univariate} class.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:19 $\n+ */\n+\n+public final class DescriptiveStatisticsTest extends TestCase {\n+    private double one = 1;\n+    private float two = 2;\n+    private int three = 3;\n+    private double mean = 2;\n+    private double sumSq = 18;\n+    private double sum = 8;\n+    private double var = 0.666666666666666666667;\n+    private double std = Math.sqrt(var);\n+    private double n = 4;\n+    private double min = 1;\n+    private double max = 3;\n+    private double skewness = 0;\n+    private double kurtosis = 0.5;\n+    private double tolerance = 10E-15;\n+    \n+    public DescriptiveStatisticsTest(String name) {\n+        super(name);\n+    }\n+    \n+    public void setUp() {  \n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(DescriptiveStatisticsTest.class);\n+        suite.setName(\"Descriptive Statistics Tests\");\n+        return suite;\n+    }\n+    \n+    /** test stats */\n+    public void testStats() {\n+        DescriptiveStatistics u = DescriptiveStatistics.newInstance(); \n+        assertEquals(\"total count\",0,u.getN(),tolerance);\n+        u.addValue(one);\n+        u.addValue(two);\n+        u.addValue(two);\n+        u.addValue(three);\n+        assertEquals(\"N\",n,u.getN(),tolerance);\n+        assertEquals(\"sum\",sum,u.getSum(),tolerance);\n+        assertEquals(\"sumsq\",sumSq,u.getSumsq(),tolerance);\n+        assertEquals(\"var\",var,u.getVariance(),tolerance);\n+        assertEquals(\"std\",std,u.getStandardDeviation(),tolerance);\n+        assertEquals(\"mean\",mean,u.getMean(),tolerance);\n+        assertEquals(\"min\",min,u.getMin(),tolerance);\n+        assertEquals(\"max\",max,u.getMax(),tolerance);\n+        u.clear();\n+        assertEquals(\"total count\",0,u.getN(),tolerance);    \n+    }     \n+    \n+    public void testN0andN1Conditions() throws Exception {\n+    \tDescriptiveStatistics u = DescriptiveStatistics.newInstance();\n+    \t    \t\n+            assertTrue(\"Mean of n = 0 set should be NaN\", \n+                Double.isNaN( u.getMean() ) );\n+            assertTrue(\"Standard Deviation of n = 0 set should be NaN\", \n+                Double.isNaN( u.getStandardDeviation() ) );\n+            assertTrue(\"Variance of n = 0 set should be NaN\",\n+                Double.isNaN(u.getVariance() ) );\n+\n+            u.addValue(one);\n+\n+            assertTrue( \"Mean of n = 1 set should be value of single item n1\",\n+                u.getMean() == one);\n+            assertTrue( \"StdDev of n = 1 set should be zero, instead it is: \" \n+                + u.getStandardDeviation(), u.getStandardDeviation() == 0);\n+            assertTrue( \"Variance of n = 1 set should be zero\", \n+                u.getVariance() == 0);\t\n+    }\n+    \n+    public void testSkewAndKurtosis() {\n+    \tDescriptiveStatistics u = DescriptiveStatistics.newInstance();\n+    \t\n+    \tdouble[] testArray = \n+        { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,\n+          9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };\n+  \t  \tfor( int i = 0; i < testArray.length; i++) {\n+  \t  \t\tu.addValue( testArray[i]);\n+  \t  \t}\n+  \t  \t\n+\t\tassertEquals(\"mean\", 12.40455, u.getMean(), 0.0001);\n+\t\tassertEquals(\"variance\", 10.00236, u.getVariance(), 0.0001);\n+\t\tassertEquals(\"skewness\", 1.437424, u.getSkewness(), 0.0001);\n+  \t  \tassertEquals(\"kurtosis\", 2.37719, u.getKurtosis(), 0.0001);\n+    }\n+\n+    public void testProductAndGeometricMean() throws Exception {\n+    \tDescriptiveStatistics u = DescriptiveStatistics.newInstance();\n+        u.setWindowSize(10);\n+    \t    \t\n+        u.addValue( 1.0 );\n+        u.addValue( 2.0 );\n+        u.addValue( 3.0 );\n+        u.addValue( 4.0 );\n+\n+        //assertEquals( \"Product not expected\", \n+        //    24.0, u.getProduct(), Double.MIN_VALUE );\n+        assertEquals( \"Geometric mean not expected\", \n+            2.213364, u.getGeometricMean(), 0.00001 );\n+\n+        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution\n+        // of a discarded element\n+        for( int i = 0; i < 10; i++ ) {\n+            u.addValue( i + 2 );\n+        }\n+        // Values should be (2,3,4,5,6,7,8,9,10,11)\n+        \n+        //assertEquals( \"Product not expected\", 39916800.0, \n+        //    u.getProduct(), 0.00001 );\n+        assertEquals( \"Geometric mean not expected\", 5.755931, \n+            u.getGeometricMean(), 0.00001 );\n+    }\n+    \n+\tpublic void testAddValue() {\n+\t\tdouble[] test1 = {5,4,3,2,1,0};\n+\t\tdouble[] test2 = {5,2,1,0,4,3};\n+\n+\t\tDescriptiveStatistics stats = DescriptiveStatistics.newInstance();\n+\t\tstats.setWindowSize(12);\n+\t\t\n+\t\tfor(int i = 0; i < test1.length; i++){\n+\t\t\tstats.addValue(test1[i]);\n+\t\t}     \n+\t\t\n+\t\tdouble[] test3 = stats.getValues();\n+\t\t\n+\t\tfor(int i = 0; i < 6; i++){\n+\t\t\tassertEquals( \"Added value [\"+i+\"] not equal\", \n+\t\t\ttest3[i], test1[i],0.0);\n+\t\t\t//System.out.println(test3[i] + \" \"+test1[i]);\n+\t\t}     \n+\t\t\t\t\n+\t\tfor(int i = 0; i < test2.length; i++){\n+\t\t\tstats.addValue(test2[i]);\n+\t\t}     \n+ \n+\t\ttest3 = stats.getValues();  \n+\t\t\n+\t\tfor(int i = 6; i < 12; i++){\n+\t\t\tassertEquals( \"Added value [\"+i+\"] not equal\", \n+\t\t\ttest3[i], test2[i-6],0.0);\n+\t\t\t//System.out.println(test3[i] + \" \"+test2[i-6]);\n+\t\t}    \n+\t\t\n+\t\tfor(int i = 0; i < test2.length; i++){\n+\t\t\tstats.addValue(test2[i]);\n+\t\t}     \n+ \n+\t\ttest3 = stats.getValues();  \n+\t\t\n+\t\tfor(int i = 0; i < 6; i++){\n+\t\t\tassertEquals( \"Added value [\"+i+\"] not equal\", \n+\t\t\ttest3[i], test2[i],0.0);\n+\t\t\t//System.out.println(test3[i] + \" \"+test2[i]);\n+\t\t}  \n+\t\t\n+\t\tfor(int i = 6; i < 12; i++){\n+\t\t\tassertEquals( \"Added value [\"+i+\"] not equal\", \n+\t\t\ttest3[i], test2[i-6],0.0);\n+\t\t\t//System.out.println(test3[i] + \" \"+test2[i-6]);\n+\t\t}  \n+\t\t \n+\t}\n+\t\n+    public void testGetSortedValues() {\n+        double[] test1 = {5,4,3,2,1};\n+        double[] test2 = {5,2,1,3,4,0};\n+        double[] test3 = {1};\n+        int[] testi = null;\n+        double[] test4 = null;\n+        RandomData rd = new RandomDataImpl();\n+        tstGetSortedValues(test1);\n+        tstGetSortedValues(test2);\n+        tstGetSortedValues(test3);\n+        for (int i = 0; i < 10; i++) {\n+            testi = rd.nextPermutation(10,6);\n+            test4 = new double[6];\n+            for (int j = 0; j < testi.length; j++) {\n+                test4[j] = (double) testi[j];\n+            }\n+            tstGetSortedValues(test4);\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            testi = rd.nextPermutation(10,5);\n+            test4 = new double[5];\n+            for (int j = 0; j < testi.length; j++) {\n+                test4[j] = (double) testi[j];\n+            }\n+            tstGetSortedValues(test4);\n+        }        \n+    }\n+    \n+        \n+        \n+    private void tstGetSortedValues(double[] test) {\n+        DescriptiveStatistics u = DescriptiveStatistics.newInstance();\n+        u.setWindowSize(test.length);\n+        for (int i = 0; i < test.length; i++) {\n+            u.addValue(test[i]);\n+        }\n+        double[] sorted = u.getSortedValues();\n+        if (sorted.length != test.length) {\n+            fail(\"wrong length for sorted values array\");\n+        }\n+        for (int i = 0; i < sorted.length-1; i++) {\n+            if (sorted[i] > sorted[i+1]) {\n+                fail(\"sorted values out of sequence\");\n+            }\n+        }\n+    }\n+    \n+    public void testPercentiles() {\n+        double[] test = {5,4,3,2,1};\n+        DescriptiveStatistics u = DescriptiveStatistics.newInstance();\n+        u.setWindowSize(110);\n+        for (int i = 0; i < test.length; i++) {\n+            u.addValue(test[i]);\n+        }\n+        assertEquals(\"expecting min\",1,u.getPercentile(5),10E-12);\n+        assertEquals(\"expecting max\",5,u.getPercentile(99),10E-12);\n+        assertEquals(\"expecting middle\",3,u.getPercentile(50),10E-12);\n+        try {\n+            double x = u.getPercentile(0);\n+            fail(\"expecting IllegalArgumentException for getPercentile(0)\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        try {\n+            double x = u.getPercentile(120);\n+            fail(\"expecting IllegalArgumentException for getPercentile(120)\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }\n+        \n+        u.clear();\n+        double[] test2 = {1,2,3,4};\n+        for (int i = 0; i < test2.length; i++) {\n+            u.addValue(test2[i]);\n+        }\n+        assertEquals(\"Q1\",1.25,u.getPercentile(25),10E-12);\n+        assertEquals(\"Q3\",3.75,u.getPercentile(75),10E-12);\n+        assertEquals(\"Q2\",2.5,u.getPercentile(50),10E-12);\n+        \n+        u.clear();\n+        double[] test3 = {1};\n+        for (int i = 0; i < test3.length; i++) {\n+            u.addValue(test3[i]);\n+        }\n+        assertEquals(\"Q1\",1,u.getPercentile(25),10E-12);\n+        assertEquals(\"Q3\",1,u.getPercentile(75),10E-12);\n+        assertEquals(\"Q2\",1,u.getPercentile(50),10E-12);\n+        \n+        u.clear();\n+        RandomData rd = new RandomDataImpl();\n+        int[] testi = rd.nextPermutation(100,100); // will contain 0-99\n+        for (int j = 0; j < testi.length; j++) {\n+            u.addValue((double) testi[j]);  //OK, laugh at me for the cast\n+        }\n+        for (int i = 1; i < 100; i++) {\n+            assertEquals(\"percentile \" + i,\n+                (double) i-1 + (double) i*(.01), u.getPercentile(i),10E-12);\n+        }\n+        \n+        u.clear();\n+        double[] test4 = {1,2,3,4,100};\n+        for (int i = 0; i < test4.length; i++) {\n+            u.addValue(test4[i]);\n+        }\n+        assertEquals(\"80th\",80.8,u.getPercentile(80),10E-12);\n+        \n+        u.clear();\n+        assertTrue(\"empty value set should return NaN\",\n+            Double.isNaN(u.getPercentile(50)));\n+    }\n+                      \n+    /** test stats */\n+    public void testSerialization() {\n+        DescriptiveStatistics u = DescriptiveStatistics.newInstance(); \n+        assertEquals(\"total count\",0,u.getN(),tolerance);\n+        u.addValue(one);\n+        u.addValue(two);\n+        \n+        DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u); \n+ \n+        u2.addValue(two);\n+        u2.addValue(three);\n+        \n+        assertEquals(\"N\",n,u2.getN(),tolerance);\n+        assertEquals(\"sum\",sum,u2.getSum(),tolerance);\n+        assertEquals(\"sumsq\",sumSq,u2.getSumsq(),tolerance);\n+        assertEquals(\"var\",var,u2.getVariance(),tolerance);\n+        assertEquals(\"std\",std,u2.getStandardDeviation(),tolerance);\n+        assertEquals(\"mean\",mean,u2.getMean(),tolerance);\n+        assertEquals(\"min\",min,u2.getMin(),tolerance);\n+        assertEquals(\"max\",max,u2.getMax(),tolerance);\n+\n+        u2.clear();\n+        assertEquals(\"total count\",0,u2.getN(),tolerance);    \n+    }       \n+\n+    public void testNewInstanceClassNull() {\n+        try {\n+            DescriptiveStatistics u = DescriptiveStatistics.newInstance((Class)null);\n+            fail(\"null is not a valid descriptive statistics class\");\n+        } catch (NullPointerException ex) {\n+            // success\n+        } catch (Exception ex) {\n+            fail();\n+        }\n+        \n+    }\n+    \n+    public void testNewInstanceClassValid() {\n+        try {\n+            DescriptiveStatistics u = DescriptiveStatistics.newInstance(\n+                DescriptiveStatisticsImpl.class);\n+            assertNotNull(u);\n+            assertTrue(u instanceof DescriptiveStatisticsImpl);\n+        } catch (Exception ex) {\n+            fail();\n+        }\n+    }\n+    \n+    public void testWindowSize() {\n+        DescriptiveStatistics u = DescriptiveStatistics.newInstance();\n+        u.setWindowSize(1234);\n+        assertEquals(1234, u.getWindowSize());\n+        \n+        u.addValue(1.0);\n+        u.addValue(2.0);\n+        u.addValue(3.0);\n+        u.addValue(4.0);\n+        u.addValue(5.0);\n+        assertEquals(5, u.getN());\n+        \n+        u.setWindowSize(DescriptiveStatistics.INFINITE_WINDOW);\n+        assertEquals(5, u.getN());\n+    }\n+    \n+    public void testWindowing() {\n+        DescriptiveStatistics u = DescriptiveStatistics.newInstance();\n+        u.setWindowSize(2);\n+        \n+        u.addValue(1.0);\n+        assertEquals(1.0, u.getMean(), tolerance);\n+        \n+        u.addValue(2.0);\n+        assertEquals(1.5, u.getMean(), tolerance);\n+        \n+        u.addValue(3.0);\n+        assertEquals(2.5, u.getMean(), tolerance);\n+        \n+        u.setWindowSize(1);\n+        assertEquals(3.0, u.getMean(), tolerance);\n+    }\n+    \n+    public void testToString() {\n+        DescriptiveStatistics u = DescriptiveStatistics.newInstance();\n+        assertTrue(u.toString().indexOf(\"NaN\") > 0);  \n+        assertTrue(u.toString().startsWith(\"DescriptiveStatistics\"));\n+        double[] testArray = \n+            { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,\n+                9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };\n+        for( int i = 0; i < testArray.length; i++) {\n+            u.addValue( testArray[i]);\n+        }        \n+        assertTrue(u.toString().indexOf(\"NaN\") == -1);  \n+        assertTrue(u.toString().startsWith(\"DescriptiveStatistics\"));\n+    }\n+    \n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/InteractionTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import org.apache.commons.math.stat.descriptive.moment.FourthMoment;\n+import org.apache.commons.math.stat.descriptive.moment.Kurtosis;\n+import org.apache.commons.math.stat.descriptive.moment.Mean;\n+import org.apache.commons.math.stat.descriptive.moment.Skewness;\n+import org.apache.commons.math.stat.descriptive.moment.Variance;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:19 $\n+ */\n+public class InteractionTest extends TestCase {\n+\n+    protected double mean = 12.40454545454550;\n+    protected double var = 10.00235930735930;\n+    protected double skew = 1.437423729196190;\n+    protected double kurt = 2.377191264804700;\n+\n+    protected double tolerance = 10E-12;\n+\n+    protected double[] testArray =\n+        {\n+            12.5,\n+            12,\n+            11.8,\n+            14.2,\n+            14.9,\n+            14.5,\n+            21,\n+            8.2,\n+            10.3,\n+            11.3,\n+            14.1,\n+            9.9,\n+            12.2,\n+            12,\n+            12.1,\n+            11,\n+            19.8,\n+            11,\n+            10,\n+            8.8,\n+            9,\n+            12.3 };\n+\n+    public InteractionTest(String name) {\n+        super(name);\n+    }\n+\n+\n+    public void testInteraction() {\n+        \n+        FourthMoment m4 = new FourthMoment();\n+        Mean m = new Mean(m4);\n+        Variance v = new Variance(m4);\n+        Skewness s= new Skewness(m4);\n+        Kurtosis k = new Kurtosis(m4);\n+\n+        for (int i = 0; i < testArray.length; i++){\n+            m4.increment(testArray[i]);\n+        }\n+        \n+        assertEquals(mean,m.getResult(),tolerance);\n+        assertEquals(var,v.getResult(),tolerance);\n+        assertEquals(skew ,s.getResult(),tolerance);\n+        assertEquals(kurt,k.getResult(),tolerance);\n+\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImpl.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.MathException;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.DescriptiveStatistics;\n+import org.apache.commons.math.util.DefaultTransformer;\n+import org.apache.commons.math.util.NumberTransformer;\n+\n+/**\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:19 $\n+ */\n+public class ListUnivariateImpl extends DescriptiveStatistics implements Serializable {\n+\n+    /** Serializable version identifier */\n+    static final long serialVersionUID = -8837442489133392138L;\n+    \n+    /**\n+     * Holds a reference to a list - GENERICs are going to make\n+     * out lives easier here as we could only accept List<Number>\n+     */\n+    protected List list;\n+\n+    /** Number Transformer maps Objects to Number for us. */\n+    protected NumberTransformer transformer;\n+    \n+    /** hold the window size **/\n+    protected int windowSize = DescriptiveStatistics.INFINITE_WINDOW;\n+\n+\t/**\n+\t * No argument Constructor\n+\t */\n+\tpublic ListUnivariateImpl(){\n+\t    this(new ArrayList());\n+\t}\n+\t\n+    /**\n+     * Construct a ListUnivariate with a specific List.\n+     * @param list The list that will back this DescriptiveStatistics\n+     */\n+    public ListUnivariateImpl(List list) {\n+        this(list, new DefaultTransformer());\n+    }\n+    \n+    /**\n+     * Construct a ListUnivariate with a specific List.\n+     * @param list The list that will back this DescriptiveStatistics\n+     * @param transformer the number transformer used to convert the list items.\n+     */\n+    public ListUnivariateImpl(List list, NumberTransformer transformer) {\n+        super();\n+        this.list = list;\n+        this.transformer = transformer;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getValues()\n+     */\n+    public double[] getValues() {\n+\n+        int length = list.size();\n+\n+        // If the window size is not INFINITE_WINDOW AND\n+        // the current list is larger that the window size, we need to\n+        // take into account only the last n elements of the list\n+        // as definied by windowSize\n+\n+        if (windowSize != DescriptiveStatistics.INFINITE_WINDOW &&\n+            windowSize < list.size())\n+        {\n+            length = list.size() - Math.max(0, list.size() - windowSize);\n+        }\n+\n+        // Create an array to hold all values\n+        double[] copiedArray = new double[length];\n+\n+        for (int i = 0; i < copiedArray.length; i++) {\n+            copiedArray[i] = getElement(i);\n+        }\n+        return copiedArray;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getElement(int)\n+     */\n+    public double getElement(int index) {\n+\n+        double value = Double.NaN;\n+\n+        int calcIndex = index;\n+\n+        if (windowSize != DescriptiveStatistics.INFINITE_WINDOW &&\n+            windowSize < list.size())\n+        {\n+            calcIndex = (list.size() - windowSize) + index;\n+        }\n+\n+        \n+        try {\n+\t\t\tvalue = transformer.transform(list.get(calcIndex));\n+\t\t} catch (MathException e) {\n+\t\t\te.printStackTrace();\n+\t\t}\n+        \n+        return value;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getN()\n+     */\n+    public long getN() {\n+        int n = 0;\n+\n+        if (windowSize != DescriptiveStatistics.INFINITE_WINDOW) {\n+            if (list.size() > windowSize) {\n+                n = windowSize;\n+            } else {\n+                n = list.size();\n+            }\n+        } else {\n+            n = list.size();\n+        }\n+        return n;\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#addValue(double)\n+     */\n+    public void addValue(double v) {\n+        list.add(new Double(v));\n+    }\n+    \n+    /**\n+     * Adds an object to this list. \n+     * @param o Object to add to the list\n+     */\n+    public void addObject(Object o) {\n+        list.add(o);\n+    }\n+\n+    /**\n+     * Clears all statistics.\n+     * <p>\n+     * <strong>N.B.: </strong> This method has the side effect of clearing the underlying list.\n+     */\n+    public void clear() {\n+        list.clear();\n+    }\n+    \n+    /**\n+     * Apply the given statistic to this univariate collection.\n+     * @param stat the statistic to apply\n+     * @return the computed value of the statistic.\n+     */\n+    public double apply(UnivariateStatistic stat) {\n+        double[] v = this.getValues();\n+\n+        if (v != null) {\n+            return stat.evaluate(v, 0, v.length);\n+        }\n+        return Double.NaN;\n+    }\n+    \n+    /**\n+     * Access the number transformer.\n+     * @return the number transformer.\n+     */\n+    public NumberTransformer getTransformer() {\n+        return transformer;\n+    }\n+\n+    /**\n+     * Modify the number transformer.\n+     * @param transformer the new number transformer.\n+     */\n+    public void setTransformer(NumberTransformer transformer) {\n+        this.transformer = transformer;\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#setWindowSize(int)\n+     */\n+    public synchronized void setWindowSize(int windowSize) {\n+    \tthis.windowSize = windowSize;\n+    \t//Discard elements from the front of the list if the windowSize is less than \n+    \t// the size of the list.\n+    \tint extra = list.size() - windowSize;\n+    \tfor (int i = 0; i < extra; i++) {\n+    \t\tlist.remove(0);\n+    \t}\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.DescriptiveStatistics#getWindowSize\n+     */\n+    public int getWindowSize() {\n+    \treturn windowSize;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/ListUnivariateImplTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.TestUtils;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link Univariate} class.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:19 $\n+ */\n+\n+public final class ListUnivariateImplTest extends TestCase {\n+    \n+    private double one = 1;\n+    private float two = 2;\n+    private int three = 3;\n+\n+    private double mean = 2;\n+    private double sumSq = 18;\n+    private double sum = 8;\n+    private double var = 0.666666666666666666667;\n+    private double std = Math.sqrt(var);\n+    private double n = 4;\n+    private double min = 1;\n+    private double max = 3;\n+    private double skewness = 0;\n+    private double kurtosis = 0.5;\n+    private double tolerance = 10E-15;\n+    \n+    public ListUnivariateImplTest(String name) {\n+        super(name);\n+    }\n+    \n+    public void setUp() {  \n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ListUnivariateImplTest.class);\n+        suite.setName(\"Frequency Tests\");\n+        return suite;\n+    }\n+    \n+    /** test stats */\n+    public void testStats() {\n+    \tList externalList = new ArrayList();\n+    \t\n+        DescriptiveStatistics u = new ListUnivariateImpl( externalList ); \n+\n+        assertEquals(\"total count\",0,u.getN(),tolerance);\n+        u.addValue(one);\n+        u.addValue(two);\n+        u.addValue(two);\n+        u.addValue(three);\n+        assertEquals(\"N\",n,u.getN(),tolerance);\n+        assertEquals(\"sum\",sum,u.getSum(),tolerance);\n+        assertEquals(\"sumsq\",sumSq,u.getSumsq(),tolerance);\n+        assertEquals(\"var\",var,u.getVariance(),tolerance);\n+        assertEquals(\"std\",std,u.getStandardDeviation(),tolerance);\n+        assertEquals(\"mean\",mean,u.getMean(),tolerance);\n+        assertEquals(\"min\",min,u.getMin(),tolerance);\n+        assertEquals(\"max\",max,u.getMax(),tolerance);\n+        u.clear();\n+        assertEquals(\"total count\",0,u.getN(),tolerance);    \n+    }     \n+    \n+    public void testN0andN1Conditions() throws Exception {\n+    \tList list = new ArrayList();\n+    \t\n+    \tDescriptiveStatistics u = new ListUnivariateImpl( list );\n+    \t    \t\n+\t\tassertTrue(\"Mean of n = 0 set should be NaN\", Double.isNaN( u.getMean() ) );\n+\t\tassertTrue(\"Standard Deviation of n = 0 set should be NaN\", Double.isNaN( u.getStandardDeviation() ) );\n+\t\tassertTrue(\"Variance of n = 0 set should be NaN\", Double.isNaN(u.getVariance() ) );\n+\n+\t\tlist.add( new Double(one));\n+\n+\t\tassertTrue( \"Mean of n = 1 set should be value of single item n1\", u.getMean() == one);\n+\t\tassertTrue( \"StdDev of n = 1 set should be zero, instead it is: \" + u.getStandardDeviation(), u.getStandardDeviation() == 0);\n+\t\tassertTrue( \"Variance of n = 1 set should be zero\", u.getVariance() == 0);\t\n+    }\n+    \n+    public void testSkewAndKurtosis() {\n+    \tDescriptiveStatistics u = DescriptiveStatistics.newInstance();\n+    \t\n+    \tdouble[] testArray = { 12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3, 14.1,\n+  \t  \t\t\t\t\t\t\t\t\t\t 9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10, 8.8, 9, 12.3 };\n+  \t  \tfor( int i = 0; i < testArray.length; i++) {\n+  \t  \t\tu.addValue( testArray[i]);\n+  \t  \t}\n+  \t  \t\n+\t\tassertEquals(\"mean\", 12.40455, u.getMean(), 0.0001);\n+\t\tassertEquals(\"variance\", 10.00236, u.getVariance(), 0.0001);\n+\t\tassertEquals(\"skewness\", 1.437424, u.getSkewness(), 0.0001);\n+  \t  \tassertEquals(\"kurtosis\", 2.37719, u.getKurtosis(), 0.0001);\n+    }\n+\n+    public void testProductAndGeometricMean() throws Exception {\n+    \tListUnivariateImpl u = new ListUnivariateImpl(new ArrayList());\n+        u.setWindowSize(10);\n+    \t    \t\n+        u.addValue( 1.0 );\n+        u.addValue( 2.0 );\n+        u.addValue( 3.0 );\n+        u.addValue( 4.0 );\n+\n+        assertEquals( \"Geometric mean not expected\", 2.213364, u.getGeometricMean(), 0.00001 );\n+\n+        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution\n+        // of a discarded element\n+        for( int i = 0; i < 10; i++ ) {\n+            u.addValue( i + 2 );\n+        }\n+        // Values should be (2,3,4,5,6,7,8,9,10,11)\n+        \n+        assertEquals( \"Geometric mean not expected\", 5.755931, u.getGeometricMean(), 0.00001 );\n+\n+\n+    }\n+    \n+    /** test stats */\n+    public void testSerialization() {\n+        \n+        DescriptiveStatistics u = null;\n+        \n+        try {\n+            u = DescriptiveStatistics.newInstance(ListUnivariateImpl.class);\n+        } catch (InstantiationException e) {\n+            fail(e.getMessage());\n+        } catch (IllegalAccessException e) {\n+            fail(e.getMessage());\n+        }\n+        \n+        assertEquals(\"total count\",0,u.getN(),tolerance);\n+        u.addValue(one);\n+        u.addValue(two);\n+        \n+        DescriptiveStatistics u2 = (DescriptiveStatistics)TestUtils.serializeAndRecover(u); \n+ \n+        u2.addValue(two);\n+        u2.addValue(three);\n+        \n+        assertEquals(\"N\",n,u2.getN(),tolerance);\n+        assertEquals(\"sum\",sum,u2.getSum(),tolerance);\n+        assertEquals(\"sumsq\",sumSq,u2.getSumsq(),tolerance);\n+        assertEquals(\"var\",var,u2.getVariance(),tolerance);\n+        assertEquals(\"std\",std,u2.getStandardDeviation(),tolerance);\n+        assertEquals(\"mean\",mean,u2.getMean(),tolerance);\n+        assertEquals(\"min\",min,u2.getMin(),tolerance);\n+        assertEquals(\"max\",max,u2.getMax(),tolerance);\n+\n+        u2.clear();\n+        assertEquals(\"total count\",0,u2.getN(),tolerance);    \n+    }       \n+}\n+\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/MixedListUnivariateImplTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.apache.commons.math.util.NumberTransformer;\n+import org.apache.commons.math.util.TransformerMap;\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+/**\n+ * Test cases for the {@link Univariate} class.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:19 $\n+ */\n+\n+public final class MixedListUnivariateImplTest extends TestCase {\n+    private double one = 1;\n+    private float two = 2;\n+    private int three = 3;\n+\n+    private double mean = 2;\n+    private double sumSq = 18;\n+    private double sum = 8;\n+    private double var = 0.666666666666666666667;\n+    private double std = Math.sqrt(var);\n+    private double n = 4;\n+    private double min = 1;\n+    private double max = 3;\n+    private double skewness = 0;\n+    private double kurtosis = 0.5;\n+    private double tolerance = 10E-15;\n+\n+    private TransformerMap transformers = new TransformerMap();\n+    \n+    public MixedListUnivariateImplTest(String name) {\n+        super(name);\n+        transformers = new TransformerMap();\n+\n+        transformers.putTransformer(Foo.class, new NumberTransformer() {\n+            public double transform(Object o) {\n+                return Double.parseDouble(((Foo) o).heresFoo());\n+            }\n+        });\n+\n+        transformers.putTransformer(Bar.class, new NumberTransformer() {\n+            public double transform(Object o) {\n+                return Double.parseDouble(((Bar) o).heresBar());\n+            }\n+\n+        });\n+\n+    }\n+\n+    public void setUp() {\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MixedListUnivariateImplTest.class);\n+        suite.setName(\"Mixed List Tests\");\n+        return suite;\n+    }\n+\n+    /** test stats */\n+    public void testStats() {\n+        List externalList = new ArrayList();\n+\n+        DescriptiveStatistics u = new ListUnivariateImpl(externalList,transformers);\n+\n+        assertEquals(\"total count\", 0, u.getN(), tolerance);\n+        u.addValue(one);\n+        u.addValue(two);\n+        u.addValue(two);\n+        u.addValue(three);\n+        assertEquals(\"N\", n, u.getN(), tolerance);\n+        assertEquals(\"sum\", sum, u.getSum(), tolerance);\n+        assertEquals(\"sumsq\", sumSq, u.getSumsq(), tolerance);\n+        assertEquals(\"var\", var, u.getVariance(), tolerance);\n+        assertEquals(\"std\", std, u.getStandardDeviation(), tolerance);\n+        assertEquals(\"mean\", mean, u.getMean(), tolerance);\n+        assertEquals(\"min\", min, u.getMin(), tolerance);\n+        assertEquals(\"max\", max, u.getMax(), tolerance);\n+        u.clear();\n+        assertEquals(\"total count\", 0, u.getN(), tolerance);\n+    }\n+\n+    public void testN0andN1Conditions() throws Exception {\n+        List list = new ArrayList();\n+\n+        DescriptiveStatistics u = new ListUnivariateImpl(new ArrayList(),transformers);\n+\n+        assertTrue(\n+            \"Mean of n = 0 set should be NaN\",\n+            Double.isNaN(u.getMean()));\n+        assertTrue(\n+            \"Standard Deviation of n = 0 set should be NaN\",\n+            Double.isNaN(u.getStandardDeviation()));\n+        assertTrue(\n+            \"Variance of n = 0 set should be NaN\",\n+            Double.isNaN(u.getVariance()));\n+\n+        u.addValue(one);\n+\n+        assertTrue(\n+            \"Mean of n = 1 set should be value of single item n1, instead it is \" + u.getMean() ,\n+            u.getMean() == one);\n+            \n+        assertTrue(\n+            \"StdDev of n = 1 set should be zero, instead it is: \"\n+                + u.getStandardDeviation(),\n+            u.getStandardDeviation() == 0);\n+        assertTrue(\n+            \"Variance of n = 1 set should be zero\",\n+            u.getVariance() == 0);\n+    }\n+\n+    public void testSkewAndKurtosis() {\n+        ListUnivariateImpl u =\n+            new ListUnivariateImpl(new ArrayList(), transformers);\n+\n+        u.addObject(\"12.5\");\n+        u.addObject(new Integer(12));\n+        u.addObject(\"11.8\");\n+        u.addObject(\"14.2\");\n+        u.addObject(new Foo());\n+        u.addObject(\"14.5\");\n+        u.addObject(new Long(21));\n+        u.addObject(\"8.2\");\n+        u.addObject(\"10.3\");\n+        u.addObject(\"11.3\");\n+        u.addObject(new Float(14.1));\n+        u.addObject(\"9.9\");\n+        u.addObject(\"12.2\");\n+        u.addObject(new Bar());\n+        u.addObject(\"12.1\");\n+        u.addObject(\"11\");\n+        u.addObject(new Double(19.8));\n+        u.addObject(\"11\");\n+        u.addObject(\"10\");\n+        u.addObject(\"8.8\");\n+        u.addObject(\"9\");\n+        u.addObject(\"12.3\");\n+\n+\n+        assertEquals(\"mean\", 12.40455, u.getMean(), 0.0001);\n+        assertEquals(\"variance\", 10.00236, u.getVariance(), 0.0001);\n+        assertEquals(\"skewness\", 1.437424, u.getSkewness(), 0.0001);\n+        assertEquals(\"kurtosis\", 2.37719, u.getKurtosis(), 0.0001);\n+    }\n+\n+    public void testProductAndGeometricMean() throws Exception {\n+        ListUnivariateImpl u = new ListUnivariateImpl(new ArrayList(),transformers);\n+        u.setWindowSize(10);\n+\n+        u.addValue(1.0);\n+        u.addValue(2.0);\n+        u.addValue(3.0);\n+        u.addValue(4.0);\n+\n+        assertEquals(\n+            \"Geometric mean not expected\",\n+            2.213364,\n+            u.getGeometricMean(),\n+            0.00001);\n+\n+        // Now test rolling - StorelessDescriptiveStatistics should discount the contribution\n+        // of a discarded element\n+        for (int i = 0; i < 10; i++) {\n+            u.addValue(i + 2);\n+        }\n+        // Values should be (2,3,4,5,6,7,8,9,10,11)\n+        assertEquals(\n+            \"Geometric mean not expected\",\n+            5.755931,\n+            u.getGeometricMean(),\n+            0.00001);\n+\n+    }\n+\n+    public final class Foo {\n+        public String heresFoo() {\n+            return \"14.9\";\n+        }\n+    }\n+\n+    public final class Bar {\n+        public String heresBar() {\n+            return \"12.0\";\n+        }\n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/StatisticalSummaryValuesTest.java\n+/*\n+ * Copyright 2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+/**\n+ * Test cases for the {@link StatisticalSummaryValues} class.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:19 $\n+ */\n+\n+public final class StatisticalSummaryValuesTest extends TestCase {\n+    \n+    \n+    public StatisticalSummaryValuesTest(String name) {\n+        super(name);\n+    }\n+    \n+    public void setUp() {  \n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StatisticalSummaryValuesTest.class);\n+        suite.setName(\"StatisticalSummaryValues Tests\");\n+        return suite;\n+    }\n+      \n+    public void testSerialization() {\n+        StatisticalSummaryValues u = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);\n+        TestUtils.checkSerializedEquality(u); \n+        StatisticalSummaryValues t = (StatisticalSummaryValues) TestUtils.serializeAndRecover(u);\n+        verifyEquality(u, t);\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        StatisticalSummaryValues u  = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);\n+        StatisticalSummaryValues t = null;\n+        int emptyHash = u.hashCode();\n+        assertTrue(\"reflexive\", u.equals(u));\n+        assertFalse(\"non-null compared to null\", u.equals(t));\n+        assertFalse(\"wrong type\", u.equals(new Double(0)));\n+        t = new StatisticalSummaryValues(1, 2, 3, 4, 5, 6);\n+        assertTrue(\"instances with same data should be equal\", t.equals(u));\n+        assertEquals(\"hash code\", u.hashCode(), t.hashCode());\n+        \n+        u = new StatisticalSummaryValues(Double.NaN, 2, 3, 4, 5, 6);\n+        t = new StatisticalSummaryValues(1, Double.NaN, 3, 4, 5, 6);\n+        assertFalse(\"instances based on different data should be different\", \n+                (u.equals(t) ||t.equals(u)));\n+    }\n+    \n+    private void verifyEquality(StatisticalSummaryValues s, StatisticalSummaryValues u) {\n+        assertEquals(\"N\",s.getN(),u.getN());\n+        TestUtils.assertEquals(\"sum\",s.getSum(),u.getSum(), 0);\n+        TestUtils.assertEquals(\"var\",s.getVariance(),u.getVariance(), 0);\n+        TestUtils.assertEquals(\"std\",s.getStandardDeviation(),u.getStandardDeviation(), 0);\n+        TestUtils.assertEquals(\"mean\",s.getMean(),u.getMean(), 0);\n+        TestUtils.assertEquals(\"min\",s.getMin(),u.getMin(), 0);\n+        TestUtils.assertEquals(\"max\",s.getMax(),u.getMax(), 0);   \n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/StorelessUnivariateStatisticAbstractTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import org.apache.commons.math.TestUtils;\n+import org.apache.commons.math.stat.descriptive.moment.SecondMoment;\n+\n+/**\n+ * Test cases for {@link StorelessUnivariateStatistic} classes.\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:19 $\n+ */\n+public abstract class StorelessUnivariateStatisticAbstractTest\n+    extends UnivariateStatisticAbstractTest {\n+\n+    public StorelessUnivariateStatisticAbstractTest(String name) {\n+        super(name);\n+    }\n+    \n+    /** Small sample arrays */\n+    protected double[][] smallSamples = {{}, {1}, {1,2}, {1,2,3}, {1,2,3,4}};\n+\n+    /** Return a new instance of the statistic */\n+    public abstract UnivariateStatistic getUnivariateStatistic();\n+\n+    /**Expected value for  the testArray defined in UnivariateStatisticAbstractTest */\n+    public abstract double expectedValue();\n+    \n+    /** Verify that calling increment() in a loop over testArray results in correct state */\n+    public void testIncrementation() throws Exception {\n+\n+        StorelessUnivariateStatistic statistic =\n+            (StorelessUnivariateStatistic) getUnivariateStatistic();\n+\n+        statistic.clear();\n+\n+        for (int i = 0; i < testArray.length; i++) {\n+            statistic.increment(testArray[i]);\n+        }\n+\n+        assertEquals(expectedValue(), statistic.getResult(), getTolerance());\n+        assertEquals(testArray.length, statistic.getN());\n+\n+        statistic.clear();\n+\n+        assertTrue(Double.isNaN(statistic.getResult()));\n+        assertEquals(0, statistic.getN());\n+\n+    }\n+\n+    public void testSerialization() throws Exception {\n+\n+        StorelessUnivariateStatistic statistic =\n+            (StorelessUnivariateStatistic) getUnivariateStatistic();\n+        \n+        TestUtils.checkSerializedEquality(statistic);\n+\n+        statistic.clear();\n+\n+        for (int i = 0; i < testArray.length; i++) {\n+            statistic.increment(testArray[i]);\n+            if(i % 5 == 0)\n+                statistic = (StorelessUnivariateStatistic)TestUtils.serializeAndRecover(statistic); \n+        }\n+        \n+        TestUtils.checkSerializedEquality(statistic);\n+        \n+        assertEquals(expectedValue(), statistic.getResult(), getTolerance());\n+\n+        statistic.clear();\n+\n+        assertTrue(Double.isNaN(statistic.getResult()));\n+\n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        StorelessUnivariateStatistic statistic =\n+            (StorelessUnivariateStatistic) getUnivariateStatistic();\n+        StorelessUnivariateStatistic statistic2 = null;\n+        \n+        assertTrue(\"non-null, compared to null\", !statistic.equals(statistic2));\n+        assertTrue(\"reflexive, non-null\", statistic.equals(statistic));\n+        \n+        int emptyHash = statistic.hashCode();\n+        statistic2 = (StorelessUnivariateStatistic) getUnivariateStatistic();\n+        assertTrue(\"empty stats should be equal\", statistic.equals(statistic2));\n+        assertEquals(\"empty stats should have the same hashcode\", \n+                emptyHash, statistic2.hashCode());\n+        \n+        statistic.increment(1d);\n+        assertTrue(\"reflexive, non-empty\", statistic.equals(statistic));\n+        assertTrue(\"non-empty, compared to empty\", !statistic.equals(statistic2));\n+        assertTrue(\"non-empty, compared to empty\", !statistic2.equals(statistic));\n+        assertTrue(\"non-empty stat should have different hashcode from empty stat\",\n+                statistic.hashCode() != emptyHash);\n+        \n+        statistic2.increment(1d);\n+        assertTrue(\"stats with same data should be equal\", statistic.equals(statistic2));\n+        assertEquals(\"stats with same data should have the same hashcode\", \n+                statistic.hashCode(), statistic2.hashCode());\n+        \n+        statistic.increment(Double.POSITIVE_INFINITY);\n+        assertTrue(\"stats with different n's should not be equal\", !statistic2.equals(statistic));\n+        assertTrue(\"stats with different n's should have different hashcodes\",\n+                statistic.hashCode() != statistic2.hashCode());\n+        \n+        statistic2.increment(Double.POSITIVE_INFINITY);\n+        assertTrue(\"stats with same data should be equal\", statistic.equals(statistic2));\n+        assertEquals(\"stats with same data should have the same hashcode\", \n+                statistic.hashCode(), statistic2.hashCode()); \n+        \n+        statistic.clear();\n+        statistic2.clear();\n+        assertTrue(\"cleared stats should be equal\", statistic.equals(statistic2));\n+        assertEquals(\"cleared stats should have thashcode of empty stat\", \n+                emptyHash, statistic2.hashCode());\n+        assertEquals(\"cleared stats should have thashcode of empty stat\", \n+                emptyHash, statistic.hashCode());\n+        \n+    }\n+    \n+    public void testMomentSmallSamples() {\n+        UnivariateStatistic stat = getUnivariateStatistic();\n+        if (stat instanceof SecondMoment) {\n+            SecondMoment moment = (SecondMoment) getUnivariateStatistic();\n+            assertTrue(Double.isNaN(moment.getResult()));\n+            moment.increment(1d);\n+            assertEquals(0d, moment.getResult(), 0);\n+        }\n+    }\n+    \n+    /** \n+     * Make sure that evaluate(double[]) and inrementAll(double[]), \n+     * getResult() give same results.\n+     */\n+    public void testConsistency() {\n+        StorelessUnivariateStatistic stat = (StorelessUnivariateStatistic) getUnivariateStatistic();\n+        stat.incrementAll(testArray);\n+        assertEquals(stat.getResult(), stat.evaluate(testArray), getTolerance());\n+        for (int i = 0; i < smallSamples.length; i++) {\n+            stat.clear();\n+            for (int j =0; j < smallSamples[i].length; j++) {\n+                stat.increment(smallSamples[i][j]);\n+            }\n+            TestUtils.assertEquals(stat.getResult(), stat.evaluate(smallSamples[i]), getTolerance());\n+        }\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/SummaryStatisticsImplTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.TestUtils;\n+/**\n+ * Test cases for the {@link DescriptiveStatistics} class.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:19 $\n+ */\n+\n+public final class SummaryStatisticsImplTest extends TestCase {\n+    private double one = 1;\n+    private float twoF = 2;\n+    private long twoL = 2;\n+    private int three = 3;\n+    private double mean = 2;\n+    private double sumSq = 18;\n+    private double sum = 8;\n+    private double var = 0.666666666666666666667;\n+    private double std = Math.sqrt(var);\n+    private double n = 4;\n+    private double min = 1;\n+    private double max = 3;\n+    private double tolerance = 10E-15;\n+    \n+    protected SummaryStatistics u = null;\n+    \n+    public SummaryStatisticsImplTest(String name) {\n+        super(name);\n+    }\n+    \n+    public void setUp() {  \n+        u = SummaryStatistics.newInstance();\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SummaryStatisticsImplTest.class);\n+        suite.setName(\"Frequency Tests\");\n+        return suite;\n+    }\n+    \n+    /** test stats */\n+    public void testStats() {\n+        assertEquals(\"total count\",0,u.getN(),tolerance);\n+        u.addValue(one);\n+        u.addValue(twoF);\n+        u.addValue(twoL);\n+        u.addValue(three);\n+        assertEquals(\"N\",n,u.getN(),tolerance);\n+        assertEquals(\"sum\",sum,u.getSum(),tolerance);\n+        assertEquals(\"sumsq\",sumSq,u.getSumsq(),tolerance);\n+        assertEquals(\"var\",var,u.getVariance(),tolerance);\n+        assertEquals(\"std\",std,u.getStandardDeviation(),tolerance);\n+        assertEquals(\"mean\",mean,u.getMean(),tolerance);\n+        assertEquals(\"min\",min,u.getMin(),tolerance);\n+        assertEquals(\"max\",max,u.getMax(),tolerance);\n+        u.clear();\n+        assertEquals(\"total count\",0,u.getN(),tolerance);    \n+    }     \n+    \n+    public void testN0andN1Conditions() throws Exception {\n+        assertTrue(\"Mean of n = 0 set should be NaN\", \n+            Double.isNaN( u.getMean() ) );\n+\t\tassertTrue(\"Standard Deviation of n = 0 set should be NaN\", \n+            Double.isNaN( u.getStandardDeviation() ) );\n+\t\tassertTrue(\"Variance of n = 0 set should be NaN\", \n+            Double.isNaN(u.getVariance() ) );\n+\t\t\n+\t\t/* n=1 */\n+\t\tu.addValue(one);\n+\t\tassertTrue(\"mean should be one (n = 1)\", \n+\t\t\tu.getMean() == one);\n+\t\tassertTrue(\"geometric should be one (n = 1) instead it is \" + u.getGeometricMean(), \n+\t\t\tu.getGeometricMean() == one);\n+\t\tassertTrue(\"Std should be zero (n = 1)\", \n+\t\t\tu.getStandardDeviation() == 0.0);\n+\t\tassertTrue(\"variance should be zero (n = 1)\", \n+\t\t\tu.getVariance() == 0.0);\n+\t\t\t\t\t\n+\t\t/* n=2 */\t\t\t\t\n+\t\tu.addValue(twoF);\n+\t\tassertTrue(\"Std should not be zero (n = 2)\", \n+\t\t\tu.getStandardDeviation() != 0.0);\n+\t\tassertTrue(\"variance should not be zero (n = 2)\", \n+\t\t\tu.getVariance() != 0.0);\n+            \n+    }\n+\n+    public void testProductAndGeometricMean() throws Exception {  \t    \t\n+        u.addValue( 1.0 );\n+        u.addValue( 2.0 );\n+        u.addValue( 3.0 );\n+        u.addValue( 4.0 );\n+\n+        assertEquals( \"Geometric mean not expected\", 2.213364, \n+            u.getGeometricMean(), 0.00001 );\n+    }\n+    \n+    public void testNaNContracts() {\n+        double nan = Double.NaN;\n+        assertTrue(\"mean not NaN\",Double.isNaN(u.getMean())); \n+        assertTrue(\"min not NaN\",Double.isNaN(u.getMin())); \n+        assertTrue(\"std dev not NaN\",Double.isNaN(u.getStandardDeviation())); \n+        assertTrue(\"var not NaN\",Double.isNaN(u.getVariance())); \n+        assertTrue(\"geom mean not NaN\",Double.isNaN(u.getGeometricMean()));\n+        \n+        u.addValue(1.0);\n+        \n+        assertEquals( \"mean not expected\", 1.0, \n+            u.getMean(), Double.MIN_VALUE);\n+        assertEquals( \"variance not expected\", 0.0, \n+            u.getVariance(), Double.MIN_VALUE);\n+        assertEquals( \"geometric mean not expected\", 1.0, \n+            u.getGeometricMean(), Double.MIN_VALUE);\n+        \n+        u.addValue(-1.0);\n+        \n+        assertTrue(\"geom mean not NaN\",Double.isNaN(u.getGeometricMean()));\n+        \n+        u.addValue(0.0);\n+        \n+        assertTrue(\"geom mean not NaN\",Double.isNaN(u.getGeometricMean()));\n+        \n+        //FiXME: test all other NaN contract specs\n+    }\n+    \n+    public void testGetSummary() {  \n+        StatisticalSummary summary = u.getSummary();\n+        verifySummary(summary);\n+        u.addValue(1d);\n+        summary = u.getSummary();\n+        verifySummary(summary);\n+        u.addValue(2d);\n+        summary = u.getSummary();\n+        verifySummary(summary);\n+        u.addValue(2d);\n+        summary = u.getSummary();\n+        verifySummary(summary);     \n+    }\n+    \n+    public void testSerialization() {\n+        // Empty test\n+        TestUtils.checkSerializedEquality(u);\n+        SummaryStatistics s = (SummaryStatistics) TestUtils.serializeAndRecover(u);\n+        StatisticalSummary summary = s.getSummary();\n+        verifySummary(summary);\n+        \n+        // Add some data\n+        u.addValue(2d);\n+        u.addValue(1d);\n+        u.addValue(3d);\n+        u.addValue(4d);\n+        u.addValue(5d);\n+        \n+        // Test again\n+        TestUtils.checkSerializedEquality(u);\n+        s = (SummaryStatistics) TestUtils.serializeAndRecover(u);\n+        summary = s.getSummary();\n+        verifySummary(summary);\n+        \n+    }\n+    \n+    public void testEqualsAndHashCode() {\n+        SummaryStatistics t = null;\n+        int emptyHash = u.hashCode();\n+        assertTrue(\"reflexive\", u.equals(u));\n+        assertFalse(\"non-null compared to null\", u.equals(t));\n+        assertFalse(\"wrong type\", u.equals(new Double(0)));\n+        t = SummaryStatistics.newInstance();\n+        assertTrue(\"empty instances should be equal\", t.equals(u));\n+        assertTrue(\"empty instances should be equal\", u.equals(t));\n+        assertEquals(\"empty hash code\", emptyHash, t.hashCode());\n+        \n+        // Add some data to u\n+        u.addValue(2d);\n+        u.addValue(1d);\n+        u.addValue(3d);\n+        u.addValue(4d);\n+        assertFalse(\"different n's should make instances not equal\", t.equals(u));\n+        assertFalse(\"different n's should make instances not equal\", u.equals(t));\n+        assertTrue(\"different n's should make hashcodes different\", \n+                u.hashCode() != t.hashCode());\n+        \n+        //Add data in different order to t, should not affect identity or hashcode\n+        t.addValue(4d);\n+        t.addValue(2d);\n+        t.addValue(3d);\n+        t.addValue(1d);\n+        assertTrue(\"summaries based on same data should be equal\", t.equals(u));\n+        assertTrue(\"summaries based on same data should be equal\", u.equals(t));\n+        assertEquals(\"summaries based on same data should have same hashcodes\", \n+                u.hashCode(), t.hashCode());   \n+        \n+        // Clear and make sure summaries are indistinguishable from empty summary\n+        u.clear();\n+        t.clear();\n+        assertTrue(\"empty instances should be equal\", t.equals(u));\n+        assertTrue(\"empty instances should be equal\", u.equals(t));\n+        assertEquals(\"empty hash code\", emptyHash, t.hashCode());\n+        assertEquals(\"empty hash code\", emptyHash, u.hashCode());\n+    }\n+    \n+    private void verifySummary(StatisticalSummary s) {\n+        assertEquals(\"N\",s.getN(),u.getN());\n+        TestUtils.assertEquals(\"sum\",s.getSum(),u.getSum(),tolerance);\n+        TestUtils.assertEquals(\"var\",s.getVariance(),u.getVariance(),tolerance);\n+        TestUtils.assertEquals(\"std\",s.getStandardDeviation(),u.getStandardDeviation(),tolerance);\n+        TestUtils.assertEquals(\"mean\",s.getMean(),u.getMean(),tolerance);\n+        TestUtils.assertEquals(\"min\",s.getMin(),u.getMin(),tolerance);\n+        TestUtils.assertEquals(\"max\",s.getMax(),u.getMax(),tolerance);   \n+    }\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/UnivariateStatisticAbstractTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive;\n+\n+import junit.framework.TestCase;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:19 $\n+ */\n+public abstract class UnivariateStatisticAbstractTest extends TestCase {\n+\n+    protected double mean = 12.404545454545455d;\n+    protected double geoMean = 12.070589161633011d;\n+\n+    protected double var = 10.00235930735931d;\n+    protected double std = Math.sqrt(var);\n+    protected double skew = 1.437423729196190d;\n+    protected double kurt = 2.377191264804700d;\n+\n+    protected double min = 8.2d;\n+    protected double max = 21d;\n+    protected double median = 12d;\n+    protected double percentile5 = 8.29d;\n+    protected double percentile95 = 20.82d;\n+\n+    protected double product = 628096400563833396009676.9200400128d;\n+    protected double sumLog = 54.7969806116451507d;\n+    protected double sumSq = 3595.250d;\n+    protected double sum = 272.90d;\n+    protected double secondMoment = 210.04954545454547d;\n+    protected double thirdMoment = 868.0906859504136;\n+    protected double fourthMoment = 9244.080993773481;\n+\n+    protected double tolerance = 10E-12;\n+\n+    protected double[] testArray =\n+        {12.5, 12, 11.8, 14.2, 14.9, 14.5, 21, 8.2, 10.3, 11.3,\n+          14.1, 9.9, 12.2, 12, 12.1, 11, 19.8, 11, 10,  8.8,\n+           9, 12.3 };\n+\n+    public UnivariateStatisticAbstractTest(String name) {\n+        super(name);\n+    }\n+\n+    public abstract UnivariateStatistic getUnivariateStatistic();\n+\n+    public abstract double expectedValue();\n+\n+    public double getTolerance() {\n+        return tolerance;\n+    }\n+\n+    public void testEvaluation() throws Exception {   \n+        assertEquals(\n+            expectedValue(),\n+            getUnivariateStatistic().evaluate(testArray),\n+            getTolerance());\n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/FirstMomentTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link FirstMoment} class.\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ */\n+public class FirstMomentTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    /** descriptive statistic. */\n+    protected FirstMoment stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public FirstMomentTest(String name) {\n+        super(name);\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new FirstMoment();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    public double expectedValue() {\n+        return this.mean;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/FourthMomentTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link FourthMoment} class.\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ */\n+public class FourthMomentTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    /** descriptive statistic. */\n+    protected FourthMoment stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public FourthMomentTest(String name) {\n+        super(name);\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new FourthMoment();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    public double expectedValue() {\n+       return this.fourthMoment;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/GeometricMeanTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ */\n+public class GeometricMeanTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected GeometricMean stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public GeometricMeanTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(GeometricMeanTest.class);\n+        suite.setName(\"Mean  Tests\");\n+        return suite;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new GeometricMean();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    public double expectedValue() {\n+        return this.geoMean;\n+    }\n+    \n+    public void testSpecialValues() {\n+        GeometricMean mean = new GeometricMean();\n+        // empty\n+        assertTrue(Double.isNaN(mean.getResult()));\n+        \n+        // finite data\n+        mean.increment(1d);\n+        assertFalse(Double.isNaN(mean.getResult()));\n+        \n+        // add 0 -- makes log sum blow to minus infinity, should make 0\n+        mean.increment(0d);\n+        assertEquals(0d, mean.getResult(), 0);\n+        \n+        // add positive infinity - note the minus infinity above\n+        mean.increment(Double.POSITIVE_INFINITY);\n+        assertTrue(Double.isNaN(mean.getResult()));\n+        \n+        // clear\n+        mean.clear();\n+        assertTrue(Double.isNaN(mean.getResult()));\n+        \n+        // positive infinity by itself\n+        mean.increment(Double.POSITIVE_INFINITY);\n+        assertEquals(Double.POSITIVE_INFINITY, mean.getResult(), 0);\n+        \n+        // negative value -- should make NaN\n+        mean.increment(-2d);\n+        assertTrue(Double.isNaN(mean.getResult()));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/KurtosisTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ */\n+public class KurtosisTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected Kurtosis stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public KurtosisTest(String name) {\n+        super(name);\n+    }\n+    \n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(KurtosisTest.class);\n+        suite.setName(\"Kurtosis  Tests\");\n+        return suite;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new Kurtosis();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    public double expectedValue() {\n+        return this.kurt;\n+    }\n+    \n+    /**\n+     * Make sure Double.NaN is returned iff n < 4\n+     *\n+     */\n+    public void testNaN() {\n+        Kurtosis kurt = new Kurtosis();\n+        assertTrue(Double.isNaN(kurt.getResult()));\n+        kurt.increment(1d);\n+        assertTrue(Double.isNaN(kurt.getResult()));\n+        kurt.increment(1d);\n+        assertTrue(Double.isNaN(kurt.getResult()));\n+        kurt.increment(1d);\n+        assertTrue(Double.isNaN(kurt.getResult()));\n+        kurt.increment(1d);\n+        assertFalse(Double.isNaN(kurt.getResult()));      \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/MeanTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ */\n+public class MeanTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected Mean stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public MeanTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MeanTest.class);\n+        suite.setName(\"Mean  Tests\");\n+        return suite;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new Mean();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    public double expectedValue() {\n+        return this.mean;\n+    }\n+    \n+    public void testSmallSamples() {\n+        Mean mean = new Mean();\n+        assertTrue(Double.isNaN(mean.getResult()));\n+        mean.increment(1d);\n+        assertEquals(1d, mean.getResult(), 0);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/SecondMomentTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link SecondMoment} class.\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ */\n+public class SecondMomentTest extends StorelessUnivariateStatisticAbstractTest {\n+\n+    /** descriptive statistic. */\n+    protected SecondMoment stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public SecondMomentTest(String name) {\n+        super(name);\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new SecondMoment();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    public double expectedValue() {\n+        return this.secondMoment;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/SkewnessTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ */\n+public class SkewnessTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected Skewness stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public SkewnessTest(String name) {\n+        super(name);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new Skewness();\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SkewnessTest.class);\n+        suite.setName(\"Skewness Tests\");\n+        return suite;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    public double expectedValue() {\n+        return this.skew;\n+    }\n+    \n+    /**\n+     * Make sure Double.NaN is returned iff n < 3\n+     *\n+     */\n+    public void testNaN() {\n+        Skewness skew = new Skewness();\n+        assertTrue(Double.isNaN(skew.getResult()));\n+        skew.increment(1d);\n+        assertTrue(Double.isNaN(skew.getResult()));\n+        skew.increment(1d);\n+        assertTrue(Double.isNaN(skew.getResult()));\n+        skew.increment(1d);\n+        assertFalse(Double.isNaN(skew.getResult()));      \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/StandardDeviationTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ */\n+public class StandardDeviationTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected StandardDeviation stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public StandardDeviationTest(String name) {\n+        super(name);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new StandardDeviation();\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(StandardDeviationTest.class);\n+        suite.setName(\"StandardDeviation Tests\");\n+        return suite;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    public double expectedValue() {\n+        return this.std;\n+    }\n+    \n+    /**\n+     * Make sure Double.NaN is returned iff n = 0\n+     *\n+     */\n+    public void testNaN() {\n+        StandardDeviation std = new StandardDeviation();\n+        assertTrue(Double.isNaN(std.getResult()));\n+        std.increment(1d);\n+        assertEquals(0d, std.getResult(), 0);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/ThirdMomentTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link ThirdMoment} class.\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ */\n+public class ThirdMomentTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    /** descriptive statistic. */\n+    protected ThirdMoment stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public ThirdMomentTest(String name) {\n+        super(name);\n+    }\n+    \n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new ThirdMoment();\n+    }\n+\n+    /**\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    public double expectedValue() {\n+      return this.thirdMoment;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/moment/VarianceTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.moment;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ */\n+public class VarianceTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected Variance stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public VarianceTest(String name) {\n+        super(name);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new Variance();\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(VarianceTest.class);\n+        suite.setName(\"Variance Tests\");\n+        return suite;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    public double expectedValue() {\n+        return this.var;\n+    }\n+    \n+    /**\n+     * Make sure Double.NaN is returned iff n = 0\n+     *\n+     */\n+    public void testNaN() {\n+        StandardDeviation std = new StandardDeviation();\n+        assertTrue(Double.isNaN(std.getResult()));\n+        std.increment(1d);\n+        assertEquals(0d, std.getResult(), 0);\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/rank/MaxTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.rank;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ */\n+public class MaxTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected Max stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public MaxTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MaxTest.class);\n+        suite.setName(\"Max  Tests\");\n+        return suite;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new Max();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    public double expectedValue() {\n+        return this.max;\n+    }\n+    \n+    public void testSpecialValues() {\n+        double[] testArray = {0d, Double.NaN, Double.NEGATIVE_INFINITY, \n+                Double.POSITIVE_INFINITY};\n+        Max max = new Max();\n+        assertTrue(Double.isNaN(max.getResult()));\n+        max.increment(testArray[0]);\n+        assertEquals(0d, max.getResult(), 0);\n+        max.increment(testArray[1]);\n+        assertEquals(0d, max.getResult(), 0);\n+        max.increment(testArray[2]);\n+        assertEquals(0d, max.getResult(), 0);\n+        max.increment(testArray[3]);\n+        assertEquals(Double.POSITIVE_INFINITY, max.getResult(), 0);\n+        assertEquals(Double.POSITIVE_INFINITY, max.evaluate(testArray), 0);     \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/rank/MedianTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.rank;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ */\n+public class MedianTest extends UnivariateStatisticAbstractTest{\n+\n+    protected Median stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public MedianTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MedianTest.class);\n+        suite.setName(\"Median  Tests\");\n+        return suite;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    public UnivariateStatistic getUnivariateStatistic() {  \n+        return new Median();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    public double expectedValue() {\n+        return this.median;\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/rank/MinTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.rank;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ */\n+public class MinTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected Min stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public MinTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(MinTest.class);\n+        suite.setName(\"Min  Tests\");\n+        return suite;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new Min();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    public double expectedValue() {\n+        return this.min;\n+    }\n+    \n+    public void testSpecialValues() {\n+        double[] testArray = {0d, Double.NaN, Double.POSITIVE_INFINITY, \n+                Double.NEGATIVE_INFINITY};\n+        Min min = new Min();\n+        assertTrue(Double.isNaN(min.getResult()));\n+        min.increment(testArray[0]);\n+        assertEquals(0d, min.getResult(), 0);\n+        min.increment(testArray[1]);\n+        assertEquals(0d, min.getResult(), 0);\n+        min.increment(testArray[2]);\n+        assertEquals(0d, min.getResult(), 0);\n+        min.increment(testArray[3]);\n+        assertEquals(Double.NEGATIVE_INFINITY, min.getResult(), 0);\n+        assertEquals(Double.NEGATIVE_INFINITY, min.evaluate(testArray), 0);     \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/rank/PercentileTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.rank;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ */\n+public class PercentileTest extends UnivariateStatisticAbstractTest{\n+\n+    protected Percentile stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public PercentileTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(PercentileTest.class);\n+        suite.setName(\"Percentile Tests\");\n+        return suite;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    public UnivariateStatistic getUnivariateStatistic() {   \n+        return new Percentile(95.0);\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    public double expectedValue() {\n+        return this.percentile95;\n+    }\n+\n+    public void testHighPercentile(){\n+        double[] d = new double[]{1, 2, 3};\n+        Percentile p = new Percentile(75);\n+        assertEquals(3.0, p.evaluate(d), 1.0e-5);\n+    }\n+    \n+    public void testPercentile() {\n+        double[] d = new double[] {1, 3, 2, 4};\n+        Percentile p = new Percentile(30);\n+        assertEquals(1.5, p.evaluate(d), 1.0e-5);\n+        p.setQuantile(25);\n+        assertEquals(1.25, p.evaluate(d), 1.0e-5);\n+        p.setQuantile(75);\n+        assertEquals(3.75, p.evaluate(d), 1.0e-5);\n+        p.setQuantile(50);\n+        assertEquals(2.5, p.evaluate(d), 1.0e-5);\n+    }\n+    \n+    public void testNISTExample() {\n+        double[] d = new double[] {95.1772, 95.1567, 95.1937, 95.1959, \n+                95.1442, 95.0610,  95.1591, 95.1195, 95.1772, 95.0925, 95.1990, 95.1682\n+        };\n+        Percentile p = new Percentile(90); \n+        assertEquals(95.1981, p.evaluate(d), 1.0e-4);\n+        assertEquals(95.1990, p.evaluate(d,0,d.length, 100d), 0);\n+    }\n+    \n+    public void test5() {\n+        Percentile percentile = new Percentile(5);\n+        assertEquals(this.percentile5, percentile.evaluate(testArray), getTolerance());\n+    }\n+    \n+    public void testNullEmpty() {\n+        Percentile percentile = new Percentile(50);\n+        double[] nullArray = null;\n+        double[] emptyArray = new double[] {};\n+        try {\n+            percentile.evaluate(nullArray);\n+            fail(\"Expecting IllegalArgumentException for null array\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }  \n+        assertTrue(Double.isNaN(percentile.evaluate(emptyArray)));        \n+    }\n+    \n+    public void testSingleton() {\n+        Percentile percentile = new Percentile(50);\n+        double[] singletonArray = new double[] {1d};\n+        assertEquals(1d, percentile.evaluate(singletonArray), 0);\n+        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1), 0);\n+        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 5), 0);\n+        assertEquals(1d, percentile.evaluate(singletonArray, 0, 1, 100), 0); \n+        assertTrue(Double.isNaN(percentile.evaluate(singletonArray, 0, 0)));     \n+    }\n+    \n+    public void testSpecialValues() {\n+        Percentile percentile = new Percentile(50);\n+        double[] specialValues = new double[] {0d, 1d, 2d, 3d, 4d,  Double.NaN};\n+        assertEquals(2.5d, percentile.evaluate(specialValues), 0);\n+        specialValues =  new double[] {Double.NEGATIVE_INFINITY, 1d, 2d, 3d,\n+                Double.NaN, Double.POSITIVE_INFINITY};\n+        assertEquals(2.5d, percentile.evaluate(specialValues), 0);\n+        specialValues = new double[] {1d, 1d, Double.POSITIVE_INFINITY, \n+                Double.POSITIVE_INFINITY};\n+        assertTrue(Double.isInfinite(percentile.evaluate(specialValues)));\n+        specialValues = new double[] {1d, 1d, Double.NaN, \n+                Double.NaN};\n+        assertTrue(Double.isNaN(percentile.evaluate(specialValues)));\n+        specialValues = new double[] {1d, 1d, Double.NEGATIVE_INFINITY, \n+                Double.NEGATIVE_INFINITY};\n+        // Interpolation results in NEGATIVE_INFINITY + POSITIVE_INFINITY\n+        assertTrue(Double.isNaN(percentile.evaluate(specialValues)));   \n+    }\n+    \n+    public void testSetQuantile() {\n+        Percentile percentile = new Percentile(10);\n+        percentile.setQuantile(100); // OK\n+        assertEquals(100, percentile.getQuantile(), 0);      \n+        try {\n+            percentile.setQuantile(0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }\n+        try {\n+            percentile = new Percentile(0);\n+            fail(\"Expecting IllegalArgumentException\");\n+        } catch (IllegalArgumentException ex) {\n+            // expected\n+        }        \n+    }\n+    \n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/summary/ProductTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.summary;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ */\n+public class ProductTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected Product stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public ProductTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(ProductTest.class);\n+        suite.setName(\"Product Tests\");\n+        return suite;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new Product();\n+    }\n+\n+    public double getTolerance() {\n+        return 10E8;    //sic -- big absolute error due to only 15 digits of accuracy in double\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    public double expectedValue() {\n+        return this.product;\n+    }\n+    \n+    public void testSpecialValues() {\n+        Product product = new Product();\n+        assertTrue(Double.isNaN(product.getResult()));\n+        product.increment(1);\n+        assertEquals(1, product.getResult(), 0);\n+        product.increment(Double.POSITIVE_INFINITY);\n+        assertEquals(Double.POSITIVE_INFINITY, product.getResult(), 0);\n+        product.increment(Double.NEGATIVE_INFINITY);\n+        assertEquals(Double.NEGATIVE_INFINITY, product.getResult(), 0);\n+        product.increment(Double.NaN);\n+        assertTrue(Double.isNaN(product.getResult())); \n+        product.increment(1);\n+        assertTrue(Double.isNaN(product.getResult())); \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/summary/SumLogTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.summary;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link UnivariateStatistic} class.\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ */\n+public class SumLogTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected SumOfLogs stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public SumLogTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SumLogTest.class);\n+        suite.setName(\"SumLog Tests\");\n+        return suite;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    public UnivariateStatistic getUnivariateStatistic() {        \n+        return new SumOfLogs();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    public double expectedValue() {\n+        return this.sumLog;\n+    }\n+    \n+    public void testSpecialValues() {\n+        SumOfLogs sum = new SumOfLogs();\n+        // empty\n+        assertTrue(Double.isNaN(sum.getResult()));\n+        \n+        // finite data\n+        sum.increment(1d);\n+        assertFalse(Double.isNaN(sum.getResult()));\n+        \n+        // add negative infinity\n+        sum.increment(0d);\n+        assertEquals(Double.NEGATIVE_INFINITY, sum.getResult(), 0);\n+        \n+        // add positive infinity -- should make NaN\n+        sum.increment(Double.POSITIVE_INFINITY);\n+        assertTrue(Double.isNaN(sum.getResult()));\n+        \n+        // clear\n+        sum.clear();\n+        assertTrue(Double.isNaN(sum.getResult()));\n+        \n+        // positive infinity by itself\n+        sum.increment(Double.POSITIVE_INFINITY);\n+        assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);\n+        \n+        // negative value -- should make NaN\n+        sum.increment(-2d);\n+        assertTrue(Double.isNaN(sum.getResult()));\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/summary/SumSqTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.summary;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link SumOfSquares} class.\n+ * \n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ */\n+public class SumSqTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected SumOfSquares stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public SumSqTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SumSqTest.class);\n+        suite.setName(\"SumSq Tests\");\n+        return suite;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new SumOfSquares();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    public double expectedValue() {\n+        return this.sumSq;\n+    }\n+    \n+    public void testSpecialValues() {\n+        SumOfSquares sumSq = new SumOfSquares();\n+        assertTrue(Double.isNaN(sumSq.getResult()));\n+        sumSq.increment(2d);\n+        assertEquals(4d, sumSq.getResult(), 0);\n+        sumSq.increment(Double.POSITIVE_INFINITY);\n+        assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);\n+        sumSq.increment(Double.NEGATIVE_INFINITY);\n+        assertEquals(Double.POSITIVE_INFINITY, sumSq.getResult(), 0);\n+        sumSq.increment(Double.NaN);\n+        assertTrue(Double.isNaN(sumSq.getResult())); \n+        sumSq.increment(1);\n+        assertTrue(Double.isNaN(sumSq.getResult())); \n+    }\n+\n+}\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/descriptive/summary/SumTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.descriptive.summary;\n+\n+import junit.framework.Test;\n+import junit.framework.TestSuite;\n+\n+import org.apache.commons.math.stat.descriptive.StorelessUnivariateStatisticAbstractTest;\n+import org.apache.commons.math.stat.descriptive.UnivariateStatistic;\n+\n+/**\n+ * Test cases for the {@link Sum} class.\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ */\n+public class SumTest extends StorelessUnivariateStatisticAbstractTest{\n+\n+    protected Sum stat;\n+    \n+    /**\n+     * @param name\n+     */\n+    public SumTest(String name) {\n+        super(name);\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SumTest.class);\n+        suite.setName(\"Sum Tests\");\n+        return suite;\n+    }\n+    \n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#getUnivariateStatistic()\n+     */\n+    public UnivariateStatistic getUnivariateStatistic() {\n+        return new Sum();      \n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.stat.descriptive.UnivariateStatisticAbstractTest#expectedValue()\n+     */\n+    public double expectedValue() {\n+        return this.sum;\n+    }\n+    \n+    public void testSpecialValues() {\n+        Sum sum = new Sum();\n+        assertTrue(Double.isNaN(sum.getResult()));\n+        sum.increment(1);\n+        assertEquals(1, sum.getResult(), 0);\n+        sum.increment(Double.POSITIVE_INFINITY);\n+        assertEquals(Double.POSITIVE_INFINITY, sum.getResult(), 0);\n+        sum.increment(Double.NEGATIVE_INFINITY);\n+        assertTrue(Double.isNaN(sum.getResult()));\n+        sum.increment(1);\n+        assertTrue(Double.isNaN(sum.getResult())); \n+    }\n+\n+}\n--- a/src/test/org/apache/commons/math/stat/inference/TTestTest.java\n+++ b/src/test/org/apache/commons/math/stat/inference/TTestTest.java\n import junit.framework.TestCase;\n import junit.framework.TestSuite;\n \n-import org.apache.commons.math.stat.univariate.SummaryStatistics;\n+import org.apache.commons.math.stat.descriptive.SummaryStatistics;\n /**\n  * Test cases for the TTestImpl class.\n  *\n- * @version $Revision: 1.6 $ $Date: 2004/08/02 04:20:09 $\n+ * @version $Revision: 1.7 $ $Date: 2004/10/08 05:08:20 $\n  */\n \n public final class TTestTest extends TestCase {\n--- /dev/null\n+++ b/src/test/org/apache/commons/math/stat/regression/SimpleRegressionTest.java\n+/*\n+ * Copyright 2003-2004 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.commons.math.stat.regression;\n+\n+import java.util.Random;\n+\n+import junit.framework.Test;\n+import junit.framework.TestCase;\n+import junit.framework.TestSuite;\n+/**\n+ * Test cases for the TestStatistic class.\n+ *\n+ * @version $Revision: 1.1 $ $Date: 2004/10/08 05:08:20 $\n+ */\n+\n+public final class SimpleRegressionTest extends TestCase {\n+\n+    /* \n+     * NIST \"Norris\" refernce data set from \n+     * http://www.itl.nist.gov/div898/strd/lls/data/LINKS/DATA/Norris.dat\n+     * Strangely, order is {y,x}\n+     */\n+    private double[][] data = { { 0.1, 0.2 }, {338.8, 337.4 }, {118.1, 118.2 }, \n+            {888.0, 884.6 }, {9.2, 10.1 }, {228.1, 226.5 }, {668.5, 666.3 }, {998.5, 996.3 }, \n+            {449.1, 448.6 }, {778.9, 777.0 }, {559.2, 558.2 }, {0.3, 0.4 }, {0.1, 0.6 }, {778.1, 775.5 }, \n+            {668.8, 666.9 }, {339.3, 338.0 }, {448.9, 447.5 }, {10.8, 11.6 }, {557.7, 556.0 }, \n+            {228.3, 228.1 }, {998.0, 995.8 }, {888.8, 887.6 }, {119.6, 120.2 }, {0.3, 0.3 }, \n+            {0.6, 0.3 }, {557.6, 556.8 }, {339.3, 339.1 }, {888.0, 887.2 }, {998.5, 999.0 }, \n+            {778.9, 779.0 }, {10.2, 11.1 }, {117.6, 118.3 }, {228.9, 229.2 }, {668.4, 669.1 }, \n+            {449.2, 448.9 }, {0.2, 0.5 }\n+    };\n+\n+    /* \n+     * Correlation example from \n+     * http://www.xycoon.com/correlation.htm\n+     */\n+    private double[][] corrData = { { 101.0, 99.2 }, {100.1, 99.0 }, {100.0, 100.0 }, \n+            {90.6, 111.6 }, {86.5, 122.2 }, {89.7, 117.6 }, {90.6, 121.1 }, {82.8, 136.0 }, \n+            {70.1, 154.2 }, {65.4, 153.6 }, {61.3, 158.5 }, {62.5, 140.6 }, {63.6, 136.2 }, \n+            {52.6, 168.0 }, {59.7, 154.3 }, {59.5, 149.0 }, {61.3, 165.5 }\n+    };\n+\n+    /*\n+     * From Moore and Mcabe, \"Introduction to the Practice of Statistics\"\n+     * Example 10.3 \n+     */\n+    private double[][] infData = { { 15.6, 5.2 }, {26.8, 6.1 }, {37.8, 8.7 }, {36.4, 8.5 },\n+            {35.5, 8.8 }, {18.6, 4.9 }, {15.3, 4.5 }, {7.9, 2.5 }, {0.0, 1.1 }\n+    };\n+\n+    /*\n+     * From http://www.xycoon.com/simple_linear_regression.htm\n+     */\n+    private double[][] infData2 = { { 1, 3 }, {2, 5 }, {3, 7 }, {4, 14 }, {5, 11 }};\n+\n+    public SimpleRegressionTest(String name) {\n+        super(name);\n+    }\n+\n+    public void setUp() {\n+    }\n+\n+    public static Test suite() {\n+        TestSuite suite = new TestSuite(SimpleRegressionTest.class);\n+        suite.setName(\"BivariateRegression Tests\");\n+        return suite;\n+    }\n+\n+    public void testNorris() {\n+        SimpleRegression regression = new SimpleRegression();\n+        for (int i = 0; i < data.length; i++) {\n+            regression.addData(data[i][1], data[i][0]);\n+        }\n+        assertEquals(\"slope\", 1.00211681802045, regression.getSlope(), 10E-12);\n+        assertEquals(\"slope std err\", 0.429796848199937E-03,\n+                regression.getSlopeStdErr(),10E-12);\n+        assertEquals(\"number of observations\", 36, regression.getN());\n+        assertEquals( \"intercept\", -0.262323073774029,\n+            regression.getIntercept(),10E-12);\n+        assertEquals(\"std err intercept\", 0.232818234301152,\n+            regression.getInterceptStdErr(),10E-12);\n+        assertEquals(\"r-square\", 0.999993745883712,\n+            regression.getRSquare(), 10E-12);\n+        assertEquals(\"SSR\", 4255954.13232369,\n+            regression.getRegressionSumSquares(), 10E-9);\n+        assertEquals(\"MSE\", 0.782864662630069,\n+            regression.getMeanSquareError(), 10E-10);\n+        assertEquals(\"SSE\", 26.6173985294224,\n+            regression.getSumSquaredErrors(),10E-9);\n+        assertEquals( \"predict(0)\",  -0.262323073774029,\n+            regression.predict(0), 10E-12);\n+        assertEquals(\"predict(1)\", 1.00211681802045 - 0.262323073774029,\n+            regression.predict(1), 10E-12);\n+    }\n+\n+    public void testCorr() {\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.addData(corrData);\n+        assertEquals(\"number of observations\", 17, regression.getN());\n+        assertEquals(\"r-square\", .896123, regression.getRSquare(), 10E-6);\n+        assertEquals(\"r\", -.946638, regression.getR(), 10E-6);\n+    }\n+\n+    public void testNaNs() {\n+        SimpleRegression regression = new SimpleRegression();\n+        assertTrue(\"intercept not NaN\", Double.isNaN(regression.getIntercept()));\n+        assertTrue(\"slope not NaN\", Double.isNaN(regression.getSlope()));\n+        assertTrue(\"slope std err not NaN\", Double.isNaN(regression.getSlopeStdErr()));\n+        assertTrue(\"intercept std err not NaN\", Double.isNaN(regression.getInterceptStdErr()));\n+        assertTrue(\"MSE not NaN\", Double.isNaN(regression.getMeanSquareError()));\n+        assertTrue(\"e not NaN\", Double.isNaN(regression.getR()));\n+        assertTrue(\"r-square not NaN\", Double.isNaN(regression.getRSquare()));\n+        assertTrue( \"RSS not NaN\", Double.isNaN(regression.getRegressionSumSquares()));\n+        assertTrue(\"SSE not NaN\",Double.isNaN(regression.getSumSquaredErrors()));\n+        assertTrue(\"SSTO not NaN\", Double.isNaN(regression.getTotalSumSquares()));\n+        assertTrue(\"predict not NaN\", Double.isNaN(regression.predict(0)));\n+\n+        regression.addData(1, 2);\n+        regression.addData(1, 3);\n+\n+        // No x variation, so these should still blow...\n+        assertTrue(\"intercept not NaN\", Double.isNaN(regression.getIntercept()));\n+        assertTrue(\"slope not NaN\", Double.isNaN(regression.getSlope()));\n+        assertTrue(\"slope std err not NaN\", Double.isNaN(regression.getSlopeStdErr()));\n+        assertTrue(\"intercept std err not NaN\", Double.isNaN(regression.getInterceptStdErr()));\n+        assertTrue(\"MSE not NaN\", Double.isNaN(regression.getMeanSquareError()));\n+        assertTrue(\"e not NaN\", Double.isNaN(regression.getR()));\n+        assertTrue(\"r-square not NaN\", Double.isNaN(regression.getRSquare()));\n+        assertTrue(\"RSS not NaN\", Double.isNaN(regression.getRegressionSumSquares()));\n+        assertTrue(\"SSE not NaN\", Double.isNaN(regression.getSumSquaredErrors()));\n+        assertTrue(\"predict not NaN\", Double.isNaN(regression.predict(0)));\n+\n+        // but SSTO should be OK\n+        assertTrue(\"SSTO NaN\", !Double.isNaN(regression.getTotalSumSquares()));\n+\n+        regression = new SimpleRegression();\n+\n+        regression.addData(1, 2);\n+        regression.addData(3, 3);\n+\n+        // All should be OK except MSE, s(b0), s(b1) which need one more df \n+        assertTrue(\"interceptNaN\", !Double.isNaN(regression.getIntercept()));\n+        assertTrue(\"slope NaN\", !Double.isNaN(regression.getSlope()));\n+        assertTrue (\"slope std err not NaN\", Double.isNaN(regression.getSlopeStdErr()));\n+        assertTrue(\"intercept std err not NaN\", Double.isNaN(regression.getInterceptStdErr()));\n+        assertTrue(\"MSE not NaN\", Double.isNaN(regression.getMeanSquareError()));\n+        assertTrue(\"r NaN\", !Double.isNaN(regression.getR()));\n+        assertTrue(\"r-square NaN\", !Double.isNaN(regression.getRSquare()));\n+        assertTrue(\"RSS NaN\", !Double.isNaN(regression.getRegressionSumSquares()));\n+        assertTrue(\"SSE NaN\", !Double.isNaN(regression.getSumSquaredErrors()));\n+        assertTrue(\"SSTO NaN\", !Double.isNaN(regression.getTotalSumSquares()));\n+        assertTrue(\"predict NaN\", !Double.isNaN(regression.predict(0)));\n+\n+        regression.addData(1, 4);\n+\n+        // MSE, MSE, s(b0), s(b1) should all be OK now\n+        assertTrue(\"MSE NaN\", !Double.isNaN(regression.getMeanSquareError()));\n+        assertTrue(\"slope std err NaN\", !Double.isNaN(regression.getSlopeStdErr()));\n+        assertTrue(\"intercept std err NaN\", !Double.isNaN(regression.getInterceptStdErr()));\n+    }\n+\n+    public void testClear() {\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.addData(corrData);\n+        assertEquals(\"number of observations\", 17, regression.getN());\n+        regression.clear();\n+        assertEquals(\"number of observations\", 0, regression.getN());\n+        regression.addData(corrData);\n+        assertEquals(\"r-square\", .896123, regression.getRSquare(), 10E-6);\n+        regression.addData(data);\n+        assertEquals(\"number of observations\", 53, regression.getN());\n+    }\n+\n+    public void testInference() throws Exception {\n+\n+        SimpleRegression regression = new SimpleRegression();\n+        regression.addData(infData);\n+        \n+        assertEquals(\"slope confidence interval\",  0.0271,\n+                regression.getSlopeConfidenceInterval(), 0.0001);\n+        assertEquals(\"slope std err\",0.01146,\n+                regression.getSlopeStdErr(), 0.0001);\n+   \n+        regression = new SimpleRegression();\n+        regression.addData(infData2);\n+        assertEquals(\"significance\",0.023331,\n+                regression.getSignificance(),0.0001);\n+        \n+        //FIXME: get a real example to test against with alpha = .01\n+        assertTrue(\"tighter means wider\",\n+                regression.getSlopeConfidenceInterval() < regression.getSlopeConfidenceInterval(0.01));\n+     \n+        try {\n+            double x = regression.getSlopeConfidenceInterval(1);\n+            fail(\"expecting IllegalArgumentException for alpha = 1\");\n+        } catch (IllegalArgumentException ex) {\n+            ;\n+        }  \n+\n+    }\n+\n+    public void testPerfect() throws Exception {\n+        SimpleRegression regression = new SimpleRegression();\n+        int n = 100;\n+        for (int i = 0; i < n; i++) {\n+            regression.addData(((double) i) / (n - 1), i);\n+        }\n+        assertEquals(0.0, regression.getSignificance(), 1.0e-5);\n+        assertTrue(regression.getSlope() > 0.0);\n+    }\n+\n+    public void testPerfectNegative() throws Exception {\n+        SimpleRegression regression = new SimpleRegression();\n+        int n = 100;\n+        for (int i = 0; i < n; i++) {\n+            regression.addData(- ((double) i) / (n - 1), i);\n+        }\n+   \n+        assertEquals(0.0, regression.getSignificance(), 1.0e-5);\n+        assertTrue(regression.getSlope() < 0.0);   \n+    }\n+\n+    public void testRandom() throws Exception {\n+        SimpleRegression regression = new SimpleRegression();\n+        Random random = new Random(1);\n+        int n = 100;\n+        for (int i = 0; i < n; i++) {\n+            regression.addData(((double) i) / (n - 1), random.nextDouble());\n+        }\n+\n+        assertTrue( 0.0 < regression.getSignificance()\n+                    && regression.getSignificance() < 1.0);       \n+    }\n+}", "timestamp": 1097212101, "metainfo": ""}