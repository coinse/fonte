{"sha": "3b54252f4ab35119b50d07ff722c4895324d43a1", "log": "MATH-438 Removed deprecated class \"InvalidMatrixException\".   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/CholeskyDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/CholeskyDecomposition.java\n  *   <li>a {@link #getLT() getLT} method has been added,</li>\n  *   <li>the <code>isspd</code> method has been removed, the constructors of\n  *   implementation classes being expected to throw {@link\n- *   NotPositiveDefiniteMatrixException} when a matrix cannot be decomposed,</li>\n+ *   org.apache.commons.math.exception.NonPositiveDefiniteMatrixException}\n+ *   when a matrix cannot be decomposed,</li>\n  *   <li>a {@link #getDeterminant() getDeterminant} method has been added,</li>\n  *   <li>the <code>solve</code> method has been replaced by a {@link\n  *   #getSolver() getSolver} method and the equivalent method provided by\n--- a/src/main/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n          * <p>The A matrix is implicit here. It is </p>\n          * @param b right-hand side of the equation A &times; X = B\n          * @return a vector X such that A &times; X = B\n-         * @throws IllegalArgumentException if matrices dimensions don't match\n-         * @throws InvalidMatrixException if decomposed matrix is singular\n+         * @throws DimensionMismatchException if the matrices dimensions do not match.\n+         * @throws org.apache.commons.math.exception.SingularMatrixException if\n+         * the decomposed matrix is singular.\n          */\n         public ArrayRealVector solve(ArrayRealVector b) {\n             return new ArrayRealVector(solve(b.getDataRef()), false);\n--- a/src/main/java/org/apache/commons/math/linear/DecompositionSolver.java\n+++ b/src/main/java/org/apache/commons/math/linear/DecompositionSolver.java\n      * decomposition algorithm.</p>\n      * @param b right-hand side of the equation A &times; X = B\n      * @return a vector X that minimizes the two norm of A &times; X - B\n-     * @exception IllegalArgumentException if matrices dimensions don't match\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the matrices dimensions do not match.\n+     * @throws org.apache.commons.math.exception.SingularMatrixException\n+     * if the decomposed matrix is singular.\n      */\n-    double[] solve(final double[] b)\n-        throws IllegalArgumentException, InvalidMatrixException;\n+    double[] solve(final double[] b);\n \n     /** Solve the linear equation A &times; X = B for matrices A.\n      * <p>The A matrix is implicit, it is provided by the underlying\n      * decomposition algorithm.</p>\n      * @param b right-hand side of the equation A &times; X = B\n      * @return a vector X that minimizes the two norm of A &times; X - B\n-     * @exception IllegalArgumentException if matrices dimensions don't match\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the matrices dimensions do not match.\n+     * @throws org.apache.commons.math.exception.SingularMatrixException\n+     * if the decomposed matrix is singular.\n      */\n-    RealVector solve(final RealVector b)\n-        throws IllegalArgumentException, InvalidMatrixException;\n+    RealVector solve(final RealVector b);\n \n     /** Solve the linear equation A &times; X = B for matrices A.\n      * <p>The A matrix is implicit, it is provided by the underlying\n      * decomposition algorithm.</p>\n      * @param b right-hand side of the equation A &times; X = B\n      * @return a matrix X that minimizes the two norm of A &times; X - B\n-     * @exception IllegalArgumentException if matrices dimensions don't match\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the matrices dimensions do not match.\n+     * @throws org.apache.commons.math.exception.SingularMatrixException\n+     * if the decomposed matrix is singular.\n      */\n-    RealMatrix solve(final RealMatrix b)\n-        throws IllegalArgumentException, InvalidMatrixException;\n+    RealMatrix solve(final RealMatrix b);\n \n     /**\n      * Check if the decomposed matrix is non-singular.\n-     * @return true if the decomposed matrix is non-singular\n+     * @return true if the decomposed matrix is non-singular.\n      */\n     boolean isNonSingular();\n \n     /** Get the inverse (or pseudo-inverse) of the decomposed matrix.\n      * @return inverse matrix\n-     * @throws InvalidMatrixException if decomposed matrix is singular\n+     * @throws org.apache.commons.math.exception.SingularMatrixException\n+     * if the decomposed matrix is singular.\n      */\n-    RealMatrix getInverse()\n-        throws InvalidMatrixException;\n-\n+    RealMatrix getInverse();\n }\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n          * This method only find exact linear solutions, i.e. solutions for\n          * which ||A &times; X - B|| is exactly 0.\n          * </p>\n-         * @param b\n-         *            right-hand side of the equation A &times; X = B\n-         * @return a vector X that minimizes the two norm of A &times; X - B\n-         * @exception IllegalArgumentException\n-         *                if matrices dimensions don't match\n-         * @exception InvalidMatrixException\n-         *                if decomposed matrix is singular\n+         * @param b Right-hand side of the equation A &times; X = B\n+         * @return a Vector X that minimizes the two norm of A &times; X - B\n+         * @throws DimensionMismatchException if the matrices dimensions do not match.\n+         * @throws SingularMatrixException if the decomposed matrix is singular.\n          */\n         public double[] solve(final double[] b) {\n \n--- a/src/main/java/org/apache/commons/math/linear/FieldDecompositionSolver.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldDecompositionSolver.java\n      * decomposition algorithm.</p>\n      * @param b right-hand side of the equation A &times; X = B\n      * @return a vector X that minimizes the two norm of A &times; X - B\n-     * @exception IllegalArgumentException if matrices dimensions don't match\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the matrices dimensions do not match.\n+     * @throws org.apache.commons.math.exception.SingularMatrixException\n+     * if the decomposed matrix is singular.\n      */\n-    T[] solve(final T[] b)\n-        throws IllegalArgumentException, InvalidMatrixException;\n+    T[] solve(final T[] b);\n \n     /** Solve the linear equation A &times; X = B for matrices A.\n      * <p>The A matrix is implicit, it is provided by the underlying\n      * decomposition algorithm.</p>\n      * @param b right-hand side of the equation A &times; X = B\n      * @return a vector X that minimizes the two norm of A &times; X - B\n-     * @exception IllegalArgumentException if matrices dimensions don't match\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the matrices dimensions do not match.\n+     * @throws org.apache.commons.math.exception.SingularMatrixException\n+     * if the decomposed matrix is singular.\n      */\n-    FieldVector<T> solve(final FieldVector<T> b)\n-        throws IllegalArgumentException, InvalidMatrixException;\n+    FieldVector<T> solve(final FieldVector<T> b);\n \n     /** Solve the linear equation A &times; X = B for matrices A.\n      * <p>The A matrix is implicit, it is provided by the underlying\n      * decomposition algorithm.</p>\n      * @param b right-hand side of the equation A &times; X = B\n      * @return a matrix X that minimizes the two norm of A &times; X - B\n-     * @exception IllegalArgumentException if matrices dimensions don't match\n-     * @exception InvalidMatrixException if decomposed matrix is singular\n+     * @throws org.apache.commons.math.exception.DimensionMismatchException\n+     * if the matrices dimensions do not match.\n+     * @throws org.apache.commons.math.exception.SingularMatrixException\n+     * if the decomposed matrix is singular.\n      */\n-    FieldMatrix<T> solve(final FieldMatrix<T> b)\n-        throws IllegalArgumentException, InvalidMatrixException;\n+    FieldMatrix<T> solve(final FieldMatrix<T> b);\n \n     /**\n      * Check if the decomposed matrix is non-singular.\n \n     /** Get the inverse (or pseudo-inverse) of the decomposed matrix.\n      * @return inverse matrix\n-     * @throws InvalidMatrixException if decomposed matrix is singular\n+     * @throws org.apache.commons.math.exception.SingularMatrixException\n+     * if the decomposed matrix is singular.\n      */\n-    FieldMatrix<T> getInverse()\n-        throws InvalidMatrixException;\n-\n+    FieldMatrix<T> getInverse();\n }\n--- a/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/FieldLUDecompositionImpl.java\n          * <p>The A matrix is implicit here. It is </p>\n          * @param b right-hand side of the equation A &times; X = B\n          * @return a vector X such that A &times; X = B\n-         * @throws IllegalArgumentException if matrices dimensions don't match\n-         * @throws InvalidMatrixException if decomposed matrix is singular\n+         * @throws DimensionMismatchException if the matrices dimensions do not match.\n+         * @throws SingularMatrixException if the decomposed matrix is singular.\n          */\n         public ArrayFieldVector<T> solve(ArrayFieldVector<T> b) {\n             return new ArrayFieldVector<T>(solve(b.getDataRef()), false);\n         }\n \n         /** {@inheritDoc} */\n-        public FieldMatrix<T> getInverse() throws InvalidMatrixException {\n+        public FieldMatrix<T> getInverse() {\n             final int m = pivot.length;\n             final T one = field.getOne();\n             FieldMatrix<T> identity = new Array2DRowFieldMatrix<T>(field, m, m);\n--- a/src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/LUDecompositionImpl.java\n \n     /**\n      * Calculates the LU-decomposition of the given matrix.\n-     * @param matrix The matrix to decompose.\n-     * @throws InvalidMatrixException if matrix is not square\n+     * @param matrix Matrix to decompose.\n+     * @throws NonSquareMatrixException if matrix is not square.\n      */\n-    public LUDecompositionImpl(RealMatrix matrix)\n-        throws InvalidMatrixException {\n+    public LUDecompositionImpl(RealMatrix matrix) {\n         this(matrix, DEFAULT_TOO_SMALL);\n     }\n \n          * @return a vector X such that A &times; X = B\n          * @throws DimensionMismatchException if the matrices dimensions\n          * do not match.\n-         * @throws InvalidMatrixException if decomposed matrix is singular\n+         * @throws SingularMatrixException if decomposed matrix is singular.\n          */\n         public ArrayRealVector solve(ArrayRealVector b) {\n             return new ArrayRealVector(solve(b.getDataRef()), false);\n         }\n \n         /** {@inheritDoc} */\n-        public RealMatrix getInverse() throws InvalidMatrixException {\n+        public RealMatrix getInverse() {\n             return solve(MatrixUtils.createRealIdentityMatrix(pivot.length));\n         }\n     }\n--- a/src/main/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/QRDecompositionImpl.java\n          * <p>The A matrix is implicit here. It is </p>\n          * @param b right-hand side of the equation A &times; X = B\n          * @return a vector X that minimizes the two norm of A &times; X - B\n-         * @throws IllegalArgumentException if matrices dimensions don't match\n-         * @throws InvalidMatrixException if decomposed matrix is singular\n+         * @throws DimensionMismatchException if the matrices dimensions do not match.\n+         * @throws SingularMatrixException if the decomposed matrix is singular.\n          */\n         public ArrayRealVector solve(ArrayRealVector b) {\n             return new ArrayRealVector(solve(b.getDataRef()), false);\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecompositionImpl.java\n \n     /**\n      * Calculates the compact Singular Value Decomposition of the given matrix.\n-     * @param matrix\n-     *            The matrix to decompose.\n-     * @exception InvalidMatrixException\n-     *                (wrapping a\n-     *                {@link org.apache.commons.math.ConvergenceException} if\n-     *                algorithm fails to converge\n+     * @param matrix Matrix to decompose.\n      */\n-    public SingularValueDecompositionImpl(final RealMatrix matrix)\n-            throws InvalidMatrixException {\n-\n+    public SingularValueDecompositionImpl(final RealMatrix matrix) {\n         m = matrix.getRowDimension();\n         n = matrix.getColumnDimension();\n \n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getU() throws InvalidMatrixException {\n+    public RealMatrix getU() {\n         // return the cached matrix\n         return cachedU;\n \n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getUT() throws InvalidMatrixException {\n+    public RealMatrix getUT() {\n \n         if (cachedUt == null) {\n             cachedUt = getU().transpose();\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getS() throws InvalidMatrixException {\n+    public RealMatrix getS() {\n \n         if (cachedS == null) {\n \n     }\n \n     /** {@inheritDoc} */\n-    public double[] getSingularValues() throws InvalidMatrixException {\n+    public double[] getSingularValues() {\n         return singularValues.clone();\n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getV() throws InvalidMatrixException {\n+    public RealMatrix getV() {\n         // return the cached matrix\n         return cachedV;\n \n     }\n \n     /** {@inheritDoc} */\n-    public RealMatrix getVT() throws InvalidMatrixException {\n+    public RealMatrix getVT() {\n \n         if (cachedVt == null) {\n             cachedVt = getV().transpose();\n     }\n \n     /** {@inheritDoc} */\n-    public double getNorm() throws InvalidMatrixException {\n+    public double getNorm() {\n         return singularValues[0];\n     }\n \n     /** {@inheritDoc} */\n-    public double getConditionNumber() throws InvalidMatrixException {\n+    public double getConditionNumber() {\n         return singularValues[0] / singularValues[singularValues.length - 1];\n     }\n ", "timestamp": 1289520807, "metainfo": ""}