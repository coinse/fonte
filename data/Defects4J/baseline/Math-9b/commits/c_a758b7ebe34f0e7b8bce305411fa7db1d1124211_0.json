{"sha": "a758b7ebe34f0e7b8bce305411fa7db1d1124211", "log": "fixed another bunch of checkstyle warnings  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatingFunction.java\n+++ b/src/main/java/org/apache/commons/math/analysis/interpolation/MicrosphereInterpolatingFunction.java\n                                             int brightnessExponent,\n                                             int microsphereElements,\n                                             UnitSphereRandomVectorGenerator rand)\n-        throws DimensionMismatchException, IllegalArgumentException {\n+        throws DimensionMismatchException, NoDataException {\n         if (xval.length == 0 || xval[0] == null) {\n             throw new NoDataException();\n         }\n--- a/src/main/java/org/apache/commons/math/optimization/general/BaseAbstractScalarOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/general/BaseAbstractScalarOptimizer.java\n  * A class that implements an optimization algorithm should inherit from\n  * {@link AbstractScalarOptimizer} or from\n  * {@link AbstractScalarDifferentiableOptimizer}.\n+ * @param <T> the type of the objective function to be optimized\n  *\n  * @version $Revision$ $Date$\n  * @since 2.2\n     }\n \n     /** {@inheritDoc} */\n-    public void setConvergenceChecker(RealConvergenceChecker checker) {\n-        this.checker = checker;\n+    public void setConvergenceChecker(RealConvergenceChecker convergenceChecker) {\n+        this.checker = convergenceChecker;\n     }\n \n     /** {@inheritDoc} */\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/AbstractUnivariateRealOptimizer.java\n     /** Number of evaluations already performed. */\n     private int evaluations;\n     /** Optimization type */\n-    private GoalType goal;\n+    private GoalType optimizationGoal;\n     /** Lower end of search interval. */\n-    private double min;\n+    private double searchMin;\n     /** Higher end of search interval. */\n-    private double max;\n+    private double searchMax;\n     /** Initial guess . */\n-    private double startValue;\n+    private double searchStart;\n     /** Function to optimize. */\n     private UnivariateRealFunction function;\n \n      * @return the optimization type.\n      */\n     public GoalType getGoalType() {\n-        return goal;\n+        return optimizationGoal;\n     }\n     /**\n      * @return the lower of the search interval.\n      */\n     public double getMin() {\n-        return min;\n+        return searchMin;\n     }\n     /**\n      * @return the higher of the search interval.\n      */\n     public double getMax() {\n-        return max;\n+        return searchMax;\n     }\n     /**\n      * @return the initial guess.\n      */\n     public double getStartValue() {\n-        return startValue;\n+        return searchStart;\n     }\n \n     /**\n     }\n \n     /** {@inheritDoc} */\n-    public double optimize(UnivariateRealFunction function, GoalType goal,\n+    public double optimize(UnivariateRealFunction f, GoalType goal,\n                            double min, double max, double startValue)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n         // Initialize.\n-        this.min = min;\n-        this.max = max;\n-        this.startValue = startValue;\n-        this.goal = goal;\n-        this.function = function;\n+        this.searchMin = min;\n+        this.searchMax = max;\n+        this.searchStart = startValue;\n+        this.optimizationGoal = goal;\n+        this.function = f;\n \n         // Reset.\n         functionValue = Double.NaN;\n--- a/src/main/java/org/apache/commons/math/optimization/univariate/BracketFinder.java\n+++ b/src/main/java/org/apache/commons/math/optimization/univariate/BracketFinder.java\n \n     /**\n      * @return the lower bound of the bracket.\n+     * @see #getFLow()\n      */\n     public double getLo() {\n         return lo;\n     }\n+\n+    /**\n+     * Get function value at {@link #getLo()}.\n+     * @return function value at {@link #getLo()}\n+     */\n+    public double getFLow() {\n+        return fLo;\n+    }\n+\n     /**\n      * @return the higher bound of the bracket.\n+     * @see #getFHi()\n      */\n     public double getHi() {\n         return hi;\n     }\n+\n+    /**\n+     * Get function value at {@link #getHi()}.\n+     * @return function value at {@link #getHi()}\n+     */\n+    public double getFHi() {\n+        return fHi;\n+    }\n+\n     /**\n      * @return a point in the middle of the bracket.\n+     * @see #getFMid()\n      */\n     public double getMid() {\n         return mid;\n+    }\n+\n+    /**\n+     * Get function value at {@link #getMid()}.\n+     * @return function value at {@link #getMid()}\n+     */\n+    public double getFMid() {\n+        return fMid;\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n     }\n \n     public static class Order {\n+\n+        /** Enumerate type for increasing/decreasing directions. */\n         public static enum Direction {\n-                INCREASING,\n-                DECREASING\n+\n+            /** Constant for increasing direction. */\n+            INCREASING,\n+\n+            /** Constant for decreasing direction. */\n+            DECREASING\n+\n         };\n+\n     }\n \n     /**\n--- a/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n+++ b/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n          * of the iterator.\n          * @throws IndexOutOfBoundsException if {@code index} is not in the\n          * correct interval (as defined by the length of the argument in the\n-         * {@link #MultidimensionalCounter(int[])\n+         * {@link MultidimensionalCounter#MultidimensionalCounter(int[])\n          * constructor of the enclosing class}).\n          */\n         public int getCount(int dim) {\n      * Create a counter.\n      *\n      * @param size Counter sizes (number of slots in each dimension).\n-     * @throws {@link NotStrictlyPositiveException} if one of the sizes is\n+     * @throws NotStrictlyPositiveException if one of the sizes is\n      * negative or zero.\n      */\n     public MultidimensionalCounter(int ... size) {\n      *\n      * @param index Index in unidimensional counter.\n      * @return the multidimensional counts.\n-     * @throws {@link OutOfRangeException} if {@code index} is not between\n+     * @throws OutOfRangeException if {@code index} is not between\n      * {@code 0} and the value returned by {@link #getSize()} (excluded).\n      */\n     public int[] getCounts(int index) {\n-        if (index < 0\n-            || index >= totalSize) {\n+        if (index < 0 ||\n+            index >= totalSize) {\n             throw new OutOfRangeException(index, 0, totalSize);\n         }\n \n      *\n      * @param c Indices in multidimensional counter.\n      * @return the index within the unidimensionl counter.\n-     * @throws {@link DimensionMismatchException} if the size of {@code c}\n-     * does not match the size of the array given in the contructor.\n-     * @throws {@link OutOfRangeException} if a value of {@code c} is not in\n+     * @throws DimensionMismatchException if the size of {@code c}\n+     * does not match the size of the array given in the constructor.\n+     * @throws OutOfRangeException if a value of {@code c} is not in\n      * the range of the corresponding dimension, as defined in the\n-     * {@link #MultidimensionalCounter(int[]) constructor}.\n-     */\n-    public int getCount(int ... c) {\n+     * {@link MultidimensionalCounter#MultidimensionalCounter(int...) constructor}.\n+     */\n+    public int getCount(int ... c) throws OutOfRangeException {\n         if (c.length != dimension) {\n             throw new DimensionMismatchException(c.length, dimension);\n         }\n         int count = 0;\n         for (int i = 0; i < dimension; i++) {\n             final int index = c[i];\n-            if (index < 0\n-                || index >= size[i]) {\n+            if (index < 0 ||\n+                index >= size[i]) {\n                 throw new OutOfRangeException(index, 0, size[i] - 1);\n             }\n             count += uniCounterOffset[i] * c[i];", "timestamp": 1280674890, "metainfo": ""}