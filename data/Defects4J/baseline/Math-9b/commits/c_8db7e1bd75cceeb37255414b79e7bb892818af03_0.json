{"sha": "8db7e1bd75cceeb37255414b79e7bb892818af03", "log": "The Univariate interface now contains getWindow and setWindow in addition to a constant which signifies an \"infinite\" window.  Windowing has been added to all three Univariate implementations:  * UnivariateImpl - If the window is not infinite, we keep track of 0..n elements and discount the contribution of the discarded element when our \"window\" is moved.  If the window is infinite no extra storage is used beyond an empty ContractableDoubleArray.  - In the following two implementations, the window size can be changed at anytime.  * ListStoreUnivariateImpl - If the window is not infinite, this implementation only takes into account the last n elements of the List.  * StoreUnivariateImpl - Uses an internal ContractableDoubleArray, window size can be changed at any time.   ", "commit": "\n--- a/src/java/org/apache/commons/math/DoubleArray.java\n+++ b/src/java/org/apache/commons/math/DoubleArray.java\n \t * @param i number of elements to discard from the front of the array.\n \t */\n \tpublic abstract void discardFrontElements(int i);\n+\t\n+\t/**\n+\t * Returns the minimum value stored in this array\n+\t */\n+\tpublic abstract double getMin();\n+\n+\t/**\n+\t * Returns the maximum value stored in this array\n+\t */\n+\tpublic abstract double getMax();\n }\n--- a/src/java/org/apache/commons/math/ExpandableDoubleArray.java\n+++ b/src/java/org/apache/commons/math/ExpandableDoubleArray.java\n \t\treturn elementArray;\n \t}\n \n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.DoubleArray#getMax()\n+\t */\n+\tpublic double getMax() {\n+\t\tdouble max = internalArray[startIndex];\n+\t\t\n+\t\tfor( int i = startIndex + 1; i < numElements; i++) {\n+\t\t\tif( internalArray[i] > max ) {\n+\t\t\t\tmax = internalArray[i];\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn max;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.DoubleArray#getMin()\n+\t */\n+\tpublic double getMin() {\n+\t\tdouble min = internalArray[startIndex];\n+\t\t\n+\t\tfor( int i = startIndex + 1; i < numElements; i++) {\n+\t\t\tif( internalArray[i] < min ) {\n+\t\t\t\tmin = internalArray[i];\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn min;\n+\t}\n+\n }\n--- a/src/java/org/apache/commons/math/ListUnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/ListUnivariateImpl.java\n  */\n public class ListUnivariateImpl extends AbstractStoreUnivariate {\n \n+\t// Holds the value of the windowSize, initial windowSize is the constant\n+\t// Univariate.INFINITE_WINDOW\n+\tprivate int windowSize = Univariate.INIFINTE_WINDOW;\n+\n \t// Holds a reference to a list - GENERICs are going to make\n \t// out lives easier here as we could only accept List<Number>\n \tList list;\n \t */\n \tpublic double[] getValues() {\n \n-\t\tdouble[] copiedArray = new double[list.size()];\n+\t\t// If we've got a windowSize, we might not care about the entire list.\n+\t\tList effectiveList = list;\n+\t\t\n+\t\t// If the window size is not INIFINITE_WINDOW AND\n+\t\t// the current list is larger that the window size, we need to\n+\t\t// take into account only the last n elements of the list\n+\t\t// as definied by windowSize\n+\t\tif( windowSize != Univariate.INIFINTE_WINDOW &&\n+\t\t\twindowSize < list.size() ) {\n+\t\t\teffectiveList = list.subList( (list.size() - 1) - windowSize, (list.size()-1));\n+\t\t}\n+\n+\t\t// Create an array to hold all values\n+\t\tdouble[] copiedArray = new double[effectiveList.size()];\n \n \t\tint i = 0;\n-\t\tIterator it = list.iterator();\n+\t\tIterator it = effectiveList.iterator();\n \t\twhile( it.hasNext() ) {\n \t\t\tNumber n = (Number) it.next();\n \t\t\tcopiedArray[i] = n.doubleValue();\n \t * @see org.apache.commons.math.StoreUnivariate#getElement(int)\n \t */\n \tpublic double getElement(int index) {\n-\t\tNumber n = (Number) list.get(index);\n-\t\treturn n.doubleValue();\n+\t\t\n+\t\tdouble value = Double.NaN;\n+\n+\t\tif( windowSize != Univariate.INIFINTE_WINDOW &&\n+\t\t\t windowSize < list.size() ) {\n+\t\t\tNumber n = (Number) list.get( ( (list.size() - 1) - windowSize ) + index ) ;\n+\t\t\tvalue = n.doubleValue();\n+\t\t} else {\n+\t\t\tNumber n = (Number) list.get(index);\n+\t\t\tvalue = n.doubleValue();\n+\t\t}\n+\t\t\n+\t\treturn value;\n \t}\n \t\n \t/* (non-Javadoc)\n \t * @see org.apache.commons.math.Univariate#getN()\n \t */\n \tpublic double getN() {\n-\t\treturn list.size();\n+\t\tdouble N = 0.0;\n+\t\t\n+\t\tif( windowSize != Univariate.INIFINTE_WINDOW ) {\n+\t\t\tif( list.size() > windowSize ) {\n+\t\t\t\tN = windowSize;\n+\t\t\t} else {\n+\t\t\t\tN = list.size();\n+\t\t\t}\n+\t\t} else {\n+\t\t\tN = list.size();\n+\t\t}\n+\t\t\n+\t\treturn N;\n \t}\n \t\n \t/* (non-Javadoc)\n \t\tlist.clear();\n \t}\n \n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.Univariate#getWindowSize()\n+\t */\n+\tpublic int getWindowSize() {\n+\t\treturn windowSize;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.Univariate#setWindowSize(int)\n+\t */\n+\tpublic void setWindowSize(int windowSize) {\n+\t\tthis.windowSize = windowSize;\n+\t}\n+\n }\n--- a/src/java/org/apache/commons/math/StoreUnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/StoreUnivariateImpl.java\n  */\n public class StoreUnivariateImpl extends AbstractStoreUnivariate {\n \n-\tExpandableDoubleArray eDA;\n+\t// Use an internal double array\n+\tDoubleArray eDA;\n+\t\n+\t// Store the windowSize\n+\tprivate int windowSize = Univariate.INIFINTE_WINDOW;\n \n \tpublic StoreUnivariateImpl() {\n-\t\teDA = new ExpandableDoubleArray();\n+\t\t// A contractable double array is used.  memory is reclaimed when\n+\t\t// the storage of the array becomes too empty.\n+\t\teDA = new ContractableDoubleArray();\n \t}\n \n \t/* (non-Javadoc)\n \tpublic double[] getValues() {\n \n \t\tdouble[] copiedArray = new double[ eDA.getNumElements() ];\n-\t\tSystem.arraycopy( eDA.getValues(), 0, copiedArray, 0, eDA.getNumElements());\n+\t\tSystem.arraycopy( eDA.getElements(), 0, copiedArray, 0, eDA.getNumElements());\n \t\treturn copiedArray;\n \t}\n \n \t/* (non-Javadoc)\n \t * @see org.apache.commons.math.Univariate#addValue(double)\n \t */\n-\tpublic void addValue(double v) {\n-\t\teDA.addElement( v );\n+\tpublic synchronized void addValue(double v) {\n+\t\tif( windowSize != Univariate.INIFINTE_WINDOW ) {\n+\t\t\tif( getN() == windowSize ) {\n+\t\t\t\teDA.addElementRolling( v );\n+\t\t\t} else if( getN() < windowSize ) {\n+\t\t\t\teDA.addElement(v);\n+\t\t\t} else {\n+\t\t\t\tthrow new RuntimeException( \"A window Univariate had more element than \" +\n+\t\t\t\t\t\"the windowSize.  This is an inconsistent state.\");\n+\t\t\t}\n+\t\t} else {\n+\t\t\teDA.addElement(v);\n+\t\t}\n \t}\n \n \t/* (non-Javadoc)\n \t * @see org.apache.commons.math.Univariate#clear()\n \t */\n-\tpublic void clear() {\n+\tpublic synchronized void clear() {\n \t\teDA.clear();\n \t}\n \n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.Univariate#getWindowSize()\n+\t */\n+\tpublic int getWindowSize() {\n+\t\treturn windowSize;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.Univariate#setWindowSize(int)\n+\t */\n+\tpublic synchronized void setWindowSize(int windowSize) {\n+\t\tthis.windowSize = windowSize;\n+\t\t\n+\t\t// We need to check to see if we need to discard elements\n+\t\t// from the front of the array.  If the windowSize is less than \n+\t\t// the current number of elements.\n+\t\tif( windowSize < eDA.getNumElements() ) {\n+\t\t\teDA.discardFrontElements( eDA.getNumElements() - windowSize);\n+\t\t}\n+\t\t\n+\t}\n+\n }\n--- a/src/java/org/apache/commons/math/Univariate.java\n+++ b/src/java/org/apache/commons/math/Univariate.java\n  *\n  * @author Phil Steitz\n  * @author <a href=\"mailto:tobrien@apache.org\">Tim O'Brien</a>\n- * @version $Revision: 1.2 $ $Date: 2003/05/15 05:39:00 $\n+ * @version $Revision: 1.3 $ $Date: 2003/05/16 05:23:29 $\n  * \n */\n public interface Univariate {\n \n \t/** Resets all sums to 0, resets min and max */\n \tpublic abstract void clear();\n+\t\n+\t/**\n+\t * This constant signals that a Univariate implementation\n+\t * takes into account the contributions of an infinite number of\n+\t * elements.  In other words, if getWindow returns this\n+\t * constant, there is, in effect, no \"window\".\n+\t */\n+\tpublic static final int INIFINTE_WINDOW = -1;\n+\n+\t/**\n+\t * Univariate has the ability to return only measures for the\n+\t * last N elements added to the set of values.  This function returns\n+\t */\n+\tpublic abstract int getWindowSize();\n+\t\n+\t/**\n+\t * Sets the window.  windowSize controls the number of value\n+\t * which contribute to the values returned by Univariate.  \n+\t * For example, a window value of 10 means that getMean()\n+\t * will return the mean of the last 10 values added.\n+\t */\n+\tpublic abstract void setWindowSize(int windowSize);\n }\n--- a/src/java/org/apache/commons/math/UnivariateImpl.java\n+++ b/src/java/org/apache/commons/math/UnivariateImpl.java\n  * to doubles by addValue().  \n  *\n  * @author Phil Steitz\n- * @version $Revision: 1.2 $ $Date: 2003/05/15 06:33:19 $\n+ * @version $Revision: 1.3 $ $Date: 2003/05/16 05:23:29 $\n  * \n */\n public class UnivariateImpl implements Univariate, Serializable {\n+\n+\t/** hold the window size **/\n+\tprivate int windowSize = Univariate.INIFINTE_WINDOW;\n+\t\n+\t/** Just in case, the windowSize is not inifinite, we need to\n+\t *   keep an array to remember values 0 to N\n+\t */\n+\tprivate DoubleArray doubleArray =\n+\t\tnew ContractableDoubleArray(); \n \n     /** running sum of values that have been added */\n     private double sum = 0.0;\n      * @param v the value to be added \n      */\n     private void insertValue(double v) {\n-        n += 1.0;\n-        if (v < min) min = v;\n-        if (v > max) max = v;\n-        sum += v;\n-        sumsq += v*v;\n+    \t\n+    \tif( windowSize != Univariate.INIFINTE_WINDOW ) {\n+    \t\tif( windowSize == n ) {\n+\t\t\t\tdouble discarded = doubleArray.addElementRolling( v );        \t\n+\t\t\t\n+\t\t\t\t// Remove the influence of the discarded\n+\t\t\t\tsum -= discarded;\n+\t\t\t\tsumsq -= discarded * discarded;\n+\t\t\t\n+\t\t\t\t// Include the influence of the new\n+\t\t\t\t// TODO: The next two lines seems rather expensive, but\n+\t\t\t\t// I don't see many alternatives.\t\t\t \n+\t\t\t\tmin = doubleArray.getMin();\n+\t\t\t\tmax = doubleArray.getMax();\n+\t\t\t\tsum += v;\n+\t\t\t\tsumsq += v*v;\n+    \t\t} else {\n+\t\t\t\tdoubleArray.addElement( v );        \t\n+\t        \tn += 1.0;\n+    \t    \tif (v < min) min = v;\n+       \t\t\tif (v > max) max = v;\n+        \t\tsum += v;\n+        \t\tsumsq += v*v;\n+    \t\t}\n+    \t} else {\n+\t\t\t// If the windowSize is inifinite please don't take the time to\n+\t\t\t// worry about storing any values.  We don't need to discard the\n+\t\t\t// influence of any single item.\n+\t\t\tn += 1.0;\n+\t\t\tif (v < min) min = v;\n+\t\t\tif (v > max) max = v;\n+\t\t\tsum += v;\n+\t\t\tsumsq += v*v;\n+    \t}\n     }\n \n     /** Getter for property max.\n         this.max = Double.MIN_VALUE;\n     }\n \n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.Univariate#getWindowSize()\n+\t */\n+\tpublic int getWindowSize() {\n+\t\treturn windowSize;\n+\t}\n+\n+\t/* (non-Javadoc)\n+\t * @see org.apache.commons.math.Univariate#setWindowSize(int)\n+\t */\n+\tpublic void setWindowSize(int windowSize) {\n+\t\tthis.windowSize = windowSize;\n+\t}\n+\n }", "timestamp": 1053062609, "metainfo": ""}