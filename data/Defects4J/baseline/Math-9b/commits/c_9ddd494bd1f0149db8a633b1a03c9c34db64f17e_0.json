{"sha": "9ddd494bd1f0149db8a633b1a03c9c34db64f17e", "log": "Added hyperbolic trigonometric functions and inverses to DSCompiler.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DSCompiler.java\n \n     }\n \n+    /** Compute hyperbolic cosine of a derivative structure.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param result array where result must be stored (for\n+     * hyperbolic cosine the result array <em>cannot</em> be the input\n+     * array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void cosh(final double[] operand, final int operandOffset,\n+                     final double[] result, final int resultOffset) {\n+\n+        // create the function value and derivatives\n+        double[] function = new double[1 + order];\n+        function[0] = FastMath.cosh(operand[operandOffset]);\n+        if (order > 0) {\n+            function[1] = FastMath.sinh(operand[operandOffset]);\n+            for (int i = 2; i <= order; ++i) {\n+                function[i] = function[i - 2];\n+            }\n+        }\n+\n+        // apply function composition\n+        compose(operand, operandOffset, function, result, resultOffset);\n+\n+    }\n+\n+    /** Compute hyperbolic sine of a derivative structure.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param result array where result must be stored (for\n+     * hyperbolic sine the result array <em>cannot</em> be the input\n+     * array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void sinh(final double[] operand, final int operandOffset,\n+                     final double[] result, final int resultOffset) {\n+\n+        // create the function value and derivatives\n+        double[] function = new double[1 + order];\n+        function[0] = FastMath.sinh(operand[operandOffset]);\n+        if (order > 0) {\n+            function[1] = FastMath.cosh(operand[operandOffset]);\n+            for (int i = 2; i <= order; ++i) {\n+                function[i] = function[i - 2];\n+            }\n+        }\n+\n+        // apply function composition\n+        compose(operand, operandOffset, function, result, resultOffset);\n+\n+    }\n+\n+    /** Compute hyperbolic tangent of a derivative structure.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param result array where result must be stored (for\n+     * hyperbolic tangent the result array <em>cannot</em> be the input\n+     * array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void tanh(final double[] operand, final int operandOffset,\n+                     final double[] result, final int resultOffset) {\n+\n+        // create the function value and derivatives\n+        final double[] function = new double[1 + order];\n+        final double t = FastMath.tanh(operand[operandOffset]);\n+        function[0] = t;\n+\n+        if (order > 0) {\n+\n+            // the nth order derivative of tanh has the form:\n+            // dn(tanh(x)/dxn = P_n(tanh(x))\n+            // where P_n(t) is a degree n+1 polynomial with same parity as n+1\n+            // P_0(t) = t, P_1(t) = 1 - t^2, P_2(x) = -2 t (1 - t^2) ...\n+            // the general recurrence relation for P_n is:\n+            // P_n(x) = (1-t^2) P_(n-1)'(t)\n+            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n+            final double[] p = new double[order + 2];\n+            p[1] = 1;\n+            final double t2 = t * t;\n+            for (int n = 1; n <= order; ++n) {\n+\n+                // update and evaluate polynomial P_n(t)\n+                double v = 0;\n+                p[n + 1] = -n * p[n];\n+                for (int k = n + 1; k >= 0; k -= 2) {\n+                    v = v * t2 + p[k];\n+                    if (k > 2) {\n+                        p[k - 2] = (k - 1) * p[k - 1] - (k - 3) * p[k - 3];\n+                    } else if (k == 2) {\n+                        p[0] = p[1];\n+                    }\n+                }\n+                if ((n & 0x1) == 0) {\n+                    v *= t;\n+                }\n+\n+                function[n] = v;\n+\n+            }\n+        }\n+\n+        // apply function composition\n+        compose(operand, operandOffset, function, result, resultOffset);\n+\n+    }\n+\n+    /** Compute inverse hyperbolic cosine of a derivative structure.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param result array where result must be stored (for\n+     * inverse hyperbolic cosine the result array <em>cannot</em> be the input\n+     * array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void acosh(final double[] operand, final int operandOffset,\n+                     final double[] result, final int resultOffset) {\n+\n+        // create the function value and derivatives\n+        double[] function = new double[1 + order];\n+        final double x = operand[operandOffset];\n+        function[0] = FastMath.acosh(x);\n+        if (order > 0) {\n+            // the nth order derivative of acosh has the form:\n+            // dn(acosh(x)/dxn = P_n(x) / [x^2 - 1]^((2n-1)/2)\n+            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n+            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 + 1 ...\n+            // the general recurrence relation for P_n is:\n+            // P_n(x) = (x^2-1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n+            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n+            final double[] p = new double[order];\n+            p[0] = 1;\n+            final double x2  = x * x;\n+            final double f   = 1.0 / (x2 - 1);\n+            double coeff = FastMath.sqrt(f);\n+            function[1] = coeff * p[0];\n+            for (int n = 2; n <= order; ++n) {\n+\n+                // update and evaluate polynomial P_n(x)\n+                double v = 0;\n+                p[n - 1] = (1 - n) * p[n - 2];\n+                for (int k = n - 1; k >= 0; k -= 2) {\n+                    v = v * x2 + p[k];\n+                    if (k > 2) {\n+                        p[k - 2] = (1 - k) * p[k - 1] + (k - 2 * n) * p[k - 3];\n+                    } else if (k == 2) {\n+                        p[0] = -p[1];\n+                    }\n+                }\n+                if ((n & 0x1) == 0) {\n+                    v *= x;\n+                }\n+\n+                coeff *= f;\n+                function[n] = coeff * v;\n+\n+            }\n+        }\n+\n+        // apply function composition\n+        compose(operand, operandOffset, function, result, resultOffset);\n+\n+    }\n+\n+    /** Compute inverse hyperbolic sine of a derivative structure.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param result array where result must be stored (for\n+     * inverse hyperbolic sine the result array <em>cannot</em> be the input\n+     * array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void asinh(final double[] operand, final int operandOffset,\n+                     final double[] result, final int resultOffset) {\n+\n+        // create the function value and derivatives\n+        double[] function = new double[1 + order];\n+        final double x = operand[operandOffset];\n+        function[0] = FastMath.asinh(x);\n+        if (order > 0) {\n+            // the nth order derivative of asinh has the form:\n+            // dn(asinh(x)/dxn = P_n(x) / [x^2 + 1]^((2n-1)/2)\n+            // where P_n(x) is a degree n-1 polynomial with same parity as n-1\n+            // P_1(x) = 1, P_2(x) = -x, P_3(x) = 2x^2 - 1 ...\n+            // the general recurrence relation for P_n is:\n+            // P_n(x) = (x^2+1) P_(n-1)'(x) - (2n-3) x P_(n-1)(x)\n+            // as per polynomial parity, we can store coefficients of both P_(n-1) and P_n in the same array\n+            final double[] p = new double[order];\n+            p[0] = 1;\n+            final double x2    = x * x;\n+            final double f     = 1.0 / (1 + x2);\n+            double coeff = FastMath.sqrt(f);\n+            function[1] = coeff * p[0];\n+            for (int n = 2; n <= order; ++n) {\n+\n+                // update and evaluate polynomial P_n(x)\n+                double v = 0;\n+                p[n - 1] = (1 - n) * p[n - 2];\n+                for (int k = n - 1; k >= 0; k -= 2) {\n+                    v = v * x2 + p[k];\n+                    if (k > 2) {\n+                        p[k - 2] = (k - 1) * p[k - 1] + (k - 2 * n) * p[k - 3];\n+                    } else if (k == 2) {\n+                        p[0] = p[1];\n+                    }\n+                }\n+                if ((n & 0x1) == 0) {\n+                    v *= x;\n+                }\n+\n+                coeff *= f;\n+                function[n] = coeff * v;\n+\n+            }\n+        }\n+\n+        // apply function composition\n+        compose(operand, operandOffset, function, result, resultOffset);\n+\n+    }\n+\n+    /** Compute inverse hyperbolic tangent of a derivative structure.\n+     * @param operand array holding the operand\n+     * @param operandOffset offset of the operand in its array\n+     * @param result array where result must be stored (for\n+     * inverse hyperbolic tangent the result array <em>cannot</em> be the input\n+     * array)\n+     * @param resultOffset offset of the result in its array\n+     */\n+    public void atanh(final double[] operand, final int operandOffset,\n+                      final double[] result, final int resultOffset) {\n+\n+        // create the function value and derivatives\n+        double[] function = new double[1 + order];\n+        final double x = operand[operandOffset];\n+        function[0] = FastMath.atanh(x);\n+        if (order > 0) {\n+            // the nth order derivative of atanh has the form:\n+            // dn(atanh(x)/dxn = Q_n(x) / (1 - x^2)^n\n+            // where Q_n(x) is a degree n-1 polynomial with same parity as n-1\n+            // Q_1(x) = 1, Q_2(x) = 2x, Q_3(x) = 6x^2 + 2 ...\n+            // the general recurrence relation for Q_n is:\n+            // Q_n(x) = (1-x^2) Q_(n-1)'(x) + 2(n-1) x Q_(n-1)(x)\n+            // as per polynomial parity, we can store coefficients of both Q_(n-1) and Q_n in the same array\n+            final double[] q = new double[order];\n+            q[0] = 1;\n+            final double x2 = x * x;\n+            final double f  = 1.0 / (1 - x2);\n+            double coeff = f;\n+            function[1] = coeff * q[0];\n+            for (int n = 2; n <= order; ++n) {\n+\n+                // update and evaluate polynomial Q_n(x)\n+                double v = 0;\n+                q[n - 1] = n * q[n - 2];\n+                for (int k = n - 1; k >= 0; k -= 2) {\n+                    v = v * x2 + q[k];\n+                    if (k > 2) {\n+                        q[k - 2] = (k - 1) * q[k - 1] + (2 * n - k + 1) * q[k - 3];\n+                    } else if (k == 2) {\n+                        q[0] = q[1];\n+                    }\n+                }\n+                if ((n & 0x1) == 0) {\n+                    v *= x;\n+                }\n+\n+                coeff *= f;\n+                function[n] = coeff * v;\n+\n+            }\n+        }\n+\n+        // apply function composition\n+        compose(operand, operandOffset, function, result, resultOffset);\n+\n+    }\n+\n     /** Compute composition of a derivative structure by a function.\n      * @param operand array holding the operand\n      * @param operandOffset offset of the operand in its array\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n     }\n \n     /** Arc tangent operation.\n-     * @return tan(this)\n+     * @return atan(this)\n      */\n     public DerivativeStructure atan() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n         y.compiler.checkCompatibility(x.compiler);\n         final DerivativeStructure result = new DerivativeStructure(y.compiler);\n         y.compiler.atan2(y.data, 0, x.data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** Hyperbolic cosine operation.\n+     * @return cosh(this)\n+     */\n+    public DerivativeStructure cosh() {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.cosh(data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** Hyperbolic sine operation.\n+     * @return sinh(this)\n+     */\n+    public DerivativeStructure sinh() {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.sinh(data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** Hyperbolic tangent operation.\n+     * @return tanh(this)\n+     */\n+    public DerivativeStructure tanh() {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.tanh(data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** Inverse hyperbolic cosine operation.\n+     * @return acosh(this)\n+     */\n+    public DerivativeStructure acosh() {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.acosh(data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** Inverse hyperbolic sine operation.\n+     * @return asin(this)\n+     */\n+    public DerivativeStructure asinh() {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.asinh(data, 0, result.data, 0);\n+        return result;\n+    }\n+\n+    /** Inverse hyperbolic  tangent operation.\n+     * @return atanh(this)\n+     */\n+    public DerivativeStructure atanh() {\n+        final DerivativeStructure result = new DerivativeStructure(compiler);\n+        compiler.atanh(data, 0, result.data, 0);\n         return result;\n     }\n \n--- a/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n+++ b/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n     }\n \n     @Test\n+    public void testSinhDefinition() {\n+        double[] epsilon = new double[] { 3.0e-16, 3.0e-16, 5.0e-16, 2.0e-15, 6.0e-15 };\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                DerivativeStructure sinh1 = dsX.exp().subtract(dsX.exp().reciprocal()).multiply(0.5);\n+                DerivativeStructure sinh2 = dsX.sinh();\n+                DerivativeStructure zero = sinh1.subtract(sinh2);\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testCoshDefinition() {\n+        double[] epsilon = new double[] { 3.0e-16, 3.0e-16, 5.0e-16, 2.0e-15, 6.0e-15 };\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                DerivativeStructure cosh1 = dsX.exp().add(dsX.exp().reciprocal()).multiply(0.5);\n+                DerivativeStructure cosh2 = dsX.cosh();\n+                DerivativeStructure zero = cosh1.subtract(cosh2);\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTanhDefinition() {\n+        double[] epsilon = new double[] { 3.0e-16, 5.0e-16, 7.0e-16, 3.0e-15, 2.0e-14 };\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                DerivativeStructure tanh1 = dsX.exp().subtract(dsX.exp().reciprocal()).divide(dsX.exp().add(dsX.exp().reciprocal()));\n+                DerivativeStructure tanh2 = dsX.tanh();\n+                DerivativeStructure zero = tanh1.subtract(tanh2);\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(0, zero.getPartialDerivative(n), epsilon[n]);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testSinhAsinh() {\n+        double[] epsilon = new double[] { 3.0e-16, 3.0e-16, 4.0e-16, 7.0e-16, 3.0e-15, 8.0e-15 };\n+        for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                DerivativeStructure rebuiltX = dsX.sinh().asinh();\n+                DerivativeStructure zero = rebuiltX.subtract(dsX);\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testCoshAcosh() {\n+        double[] epsilon = new double[] { 2.0e-15, 1.0e-14, 2.0e-13, 6.0e-12, 3.0e-10, 2.0e-8 };\n+        for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                DerivativeStructure rebuiltX = dsX.cosh().acosh();\n+                DerivativeStructure zero = rebuiltX.subtract(dsX);\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testTanhAtanh() {\n+        double[] epsilon = new double[] { 3.0e-16, 2.0e-16, 7.0e-16, 4.0e-15, 3.0e-14, 4.0e-13 };\n+        for (int maxOrder = 0; maxOrder < 6; ++maxOrder) {\n+            for (double x = 0.1; x < 1.2; x += 0.001) {\n+                DerivativeStructure dsX = new DerivativeStructure(1, maxOrder, 0, x);\n+                DerivativeStructure rebuiltX = dsX.tanh().atanh();\n+                DerivativeStructure zero = rebuiltX.subtract(dsX);\n+                for (int n = 0; n <= maxOrder; ++n) {\n+                    Assert.assertEquals(0.0, zero.getPartialDerivative(n), epsilon[n]);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n     public void testCompositionOneVariableY() {\n         double epsilon = 1.0e-13;\n         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {", "timestamp": 1344954350, "metainfo": ""}