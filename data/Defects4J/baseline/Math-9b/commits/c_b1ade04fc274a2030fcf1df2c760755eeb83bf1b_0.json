{"sha": "b1ade04fc274a2030fcf1df2c760755eeb83bf1b", "log": "PR: 35904 Changed rounding methods to not rely on BigDecimal conversions which was causing numerical error.  ", "commit": "\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n /*\n- * Copyright 2003-2005 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n- *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+ * Copyright 2003-2005 The Apache Software Foundation. Licensed under the Apache\n+ * License, Version 2.0 (the \"License\"); you may not use this file except in\n+ * compliance with the License. You may obtain a copy of the License at\n+ * http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law\n+ * or agreed to in writing, software distributed under the License is\n+ * distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the specific language\n+ * governing permissions and limitations under the License.\n  */\n \n package org.apache.commons.math.util;\n \n /**\n  * Some useful additions to the built-in functions in {@link Math}.\n- *\n- * @version $Revision$ $Date$\n+ * \n+ * @version $Revision$ $Date: 2005-07-30 02:25:26 -0500 (Sat, 30 Jul\n+ *          2005) $\n  */\n public final class MathUtils {\n-    \n+\n+    /** -1.0 cast as a byte. */\n+    private static final byte  NB = (byte)-1;\n+\n+    /** -1.0 cast as a short. */\n+    private static final short NS = (short)-1;\n+\n+    /** 1.0 cast as a byte. */\n+    private static final byte  PB = (byte)1;\n+\n+    /** 1.0 cast as a short. */\n+    private static final short PS = (short)1;\n+\n     /** 0.0 cast as a byte. */\n-    private static final byte ZB = (byte) 0;\n-    \n-    /** -1.0 cast as a byte. */\n-    private static final byte NB = (byte) -1;\n-    \n-    /** 1.0 cast as a byte. */\n-    private static final byte PB = (byte) 1;\n-    \n+    private static final byte  ZB = (byte)0;\n+\n     /** 0.0 cast as a short. */\n-    private static final short ZS = (short) 0;\n-    \n-    /** -1.0 cast as a short. */\n-    private static final short NS = (short) -1;\n-    \n-    /** 1.0 cast as a short. */\n-    private static final short PS = (short) 1;\n-    \n+    private static final short ZS = (short)0;\n+\n     /**\n      * Private Constructor\n      */\n     private MathUtils() {\n-    }\n-    \n-    /**\n-     * Round the given value to the specified number of decimal places.  The\n-     * value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n-     * @param x the value to round.\n-     * @param scale the number of digits to the right of the decimal point.\n-     * @return the rounded value.\n-     * @since 1.1\n-     */\n-    public static double round(double x, int scale) {\n-        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n-    }\n-\n-    /**\n-     * Round the given value to the specified number of decimal places.  The\n-     * value is rounded using the given method which is any method defined in\n-     * {@link BigDecimal}.\n-     * @param x the value to round.\n-     * @param scale the number of digits to the right of the decimal point.\n-     * @param roundingMethod the rounding method as defined in\n-     *        {@link BigDecimal}. \n-     * @return the rounded value.\n-     * @since 1.1\n-     */\n-    public static double round(\n-        double x, int scale, int roundingMethod)\n-    {\n-        return (new BigDecimal(new Double(x).toString()).setScale(scale, roundingMethod))\n-            .doubleValue();\n-    }\n-    \n-    /**\n-     * Round the given value to the specified number of decimal places.  The\n-     * value is rounding using the {@link BigDecimal#ROUND_HALF_UP} method.\n-     * @param x the value to round.\n-     * @param scale the number of digits to the right of the decimal point.\n-     * @return the rounded value.\n-     * @since 1.1\n-     */\n-    public static float round(float x, int scale) {\n-        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n-    }\n-\n-    /**\n-     * Round the given value to the specified number of decimal places.  The\n-     * value is rounded using the given method which is any method defined in\n-     * {@link BigDecimal}.\n-     * @param x the value to round.\n-     * @param scale the number of digits to the right of the decimal point.\n-     * @param roundingMethod the rounding method as defined in\n-     *        {@link BigDecimal}. \n-     * @return the rounded value.\n-     * @since 1.1\n-     */\n-    public static float round(float x, int scale, int roundingMethod) {\n-        return (new BigDecimal(new Float(x).toString()).setScale(scale, roundingMethod)).floatValue();\n-    }\n-    \n-    /**\n-     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\">\n-     * sign</a> for double precision <code>x</code>.\n-     *\n-     * <p>\n-     * For a double value <code>x</code>, this method returns <code>+1.0</code>\n-     * if <code>x > 0</code>, <code>0.0</code> if <code>x = 0.0</code>,\n-     * and <code>-1.0</code> if <code>x < 0</code>.  Returns <code>NaN</code> \n-     * if <code>x</code> is <code>NaN</code>.\n-     *\n-     * @param x the value, a double\n-     * @return +1.0, 0.0, or -1.0, depending on the sign of x\n-     */\n-    public static double sign(final double x) {\n-        if (Double.isNaN(x)) {\n-            return Double.NaN;\n-        }\n-        return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;\n-    }\n-    \n-    /**\n-     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\">\n-     * sign</a> for float value <code>x</code>.\n-     *\n-     * <p>\n-     * For a float value x, this method returns +1.0F if x > 0, 0.0F if\n-     * x = 0.0F, and -1.0F if x < 0.  Returns <code>NaN</code> \n-     * if <code>x</code> is <code>NaN</code>.\n-     *\n-     * @param x the value, a float\n-     * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x\n-     */\n-    public static float sign(final float x) {\n-        if (Float.isNaN(x)) {\n-            return Float.NaN;\n-        }\n-        return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;\n-    }\n-    \n-    /**\n-     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\">\n-     * sign</a> for byte value <code>x</code>.\n-     *\n-     * <p>\n-     * For a byte value x, this method returns (byte)(+1) if x > 0, (byte)(0)\n-     * if x = 0, and (byte)(-1) if x < 0.\n-     *\n-     * @param x the value, a byte\n-     * @return (byte)(+1), (byte)(0), or (byte)(-1), depending on the sign of x\n-     */\n-    public static byte sign(final byte x) {\n-        return (x == ZB) ? ZB : (x > ZB) ? PB : NB;\n-    }\n-    \n-    /**\n-     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\">\n-     * sign</a> for short value <code>x</code>.\n-     *\n-     * <p>\n-     * For a short value x, this method returns (short)(+1) if x > 0, (short)(0)\n-     * if x = 0, and (short)(-1) if x < 0.\n-     *\n-     * @param x the value, a short\n-     * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign\n-     * of x\n-     */\n-    public static short sign(final short x) {\n-        return (x == ZS) ? ZS : (x > ZS) ? PS : NS;\n-    }\n-    \n-    /**\n-     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\">\n-     * sign</a> for int value <code>x</code>.\n-     *\n-     * <p>\n-     * For an int value x, this method returns +1 if x > 0, 0 if x = 0,\n-     * and -1 if x < 0.\n-     *\n-     * @param x the value, an int\n-     * @return +1, 0, or -1, depending on the sign of x\n-     */\n-    public static int sign(final int x) {\n-        return (x == 0) ? 0 : (x > 0) ? 1 : -1;\n-    }\n-    \n-    /**\n-     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\">\n-     * sign</a> for long value <code>x</code>.\n-     *\n-     * <p>\n-     * For a long value x, this method returns +1L if x > 0, 0L if x = 0,\n-     * and -1L if x < 0.\n-     *\n-     * @param x the value, a long\n-     * @return +1L, 0L, or -1L, depending on the sign of x\n-     */\n-    public static long sign(final long x) {\n-        return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;\n-    }\n-    \n-    /**\n-     * For a double precision value x, this method returns +1.0 if x >= 0\n-     * and -1.0 if x < 0.   Returns <code>NaN</code> \n-     * if <code>x</code> is <code>NaN</code>.\n-     *\n-     * @param x the value, a double\n-     * @return +1.0 or -1.0, depending on the sign of x\n-     */\n-    public static double indicator(final double x) {\n-        if (Double.isNaN(x)) {\n-            return Double.NaN;\n-        }\n-        return (x >= 0.0) ? 1.0 : -1.0;\n-    }\n-    \n-    /**\n-     * For a float value x, this method returns +1.0F if x >= 0\n-     * and -1.0F if x < 0.   Returns <code>NaN</code> \n-     * if <code>x</code> is <code>NaN</code>.\n-     *\n-     * @param x the value, a float\n-     * @return +1.0F or -1.0F, depending on the sign of x\n-     */\n-    public static float indicator(final float x) {\n-        if (Float.isNaN(x)) {\n-            return Float.NaN;\n-        }\n-        return (x >= 0.0F) ? 1.0F : -1.0F;\n-    }\n-    \n-    /**\n-     * For a byte value x, this method returns (byte)(+1) if x >= 0\n-     * and (byte)(-1) if x < 0.\n-     *\n-     * @param x the value, a byte\n-     * @return (byte)(+1) or (byte)(-1), depending on the sign of x\n-     */\n-    public static byte indicator(final byte x) {\n-        return (x >= ZB) ? PB : NB;\n-    }\n-    \n-    /**\n-     * For a short value x, this method returns (short)(+1) if x >= 0\n-     * and (short)(-1) if x < 0.\n-     *\n-     * @param x the value, a short\n-     * @return (short)(+1) or (short)(-1), depending on the sign of x\n-     */\n-    public static short indicator(final short x) {\n-        return (x >= ZS) ? PS : NS;\n-    }\n-    \n-    /**\n-     * For an int value x, this method returns +1 if x >= 0\n-     * and -1 if x < 0.\n-     *\n-     * @param x the value, an int\n-     * @return +1 or -1, depending on the sign of x\n-     */\n-    public static int indicator(final int x) {\n-        return (x >= 0) ? 1 : -1;\n-    }\n-    \n-    /**\n-     * For a long value x, this method returns +1L if x >= 0\n-     * and -1L if x < 0.\n-     *\n-     * @param x the value, a long\n-     * @return +1L or -1L, depending on the sign of x\n-     */\n-    public static long indicator(final long x) {\n-        return (x >= 0L) ? 1L : -1L;\n-    }\n-    \n-    /**\n-     * Returns an exact representation of the\n-     * <a href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\">\n-     * Binomial Coefficient</a>,  \"<code>n choose k</code>\",\n-     * the number of <code>k</code>-element subsets that can be selected from\n-     * an <code>n</code>-element set.\n-     * <p>\n-     * <Strong>Preconditions</strong>:<ul>\n+        super();\n+    }\n+\n+    /**\n+     * Add two integers, checking for overflow.\n+     * \n+     * @param x an addend\n+     * @param y an addend\n+     * @return the sum <code>x+y</code>\n+     * @throws ArithmeticException if the result can not be represented as an\n+     *         int\n+     * @since 1.1\n+     */\n+    public static int addAndCheck(int x, int y) {\n+        long s = (long)x + (long)y;\n+        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n+            throw new ArithmeticException(\"overflow: add\");\n+        }\n+        return (int)s;\n+    }\n+\n+    /**\n+     * Returns an exact representation of the <a\n+     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n+     * Coefficient</a>, \"<code>n choose k</code>\", the number of\n+     * <code>k</code>-element subsets that can be selected from an\n+     * <code>n</code>-element set.\n+     * <p>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n      * <li> <code>0 <= k <= n </code> (otherwise\n-     *      <code>IllegalArgumentException</code> is thrown)</li>\n-     * <li> The result is small enough to fit into a <code>long</code>.  The\n-     *      largest value of <code>n</code> for which all coefficients are\n-     *      <code> < Long.MAX_VALUE</code> is 66.  If the computed value\n-     *      exceeds <code>Long.MAX_VALUE</code> an <code>ArithMeticException\n-     *      </code> is thrown.</li>\n+     * <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li> The result is small enough to fit into a <code>long</code>. The\n+     * largest value of <code>n</code> for which all coefficients are\n+     * <code> < Long.MAX_VALUE</code> is 66. If the computed value exceeds\n+     * <code>Long.MAX_VALUE</code> an <code>ArithMeticException\n+     *      </code> is\n+     * thrown.</li>\n      * </ul>\n-     *\n+     * \n      * @param n the size of the set\n      * @param k the size of the subsets to be counted\n      * @return <code>n choose k</code>\n     public static long binomialCoefficient(final int n, final int k) {\n         if (n < k) {\n             throw new IllegalArgumentException(\n-            \"must have n >= k for binomial coefficient (n,k)\");\n+                \"must have n >= k for binomial coefficient (n,k)\");\n         }\n         if (n < 0) {\n             throw new IllegalArgumentException(\n-            \"must have n >= 0 for binomial coefficient (n,k)\");\n+                \"must have n >= 0 for binomial coefficient (n,k)\");\n         }\n         if ((n == k) || (k == 0)) {\n             return 1;\n         if ((k == 1) || (k == n - 1)) {\n             return n;\n         }\n-        \n+\n         long result = Math.round(binomialCoefficientDouble(n, k));\n         if (result == Long.MAX_VALUE) {\n             throw new ArithmeticException(\n-            \"result too large to represent in a long integer\");\n+                \"result too large to represent in a long integer\");\n         }\n         return result;\n     }\n-    \n-    /**\n-     * Returns a <code>double</code> representation of the\n-     * <a href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\">\n-     * Binomial Coefficient</a>,  \"<code>n choose k</code>\",\n-     * the number of <code>k</code>-element subsets that can be selected from\n-     * an <code>n</code>-element set.\n-     * <p>\n-     * <Strong>Preconditions</strong>:<ul>\n+\n+    /**\n+     * Returns a <code>double</code> representation of the <a\n+     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n+     * Coefficient</a>, \"<code>n choose k</code>\", the number of\n+     * <code>k</code>-element subsets that can be selected from an\n+     * <code>n</code>-element set.\n+     * <p>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n      * <li> <code>0 <= k <= n </code> (otherwise\n-     *      <code>IllegalArgumentException</code> is thrown)</li>\n-     * <li> The result is small enough to fit into a <code>double</code>.\n-     *      The largest value of <code>n</code> for which all coefficients are\n-     *      < Double.MAX_VALUE is 1029.  If the computed value exceeds\n-     *      Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>\n+     * <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li> The result is small enough to fit into a <code>double</code>. The\n+     * largest value of <code>n</code> for which all coefficients are <\n+     * Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE,\n+     * Double.POSITIVE_INFINITY is returned</li>\n      * </ul>\n-     *\n+     * \n      * @param n the size of the set\n      * @param k the size of the subsets to be counted\n      * @return <code>n choose k</code>\n     public static double binomialCoefficientDouble(final int n, final int k) {\n         return Math.floor(Math.exp(binomialCoefficientLog(n, k)) + 0.5);\n     }\n-    \n-    /**\n-     * Returns the natural <code>log</code> of the\n-     * <a href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\">\n-     * Binomial Coefficient</a>,  \"<code>n choose k</code>\",\n-     * the number of <code>k</code>-element subsets that can be selected from\n-     * an <code>n</code>-element set.\n-     * <p>\n-     * <Strong>Preconditions</strong>:<ul>\n+\n+    /**\n+     * Returns the natural <code>log</code> of the <a\n+     * href=\"http://mathworld.wolfram.com/BinomialCoefficient.html\"> Binomial\n+     * Coefficient</a>, \"<code>n choose k</code>\", the number of\n+     * <code>k</code>-element subsets that can be selected from an\n+     * <code>n</code>-element set.\n+     * <p>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n      * <li> <code>0 <= k <= n </code> (otherwise\n-     *      <code>IllegalArgumentException</code> is thrown)</li>\n+     * <code>IllegalArgumentException</code> is thrown)</li>\n      * </ul>\n-     *\n+     * \n      * @param n the size of the set\n      * @param k the size of the subsets to be counted\n      * @return <code>n choose k</code>\n     public static double binomialCoefficientLog(final int n, final int k) {\n         if (n < k) {\n             throw new IllegalArgumentException(\n-            \"must have n >= k for binomial coefficient (n,k)\");\n+                \"must have n >= k for binomial coefficient (n,k)\");\n         }\n         if (n < 0) {\n             throw new IllegalArgumentException(\n-            \"must have n >= 0 for binomial coefficient (n,k)\");\n+                \"must have n >= 0 for binomial coefficient (n,k)\");\n         }\n         if ((n == k) || (k == 0)) {\n             return 0;\n         }\n         if ((k == 1) || (k == n - 1)) {\n-            return Math.log((double) n);\n+            return Math.log((double)n);\n         }\n         double logSum = 0;\n-        \n+\n         // n!/k!\n         for (int i = k + 1; i <= n; i++) {\n-            logSum += Math.log((double) i);\n-        }\n-        \n+            logSum += Math.log((double)i);\n+        }\n+\n         // divide by (n-k)!\n         for (int i = 2; i <= n - k; i++) {\n-            logSum -= Math.log((double) i);\n-        }\n-        \n+            logSum -= Math.log((double)i);\n+        }\n+\n         return logSum;\n     }\n-    \n-    /**\n-     * Returns n!.  Shorthand for <code>n</code>\n-     * <a href=\"http://mathworld.wolfram.com/Factorial.html\">\n-     * Factorial</a>, the product of the numbers <code>1,...,n</code>.\n-     *\n-     * <p>\n-     * <Strong>Preconditions</strong>:<ul>\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\">\n+     * hyperbolic cosine</a> of x.\n+     * \n+     * @param x double value for which to find the hyperbolic cosine\n+     * @return hyperbolic cosine of x\n+     */\n+    public static double cosh(double x) {\n+        return (Math.exp(x) + Math.exp(-x)) / 2.0;\n+    }\n+\n+    /**\n+     * Returns true iff both arguments are NaN or neither is NaN and they are\n+     * equal\n+     * \n+     * @param x first value\n+     * @param y second value\n+     * @return true if the values are equal or both are NaN\n+     */\n+    public static boolean equals(double x, double y) {\n+        return ((Double.isNaN(x) && Double.isNaN(y)) || x == y);\n+    }\n+\n+    /**\n+     * Returns n!. Shorthand for <code>n</code> <a\n+     * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n+     * product of the numbers <code>1,...,n</code>.\n+     * <p>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n      * <li> <code>n >= 0</code> (otherwise\n-     *      <code>IllegalArgumentException</code> is thrown)</li>\n-     * <li> The result is small enough to fit into a <code>long</code>.  The\n-     *      largest value of <code>n</code> for which <code>n!</code>\n-     *      < Long.MAX_VALUE</code> is 20.  If the computed value\n-     *      exceeds <code>Long.MAX_VALUE</code> an <code>ArithMeticException\n-     *      </code> is thrown.</li>\n+     * <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li> The result is small enough to fit into a <code>long</code>. The\n+     * largest value of <code>n</code> for which <code>n!</code> <\n+     * Long.MAX_VALUE</code> is 20. If the computed value exceeds <code>Long.MAX_VALUE</code>\n+     * an <code>ArithMeticException </code> is thrown.</li>\n      * </ul>\n      * </p>\n-     *\n+     * \n      * @param n argument\n      * @return <code>n!</code>\n      * @throws ArithmeticException if the result is too large to be represented\n         long result = Math.round(factorialDouble(n));\n         if (result == Long.MAX_VALUE) {\n             throw new ArithmeticException(\n-            \"result too large to represent in a long integer\");\n+                \"result too large to represent in a long integer\");\n         }\n         return result;\n     }\n-    \n-    /**\n-     * Returns n!.  Shorthand for <code>n</code>\n-     * <a href=\"http://mathworld.wolfram.com/Factorial.html\">\n-     * Factorial</a>, the product of the numbers <code>1,...,n</code> as a\n-     * <code>double</code>.\n-     *\n-     * <p>\n-     * <Strong>Preconditions</strong>:<ul>\n+\n+    /**\n+     * Returns n!. Shorthand for <code>n</code> <a\n+     * href=\"http://mathworld.wolfram.com/Factorial.html\"> Factorial</a>, the\n+     * product of the numbers <code>1,...,n</code> as a <code>double</code>.\n+     * <p>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n      * <li> <code>n >= 0</code> (otherwise\n-     *      <code>IllegalArgumentException</code> is thrown)</li>\n-     * <li> The result is small enough to fit into a <code>double</code>.  The\n-     *      largest value of <code>n</code> for which <code>n!</code>\n-     *      < Double.MAX_VALUE</code> is 170.  If the computed value exceeds\n-     *      Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>\n+     * <code>IllegalArgumentException</code> is thrown)</li>\n+     * <li> The result is small enough to fit into a <code>double</code>. The\n+     * largest value of <code>n</code> for which <code>n!</code> <\n+     * Double.MAX_VALUE</code> is 170. If the computed value exceeds\n+     * Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned</li>\n      * </ul>\n      * </p>\n-     *\n+     * \n      * @param n argument\n      * @return <code>n!</code>\n      * @throws IllegalArgumentException if n < 0\n         }\n         return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n     }\n-    \n+\n     /**\n      * Returns the natural logarithm of n!.\n      * <p>\n-     * <Strong>Preconditions</strong>:<ul>\n+     * <Strong>Preconditions</strong>:\n+     * <ul>\n      * <li> <code>n >= 0</code> (otherwise\n-     *      <code>IllegalArgumentException</code> is thrown)</li>\n+     * <code>IllegalArgumentException</code> is thrown)</li>\n      * </ul>\n-     *\n+     * \n      * @param n argument\n      * @return <code>n!</code>\n      * @throws IllegalArgumentException if preconditions are not met.\n         }\n         double logSum = 0;\n         for (int i = 2; i <= n; i++) {\n-            logSum += Math.log((double) i);\n+            logSum += Math.log((double)i);\n         }\n         return logSum;\n     }\n-    \n-    /**\n-     * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicCosine.html\">\n-     * hyperbolic cosine</a> of x.\n-     *\n-     * @param x double value for which to find the hyperbolic cosine\n-     * @return hyperbolic cosine of x\n-     */\n-    public static double cosh(double x) {\n-        return (Math.exp(x) + Math.exp(-x)) / 2.0;\n-    }\n-    \n-    /**\n-     * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\">\n-     * hyperbolic sine</a> of x.\n-     *\n-     * @param x double value for which to find the hyperbolic sine\n-     * @return hyperbolic sine of x\n-     */\n-    public static double sinh(double x) {\n-        return (Math.exp(x) - Math.exp(-x)) / 2.0;\n-    }\n-    \n-    /**\n-     * Returns an integer hash code representing the given double value.\n-     *\n-     * @param value  the value to be hashed\n-     * @return the hash code\n-     */\n-    public static int hash(double value) {\n-        long bits = Double.doubleToLongBits(value);\n-        return (int)(bits ^ (bits >>> 32));\n-    }\n-    \n-    /**\n-     * Returns true iff both arguments are NaN or\n-     * neither is NaN and they are equal\n-     *\n-     * @param x first value\n-     * @param y second value\n-     * @return true if the values are equal or both are NaN\n-     */\n-    public static boolean equals(double x, double y) {\n-        return ((Double.isNaN(x) && Double.isNaN(y)) || x == y);\n-    }\n-\n-    /**\n-     * Returns the least common multiple between two integer values.\n-     * \n-     * @param a the first integer value.\n-     * @param b the second integer value.\n-     * @return the least common multiple between a and b.\n-     * @throws ArithmeticException if the lcm is too large to store as an int\n-     * @since 1.1\n-     */\n-    public static int lcm(int a, int b) {\n-        return Math.abs(mulAndCheck(a / gcd(a, b) , b));\n-    }\n-\n-    /**\n-     * <p>Gets the greatest common divisor of the absolute value of\n-     * two numbers, using the \"binary gcd\" method which avoids\n-     * division and modulo operations.  See Knuth 4.5.2 algorithm B.\n-     * This algorithm is due to Josef Stein (1961).</p>\n-     *\n-     * @param u  a non-zero number\n-     * @param v  a non-zero number\n+\n+    /**\n+     * <p>\n+     * Gets the greatest common divisor of the absolute value of two numbers,\n+     * using the \"binary gcd\" method which avoids division and modulo\n+     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n+     * Stein (1961).\n+     * </p>\n+     * \n+     * @param u a non-zero number\n+     * @param v a non-zero number\n      * @return the greatest common divisor, never zero\n      * @since 1.1\n      */\n         // (i.e. we can't necessarily negate a negative number without\n         // overflow)\n         /* assert u!=0 && v!=0; */\n-        if (u>0) { u=-u; } // make u negative\n-        if (v>0) { v=-v; } // make v negative\n+        if (u > 0) {\n+            u = -u;\n+        } // make u negative\n+        if (v > 0) {\n+            v = -v;\n+        } // make v negative\n         // B1. [Find power of 2]\n-        int k=0;\n-        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n-            u/=2; v/=2; k++; // cast out twos.\n-        }\n-        if (k==31) {\n+        int k = 0;\n+        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n+                                                            // both even...\n+            u /= 2;\n+            v /= 2;\n+            k++; // cast out twos.\n+        }\n+        if (k == 31) {\n             throw new ArithmeticException(\"overflow: gcd is 2^31\");\n         }\n         // B2. Initialize: u and v have been divided by 2^k and at least\n-        //     one is odd.\n-        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n+        // one is odd.\n+        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n         // t negative: u was odd, v may be even (t replaces v)\n         // t positive: u was even, v is odd (t replaces u)\n         do {\n             /* assert u<0 && v<0; */\n             // B4/B3: cast out twos from t.\n-            while ((t&1)==0) { // while t is even..\n-                t/=2; // cast out twos\n+            while ((t & 1) == 0) { // while t is even..\n+                t /= 2; // cast out twos\n             }\n             // B5 [reset max(u,v)]\n-            if (t>0) {\n+            if (t > 0) {\n                 u = -t;\n             } else {\n                 v = t;\n             }\n             // B6/B3. at this point both u and v should be odd.\n-            t = (v - u)/2;\n+            t = (v - u) / 2;\n             // |u| larger: t positive (replace u)\n             // |v| larger: t negative (replace v)\n-        } while (t!=0);\n-        return -u*(1<<k); // gcd is u*2^k\n-    }\n-\n-    /** \n+        } while (t != 0);\n+        return -u * (1 << k); // gcd is u*2^k\n+    }\n+\n+    /**\n+     * Returns an integer hash code representing the given double value.\n+     * \n+     * @param value the value to be hashed\n+     * @return the hash code\n+     */\n+    public static int hash(double value) {\n+        long bits = Double.doubleToLongBits(value);\n+        return (int)(bits ^ (bits >>> 32));\n+    }\n+\n+    /**\n+     * For a byte value x, this method returns (byte)(+1) if x >= 0 and\n+     * (byte)(-1) if x < 0.\n+     * \n+     * @param x the value, a byte\n+     * @return (byte)(+1) or (byte)(-1), depending on the sign of x\n+     */\n+    public static byte indicator(final byte x) {\n+        return (x >= ZB) ? PB : NB;\n+    }\n+\n+    /**\n+     * For a double precision value x, this method returns +1.0 if x >= 0 and\n+     * -1.0 if x < 0. Returns <code>NaN</code> if <code>x</code> is\n+     * <code>NaN</code>.\n+     * \n+     * @param x the value, a double\n+     * @return +1.0 or -1.0, depending on the sign of x\n+     */\n+    public static double indicator(final double x) {\n+        if (Double.isNaN(x)) {\n+            return Double.NaN;\n+        }\n+        return (x >= 0.0) ? 1.0 : -1.0;\n+    }\n+\n+    /**\n+     * For a float value x, this method returns +1.0F if x >= 0 and -1.0F if x <\n+     * 0. Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.\n+     * \n+     * @param x the value, a float\n+     * @return +1.0F or -1.0F, depending on the sign of x\n+     */\n+    public static float indicator(final float x) {\n+        if (Float.isNaN(x)) {\n+            return Float.NaN;\n+        }\n+        return (x >= 0.0F) ? 1.0F : -1.0F;\n+    }\n+\n+    /**\n+     * For an int value x, this method returns +1 if x >= 0 and -1 if x < 0.\n+     * \n+     * @param x the value, an int\n+     * @return +1 or -1, depending on the sign of x\n+     */\n+    public static int indicator(final int x) {\n+        return (x >= 0) ? 1 : -1;\n+    }\n+\n+    /**\n+     * For a long value x, this method returns +1L if x >= 0 and -1L if x < 0.\n+     * \n+     * @param x the value, a long\n+     * @return +1L or -1L, depending on the sign of x\n+     */\n+    public static long indicator(final long x) {\n+        return (x >= 0L) ? 1L : -1L;\n+    }\n+\n+    /**\n+     * For a short value x, this method returns (short)(+1) if x >= 0 and\n+     * (short)(-1) if x < 0.\n+     * \n+     * @param x the value, a short\n+     * @return (short)(+1) or (short)(-1), depending on the sign of x\n+     */\n+    public static short indicator(final short x) {\n+        return (x >= ZS) ? PS : NS;\n+    }\n+\n+    /**\n+     * Returns the least common multiple between two integer values.\n+     * \n+     * @param a the first integer value.\n+     * @param b the second integer value.\n+     * @return the least common multiple between a and b.\n+     * @throws ArithmeticException if the lcm is too large to store as an int\n+     * @since 1.1\n+     */\n+    public static int lcm(int a, int b) {\n+        return Math.abs(mulAndCheck(a / gcd(a, b), b));\n+    }\n+\n+    /**\n      * Multiply two integers, checking for overflow.\n      * \n      * @param x a factor\n      * @param y a factor\n      * @return the product <code>x*y</code>\n-     * @throws ArithmeticException if the result can not be represented as\n-     *                             an int\n+     * @throws ArithmeticException if the result can not be represented as an\n+     *         int\n      * @since 1.1\n      */\n     public static int mulAndCheck(int x, int y) {\n-        long m = ((long)x)*((long)y);\n-        if (m < Integer.MIN_VALUE ||\n-                m > Integer.MAX_VALUE) {\n+        long m = ((long)x) * ((long)y);\n+        if (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\n             throw new ArithmeticException(\"overflow: mul\");\n         }\n         return (int)m;\n     }\n-    \n-    /** \n-     * Add two integers, checking for overflow.\n-     * \n-     * @param x an addend\n-     * @param y an addend\n-     * @return the sum <code>x+y</code>\n-     * @throws ArithmeticException if the result can not be represented as\n-     * an int\n-     * @since 1.1\n-     */\n-    public static int addAndCheck(int x, int y) {\n-        long s = (long)x+(long)y;\n-        if (s < Integer.MIN_VALUE ||\n-                s > Integer.MAX_VALUE) {\n-            throw new ArithmeticException(\"overflow: add\");\n-        }\n-        return (int)s;\n-    }\n-    \n-    /** \n+\n+    /**\n+     * Round the given value to the specified number of decimal places. The\n+     * value is rounded using the {@link BigDecimal#ROUND_HALF_UP} method.\n+     * \n+     * @param x the value to round.\n+     * @param scale the number of digits to the right of the decimal point.\n+     * @return the rounded value.\n+     * @since 1.1\n+     */\n+    public static double round(double x, int scale) {\n+        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n+    }\n+\n+    /**\n+     * Round the given value to the specified number of decimal places. The\n+     * value is rounded using the given method which is any method defined in\n+     * {@link BigDecimal}.\n+     * \n+     * @param x the value to round.\n+     * @param scale the number of digits to the right of the decimal point.\n+     * @param roundingMethod the rounding method as defined in\n+     *        {@link BigDecimal}.\n+     * @return the rounded value.\n+     * @since 1.1\n+     */\n+    public static double round(double x, int scale, int roundingMethod) {\n+        double sign = sign(x);\n+        double factor = Math.pow(10.0, scale) * sign;\n+        return roundUnscaled(x * factor, sign, roundingMethod) / factor;\n+    }\n+\n+    /**\n+     * Round the given value to the specified number of decimal places. The\n+     * value is rounding using the {@link BigDecimal#ROUND_HALF_UP} method.\n+     * \n+     * @param x the value to round.\n+     * @param scale the number of digits to the right of the decimal point.\n+     * @return the rounded value.\n+     * @since 1.1\n+     */\n+    public static float round(float x, int scale) {\n+        return round(x, scale, BigDecimal.ROUND_HALF_UP);\n+    }\n+\n+    /**\n+     * Round the given value to the specified number of decimal places. The\n+     * value is rounded using the given method which is any method defined in\n+     * {@link BigDecimal}.\n+     * \n+     * @param x the value to round.\n+     * @param scale the number of digits to the right of the decimal point.\n+     * @param roundingMethod the rounding method as defined in\n+     *        {@link BigDecimal}.\n+     * @return the rounded value.\n+     * @since 1.1\n+     */\n+    public static float round(float x, int scale, int roundingMethod) {\n+        float sign = sign(x);\n+        float factor = (float)Math.pow(10.0f, scale) * sign;\n+        return (float)roundUnscaled(x * factor, sign, roundingMethod) / factor;\n+    }\n+\n+    /**\n+     * Round the given non-negative, value to the \"nearest\" integer. Nearest is\n+     * determined by the rounding method specified. Rounding methods are defined\n+     * in {@link BigDecimal}.\n+     * \n+     * @param unscaled the value to round.\n+     * @param sign the sign of the original, scaled value.\n+     * @param roundingMethod the rounding method as defined in\n+     *        {@link BigDecimal}.\n+     * @return the rounded value.\n+     * @since 1.1\n+     */\n+    private static double roundUnscaled(double unscaled, double sign,\n+        int roundingMethod) {\n+        switch (roundingMethod) {\n+        case BigDecimal.ROUND_CEILING :\n+            if (sign == -1) {\n+                unscaled = Math.floor(unscaled);\n+            } else {\n+                unscaled = Math.ceil(unscaled);\n+            }\n+            break;\n+        case BigDecimal.ROUND_DOWN :\n+            unscaled = Math.floor(unscaled);\n+            break;\n+        case BigDecimal.ROUND_FLOOR :\n+            if (sign == -1) {\n+                unscaled = Math.ceil(unscaled);\n+            } else {\n+                unscaled = Math.floor(unscaled);\n+            }\n+            break;\n+        case BigDecimal.ROUND_HALF_DOWN : {\n+            double fraction = Math.abs(unscaled - Math.floor(unscaled));\n+            if (fraction > 0.5) {\n+                unscaled = Math.ceil(unscaled);\n+            } else {\n+                unscaled = Math.floor(unscaled);\n+            }\n+            break;\n+        }\n+        case BigDecimal.ROUND_HALF_EVEN : {\n+            double fraction = Math.abs(unscaled - Math.floor(unscaled));\n+            if (fraction > 0.5) {\n+                unscaled = Math.ceil(unscaled);\n+            } else if (fraction < 0.5) {\n+                unscaled = Math.floor(unscaled);\n+            } else {\n+                if (Math.floor(unscaled) / 2.0 == Math.floor(Math\n+                    .floor(unscaled) / 2.0)) { // even\n+                    unscaled = Math.floor(unscaled);\n+                } else { // odd\n+                    unscaled = Math.ceil(unscaled);\n+                }\n+            }\n+            break;\n+        }\n+        case BigDecimal.ROUND_HALF_UP : {\n+            double fraction = Math.abs(unscaled - Math.floor(unscaled));\n+            if (fraction >= 0.5) {\n+                unscaled = Math.ceil(unscaled);\n+            } else {\n+                unscaled = Math.floor(unscaled);\n+            }\n+            break;\n+        }\n+        case BigDecimal.ROUND_UNNECESSARY :\n+            if (unscaled != Math.floor(unscaled)) {\n+                throw new ArithmeticException(\"Inexact result from rounding\");\n+            }\n+            break;\n+        case BigDecimal.ROUND_UP :\n+            unscaled = Math.ceil(unscaled);\n+            break;\n+        default :\n+            throw new IllegalArgumentException(\"Invalid rounding method.\");\n+        }\n+        return unscaled;\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n+     * for byte value <code>x</code>.\n+     * <p>\n+     * For a byte value x, this method returns (byte)(+1) if x > 0, (byte)(0) if\n+     * x = 0, and (byte)(-1) if x < 0.\n+     * \n+     * @param x the value, a byte\n+     * @return (byte)(+1), (byte)(0), or (byte)(-1), depending on the sign of x\n+     */\n+    public static byte sign(final byte x) {\n+        return (x == ZB) ? ZB : (x > ZB) ? PB : NB;\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n+     * for double precision <code>x</code>.\n+     * <p>\n+     * For a double value <code>x</code>, this method returns\n+     * <code>+1.0</code> if <code>x > 0</code>, <code>0.0</code> if\n+     * <code>x = 0.0</code>, and <code>-1.0</code> if <code>x < 0</code>.\n+     * Returns <code>NaN</code> if <code>x</code> is <code>NaN</code>.\n+     * \n+     * @param x the value, a double\n+     * @return +1.0, 0.0, or -1.0, depending on the sign of x\n+     */\n+    public static double sign(final double x) {\n+        if (Double.isNaN(x)) {\n+            return Double.NaN;\n+        }\n+        return (x == 0.0) ? 0.0 : (x > 0.0) ? 1.0 : -1.0;\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n+     * for float value <code>x</code>.\n+     * <p>\n+     * For a float value x, this method returns +1.0F if x > 0, 0.0F if x =\n+     * 0.0F, and -1.0F if x < 0. Returns <code>NaN</code> if <code>x</code>\n+     * is <code>NaN</code>.\n+     * \n+     * @param x the value, a float\n+     * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x\n+     */\n+    public static float sign(final float x) {\n+        if (Float.isNaN(x)) {\n+            return Float.NaN;\n+        }\n+        return (x == 0.0F) ? 0.0F : (x > 0.0F) ? 1.0F : -1.0F;\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n+     * for int value <code>x</code>.\n+     * <p>\n+     * For an int value x, this method returns +1 if x > 0, 0 if x = 0, and -1\n+     * if x < 0.\n+     * \n+     * @param x the value, an int\n+     * @return +1, 0, or -1, depending on the sign of x\n+     */\n+    public static int sign(final int x) {\n+        return (x == 0) ? 0 : (x > 0) ? 1 : -1;\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n+     * for long value <code>x</code>.\n+     * <p>\n+     * For a long value x, this method returns +1L if x > 0, 0L if x = 0, and\n+     * -1L if x < 0.\n+     * \n+     * @param x the value, a long\n+     * @return +1L, 0L, or -1L, depending on the sign of x\n+     */\n+    public static long sign(final long x) {\n+        return (x == 0L) ? 0L : (x > 0L) ? 1L : -1L;\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/Sign.html\"> sign</a>\n+     * for short value <code>x</code>.\n+     * <p>\n+     * For a short value x, this method returns (short)(+1) if x > 0, (short)(0)\n+     * if x = 0, and (short)(-1) if x < 0.\n+     * \n+     * @param x the value, a short\n+     * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign of\n+     *         x\n+     */\n+    public static short sign(final short x) {\n+        return (x == ZS) ? ZS : (x > ZS) ? PS : NS;\n+    }\n+\n+    /**\n+     * Returns the <a href=\"http://mathworld.wolfram.com/HyperbolicSine.html\">\n+     * hyperbolic sine</a> of x.\n+     * \n+     * @param x double value for which to find the hyperbolic sine\n+     * @return hyperbolic sine of x\n+     */\n+    public static double sinh(double x) {\n+        return (Math.exp(x) - Math.exp(-x)) / 2.0;\n+    }\n+\n+    /**\n      * Subtract two integers, checking for overflow.\n      * \n      * @param x the minuend\n      * @param y the subtrahend\n      * @return the difference <code>x-y</code>\n-     * @throws ArithmeticException if the result can not be represented as\n-     * an int\n+     * @throws ArithmeticException if the result can not be represented as an\n+     *         int\n      * @since 1.1\n      */\n     public static int subAndCheck(int x, int y) {\n-        long s = (long)x-(long)y;\n-        if (s < Integer.MIN_VALUE ||\n-                s > Integer.MAX_VALUE) {\n+        long s = (long)x - (long)y;\n+        if (s < Integer.MIN_VALUE || s > Integer.MAX_VALUE) {\n             throw new ArithmeticException(\"overflow: add\");\n         }\n         return (int)s;\n--- a/src/test/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/org/apache/commons/math/util/MathUtilsTest.java\n         super(name);\n     }\n \n-    public void setUp() {\n-    }\n-\n     public static Test suite() {\n         TestSuite suite = new TestSuite(MathUtilsTest.class);\n         suite.setName(\"MathUtils Tests\");\n             // expected\n         }\n     }\n-    \n     public void testRoundFloat() {\n         float x = 1.234567890f;\n-        assertEquals(1.23f, MathUtils.round(x, 2), 0.0f);\n-        assertEquals(1.235f, MathUtils.round(x, 3), 0.0f);\n-        assertEquals(1.2346f, MathUtils.round(x, 4), 0.0f);\n-        \n+        assertEquals(1.23f, MathUtils.round(x, 2), 0.0);\n+        assertEquals(1.235f, MathUtils.round(x, 3), 0.0);\n+        assertEquals(1.2346f, MathUtils.round(x, 4), 0.0);\n         \n         // BZ 35904\n         assertEquals(30.1f, MathUtils.round(30.095f, 2), 0.0f);\n         assertEquals(50.01f,  MathUtils.round(50.005f, 2), 0.0f);\n         assertEquals(30.01f,  MathUtils.round(30.005f, 2), 0.0f);\n         assertEquals(30.65f,  MathUtils.round(30.645f, 2), 0.0f);\n-\n-        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0f);\n-        assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0f);\n-        assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0f);\n+        \n+        assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);\n+\n+        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);\n+        assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);\n+        assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);\n+        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);\n+        assertEquals(-1.234f, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);\n+        assertEquals(-1.2345f, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);\n+        \n+        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(1.234f, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(1.2345f, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n+        \n+        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        \n+        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(1.234f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.234f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(1.236f, MathUtils.round(1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.236f, MathUtils.round(-1.2355f, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        \n+        assertEquals(1.23f, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(-1.23f, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(1.235f, MathUtils.round(1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(-1.235f, MathUtils.round(-1.2345f, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        \n+        assertEquals(-1.23f, MathUtils.round(-1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n+        assertEquals(1.23f, MathUtils.round(1.23f, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n+        \n+        try {\n+            MathUtils.round(1.234f, 2, BigDecimal.ROUND_UNNECESSARY);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // success\n+        }\n+        \n+        assertEquals(1.24f, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(1.235f, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(1.2346f, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(-1.24f, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(-1.235f, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(-1.2346f, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);\n+        \n+        try {\n+            MathUtils.round(1.234f, 2, 1923);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n     }\n     \n     public void testRoundDouble() {\n         assertEquals(50.01d,  MathUtils.round(50.005d, 2), 0.0d);\n         assertEquals(30.01d,  MathUtils.round(30.005d, 2), 0.0d);\n         assertEquals(30.65d,  MathUtils.round(30.645d, 2), 0.0d);\n+        \n+        assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_CEILING), 0.0);\n+        assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_CEILING), 0.0);\n \n         assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_DOWN), 0.0);\n         assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_DOWN), 0.0);\n         assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_DOWN), 0.0);\n+        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_DOWN), 0.0);\n+        assertEquals(-1.234, MathUtils.round(-x, 3, BigDecimal.ROUND_DOWN), 0.0);\n+        assertEquals(-1.2345, MathUtils.round(-x, 4, BigDecimal.ROUND_DOWN), 0.0);\n+        \n+        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(1.234, MathUtils.round(x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(1.2345, MathUtils.round(x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_FLOOR), 0.0);\n+        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_FLOOR), 0.0);\n+        \n+        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_DOWN), 0.0);\n+        \n+        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(1.234, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.234, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(1.236, MathUtils.round(1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        assertEquals(-1.236, MathUtils.round(-1.2355, 3, BigDecimal.ROUND_HALF_EVEN), 0.0);\n+        \n+        assertEquals(1.23, MathUtils.round(x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(-1.23, MathUtils.round(-x, 2, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(1.235, MathUtils.round(1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        assertEquals(-1.235, MathUtils.round(-1.2345, 3, BigDecimal.ROUND_HALF_UP), 0.0);\n+        \n+        assertEquals(-1.23, MathUtils.round(-1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n+        assertEquals(1.23, MathUtils.round(1.23, 2, BigDecimal.ROUND_UNNECESSARY), 0.0);\n+        \n+        try {\n+            MathUtils.round(1.234, 2, BigDecimal.ROUND_UNNECESSARY);\n+            fail();\n+        } catch (ArithmeticException ex) {\n+            // success\n+        }\n+        \n+        assertEquals(1.24, MathUtils.round(x, 2, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(1.235, MathUtils.round(x, 3, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(1.2346, MathUtils.round(x, 4, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(-1.24, MathUtils.round(-x, 2, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(-1.235, MathUtils.round(-x, 3, BigDecimal.ROUND_UP), 0.0);\n+        assertEquals(-1.2346, MathUtils.round(-x, 4, BigDecimal.ROUND_UP), 0.0);\n+        \n+        try {\n+            MathUtils.round(1.234, 2, 1923);\n+            fail();\n+        } catch (IllegalArgumentException ex) {\n+            // success\n+        }\n     }\n }", "timestamp": 1123593026, "metainfo": ""}