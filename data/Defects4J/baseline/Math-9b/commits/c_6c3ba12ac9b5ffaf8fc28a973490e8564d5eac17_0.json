{"sha": "6c3ba12ac9b5ffaf8fc28a973490e8564d5eac17", "log": "Added getExponent, scalb and hypot to DerivativeStructure.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n+++ b/src/main/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructure.java\n         return negate(); // flip sign\n     }\n \n+    /**\n+     * Return the exponent of the instance value, removing the bias.\n+     * <p>\n+     * For double numbers of the form 2<sup>x</sup>, the unbiased\n+     * exponent is exactly x.\n+     * </p>\n+     * @return exponent for instance in IEEE754 representation, without bias\n+     */\n+    public int getExponent() {\n+        return FastMath.getExponent(data[0]);\n+    }\n+\n+    /**\n+     * Multiply the instance by a power of 2.\n+     * @param n power of 2\n+     * @return this &times; 2<sup>n</sup>\n+     */\n+    public DerivativeStructure scalb(final int n) {\n+        final DerivativeStructure ds = new DerivativeStructure(compiler);\n+        for (int i = 0; i < ds.data.length; ++i) {\n+            ds.data[i] = FastMath.scalb(data[i], n);\n+        }\n+        return ds;\n+    }\n+\n+    /**\n+     * Returns the hypotenuse of a triangle with sides {@code x} and {@code y}\n+     * - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)<br/>\n+     * avoiding intermediate overflow or underflow.\n+     *\n+     * <ul>\n+     * <li> If either argument is infinite, then the result is positive infinity.</li>\n+     * <li> else, if either argument is NaN then the result is NaN.</li>\n+     * </ul>\n+     *\n+     * @param x a value\n+     * @param y a value\n+     * @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)\n+     * @exception DimensionMismatchException if number of free parameters or orders are inconsistent\n+     */\n+    public static DerivativeStructure hypot(final DerivativeStructure x, final DerivativeStructure y)\n+        throws DimensionMismatchException {\n+\n+        x.compiler.checkCompatibility(y.compiler);\n+\n+        if (Double.isInfinite(x.data[0]) || Double.isInfinite(y.data[0])) {\n+            return new DerivativeStructure(x.compiler.getFreeParameters(),\n+                                           x.compiler.getFreeParameters(),\n+                                           Double.POSITIVE_INFINITY);\n+        } else if (Double.isNaN(x.data[0]) || Double.isNaN(y.data[0])) {\n+            return new DerivativeStructure(x.compiler.getFreeParameters(),\n+                                           x.compiler.getFreeParameters(),\n+                                           Double.NaN);\n+        } else {\n+\n+            final int expX = x.getExponent();\n+            final int expY = y.getExponent();\n+            if (expX > expY + 27) {\n+                // y is neglectible with respect to x\n+                return x.abs();\n+            } else if (expY > expX + 27) {\n+                // x is neglectible with respect to y\n+                return y.abs();\n+            } else {\n+\n+                // find an intermediate scale to avoid both overflow and underflow\n+                final int middleExp = (expX + expY) / 2;\n+\n+                // scale parameters without losing precision\n+                final DerivativeStructure scaledX = x.scalb(-middleExp);\n+                final DerivativeStructure scaledY = y.scalb(-middleExp);\n+\n+                // compute scaled hypotenuse\n+                final DerivativeStructure scaledH =\n+                        scaledX.multiply(scaledX).add(scaledY.multiply(scaledY)).sqrt();\n+\n+                // remove scaling\n+                return scaledH.scalb(middleExp);\n+\n+            }\n+\n+        }\n+    }\n+\n     /** {@inheritDoc} */\n     public DerivativeStructure reciprocal() {\n         final DerivativeStructure result = new DerivativeStructure(compiler);\n--- a/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n+++ b/src/test/java/org/apache/commons/math3/analysis/differentiation/DerivativeStructureTest.java\n     }\n \n     @Test\n+    public void testHypotDefinition() {\n+        double epsilon = 1.0e-20;\n+        for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {\n+            for (double x = -1.7; x < 2; x += 0.2) {\n+                DerivativeStructure dsX = new DerivativeStructure(2, maxOrder, 0, x);\n+                for (double y = -1.7; y < 2; y += 0.2) {\n+                    DerivativeStructure dsY = new DerivativeStructure(2, maxOrder, 1, y);\n+                    DerivativeStructure hypot = DerivativeStructure.hypot(dsY, dsX);\n+                    DerivativeStructure ref = dsX.multiply(dsX).add(dsY.multiply(dsY)).sqrt();\n+                    DerivativeStructure zero = hypot.subtract(ref);\n+                    for (int n = 0; n <= maxOrder; ++n) {\n+                        for (int m = 0; m <= maxOrder; ++m) {\n+                            if (n + m <= maxOrder) {\n+                                Assert.assertEquals(0, zero.getPartialDerivative(n, m), epsilon);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testHypotNoOverflow() {\n+\n+        DerivativeStructure dsX = new DerivativeStructure(2, 5, 0, +3.0e250);\n+        DerivativeStructure dsY = new DerivativeStructure(2, 5, 1, -4.0e250);\n+        DerivativeStructure hypot = DerivativeStructure.hypot(dsX, dsY);\n+        Assert.assertEquals(5.0e250, hypot.getValue(), 1.0e235);\n+        Assert.assertEquals(dsX.getValue() / hypot.getValue(), hypot.getPartialDerivative(1, 0), 1.0e-10);\n+        Assert.assertEquals(dsY.getValue() / hypot.getValue(), hypot.getPartialDerivative(0, 1), 1.0e-10);\n+\n+        DerivativeStructure sqrt  = dsX.multiply(dsX).add(dsY.multiply(dsY)).sqrt();\n+        Assert.assertTrue(Double.isInfinite(sqrt.getValue()));\n+\n+    }\n+\n+    @Test\n     public void testExp() {\n         double[] epsilon = new double[] { 1.0e-16, 1.0e-16, 1.0e-16, 1.0e-16, 1.0e-16 };\n         for (int maxOrder = 0; maxOrder < 5; ++maxOrder) {", "timestamp": 1345111646, "metainfo": ""}