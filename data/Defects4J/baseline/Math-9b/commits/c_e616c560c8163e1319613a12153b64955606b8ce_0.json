{"sha": "e616c560c8163e1319613a12153b64955606b8ce", "log": "In class o.a.c.math3.linear.SymmLQ   - Changed parameter order for the constructor of nested class State (for consistency with the constructor of SymmLQ).   - Moved some static helper methods from SymmLQ to nested class State   - Changed visibility of some static fields from private to protected in order to avoid the use of synthetic getters. See MATH-761.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/linear/SymmLQ.java\n+++ b/src/main/java/org/apache/commons/math3/linear/SymmLQ.java\n          * to contain a large multiple of {@code b}\n          * @param shift the amount to be subtracted to all diagonal elements of\n          * A\n-         */\n-        public State(final RealLinearOperator a, final RealLinearOperator minv,\n-            final RealVector b, final RealVector x, final boolean goodb,\n+         * @param delta the &delta; parameter for the default stopping criterion\n+         * @param check {@code true} if self-adjointedness of both matrix and\n+         * preconditioner should be checked\n+         */\n+        public State(final RealLinearOperator a,\n+            final RealLinearOperator minv,\n+            final RealVector b,\n+            final RealVector x,\n+            final boolean goodb,\n             final double shift,\n-            final boolean check,\n-            final double delta) {\n+            final double delta,\n+            final boolean check) {\n             this.a = a;\n             this.minv = minv;\n             this.b = b;\n             this.check = check;\n             this.delta = delta;\n             init();\n+        }\n+\n+        /**\n+         * Performs a symmetry check on the specified linear operator, and throws an\n+         * exception in case this check fails. Given a linear operator L, and a\n+         * vector x, this method checks that\n+         * x' &middot; L &middot; y = y' &middot; L &middot; x\n+         * (within a given accuracy), where y = L &middot; x.\n+         *\n+         * @param l the linear operator L\n+         * @param x the candidate vector x\n+         * @param y the candidate vector y = L &middot; x\n+         * @param z the vector z = L &middot; y\n+         * @throws NonSelfAdjointOperatorException when the test fails\n+         */\n+        private static void checkSymmetry(final RealLinearOperator l,\n+            final RealVector x, final RealVector y, final RealVector z)\n+            throws NonSelfAdjointOperatorException {\n+            final double s = y.dotProduct(y);\n+            final double t = x.dotProduct(z);\n+            final double epsa = (s + SymmLQ.MACH_PREC) * SymmLQ.CBRT_MACH_PREC;\n+            if (FastMath.abs(s - t) > epsa) {\n+                final NonSelfAdjointOperatorException e;\n+                e = new NonSelfAdjointOperatorException();\n+                final ExceptionContext context = e.getContext();\n+                context.setValue(SymmLQ.OPERATOR, l);\n+                context.setValue(SymmLQ.VECTOR1, x);\n+                context.setValue(SymmLQ.VECTOR2, y);\n+                context.setValue(SymmLQ.THRESHOLD, Double.valueOf(epsa));\n+                throw e;\n+            }\n+        }\n+\n+        /**\n+         * Throws a new {@link NonPositiveDefiniteOperatorException} with\n+         * appropriate context.\n+         *\n+         * @param l the offending linear operator\n+         * @param v the offending vector\n+         * @throws NonPositiveDefiniteOperatorException in any circumstances\n+         */\n+        private static void throwNPDLOException(final RealLinearOperator l,\n+            final RealVector v) throws NonPositiveDefiniteOperatorException {\n+            final NonPositiveDefiniteOperatorException e;\n+            e = new NonPositiveDefiniteOperatorException();\n+            final ExceptionContext context = e.getContext();\n+            context.setValue(OPERATOR, l);\n+            context.setValue(VECTOR, v);\n+            throw e;\n+        }\n+\n+        /**\n+         * A clone of the BLAS {@code DAXPY} function, which carries out the\n+         * operation y &larr; a &middot; x + y. This is for internal use only: no\n+         * dimension checks are provided.\n+         *\n+         * @param a the scalar by which {@code x} is to be multiplied\n+         * @param x the vector to be added to {@code y}\n+         * @param y the vector to be incremented\n+         */\n+        private static void daxpy(final double a, final RealVector x,\n+            final RealVector y) {\n+            final int n = x.getDimension();\n+            for (int i = 0; i < n; i++) {\n+                y.setEntry(i, a * x.getEntry(i) + y.getEntry(i));\n+            }\n+        }\n+\n+        /**\n+         * A BLAS-like function, for the operation z &larr; a &middot; x + b\n+         * &middot; y + z. This is for internal use only: no dimension checks are\n+         * provided.\n+         *\n+         * @param a the scalar by which {@code x} is to be multiplied\n+         * @param x the first vector to be added to {@code z}\n+         * @param b the scalar by which {@code y} is to be multiplied\n+         * @param y the second vector to be added to {@code z}\n+         * @param z the vector to be incremented\n+         */\n+        private static void daxpbypz(final double a, final RealVector x,\n+            final double b, final RealVector y, final RealVector z) {\n+            final int n = z.getDimension();\n+            for (int i = 0; i < n; i++) {\n+                final double zi;\n+                zi = a * x.getEntry(i) + b * y.getEntry(i) + z.getEntry(i);\n+                z.setEntry(i, zi);\n+            }\n         }\n \n         /**\n              */\n             this.r1 = this.b.copy();\n             this.y = this.minv == null ? this.b.copy() : this.minv.operate(this.r1);\n-            if ((this.minv != null) && check) {\n+            if ((this.minv != null) && this.check) {\n                 checkSymmetry(this.minv, this.r1, this.y, this.minv.operate(this.y));\n             }\n \n              */\n             final RealVector v = this.y.mapMultiply(1. / this.beta1);\n             this.y = this.a.operate(v);\n-            if (check) {\n+            if (this.check) {\n                 checkSymmetry(this.a, v, this.y, this.a.operate(this.y));\n             }\n             /*\n          * value of the state variables of {@code this} object correspond to the\n          * current iteration count {@code k}.\n          */\n-        private void update() {\n+        protected void update() {\n             final RealVector v = y.mapMultiply(1. / beta);\n             y = a.operate(v);\n             daxpbypz(-shift, v, -beta / oldb, r1, y);\n      * @version $Id$\n      */\n     private static class SymmLQEvent extends IterativeLinearSolverEvent {\n-        /*\n-         * TODO This class relies dangerously on references being transparently\n-         * updated.\n-         */\n-\n         /** Identifier. */\n         private static final long serialVersionUID = 2012012801L;\n \n     }\n \n     /** The cubic root of {@link #MACH_PREC}. */\n-    private static final double CBRT_MACH_PREC;\n+    protected static final double CBRT_MACH_PREC;\n \n     /** The machine precision. */\n-    private static final double MACH_PREC;\n+    protected static final double MACH_PREC;\n \n     /** Key for the exception context. */\n     private static final String OPERATOR = \"operator\";\n     static {\n         MACH_PREC = Math.ulp(1.);\n         CBRT_MACH_PREC = Math.cbrt(MACH_PREC);\n-    }\n-\n-    /**\n-     * Performs a symmetry check on the specified linear operator, and throws an\n-     * exception in case this check fails. Given a linear operator L, and a\n-     * vector x, this method checks that\n-     * x' &middot; L &middot; y = y' &middot; L &middot; x\n-     * (within a given accuracy), where y = L &middot; x.\n-     *\n-     * @param l the linear operator L\n-     * @param x the candidate vector x\n-     * @param y the candidate vector y = L &middot; x\n-     * @param z the vector z = L &middot; y\n-     * @throws NonSelfAdjointOperatorException when the test fails\n-     */\n-    private static void checkSymmetry(final RealLinearOperator l,\n-        final RealVector x, final RealVector y, final RealVector z)\n-        throws NonSelfAdjointOperatorException {\n-        final double s = y.dotProduct(y);\n-        final double t = x.dotProduct(z);\n-        final double epsa = (s + MACH_PREC) * CBRT_MACH_PREC;\n-        if (FastMath.abs(s - t) > epsa) {\n-            final NonSelfAdjointOperatorException e;\n-            e = new NonSelfAdjointOperatorException();\n-            final ExceptionContext context = e.getContext();\n-            context.setValue(OPERATOR, l);\n-            context.setValue(VECTOR1, x);\n-            context.setValue(VECTOR2, y);\n-            context.setValue(THRESHOLD, Double.valueOf(epsa));\n-            throw e;\n-        }\n-    }\n-\n-    /**\n-     * A BLAS-like function, for the operation z &larr; a &middot; x + b\n-     * &middot; y + z. This is for internal use only: no dimension checks are\n-     * provided.\n-     *\n-     * @param a the scalar by which {@code x} is to be multiplied\n-     * @param x the first vector to be added to {@code z}\n-     * @param b the scalar by which {@code y} is to be multiplied\n-     * @param y the second vector to be added to {@code z}\n-     * @param z the vector to be incremented\n-     */\n-    private static void daxpbypz(final double a, final RealVector x,\n-        final double b, final RealVector y, final RealVector z) {\n-        final int n = z.getDimension();\n-        for (int i = 0; i < n; i++) {\n-            final double zi;\n-            zi = a * x.getEntry(i) + b * y.getEntry(i) + z.getEntry(i);\n-            z.setEntry(i, zi);\n-        }\n-    }\n-\n-    /**\n-     * A clone of the BLAS {@code DAXPY} function, which carries out the\n-     * operation y &larr; a &middot; x + y. This is for internal use only: no\n-     * dimension checks are provided.\n-     *\n-     * @param a the scalar by which {@code x} is to be multiplied\n-     * @param x the vector to be added to {@code y}\n-     * @param y the vector to be incremented\n-     */\n-    private static void daxpy(final double a, final RealVector x,\n-        final RealVector y) {\n-        final int n = x.getDimension();\n-        for (int i = 0; i < n; i++) {\n-            y.setEntry(i, a * x.getEntry(i) + y.getEntry(i));\n-        }\n-    }\n-\n-    /**\n-     * Throws a new {@link NonPositiveDefiniteOperatorException} with\n-     * appropriate context.\n-     *\n-     * @param l the offending linear operator\n-     * @param v the offending vector\n-     * @throws NonPositiveDefiniteOperatorException in any circumstances\n-     */\n-    private static void throwNPDLOException(final RealLinearOperator l,\n-        final RealVector v) throws NonPositiveDefiniteOperatorException {\n-        final NonPositiveDefiniteOperatorException e;\n-        e = new NonPositiveDefiniteOperatorException();\n-        final ExceptionContext context = e.getContext();\n-        context.setValue(OPERATOR, l);\n-        context.setValue(VECTOR, v);\n-        throw e;\n     }\n \n     /**\n         manager.resetIterationCount();\n         manager.incrementIterationCount();\n \n-        final State state = new State(a, minv, b, x, goodb, shift, check, delta);\n+        final State state = new State(a, minv, b, x, goodb, shift, delta, check);\n         final IterativeLinearSolverEvent event = new SymmLQEvent(this, state);\n         if (state.beta1 == 0.) {\n             /* If b = 0 exactly, stop with x = 0. */", "timestamp": 1332139592, "metainfo": ""}