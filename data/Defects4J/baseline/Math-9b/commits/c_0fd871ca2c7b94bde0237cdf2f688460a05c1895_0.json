{"sha": "0fd871ca2c7b94bde0237cdf2f688460a05c1895", "log": "Added gcd(long, long), lcm(long, long) methods. JIRA: MATH-239.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n+++ b/src/main/java/org/apache/commons/math/MessagesResources_fr.java\n       \"n doit \\u00eatre positif pour le calcul de n!, or n = {0}\" },\n     { \"overflow: gcd({0}, {1}) is 2^31\",\n       \"d\\u00e9passement de capacit\\u00e9 : le PGCD de {0} et {1} vaut 2^31\" },\n+    { \"overflow: gcd({0}, {1}) is 2^63\",\n+      \"d\\u00e9passement de capacit\\u00e9 : le PGCD de {0} et {1} vaut 2^63\" },\n+    { \"overflow: lcm({0}, {1}) is 2^31\",\n+      \"d\\u00e9passement de capacit\\u00e9 : le MCM de {0} et {1} vaut 2^31\" },\n+    { \"overflow: lcm({0}, {1}) is 2^63\",\n+      \"d\\u00e9passement de capacit\\u00e9 : le MCM de {0} et {1} vaut 2^63\" },\n     { \"cannot raise an integral value to a negative power ({0}^{1})\",\n       \"impossible d''\\u00e9lever une valeur enti\\u00e8re \" +\n       \"\\u00e0 une puissance n\\u00e9gative ({0}^{1})\" },\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n      * @param p any number\n      * @param q any number\n      * @return the greatest common divisor, never negative\n-     * @throws ArithmeticException\n-     *             if the result cannot be represented as a nonnegative int\n-     *             value\n+     * @throws ArithmeticException if the result cannot be represented as a\n+     * nonnegative int value\n      * @since 1.1\n      */\n     public static int gcd(final int p, final int q) {\n     }\n \n     /**\n+     * <p>\n+     * Gets the greatest common divisor of the absolute value of two numbers,\n+     * using the \"binary gcd\" method which avoids division and modulo\n+     * operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef\n+     * Stein (1961).\n+     * </p>\n+     * Special cases:\n+     * <ul>\n+     * <li>The invocations\n+     * <code>gcd(Long.MIN_VALUE, Long.MIN_VALUE)</code>,\n+     * <code>gcd(Long.MIN_VALUE, 0L)</code> and\n+     * <code>gcd(0L, Long.MIN_VALUE)</code> throw an\n+     * <code>ArithmeticException</code>, because the result would be 2^63, which\n+     * is too large for a long value.</li>\n+     * <li>The result of <code>gcd(x, x)</code>, <code>gcd(0L, x)</code> and\n+     * <code>gcd(x, 0L)</code> is the absolute value of <code>x</code>, except\n+     * for the special cases above.\n+     * <li>The invocation <code>gcd(0L, 0L)</code> is the only one which returns\n+     * <code>0L</code>.</li>\n+     * </ul>\n+     * \n+     * @param u any number\n+     * @param v any number\n+     * @return the greatest common divisor, never negative\n+     * @throws ArithmeticException if the result cannot be represented as a nonnegative long\n+     * value\n+     * @since 2.1\n+     */\n+    public static long gcd(final long p, final long q) {\n+        long u = p;\n+        long v = q;\n+        if ((u == 0) || (v == 0)) {\n+            if ((u == Long.MIN_VALUE) || (v == Long.MIN_VALUE)){\n+                throw MathRuntimeException.createArithmeticException(\n+                        \"overflow: gcd({0}, {1}) is 2^63\",\n+                        p, q);\n+            }\n+            return (Math.abs(u) + Math.abs(v));\n+        }\n+        // keep u and v negative, as negative integers range down to\n+        // -2^63, while positive numbers can only be as large as 2^63-1\n+        // (i.e. we can't necessarily negate a negative number without\n+        // overflow)\n+        /* assert u!=0 && v!=0; */\n+        if (u > 0) {\n+            u = -u;\n+        } // make u negative\n+        if (v > 0) {\n+            v = -v;\n+        } // make v negative\n+        // B1. [Find power of 2]\n+        int k = 0;\n+        while ((u & 1) == 0 && (v & 1) == 0 && k < 63) { // while u and v are\n+                                                            // both even...\n+            u /= 2;\n+            v /= 2;\n+            k++; // cast out twos.\n+        }\n+        if (k == 63) {\n+            throw MathRuntimeException.createArithmeticException(\n+                    \"overflow: gcd({0}, {1}) is 2^63\",\n+                    p, q);\n+        }\n+        // B2. Initialize: u and v have been divided by 2^k and at least\n+        // one is odd.\n+        long t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n+        // t negative: u was odd, v may be even (t replaces v)\n+        // t positive: u was even, v is odd (t replaces u)\n+        do {\n+            /* assert u<0 && v<0; */\n+            // B4/B3: cast out twos from t.\n+            while ((t & 1) == 0) { // while t is even..\n+                t /= 2; // cast out twos\n+            }\n+            // B5 [reset max(u,v)]\n+            if (t > 0) {\n+                u = -t;\n+            } else {\n+                v = t;\n+            }\n+            // B6/B3. at this point both u and v should be odd.\n+            t = (v - u) / 2;\n+            // |u| larger: t positive (replace u)\n+            // |v| larger: t negative (replace v)\n+        } while (t != 0);\n+        return -u * (1L << k); // gcd is u*2^k\n+    }\n+\n+    /**\n      * Returns an integer hash code representing the given double value.\n      *\n      * @param value the value to be hashed\n             return 0;\n         }\n         int lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n-        if (lcm == Integer.MIN_VALUE){\n-            throw new ArithmeticException(\"overflow: lcm is 2^31\");\n+        if (lcm == Integer.MIN_VALUE) {\n+            throw MathRuntimeException.createArithmeticException(\n+                \"overflow: lcm({0}, {1}) is 2^31\",\n+                a, b);\n+        }\n+        return lcm;\n+    }\n+\n+    /**\n+     * <p>\n+     * Returns the least common multiple of the absolute value of two numbers,\n+     * using the formula <code>lcm(a,b) = (a / gcd(a,b)) * b</code>.\n+     * </p>\n+     * Special cases:\n+     * <ul>\n+     * <li>The invocations <code>lcm(Long.MIN_VALUE, n)</code> and\n+     * <code>lcm(n, Long.MIN_VALUE)</code>, where <code>abs(n)</code> is a\n+     * power of 2, throw an <code>ArithmeticException</code>, because the result\n+     * would be 2^63, which is too large for an int value.</li>\n+     * <li>The result of <code>lcm(0L, x)</code> and <code>lcm(x, 0L)</code> is\n+     * <code>0L</code> for any <code>x</code>.\n+     * </ul>\n+     * \n+     * @param a any number\n+     * @param b any number\n+     * @return the least common multiple, never negative\n+     * @throws ArithmeticException if the result cannot be represented as a nonnegative long\n+     * value\n+     * @since 2.1\n+     */\n+    public static long lcm(long a, long b) {\n+        if (a==0 || b==0){\n+            return 0;\n+        }\n+        long lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\n+        if (lcm == Long.MIN_VALUE){\n+            throw MathRuntimeException.createArithmeticException(\n+                \"overflow: lcm({0}, {1}) is 2^63\",\n+                a, b);\n         }\n         return lcm;\n     }\n--- a/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n+++ b/src/test/java/org/apache/commons/math/util/MathUtilsTest.java\n         }\n     }\n \n+    public void  testGcdLong(){\n+        long a = 30;\n+        long b = 50;\n+        long c = 77;\n+\n+        assertEquals(0, MathUtils.gcd(0L, 0));\n+\n+        assertEquals(b, MathUtils.gcd(0, b));\n+        assertEquals(a, MathUtils.gcd(a, 0));\n+        assertEquals(b, MathUtils.gcd(0, -b));\n+        assertEquals(a, MathUtils.gcd(-a, 0));\n+\n+        assertEquals(10, MathUtils.gcd(a, b));\n+        assertEquals(10, MathUtils.gcd(-a, b));\n+        assertEquals(10, MathUtils.gcd(a, -b));\n+        assertEquals(10, MathUtils.gcd(-a, -b));\n+\n+        assertEquals(1, MathUtils.gcd(a, c));\n+        assertEquals(1, MathUtils.gcd(-a, c));\n+        assertEquals(1, MathUtils.gcd(a, -c));\n+        assertEquals(1, MathUtils.gcd(-a, -c));\n+\n+        assertEquals(3L * (1L<<45), MathUtils.gcd(3L * (1L<<50), 9L * (1L<<45)));\n+\n+        assertEquals(1L<<45, MathUtils.gcd(1L<<45, Long.MIN_VALUE));\n+\n+        assertEquals(Long.MAX_VALUE, MathUtils.gcd(Long.MAX_VALUE, 0L));\n+        assertEquals(Long.MAX_VALUE, MathUtils.gcd(-Long.MAX_VALUE, 0L));\n+        assertEquals(1, MathUtils.gcd(60247241209L, 153092023L));\n+        try {\n+            // gcd(Long.MIN_VALUE, 0) > Long.MAX_VALUE\n+            MathUtils.gcd(Long.MIN_VALUE, 0);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException expected) {\n+            // expected\n+        }\n+        try {\n+            // gcd(0, Long.MIN_VALUE) > Long.MAX_VALUE\n+            MathUtils.gcd(0, Long.MIN_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException expected) {\n+            // expected\n+        }\n+        try {\n+            // gcd(Long.MIN_VALUE, Long.MIN_VALUE) > Long.MAX_VALUE\n+            MathUtils.gcd(Long.MIN_VALUE, Long.MIN_VALUE);\n+            fail(\"expecting ArithmeticException\");\n+        } catch (ArithmeticException expected) {\n+            // expected\n+        }\n+    }\n+    \n+    public void testGcdConsistency() {\n+        int[] primeList = {19, 23, 53, 67, 73, 79, 101, 103, 111, 131};\n+        ArrayList<Integer> primes = new ArrayList<Integer>();\n+        for (int i = 0; i < primeList.length; i++) {\n+            primes.add(Integer.valueOf(primeList[i]));\n+        }\n+        RandomDataImpl randomData = new RandomDataImpl();\n+        for (int i = 0; i < 20; i++) {\n+            Object[] sample = randomData.nextSample(primes, 4);\n+            int p1 = ((Integer) sample[0]).intValue();\n+            int p2 = ((Integer) sample[1]).intValue();\n+            int p3 = ((Integer) sample[2]).intValue();\n+            int p4 = ((Integer) sample[3]).intValue();\n+            int i1 = p1 * p2 * p3;\n+            int i2 = p1 * p2 * p4;\n+            int gcd = p1 * p2;\n+            assertEquals(gcd, MathUtils.gcd(i1, i2));\n+            long l1 = i1;\n+            long l2 = i2;\n+            assertEquals(gcd, MathUtils.gcd(l1, l2));\n+        }\n+    }\n+\n     public void testHash() {\n         double[] testArray = {\n             Double.NaN,\n             // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n             MathUtils.lcm(Integer.MIN_VALUE, 1);\n             fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+        } catch (ArithmeticException expected) {\n             // expected\n         }\n \n             // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n             MathUtils.lcm(Integer.MIN_VALUE, 1<<20);\n             fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+        } catch (ArithmeticException expected) {\n             // expected\n         }\n \n         try {\n             MathUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1);\n             fail(\"Expecting ArithmeticException\");\n-        } catch (ArithmeticException ex) {\n+        } catch (ArithmeticException expected) {\n+            // expected\n+        }\n+    }\n+\n+    public void testLcmLong() {\n+        long a = 30;\n+        long b = 50;\n+        long c = 77;\n+\n+        assertEquals(0, MathUtils.lcm(0, b));\n+        assertEquals(0, MathUtils.lcm(a, 0));\n+        assertEquals(b, MathUtils.lcm(1, b));\n+        assertEquals(a, MathUtils.lcm(a, 1));\n+        assertEquals(150, MathUtils.lcm(a, b));\n+        assertEquals(150, MathUtils.lcm(-a, b));\n+        assertEquals(150, MathUtils.lcm(a, -b));\n+        assertEquals(150, MathUtils.lcm(-a, -b));\n+        assertEquals(2310, MathUtils.lcm(a, c));\n+\n+        assertEquals(Long.MAX_VALUE, MathUtils.lcm(60247241209L, 153092023L));\n+\n+        // Assert that no intermediate value overflows:\n+        // The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)\n+        assertEquals((1L<<50)*15, MathUtils.lcm((1L<<45)*3, (1L<<50)*5));\n+\n+        // Special case\n+        assertEquals(0L, MathUtils.lcm(0L, 0L));\n+\n+        try {\n+            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n+            MathUtils.lcm(Long.MIN_VALUE, 1);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException expected) {\n+            // expected\n+        }\n+        \n+        try {\n+            // lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\n+            MathUtils.lcm(Long.MIN_VALUE, 1<<20);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException expected) {\n+            // expected\n+        }\n+\n+        assertEquals((long) Integer.MAX_VALUE * (Integer.MAX_VALUE - 1),\n+            MathUtils.lcm((long)Integer.MAX_VALUE, Integer.MAX_VALUE - 1));\n+        try {\n+            MathUtils.lcm(Long.MAX_VALUE, Long.MAX_VALUE - 1);\n+            fail(\"Expecting ArithmeticException\");\n+        } catch (ArithmeticException expected) {\n             // expected\n         }\n     }", "timestamp": 1262214203, "metainfo": ""}