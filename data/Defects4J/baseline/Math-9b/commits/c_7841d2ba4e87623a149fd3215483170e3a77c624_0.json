{"sha": "7841d2ba4e87623a149fd3215483170e3a77c624", "log": "Merged SingularValueDecomposition and SingularValueDecompositionImpl (see MATH-662).  ", "commit": "\n--- a/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n+++ b/src/main/java/org/apache/commons/math/linear/SingularValueDecomposition.java\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n  */\n-\n package org.apache.commons.math.linear;\n \n-\n+import org.apache.commons.math.exception.NumberIsTooLargeException;\n+import org.apache.commons.math.exception.util.LocalizedFormats;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n \n /**\n- * An interface to classes that implement an algorithm to calculate the\n- * Singular Value Decomposition of a real matrix.\n+ * Calculates the compact Singular Value Decomposition of a matrix.\n  * <p>\n  * The Singular Value Decomposition of matrix A is a set of three matrices: U,\n  * &Sigma; and V such that A = U &times; &Sigma; &times; V<sup>T</sup>. Let A be\n  * n orthogonal matrix (hence V<sup>T</sup> is also orthogonal) where\n  * p=min(m,n).\n  * </p>\n- * <p>This interface is similar to the class with similar name from the\n+ * <p>This class is similar to the class with similar name from the\n  * <a href=\"http://math.nist.gov/javanumerics/jama/\">JAMA</a> library, with the\n  * following changes:</p>\n  * <ul>\n- *   <li>the <code>norm2</code> method which has been renamed as {@link #getNorm()\n+ *   <li>the {@code norm2} method which has been renamed as {@link #getNorm()\n  *   getNorm},</li>\n- *   <li>the <code>cond</code> method which has been renamed as {@link\n+ *   <li>the {@code cond} method which has been renamed as {@link\n  *   #getConditionNumber() getConditionNumber},</li>\n- *   <li>the <code>rank</code> method which has been renamed as {@link #getRank()\n+ *   <li>the {@code rank} method which has been renamed as {@link #getRank()\n  *   getRank},</li>\n  *   <li>a {@link #getUT() getUT} method has been added,</li>\n  *   <li>a {@link #getVT() getVT} method has been added,</li>\n  * @see <a href=\"http://mathworld.wolfram.com/SingularValueDecomposition.html\">MathWorld</a>\n  * @see <a href=\"http://en.wikipedia.org/wiki/Singular_value_decomposition\">Wikipedia</a>\n  * @version $Id$\n- * @since 2.0\n+ * @since 2.0 (changed to concrete class in 3.0)\n  */\n-public interface SingularValueDecomposition {\n+public class SingularValueDecomposition {\n+    /** Relative threshold for small singular values. */\n+    private static final double EPS = 0x1.0p-52;\n+    /** Absolute threshold for small singular values. */\n+    private static final double TINY = 0x1.0p-966;\n+    /** Computed singular values. */\n+    private final double[] singularValues;\n+    /** max(row dimension, column dimension). */\n+    private final int m;\n+    /** min(row dimension, column dimension). */\n+    private final int n;\n+    /** Indicator for transposed matrix. */\n+    private final boolean transposed;\n+    /** Cached value of U matrix. */\n+    private final RealMatrix cachedU;\n+    /** Cached value of transposed U matrix. */\n+    private RealMatrix cachedUt;\n+    /** Cached value of S (diagonal) matrix. */\n+    private RealMatrix cachedS;\n+    /** Cached value of V matrix. */\n+    private final RealMatrix cachedV;\n+    /** Cached value of transposed V matrix. */\n+    private RealMatrix cachedVt;\n+    /**\n+     * Tolerance value for small singular values, calculated once we have\n+     * populated \"singularValues\".\n+     **/\n+    private final double tol;\n+\n+    /**\n+     * Calculates the compact Singular Value Decomposition of the given matrix.\n+     *\n+     * @param matrix Matrix to decompose.\n+     */\n+    public SingularValueDecomposition(final RealMatrix matrix) {\n+        final double[][] A;\n+\n+         // \"m\" is always the largest dimension.\n+        if (matrix.getRowDimension() < matrix.getColumnDimension()) {\n+            transposed = true;\n+            A = matrix.transpose().getData();\n+            m = matrix.getColumnDimension();\n+            n = matrix.getRowDimension();\n+        } else {\n+            transposed = false;\n+            A = matrix.getData();\n+            m = matrix.getRowDimension();\n+            n = matrix.getColumnDimension();\n+        }\n+\n+        singularValues = new double[n];\n+        final double[][] U = new double[m][n];\n+        final double[][] V = new double[n][n];\n+        final double[] e = new double[n];\n+        final double[] work = new double[m];\n+        // Reduce A to bidiagonal form, storing the diagonal elements\n+        // in s and the super-diagonal elements in e.\n+        final int nct = FastMath.min(m - 1, n);\n+        final int nrt = FastMath.max(0, n - 2);\n+        for (int k = 0; k < FastMath.max(nct, nrt); k++) {\n+            if (k < nct) {\n+                // Compute the transformation for the k-th column and\n+                // place the k-th diagonal in s[k].\n+                // Compute 2-norm of k-th column without under/overflow.\n+                singularValues[k] = 0;\n+                for (int i = k; i < m; i++) {\n+                    singularValues[k] = FastMath.hypot(singularValues[k], A[i][k]);\n+                }\n+                if (singularValues[k] != 0) {\n+                    if (A[k][k] < 0) {\n+                        singularValues[k] = -singularValues[k];\n+                    }\n+                    for (int i = k; i < m; i++) {\n+                        A[i][k] /= singularValues[k];\n+                    }\n+                    A[k][k] += 1;\n+                }\n+                singularValues[k] = -singularValues[k];\n+            }\n+            for (int j = k + 1; j < n; j++) {\n+                if (k < nct &&\n+                    singularValues[k] != 0) {\n+                    // Apply the transformation.\n+                    double t = 0;\n+                    for (int i = k; i < m; i++) {\n+                        t += A[i][k] * A[i][j];\n+                    }\n+                    t = -t / A[k][k];\n+                    for (int i = k; i < m; i++) {\n+                        A[i][j] += t * A[i][k];\n+                    }\n+                }\n+                // Place the k-th row of A into e for the\n+                // subsequent calculation of the row transformation.\n+                e[j] = A[k][j];\n+            }\n+            if (k < nct) {\n+                // Place the transformation in U for subsequent back\n+                // multiplication.\n+                for (int i = k; i < m; i++) {\n+                    U[i][k] = A[i][k];\n+                }\n+            }\n+            if (k < nrt) {\n+                // Compute the k-th row transformation and place the\n+                // k-th super-diagonal in e[k].\n+                // Compute 2-norm without under/overflow.\n+                e[k] = 0;\n+                for (int i = k + 1; i < n; i++) {\n+                    e[k] = FastMath.hypot(e[k], e[i]);\n+                }\n+                if (e[k] != 0) {\n+                    if (e[k + 1] < 0) {\n+                        e[k] = -e[k];\n+                    }\n+                    for (int i = k + 1; i < n; i++) {\n+                        e[i] /= e[k];\n+                    }\n+                    e[k + 1] += 1;\n+                }\n+                e[k] = -e[k];\n+                if (k + 1 < m &&\n+                    e[k] != 0) {\n+                    // Apply the transformation.\n+                    for (int i = k + 1; i < m; i++) {\n+                        work[i] = 0;\n+                    }\n+                    for (int j = k + 1; j < n; j++) {\n+                        for (int i = k + 1; i < m; i++) {\n+                            work[i] += e[j] * A[i][j];\n+                        }\n+                    }\n+                    for (int j = k + 1; j < n; j++) {\n+                        final double t = -e[j] / e[k + 1];\n+                        for (int i = k + 1; i < m; i++) {\n+                            A[i][j] += t * work[i];\n+                        }\n+                    }\n+                }\n+\n+                // Place the transformation in V for subsequent\n+                // back multiplication.\n+                for (int i = k + 1; i < n; i++) {\n+                    V[i][k] = e[i];\n+                }\n+            }\n+        }\n+        // Set up the final bidiagonal matrix or order p.\n+        int p = n;\n+        if (nct < n) {\n+            singularValues[nct] = A[nct][nct];\n+        }\n+        if (m < p) {\n+            singularValues[p - 1] = 0;\n+        }\n+        if (nrt + 1 < p) {\n+            e[nrt] = A[nrt][p - 1];\n+        }\n+        e[p - 1] = 0;\n+\n+        // Generate U.\n+        for (int j = nct; j < n; j++) {\n+            for (int i = 0; i < m; i++) {\n+                U[i][j] = 0;\n+            }\n+            U[j][j] = 1;\n+        }\n+        for (int k = nct - 1; k >= 0; k--) {\n+            if (singularValues[k] != 0) {\n+                for (int j = k + 1; j < n; j++) {\n+                    double t = 0;\n+                    for (int i = k; i < m; i++) {\n+                        t += U[i][k] * U[i][j];\n+                    }\n+                    t = -t / U[k][k];\n+                    for (int i = k; i < m; i++) {\n+                        U[i][j] += t * U[i][k];\n+                    }\n+                }\n+                for (int i = k; i < m; i++) {\n+                    U[i][k] = -U[i][k];\n+                }\n+                U[k][k] = 1 + U[k][k];\n+                for (int i = 0; i < k - 1; i++) {\n+                    U[i][k] = 0;\n+                }\n+            } else {\n+                for (int i = 0; i < m; i++) {\n+                    U[i][k] = 0;\n+                }\n+                U[k][k] = 1;\n+            }\n+        }\n+\n+        // Generate V.\n+        for (int k = n - 1; k >= 0; k--) {\n+            if (k < nrt &&\n+                e[k] != 0) {\n+                for (int j = k + 1; j < n; j++) {\n+                    double t = 0;\n+                    for (int i = k + 1; i < n; i++) {\n+                        t += V[i][k] * V[i][j];\n+                    }\n+                    t = -t / V[k + 1][k];\n+                    for (int i = k + 1; i < n; i++) {\n+                        V[i][j] += t * V[i][k];\n+                    }\n+                }\n+            }\n+            for (int i = 0; i < n; i++) {\n+                V[i][k] = 0;\n+            }\n+            V[k][k] = 1;\n+        }\n+\n+        // Main iteration loop for the singular values.\n+        final int pp = p - 1;\n+        int iter = 0;\n+        while (p > 0) {\n+            int k;\n+            int kase;\n+            // Here is where a test for too many iterations would go.\n+            // This section of the program inspects for\n+            // negligible elements in the s and e arrays.  On\n+            // completion the variables kase and k are set as follows.\n+            // kase = 1     if s(p) and e[k-1] are negligible and k<p\n+            // kase = 2     if s(k) is negligible and k<p\n+            // kase = 3     if e[k-1] is negligible, k<p, and\n+            //              s(k), ..., s(p) are not negligible (qr step).\n+            // kase = 4     if e(p-1) is negligible (convergence).\n+            for (k = p - 2; k >= 0; k--) {\n+                final double threshold\n+                    = TINY + EPS * (FastMath.abs(singularValues[k]) +\n+                                    FastMath.abs(singularValues[k + 1]));\n+                if (FastMath.abs(e[k]) <= threshold) {\n+                    e[k] = 0;\n+                    break;\n+                }\n+            }\n+\n+            if (k == p - 2) {\n+                kase = 4;\n+            } else {\n+                int ks;\n+                for (ks = p - 1; ks >= k; ks--) {\n+                    if (ks == k) {\n+                        break;\n+                    }\n+                    final double t = (ks != p ? FastMath.abs(e[ks]) : 0) +\n+                        (ks != k + 1 ? FastMath.abs(e[ks - 1]) : 0);\n+                    if (FastMath.abs(singularValues[ks]) <= TINY + EPS * t) {\n+                        singularValues[ks] = 0;\n+                        break;\n+                    }\n+                }\n+                if (ks == k) {\n+                    kase = 3;\n+                } else if (ks == p - 1) {\n+                    kase = 1;\n+                } else {\n+                    kase = 2;\n+                    k = ks;\n+                }\n+            }\n+            k++;\n+            // Perform the task indicated by kase.\n+            switch (kase) {\n+                // Deflate negligible s(p).\n+                case 1: {\n+                    double f = e[p - 2];\n+                    e[p - 2] = 0;\n+                    for (int j = p - 2; j >= k; j--) {\n+                        double t = FastMath.hypot(singularValues[j], f);\n+                        final double cs = singularValues[j] / t;\n+                        final double sn = f / t;\n+                        singularValues[j] = t;\n+                        if (j != k) {\n+                            f = -sn * e[j - 1];\n+                            e[j - 1] = cs * e[j - 1];\n+                        }\n+\n+                        for (int i = 0; i < n; i++) {\n+                            t = cs * V[i][j] + sn * V[i][p - 1];\n+                            V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\n+                            V[i][j] = t;\n+                        }\n+                    }\n+                }\n+                break;\n+                // Split at negligible s(k).\n+                case 2: {\n+                    double f = e[k - 1];\n+                    e[k - 1] = 0;\n+                    for (int j = k; j < p; j++) {\n+                        double t = FastMath.hypot(singularValues[j], f);\n+                        final double cs = singularValues[j] / t;\n+                        final double sn = f / t;\n+                        singularValues[j] = t;\n+                        f = -sn * e[j];\n+                        e[j] = cs * e[j];\n+\n+                        for (int i = 0; i < m; i++) {\n+                            t = cs * U[i][j] + sn * U[i][k - 1];\n+                            U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\n+                            U[i][j] = t;\n+                        }\n+                    }\n+                }\n+                break;\n+                // Perform one qr step.\n+                case 3: {\n+                    // Calculate the shift.\n+                    final double scale = FastMath.max(FastMath.max(FastMath.max(FastMath.max(\n+                            FastMath.abs(singularValues[p - 1]), FastMath.abs(singularValues[p - 2])), FastMath.abs(e[p - 2])),\n+                            FastMath.abs(singularValues[k])), FastMath.abs(e[k]));\n+                    final double sp = singularValues[p - 1] / scale;\n+                    final double spm1 = singularValues[p - 2] / scale;\n+                    final double epm1 = e[p - 2] / scale;\n+                    final double sk = singularValues[k] / scale;\n+                    final double ek = e[k] / scale;\n+                    final double b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;\n+                    final double c = (sp * epm1) * (sp * epm1);\n+                    double shift = 0;\n+                    if (b != 0 ||\n+                        c != 0) {\n+                        shift = FastMath.sqrt(b * b + c);\n+                        if (b < 0) {\n+                            shift = -shift;\n+                        }\n+                        shift = c / (b + shift);\n+                    }\n+                    double f = (sk + sp) * (sk - sp) + shift;\n+                    double g = sk * ek;\n+                    // Chase zeros.\n+                    for (int j = k; j < p - 1; j++) {\n+                        double t = FastMath.hypot(f, g);\n+                        double cs = f / t;\n+                        double sn = g / t;\n+                        if (j != k) {\n+                            e[j - 1] = t;\n+                        }\n+                        f = cs * singularValues[j] + sn * e[j];\n+                        e[j] = cs * e[j] - sn * singularValues[j];\n+                        g = sn * singularValues[j + 1];\n+                        singularValues[j + 1] = cs * singularValues[j + 1];\n+\n+                        for (int i = 0; i < n; i++) {\n+                            t = cs * V[i][j] + sn * V[i][j + 1];\n+                            V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\n+                            V[i][j] = t;\n+                        }\n+                        t = FastMath.hypot(f, g);\n+                        cs = f / t;\n+                        sn = g / t;\n+                        singularValues[j] = t;\n+                        f = cs * e[j] + sn * singularValues[j + 1];\n+                        singularValues[j + 1] = -sn * e[j] + cs * singularValues[j + 1];\n+                        g = sn * e[j + 1];\n+                        e[j + 1] = cs * e[j + 1];\n+                        if (j < m - 1) {\n+                            for (int i = 0; i < m; i++) {\n+                                t = cs * U[i][j] + sn * U[i][j + 1];\n+                                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\n+                                U[i][j] = t;\n+                            }\n+                        }\n+                    }\n+                    e[p - 2] = f;\n+                    iter = iter + 1;\n+                }\n+                break;\n+                // Convergence.\n+                default: {\n+                    // Make the singular values positive.\n+                    if (singularValues[k] <= 0) {\n+                        singularValues[k] = singularValues[k] < 0 ? -singularValues[k] : 0;\n+\n+                        for (int i = 0; i <= pp; i++) {\n+                            V[i][k] = -V[i][k];\n+                        }\n+                    }\n+                    // Order the singular values.\n+                    while (k < pp) {\n+                        if (singularValues[k] >= singularValues[k + 1]) {\n+                            break;\n+                        }\n+                        double t = singularValues[k];\n+                        singularValues[k] = singularValues[k + 1];\n+                        singularValues[k + 1] = t;\n+                        if (k < n - 1) {\n+                            for (int i = 0; i < n; i++) {\n+                                t = V[i][k + 1];\n+                                V[i][k + 1] = V[i][k];\n+                                V[i][k] = t;\n+                            }\n+                        }\n+                        if (k < m - 1) {\n+                            for (int i = 0; i < m; i++) {\n+                                t = U[i][k + 1];\n+                                U[i][k + 1] = U[i][k];\n+                                U[i][k] = t;\n+                            }\n+                        }\n+                        k++;\n+                    }\n+                    iter = 0;\n+                    p--;\n+                }\n+                break;\n+            }\n+        }\n+\n+        // Set the small value tolerance used to calculate rank and pseudo-inverse\n+        tol = FastMath.max(m * singularValues[0] * EPS,\n+                           FastMath.sqrt(MathUtils.SAFE_MIN));\n+\n+        if (!transposed) {\n+            cachedU = MatrixUtils.createRealMatrix(U);\n+            cachedV = MatrixUtils.createRealMatrix(V);\n+        } else {\n+            cachedU = MatrixUtils.createRealMatrix(V);\n+            cachedV = MatrixUtils.createRealMatrix(U);\n+        }\n+    }\n \n     /**\n      * Returns the matrix U of the decomposition.\n      * @return the U matrix\n      * @see #getUT()\n      */\n-    RealMatrix getU();\n+    public RealMatrix getU() {\n+        // return the cached matrix\n+        return cachedU;\n+\n+    }\n \n     /**\n      * Returns the transpose of the matrix U of the decomposition.\n      * @return the U matrix (or null if decomposed matrix is singular)\n      * @see #getU()\n      */\n-    RealMatrix getUT();\n+    public RealMatrix getUT() {\n+        if (cachedUt == null) {\n+            cachedUt = getU().transpose();\n+        }\n+        // return the cached matrix\n+        return cachedUt;\n+    }\n \n     /**\n      * Returns the diagonal matrix &Sigma; of the decomposition.\n      * non-increasing order, for compatibility with Jama.</p>\n      * @return the &Sigma; matrix\n      */\n-    RealMatrix getS();\n+    public RealMatrix getS() {\n+        if (cachedS == null) {\n+            // cache the matrix for subsequent calls\n+            cachedS = MatrixUtils.createRealDiagonalMatrix(singularValues);\n+        }\n+        return cachedS;\n+    }\n \n     /**\n      * Returns the diagonal elements of the matrix &Sigma; of the decomposition.\n      * compatibility with Jama.</p>\n      * @return the diagonal elements of the &Sigma; matrix\n      */\n-    double[] getSingularValues();\n+    public double[] getSingularValues() {\n+        return singularValues.clone();\n+    }\n \n     /**\n      * Returns the matrix V of the decomposition.\n      * @return the V matrix (or null if decomposed matrix is singular)\n      * @see #getVT()\n      */\n-    RealMatrix getV();\n+    public RealMatrix getV() {\n+        // return the cached matrix\n+        return cachedV;\n+    }\n \n     /**\n      * Returns the transpose of the matrix V of the decomposition.\n      * @return the V matrix (or null if decomposed matrix is singular)\n      * @see #getV()\n      */\n-    RealMatrix getVT();\n+    public RealMatrix getVT() {\n+        if (cachedVt == null) {\n+            cachedVt = getV().transpose();\n+        }\n+        // return the cached matrix\n+        return cachedVt;\n+    }\n \n     /**\n      * Returns the n &times; n covariance matrix.\n      * @exception IllegalArgumentException if minSingularValue is larger than\n      * the largest singular value, meaning all singular values are ignored\n      */\n-    RealMatrix getCovariance(double minSingularValue);\n+    public RealMatrix getCovariance(final double minSingularValue) {\n+        // get the number of singular values to consider\n+        final int p = singularValues.length;\n+        int dimension = 0;\n+        while (dimension < p &&\n+               singularValues[dimension] >= minSingularValue) {\n+            ++dimension;\n+        }\n+\n+        if (dimension == 0) {\n+            throw new NumberIsTooLargeException(LocalizedFormats.TOO_LARGE_CUTOFF_SINGULAR_VALUE,\n+                                                minSingularValue, singularValues[0], true);\n+        }\n+\n+        final double[][] data = new double[dimension][p];\n+        getVT().walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n+            /** {@inheritDoc} */\n+            @Override\n+            public void visit(final int row, final int column,\n+                    final double value) {\n+                data[row][column] = value / singularValues[row];\n+            }\n+        }, 0, dimension - 1, 0, p - 1);\n+\n+        RealMatrix jv = new Array2DRowRealMatrix(data, false);\n+        return jv.transpose().multiply(jv);\n+    }\n \n     /**\n      * Returns the L<sub>2</sub> norm of the matrix.\n      * (i.e. the traditional euclidian norm).</p>\n      * @return norm\n      */\n-    double getNorm();\n+    public double getNorm() {\n+        return singularValues[0];\n+    }\n \n     /**\n      * Return the condition number of the matrix.\n      * @return condition number of the matrix\n      */\n-    double getConditionNumber();\n+    public double getConditionNumber() {\n+        return singularValues[0] / singularValues[n - 1];\n+    }\n+\n+    /**\n+     * Computes the inverse of the condition number.\n+     * In cases of rank deficiency, the {@link #getConditionNumber() condition\n+     * number} will become undefined.\n+     *\n+     * @return the inverse of the condition number.\n+     */\n+    public double getInverseConditionNumber() {\n+        return singularValues[n - 1] / singularValues[0];\n+    }\n \n     /**\n      * Return the effective numerical matrix rank.\n      * is the least significant bit of the largest singular value.</p>\n      * @return effective numerical matrix rank\n      */\n-    int getRank();\n+    public int getRank() {\n+        int r = 0;\n+        for (int i = 0; i < singularValues.length; i++) {\n+            if (singularValues[i] > tol) {\n+                r++;\n+            }\n+        }\n+        return r;\n+    }\n \n     /**\n      * Get a solver for finding the A &times; X = B solution in least square sense.\n      * @return a solver\n      */\n-    DecompositionSolver getSolver();\n-\n+    public DecompositionSolver getSolver() {\n+        return new Solver(singularValues, getUT(), getV(), getRank() == m, tol);\n+    }\n+\n+    /** Specialized solver. */\n+    private static class Solver implements DecompositionSolver {\n+        /** Pseudo-inverse of the initial matrix. */\n+        private final RealMatrix pseudoInverse;\n+        /** Singularity indicator. */\n+        private boolean nonSingular;\n+\n+        /**\n+         * Build a solver from decomposed matrix.\n+         *\n+         * @param singularValues Singular values.\n+         * @param uT U<sup>T</sup> matrix of the decomposition.\n+         * @param v V matrix of the decomposition.\n+         * @param nonSingular Singularity indicator.\n+         * @param tol tolerance for singular values\n+         */\n+        private Solver(final double[] singularValues, final RealMatrix uT,\n+                       final RealMatrix v, final boolean nonSingular, final double tol) {\n+            final double[][] suT = uT.getData();\n+            for (int i = 0; i < singularValues.length; ++i) {\n+                final double a;\n+                if (singularValues[i] > tol) {\n+                    a = 1 / singularValues[i];\n+                } else {\n+                    a = 0;\n+                }\n+                final double[] suTi = suT[i];\n+                for (int j = 0; j < suTi.length; ++j) {\n+                    suTi[j] *= a;\n+                }\n+            }\n+            pseudoInverse = v.multiply(new Array2DRowRealMatrix(suT, false));\n+            this.nonSingular = nonSingular;\n+        }\n+\n+        /**\n+         * Solve the linear equation A &times; X = B in least square sense.\n+         * <p>\n+         * The m&times;n matrix A may not be square, the solution X is such that\n+         * ||A &times; X - B|| is minimal.\n+         * </p>\n+         * @param b Right-hand side of the equation A &times; X = B\n+         * @return a vector X that minimizes the two norm of A &times; X - B\n+         * @throws org.apache.commons.math.exception.DimensionMismatchException\n+         * if the matrices dimensions do not match.\n+         */\n+        public RealVector solve(final RealVector b) {\n+            return pseudoInverse.operate(b);\n+        }\n+\n+        /**\n+         * Solve the linear equation A &times; X = B in least square sense.\n+         * <p>\n+         * The m&times;n matrix A may not be square, the solution X is such that\n+         * ||A &times; X - B|| is minimal.\n+         * </p>\n+         *\n+         * @param b Right-hand side of the equation A &times; X = B\n+         * @return a matrix X that minimizes the two norm of A &times; X - B\n+         * @throws org.apache.commons.math.exception.DimensionMismatchException\n+         * if the matrices dimensions do not match.\n+         */\n+        public RealMatrix solve(final RealMatrix b) {\n+            return pseudoInverse.multiply(b);\n+        }\n+\n+        /**\n+         * Check if the decomposed matrix is non-singular.\n+         *\n+         * @return {@code true} if the decomposed matrix is non-singular.\n+         */\n+        public boolean isNonSingular() {\n+            return nonSingular;\n+        }\n+\n+        /**\n+         * Get the pseudo-inverse of the decomposed matrix.\n+         *\n+         * @return the inverse matrix.\n+         */\n+        public RealMatrix getInverse() {\n+            return pseudoInverse;\n+        }\n+    }\n }\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/math/linear/SingularValueDecompositionTest.java\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.commons.math.linear;\n+\n+import java.io.BufferedReader;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.util.Random;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+\n+public class SingularValueDecompositionTest {\n+\n+    private double[][] testSquare = {\n+            { 24.0 / 25.0, 43.0 / 25.0 },\n+            { 57.0 / 25.0, 24.0 / 25.0 }\n+    };\n+\n+    private double[][] testNonSquare = {\n+        {  -540.0 / 625.0,  963.0 / 625.0, -216.0 / 625.0 },\n+        { -1730.0 / 625.0, -744.0 / 625.0, 1008.0 / 625.0 },\n+        {  -720.0 / 625.0, 1284.0 / 625.0, -288.0 / 625.0 },\n+        {  -360.0 / 625.0,  192.0 / 625.0, 1756.0 / 625.0 },\n+    };\n+\n+    private static final double normTolerance = 10e-14;\n+\n+    @Test\n+    public void testMoreRows() {\n+        final double[] singularValues = { 123.456, 2.3, 1.001, 0.999 };\n+        final int rows    = singularValues.length + 2;\n+        final int columns = singularValues.length;\n+        Random r = new Random(15338437322523l);\n+        SingularValueDecomposition svd =\n+            new SingularValueDecomposition(createTestMatrix(r, rows, columns, singularValues));\n+        double[] computedSV = svd.getSingularValues();\n+        Assert.assertEquals(singularValues.length, computedSV.length);\n+        for (int i = 0; i < singularValues.length; ++i) {\n+            Assert.assertEquals(singularValues[i], computedSV[i], 1.0e-10);\n+        }\n+    }\n+\n+    @Test\n+    public void testMoreColumns() {\n+        final double[] singularValues = { 123.456, 2.3, 1.001, 0.999 };\n+        final int rows    = singularValues.length;\n+        final int columns = singularValues.length + 2;\n+        Random r = new Random(732763225836210l);\n+        SingularValueDecomposition svd =\n+            new SingularValueDecomposition(createTestMatrix(r, rows, columns, singularValues));\n+        double[] computedSV = svd.getSingularValues();\n+        Assert.assertEquals(singularValues.length, computedSV.length);\n+        for (int i = 0; i < singularValues.length; ++i) {\n+            Assert.assertEquals(singularValues[i], computedSV[i], 1.0e-10);\n+        }\n+    }\n+\n+    /** test dimensions */\n+    @Test\n+    public void testDimensions() {\n+        RealMatrix matrix = MatrixUtils.createRealMatrix(testSquare);\n+        final int m = matrix.getRowDimension();\n+        final int n = matrix.getColumnDimension();\n+        SingularValueDecomposition svd = new SingularValueDecomposition(matrix);\n+        Assert.assertEquals(m, svd.getU().getRowDimension());\n+        Assert.assertEquals(m, svd.getU().getColumnDimension());\n+        Assert.assertEquals(m, svd.getS().getColumnDimension());\n+        Assert.assertEquals(n, svd.getS().getColumnDimension());\n+        Assert.assertEquals(n, svd.getV().getRowDimension());\n+        Assert.assertEquals(n, svd.getV().getColumnDimension());\n+\n+    }\n+\n+    /** Test based on a dimension 4 Hadamard matrix. */\n+    @Test\n+    public void testHadamard() {\n+        RealMatrix matrix = new Array2DRowRealMatrix(new double[][] {\n+                {15.0 / 2.0,  5.0 / 2.0,  9.0 / 2.0,  3.0 / 2.0 },\n+                { 5.0 / 2.0, 15.0 / 2.0,  3.0 / 2.0,  9.0 / 2.0 },\n+                { 9.0 / 2.0,  3.0 / 2.0, 15.0 / 2.0,  5.0 / 2.0 },\n+                { 3.0 / 2.0,  9.0 / 2.0,  5.0 / 2.0, 15.0 / 2.0 }\n+        }, false);\n+        SingularValueDecomposition svd = new SingularValueDecomposition(matrix);\n+        Assert.assertEquals(16.0, svd.getSingularValues()[0], 1.0e-14);\n+        Assert.assertEquals( 8.0, svd.getSingularValues()[1], 1.0e-14);\n+        Assert.assertEquals( 4.0, svd.getSingularValues()[2], 1.0e-14);\n+        Assert.assertEquals( 2.0, svd.getSingularValues()[3], 1.0e-14);\n+\n+        RealMatrix fullCovariance = new Array2DRowRealMatrix(new double[][] {\n+                {  85.0 / 1024, -51.0 / 1024, -75.0 / 1024,  45.0 / 1024 },\n+                { -51.0 / 1024,  85.0 / 1024,  45.0 / 1024, -75.0 / 1024 },\n+                { -75.0 / 1024,  45.0 / 1024,  85.0 / 1024, -51.0 / 1024 },\n+                {  45.0 / 1024, -75.0 / 1024, -51.0 / 1024,  85.0 / 1024 }\n+        }, false);\n+        Assert.assertEquals(0.0,\n+                     fullCovariance.subtract(svd.getCovariance(0.0)).getNorm(),\n+                     1.0e-14);\n+\n+        RealMatrix halfCovariance = new Array2DRowRealMatrix(new double[][] {\n+                {   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024 },\n+                {  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024 },\n+                {   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024 },\n+                {  -3.0 / 1024,   5.0 / 1024,  -3.0 / 1024,   5.0 / 1024 }\n+        }, false);\n+        Assert.assertEquals(0.0,\n+                     halfCovariance.subtract(svd.getCovariance(6.0)).getNorm(),\n+                     1.0e-14);\n+\n+    }\n+\n+    /** test A = USVt */\n+    @Test\n+    public void testAEqualUSVt() {\n+        checkAEqualUSVt(MatrixUtils.createRealMatrix(testSquare));\n+        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare));\n+        checkAEqualUSVt(MatrixUtils.createRealMatrix(testNonSquare).transpose());\n+    }\n+\n+    public void checkAEqualUSVt(final RealMatrix matrix) {\n+        SingularValueDecomposition svd = new SingularValueDecomposition(matrix);\n+        RealMatrix u = svd.getU();\n+        RealMatrix s = svd.getS();\n+        RealMatrix v = svd.getV();\n+        double norm = u.multiply(s).multiply(v.transpose()).subtract(matrix).getNorm();\n+        Assert.assertEquals(0, norm, normTolerance);\n+\n+    }\n+\n+    /** test that U is orthogonal */\n+    @Test\n+    public void testUOrthogonal() {\n+        checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)).getU());\n+        checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testNonSquare)).getU());\n+        checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getU());\n+    }\n+\n+    /** test that V is orthogonal */\n+    @Test\n+    public void testVOrthogonal() {\n+        checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)).getV());\n+        checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testNonSquare)).getV());\n+        checkOrthogonal(new SingularValueDecomposition(MatrixUtils.createRealMatrix(testNonSquare).transpose()).getV());\n+    }\n+\n+    public void checkOrthogonal(final RealMatrix m) {\n+        RealMatrix mTm = m.transpose().multiply(m);\n+        RealMatrix id  = MatrixUtils.createRealIdentityMatrix(mTm.getRowDimension());\n+        Assert.assertEquals(0, mTm.subtract(id).getNorm(), normTolerance);\n+    }\n+\n+    /** test matrices values */\n+    // This test is useless since whereas the columns of U and V are linked\n+    // together, the actual triplet (U,S,V) is not uniquely defined.\n+    public void testMatricesValues1() {\n+       SingularValueDecomposition svd =\n+            new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare));\n+        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 3.0 / 5.0, -4.0 / 5.0 },\n+                { 4.0 / 5.0,  3.0 / 5.0 }\n+        });\n+        RealMatrix sRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 3.0, 0.0 },\n+                { 0.0, 1.0 }\n+        });\n+        RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {\n+                { 4.0 / 5.0,  3.0 / 5.0 },\n+                { 3.0 / 5.0, -4.0 / 5.0 }\n+        });\n+\n+        // check values against known references\n+        RealMatrix u = svd.getU();\n+        Assert.assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);\n+        RealMatrix s = svd.getS();\n+        Assert.assertEquals(0, s.subtract(sRef).getNorm(), normTolerance);\n+        RealMatrix v = svd.getV();\n+        Assert.assertEquals(0, v.subtract(vRef).getNorm(), normTolerance);\n+\n+        // check the same cached instance is returned the second time\n+        Assert.assertTrue(u == svd.getU());\n+        Assert.assertTrue(s == svd.getS());\n+        Assert.assertTrue(v == svd.getV());\n+\n+    }\n+\n+    /** test matrices values */\n+    // This test is useless since whereas the columns of U and V are linked\n+    // together, the actual triplet (U,S,V) is not uniquely defined.\n+    public void useless_testMatricesValues2() {\n+\n+        RealMatrix uRef = MatrixUtils.createRealMatrix(new double[][] {\n+            {  0.0 / 5.0,  3.0 / 5.0,  0.0 / 5.0 },\n+            { -4.0 / 5.0,  0.0 / 5.0, -3.0 / 5.0 },\n+            {  0.0 / 5.0,  4.0 / 5.0,  0.0 / 5.0 },\n+            { -3.0 / 5.0,  0.0 / 5.0,  4.0 / 5.0 }\n+        });\n+        RealMatrix sRef = MatrixUtils.createRealMatrix(new double[][] {\n+            { 4.0, 0.0, 0.0 },\n+            { 0.0, 3.0, 0.0 },\n+            { 0.0, 0.0, 2.0 }\n+        });\n+        RealMatrix vRef = MatrixUtils.createRealMatrix(new double[][] {\n+            {  80.0 / 125.0,  -60.0 / 125.0, 75.0 / 125.0 },\n+            {  24.0 / 125.0,  107.0 / 125.0, 60.0 / 125.0 },\n+            { -93.0 / 125.0,  -24.0 / 125.0, 80.0 / 125.0 }\n+        });\n+\n+        // check values against known references\n+        SingularValueDecomposition svd =\n+            new SingularValueDecomposition(MatrixUtils.createRealMatrix(testNonSquare));\n+        RealMatrix u = svd.getU();\n+        Assert.assertEquals(0, u.subtract(uRef).getNorm(), normTolerance);\n+        RealMatrix s = svd.getS();\n+        Assert.assertEquals(0, s.subtract(sRef).getNorm(), normTolerance);\n+        RealMatrix v = svd.getV();\n+        Assert.assertEquals(0, v.subtract(vRef).getNorm(), normTolerance);\n+\n+        // check the same cached instance is returned the second time\n+        Assert.assertTrue(u == svd.getU());\n+        Assert.assertTrue(s == svd.getS());\n+        Assert.assertTrue(v == svd.getV());\n+\n+    }\n+\n+     /** test MATH-465 */\n+    @Test\n+    public void testRank() {\n+        double[][] d = { { 1, 1, 1 }, { 0, 0, 0 }, { 1, 2, 3 } };\n+        RealMatrix m = new Array2DRowRealMatrix(d);\n+        SingularValueDecomposition svd = new SingularValueDecomposition(m);\n+        Assert.assertEquals(2, svd.getRank());\n+    }\n+\n+    /** test MATH-583 */\n+    @Test\n+    public void testStability1() {\n+        RealMatrix m = new Array2DRowRealMatrix(201, 201);\n+        loadRealMatrix(m,\"matrix1.csv\");\n+        try {\n+            new SingularValueDecomposition(m);\n+        } catch (Exception e) {\n+            Assert.fail(\"Exception whilst constructing SVD\");\n+        }\n+    }\n+\n+    /** test MATH-327 */\n+    @Test\n+    public void testStability2() {\n+        RealMatrix m = new Array2DRowRealMatrix(7, 168);\n+        loadRealMatrix(m,\"matrix2.csv\");\n+        try {\n+            new SingularValueDecomposition(m);\n+        } catch (Throwable e) {\n+            Assert.fail(\"Exception whilst constructing SVD\");\n+        }\n+    }\n+\n+    private void loadRealMatrix(RealMatrix m, String resourceName) {\n+        try {\n+            DataInputStream in = new DataInputStream(getClass().getResourceAsStream(resourceName));\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in));\n+            String strLine;\n+            int row = 0;\n+            while ((strLine = br.readLine()) != null) {\n+                int col = 0;\n+                for (String entry : strLine.split(\",\")) {\n+                    m.setEntry(row, col++, Double.parseDouble(entry));\n+                }\n+                row++;\n+            }\n+            in.close();\n+        } catch (IOException e) {}\n+    }\n+\n+    /** test condition number */\n+    @Test\n+    public void testConditionNumber() {\n+        SingularValueDecomposition svd =\n+            new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare));\n+        // replace 1.0e-15 with 1.5e-15\n+        Assert.assertEquals(3.0, svd.getConditionNumber(), 1.5e-15);\n+    }\n+\n+    @Test\n+    public void testInverseConditionNumber() {\n+        SingularValueDecomposition svd =\n+            new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare));\n+        Assert.assertEquals(1.0/3.0, svd.getInverseConditionNumber(), 1.5e-15);\n+    }\n+\n+    private RealMatrix createTestMatrix(final Random r, final int rows, final int columns,\n+                                        final double[] singularValues) {\n+        final RealMatrix u =\n+            EigenDecompositionTest.createOrthogonalMatrix(r, rows);\n+        final RealMatrix d =\n+            EigenDecompositionTest.createDiagonalMatrix(singularValues, rows, columns);\n+        final RealMatrix v =\n+            EigenDecompositionTest.createOrthogonalMatrix(r, columns);\n+        return u.multiply(d).multiply(v);\n+    }\n+\n+}\n--- a/src/test/java/org/apache/commons/math/linear/SingularValueSolverTest.java\n+++ b/src/test/java/org/apache/commons/math/linear/SingularValueSolverTest.java\n     @Test\n     public void testSolveDimensionErrors() {\n         DecompositionSolver solver =\n-            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getSolver();\n+            new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[3][2]);\n         try {\n             solver.solve(b);\n                                    { 1.0, 0.0 },\n                                    { 0.0, 0.0 }\n                                });\n-        DecompositionSolver solver = new SingularValueDecompositionImpl(m).getSolver();\n+        DecompositionSolver solver = new SingularValueDecomposition(m).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n             { 11, 12 }, { 21, 22 }\n         });\n     @Test\n     public void testSolve() {\n         DecompositionSolver solver =\n-            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare)).getSolver();\n+            new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare)).getSolver();\n         RealMatrix b = MatrixUtils.createRealMatrix(new double[][] {\n                 { 1, 2, 3 }, { 0, -5, 1 }\n         });\n     /** test condition number */\n     @Test\n     public void testConditionNumber() {\n-        SingularValueDecompositionImpl svd =\n-            new SingularValueDecompositionImpl(MatrixUtils.createRealMatrix(testSquare));\n+        SingularValueDecomposition svd =\n+            new SingularValueDecomposition(MatrixUtils.createRealMatrix(testSquare));\n         // replace 1.0e-15 with 1.5e-15\n         Assert.assertEquals(3.0, svd.getConditionNumber(), 1.5e-15);\n     }\n             { 1.0, 2.0 }, { 1.0, 2.0 }\n         });\n         SingularValueDecomposition svd =\n-            new SingularValueDecompositionImpl(rm);\n+            new SingularValueDecomposition(rm);\n         RealMatrix recomposed = svd.getU().multiply(svd.getS()).multiply(svd.getVT());\n         Assert.assertEquals(0.0, recomposed.subtract(rm).getNorm(), 2.0e-15);\n     }", "timestamp": 1316841233, "metainfo": ""}