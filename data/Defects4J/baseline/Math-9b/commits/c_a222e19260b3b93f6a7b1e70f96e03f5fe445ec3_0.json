{"sha": "a222e19260b3b93f6a7b1e70f96e03f5fe445ec3", "log": "This is the first half of this pr. Commit of analysis solvers. PR: http://nagoya.apache.org/bugzilla/show_bug.cgi?id=20844 Submitted by:\tJ. Pietschman   ", "commit": "\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Provide the Brent algorithm for solving for zeros of real univariate\n+ * functions.\n+ * It will only search for one zero in the given interval.\n+ * The function is supposed to be continuous but not necessarily smooth.\n+ *  \n+ * @author pietsch at apache.org\n+ */\n+public class BrentSolver extends UnivariateRealSolverImpl {\n+\n+    private UnivariateRealFunction f;\n+\n+    public BrentSolver(UnivariateRealFunction f) {\n+        super(100, 1E-6);\n+        this.f = f;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.UnivariateRealSolver#solve(double, double)\n+     */\n+    public double solve(double min, double max) throws MathException {\n+        clearResult();\n+        // Index 0 is the old approximation for the root.\n+        // Index 1 is the last calculated approximation  for the root.\n+        // Index 2 is a bracket for the root with respect to x1.\n+        double x0 = min;\n+        double x1 = max;\n+        double y0 = f.value(x0);\n+        double y1 = f.value(x1);\n+        if ((y0 > 0) == (y1 > 0)) {\n+            throw new MathException(\"Interval doesn't bracket a zero.\");\n+        }\n+        double x2 = x0;\n+        double y2 = y0;\n+        double delta = x1 - x0;\n+        double oldDelta = delta;\n+\n+        int i = 0;\n+        while (i < maximalIterationCount) {\n+            if (Math.abs(y2) < Math.abs(y1)) {\n+                x0 = x1;\n+                x1 = x2;\n+                x2 = x0;\n+                y0 = y1;\n+                y1 = y2;\n+                y2 = y0;\n+            }\n+            if (Math.abs(y1) <= functionValueAccuracy) {\n+                // Avoid division by very small values. Assume\n+                // the iteration has converged (the problem may\n+                // still be ill conditioned)\n+                setResult(x1, i);\n+                return result;\n+            }\n+            double dx = (x2 - x1);\n+            double tolerance =\n+                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n+            if (Math.abs(dx) <= tolerance) {\n+                setResult(x1, i);\n+                return result;\n+            }\n+//          System.out.println(\n+//              \" x0=\"\n+//                  + x0\n+//                  + \" y0=\"\n+//                  + y0\n+//                  + \" x1=\"\n+//                  + x1\n+//                  + \" y1=\"\n+//                  + y1\n+//                  + \" x2=\"\n+//                  + x2+\" y2=\"+y2);\n+//            System.out.println(\" dx=\"+dx+\"   delta: \"+delta+\"   olddelta: \"+oldDelta);\n+            if (Math.abs(oldDelta) < tolerance\n+                || Math.abs(y0) <= Math.abs(y1)) {\n+//                    System.out.println(\"bisection\");\n+                // Force bisection.\n+                delta = 0.5 * dx;\n+                oldDelta = delta;\n+            } else {\n+                double r3 = y1 / y0;\n+                double p;\n+                double p1;\n+                if (x0 == x2) {\n+                    // Linear interpolation.\n+//                    System.out.println(\"linear\");\n+                    p = dx * r3;\n+                    p1 = 1.0 - r3;\n+                } else {\n+                    // Inverse quadratic interpolation.\n+//                    System.out.println(\"invers quad\");\n+                    double r1 = y0 / y2;\n+                    double r2 = y1 / y2;\n+                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n+                    p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n+                }\n+                if (p > 0.0) {\n+                    p1 = -p1;\n+                } else {\n+                    p = -p;\n+                }\n+//                System.out.println(\"  p=\"+p+\" p1=\"+p1+\" qq: \"+(1.5 * dx * p1 - Math.abs(tolerance * p1)));\n+//                System.out.println(\"  p=\"+p+\" q: \"+p1+\" ad=\"+Math.abs(0.5 * oldDelta * p1));\n+                if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1)\n+                    || p >= Math.abs(0.5 * oldDelta * p1)) {\n+                    // Inverse quadratic interpolation gives a value\n+                    // in the wrong direction, or progress is slow.\n+                    // Fall back to bisection.\n+//                    System.out.println(\"bisection fallback\");\n+                    delta = 0.5 * dx;\n+                    oldDelta = delta;\n+                } else {\n+                    oldDelta = delta;\n+                    delta = p / p1;\n+                }\n+            }\n+            // Save old X1, Y1 \n+            x0 = x1;\n+            y0 = y1;\n+            // Compute new X1, Y1\n+            if (Math.abs(delta) > tolerance) {\n+                x1 = x1 + delta;\n+            } else if (dx > 0.0) {\n+                x1 = x1 + 0.5*tolerance;\n+            } else if (dx <= 0.0) {\n+                x1 = x1 - 0.5*tolerance;\n+            }\n+            y1 = f.value(x1);\n+            if ((y1 > 0) == (y2 > 0)) {\n+                x2 = x0;\n+                y2 = y0;\n+                delta = x1 - x0;\n+                oldDelta = delta;\n+            }\n+            i++;\n+        }\n+        throw new MathException(\"Maximal iteration number exceeded.\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/SecantSolver.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Provide the secant algorithm for solving for zeros of real univariate\n+ * functions. Because of forced bracketing, convergence is slower than\n+ * the unrestricted secant algorithm. However, slow convergence of the\n+ * Regula Falsi can be avoided.\n+ * It will only search for one zero in the given interval.\n+ * The function is supposed to be continuous but not necessarily smooth.\n+ *  \n+ * @author pietsch at apache.org\n+ */\n+public class SecantSolver extends UnivariateRealSolverImpl {\n+\n+    private UnivariateRealFunction f;\n+\n+    public SecantSolver(UnivariateRealFunction f) {\n+        super(100, 1E-6);\n+        this.f = f;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.UnivariateRealSolver#solve(double, double)\n+     */\n+    public double solve(double min, double max) throws MathException {\n+        clearResult();\n+        // Index 0 is the old approximation for the root.\n+        // Index 1 is the last calculated approximation  for the root.\n+        // Index 2 is a bracket for the root with respect to x0.\n+        // OldDelta is the length of the bracketing interval of the last\n+        // iteration.\n+        double x0 = min;\n+        double x1 = max;\n+        double y0 = f.value(x0);\n+        double y1 = f.value(x1);\n+        if ((y0>0)== (y1>0)) {\n+            throw new MathException(\"Interval doesn't bracket a zero.\");\n+        }\n+        double x2 = x0;\n+        double y2 = y0;\n+        double oldDelta = x2 - x1;\n+        int i = 0;\n+        while (i < maximalIterationCount) {\n+            if (Math.abs(y2) < Math.abs(y1)) {\n+                x0 = x1;\n+                x1 = x2;\n+                x2 = x0;\n+                y0 = y1;\n+                y1 = y2;\n+                y2 = y0;\n+            }\n+            if (Math.abs(y1) <= functionValueAccuracy) {\n+                setResult(x1, i);\n+                return result;\n+            }\n+            if (Math.abs(oldDelta)\n+                < Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy)) {\n+                setResult(x1, i);\n+                return result;\n+            }\n+            double delta;\n+            if (Math.abs(y1) > Math.abs(y0)) {\n+                // Function value increased in last iteration. Force bisection.\n+                delta = 0.5 * oldDelta;\n+//                System.out.println(\"Forced Bisection\");\n+            } else {\n+                delta = (x0 - x1) / (1 - y0 / y1);\n+                // System.out.println(\"delta=\" + delta + \" olddelta=\" + oldDelta);\n+                if (delta / oldDelta > 1) {\n+                    // New approximation falls outside bracket. Fall back to bisection.\n+                    delta = 0.5 * oldDelta;\n+//                    System.out.println(\"Fallback Bisection\");\n+                }\n+            }\n+            x0 = x1;\n+            y0 = y1;\n+            x1 = x1 + delta;\n+            y1 = f.value(x1);\n+            if ((y1>0) == (y2>0)) {\n+                // New bracket is (x0,x1).                    \n+                x2 = x0;\n+                y2 = y0;\n+            }\n+            oldDelta = x2 - x1;\n+            i++;\n+        }\n+        throw new MathException(\"Maximal iteration number exceeded\");\n+    }\n+\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealFunction.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Provide an interface univariate real functions.\n+ * The object may held temporary data which is shared between calculations\n+ * of the value and the derivatives for the same argument. It is not guaranteed\n+ * that derivatives are evaluated after the value, the evaluation algorithm\n+ * should throw an InvalidStateException if it can't cope with this.\n+ *  \n+ * @author pietsch at apache.org\n+ */\n+public interface UnivariateRealFunction {\n+\n+    /**\n+     * Compute the value for the function.\n+     * @param x the point for which the function value should be computed\n+     * @return the value\n+     * @throws MathException if the function couldn't be computed due to\n+     *  missing additional data or other environmental problems.\n+     * @throws RuntimeException if the operation isn't supported, the argument\n+     *  was outside the supported domain or any other problem.\n+     * \n+     */\n+    public double value(double x) throws MathException;\n+\n+    /**\n+     * Compute the value for the first derivative of the function.\n+     * It is recommended to provide this method only if the first derivative is\n+     * analytical. Numerical derivatives may be acceptable in some cases.\n+     * An implementation should throw an UnsupportedOperationException if\n+     * this method is not implemented.\n+     * @param x the point for which the first derivative should be computed\n+     * @return the value\n+     * @throws MathException if the derivative couldn't be computed.\n+     * @throws RuntimeException if the operation isn't supported, the argument\n+     *  was outside the supported domain or any other problem.\n+     * \n+     */\n+    public double firstDerivative(double x) throws MathException;\n+\n+    /**\n+     * Compute the value for the second derivative of the function.\n+     * It is recommended to provide this method only if the second derivative is\n+     * analytical. Numerical derivatives may be acceptable in some cases.\n+     * An implementation should throw an UnsupportedOperationException if\n+     * this method is not implemented.\n+     * @param x the point for which the first derivative should be computed\n+     * @return the value\n+     * @throws MathException if the second derivative couldn't be computed.\n+     * @throws RuntimeException if the operation isn't supported, the argument\n+     *  was outside the supported domain or any other problem.\n+     * \n+     */\n+    public double secondDerivative(double x) throws MathException;\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolver.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Provide an interface to algorithms for solving for zeros of real univariate\n+ * functions.\n+ * An implementation will only search for one zero in the given interval.\n+ *  \n+ * @author pietsch at apache.org\n+ */\n+public interface UnivariateRealSolver {\n+\n+    /**\n+     * Set the upper limit for the number of iterations.\n+     * Usually a high iteration count indicates convergence problems. However,\n+     * the \"reasonable value\" varies widely for different solvers, users are\n+     * advised to use the default value supplied by the solver. \n+     * An exception will be thrown if the number is exceeded.\n+     *  \n+     * @param count\n+     */\n+    public void setMaximalIterationCount(int count);\n+\n+    /**\n+     * Get the upper limit for the number of iterations.\n+     * @return the actual upper limit\n+     */\n+    public int getMaximalIterationCount();\n+\n+    /**\n+     * Reset the upper limit for the number of iterations to the default.\n+     * The default value is supplied by the solver implementation.\n+     * \n+     * @see #setMaximalIterationCount(int)\n+     */\n+    public void resetMaximalIterationCount();\n+\n+    /**\n+     * Set the absolute accuracy.\n+     * The default is usually choosen so taht roots in the interval\n+     * -10..-0.1 and +0.1..+10 can be found wit a reasonable accuracy. If the expected\n+     * absolute value of your roots is of much smaller magnitude, set this to a smaller\n+     * value.\n+     * Solvers are advised to do a plausibility check with the relative accuracy, but\n+     * clients should not rely on this. \n+     * @param accuracy the accuracy.\n+     * @throws MathException if the accuracy can't be achieved by the solver or is\n+     * otherwise deemed unreasonable. \n+     */\n+    public void setAbsoluteAccuracy(double accuracy) throws MathException;\n+\n+    /**\n+     * Get the actual absolute accuracy.\n+     * @return the accuracy\n+     */\n+    public double getAbsoluteAccuracy();\n+\n+    /**\n+     * Reset the absolute accuracy to the default.\n+     * The default value is provided by the solver implementation.\n+     */\n+    public void resetAbsoluteAccuracy();\n+\n+    /**\n+     * Set the relative accuracy.\n+     * This is used to stop iterations if the absolute accuracy can't be achieved\n+     * due to large values or short mantissa length.\n+     * If this should be the primary criterium for convergence rather then a safety\n+     * measure, set the absolute accuracy to a ridiculously small value, like 1E-1000.\n+     * @param accuracy the relative accuracy.\n+     * @throws MathException if the accuracy can't be achieved by the solver or is\n+     * otherwise deemed unreasonable. \n+     */\n+    public void setRelativeAccuracy(double Accuracy) throws MathException;\n+\n+    /**\n+     * Get the actual relative accuracy.\n+     * @return the accuracy\n+     */\n+    public double getRelativeAccuracy();\n+\n+    /**\n+     * Reset the relative accuracy to the default.\n+     * The default value is provided by the solver implementation.\n+     */\n+    public void resetRelativeAccuracy();\n+\n+    /**\n+     * Set the function value accuracy.\n+     * This is used to determine whan an evaluated function value or some other\n+     * value which is used as divisor is zero.\n+     * This is a safety guard and it shouldn't be necesary to change this in general.\n+     * @param accuracy the accuracy.\n+     * @throws MathException if the accuracy can't be achieved by the solver or is\n+     * otherwise deemed unreasonable. \n+     */\n+    public void setFunctionValueAccuracy(double Accuracy) throws MathException;\n+\n+    /**\n+     * Get the actual function value accuracy.\n+     * @return the accuracy\n+     */\n+    public double getFunctionValueAccuracy();\n+\n+    /**\n+     * Reset the actual function accuracy to the default.\n+     * The default value is provided by the solver implementation.\n+     */\n+    public void resetFunctionValueAccuracy();\n+\n+    /**\n+     * Solve for a zero root in the given interval.\n+     * A solver may require that the interval brackets a single zero root.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @return the value where the function is zero\n+     * @throws MathException if the iteration count was exceeded or the\n+     *  solver detects convergence problems otherwise.\n+     */\n+    public double solve(double min, double max) throws MathException;\n+\n+    /**\n+     * Solve for a zero in the given interval, start at startValue.\n+     * A solver may require that the interval brackets a single zero root.\n+     * @param min the lower bound for the interval.\n+     * @param max the upper bound for the interval.\n+     * @param startValue the start value to use\n+     * @return the value where the function is zero\n+     * @throws MathException if the iteration count was exceeded or the\n+     *  solver detects convergence problems otherwise.\n+     */\n+    public double solve(double min, double max, double startValue)\n+        throws MathException;\n+\n+    /**\n+     * Get the result of the last run of the solver.\n+     * @return the last result.\n+     * @throws MathException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed.\n+     */\n+    public double getResult() throws MathException;\n+\n+    /**\n+     * Get the number of iterations in the last run of the solver.\n+     * This is mainly meant for testing purposes. It may occasionally\n+     * help track down performance problems: if the iteration count\n+     * is notoriously high, check whether the function is evaluated\n+     * properly, and whether another solver is more amenable to the\n+     * problem.\n+     * @return the last iteration count.\n+     * @throws MathException if there is no result available, either\n+     * because no result was yet computed or the last attempt failed.\n+     */\n+    public int getIterationCount() throws MathException;\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverFactory.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+package org.apache.commons.math.analysis;\n+\n+import java.lang.reflect.InvocationTargetException;\n+\n+import org.apache.commons.math.MathConfigurationException;\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * @author pietsch at apache.org\n+ *\n+ * A factory to easily get a default solver and some convenience\n+ * functions.\n+ * Because solvers are easily reusable, the factory does not\n+ * store configuration data and creates preconfigured solvers\n+ * (this may be controversial, because the configuration data\n+ * may also be used for the default solver used by the static\n+ * solve() method).\n+ * \n+ */\n+public class UnivariateRealSolverFactory {\n+    protected UnivariateRealSolverFactory() {\n+    }\n+\n+    public static UnivariateRealSolver newSolver(UnivariateRealFunction f)\n+        throws MathConfigurationException {\n+        String solverClassName =\n+            System.getProperty(\n+                \"org.apache.commons.math.analysis.UnivariateRealSolver\",\n+                \"org.apache.commons.math.analysis.BrentSolver\");\n+        try {\n+            Class clazz = Class.forName(solverClassName);\n+            Class paramClass[] = new Class[1];\n+            paramClass[0] =\n+                Class.forName(\"org.apache.commons.math.analysis.UnivariateRealFunction\");\n+            Object param[] = new Object[1];\n+            param[0] = f;\n+            return (UnivariateRealSolver)clazz.getConstructor(\n+                paramClass).newInstance(\n+                param);\n+        } catch (IllegalArgumentException e) {\n+            throw new MathConfigurationException(e);\n+        } catch (SecurityException e) {\n+            throw new MathConfigurationException(\n+                \"Can't access \" + solverClassName,\n+                e);\n+        } catch (ClassNotFoundException e) {\n+            throw new MathConfigurationException(\n+                \"Class not found: \" + solverClassName,\n+                e);\n+        } catch (InstantiationException e) {\n+            throw new MathConfigurationException(\n+                \"Can't instantiate \" + solverClassName,\n+                e);\n+        } catch (IllegalAccessException e) {\n+            throw new MathConfigurationException(\n+                \"Can't access \" + solverClassName,\n+                e);\n+        } catch (InvocationTargetException e) {\n+            throw new MathConfigurationException(e);\n+        } catch (NoSuchMethodException e) {\n+            throw new MathConfigurationException(\n+                \"No constructor with UnivariateRealFunction in \"\n+                    + solverClassName,\n+                e);\n+        }\n+    }\n+\n+    public static double solve(UnivariateRealFunction f, double x0, double x1)\n+        throws MathException {\n+        return newSolver(f).solve(x0, x1);\n+    }\n+\n+    public static double solve(\n+        UnivariateRealFunction f,\n+        double x0,\n+        double x1,\n+        double absoluteAccuracy)\n+        throws MathException {\n+        UnivariateRealSolver solver = newSolver(f);\n+        solver.setAbsoluteAccuracy(absoluteAccuracy);\n+        return solver.solve(x0, x1);\n+    }\n+}\n--- /dev/null\n+++ b/src/java/org/apache/commons/math/analysis/UnivariateRealSolverImpl.java\n+/* ====================================================================\n+ * The Apache Software License, Version 1.1\n+ *\n+ * Copyright (c) 2003 The Apache Software Foundation.  All rights\n+ * reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions\n+ * are met:\n+ *\n+ * 1. Redistributions of source code must retain the above copyright\n+ *    notice, this list of conditions and the following disclaimer.\n+ *\n+ * 2. Redistributions in binary form must reproduce the above copyright\n+ *    notice, this list of conditions and the following disclaimer in\n+ *    the documentation and/or other materials provided with the\n+ *    distribution.\n+ *\n+ * 3. The end-user documentation included with the redistribution, if\n+ *    any, must include the following acknowlegement:\n+ *       \"This product includes software developed by the\n+ *        Apache Software Foundation (http://www.apache.org/).\"\n+ *    Alternately, this acknowlegement may appear in the software itself,\n+ *    if and wherever such third-party acknowlegements normally appear.\n+ *\n+ * 4. The names \"The Jakarta Project\", \"Commons\", and \"Apache Software\n+ *    Foundation\" must not be used to endorse or promote products derived\n+ *    from this software without prior written permission. For written\n+ *    permission, please contact apache@apache.org.\n+ *\n+ * 5. Products derived from this software may not be called \"Apache\"\n+ *    nor may \"Apache\" appear in their names without prior written\n+ *    permission of the Apache Software Foundation.\n+ *\n+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED\n+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR\n+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n+ * SUCH DAMAGE.\n+ * ====================================================================\n+ *\n+ * This software consists of voluntary contributions made by many\n+ * individuals on behalf of the Apache Software Foundation.  For more\n+ * information on the Apache Software Foundation, please see\n+ * <http://www.apache.org/>.\n+ */\n+\n+package org.apache.commons.math.analysis;\n+\n+import org.apache.commons.math.MathException;\n+\n+/**\n+ * Provide a default implementation for several functions useful to generic\n+ * solvers.\n+ *  \n+ * @author pietsch at apache.org\n+ */\n+public abstract class UnivariateRealSolverImpl\n+    implements UnivariateRealSolver {\n+\n+    protected double absoluteAccuracy;\n+    protected double relativeAccuracy;\n+    protected double functionValueAccuracy;\n+    protected int maximalIterationCount;\n+\n+    protected double defaultAbsoluteAccuracy;\n+    protected double defaultRelativeAccuracy;\n+    protected double defaultFunctionValueAccuracy;\n+    protected int defaultMaximalIterationCount;\n+\n+    protected boolean resultComputed = false;\n+    protected double result;\n+    // Mainly for test framework.\n+    protected int iterationCount;\n+\n+    protected UnivariateRealSolverImpl(\n+        int defaultMaximalIterationCount,\n+        double defaultAbsoluteAccuracy) {\n+        this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\n+        this.defaultRelativeAccuracy = 1E-14;\n+        this.defaultFunctionValueAccuracy = 1E-15;\n+        this.absoluteAccuracy = defaultAbsoluteAccuracy;\n+        this.relativeAccuracy = defaultRelativeAccuracy;\n+        this.functionValueAccuracy = defaultFunctionValueAccuracy;\n+        this.defaultMaximalIterationCount = defaultMaximalIterationCount;\n+        this.maximalIterationCount = defaultMaximalIterationCount;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.UnivariateRealSolver#solve(double, double)\n+     */\n+    public double solve(double min, double max) throws MathException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.UnivariateRealSolver#solve(double, double, double)\n+     */\n+    public double solve(double min, double max, double startValue)\n+        throws MathException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    /*\n+     * Get result of last solver run.\n+     * @see org.apache.commons.math.UnivariateRealSolver#getResult()\n+     */\n+    public double getResult() throws MathException {\n+        if (resultComputed) {\n+            return result;\n+        } else {\n+            throw new MathException(\"No result available\");\n+        }\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.UnivariateRealSolver#getIterationCount()\n+     */\n+    public int getIterationCount() throws MathException {\n+        if (resultComputed) {\n+            return iterationCount;\n+        } else {\n+            throw new MathException(\"No result available\");\n+        }\n+    }\n+\n+    /*\n+     * Convenience function for implementations.\n+     * @param result the result to set\n+     * @param iteratinCount the iteration count to set\n+     */\n+    protected final void setResult(double result, int iterationCount) {\n+        this.result = result;\n+        this.iterationCount = iterationCount;\n+        this.resultComputed = true;\n+    }\n+\n+    /*\n+     * Convenience function for implementations.\n+     */\n+    protected final void clearResult() {\n+        this.resultComputed = false;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.UnivariateRealSolver#setAccuracy(double)\n+     */\n+    public void setAbsoluteAccuracy(double accuracy)\n+        throws MathException {\n+        absoluteAccuracy = accuracy;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.UnivariateRealSolver#getAccuracy()\n+     */\n+    public double getAbsoluteAccuracy() {\n+        return absoluteAccuracy;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.UnivariateRealSolver#resetAbsoluteAccuracy()\n+     */\n+    public void resetAbsoluteAccuracy() {\n+        absoluteAccuracy = defaultAbsoluteAccuracy;\n+    }\n+\n+    /* Set maximum iteration count.\n+     * @see org.apache.commons.math.UnivariateRealSolver#setMaximalIterationCount(int)\n+     */\n+    public void setMaximalIterationCount(int count) {\n+        maximalIterationCount = count;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.UnivariateRealSolver#getMaximalIterationCount()\n+     */\n+    public int getMaximalIterationCount() {\n+        return maximalIterationCount;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.UnivariateRealSolver#resetMaximalIterationCount()\n+     */\n+    public void resetMaximalIterationCount() {\n+        maximalIterationCount = defaultMaximalIterationCount;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.UnivariateRealSolver#setRelativeAccuracy(double)\n+     */\n+    public void setRelativeAccuracy(double accuracy) throws MathException {\n+        relativeAccuracy = accuracy;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.UnivariateRealSolver#getRelativeAccuracy()\n+     */\n+    public double getRelativeAccuracy() {\n+        return relativeAccuracy;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.UnivariateRealSolver#resetRelativeAccuracy()\n+     */\n+    public void resetRelativeAccuracy() {\n+        relativeAccuracy = defaultRelativeAccuracy;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.UnivariateRealSolver#setFunctionValueAccuracy(double)\n+     */\n+    public void setFunctionValueAccuracy(double accuracy)\n+        throws MathException {\n+        functionValueAccuracy = accuracy;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.UnivariateRealSolver#getFunctionValueAccuracy()\n+     */\n+    public double getFunctionValueAccuracy() {\n+        return functionValueAccuracy;\n+    }\n+\n+    /* (non-Javadoc)\n+     * @see org.apache.commons.math.UnivariateRealSolver#resetFunctionValueAccuracy()\n+     */\n+    public void resetFunctionValueAccuracy() {\n+        functionValueAccuracy = defaultFunctionValueAccuracy;\n+    }\n+\n+}", "timestamp": 1056423700, "metainfo": ""}