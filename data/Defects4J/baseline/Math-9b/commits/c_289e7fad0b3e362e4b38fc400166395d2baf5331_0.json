{"sha": "289e7fad0b3e362e4b38fc400166395d2baf5331", "log": "[MATH-474] Added Frequency#merge method, thanks to patch from Dan Checkoway.  ", "commit": "\n--- a/src/main/java/org/apache/commons/math3/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math3/stat/Frequency.java\n \n import java.io.Serializable;\n import java.text.NumberFormat;\n+import java.util.Collection;\n import java.util.Iterator;\n import java.util.Comparator;\n+import java.util.Map;\n import java.util.TreeMap;\n \n import org.apache.commons.math3.exception.MathIllegalArgumentException;\n      * @throws MathIllegalArgumentException if <code>v</code> is not comparable with previous entries\n      */\n     public void addValue(Comparable<?> v) throws MathIllegalArgumentException {\n+        incrementValue(v, 1);\n+    }\n+\n+    /**\n+     * Increments the frequency count for v.\n+     * <p>\n+     * If other objects have already been added to this Frequency, v must\n+     * be comparable to those that have already been added.\n+     * </p>\n+     *\n+     * @param v the value to add.\n+     * @param increment the amount by which the value should be incremented\n+     * @throws IllegalArgumentException if <code>v</code> is not comparable with previous entries\n+     */\n+    public void incrementValue(Comparable<?> v, long increment){\n         Comparable<?> obj = v;\n         if (v instanceof Integer) {\n-           obj = Long.valueOf(((Integer) v).longValue());\n+            obj = Long.valueOf(((Integer) v).longValue());\n         }\n         try {\n             Long count = freqTable.get(obj);\n             if (count == null) {\n-                freqTable.put(obj, Long.valueOf(1));\n+                freqTable.put(obj, Long.valueOf(increment));\n             } else {\n-                freqTable.put(obj, Long.valueOf(count.longValue() + 1));\n+                freqTable.put(obj, Long.valueOf(count.longValue() + increment));\n             }\n         } catch (ClassCastException ex) {\n             //TreeMap will throw ClassCastException if v is not comparable\n      */\n     public Iterator<Comparable<?>> valuesIterator() {\n         return freqTable.keySet().iterator();\n+    }\n+\n+    /**\n+     * Return an Iterator over the set of keys and values that have been added.\n+     * Using the entry set to iterate is more efficient in the case where you\n+     * need to access respective counts as well as values, since it doesn't\n+     * require a \"get\" for every key...the value is provided in the Map.Entry.\n+     * <p>\n+     * If added values are integral (i.e., integers, longs, Integers, or Longs),\n+     * they are converted to Longs when they are added, so the values of the\n+     * map entries returned by the Iterator will in this case be Longs.</p>\n+     *\n+     * @return entry set Iterator\n+     */\n+    public Iterator<Map.Entry<Comparable<?>, Long>> entrySetIterator() {\n+        return freqTable.entrySet().iterator();\n     }\n \n     //-------------------------------------------------------------------------\n     public double getCumPct(char v) {\n         return getCumPct(Character.valueOf(v));\n     }\n+\n+    //----------------------------------------------------------------------------------------------\n+\n+    /**\n+     * Merge another Frequency object's counts into this instance.\n+     * This Frequency's counts will be incremented (or set when not already set)\n+     * by the counts represented by other.\n+     *\n+     * @param other the other {@link Frequency} object to be merged\n+     */\n+    public void merge(Frequency other) {\n+        for (Iterator<Map.Entry<Comparable<?>, Long>> iter = other.entrySetIterator(); iter.hasNext();) {\n+            Map.Entry<Comparable<?>, Long> entry = iter.next();\n+            incrementValue(entry.getKey(), entry.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Merge a {@link Collection} of {@link Frequency} objects into this instance.\n+     * This Frequency's counts will be incremented (or set when not already set)\n+     * by the counts represented by each of the others.\n+     *\n+     * @param others the other {@link Frequency} objects to be merged\n+     */\n+    public void merge(Collection<Frequency> others) {\n+        for (Iterator<Frequency> iter = others.iterator(); iter.hasNext();) {\n+            merge(iter.next());\n+        }\n+    }\n+\n+    //----------------------------------------------------------------------------------------------\n \n     /**\n      * A Comparator that compares comparable objects using the\n--- a/src/test/java/org/apache/commons/math3/stat/FrequencyTest.java\n+++ b/src/test/java/org/apache/commons/math3/stat/FrequencyTest.java\n \n import java.io.BufferedReader;\n import java.io.StringReader;\n+import java.util.ArrayList;\n import java.util.Iterator;\n+import java.util.List;\n \n \n import org.apache.commons.math3.TestUtils;\n         f.addValue(twoI);\n         Assert.assertEquals(2, f.getUniqueCount());\n     }\n+    \n+    @Test\n+    public void testIncrement() {\n+        Assert.assertEquals(0, f.getUniqueCount());\n+        f.incrementValue(oneL, 1);\n+        Assert.assertEquals(1, f.getCount(oneL));\n+\n+        f.incrementValue(oneL, 4);\n+        Assert.assertEquals(5, f.getCount(oneL));\n+        \n+        f.incrementValue(oneL, -5);\n+        Assert.assertEquals(0, f.getCount(oneL));\n+    }\n+    \n+    @Test\n+    public void testMerge() {\n+        Assert.assertEquals(0, f.getUniqueCount());\n+        f.addValue(oneL);\n+        f.addValue(twoL);\n+        f.addValue(oneI);\n+        f.addValue(twoI);\n+        \n+        Assert.assertEquals(2, f.getUniqueCount());\n+        Assert.assertEquals(2, f.getCount(oneI));\n+        Assert.assertEquals(2, f.getCount(twoI));\n+\n+        Frequency g = new Frequency();\n+        g.addValue(oneL);\n+        g.addValue(threeL);\n+        g.addValue(threeI);\n+\n+        Assert.assertEquals(2, g.getUniqueCount());\n+        Assert.assertEquals(1, g.getCount(oneI));\n+        Assert.assertEquals(2, g.getCount(threeI));\n+\n+        f.merge(g);\n+        \n+        Assert.assertEquals(3, f.getUniqueCount());\n+        Assert.assertEquals(3, f.getCount(oneI));\n+        Assert.assertEquals(2, f.getCount(twoI));\n+        Assert.assertEquals(2, f.getCount(threeI));        \n+    }\n+    \n+    @Test\n+    public void testMergeCollection() {\n+        Assert.assertEquals(0, f.getUniqueCount());\n+        f.addValue(oneL);\n+        \n+        Assert.assertEquals(1, f.getUniqueCount());\n+        Assert.assertEquals(1, f.getCount(oneI));\n+        Assert.assertEquals(0, f.getCount(twoI));\n+\n+        Frequency g = new Frequency();\n+        g.addValue(twoL);\n+\n+        Frequency h = new Frequency();\n+        h.addValue(threeL);\n+        \n+        List<Frequency> coll = new ArrayList<Frequency>();\n+        coll.add(g);\n+        coll.add(h);\n+        f.merge(coll);\n+        \n+        Assert.assertEquals(3, f.getUniqueCount());\n+        Assert.assertEquals(1, f.getCount(oneI));\n+        Assert.assertEquals(1, f.getCount(twoI));\n+        Assert.assertEquals(1, f.getCount(threeI));        \n+    }\n }\n ", "timestamp": 1350840817, "metainfo": ""}