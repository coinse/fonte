{"sha": "c0a94937d69cd75926e099503505c18562154b7a", "log": "MATH-621 Local variables defined at initialization.   ", "commit": "\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n         double dsq = Double.NaN;\n         double crvmin = Double.NaN;\n \n-        // System generated locals\n-        double d__1, d__2, d__3, d__4;\n-\n-        // Local variables\n-        double f = 0;\n-        int ih, ip, jp;\n-        double dx;\n-        double den = 0, rho = 0, sum = 0, diff = 0, beta = 0, gisq = 0;\n-        int knew = 0;\n-        double temp, suma, sumb, bsum, fopt;\n-        double curv;\n-        int ksav;\n-        double gqsq = 0, dist = 0, sumw = 0, sumz = 0, diffa = 0, diffb = 0, diffc = 0, hdiag = 0;\n-        int kbase;\n-        double delta = 0, adelt = 0, denom = 0, fsave = 0, bdtol = 0, delsq = 0;\n-        int nfsav;\n-        double ratio = 0, dnorm = 0, vquad = 0, pqold = 0;\n-        int itest;\n-        double sumpq, scaden;\n-        double errbig, fracsq, biglsq, densav;\n-        double bdtest;\n-        double frhosq;\n-        double distsq = 0;\n-        int ntrits;\n-\n         // Set some constants.\n         // Parameter adjustments\n \n \n         prelim(currentBest, xbase,\n                xpt, fval, gopt, hq, pq, bmat,\n-                zmat, sl, su);\n+               zmat, sl, su);\n         double xoptsq = ZERO;\n         for (int i = 0; i < n; i++) {\n             xopt.setEntry(i, xpt.getEntry(trustRegionCenterInterpolationPointIndex, i));\n             final double deltaOne = xopt.getEntry(i);\n             xoptsq += deltaOne * deltaOne;\n         }\n-        fsave = fval.getEntry(0);\n-        kbase = 0;\n+        double fsave = fval.getEntry(0);\n+        final int kbase = 0;\n \n         // Complete the settings that are required for the iterative procedure.\n \n-        rho = initialTrustRegionRadius;\n-        delta = rho;\n-        ntrits = 0;\n-        diffa = ZERO;\n-        diffb = ZERO;\n-        itest = 0;\n-        nfsav = getEvaluations();\n+        int ntrits = 0;\n+        int itest = 0;\n+        int knew = 0;\n+        int nfsav = getEvaluations();\n+        double rho = initialTrustRegionRadius;\n+        double delta = rho;\n+        double diffa = ZERO;\n+        double diffb = ZERO;\n+        double diffc = ZERO;\n+        double f = ZERO;\n+        double beta = ZERO;\n+        double adelt = ZERO;\n+        double denom = ZERO;\n+        double ratio = ZERO;\n+        double dnorm = ZERO;\n+        double scaden = ZERO;\n+        double biglsq = ZERO;\n+        double distsq = ZERO;\n \n         // Update GOPT if necessary before the first iteration and after each\n         // call of RESCUE that makes a call of CALFUN.\n         for(;;) switch (state) {\n         case 20: {\n             if (trustRegionCenterInterpolationPointIndex != kbase) {\n-                ih = 0;\n+                int ih = 0;\n                 for (int j = 0; j < n; j++) {\n                     for (int i = 0; i <= j; i++) {\n                         if (i < j) {\n                 }\n                 if (getEvaluations() > npt) {\n                     for (int k = 0; k < npt; k++) {\n-                        temp = ZERO;\n+                        double temp = ZERO;\n                         for (int j = 0; j < n; j++) {\n                             temp += xpt.getEntry(k, j) * xopt.getEntry(j);\n                         }\n-                        temp = pq.getEntry(k) * temp;\n+                        temp *= pq.getEntry(k);\n                         for (int i = 0; i < n; i++) {\n                             gopt.setEntry(i, gopt.getEntry(i) + temp * xpt.getEntry(k, i));\n                         }\n \n                 // Computing MAX\n                 deltaOne = Math.max(diffa, diffb);\n-                errbig = Math.max(deltaOne, diffc);\n-                frhosq = rho * ONE_OVER_EIGHT * rho;\n+                final double errbig = Math.max(deltaOne, diffc);\n+                final double frhosq = rho * ONE_OVER_EIGHT * rho;\n                 if (crvmin > ZERO &&\n                     errbig > frhosq * crvmin) {\n                     state = 650; break;\n                 }\n-                bdtol = errbig / rho;\n+                final double bdtol = errbig / rho;\n                 for (int j = 0; j < n; j++) {\n-                    bdtest = bdtol;\n+                    double bdtest = bdtol;\n                     if (xnew.getEntry(j) == sl.getEntry(j)) {\n                         bdtest = work1.getEntry(j);\n                     }\n                         bdtest = -work1.getEntry(j);\n                     }\n                     if (bdtest < bdtol) {\n-                        curv = hq.getEntry((j + j * j) / 2);\n+                        double curv = hq.getEntry((j + j * j) / 2);\n                         for (int k = 0; k < npt; k++) {\n                             // Computing 2nd power\n                             final double d1 = xpt.getEntry(k, j);\n         }\n         case 90: {\n             if (dsq <= xoptsq * ONE_OVER_A_THOUSAND) {\n-                fracsq = xoptsq * ONE_OVER_FOUR;\n-                sumpq = ZERO;\n+                final double fracsq = xoptsq * ONE_OVER_FOUR;\n+                double sumpq = ZERO;\n                 // final RealVector sumVector\n                 //     = new ArrayRealVector(npt, -HALF * xoptsq).add(xpt.operate(xopt));\n                 for (int k = 0; k < npt; k++) {\n                     sumpq += pq.getEntry(k);\n-                    sum = -HALF * xoptsq;\n+                    double sum = -HALF * xoptsq;\n                     for (int i = 0; i < n; i++) {\n                         sum += xpt.getEntry(k, i) * xopt.getEntry(i);\n                     }\n                     // sum = sumVector.getEntry(k); // XXX \"testAckley\" and \"testDiffPow\" fail.\n                     work2.setEntry(k, sum);\n-                    temp = fracsq - HALF * sum;\n+                    final double temp = fracsq - HALF * sum;\n                     for (int i = 0; i < n; i++) {\n                         work1.setEntry(i, bmat.getEntry(k, i));\n                         vlag.setEntry(i, sum * xpt.getEntry(k, i) + temp * xopt.getEntry(i));\n-                        ip = npt + i;\n+                        final int ip = npt + i;\n                         for (int j = 0; j <= i; j++) {\n                             bmat.setEntry(ip, j,\n                                           bmat.getEntry(ip, j)\n                 // Then the revisions of BMAT that depend on ZMAT are calculated.\n \n                 for (int m = 0; m < nptm; m++) {\n-                    sumz = ZERO;\n-                    sumw = ZERO;\n+                    double sumz = ZERO;\n+                    double sumw = ZERO;\n                     for (int k = 0; k < npt; k++) {\n                         sumz += zmat.getEntry(k, m);\n                         vlag.setEntry(k, work2.getEntry(k) * zmat.getEntry(k, m));\n                         sumw += vlag.getEntry(k);\n                     }\n                     for (int j = 0; j < n; j++) {\n-                        sum = (fracsq * sumz - HALF * sumw) * xopt.getEntry(j);\n+                        double sum = (fracsq * sumz - HALF * sumw) * xopt.getEntry(j);\n                         for (int k = 0; k < npt; k++) {\n                             sum += vlag.getEntry(k) * xpt.getEntry(k, j);\n                         }\n                         }\n                     }\n                     for (int i = 0; i < n; i++) {\n-                        ip = i + npt;\n-                        temp = work1.getEntry(i);\n+                        final int ip = i + npt;\n+                        final double temp = work1.getEntry(i);\n                         for (int j = 0; j <= i; j++) {\n                             bmat.setEntry(ip, j,\n                                           bmat.getEntry(ip, j)\n                 // The following instructions complete the shift, including the changes\n                 // to the second derivative parameters of the quadratic model.\n \n-                ih = 0;\n+                int ih = 0;\n                 for (int j = 0; j < n; j++) {\n                     work1.setEntry(j, -HALF * sumpq * xopt.getEntry(j));\n                     for (int k = 0; k < npt; k++) {\n         }\n         case 230: {\n             for (int k = 0; k < npt; k++) {\n-                suma = ZERO;\n-                sumb = ZERO;\n-                sum = ZERO;\n+                double suma = ZERO;\n+                double sumb = ZERO;\n+                double sum = ZERO;\n                 for (int j = 0; j < n; j++) {\n                     suma += xpt.getEntry(k, j) * d__.getEntry(j);\n                     sumb += xpt.getEntry(k, j) * xopt.getEntry(j);\n             }\n             beta = ZERO;\n             for (int m = 0; m < nptm; m++) {\n-                sum = ZERO;\n+                double sum = ZERO;\n                 for (int k = 0; k < npt; k++) {\n                     sum += zmat.getEntry(k, m) * work3.getEntry(k);\n                 }\n                 }\n             }\n             dsq = ZERO;\n-            bsum = ZERO;\n-            dx = ZERO;\n+            double bsum = ZERO;\n+            double dx = ZERO;\n             for (int j = 0; j < n; j++) {\n                 // Computing 2nd power\n                 final double d1 = d__.getEntry(j);\n                 dsq += d1 * d1;\n-                sum = ZERO;\n+                double sum = ZERO;\n                 for (int k = 0; k < npt; k++) {\n                     sum += work3.getEntry(k) * bmat.getEntry(k, j);\n                 }\n                 bsum += sum * d__.getEntry(j);\n-                jp = npt + j;\n+                final int jp = npt + j;\n                 for (int i = 0; i < n; i++) {\n                     sum += bmat.getEntry(jp, i) * d__.getEntry(i);\n                 }\n                 dx += d__.getEntry(j) * xopt.getEntry(j);\n             }\n             beta = dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) + beta - bsum;\n-            vlag.setEntry(trustRegionCenterInterpolationPointIndex, vlag.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);\n+            vlag.setEntry(trustRegionCenterInterpolationPointIndex,\n+                          vlag.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);\n \n             // If NTRITS is zero, the denominator may be increased by replacing\n             // the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if\n                 // KNEW before calculating the next value of the objective function.\n \n             } else {\n-                delsq = delta * delta;\n+                final double delsq = delta * delta;\n                 scaden = ZERO;\n                 biglsq = ZERO;\n                 knew = 0;\n                     if (k == trustRegionCenterInterpolationPointIndex) {\n                         continue;\n                     }\n-                    hdiag = ZERO;\n+                    double hdiag = ZERO;\n                     for (int m = 0; m < nptm; m++) {\n                         // Computing 2nd power\n                         final double d1 = zmat.getEntry(k, m);\n                         hdiag += d1 * d1;\n                     }\n                     // Computing 2nd power\n-                    d__1 = vlag.getEntry(k);\n-                    den = beta * hdiag + d__1 * d__1;\n+                    final double d2 = vlag.getEntry(k);\n+                    final double den = beta * hdiag + d2 * d2;\n                     distsq = ZERO;\n                     for (int j = 0; j < n; j++) {\n                         // Computing 2nd power\n-                        final double d1 = xpt.getEntry(k, j) - xopt.getEntry(j);\n-                        distsq += d1 * d1;\n+                        final double d3 = xpt.getEntry(k, j) - xopt.getEntry(j);\n+                        distsq += d3 * d3;\n                     }\n                     // Computing MAX\n                     // Computing 2nd power\n-                    d__3 = distsq / delsq;\n-                    d__1 = ONE;\n-                    d__2 = d__3 * d__3;\n-                    temp = Math.max(d__1,d__2);\n+                    final double d4 = distsq / delsq;\n+                    final double temp = Math.max(ONE, d4 * d4);\n                     if (temp * den > scaden) {\n                         scaden = temp * den;\n                         knew = k;\n                     }\n                     // Computing MAX\n                     // Computing 2nd power\n-                    d__3 = vlag.getEntry(k);\n-                    d__1 = biglsq;\n-                    d__2 = temp * (d__3 * d__3);\n-                    biglsq = Math.max(d__1, d__2);\n+                    final double d5 = vlag.getEntry(k);\n+                    biglsq = Math.max(biglsq, temp * (d5 * d5));\n                 }\n             }\n \n             for (int i = 0; i < n; i++) {\n                 // Computing MIN\n                 // Computing MAX\n-                d__3 = lowerBound[i];\n-                d__4 = xbase.getEntry(i) + xnew.getEntry(i);\n-                d__1 = Math.max(d__3, d__4);\n-                d__2 = upperBound[i];\n-                currentBest.setEntry(i, Math.min(d__1, d__2));\n+                final double d3 = lowerBound[i];\n+                final double d4 = xbase.getEntry(i) + xnew.getEntry(i);\n+                final double d1 = Math.max(d3, d4);\n+                final double d2 = upperBound[i];\n+                currentBest.setEntry(i, Math.min(d1, d2));\n                 if (xnew.getEntry(i) == sl.getEntry(i)) {\n                     currentBest.setEntry(i, lowerBound[i]);\n                 }\n             // Use the quadratic model to predict the change in F due to the step D,\n             //   and set DIFF to the error of this prediction.\n \n-            fopt = fval.getEntry(trustRegionCenterInterpolationPointIndex);\n-            vquad = ZERO;\n-            ih = 0;\n+            final double fopt = fval.getEntry(trustRegionCenterInterpolationPointIndex);\n+            double vquad = ZERO;\n+            int ih = 0;\n             for (int j = 0; j < n; j++) {\n                 vquad += d__.getEntry(j) * gopt.getEntry(j);\n                 for (int i = 0; i <= j; i++) {\n-                     temp = d__.getEntry(i) * d__.getEntry(j);\n+                    double temp = d__.getEntry(i) * d__.getEntry(j);\n                     if (i == j) {\n-                        temp = HALF * temp;\n+                        temp *= HALF;\n                     }\n                     vquad += hq.getEntry(ih) * temp;\n                     ih++;\n                 final double d2 = d1 * d1; // \"d1\" must be squared first to prevent test failures.\n                 vquad += HALF * pq.getEntry(k) * d2;\n             }\n-            diff = f - fopt - vquad;\n+            final double diff = f - fopt - vquad;\n             diffc = diffb;\n             diffb = diffa;\n             diffa = Math.abs(diff);\n                     throw new MathIllegalStateException(LocalizedFormats.TRUST_REGION_STEP_FAILED, vquad);\n                 }\n                 ratio = (f - fopt) / vquad;\n+                final double hDelta = HALF * delta;\n                 if (ratio <= ONE_OVER_TEN) {\n                     // Computing MIN\n-                    d__1 = HALF * delta;\n-                    delta = Math.min(d__1,dnorm);\n+                    delta = Math.min(hDelta, dnorm);\n                 } else if (ratio <= .7) {\n                     // Computing MAX\n-                    d__1 = HALF * delta;\n-                    delta = Math.max(d__1,dnorm);\n+                    delta = Math.max(hDelta, dnorm);\n                 } else {\n                     // Computing MAX\n-                    d__1 = HALF * delta;\n-                    d__2 = dnorm + dnorm;\n-                    delta = Math.max(d__1,d__2);\n+                    delta = Math.max(hDelta, 2 * dnorm);\n                 }\n                 if (delta <= rho * 1.5) {\n                     delta = rho;\n                 // Recalculate KNEW and DENOM if the new F is less than FOPT.\n \n                 if (f < fopt) {\n-                    ksav = knew;\n-                    densav = denom;\n-                    delsq = delta * delta;\n+                    final int ksav = knew;\n+                    final double densav = denom;\n+                    final double delsq = delta * delta;\n                     scaden = ZERO;\n                     biglsq = ZERO;\n                     knew = 0;\n                     for (int k = 0; k < npt; k++) {\n-                        hdiag = ZERO;\n+                        double hdiag = ZERO;\n                         for (int m = 0; m < nptm; m++) {\n                             // Computing 2nd power\n                             final double d1 = zmat.getEntry(k, m);\n                             hdiag += d1 * d1;\n                         }\n                         // Computing 2nd power\n-                        d__1 = vlag.getEntry(k);\n-                        den = beta * hdiag + d__1 * d__1;\n+                        final double d1 = vlag.getEntry(k);\n+                        final double den = beta * hdiag + d1 * d1;\n                         distsq = ZERO;\n                         for (int j = 0; j < n; j++) {\n                             // Computing 2nd power\n-                            final double d1 = xpt.getEntry(k, j) - xnew.getEntry(j);\n-                            distsq += d1 * d1;\n+                            final double d2 = xpt.getEntry(k, j) - xnew.getEntry(j);\n+                            distsq += d2 * d2;\n                         }\n                         // Computing MAX\n                         // Computing 2nd power\n-                        d__3 = distsq / delsq;\n-                        d__1 = ONE;\n-                        d__2 = d__3 * d__3;\n-                        temp = Math.max(d__1, d__2);\n+                        final double d3 = distsq / delsq;\n+                        final double temp = Math.max(ONE, d3 * d3);\n                         if (temp * den > scaden) {\n                             scaden = temp * den;\n                             knew = k;\n                         }\n                         // Computing MAX\n                         // Computing 2nd power\n-                        d__3 = vlag.getEntry(k);\n-                        d__1 = biglsq;\n-                        d__2 = temp * (d__3 * d__3);\n-                        biglsq = Math.max(d__1, d__2);\n+                        final double d4 = vlag.getEntry(k);\n+                        final double d5 = temp * (d4 * d4);\n+                        biglsq = Math.max(biglsq, d5);\n                     }\n                     if (scaden <= HALF * biglsq) {\n                         knew = ksav;\n             // moved. Also update the second derivative terms of the model.\n \n             update(bmat, zmat, vlag,\n-                    beta, denom, knew);\n+                   beta, denom, knew);\n \n             ih = 0;\n-            pqold = pq.getEntry(knew);\n+            final double pqold = pq.getEntry(knew);\n             pq.setEntry(knew, ZERO);\n             for (int i = 0; i < n; i++) {\n-                temp = pqold * xpt.getEntry(knew, i);\n+                final double temp = pqold * xpt.getEntry(knew, i);\n                 for (int j = 0; j <= i; j++) {\n                     hq.setEntry(ih, hq.getEntry(ih) + temp * xpt.getEntry(knew, j));\n                     ih++;\n                 }\n             }\n             for (int m = 0; m < nptm; m++) {\n-                temp = diff * zmat.getEntry(knew, m);\n+                final double temp = diff * zmat.getEntry(knew, m);\n                 for (int k = 0; k < npt; k++) {\n                     pq.setEntry(k, pq.getEntry(k) + temp * zmat.getEntry(k, m));\n                 }\n                 work1.setEntry(i, bmat.getEntry(knew, i));\n             }\n             for (int k = 0; k < npt; k++) {\n-                suma = ZERO;\n+                double suma = ZERO;\n                 for (int m = 0; m < nptm; m++) {\n                     suma += zmat.getEntry(knew, m) * zmat.getEntry(k, m);\n                 }\n-                sumb = ZERO;\n+                double sumb = ZERO;\n                 for (int j = 0; j < n; j++) {\n                     sumb += xpt.getEntry(k, j) * xopt.getEntry(j);\n                 }\n-                temp = suma * sumb;\n+                final double temp = suma * sumb;\n                 for (int i = 0; i < n; i++) {\n                     work1.setEntry(i, work1.getEntry(i) + temp * xpt.getEntry(k, i));\n                 }\n                     }\n                 }\n                 for (int k = 0; k < npt; k++) {\n-                    temp = ZERO;\n+                    double temp = ZERO;\n                     for (int j = 0; j < n; j++) {\n                         temp += xpt.getEntry(k, j) * d__.getEntry(j);\n                     }\n-                    temp = pq.getEntry(k) * temp;\n+                    temp *= pq.getEntry(k);\n                     for (int i = 0; i < n; i++) {\n                         gopt.setEntry(i, gopt.getEntry(i) + temp * xpt.getEntry(k, i));\n                     }\n                     work3.setEntry(k, ZERO);\n                 }\n                 for (int j = 0; j < nptm; j++) {\n-                    sum = ZERO;\n+                    double sum = ZERO;\n                     for (int k = 0; k < npt; k++) {\n                         sum += zmat.getEntry(k, j) * vlag.getEntry(k);\n                     }\n                     }\n                 }\n                 for (int k = 0; k < npt; k++) {\n-                    sum = ZERO;\n+                    double sum = ZERO;\n                     for (int j = 0; j < n; j++) {\n                         sum += xpt.getEntry(k, j) * xopt.getEntry(j);\n                     }\n                     work2.setEntry(k, work3.getEntry(k));\n                     work3.setEntry(k, sum * work3.getEntry(k));\n                 }\n-                gqsq = ZERO;\n-                gisq = ZERO;\n+                double gqsq = ZERO;\n+                double gisq = ZERO;\n                 for (int i = 0; i < n; i++) {\n-                    sum = ZERO;\n+                    double sum = ZERO;\n                     for (int k = 0; k < npt; k++) {\n                         sum += bmat.getEntry(k, i) *\n                             vlag.getEntry(k) + xpt.getEntry(k, i) * work3.getEntry(k);\n                     }\n                     if (xopt.getEntry(i) == sl.getEntry(i)) {\n                         // Computing MIN\n-                        d__2 = ZERO;\n-                        d__3 = gopt.getEntry(i);\n                         // Computing 2nd power\n-                        d__1 = Math.min(d__2, d__3);\n-                        gqsq += d__1 * d__1;\n+                        final double d1 = Math.min(ZERO, gopt.getEntry(i));\n+                        gqsq += d1 * d1;\n                         // Computing 2nd power\n-                        d__1 = Math.min(ZERO, sum);\n-                        gisq += d__1 * d__1;\n+                        final double d2 = Math.min(ZERO, sum);\n+                        gisq += d2 * d2;\n                     } else if (xopt.getEntry(i) == su.getEntry(i)) {\n                         // Computing MAX\n-                        d__2 = ZERO;\n-                        d__3 = gopt.getEntry(i);\n                         // Computing 2nd power\n-                        d__1 = Math.max(d__2, d__3);\n-                        gqsq += d__1 * d__1;\n+                        final double d1 = Math.max(ZERO, gopt.getEntry(i));\n+                        gqsq += d1 * d1;\n                         // Computing 2nd power\n-                        d__1 = Math.max(ZERO, sum);\n-                        gisq += d__1 * d__1;\n+                        final double d2 = Math.max(ZERO, sum);\n+                        gisq += d2 * d2;\n                     } else {\n                         // Computing 2nd power\n-                        d__1 = gopt.getEntry(i);\n-                        gqsq += d__1 * d__1;\n+                        final double d1 = gopt.getEntry(i);\n+                        gqsq += d1 * d1;\n                         gisq += sum * sum;\n                     }\n                     vlag.setEntry(npt + i, sum);\n \n             // Computing MAX\n             // Computing 2nd power\n-            d__3 = TWO * delta;\n+            final double d1 = TWO * delta;\n             // Computing 2nd power\n-            d__4 = TEN * rho;\n-            d__1 = d__3 * d__3;\n-            d__2 = d__4 * d__4;\n-            distsq = Math.max(d__1, d__2);\n+            final double d2 = TEN * rho;\n+            distsq = Math.max(d1 * d1, d2 * d2);\n         }\n         case 650: {\n             knew = -1;\n             for (int k = 0; k < npt; k++) {\n-                sum = ZERO;\n+                double sum = ZERO;\n                 for (int j = 0; j < n; j++) {\n                     // Computing 2nd power\n                     final double d1 = xpt.getEntry(k, j) - xopt.getEntry(j);\n             // current RHO are complete.\n \n             if (knew >= 0) {\n-                dist = Math.sqrt(distsq);\n+                final double dist = Math.sqrt(distsq);\n                 if (ntrits == -1) {\n                     // Computing MIN\n-                    d__1 = ONE_OVER_TEN * delta;\n-                    d__2 = HALF * dist;\n-                    delta = Math.min(d__1,d__2);\n+                    delta = Math.min(ONE_OVER_TEN * delta, HALF * dist);\n                     if (delta <= rho * 1.5) {\n                         delta = rho;\n                     }\n                 ntrits = 0;\n                 // Computing MAX\n                 // Computing MIN\n-                d__2 = ONE_OVER_TEN * dist;\n-                d__1 = Math.min(d__2, delta);\n-                adelt = Math.max(d__1, rho);\n+                final double d1 = Math.min(ONE_OVER_TEN * dist, delta);\n+                adelt = Math.max(d1, rho);\n                 dsq = adelt * adelt;\n                 state = 90; break;\n             }\n                 } else if (ratio <= TWO_HUNDRED_FIFTY) {\n                     rho = Math.sqrt(ratio) * stoppingTrustRegionRadius;\n                 } else {\n-                    rho = ONE_OVER_TEN * rho;\n+                    rho *= ONE_OVER_TEN;\n                 }\n                 delta = Math.max(delta, rho);\n                 ntrits = 0;\n                 for (int i = 0; i < n; i++) {\n                     // Computing MIN\n                     // Computing MAX\n-                    d__3 = lowerBound[i];\n-                    d__4 = xbase.getEntry(i) + xopt.getEntry(i);\n-                    d__1 = Math.max(d__3, d__4);\n-                    d__2 = upperBound[i];\n-                    currentBest.setEntry(i, Math.min(d__1, d__2));\n+                    final double d3 = lowerBound[i];\n+                    final double d4 = xbase.getEntry(i) + xopt.getEntry(i);\n+                    final double d1 = Math.max(d3, d4);\n+                    final double d2 = upperBound[i];\n+                    currentBest.setEntry(i, Math.min(d1, d2));\n                     if (xopt.getEntry(i) == sl.getEntry(i)) {\n                         currentBest.setEntry(i, lowerBound[i]);\n                     }\n         double crvmin = Double.NaN;\n \n         // Local variables\n-        int ih;\n         double ds;\n         int iu;\n         double dhd, dhs, cth, shs, sth, ssq, beta=0, sdec, blen;\n             // they can be regarded as an external subroutine.\n         }\n         case 210: {\n-            ih = 0;\n+            int ih = 0;\n             for (int j = 0; j < n; j++) {\n                 hs.setEntry(j, ZERO);\n                 for (int i = 0; i <= j; i++) {", "timestamp": 1318948453, "metainfo": ""}